{"sha": "696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NjY5MWUzYzRmMmIzYWEwMmZiZDFjYzc2ZGMyZjdlOGE0MDFkYjg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-08-01T21:16:16Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-08-03T12:08:47Z"}, "message": "audit LLVM C++ types in ArchiveWrapper and PassWrapper", "tree": {"sha": "b74e88f26e0a6d2f5d3ff114efe34fbd6b805223", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b74e88f26e0a6d2f5d3ff114efe34fbd6b805223"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8", "html_url": "https://github.com/rust-lang/rust/commit/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "81df89fc2d6ba1b55ab20b0615b8523a6e90963f", "url": "https://api.github.com/repos/rust-lang/rust/commits/81df89fc2d6ba1b55ab20b0615b8523a6e90963f", "html_url": "https://github.com/rust-lang/rust/commit/81df89fc2d6ba1b55ab20b0615b8523a6e90963f"}], "stats": {"total": 389, "additions": 275, "deletions": 114}, "files": [{"sha": "4019732221fe5aecb5760843607ca040d66d3edc", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 48, "deletions": 28, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8", "patch": "@@ -40,13 +40,9 @@ pub use self::TypeKind::*;\n pub use self::AtomicBinOp::*;\n pub use self::AtomicOrdering::*;\n pub use self::SynchronizationScope::*;\n-pub use self::FileType::*;\n pub use self::MetadataType::*;\n pub use self::AsmDialect::*;\n-pub use self::CodeGenOptLevel::*;\n pub use self::CodeGenOptSize::*;\n-pub use self::RelocMode::*;\n-pub use self::CodeGenModel::*;\n pub use self::DiagnosticKind::*;\n pub use self::CallConv::*;\n pub use self::Visibility::*;\n@@ -75,9 +71,26 @@ pub type Bool = c_uint;\n pub const True: Bool = 1 as Bool;\n pub const False: Bool = 0 as Bool;\n \n+#[repr(C)]\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum LLVMRustResult {\n+    Success = 0,\n+    Failure = 1\n+}\n+\n+impl LLVMRustResult {\n+    pub fn into_result(self) -> Result<(), ()> {\n+        match self {\n+            LLVMRustResult::Success => Ok(()),\n+            LLVMRustResult::Failure => Err(()),\n+        }\n+    }\n+}\n+\n // Consts for the LLVM CallConv type, pre-cast to usize.\n \n #[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n pub enum CallConv {\n     CCallConv = 0,\n     FastCallConv = 8,\n@@ -89,6 +102,7 @@ pub enum CallConv {\n }\n \n #[derive(Copy, Clone)]\n+#[repr(C)]\n pub enum Visibility {\n     LLVMDefaultVisibility = 0,\n     HiddenVisibility = 1,\n@@ -100,6 +114,7 @@ pub enum Visibility {\n // LinkerPrivateLinkage and LinkerPrivateWeakLinkage are not included either;\n // they've been removed in upstream LLVM commit r203866.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[repr(C)]\n pub enum Linkage {\n     ExternalLinkage = 0,\n     AvailableExternallyLinkage = 1,\n@@ -337,12 +352,12 @@ pub enum SynchronizationScope {\n     CrossThread = 1\n }\n \n-// Consts for the LLVMCodeGenFileType type (in include/llvm/c/TargetMachine.h)\n #[repr(C)]\n #[derive(Copy, Clone)]\n pub enum FileType {\n-    AssemblyFileType = 0,\n-    ObjectFileType = 1\n+    Other,\n+    AssemblyFile,\n+    ObjectFile,\n }\n \n #[derive(Copy, Clone)]\n@@ -371,10 +386,11 @@ pub enum AsmDialect {\n #[derive(Copy, Clone, PartialEq)]\n #[repr(C)]\n pub enum CodeGenOptLevel {\n-    CodeGenLevelNone = 0,\n-    CodeGenLevelLess = 1,\n-    CodeGenLevelDefault = 2,\n-    CodeGenLevelAggressive = 3,\n+    Other,\n+    None,\n+    Less,\n+    Default,\n+    Aggressive,\n }\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -388,21 +404,22 @@ pub enum CodeGenOptSize {\n #[derive(Copy, Clone, PartialEq)]\n #[repr(C)]\n pub enum RelocMode {\n-    RelocDefault = 0,\n-    RelocStatic = 1,\n-    RelocPIC = 2,\n-    RelocDynamicNoPic = 3,\n+    Default = 0,\n+    Static = 1,\n+    PIC = 2,\n+    DynamicNoPic = 3,\n }\n \n #[repr(C)]\n #[derive(Copy, Clone)]\n-pub enum CodeGenModel {\n-    CodeModelDefault = 0,\n-    CodeModelJITDefault = 1,\n-    CodeModelSmall = 2,\n-    CodeModelKernel = 3,\n-    CodeModelMedium = 4,\n-    CodeModelLarge = 5,\n+pub enum CodeModel {\n+    Other,\n+    Default,\n+    JITDefault,\n+    Small,\n+    Kernel,\n+    Medium,\n+    Large,\n }\n \n #[repr(C)]\n@@ -421,6 +438,7 @@ pub enum DiagnosticKind {\n #[repr(C)]\n #[derive(Copy, Clone)]\n pub enum ArchiveKind {\n+    Other,\n     K_GNU,\n     K_MIPS64,\n     K_BSD,\n@@ -444,10 +462,10 @@ impl FromStr for ArchiveKind {\n /// Represents the different LLVM passes Rust supports\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[repr(C)]\n-pub enum SupportedPassKind {\n+pub enum PassKind {\n+    Other,\n     Function,\n     Module,\n-    Unsupported,\n }\n \n // Opaque pointer types\n@@ -2021,7 +2039,7 @@ extern {\n     pub fn LLVMIsAAllocaInst(value_ref: ValueRef) -> ValueRef;\n     pub fn LLVMIsAConstantInt(value_ref: ValueRef) -> ValueRef;\n \n-    pub fn LLVMRustPassKind(Pass: PassRef) -> SupportedPassKind;\n+    pub fn LLVMRustPassKind(Pass: PassRef) -> PassKind;\n     pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> PassRef;\n     pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: PassRef);\n \n@@ -2031,7 +2049,7 @@ extern {\n     pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n                                        CPU: *const c_char,\n                                        Features: *const c_char,\n-                                       Model: CodeGenModel,\n+                                       Model: CodeModel,\n                                        Reloc: RelocMode,\n                                        Level: CodeGenOptLevel,\n                                        UseSoftFP: bool,\n@@ -2057,7 +2075,8 @@ extern {\n                                    PM: PassManagerRef,\n                                    M: ModuleRef,\n                                    Output: *const c_char,\n-                                   FileType: FileType) -> bool;\n+                                   FileType: FileType)\n+                                   -> LLVMRustResult;\n     pub fn LLVMRustPrintModule(PM: PassManagerRef,\n                                M: ModuleRef,\n                                Output: *const c_char);\n@@ -2123,7 +2142,8 @@ extern {\n                                 NumMembers: size_t,\n                                 Members: *const RustArchiveMemberRef,\n                                 WriteSymbtab: bool,\n-                                Kind: ArchiveKind) -> c_int;\n+                                Kind: ArchiveKind) ->\n+                                LLVMRustResult;\n     pub fn LLVMRustArchiveMemberNew(Filename: *const c_char,\n                                     Name: *const c_char,\n                                     Child: ArchiveChildRef) -> RustArchiveMemberRef;"}, {"sha": "e063209799f16b0ba4641cf4fdcb524b6473f431", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8", "patch": "@@ -293,7 +293,7 @@ impl<'a> ArchiveBuilder<'a> {\n                                                members.as_ptr(),\n                                                self.should_update_symbols,\n                                                kind);\n-            let ret = if r != 0 {\n+            let ret = if r.into_result().is_err() {\n                 let err = llvm::LLVMRustGetLastError();\n                 let msg = if err.is_null() {\n                     \"failed to write archive\".to_string()"}, {"sha": "0f3a45a7cff771d2eedda42c9213b4042e6df2d7", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8", "patch": "@@ -54,7 +54,7 @@ pub fn write_output_file(\n         let output_c = path2cstr(output);\n         let result = llvm::LLVMRustWriteOutputFile(\n                 target, pm, m, output_c.as_ptr(), file_type);\n-        if !result {\n+        if result.into_result().is_err() {\n             llvm_err(handler, format!(\"could not write output to {}\", output.display()));\n         }\n     }\n@@ -138,11 +138,11 @@ fn target_feature(sess: &Session) -> String {\n \n fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n     match optimize {\n-      config::OptLevel::No => llvm::CodeGenLevelNone,\n-      config::OptLevel::Less => llvm::CodeGenLevelLess,\n-      config::OptLevel::Default => llvm::CodeGenLevelDefault,\n-      config::OptLevel::Aggressive => llvm::CodeGenLevelAggressive,\n-      _ => llvm::CodeGenLevelDefault,\n+      config::OptLevel::No => llvm::CodeGenOptLevel::None,\n+      config::OptLevel::Less => llvm::CodeGenOptLevel::Less,\n+      config::OptLevel::Default => llvm::CodeGenOptLevel::Default,\n+      config::OptLevel::Aggressive => llvm::CodeGenOptLevel::Aggressive,\n+      _ => llvm::CodeGenOptLevel::Default,\n     }\n }\n \n@@ -169,11 +169,11 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     };\n \n     let code_model = match code_model_arg {\n-        \"default\" => llvm::CodeModelDefault,\n-        \"small\" => llvm::CodeModelSmall,\n-        \"kernel\" => llvm::CodeModelKernel,\n-        \"medium\" => llvm::CodeModelMedium,\n-        \"large\" => llvm::CodeModelLarge,\n+        \"default\" => llvm::CodeModel::Default,\n+        \"small\" => llvm::CodeModel::Small,\n+        \"kernel\" => llvm::CodeModel::Kernel,\n+        \"medium\" => llvm::CodeModel::Medium,\n+        \"large\" => llvm::CodeModel::Large,\n         _ => {\n             sess.err(&format!(\"{:?} is not a valid code model\",\n                              sess.opts\n@@ -449,9 +449,9 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                 return false;\n             }\n             let pass_manager = match llvm::LLVMRustPassKind(pass) {\n-                llvm::SupportedPassKind::Function => fpm,\n-                llvm::SupportedPassKind::Module => mpm,\n-                llvm::SupportedPassKind::Unsupported => {\n+                llvm::PassKind::Function => fpm,\n+                llvm::PassKind::Module => mpm,\n+                llvm::PassKind::Other => {\n                     cgcx.handler.err(\"Encountered LLVM pass kind we can't handle\");\n                     return true\n                 },\n@@ -579,7 +579,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             };\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path,\n-                                  llvm::AssemblyFileType);\n+                                  llvm::FileType::AssemblyFile);\n             });\n             if config.emit_obj {\n                 llvm::LLVMDisposeModule(llmod);\n@@ -588,7 +588,8 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n         if write_obj {\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(cgcx.handler, tm, cpm, llmod, &obj_out, llvm::ObjectFileType);\n+                write_output_file(cgcx.handler, tm, cpm, llmod, &obj_out,\n+                                  llvm::FileType::ObjectFile);\n             });\n         }\n     });\n@@ -1078,7 +1079,7 @@ pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n     // reasonable defaults and prepare it to actually populate the pass\n     // manager.\n     let builder = llvm::LLVMPassManagerBuilderCreate();\n-    let opt_level = config.opt_level.unwrap_or(llvm::CodeGenLevelNone);\n+    let opt_level = config.opt_level.unwrap_or(llvm::CodeGenOptLevel::None);\n     let opt_size = config.opt_size.unwrap_or(llvm::CodeGenOptSizeNone);\n     let inline_threshold = config.inline_threshold;\n \n@@ -1102,7 +1103,7 @@ pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n         (_, _, Some(t)) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, t as u32);\n         }\n-        (llvm::CodeGenLevelAggressive, _, _) => {\n+        (llvm::CodeGenOptLevel::Aggressive, _, _) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 275);\n         }\n         (_, llvm::CodeGenOptSizeDefault, _) => {\n@@ -1111,15 +1112,18 @@ pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n         (_, llvm::CodeGenOptSizeAggressive, _) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 25);\n         }\n-        (llvm::CodeGenLevelNone, _, _) => {\n+        (llvm::CodeGenOptLevel::None, _, _) => {\n             llvm::LLVMRustAddAlwaysInlinePass(builder, false);\n         }\n-        (llvm::CodeGenLevelLess, _, _) => {\n+        (llvm::CodeGenOptLevel::Less, _, _) => {\n             llvm::LLVMRustAddAlwaysInlinePass(builder, true);\n         }\n-        (llvm::CodeGenLevelDefault, _, _) => {\n+        (llvm::CodeGenOptLevel::Default, _, _) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 225);\n         }\n+        (llvm::CodeGenOptLevel::Other, _, _) => {\n+            bug!(\"CodeGenOptLevel::Other selected\")\n+        }\n     }\n \n     f(builder);"}, {"sha": "166ce990fddfa72303618ca5d0aea7cad9c20dee", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8", "patch": "@@ -325,10 +325,10 @@ pub fn get_reloc_model(sess: &Session) -> llvm::RelocMode {\n     };\n \n     match reloc_model_arg {\n-        \"pic\" => llvm::RelocPIC,\n-        \"static\" => llvm::RelocStatic,\n-        \"default\" => llvm::RelocDefault,\n-        \"dynamic-no-pic\" => llvm::RelocDynamicNoPic,\n+        \"pic\" => llvm::RelocMode::PIC,\n+        \"static\" => llvm::RelocMode::Static,\n+        \"default\" => llvm::RelocMode::Default,\n+        \"dynamic-no-pic\" => llvm::RelocMode::DynamicNoPic,\n         _ => {\n             sess.err(&format!(\"{:?} is not a valid relocation mode\",\n                              sess.opts\n@@ -347,7 +347,7 @@ fn is_any_library(sess: &Session) -> bool {\n }\n \n pub fn is_pie_binary(sess: &Session) -> bool {\n-    !is_any_library(sess) && get_reloc_model(sess) == llvm::RelocPIC\n+    !is_any_library(sess) && get_reloc_model(sess) == llvm::RelocMode::PIC\n }\n \n unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {"}, {"sha": "059cc40d51144338b3e57d68e58df25c63cfc6a4", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 65, "deletions": 33, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8", "patch": "@@ -16,24 +16,62 @@\n using namespace llvm;\n using namespace llvm::object;\n \n-struct LLVMRustArchiveMember {\n+struct RustArchiveMember {\n   const char *filename;\n   const char *name;\n   Archive::Child child;\n \n-  LLVMRustArchiveMember(): filename(NULL), name(NULL),\n+  RustArchiveMember(): filename(NULL), name(NULL),\n #if LLVM_VERSION_MINOR >= 8\n     child(NULL, NULL, NULL)\n #else\n     child(NULL, NULL)\n #endif\n   {}\n-  ~LLVMRustArchiveMember() {}\n+  ~RustArchiveMember() {}\n };\n \n-typedef OwningBinary<Archive> RustArchive;\n \n-extern \"C\" void*\n+struct RustArchiveIterator {\n+    Archive::child_iterator cur;\n+    Archive::child_iterator end;\n+#if LLVM_VERSION_MINOR >= 9\n+    Error err;\n+#endif\n+};\n+\n+enum class LLVMRustArchiveKind {\n+    Other,\n+    GNU,\n+    MIPS64,\n+    BSD,\n+    COFF,\n+};\n+\n+static Archive::Kind\n+from_rust(LLVMRustArchiveKind kind)\n+{\n+    switch (kind) {\n+    case LLVMRustArchiveKind::GNU:\n+        return Archive::K_GNU;\n+    case LLVMRustArchiveKind::MIPS64:\n+        return Archive::K_MIPS64;\n+    case LLVMRustArchiveKind::BSD:\n+        return Archive::K_BSD;\n+    case LLVMRustArchiveKind::COFF:\n+        return Archive::K_COFF;\n+    default:\n+        abort();\n+  }\n+}\n+\n+typedef OwningBinary<Archive> *LLVMRustArchiveRef;\n+typedef RustArchiveMember *LLVMRustArchiveMemberRef;\n+typedef Archive::Child *LLVMRustArchiveChildRef;\n+typedef Archive::Child const *LLVMRustArchiveChildConstRef;\n+typedef RustArchiveIterator *LLVMRustArchiveIteratorRef;\n+\n+extern \"C\" LLVMRustArchiveRef\n LLVMRustOpenArchive(char *path) {\n     ErrorOr<std::unique_ptr<MemoryBuffer>> buf_or = MemoryBuffer::getFile(path,\n                                                                           -1,\n@@ -66,20 +104,12 @@ LLVMRustOpenArchive(char *path) {\n }\n \n extern \"C\" void\n-LLVMRustDestroyArchive(RustArchive *ar) {\n+LLVMRustDestroyArchive(LLVMRustArchiveRef ar) {\n     delete ar;\n }\n \n-struct RustArchiveIterator {\n-    Archive::child_iterator cur;\n-    Archive::child_iterator end;\n-#if LLVM_VERSION_MINOR >= 9\n-    Error err;\n-#endif\n-};\n-\n-extern \"C\" RustArchiveIterator*\n-LLVMRustArchiveIteratorNew(RustArchive *ra) {\n+extern \"C\" LLVMRustArchiveIteratorRef\n+LLVMRustArchiveIteratorNew(LLVMRustArchiveRef ra) {\n     Archive *ar = ra->getBinary();\n     RustArchiveIterator *rai = new RustArchiveIterator();\n #if LLVM_VERSION_MINOR <= 8\n@@ -95,8 +125,8 @@ LLVMRustArchiveIteratorNew(RustArchive *ra) {\n     return rai;\n }\n \n-extern \"C\" const Archive::Child*\n-LLVMRustArchiveIteratorNext(RustArchiveIterator *rai) {\n+extern \"C\" LLVMRustArchiveChildConstRef\n+LLVMRustArchiveIteratorNext(LLVMRustArchiveIteratorRef rai) {\n #if LLVM_VERSION_MINOR >= 9\n     if (rai->err) {\n         LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n@@ -122,17 +152,17 @@ LLVMRustArchiveIteratorNext(RustArchiveIterator *rai) {\n }\n \n extern \"C\" void\n-LLVMRustArchiveChildFree(Archive::Child *child) {\n+LLVMRustArchiveChildFree(LLVMRustArchiveChildRef child) {\n     delete child;\n }\n \n extern \"C\" void\n-LLVMRustArchiveIteratorFree(RustArchiveIterator *rai) {\n+LLVMRustArchiveIteratorFree(LLVMRustArchiveIteratorRef rai) {\n     delete rai;\n }\n \n extern \"C\" const char*\n-LLVMRustArchiveChildName(const Archive::Child *child, size_t *size) {\n+LLVMRustArchiveChildName(LLVMRustArchiveChildConstRef child, size_t *size) {\n     ErrorOr<StringRef> name_or_err = child->getName();\n     if (name_or_err.getError())\n         return NULL;\n@@ -142,7 +172,7 @@ LLVMRustArchiveChildName(const Archive::Child *child, size_t *size) {\n }\n \n extern \"C\" const char*\n-LLVMRustArchiveChildData(Archive::Child *child, size_t *size) {\n+LLVMRustArchiveChildData(LLVMRustArchiveChildRef child, size_t *size) {\n     StringRef buf;\n     ErrorOr<StringRef> buf_or_err = child->getBuffer();\n     if (buf_or_err.getError()) {\n@@ -154,9 +184,10 @@ LLVMRustArchiveChildData(Archive::Child *child, size_t *size) {\n     return buf.data();\n }\n \n-extern \"C\" LLVMRustArchiveMember*\n-LLVMRustArchiveMemberNew(char *Filename, char *Name, Archive::Child *child) {\n-    LLVMRustArchiveMember *Member = new LLVMRustArchiveMember;\n+extern \"C\" LLVMRustArchiveMemberRef\n+LLVMRustArchiveMemberNew(char *Filename, char *Name,\n+\t\t\t LLVMRustArchiveChildRef child) {\n+    RustArchiveMember *Member = new RustArchiveMember;\n     Member->filename = Filename;\n     Member->name = Name;\n     if (child)\n@@ -165,22 +196,23 @@ LLVMRustArchiveMemberNew(char *Filename, char *Name, Archive::Child *child) {\n }\n \n extern \"C\" void\n-LLVMRustArchiveMemberFree(LLVMRustArchiveMember *Member) {\n+LLVMRustArchiveMemberFree(LLVMRustArchiveMemberRef Member) {\n     delete Member;\n }\n \n-extern \"C\" int\n+extern \"C\" LLVMRustResult\n LLVMRustWriteArchive(char *Dst,\n                      size_t NumMembers,\n-                     const LLVMRustArchiveMember **NewMembers,\n+                     const LLVMRustArchiveMemberRef *NewMembers,\n                      bool WriteSymbtab,\n-                     Archive::Kind Kind) {\n+                     LLVMRustArchiveKind rust_kind) {\n \n #if LLVM_VERSION_MINOR <= 8\n   std::vector<NewArchiveIterator> Members;\n #else\n   std::vector<NewArchiveMember> Members;\n #endif\n+  auto Kind = from_rust(rust_kind);\n \n   for (size_t i = 0; i < NumMembers; i++) {\n     auto Member = NewMembers[i];\n@@ -190,7 +222,7 @@ LLVMRustWriteArchive(char *Dst,\n       Expected<NewArchiveMember> MOrErr = NewArchiveMember::getFile(Member->filename, true);\n       if (!MOrErr) {\n         LLVMRustSetLastError(toString(MOrErr.takeError()).c_str());\n-        return -1;\n+        return LLVMRustResult::Failure;\n       }\n       Members.push_back(std::move(*MOrErr));\n #elif LLVM_VERSION_MINOR == 8\n@@ -205,7 +237,7 @@ LLVMRustWriteArchive(char *Dst,\n       Expected<NewArchiveMember> MOrErr = NewArchiveMember::getOldMember(Member->child, true);\n       if (!MOrErr) {\n         LLVMRustSetLastError(toString(MOrErr.takeError()).c_str());\n-        return -1;\n+        return LLVMRustResult::Failure;\n       }\n       Members.push_back(std::move(*MOrErr));\n #endif\n@@ -217,7 +249,7 @@ LLVMRustWriteArchive(char *Dst,\n   auto pair = writeArchive(Dst, Members, WriteSymbtab, Kind, true);\n #endif\n   if (!pair.second)\n-    return 0;\n+    return LLVMRustResult::Success;\n   LLVMRustSetLastError(pair.second.message().c_str());\n-  return -1;\n+  return LLVMRustResult::Failure;\n }"}, {"sha": "9e72724d8ab780950fb1ee0d4eaeab7d95ee8a0f", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 112, "deletions": 26, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8", "patch": "@@ -54,41 +54,48 @@ LLVMInitializePasses() {\n   initializeTarget(Registry);\n }\n \n-\n-enum class SupportedPassKind {\n+enum class LLVMRustPassKind {\n+  Other,\n   Function,\n   Module,\n-  Unsupported\n };\n \n-extern \"C\" Pass*\n+static LLVMRustPassKind\n+to_rust(PassKind kind)\n+{\n+  switch (kind) {\n+  case PT_Function:\n+      return LLVMRustPassKind::Function;\n+  case PT_Module:\n+      return LLVMRustPassKind::Module;\n+  default:\n+      return LLVMRustPassKind::Other;\n+  }\n+}\n+\n+extern \"C\" LLVMPassRef\n LLVMRustFindAndCreatePass(const char *PassName) {\n     StringRef SR(PassName);\n     PassRegistry *PR = PassRegistry::getPassRegistry();\n \n     const PassInfo *PI = PR->getPassInfo(SR);\n     if (PI) {\n-        return PI->createPass();\n+      return wrap(PI->createPass());\n     }\n     return NULL;\n }\n \n-extern \"C\" SupportedPassKind\n-LLVMRustPassKind(Pass *pass) {\n-    assert(pass);\n-    PassKind passKind = pass->getPassKind();\n-    if (passKind == PT_Module) {\n-        return SupportedPassKind::Module;\n-    } else if (passKind == PT_Function) {\n-        return SupportedPassKind::Function;\n-    } else {\n-        return SupportedPassKind::Unsupported;\n-    }\n+extern \"C\" LLVMRustPassKind\n+LLVMRustPassKind(LLVMPassRef rust_pass) {\n+    assert(rust_pass);\n+    Pass *pass = unwrap(rust_pass);\n+    return to_rust(pass->getPassKind());\n }\n \n extern \"C\" void\n-LLVMRustAddPass(LLVMPassManagerRef PM, Pass *pass) {\n-    assert(pass);\n+LLVMRustAddPass(LLVMPassManagerRef PM, LLVMPassRef rust_pass) {\n+    assert(rust_pass);\n+    Pass *pass = unwrap(rust_pass);\n     PassManagerBase *pm = unwrap(PM);\n     pm->add(pass);\n }\n@@ -162,13 +169,69 @@ LLVMRustHasFeature(LLVMTargetMachineRef TM,\n     return (Bits & FeatureEntry->Value) == FeatureEntry->Value;\n }\n \n+enum class LLVMRustCodeModel {\n+    Other,\n+    Default,\n+    JITDefault,\n+    Small,\n+    Kernel,\n+    Medium,\n+    Large,\n+};\n+\n+static CodeModel::Model\n+from_rust(LLVMRustCodeModel model)\n+{\n+    switch (model) {\n+    case LLVMRustCodeModel::Default:\n+        return CodeModel::Default;\n+    case LLVMRustCodeModel::JITDefault:\n+        return CodeModel::JITDefault;\n+    case LLVMRustCodeModel::Small:\n+        return CodeModel::Small;\n+    case LLVMRustCodeModel::Kernel:\n+        return CodeModel::Kernel;\n+    case LLVMRustCodeModel::Medium:\n+        return CodeModel::Medium;\n+    case LLVMRustCodeModel::Large:\n+        return CodeModel::Large;\n+    default:\n+        abort();\n+  }\n+}\n+\n+enum class LLVMRustCodeGenOptLevel {\n+    Other,\n+    None,\n+    Less,\n+    Default,\n+    Aggressive,\n+};\n+\n+static CodeGenOpt::Level\n+from_rust(LLVMRustCodeGenOptLevel level)\n+{\n+    switch (level) {\n+    case LLVMRustCodeGenOptLevel::None:\n+        return CodeGenOpt::None;\n+    case LLVMRustCodeGenOptLevel::Less:\n+        return CodeGenOpt::Less;\n+    case LLVMRustCodeGenOptLevel::Default:\n+        return CodeGenOpt::Default;\n+    case LLVMRustCodeGenOptLevel::Aggressive:\n+        return CodeGenOpt::Aggressive;\n+    default:\n+        abort();\n+  }\n+}\n+\n extern \"C\" LLVMTargetMachineRef\n LLVMRustCreateTargetMachine(const char *triple,\n                             const char *cpu,\n                             const char *feature,\n-                            CodeModel::Model CM,\n+                            LLVMRustCodeModel rust_CM,\n                             LLVMRelocMode Reloc,\n-                            CodeGenOpt::Level OptLevel,\n+                            LLVMRustCodeGenOptLevel rust_OptLevel,\n                             bool UseSoftFloat,\n                             bool PositionIndependentExecutable,\n                             bool FunctionSections,\n@@ -179,6 +242,9 @@ LLVMRustCreateTargetMachine(const char *triple,\n #else\n     Optional<Reloc::Model> RM;\n #endif\n+    auto CM = from_rust(rust_CM);\n+    auto OptLevel = from_rust(rust_OptLevel);\n+\n     switch (Reloc){\n         case LLVMRelocStatic:\n             RM = Reloc::Static;\n@@ -251,14 +317,14 @@ LLVMRustAddAnalysisPasses(LLVMTargetMachineRef TM,\n \n extern \"C\" void\n LLVMRustConfigurePassManagerBuilder(LLVMPassManagerBuilderRef PMB,\n-                                    CodeGenOpt::Level OptLevel,\n+\t\t\t\t    LLVMRustCodeGenOptLevel OptLevel,\n                                     bool MergeFunctions,\n                                     bool SLPVectorize,\n                                     bool LoopVectorize) {\n     // Ignore mergefunc for now as enabling it causes crashes.\n     //unwrap(PMB)->MergeFunctions = MergeFunctions;\n     unwrap(PMB)->SLPVectorize = SLPVectorize;\n-    unwrap(PMB)->OptLevel = OptLevel;\n+    unwrap(PMB)->OptLevel = from_rust(OptLevel);\n     unwrap(PMB)->LoopVectorize = LoopVectorize;\n }\n \n@@ -314,13 +380,33 @@ LLVMRustSetLLVMOptions(int Argc, char **Argv) {\n     cl::ParseCommandLineOptions(Argc, Argv);\n }\n \n-extern \"C\" bool\n+enum class LLVMRustFileType {\n+    Other,\n+    AssemblyFile,\n+    ObjectFile,\n+};\n+\n+static TargetMachine::CodeGenFileType\n+from_rust(LLVMRustFileType type)\n+{\n+    switch (type) {\n+    case LLVMRustFileType::AssemblyFile:\n+        return TargetMachine::CGFT_AssemblyFile;\n+    case LLVMRustFileType::ObjectFile:\n+        return TargetMachine::CGFT_ObjectFile;\n+    default:\n+        abort();\n+  }\n+}\n+\n+extern \"C\" LLVMRustResult\n LLVMRustWriteOutputFile(LLVMTargetMachineRef Target,\n                         LLVMPassManagerRef PMR,\n                         LLVMModuleRef M,\n                         const char *path,\n-                        TargetMachine::CodeGenFileType FileType) {\n+                        LLVMRustFileType rust_FileType) {\n   llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n+  auto FileType = from_rust(rust_FileType);\n \n   std::string ErrorInfo;\n   std::error_code EC;\n@@ -329,7 +415,7 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target,\n     ErrorInfo = EC.message();\n   if (ErrorInfo != \"\") {\n     LLVMRustSetLastError(ErrorInfo.c_str());\n-    return false;\n+    return LLVMRustResult::Failure;\n   }\n \n   unwrap(Target)->addPassesToEmitFile(*PM, OS, FileType, false);\n@@ -339,7 +425,7 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target,\n   // stream (OS), so the only real safe place to delete this is here? Don't we\n   // wish this was written in Rust?\n   delete PM;\n-  return true;\n+  return LLVMRustResult::Success;\n }\n \n extern \"C\" void"}, {"sha": "e1c6dd07d2b3856a5a2050a8551474123f7a56c3", "filename": "src/rustllvm/README", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Frustllvm%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Frustllvm%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FREADME?ref=696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8", "patch": "@@ -1,2 +1,16 @@\n This directory currently contains some LLVM support code. This will generally\n be sent upstream to LLVM in time; for now it lives here.\n+\n+NOTE: the LLVM C++ ABI is subject to between-version breakage and must *never*\n+be exposed to Rust. To allow for easy auditing of that, all Rust-exposed types\n+must be typedef-ed as \"LLVMXyz\", or \"LLVMRustXyz\" if they were defined here.\n+\n+Functions that return a failure status and leave the error in\n+the LLVM last error should return an LLVMRustResult rather than an\n+int or anything to avoid confusion.\n+\n+When translating enums, add a single `Other` variant as the first\n+one to allow for new variants to be added. It should abort when used\n+as an input.\n+\n+All other types must not be typedef-ed as such."}, {"sha": "5aae11fb456b6d9ce0abb96efcf587c9fbfec24f", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=696691e3c4f2b3aa02fbd1cc76dc2f7e8a401db8", "patch": "@@ -58,6 +58,11 @@\n \n void LLVMRustSetLastError(const char*);\n \n+enum class LLVMRustResult {\n+    Success,\n+    Failure\n+};\n+\n typedef struct OpaqueRustString *RustStringRef;\n typedef struct LLVMOpaqueTwine *LLVMTwineRef;\n typedef struct LLVMOpaqueDebugLoc *LLVMDebugLocRef;"}]}