{"sha": "8a3267672c43e7cc116e588dd21998d14fc21ba4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMzI2NzY3MmM0M2U3Y2MxMTZlNTg4ZGQyMTk5OGQxNGZjMjFiYTQ=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-06T03:42:45Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-06T05:26:04Z"}, "message": "deque: Move the shorter part when growing\n\nThe deque is split at the marker lo, or logical index 0. Move the\nshortest part (split by lo) when growing. This way add_front is just as\nfast as add_back, on average.", "tree": {"sha": "e2847b0d0a7a3d69f1ebb0323058c521931dba44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2847b0d0a7a3d69f1ebb0323058c521931dba44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a3267672c43e7cc116e588dd21998d14fc21ba4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a3267672c43e7cc116e588dd21998d14fc21ba4", "html_url": "https://github.com/rust-lang/rust/commit/8a3267672c43e7cc116e588dd21998d14fc21ba4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a3267672c43e7cc116e588dd21998d14fc21ba4/comments", "author": null, "committer": null, "parents": [{"sha": "75015c36f9fa6d0958874c1a448d6d67056145ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/75015c36f9fa6d0958874c1a448d6d67056145ae", "html_url": "https://github.com/rust-lang/rust/commit/75015c36f9fa6d0958874c1a448d6d67056145ae"}], "stats": {"total": 32, "additions": 25, "deletions": 7}, "files": [{"sha": "3dfc90002d3c7d286a7d4b534eeca480a5621a79", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8a3267672c43e7cc116e588dd21998d14fc21ba4/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3267672c43e7cc116e588dd21998d14fc21ba4/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=8a3267672c43e7cc116e588dd21998d14fc21ba4", "patch": "@@ -108,7 +108,7 @@ impl<T> Deque<T> {\n     /// Prepend an element to the deque\n     pub fn add_front(&mut self, t: T) {\n         if self.nelts == self.elts.len() {\n-            grow(self.nelts, self.lo, &mut self.elts);\n+            grow(self.nelts, &mut self.lo, &mut self.elts);\n         }\n         if self.lo == 0u {\n             self.lo = self.elts.len() - 1u;\n@@ -120,7 +120,7 @@ impl<T> Deque<T> {\n     /// Append an element to the deque\n     pub fn add_back(&mut self, t: T) {\n         if self.nelts == self.elts.len() {\n-            grow(self.nelts, self.lo, &mut self.elts);\n+            grow(self.nelts, &mut self.lo, &mut self.elts);\n         }\n         let hi = self.raw_index(self.nelts);\n         self.elts[hi] = Some(t);\n@@ -230,18 +230,36 @@ iterator!{impl DequeMutRevIterator -> &'self mut T, get_mut_ref, -1}\n \n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere.\n-fn grow<T>(nelts: uint, lo: uint, elts: &mut ~[Option<T>]) {\n+fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut ~[Option<T>]) {\n     assert_eq!(nelts, elts.len());\n-    let newlen = elts.capacity() * 2;\n+    let lo = *loptr;\n+    let newlen = nelts * 2;\n     elts.reserve(newlen);\n \n     /* fill with None */\n     for uint::range(elts.len(), elts.capacity()) |_| {\n         elts.push(None);\n     }\n-    /* move the former wraparound to the new half */\n-    for uint::range(0, lo) |i| {\n-        elts.swap(i, nelts + i);\n+\n+    /*\n+      Move the shortest half into the newly reserved area.\n+      lo ---->|\n+      nelts ----------->|\n+        [o o o|o o o o o]\n+      A [. . .|o o o o o o o o|. . . . .]\n+      B [o o o|. . . . . . . .|o o o o o]\n+     */\n+\n+    assert!(newlen - nelts/2 >= nelts);\n+    if lo <= (nelts - lo) { // A\n+        for uint::range(0, lo) |i| {\n+            elts.swap(i, nelts + i);\n+        }\n+    } else {                // B\n+        for uint::range(lo, nelts) |i| {\n+            elts.swap(i, newlen - nelts + i);\n+        }\n+        *loptr += newlen - nelts;\n     }\n }\n "}]}