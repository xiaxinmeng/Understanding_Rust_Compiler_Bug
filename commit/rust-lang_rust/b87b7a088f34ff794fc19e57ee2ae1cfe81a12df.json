{"sha": "b87b7a088f34ff794fc19e57ee2ae1cfe81a12df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4N2I3YTA4OGYzNGZmNzk0ZmMxOWU1N2VlMmFlMWNmZTgxYTEyZGY=", "commit": {"author": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-04-05T01:02:27Z"}, "committer": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-04-07T12:12:08Z"}, "message": "remove panics", "tree": {"sha": "dcfd92910610f457a6ae598068c847bcd49867cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcfd92910610f457a6ae598068c847bcd49867cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b87b7a088f34ff794fc19e57ee2ae1cfe81a12df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b87b7a088f34ff794fc19e57ee2ae1cfe81a12df", "html_url": "https://github.com/rust-lang/rust/commit/b87b7a088f34ff794fc19e57ee2ae1cfe81a12df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b87b7a088f34ff794fc19e57ee2ae1cfe81a12df/comments", "author": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "html_url": "https://github.com/rust-lang/rust/commit/8c378af72117e92bc894fd4a79e978ef0d1c0cc7"}], "stats": {"total": 280, "additions": 214, "deletions": 66}, "files": [{"sha": "de291c1f60745fecf56d4314a0cd50fd3ad4c6bb", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 209, "deletions": 64, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/b87b7a088f34ff794fc19e57ee2ae1cfe81a12df/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87b7a088f34ff794fc19e57ee2ae1cfe81a12df/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=b87b7a088f34ff794fc19e57ee2ae1cfe81a12df", "patch": "@@ -42,6 +42,10 @@ impl From<PatId> for PatIdOrWild {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq)]\n+pub struct MatchCheckNotImplemented;\n+pub type MatchCheckResult<T> = Result<T, MatchCheckNotImplemented>;\n+\n type PatStackInner = SmallVec<[PatIdOrWild; 2]>;\n #[derive(Debug)]\n pub(crate) struct PatStack(PatStackInner);\n@@ -104,42 +108,49 @@ impl PatStack {\n         &self,\n         cx: &MatchCheckCtx,\n         constructor: &Constructor,\n-    ) -> Option<PatStack> {\n-        match (self.head().as_pat(cx), constructor) {\n+    ) -> MatchCheckResult<Option<PatStack>> {\n+        let result = match (self.head().as_pat(cx), constructor) {\n             (Pat::Tuple(ref pat_ids), Constructor::Tuple { arity }) => {\n                 if pat_ids.len() != *arity {\n-                    return None;\n+                    None\n+                } else {\n+                    Some(self.replace_head_with(pat_ids))\n                 }\n-\n-                Some(self.replace_head_with(pat_ids))\n             }\n             (Pat::Lit(_), Constructor::Bool(_)) => {\n                 // for now we only support bool literals\n                 Some(self.to_tail())\n             }\n-            (Pat::Wild, constructor) => Some(self.expand_wildcard(cx, constructor)),\n+            (Pat::Wild, constructor) => Some(self.expand_wildcard(cx, constructor)?),\n             (Pat::Path(_), Constructor::Enum(constructor)) => {\n+                // enums with no associated data become `Pat::Path`\n                 let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n                 if !enum_variant_matches(cx, pat_id, *constructor) {\n-                    return None;\n+                    None\n+                } else {\n+                    Some(self.to_tail())\n                 }\n-                // enums with no associated data become `Pat::Path`\n-                Some(self.to_tail())\n             }\n             (Pat::TupleStruct { args: ref pat_ids, .. }, Constructor::Enum(constructor)) => {\n                 let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n                 if !enum_variant_matches(cx, pat_id, *constructor) {\n-                    return None;\n+                    None\n+                } else {\n+                    Some(self.replace_head_with(pat_ids))\n                 }\n-\n-                Some(self.replace_head_with(pat_ids))\n             }\n             (Pat::Or(_), _) => unreachable!(\"we desugar or patterns so this should never happen\"),\n-            (a, b) => unimplemented!(\"{:?}, {:?}\", a, b),\n-        }\n+            (_, _) => return Err(MatchCheckNotImplemented),\n+        };\n+\n+        Ok(result)\n     }\n \n-    fn expand_wildcard(&self, cx: &MatchCheckCtx, constructor: &Constructor) -> PatStack {\n+    fn expand_wildcard(\n+        &self,\n+        cx: &MatchCheckCtx,\n+        constructor: &Constructor,\n+    ) -> MatchCheckResult<PatStack> {\n         assert_eq!(\n             Pat::Wild,\n             self.head().as_pat(cx),\n@@ -154,7 +165,7 @@ impl PatStack {\n                 match cx.db.enum_data(e.parent).variants[e.local_id].variant_data.as_ref() {\n                     VariantData::Tuple(struct_field_data) => struct_field_data.len(),\n                     VariantData::Unit => 0,\n-                    x => unimplemented!(\"{:?}\", x),\n+                    _ => return Err(MatchCheckNotImplemented),\n                 }\n             }\n         };\n@@ -167,7 +178,7 @@ impl PatStack {\n             patterns.push(*pat);\n         }\n \n-        PatStack::from_vec(patterns)\n+        Ok(PatStack::from_vec(patterns))\n     }\n }\n \n@@ -204,8 +215,19 @@ impl Matrix {\n     }\n \n     // Computes `S(constructor, self)`.\n-    fn specialize_constructor(&self, cx: &MatchCheckCtx, constructor: &Constructor) -> Self {\n-        Self::collect(cx, self.0.iter().filter_map(|r| r.specialize_constructor(cx, constructor)))\n+    fn specialize_constructor(\n+        &self,\n+        cx: &MatchCheckCtx,\n+        constructor: &Constructor,\n+    ) -> MatchCheckResult<Self> {\n+        let mut new_matrix = Matrix::empty();\n+        for pat in &self.0 {\n+            if let Some(pat) = pat.specialize_constructor(cx, constructor)? {\n+                new_matrix.push(cx, pat);\n+            }\n+        }\n+\n+        Ok(new_matrix)\n     }\n \n     fn collect<T: IntoIterator<Item = PatStack>>(cx: &MatchCheckCtx, iter: T) -> Self {\n@@ -239,37 +261,56 @@ pub struct MatchCheckCtx<'a> {\n // don't think we can make that assumption here. How should that be handled?\n //\n // Perhaps check that validity before passing the patterns into this method?\n-pub(crate) fn is_useful(cx: &MatchCheckCtx, matrix: &Matrix, v: &PatStack) -> Usefulness {\n-    dbg!(matrix);\n-    dbg!(v);\n+pub(crate) fn is_useful(\n+    cx: &MatchCheckCtx,\n+    matrix: &Matrix,\n+    v: &PatStack,\n+) -> MatchCheckResult<Usefulness> {\n     if v.is_empty() {\n-        if matrix.is_empty() {\n-            return Usefulness::Useful;\n-        } else {\n-            return Usefulness::NotUseful;\n-        }\n+        let result = if matrix.is_empty() { Usefulness::Useful } else { Usefulness::NotUseful };\n+\n+        return Ok(result);\n     }\n \n     if let Pat::Or(pat_ids) = v.head().as_pat(cx) {\n+        let mut found_unimplemented = false;\n         let any_useful = pat_ids.iter().any(|&pat_id| {\n             let v = PatStack::from_pattern(pat_id);\n \n-            is_useful(cx, matrix, &v) == Usefulness::Useful\n+            match is_useful(cx, matrix, &v) {\n+                Ok(Usefulness::Useful) => true,\n+                Ok(Usefulness::NotUseful) => false,\n+                _ => {\n+                    found_unimplemented = true;\n+                    false\n+                }\n+            }\n         });\n \n-        return if any_useful { Usefulness::Useful } else { Usefulness::NotUseful };\n+        return if any_useful {\n+            Ok(Usefulness::Useful)\n+        } else if found_unimplemented {\n+            Err(MatchCheckNotImplemented)\n+        } else {\n+            Ok(Usefulness::NotUseful)\n+        };\n     }\n \n-    if let Some(constructor) = pat_constructor(cx, v.head()) {\n-        let matrix = matrix.specialize_constructor(&cx, &constructor);\n-        let v = v.specialize_constructor(&cx, &constructor).expect(\"todo handle this case\");\n+    if let Some(constructor) = pat_constructor(cx, v.head())? {\n+        let matrix = matrix.specialize_constructor(&cx, &constructor)?;\n+        let v = v\n+            .specialize_constructor(&cx, &constructor)?\n+            .expect(\"we know this can't fail because we get the constructor from `v.head()` above\");\n \n         is_useful(&cx, &matrix, &v)\n     } else {\n-        dbg!(\"expanding wildcard\");\n         // expanding wildcard\n-        let used_constructors: Vec<Constructor> =\n-            matrix.heads().iter().filter_map(|&p| pat_constructor(cx, p)).collect();\n+        let mut used_constructors: Vec<Constructor> = vec![];\n+        for pat in matrix.heads() {\n+            if let Some(constructor) = pat_constructor(cx, pat)? {\n+                used_constructors.push(constructor);\n+            }\n+        }\n \n         // We assume here that the first constructor is the \"correct\" type. Since we\n         // only care about the \"type\" of the constructor (i.e. if it is a bool we\n@@ -278,51 +319,55 @@ pub(crate) fn is_useful(cx: &MatchCheckCtx, matrix: &Matrix, v: &PatStack) -> Us\n         // this is to use the match expressions type.\n         match &used_constructors.first() {\n             Some(constructor) if all_constructors_covered(&cx, constructor, &used_constructors) => {\n-                dbg!(\"all constructors are covered\");\n                 // If all constructors are covered, then we need to consider whether\n                 // any values are covered by this wildcard.\n                 //\n                 // For example, with matrix '[[Some(true)], [None]]', all\n                 // constructors are covered (`Some`/`None`), so we need\n                 // to perform specialization to see that our wildcard will cover\n                 // the `Some(false)` case.\n-                let constructor =\n-                    matrix.heads().iter().filter_map(|&pat| pat_constructor(cx, pat)).next();\n+                let mut constructor = None;\n+                for pat in matrix.heads() {\n+                    if let Some(c) = pat_constructor(cx, pat)? {\n+                        constructor = Some(c);\n+                        break;\n+                    }\n+                }\n \n                 if let Some(constructor) = constructor {\n-                    dbg!(\"found constructor {:?}, specializing..\", &constructor);\n                     if let Constructor::Enum(e) = constructor {\n                         // For enums we handle each variant as a distinct constructor, so\n                         // here we create a constructor for each variant and then check\n                         // usefulness after specializing for that constructor.\n-                        let any_useful = cx\n-                            .db\n-                            .enum_data(e.parent)\n-                            .variants\n-                            .iter()\n-                            .map(|(local_id, _)| {\n+                        let mut found_unimplemented = false;\n+                        for constructor in\n+                            cx.db.enum_data(e.parent).variants.iter().map(|(local_id, _)| {\n                                 Constructor::Enum(EnumVariantId { parent: e.parent, local_id })\n                             })\n-                            .any(|constructor| {\n-                                let matrix = matrix.specialize_constructor(&cx, &constructor);\n-                                let v = v.expand_wildcard(&cx, &constructor);\n-\n-                                is_useful(&cx, &matrix, &v) == Usefulness::Useful\n-                            });\n+                        {\n+                            let matrix = matrix.specialize_constructor(&cx, &constructor)?;\n+                            let v = v.expand_wildcard(&cx, &constructor)?;\n+\n+                            match is_useful(&cx, &matrix, &v) {\n+                                Ok(Usefulness::Useful) => return Ok(Usefulness::Useful),\n+                                Ok(Usefulness::NotUseful) => continue,\n+                                _ => found_unimplemented = true,\n+                            };\n+                        }\n \n-                        if any_useful {\n-                            Usefulness::Useful\n+                        if found_unimplemented {\n+                            Err(MatchCheckNotImplemented)\n                         } else {\n-                            Usefulness::NotUseful\n+                            Ok(Usefulness::NotUseful)\n                         }\n                     } else {\n-                        let matrix = matrix.specialize_constructor(&cx, &constructor);\n-                        let v = v.expand_wildcard(&cx, &constructor);\n+                        let matrix = matrix.specialize_constructor(&cx, &constructor)?;\n+                        let v = v.expand_wildcard(&cx, &constructor)?;\n \n                         is_useful(&cx, &matrix, &v)\n                     }\n                 } else {\n-                    Usefulness::NotUseful\n+                    Ok(Usefulness::NotUseful)\n                 }\n             }\n             _ => {\n@@ -345,30 +390,32 @@ enum Constructor {\n     Enum(EnumVariantId),\n }\n \n-fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> Option<Constructor> {\n-    match pat.as_pat(cx) {\n+fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> MatchCheckResult<Option<Constructor>> {\n+    let res = match pat.as_pat(cx) {\n         Pat::Wild => None,\n         Pat::Tuple(pats) => Some(Constructor::Tuple { arity: pats.len() }),\n         Pat::Lit(lit_expr) => {\n             // for now we only support bool literals\n             match cx.body.exprs[lit_expr] {\n                 Expr::Literal(Literal::Bool(val)) => Some(Constructor::Bool(val)),\n-                _ => unimplemented!(),\n+                _ => return Err(MatchCheckNotImplemented),\n             }\n         }\n         Pat::TupleStruct { .. } | Pat::Path(_) => {\n             let pat_id = pat.as_id().expect(\"we already know this pattern is not a wild\");\n             let variant_id =\n-                cx.infer.variant_resolution_for_pat(pat_id).unwrap_or_else(|| unimplemented!());\n+                cx.infer.variant_resolution_for_pat(pat_id).ok_or(MatchCheckNotImplemented)?;\n             match variant_id {\n                 VariantId::EnumVariantId(enum_variant_id) => {\n                     Some(Constructor::Enum(enum_variant_id))\n                 }\n-                _ => unimplemented!(),\n+                _ => return Err(MatchCheckNotImplemented),\n             }\n         }\n-        x => unimplemented!(\"{:?} not yet implemented\", x),\n-    }\n+        _ => return Err(MatchCheckNotImplemented),\n+    };\n+\n+    Ok(res)\n }\n \n fn all_constructors_covered(\n@@ -613,6 +660,34 @@ mod tests {\n         check_no_diagnostic(content);\n     }\n \n+    #[test]\n+    fn tuple_of_bools_binding_missing_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true) {\n+                    (true, _x) => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_binding_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true) {\n+                    (true, _x) => {},\n+                    (false, true) => {},\n+                    (false, false) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n     #[test]\n     fn tuple_of_tuple_and_bools_no_arms() {\n         let content = r\"\n@@ -941,4 +1016,74 @@ mod false_negatives {\n         // match the type of the match expression.\n         check_no_diagnostic(content);\n     }\n+\n+    #[test]\n+    fn mismatched_types_with_different_arity() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (true, false) {\n+                    (true, false, true) => (),\n+                    (true) => (),\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // We don't currently check that the match arms actually\n+        // match the type of the match expression. This test\n+        // checks to ensure we don't panic when the code we are\n+        // checking is malformed in such a way that the arity of the\n+        // constructors doesn't match.\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn integers() {\n+        let content = r\"\n+            fn test_fn() {\n+                match 5 {\n+                    10 => (),\n+                    11..20 => (),\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // We don't currently check integer exhaustiveness.\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: u32 },\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A { foo: 5 } => (),\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // We don't currently handle enum record types.\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_not_in_scope() {\n+        let content = r\"\n+            fn test_fn() {\n+                match Foo::Bar {\n+                    Foo::Baz => (),\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // The enum is not in scope so we don't perform exhaustiveness checking.\n+        check_no_diagnostic(content);\n+    }\n }"}, {"sha": "7498d04dcb4d64b51ea31f8ab13ac93e5d430c99", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b87b7a088f34ff794fc19e57ee2ae1cfe81a12df/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87b7a088f34ff794fc19e57ee2ae1cfe81a12df/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=b87b7a088f34ff794fc19e57ee2ae1cfe81a12df", "patch": "@@ -90,9 +90,12 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n \n         match is_useful(&cx, &seen, &PatStack::from_wild()) {\n-            Usefulness::Useful => (),\n+            Ok(Usefulness::Useful) => (),\n             // if a wildcard pattern is not useful, then all patterns are covered\n-            Usefulness::NotUseful => return,\n+            Ok(Usefulness::NotUseful) => return,\n+            // this path is for unimplemented checks, so we err on the side of not\n+            // reporting any errors\n+            _ => return,\n         }\n \n         if let Ok(source_ptr) = source_map.expr_syntax(id) {"}]}