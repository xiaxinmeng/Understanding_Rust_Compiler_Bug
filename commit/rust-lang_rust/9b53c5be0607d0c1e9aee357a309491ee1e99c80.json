{"sha": "9b53c5be0607d0c1e9aee357a309491ee1e99c80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNTNjNWJlMDYwN2QwYzFlOWFlZTM1N2EzMDk0OTFlZTFlOTljODA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-04T09:13:29Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-20T21:53:40Z"}, "message": "fix bug in parse_tuple_parens_expr + related refactoring", "tree": {"sha": "c3374e7e6ceeb86012c2062dc86adb03754d928e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3374e7e6ceeb86012c2062dc86adb03754d928e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b53c5be0607d0c1e9aee357a309491ee1e99c80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b53c5be0607d0c1e9aee357a309491ee1e99c80", "html_url": "https://github.com/rust-lang/rust/commit/9b53c5be0607d0c1e9aee357a309491ee1e99c80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b53c5be0607d0c1e9aee357a309491ee1e99c80/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66470d3217f27b5950c38a3af4a99e0ef12fa2c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/66470d3217f27b5950c38a3af4a99e0ef12fa2c8", "html_url": "https://github.com/rust-lang/rust/commit/66470d3217f27b5950c38a3af4a99e0ef12fa2c8"}], "stats": {"total": 117, "additions": 49, "deletions": 68}, "files": [{"sha": "51310fb88f65a86f997a66e6af553c421f80d239", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9b53c5be0607d0c1e9aee357a309491ee1e99c80/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b53c5be0607d0c1e9aee357a309491ee1e99c80/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=9b53c5be0607d0c1e9aee357a309491ee1e99c80", "patch": "@@ -1,4 +1,4 @@\n-use super::{SeqSep, Parser, TokenType, PathStyle};\n+use super::{Parser, TokenType, PathStyle};\n use rustc_errors::PResult;\n use syntax::attr;\n use syntax::ast;\n@@ -301,8 +301,10 @@ impl<'a> Parser<'a> {\n     crate fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n         Ok(if self.eat(&token::Eq) {\n             ast::MetaItemKind::NameValue(self.parse_unsuffixed_lit()?)\n-        } else if self.eat(&token::OpenDelim(token::Paren)) {\n-            ast::MetaItemKind::List(self.parse_meta_seq()?)\n+        } else if self.check(&token::OpenDelim(token::Paren)) {\n+            // Matches `meta_seq = ( COMMASEP(meta_item_inner) )`.\n+            let (list, _) = self.parse_paren_comma_seq(|p| p.parse_meta_item_inner())?;\n+            ast::MetaItemKind::List(list)\n         } else {\n             ast::MetaItemKind::Word\n         })\n@@ -311,28 +313,17 @@ impl<'a> Parser<'a> {\n     /// Matches `meta_item_inner : (meta_item | UNSUFFIXED_LIT) ;`.\n     fn parse_meta_item_inner(&mut self) -> PResult<'a, ast::NestedMetaItem> {\n         match self.parse_unsuffixed_lit() {\n-            Ok(lit) => {\n-                return Ok(ast::NestedMetaItem::Literal(lit))\n-            }\n+            Ok(lit) => return Ok(ast::NestedMetaItem::Literal(lit)),\n             Err(ref mut err) => err.cancel(),\n         }\n \n         match self.parse_meta_item() {\n-            Ok(mi) => {\n-                return Ok(ast::NestedMetaItem::MetaItem(mi))\n-            }\n+            Ok(mi) => return Ok(ast::NestedMetaItem::MetaItem(mi)),\n             Err(ref mut err) => err.cancel(),\n         }\n \n         let found = self.this_token_to_string();\n         let msg = format!(\"expected unsuffixed literal or identifier, found `{}`\", found);\n         Err(self.diagnostic().struct_span_err(self.token.span, &msg))\n     }\n-\n-    /// Matches `meta_seq = ( COMMASEP(meta_item_inner) )`.\n-    fn parse_meta_seq(&mut self) -> PResult<'a, Vec<ast::NestedMetaItem>> {\n-        self.parse_seq_to_end(&token::CloseDelim(token::Paren),\n-                              SeqSep::trailing_allowed(token::Comma),\n-                              |p: &mut Parser<'a>| p.parse_meta_item_inner())\n-    }\n }"}, {"sha": "8c66804604f22a531ca42a3b12eb1feb7777cd86", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9b53c5be0607d0c1e9aee357a309491ee1e99c80/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b53c5be0607d0c1e9aee357a309491ee1e99c80/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=9b53c5be0607d0c1e9aee357a309491ee1e99c80", "patch": "@@ -919,17 +919,13 @@ impl<'a> Parser<'a> {\n \n     fn parse_tuple_parens_expr(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n-        let mut first = true;\n-        let parse_leading_attr_expr = |p: &mut Self| {\n-            if first {\n-                // `(#![foo] a, b, ...)` is OK...\n-                attrs.extend(p.parse_inner_attributes()?);\n-                // ...but not `(a, #![foo] b, ...)`.\n-                first = false;\n-            }\n-            p.parse_expr_catch_underscore()\n-        };\n-        let (es, trailing_comma) = match self.parse_paren_comma_seq(parse_leading_attr_expr) {\n+        self.expect(&token::OpenDelim(token::Paren))?;\n+        attrs.extend(self.parse_inner_attributes()?); // `(#![foo] a, b, ...)` is OK.\n+        let (es, trailing_comma) = match self.parse_seq_to_end(\n+            &token::CloseDelim(token::Paren),\n+            SeqSep::trailing_allowed(token::Comma),\n+            |p| p.parse_expr_catch_underscore(),\n+        ) {\n             Ok(x) => x,\n             Err(err) => return Ok(self.recover_seq_parse_error(token::Paren, lo, Err(err))),\n         };\n@@ -950,7 +946,8 @@ impl<'a> Parser<'a> {\n \n         attrs.extend(self.parse_inner_attributes()?);\n \n-        let kind = if self.eat(&token::CloseDelim(token::Bracket)) {\n+        let close = &token::CloseDelim(token::Bracket);\n+        let kind = if self.eat(close) {\n             // Empty vector\n             ExprKind::Array(Vec::new())\n         } else {\n@@ -962,21 +959,18 @@ impl<'a> Parser<'a> {\n                     id: DUMMY_NODE_ID,\n                     value: self.parse_expr()?,\n                 };\n-                self.expect(&token::CloseDelim(token::Bracket))?;\n+                self.expect(close)?;\n                 ExprKind::Repeat(first_expr, count)\n             } else if self.eat(&token::Comma) {\n                 // Vector with two or more elements.\n-                let remaining_exprs = self.parse_seq_to_end(\n-                    &token::CloseDelim(token::Bracket),\n-                    SeqSep::trailing_allowed(token::Comma),\n-                    |p| Ok(p.parse_expr()?)\n-                )?;\n+                let sep = SeqSep::trailing_allowed(token::Comma);\n+                let (remaining_exprs, _) = self.parse_seq_to_end(close, sep, |p| p.parse_expr())?;\n                 let mut exprs = vec![first_expr];\n                 exprs.extend(remaining_exprs);\n                 ExprKind::Array(exprs)\n             } else {\n                 // Vector with one element\n-                self.expect(&token::CloseDelim(token::Bracket))?;\n+                self.expect(close)?;\n                 ExprKind::Array(vec![first_expr])\n             }\n         };"}, {"sha": "255e789b58ea92403bae2d5b8e7b728bc135bfb8", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9b53c5be0607d0c1e9aee357a309491ee1e99c80/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b53c5be0607d0c1e9aee357a309491ee1e99c80/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=9b53c5be0607d0c1e9aee357a309491ee1e99c80", "patch": "@@ -739,34 +739,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses a sequence, including the closing delimiter. The function\n-    /// `f` must consume tokens until reaching the next separator or\n-    /// closing bracket.\n-    fn parse_seq_to_end<T>(\n-        &mut self,\n-        ket: &TokenKind,\n-        sep: SeqSep,\n-        f: impl FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n-    ) -> PResult<'a, Vec<T>> {\n-        let (val, _, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;\n-        if !recovered {\n-            self.bump();\n-        }\n-        Ok(val)\n-    }\n-\n-    /// Parses a sequence, not including the closing delimiter. The function\n-    /// `f` must consume tokens until reaching the next separator or\n-    /// closing bracket.\n-    fn parse_seq_to_before_end<T>(\n-        &mut self,\n-        ket: &TokenKind,\n-        sep: SeqSep,\n-        f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n-    ) -> PResult<'a, (Vec<T>, bool, bool)> {\n-        self.parse_seq_to_before_tokens(&[ket], sep, TokenExpectType::Expect, f)\n-    }\n-\n     fn expect_any_with_type(&mut self, kets: &[&TokenKind], expect: TokenExpectType) -> bool {\n         kets.iter().any(|k| {\n             match expect {\n@@ -854,6 +826,34 @@ impl<'a> Parser<'a> {\n         Ok((v, trailing, recovered))\n     }\n \n+    /// Parses a sequence, not including the closing delimiter. The function\n+    /// `f` must consume tokens until reaching the next separator or\n+    /// closing bracket.\n+    fn parse_seq_to_before_end<T>(\n+        &mut self,\n+        ket: &TokenKind,\n+        sep: SeqSep,\n+        f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n+    ) -> PResult<'a, (Vec<T>, bool, bool)> {\n+        self.parse_seq_to_before_tokens(&[ket], sep, TokenExpectType::Expect, f)\n+    }\n+\n+    /// Parses a sequence, including the closing delimiter. The function\n+    /// `f` must consume tokens until reaching the next separator or\n+    /// closing bracket.\n+    fn parse_seq_to_end<T>(\n+        &mut self,\n+        ket: &TokenKind,\n+        sep: SeqSep,\n+        f: impl FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n+    ) -> PResult<'a, (Vec<T>, bool /* trailing */)> {\n+        let (val, trailing, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;\n+        if !recovered {\n+            self.eat(ket);\n+        }\n+        Ok((val, trailing))\n+    }\n+\n     /// Parses a sequence, including the closing delimiter. The function\n     /// `f` must consume tokens until reaching the next separator or\n     /// closing bracket.\n@@ -865,11 +865,7 @@ impl<'a> Parser<'a> {\n         f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     ) -> PResult<'a, (Vec<T>, bool)> {\n         self.expect(bra)?;\n-        let (result, trailing, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;\n-        if !recovered {\n-            self.eat(ket);\n-        }\n-        Ok((result, trailing))\n+        self.parse_seq_to_end(ket, sep, f)\n     }\n \n     fn parse_delim_comma_seq<T>("}]}