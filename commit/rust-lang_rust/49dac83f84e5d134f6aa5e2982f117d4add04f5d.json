{"sha": "49dac83f84e5d134f6aa5e2982f117d4add04f5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZGFjODNmODRlNWQxMzRmNmFhNWUyOTgyZjExN2Q0YWRkMDRmNWQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-16T08:59:42Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-16T16:22:37Z"}, "message": "Cleanup metadata and incremental cache processing of constants", "tree": {"sha": "0e61a1146768cab00ca148308055522ee5476254", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e61a1146768cab00ca148308055522ee5476254"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49dac83f84e5d134f6aa5e2982f117d4add04f5d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqr72oACgkQpp+NIls6\n19ltzw//dZds68/poYZqmD8jG5wJ8XLUSjM2vWCcI44jW9LzElGZumaI9iJ4KDqe\n6eFXvVQ/AMbjB86HMDMBnEmyrfPyGR+WrzrZIFHxnP+JAtxYB6oWtb2/e0RfA+0K\nxJsO9+TUW3wZ62UHQMn3+naN/CLBQkoQcr8YG6/WTjgo95nHO848W0sRyDH1hCG3\nlW/zRbl2COvmWt0MVPLG8cWmZRvrO0yTTjvmEO12Dp4GgLg3UJCtOPRaBRPC+azz\n4iAmvYbPBBdyyiApO/qPmIpE2PF8QpBcRzEJA5nH5bdIvCDCXMUheFePjti8v19b\npViFUWAxgUssBhY6adGhDyH7ePPC0rCRBuEISLQ/vUCuu6VAYDIVykSv46uNh54h\nslR9B7f4GNqN5zCQGZBGNUMuuIYc69dT2EBzhDtziGsD19v2n5It3k4pPJiBblwf\n7bv2zjRWx5FCoC596HY3EQ0/+TAfXhLUgcqW3rLMLb3wbwYE1Qqukis3NQJuQzAe\nb/qD29sFeTqPL/tq0gT95kwS5+DI59uuWaOlRmX8DDxXBTm3p0zcgHkzhE1jOFwX\nahgssZo5AHPwfWh88n52nC5AVxbq4dfDj0UkzuYmuvOrgnC75EQvHBdvPygMw3xM\nYazJZxIZZekR6VCFK5qdnDwtPyllNu2WDVzyRP7nHmiCrWUaXvA=\n=e5DI\n-----END PGP SIGNATURE-----", "payload": "tree 0e61a1146768cab00ca148308055522ee5476254\nparent a7170b0412d1baa4e30cb31d1ea326617021f086\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1521190782 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1521217357 +0100\n\nCleanup metadata and incremental cache processing of constants\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49dac83f84e5d134f6aa5e2982f117d4add04f5d", "html_url": "https://github.com/rust-lang/rust/commit/49dac83f84e5d134f6aa5e2982f117d4add04f5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49dac83f84e5d134f6aa5e2982f117d4add04f5d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7170b0412d1baa4e30cb31d1ea326617021f086", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7170b0412d1baa4e30cb31d1ea326617021f086", "html_url": "https://github.com/rust-lang/rust/commit/a7170b0412d1baa4e30cb31d1ea326617021f086"}], "stats": {"total": 338, "additions": 212, "deletions": 126}, "files": [{"sha": "04ffb9af29ed5fd0898d78b63c93efe641633f59", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/49dac83f84e5d134f6aa5e2982f117d4add04f5d/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dac83f84e5d134f6aa5e2982f117d4add04f5d/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=49dac83f84e5d134f6aa5e2982f117d4add04f5d", "patch": "@@ -15,11 +15,13 @@ pub use self::value::{PrimVal, PrimValKind, Value, Pointer};\n use std::collections::BTreeMap;\n use std::fmt;\n use mir;\n-use ty;\n+use hir::def_id::DefId;\n+use ty::{self, TyCtxt};\n use ty::layout::{self, Align, HasDataLayout};\n use middle::region;\n use std::iter;\n use syntax::ast::Mutability;\n+use rustc_serialize::{Encoder, Decoder, Decodable, Encodable};\n \n #[derive(Clone, Debug, PartialEq)]\n pub enum Lock {\n@@ -152,6 +154,84 @@ pub struct AllocId(pub u64);\n impl ::rustc_serialize::UseSpecializedEncodable for AllocId {}\n impl ::rustc_serialize::UseSpecializedDecodable for AllocId {}\n \n+pub const ALLOC_DISCRIMINANT: usize = 0;\n+pub const FN_DISCRIMINANT: usize = 1;\n+\n+pub fn specialized_encode_alloc_id<\n+    'a, 'tcx,\n+    E: Encoder,\n+>(\n+    encoder: &mut E,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    alloc_id: AllocId,\n+    shorthand: Option<usize>,\n+) -> Result<(), E::Error> {\n+    if let Some(shorthand) = shorthand {\n+        return shorthand.encode(encoder);\n+    }\n+    if let Some(alloc) = tcx.interpret_interner.get_alloc(alloc_id) {\n+        trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n+        ALLOC_DISCRIMINANT.encode(encoder)?;\n+        alloc.encode(encoder)?;\n+        tcx.interpret_interner\n+            .get_corresponding_static_def_id(alloc_id)\n+            .encode(encoder)?;\n+    } else if let Some(fn_instance) = tcx.interpret_interner.get_fn(alloc_id) {\n+        trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n+        FN_DISCRIMINANT.encode(encoder)?;\n+        fn_instance.encode(encoder)?;\n+    } else {\n+        bug!(\"alloc id without corresponding allocation: {}\", alloc_id);\n+    }\n+    Ok(())\n+}\n+\n+pub fn specialized_decode_alloc_id<\n+    'a, 'tcx,\n+    D: Decoder,\n+    CACHE: FnOnce(&mut D, usize, AllocId),\n+    SHORT: FnOnce(&mut D, usize) -> Result<AllocId, D::Error>\n+>(\n+    decoder: &mut D,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pos: usize,\n+    cache: CACHE,\n+    short: SHORT,\n+) -> Result<AllocId, D::Error> {\n+    match usize::decode(decoder)? {\n+        ALLOC_DISCRIMINANT => {\n+            let alloc_id = tcx.interpret_interner.reserve();\n+            trace!(\"creating alloc id {:?} at {}\", alloc_id, pos);\n+            // insert early to allow recursive allocs\n+            cache(decoder, pos, alloc_id);\n+\n+            let allocation = Allocation::decode(decoder)?;\n+            trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n+            let allocation = tcx.intern_const_alloc(allocation);\n+            tcx.interpret_interner.intern_at_reserved(alloc_id, allocation);\n+\n+            if let Some(glob) = Option::<DefId>::decode(decoder)? {\n+                tcx.interpret_interner.cache(glob, alloc_id);\n+            }\n+\n+            Ok(alloc_id)\n+        },\n+        FN_DISCRIMINANT => {\n+            trace!(\"creating fn alloc id at {}\", pos);\n+            let instance = ty::Instance::decode(decoder)?;\n+            trace!(\"decoded fn alloc instance: {:?}\", instance);\n+            let id = tcx.interpret_interner.create_fn_alloc(instance);\n+            trace!(\"created fn alloc id: {:?}\", id);\n+            cache(decoder, pos, id);\n+            Ok(id)\n+        },\n+        shorthand => {\n+            trace!(\"loading shorthand {}\", shorthand);\n+            short(decoder, shorthand)\n+        },\n+    }\n+}\n+\n impl fmt::Display for AllocId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.0)"}, {"sha": "e56d8f8e818dde032338542a3d15ad438f137e65", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/49dac83f84e5d134f6aa5e2982f117d4add04f5d/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dac83f84e5d134f6aa5e2982f117d4add04f5d/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=49dac83f84e5d134f6aa5e2982f117d4add04f5d", "patch": "@@ -75,6 +75,13 @@ pub struct OnDiskCache<'sess> {\n     // A map from dep-node to the position of any associated diagnostics in\n     // `serialized_data`.\n     prev_diagnostics_index: FxHashMap<SerializedDepNodeIndex, AbsoluteBytePos>,\n+\n+    // A cache to ensure we don't read allocations twice\n+    interpret_alloc_cache: RefCell<FxHashMap<usize, interpret::AllocId>>,\n+\n+    // A map from positions to size of the serialized allocation\n+    // so we can skip over already processed allocations\n+    interpret_alloc_size: RefCell<FxHashMap<usize, usize>>,\n }\n \n // This type is used only for (de-)serialization.\n@@ -140,6 +147,8 @@ impl<'sess> OnDiskCache<'sess> {\n             query_result_index: footer.query_result_index.into_iter().collect(),\n             prev_diagnostics_index: footer.diagnostics_index.into_iter().collect(),\n             synthetic_expansion_infos: RefCell::new(FxHashMap()),\n+            interpret_alloc_cache: RefCell::new(FxHashMap::default()),\n+            interpret_alloc_size: RefCell::new(FxHashMap::default()),\n         }\n     }\n \n@@ -155,6 +164,8 @@ impl<'sess> OnDiskCache<'sess> {\n             query_result_index: FxHashMap(),\n             prev_diagnostics_index: FxHashMap(),\n             synthetic_expansion_infos: RefCell::new(FxHashMap()),\n+            interpret_alloc_cache: RefCell::new(FxHashMap::default()),\n+            interpret_alloc_size: RefCell::new(FxHashMap::default()),\n         }\n     }\n \n@@ -381,7 +392,8 @@ impl<'sess> OnDiskCache<'sess> {\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n             synthetic_expansion_infos: &self.synthetic_expansion_infos,\n-            interpret_alloc_cache: FxHashMap::default(),\n+            interpret_alloc_cache: &self.interpret_alloc_cache,\n+            interpret_alloc_size: &self.interpret_alloc_size,\n         };\n \n         match decode_tagged(&mut decoder, dep_node_index) {\n@@ -443,7 +455,8 @@ struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n     synthetic_expansion_infos: &'x RefCell<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n     file_index_to_file: &'x RefCell<FxHashMap<FileMapIndex, Lrc<FileMap>>>,\n     file_index_to_stable_id: &'x FxHashMap<FileMapIndex, StableFilemapId>,\n-    interpret_alloc_cache: FxHashMap<usize, interpret::AllocId>,\n+    interpret_alloc_cache: &'x RefCell<FxHashMap<usize, interpret::AllocId>>,\n+    interpret_alloc_size: &'x RefCell<FxHashMap<usize, usize>>,\n }\n \n impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n@@ -565,47 +578,37 @@ implement_ty_decoder!( CacheDecoder<'a, 'tcx, 'x> );\n \n impl<'a, 'tcx, 'x> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, 'tcx, 'x> {\n     fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n-        const MAX1: usize = usize::max_value() - 1;\n         let tcx = self.tcx;\n         let pos = TyDecoder::position(self);\n-        match usize::decode(self)? {\n-            ::std::usize::MAX => {\n-                let alloc_id = tcx.interpret_interner.reserve();\n-                trace!(\"creating alloc id {:?} at {}\", alloc_id, pos);\n-                // insert early to allow recursive allocs\n-                self.interpret_alloc_cache.insert(pos, alloc_id);\n-\n-                let allocation = interpret::Allocation::decode(self)?;\n-                trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n-                let allocation = self.tcx.intern_const_alloc(allocation);\n-                tcx.interpret_interner.intern_at_reserved(alloc_id, allocation);\n-\n-                if let Some(glob) = Option::<DefId>::decode(self)? {\n-                    trace!(\"connecting alloc {:?} with {:?}\", alloc_id, glob);\n-                    tcx.interpret_interner.cache(glob, alloc_id);\n-                }\n-\n-                Ok(alloc_id)\n-            },\n-            MAX1 => {\n-                trace!(\"creating fn alloc id at {}\", pos);\n-                let instance = ty::Instance::decode(self)?;\n-                trace!(\"decoded fn alloc instance: {:?}\", instance);\n-                let id = tcx.interpret_interner.create_fn_alloc(instance);\n-                trace!(\"created fn alloc id: {:?}\", id);\n-                self.interpret_alloc_cache.insert(pos, id);\n-                Ok(id)\n+        trace!(\"specialized_decode_alloc_id: {:?}\", pos);\n+        if let Some(cached) = self.interpret_alloc_cache.borrow().get(&pos).cloned() {\n+            // if there's no end position we are currently deserializing a recursive\n+            // allocation\n+            if let Some(end) = self.interpret_alloc_size.borrow().get(&pos).cloned() {\n+                trace!(\"{} already cached as {:?}\", pos, cached);\n+                // skip ahead\n+                self.opaque.set_position(end);\n+                return Ok(cached)\n+            }\n+        }\n+        let id = interpret::specialized_decode_alloc_id(\n+            self,\n+            tcx,\n+            pos,\n+            |this, pos, alloc_id| {\n+                assert!(this.interpret_alloc_cache.borrow_mut().insert(pos, alloc_id).is_none());\n             },\n-            shorthand => {\n-                trace!(\"loading shorthand {}\", shorthand);\n-                if let Some(&alloc_id) = self.interpret_alloc_cache.get(&shorthand) {\n-                    return Ok(alloc_id);\n-                }\n-                trace!(\"shorthand {} not cached, loading entire allocation\", shorthand);\n+            |this, shorthand| {\n                 // need to load allocation\n-                self.with_position(shorthand, |this| interpret::AllocId::decode(this))\n-            },\n-        }\n+                this.with_position(shorthand, |this| interpret::AllocId::decode(this))\n+            }\n+        )?;\n+        assert!(self\n+            .interpret_alloc_size\n+            .borrow_mut()\n+            .insert(pos, TyDecoder::position(self))\n+            .is_none());\n+        Ok(id)\n     }\n }\n impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n@@ -806,30 +809,27 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<\n     where E: 'enc + ty_codec::TyEncoder\n {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n-        trace!(\"encoding {:?} at {}\", alloc_id, self.position());\n-        if let Some(shorthand) = self.interpret_alloc_shorthands.get(alloc_id).cloned() {\n-            trace!(\"encoding {:?} as shorthand to {}\", alloc_id, shorthand);\n-            return shorthand.encode(self);\n-        }\n-        let start = self.position();\n-        // cache the allocation shorthand now, because the allocation itself might recursively\n-        // point to itself.\n-        self.interpret_alloc_shorthands.insert(*alloc_id, start);\n-        if let Some(alloc) = self.tcx.interpret_interner.get_alloc(*alloc_id) {\n-            trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n-            usize::max_value().encode(self)?;\n-            alloc.encode(self)?;\n-            self.tcx.interpret_interner\n-                .get_corresponding_static_def_id(*alloc_id)\n-                .encode(self)?;\n-        } else if let Some(fn_instance) = self.tcx.interpret_interner.get_fn(*alloc_id) {\n-            trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n-            (usize::max_value() - 1).encode(self)?;\n-            fn_instance.encode(self)?;\n-        } else {\n-            bug!(\"alloc id without corresponding allocation: {}\", alloc_id);\n-        }\n-        Ok(())\n+        use std::collections::hash_map::Entry;\n+        let tcx = self.tcx;\n+        let pos = self.position();\n+        let shorthand = match self.interpret_alloc_shorthands.entry(*alloc_id) {\n+            Entry::Occupied(entry) => Some(entry.get().clone()),\n+            Entry::Vacant(entry) => {\n+                // ensure that we don't place any AllocIds at the very beginning\n+                // of the metadata file, because that would end up making our indices\n+                // not special. It is essentially impossible for that to happen,\n+                // but let's make sure\n+                assert!(pos != interpret::ALLOC_DISCRIMINANT && pos != interpret::FN_DISCRIMINANT);\n+                entry.insert(pos);\n+                None\n+            },\n+        };\n+        interpret::specialized_encode_alloc_id(\n+            self,\n+            tcx,\n+            *alloc_id,\n+            shorthand,\n+        )\n     }\n }\n "}, {"sha": "320160b4d6112e03bbc1963eaee8249b4c4f026e", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 30, "deletions": 38, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/49dac83f84e5d134f6aa5e2982f117d4add04f5d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dac83f84e5d134f6aa5e2982f117d4add04f5d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=49dac83f84e5d134f6aa5e2982f117d4add04f5d", "patch": "@@ -58,6 +58,9 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n \n     // interpreter allocation cache\n     interpret_alloc_cache: FxHashMap<usize, interpret::AllocId>,\n+    // a cache for sizes of interpreter allocations\n+    // needed to skip already deserialized allocations\n+    interpret_alloc_size: FxHashMap<usize, usize>,\n }\n \n /// Abstract over the various ways one can create metadata decoders.\n@@ -77,6 +80,7 @@ pub trait Metadata<'a, 'tcx>: Copy {\n             last_filemap_index: 0,\n             lazy_state: LazyState::NoNode,\n             interpret_alloc_cache: FxHashMap::default(),\n+            interpret_alloc_size: FxHashMap::default(),\n         }\n     }\n }\n@@ -282,46 +286,34 @@ impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for DecodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n-        const MAX1: usize = usize::max_value() - 1;\n-        let tcx = self.tcx.unwrap();\n+        let tcx = self.tcx.expect(\"need tcx for AllocId decoding\");\n         let pos = self.position();\n-        match usize::decode(self)? {\n-            ::std::usize::MAX => {\n-                let alloc_id = tcx.interpret_interner.reserve();\n-                trace!(\"creating alloc id {:?} at {}\", alloc_id, pos);\n-                // insert early to allow recursive allocs\n-                self.interpret_alloc_cache.insert(pos, alloc_id);\n-\n-                let allocation = interpret::Allocation::decode(self)?;\n-                trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n-                let allocation = self.tcx.unwrap().intern_const_alloc(allocation);\n-                tcx.interpret_interner.intern_at_reserved(alloc_id, allocation);\n-\n-                if let Some(glob) = Option::<DefId>::decode(self)? {\n-                    tcx.interpret_interner.cache(glob, alloc_id);\n-                }\n-\n-                Ok(alloc_id)\n-            },\n-            MAX1 => {\n-                trace!(\"creating fn alloc id at {}\", pos);\n-                let instance = ty::Instance::decode(self)?;\n-                trace!(\"decoded fn alloc instance: {:?}\", instance);\n-                let id = tcx.interpret_interner.create_fn_alloc(instance);\n-                trace!(\"created fn alloc id: {:?}\", id);\n-                self.interpret_alloc_cache.insert(pos, id);\n-                Ok(id)\n-            },\n-            shorthand => {\n-                trace!(\"loading shorthand {}\", shorthand);\n-                if let Some(&alloc_id) = self.interpret_alloc_cache.get(&shorthand) {\n-                    return Ok(alloc_id);\n-                }\n-                trace!(\"shorthand {} not cached, loading entire allocation\", shorthand);\n-                // need to load allocation\n-                self.with_position(shorthand, |this| interpret::AllocId::decode(this))\n-            },\n+        if let Some(cached) = self.interpret_alloc_cache.get(&pos).cloned() {\n+            // if there's no end position we are currently deserializing a recursive\n+            // allocation\n+            if let Some(end) = self.interpret_alloc_size.get(&pos).cloned() {\n+                trace!(\"{} already cached as {:?}\", pos, cached);\n+                // skip ahead\n+                self.opaque.set_position(end);\n+                return Ok(cached)\n+            }\n         }\n+        let id = interpret::specialized_decode_alloc_id(\n+            self,\n+            tcx,\n+            pos,\n+            |this, pos, alloc_id| { this.interpret_alloc_cache.insert(pos, alloc_id); },\n+            |this, shorthand| {\n+                // need to load allocation\n+                this.with_position(shorthand, |this| interpret::AllocId::decode(this))\n+            }\n+        )?;\n+        let end_pos = self.position();\n+        assert!(self\n+            .interpret_alloc_size\n+            .insert(pos, end_pos)\n+            .is_none());\n+        Ok(id)\n     }\n }\n "}, {"sha": "0da23c2caf4aec0141e3f87d46abbf232d4c9b35", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/49dac83f84e5d134f6aa5e2982f117d4add04f5d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dac83f84e5d134f6aa5e2982f117d4add04f5d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=49dac83f84e5d134f6aa5e2982f117d4add04f5d", "patch": "@@ -196,30 +196,26 @@ impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n-        trace!(\"encoding {:?} at {}\", alloc_id, self.position());\n-        if let Some(shorthand) = self.interpret_alloc_shorthands.get(alloc_id).cloned() {\n-            trace!(\"encoding {:?} as shorthand to {}\", alloc_id, shorthand);\n-            return shorthand.encode(self);\n-        }\n-        let start = self.position();\n-        // cache the allocation shorthand now, because the allocation itself might recursively\n-        // point to itself.\n-        self.interpret_alloc_shorthands.insert(*alloc_id, start);\n-        if let Some(alloc) = self.tcx.interpret_interner.get_alloc(*alloc_id) {\n-            trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n-            usize::max_value().encode(self)?;\n-            alloc.encode(self)?;\n-            self.tcx.interpret_interner\n-                .get_corresponding_static_def_id(*alloc_id)\n-                .encode(self)?;\n-        } else if let Some(fn_instance) = self.tcx.interpret_interner.get_fn(*alloc_id) {\n-            trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n-            (usize::max_value() - 1).encode(self)?;\n-            fn_instance.encode(self)?;\n-        } else {\n-            bug!(\"alloc id without corresponding allocation: {}\", alloc_id);\n-        }\n-        Ok(())\n+        use std::collections::hash_map::Entry;\n+        let tcx = self.tcx;\n+        let pos = self.position();\n+        let shorthand = match self.interpret_alloc_shorthands.entry(*alloc_id) {\n+            Entry::Occupied(entry) => Some(entry.get().clone()),\n+            Entry::Vacant(entry) => {\n+                // ensure that we don't place any AllocIds at the very beginning\n+                // of the metadata file, because that would end up making our 0 and 1 indices\n+                // not special. This is essentially impossible, but let's make sure\n+                assert!(pos != 0 && pos != 1);\n+                entry.insert(pos);\n+                None\n+            },\n+        };\n+        interpret::specialized_encode_alloc_id(\n+            self,\n+            tcx,\n+            *alloc_id,\n+            shorthand,\n+        )\n     }\n }\n "}, {"sha": "6345b456523edc54dc6d4571bc7f2e40f75727b2", "filename": "src/test/incremental/static_refering_to_other_static/issue-49081.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/49dac83f84e5d134f6aa5e2982f117d4add04f5d/src%2Ftest%2Fincremental%2Fstatic_refering_to_other_static%2Fissue-49081.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49dac83f84e5d134f6aa5e2982f117d4add04f5d/src%2Ftest%2Fincremental%2Fstatic_refering_to_other_static%2Fissue-49081.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstatic_refering_to_other_static%2Fissue-49081.rs?ref=49dac83f84e5d134f6aa5e2982f117d4add04f5d", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// https://github.com/rust-lang/rust/issues/49081\n+\n+// revisions:rpass1 rpass2\n+\n+pub static A: i32 = 42;\n+pub static B: &i32 = &A;\n+\n+fn main() {}"}]}