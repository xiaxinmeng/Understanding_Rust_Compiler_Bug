{"sha": "6ad83834515912c5e529e0e9fe326d5060d937cf", "node_id": "C_kwDOAAsO6NoAKDZhZDgzODM0NTE1OTEyYzVlNTI5ZTBlOWZlMzI2ZDUwNjBkOTM3Y2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-29T04:22:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-29T04:22:25Z"}, "message": "Auto merge of #105590 - solid-rs:patch/kmc-solid/thread-lifecycle-ordering, r=m-ou-se\n\nkmc-solid: Fix memory ordering in thread operations\n\nFixes two memory ordering issues in the thread state machine (`ThreadInner::lifecycle`) of the [`*-kmc-solid_*`](https://doc.rust-lang.org/nightly/rustc/platform-support/kmc-solid.html) Tier 3 targets.\n\n1. When detaching a thread that is still running (i.e., the owner updates `lifecycle` first, and the child updates it next), the first update did not synchronize-with the second update, resulting in a data race between the first update and the deallocation of `ThreadInner` by the child thread.\n2. When joining on a thread, the joiner has to pass its own task ID to the joinee in order to be woken up later, but in doing so, it did not synchronize-with the read operation, creating possible sequences of execution where the joinee wakes up an incorrect or non-existent task.\n\nBoth issue are theoretical and most likely have never manifested in practice because of the stronger guarantees provided by the Arm memory model (particularly due to its barrier-based definition). Compiler optimizations could have subverted this, but the inspection of compiled code did not reveal such optimizations taking place.", "tree": {"sha": "320238d92f74ca6918ba2dcfecac0c42b132e0eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/320238d92f74ca6918ba2dcfecac0c42b132e0eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ad83834515912c5e529e0e9fe326d5060d937cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad83834515912c5e529e0e9fe326d5060d937cf", "html_url": "https://github.com/rust-lang/rust/commit/6ad83834515912c5e529e0e9fe326d5060d937cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ad83834515912c5e529e0e9fe326d5060d937cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b15ca6635f752fefebfd101aa944c6167128183c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b15ca6635f752fefebfd101aa944c6167128183c", "html_url": "https://github.com/rust-lang/rust/commit/b15ca6635f752fefebfd101aa944c6167128183c"}, {"sha": "6fbef06f26b038c97578dfb8a577e68ec0189f37", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fbef06f26b038c97578dfb8a577e68ec0189f37", "html_url": "https://github.com/rust-lang/rust/commit/6fbef06f26b038c97578dfb8a577e68ec0189f37"}], "stats": {"total": 25, "additions": 16, "deletions": 9}, "files": [{"sha": "535703be33f06474724a37802df9b6d6fb4f7353", "filename": "library/std/src/sys/itron/thread.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6ad83834515912c5e529e0e9fe326d5060d937cf/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad83834515912c5e529e0e9fe326d5060d937cf/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs?ref=6ad83834515912c5e529e0e9fe326d5060d937cf", "patch": "@@ -119,7 +119,7 @@ impl Thread {\n \n             let old_lifecycle = inner\n                 .lifecycle\n-                .swap(LIFECYCLE_EXITED_OR_FINISHED_OR_JOIN_FINALIZE, Ordering::Release);\n+                .swap(LIFECYCLE_EXITED_OR_FINISHED_OR_JOIN_FINALIZE, Ordering::AcqRel);\n \n             match old_lifecycle {\n                 LIFECYCLE_DETACHED => {\n@@ -129,9 +129,9 @@ impl Thread {\n \n                     // In this case, `*p_inner`'s ownership has been moved to\n                     // us, and we are responsible for dropping it. The acquire\n-                    // ordering is not necessary because the parent thread made\n-                    // no memory access needing synchronization since the call\n-                    // to `acre_tsk`.\n+                    // ordering ensures that the swap operation that wrote\n+                    // `LIFECYCLE_DETACHED` happens-before `Box::from_raw(\n+                    // p_inner)`.\n                     // Safety: See above.\n                     let _ = unsafe { Box::from_raw(p_inner) };\n \n@@ -151,6 +151,9 @@ impl Thread {\n                     // Since the parent might drop `*inner` and terminate us as\n                     // soon as it sees `JOIN_FINALIZE`, the release ordering\n                     // must be used in the above `swap` call.\n+                    //\n+                    // To make the task referred to by `parent_tid` visible, we\n+                    // must use the acquire ordering in the above `swap` call.\n \n                     // [JOINING \u2192 JOIN_FINALIZE]\n                     // Wake up the parent task.\n@@ -218,11 +221,15 @@ impl Thread {\n \n         let current_task = current_task as usize;\n \n-        match inner.lifecycle.swap(current_task, Ordering::Acquire) {\n+        match inner.lifecycle.swap(current_task, Ordering::AcqRel) {\n             LIFECYCLE_INIT => {\n                 // [INIT \u2192 JOINING]\n                 // The child task will transition the state to `JOIN_FINALIZE`\n                 // and wake us up.\n+                //\n+                // To make the task referred to by `current_task` visible from\n+                // the child task's point of view, we must use the release\n+                // ordering in the above `swap` call.\n                 loop {\n                     expect_success_aborting(unsafe { abi::slp_tsk() }, &\"slp_tsk\");\n                     // To synchronize with the child task's memory accesses to\n@@ -267,15 +274,15 @@ impl Drop for Thread {\n         let inner = unsafe { self.p_inner.as_ref() };\n \n         // Detach the thread.\n-        match inner.lifecycle.swap(LIFECYCLE_DETACHED_OR_JOINED, Ordering::Acquire) {\n+        match inner.lifecycle.swap(LIFECYCLE_DETACHED_OR_JOINED, Ordering::AcqRel) {\n             LIFECYCLE_INIT => {\n                 // [INIT \u2192 DETACHED]\n                 // When the time comes, the child will figure out that no\n                 // one will ever join it.\n                 // The ownership of `*p_inner` is moved to the child thread.\n-                // However, the release ordering is not necessary because we\n-                // made no memory access needing synchronization since the call\n-                // to `acre_tsk`.\n+                // The release ordering ensures that the above swap operation on\n+                // `lifecycle` happens-before the child thread's\n+                // `Box::from_raw(p_inner)`.\n             }\n             LIFECYCLE_FINISHED => {\n                 // [FINISHED \u2192 JOINED]"}]}