{"sha": "bc259ee844f608599293c83d96de353005681cca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMjU5ZWU4NDRmNjA4NTk5MjkzYzgzZDk2ZGUzNTMwMDU2ODFjY2E=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-03-14T14:50:40Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-03-22T16:02:07Z"}, "message": "Introduce HirId, a replacement for NodeId after lowering to HIR.\n\nHirId has a more stable representation than NodeId, meaning that\nmodifications to one item don't influence (part of) the IDs within\nother items. The other part is a DefIndex for which there already\nis a way of stable hashing and persistence.\n\nThis commit introduces the HirId type and generates a HirId for\nevery NodeId during HIR lowering, but the resulting values are\nnot yet used anywhere, except in consistency checks.", "tree": {"sha": "b2bfc622dd14072f227b8e7f8c56567d594c263d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2bfc622dd14072f227b8e7f8c56567d594c263d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc259ee844f608599293c83d96de353005681cca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc259ee844f608599293c83d96de353005681cca", "html_url": "https://github.com/rust-lang/rust/commit/bc259ee844f608599293c83d96de353005681cca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc259ee844f608599293c83d96de353005681cca/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "559127b4517229115397404f20167bc7b702d3d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/559127b4517229115397404f20167bc7b702d3d6", "html_url": "https://github.com/rust-lang/rust/commit/559127b4517229115397404f20167bc7b702d3d6"}], "stats": {"total": 2073, "additions": 1286, "deletions": 787}, "files": [{"sha": "22ca0e421be851e9e818fe84c5a004b109f31d3f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1001, "deletions": 772, "changes": 1773, "blob_url": "https://github.com/rust-lang/rust/blob/bc259ee844f608599293c83d96de353005681cca/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc259ee844f608599293c83d96de353005681cca/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=bc259ee844f608599293c83d96de353005681cca"}, {"sha": "0f7e54953b052151307b1ad9962542107f124caa", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bc259ee844f608599293c83d96de353005681cca/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc259ee844f608599293c83d96de353005681cca/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=bc259ee844f608599293c83d96de353005681cca", "patch": "@@ -14,8 +14,10 @@\n //! There are also some rather random cases (like const initializer\n //! expressions) that are mostly just leftovers.\n \n+use hir;\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::StableHasher;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::fmt::Write;\n@@ -121,6 +123,7 @@ pub struct Definitions {\n     table: DefPathTable,\n     node_to_def_index: NodeMap<DefIndex>,\n     def_index_to_node: Vec<ast::NodeId>,\n+    pub(super) node_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -206,6 +209,23 @@ impl DefPath {\n         s\n     }\n \n+    /// Returns a string representation of the DefPath without\n+    /// the crate-prefix. This method is useful if you don't have\n+    /// a TyCtxt available.\n+    pub fn to_string_no_crate(&self) -> String {\n+        let mut s = String::with_capacity(self.data.len() * 16);\n+\n+        for component in &self.data {\n+            write!(s,\n+                   \"::{}[{}]\",\n+                   component.data.as_interned_str(),\n+                   component.disambiguator)\n+                .unwrap();\n+        }\n+\n+        s\n+    }\n+\n     pub fn deterministic_hash(&self, tcx: TyCtxt) -> u64 {\n         debug!(\"deterministic_hash({:?})\", self);\n         let mut state = StableHasher::new();\n@@ -275,6 +295,7 @@ impl Definitions {\n             },\n             node_to_def_index: NodeMap(),\n             def_index_to_node: vec![],\n+            node_to_hir_id: IndexVec::new(),\n         }\n     }\n \n@@ -367,6 +388,15 @@ impl Definitions {\n \n         index\n     }\n+\n+    /// Initialize the ast::NodeId to HirId mapping once it has been generated during\n+    /// AST to HIR lowering.\n+    pub fn init_node_id_to_hir_id_mapping(&mut self,\n+                                          mapping: IndexVec<ast::NodeId, hir::HirId>) {\n+        assert!(self.node_to_hir_id.is_empty(),\n+                \"Trying initialize NodeId -> HirId mapping twice\");\n+        self.node_to_hir_id = mapping;\n+    }\n }\n \n impl DefPathData {"}, {"sha": "b3cc0c542ef9da217dfb225c0bcbc9746e193397", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/bc259ee844f608599293c83d96de353005681cca/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc259ee844f608599293c83d96de353005681cca/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=bc259ee844f608599293c83d96de353005681cca", "patch": "@@ -0,0 +1,184 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use hir::{self, intravisit, HirId, ItemLocalId};\n+use syntax::ast::NodeId;\n+use hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_data_structures::fx::FxHashMap;\n+\n+pub fn check_crate<'hir>(hir_map: &hir::map::Map<'hir>) {\n+    let mut outer_visitor = OuterVisitor {\n+        hir_map: hir_map,\n+        errors: vec![],\n+    };\n+\n+    hir_map.dep_graph.with_ignore(|| {\n+        hir_map.krate().visit_all_item_likes(&mut outer_visitor);\n+        if !outer_visitor.errors.is_empty() {\n+            let message = outer_visitor\n+                .errors\n+                .iter()\n+                .fold(String::new(), |s1, s2| s1 + \"\\n\" + s2);\n+            bug!(\"{}\", message);\n+        }\n+    });\n+}\n+\n+struct HirIdValidator<'a, 'hir: 'a> {\n+    hir_map: &'a hir::map::Map<'hir>,\n+    owner_def_index: Option<DefIndex>,\n+    hir_ids_seen: FxHashMap<ItemLocalId, NodeId>,\n+    errors: Vec<String>,\n+}\n+\n+struct OuterVisitor<'a, 'hir: 'a> {\n+    hir_map: &'a hir::map::Map<'hir>,\n+    errors: Vec<String>,\n+}\n+\n+impl<'a, 'hir: 'a> OuterVisitor<'a, 'hir> {\n+    fn new_inner_visitor(&self,\n+                         hir_map: &'a hir::map::Map<'hir>)\n+                         -> HirIdValidator<'a, 'hir> {\n+        HirIdValidator {\n+            hir_map: hir_map,\n+            owner_def_index: None,\n+            hir_ids_seen: FxHashMap(),\n+            errors: Vec::new(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'hir: 'a> ItemLikeVisitor<'hir> for OuterVisitor<'a, 'hir> {\n+    fn visit_item(&mut self, i: &'hir hir::Item) {\n+        let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n+        inner_visitor.check(i.id, |this| intravisit::walk_item(this, i));\n+        self.errors.extend(inner_visitor.errors.drain(..));\n+    }\n+\n+    fn visit_trait_item(&mut self, i: &'hir hir::TraitItem) {\n+        let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n+        inner_visitor.check(i.id, |this| intravisit::walk_trait_item(this, i));\n+        self.errors.extend(inner_visitor.errors.drain(..));\n+    }\n+\n+    fn visit_impl_item(&mut self, i: &'hir hir::ImplItem) {\n+        let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n+        inner_visitor.check(i.id, |this| intravisit::walk_impl_item(this, i));\n+        self.errors.extend(inner_visitor.errors.drain(..));\n+    }\n+}\n+\n+impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n+\n+    fn check<F: FnOnce(&mut HirIdValidator<'a, 'hir>)>(&mut self,\n+                                                       node_id: NodeId,\n+                                                       walk: F) {\n+        assert!(self.owner_def_index.is_none());\n+        let owner_def_index = self.hir_map.local_def_id(node_id).index;\n+        self.owner_def_index = Some(owner_def_index);\n+        walk(self);\n+\n+        if owner_def_index == CRATE_DEF_INDEX {\n+            return\n+        }\n+\n+        // There's always at least one entry for the owning item itself\n+        let max = self.hir_ids_seen\n+                      .keys()\n+                      .map(|local_id| local_id.as_usize())\n+                      .max()\n+                      .unwrap();\n+\n+        if max != self.hir_ids_seen.len() - 1 {\n+            // Collect the missing ItemLocalIds\n+            let missing: Vec<_> = (0 .. max + 1)\n+              .filter(|&i| !self.hir_ids_seen.contains_key(&ItemLocalId(i as u32)))\n+              .collect();\n+\n+            // Try to map those to something more useful\n+            let mut missing_items = vec![];\n+\n+            for local_id in missing {\n+                let hir_id = HirId {\n+                    owner: owner_def_index,\n+                    local_id: ItemLocalId(local_id as u32),\n+                };\n+\n+                // We are already in ICE mode here, so doing a linear search\n+                // should be fine.\n+                let (node_id, _) = self.hir_map\n+                                       .definitions()\n+                                       .node_to_hir_id\n+                                       .iter()\n+                                       .enumerate()\n+                                       .find(|&(_, &entry)| hir_id == entry)\n+                                       .unwrap();\n+                let node_id = NodeId::new(node_id);\n+                missing_items.push(format!(\"[local_id: {}, node:{}]\",\n+                                           local_id,\n+                                           self.hir_map.node_to_string(node_id)));\n+            }\n+\n+            self.errors.push(format!(\n+                \"ItemLocalIds not assigned densely in {}. \\\n+                Max ItemLocalId = {}, missing IDs = {:?}\",\n+                self.hir_map.def_path(DefId::local(owner_def_index)).to_string_no_crate(),\n+                max,\n+                missing_items));\n+        }\n+    }\n+}\n+\n+impl<'a, 'hir: 'a> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n+\n+    fn nested_visit_map<'this>(&'this mut self)\n+                               -> intravisit::NestedVisitorMap<'this, 'hir> {\n+        intravisit::NestedVisitorMap::OnlyBodies(self.hir_map)\n+    }\n+\n+    fn visit_id(&mut self, node_id: NodeId) {\n+        let owner = self.owner_def_index.unwrap();\n+        let stable_id = self.hir_map.definitions().node_to_hir_id[node_id];\n+\n+        if stable_id == hir::DUMMY_HIR_ID {\n+            self.errors.push(format!(\"HirIdValidator: No HirId assigned for NodeId {}: {:?}\",\n+                                     node_id,\n+                                     self.hir_map.node_to_string(node_id)));\n+        }\n+\n+        if owner != stable_id.owner {\n+            self.errors.push(format!(\n+                \"HirIdValidator: The recorded owner of {} is {} instead of {}\",\n+                self.hir_map.node_to_string(node_id),\n+                self.hir_map.def_path(DefId::local(stable_id.owner)).to_string_no_crate(),\n+                self.hir_map.def_path(DefId::local(owner)).to_string_no_crate()));\n+        }\n+\n+        if let Some(prev) = self.hir_ids_seen.insert(stable_id.local_id, node_id) {\n+            if prev != node_id {\n+                self.errors.push(format!(\n+                    \"HirIdValidator: Same HirId {}/{} assigned for nodes {} and {}\",\n+                    self.hir_map.def_path(DefId::local(stable_id.owner)).to_string_no_crate(),\n+                    stable_id.local_id.as_usize(),\n+                    self.hir_map.node_to_string(prev),\n+                    self.hir_map.node_to_string(node_id)));\n+            }\n+        }\n+    }\n+\n+    fn visit_impl_item_ref(&mut self, _: &'hir hir::ImplItemRef) {\n+        // Explicitly do nothing here. ImplItemRefs contain hir::Visibility\n+        // values that actually belong to an ImplItem instead of the ItemImpl\n+        // we are currently in. So for those it's correct that they have a\n+        // different owner.\n+    }\n+}"}, {"sha": "3def41fd42566d7599e170b39aad190434d64d4d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bc259ee844f608599293c83d96de353005681cca/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc259ee844f608599293c83d96de353005681cca/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=bc259ee844f608599293c83d96de353005681cca", "patch": "@@ -36,6 +36,7 @@ pub mod blocks;\n mod collector;\n mod def_collector;\n pub mod definitions;\n+mod hir_id_validator;\n \n #[derive(Copy, Clone, Debug)]\n pub enum Node<'hir> {\n@@ -964,13 +965,17 @@ pub fn map_crate<'hir>(forest: &'hir mut Forest,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n-    Map {\n+    let map = Map {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n         map: map,\n         definitions: definitions,\n         inlined_bodies: RefCell::new(DefIdMap()),\n-    }\n+    };\n+\n+    hir_id_validator::check_crate(&map);\n+\n+    map\n }\n \n /// Identical to the `PpAnn` implementation for `hir::Crate`,"}, {"sha": "1c79a02d3da0e88d83f9b36511b09deb34bfc69d", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bc259ee844f608599293c83d96de353005681cca/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc259ee844f608599293c83d96de353005681cca/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=bc259ee844f608599293c83d96de353005681cca", "patch": "@@ -30,7 +30,7 @@ pub use self::Visibility::{Public, Inherited};\n pub use self::PathParameters::*;\n \n use hir::def::Def;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use util::nodemap::{NodeMap, FxHashSet};\n \n use syntax_pos::{Span, ExpnId, DUMMY_SP};\n@@ -43,6 +43,8 @@ use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenStream;\n use syntax::util::ThinVec;\n \n+use rustc_data_structures::indexed_vec;\n+\n use std::collections::BTreeMap;\n use std::fmt;\n \n@@ -73,6 +75,63 @@ pub mod pat_util;\n pub mod print;\n pub mod svh;\n \n+/// A HirId uniquely identifies a node in the HIR of then current crate. It is\n+/// composed of the `owner`, which is the DefIndex of the directly enclosing\n+/// hir::Item, hir::TraitItem, or hir::ImplItem (i.e. the closest \"item-like\"),\n+/// and the `local_id` which is unique within the given owner.\n+///\n+/// This two-level structure makes for more stable values: One can move an item\n+/// around within the source code, or add or remove stuff before it, without\n+/// the local_id part of the HirId changing, which is a very useful property\n+/// incremental compilation where we have to persist things through changes to\n+/// the code base.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug,\n+         RustcEncodable, RustcDecodable)]\n+pub struct HirId {\n+    pub owner: DefIndex,\n+    pub local_id: ItemLocalId,\n+}\n+\n+/// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n+/// that is within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n+/// guarantee that the numerical value of a given `ItemLocalId` corresponds to\n+/// the node's position within the owning item in any way, but there is a\n+/// guarantee that the `LocalItemId`s within an owner occupy a dense range of\n+/// integers starting at zero, so a mapping that maps all or most nodes within\n+/// an \"item-like\" to something else can be implement by a `Vec` instead of a\n+/// tree or hash map.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug,\n+         RustcEncodable, RustcDecodable)]\n+pub struct ItemLocalId(pub u32);\n+\n+impl ItemLocalId {\n+    pub fn as_usize(&self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+impl indexed_vec::Idx for ItemLocalId {\n+    fn new(idx: usize) -> Self {\n+        debug_assert!((idx as u32) as usize == idx);\n+        ItemLocalId(idx as u32)\n+    }\n+\n+    fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+/// The `HirId` corresponding to CRATE_NODE_ID and CRATE_DEF_INDEX\n+pub const CRATE_HIR_ID: HirId = HirId {\n+    owner: CRATE_DEF_INDEX,\n+    local_id: ItemLocalId(0)\n+};\n+\n+pub const DUMMY_HIR_ID: HirId = HirId {\n+    owner: CRATE_DEF_INDEX,\n+    local_id: ItemLocalId(!0)\n+};\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,"}, {"sha": "f0e328a551d5f37003d53bf6f93a40617708ea83", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc259ee844f608599293c83d96de353005681cca/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc259ee844f608599293c83d96de353005681cca/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=bc259ee844f608599293c83d96de353005681cca", "patch": "@@ -178,17 +178,9 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n             block.stmts = block.stmts.move_flat_map(|mut stmt| {\n                 remaining_stmts -= 1;\n \n-                match stmt.node {\n-                    // Avoid wasting a node id on a trailing expression statement,\n-                    // which shares a HIR node with the expression itself.\n-                    ast::StmtKind::Expr(ref expr) if remaining_stmts == 0 => stmt.id = expr.id,\n-\n-                    _ if self.monotonic => {\n-                        assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n-                        stmt.id = self.cx.resolver.next_node_id();\n-                    }\n-\n-                    _ => {}\n+                if self.monotonic {\n+                    assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n+                    stmt.id = self.cx.resolver.next_node_id();\n                 }\n \n                 Some(stmt)"}, {"sha": "fd8d5ff9e7ea857b1f080d10c1fee5650010006f", "filename": "src/test/compile-fail/region-bounds-on-objects-and-type-parameters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc259ee844f608599293c83d96de353005681cca/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc259ee844f608599293c83d96de353005681cca/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs?ref=bc259ee844f608599293c83d96de353005681cca", "patch": "@@ -18,7 +18,7 @@ trait SomeTrait { }\n \n // Bounds on object types:\n \n-struct Foo<'a,'b,'c> { //~ ERROR parameter `'b` is never used\n+struct Foo<'a,'b,'c> { //~ ERROR parameter `'c` is never used\n     // All of these are ok, because we can derive exactly one bound:\n     a: Box<IsStatic>,\n     b: Box<Is<'static>>,"}]}