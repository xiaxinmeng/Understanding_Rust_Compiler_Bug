{"sha": "518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxOGVjMTI1OWE5NjcxNDJmY2ZiZjdjYjZkZDJkNGEzZGQ1NjEwY2Y=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T11:29:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T14:36:23Z"}, "message": "Normalize associated types in bounds too. Also, make the workaround\nfor lack of impl-trait-for-trait just a bit more targeted (don't\nsubstitute err, just drop the troublesome bound for now) -- otherwise\nsubstituting false types leads us into trouble when we normalize etc.", "tree": {"sha": "5cee2456a1bd065d078e852b18b89cba8696ad58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cee2456a1bd065d078e852b18b89cba8696ad58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf", "html_url": "https://github.com/rust-lang/rust/commit/518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdd5ff842db9eec168736998b2a5b72ba415e5bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdd5ff842db9eec168736998b2a5b72ba415e5bb", "html_url": "https://github.com/rust-lang/rust/commit/cdd5ff842db9eec168736998b2a5b72ba415e5bb"}], "stats": {"total": 215, "additions": 149, "deletions": 66}, "files": [{"sha": "d6ab0201d190a22b0cbc00feef3f0668bbe03000", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 76, "deletions": 22, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf", "patch": "@@ -6970,13 +6970,67 @@ pub trait HasProjectionTypes {\n     fn has_projection_types(&self) -> bool;\n }\n \n+impl<'tcx> HasProjectionTypes for ty::GenericBounds<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.predicates.iter().any(|p| p.has_projection_types())\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for Predicate<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        match *self {\n+            Predicate::Trait(ref data) => data.has_projection_types(),\n+            Predicate::Equate(ref data) => data.has_projection_types(),\n+            Predicate::RegionOutlives(ref data) => data.has_projection_types(),\n+            Predicate::TypeOutlives(ref data) => data.has_projection_types(),\n+            Predicate::Projection(ref data) => data.has_projection_types(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for TraitPredicate<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.trait_ref.has_projection_types()\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for EquatePredicate<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.0.has_projection_types() || self.1.has_projection_types()\n+    }\n+}\n+\n+impl HasProjectionTypes for Region {\n+    fn has_projection_types(&self) -> bool {\n+        false\n+    }\n+}\n+\n+impl<T:HasProjectionTypes,U:HasProjectionTypes> HasProjectionTypes for OutlivesPredicate<T,U> {\n+    fn has_projection_types(&self) -> bool {\n+        self.0.has_projection_types() || self.1.has_projection_types()\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for ProjectionPredicate<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.projection_ty.has_projection_types() || self.ty.has_projection_types()\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for ProjectionTy<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.trait_ref.has_projection_types()\n+    }\n+}\n+\n impl<'tcx> HasProjectionTypes for Ty<'tcx> {\n     fn has_projection_types(&self) -> bool {\n         ty::type_has_projection(*self)\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for ty::TraitRef<'tcx> {\n+impl<'tcx> HasProjectionTypes for TraitRef<'tcx> {\n     fn has_projection_types(&self) -> bool {\n         self.substs.has_projection_types()\n     }\n@@ -7012,31 +7066,31 @@ impl<'tcx,T> HasProjectionTypes for Box<T>\n     }\n }\n \n-impl<T> HasProjectionTypes for ty::Binder<T>\n+impl<T> HasProjectionTypes for Binder<T>\n     where T : HasProjectionTypes\n {\n     fn has_projection_types(&self) -> bool {\n         self.0.has_projection_types()\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for ty::FnOutput<'tcx> {\n+impl<'tcx> HasProjectionTypes for FnOutput<'tcx> {\n     fn has_projection_types(&self) -> bool {\n         match *self {\n-            ty::FnConverging(t) => t.has_projection_types(),\n-            ty::FnDiverging => false,\n+            FnConverging(t) => t.has_projection_types(),\n+            FnDiverging => false,\n         }\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for ty::FnSig<'tcx> {\n+impl<'tcx> HasProjectionTypes for FnSig<'tcx> {\n     fn has_projection_types(&self) -> bool {\n         self.inputs.iter().any(|t| t.has_projection_types()) ||\n             self.output.has_projection_types()\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for ty::BareFnTy<'tcx> {\n+impl<'tcx> HasProjectionTypes for BareFnTy<'tcx> {\n     fn has_projection_types(&self) -> bool {\n         self.sig.has_projection_types()\n     }\n@@ -7046,7 +7100,7 @@ pub trait ReferencesError {\n     fn references_error(&self) -> bool;\n }\n \n-impl<T:ReferencesError> ReferencesError for ty::Binder<T> {\n+impl<T:ReferencesError> ReferencesError for Binder<T> {\n     fn references_error(&self) -> bool {\n         self.0.references_error()\n     }\n@@ -7058,58 +7112,58 @@ impl<T:ReferencesError> ReferencesError for Rc<T> {\n     }\n }\n \n-impl<'tcx> ReferencesError for ty::TraitPredicate<'tcx> {\n+impl<'tcx> ReferencesError for TraitPredicate<'tcx> {\n     fn references_error(&self) -> bool {\n         self.trait_ref.references_error()\n     }\n }\n \n-impl<'tcx> ReferencesError for ty::ProjectionPredicate<'tcx> {\n+impl<'tcx> ReferencesError for ProjectionPredicate<'tcx> {\n     fn references_error(&self) -> bool {\n         self.projection_ty.trait_ref.references_error() || self.ty.references_error()\n     }\n }\n \n-impl<'tcx> ReferencesError for ty::TraitRef<'tcx> {\n+impl<'tcx> ReferencesError for TraitRef<'tcx> {\n     fn references_error(&self) -> bool {\n         self.input_types().iter().any(|t| t.references_error())\n     }\n }\n \n-impl<'tcx> ReferencesError for ty::Ty<'tcx> {\n+impl<'tcx> ReferencesError for Ty<'tcx> {\n     fn references_error(&self) -> bool {\n-        ty::type_is_error(*self)\n+        type_is_error(*self)\n     }\n }\n \n-impl<'tcx> ReferencesError for ty::Predicate<'tcx> {\n+impl<'tcx> ReferencesError for Predicate<'tcx> {\n     fn references_error(&self) -> bool {\n         match *self {\n-            ty::Predicate::Trait(ref data) => data.references_error(),\n-            ty::Predicate::Equate(ref data) => data.references_error(),\n-            ty::Predicate::RegionOutlives(ref data) => data.references_error(),\n-            ty::Predicate::TypeOutlives(ref data) => data.references_error(),\n-            ty::Predicate::Projection(ref data) => data.references_error(),\n+            Predicate::Trait(ref data) => data.references_error(),\n+            Predicate::Equate(ref data) => data.references_error(),\n+            Predicate::RegionOutlives(ref data) => data.references_error(),\n+            Predicate::TypeOutlives(ref data) => data.references_error(),\n+            Predicate::Projection(ref data) => data.references_error(),\n         }\n     }\n }\n \n-impl<A,B> ReferencesError for ty::OutlivesPredicate<A,B>\n+impl<A,B> ReferencesError for OutlivesPredicate<A,B>\n     where A : ReferencesError, B : ReferencesError\n {\n     fn references_error(&self) -> bool {\n         self.0.references_error() || self.1.references_error()\n     }\n }\n \n-impl<'tcx> ReferencesError for ty::EquatePredicate<'tcx>\n+impl<'tcx> ReferencesError for EquatePredicate<'tcx>\n {\n     fn references_error(&self) -> bool {\n         self.0.references_error() || self.1.references_error()\n     }\n }\n \n-impl ReferencesError for ty::Region\n+impl ReferencesError for Region\n {\n     fn references_error(&self) -> bool {\n         false"}, {"sha": "0d7ce2f871a6fd6d21d62ef7c96058e08c9469aa", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf", "patch": "@@ -10,7 +10,7 @@\n \n use middle::infer::InferCtxt;\n use middle::traits::{ObligationCause, ObligationCauseCode, FulfillmentContext};\n-use middle::ty::{mod, HasProjectionTypes, Ty};\n+use middle::ty::{mod, RegionEscape, HasProjectionTypes, Ty};\n use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -32,8 +32,7 @@ pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     let mut normalizer = AssociatedTypeNormalizer { span: span,\n                                                     body_id: body_id,\n                                                     infcx: infcx,\n-                                                    fulfillment_cx: fulfillment_cx,\n-                                                    region_binders: 0 };\n+                                                    fulfillment_cx: fulfillment_cx };\n     value.fold_with(&mut normalizer)\n }\n \n@@ -42,22 +41,13 @@ struct AssociatedTypeNormalizer<'a,'tcx:'a> {\n     fulfillment_cx: &'a mut FulfillmentContext<'tcx>,\n     span: Span,\n     body_id: ast::NodeId,\n-    region_binders: uint,\n }\n \n impl<'a,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn enter_region_binder(&mut self) {\n-        self.region_binders += 1;\n-    }\n-\n-    fn exit_region_binder(&mut self) {\n-        self.region_binders -= 1;\n-    }\n-\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         // We don't want to normalize associated types that occur inside of region\n         // binders, because they may contain bound regions, and we can't cope with that.\n@@ -69,10 +59,22 @@ impl<'a,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'tcx> {\n         // Instead of normalizing `<T as Foo<&'a>>::A` here, we'll\n         // normalize it when we instantiate those bound regions (which\n         // should occur eventually).\n-        let no_region_binders = self.region_binders == 0;\n \n         match ty.sty {\n-            ty::ty_projection(ref data) if no_region_binders => {\n+            ty::ty_projection(ref data) if !data.has_escaping_regions() => { // (*)\n+\n+                // (*) This is kind of hacky -- we need to be able to\n+                // handle normalization within binders because\n+                // otherwise we wind up a need to normalize when doing\n+                // trait matching (since you can have a trait\n+                // obligation like `for<'a> T::B : Fn(&'a int)`), but\n+                // we can't normalize with bound regions in scope. So\n+                // far now we just ignore binders but only normalize\n+                // if all bound regions are gone (and then we still\n+                // have to renormalize whenever we instantiate a\n+                // binder). It would be better to normalize in a\n+                // binding-aware fashion.\n+\n                 let cause =\n                     ObligationCause::new(\n                         self.span,"}, {"sha": "a189f780b0c270e2956f256acac4f2f84970752f", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf", "patch": "@@ -42,12 +42,6 @@ struct InstantiatedMethodSig<'tcx> {\n     /// the method.\n     all_substs: subst::Substs<'tcx>,\n \n-    /// Substitution to use when adding obligations from the method\n-    /// bounds. Normally equal to `all_substs` except for object\n-    /// receivers. See FIXME in instantiate_method_sig() for\n-    /// explanation.\n-    method_bounds_substs: subst::Substs<'tcx>,\n-\n     /// Generic bounds on the method's parameters which must be added\n     /// as pending obligations.\n     method_bounds: ty::GenericBounds<'tcx>,\n@@ -103,15 +97,15 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // Create the final signature for the method, replacing late-bound regions.\n         let InstantiatedMethodSig {\n-            method_sig, all_substs, method_bounds_substs, method_bounds\n+            method_sig, all_substs, method_bounds\n         } = self.instantiate_method_sig(&pick, all_substs);\n         let method_self_ty = method_sig.inputs[0];\n \n         // Unify the (adjusted) self type with what the method expects.\n         self.unify_receivers(self_ty, method_self_ty);\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n-        self.add_obligations(&pick, &method_bounds_substs, &method_bounds);\n+        self.add_obligations(&pick, &all_substs, &method_bounds);\n \n         // Create the final `MethodCallee`.\n         let fty = ty::mk_bare_fn(self.tcx(), None, self.tcx().mk_bare_fn(ty::BareFnTy {\n@@ -403,24 +397,17 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // type `Trait`, this leads to an obligation\n         // `Trait:Trait`. Until such time we DST is fully implemented,\n         // that obligation is not necessarily satisfied. (In the\n-        // future, it would be.)\n-        //\n-        // To sidestep this, we overwrite the binding for `Self` with\n-        // `err` (just for trait objects) when we generate the\n-        // obligations.  This causes us to generate the obligation\n-        // `err:Trait`, and the error type is considered to implement\n-        // all traits, so we're all good. Hack hack hack.\n-        let method_bounds_substs = match pick.kind {\n+        // future, it would be.) But we know that the true `Self` DOES implement\n+        // the trait. So we just delete this requirement. Hack hack hack.\n+        let mut method_bounds = pick.method_ty.generics.to_bounds(self.tcx(), &all_substs);\n+        match pick.kind {\n             probe::ObjectPick(..) => {\n-                let mut temp_substs = all_substs.clone();\n-                temp_substs.types.get_mut_slice(subst::SelfSpace)[0] = self.tcx().types.err;\n-                temp_substs\n+                assert_eq!(method_bounds.predicates.get_slice(subst::SelfSpace).len(), 1);\n+                method_bounds.predicates.pop(subst::SelfSpace);\n             }\n-            _ => {\n-                all_substs.clone()\n-            }\n-        };\n-        let method_bounds = pick.method_ty.generics.to_bounds(self.tcx(), &method_bounds_substs);\n+            _ => { }\n+        }\n+        let method_bounds = self.fcx.normalize_associated_types_in(self.span, &method_bounds);\n \n         debug!(\"method_bounds after subst = {}\",\n                method_bounds.repr(self.tcx()));\n@@ -442,26 +429,25 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         InstantiatedMethodSig {\n             method_sig: method_sig,\n             all_substs: all_substs,\n-            method_bounds_substs: method_bounds_substs,\n             method_bounds: method_bounds,\n         }\n     }\n \n     fn add_obligations(&mut self,\n                        pick: &probe::Pick<'tcx>,\n-                       method_bounds_substs: &subst::Substs<'tcx>,\n+                       all_substs: &subst::Substs<'tcx>,\n                        method_bounds: &ty::GenericBounds<'tcx>) {\n-        debug!(\"add_obligations: pick={} method_bounds_substs={} method_bounds={}\",\n+        debug!(\"add_obligations: pick={} all_substs={} method_bounds={}\",\n                pick.repr(self.tcx()),\n-               method_bounds_substs.repr(self.tcx()),\n+               all_substs.repr(self.tcx()),\n                method_bounds.repr(self.tcx()));\n \n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::misc(self.span, self.fcx.body_id),\n             method_bounds);\n \n         self.fcx.add_default_region_param_bounds(\n-            method_bounds_substs,\n+            all_substs,\n             self.call_expr);\n     }\n "}, {"sha": "47473564254e13af2f0717a2e302a159ad451a42", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf", "patch": "@@ -1071,7 +1071,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     debug!(\"ty_generics_for_trait: assoc_predicates={}\", assoc_predicates.repr(ccx.tcx));\n \n     for assoc_predicate in assoc_predicates.into_iter() {\n-        generics.predicates.push(subst::SelfSpace, assoc_predicate);\n+        generics.predicates.push(subst::TypeSpace, assoc_predicate);\n     }\n \n     return generics;"}, {"sha": "f09c27029d7fa448e90bf77eeb89c87ce2d439c2", "filename": "src/test/run-pass/associated-types-normalize-in-bounds.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds.rs?ref=518ec1259a967142fcfbf7cb6dd2d4a3dd5610cf", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we normalize associated types that appear in bounds; if\n+// we didn't, the call to `self.split2()` fails to type check.\n+\n+#![feature(associated_types)]\n+\n+struct Splits<'a, T, P>;\n+struct SplitsN<I>;\n+\n+trait SliceExt2 for Sized? {\n+    type Item;\n+\n+    fn split2<'a, P>(&'a self, pred: P) -> Splits<'a, Self::Item, P>\n+        where P: FnMut(&Self::Item) -> bool;\n+    fn splitn2<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, Self::Item, P>>\n+        where P: FnMut(&Self::Item) -> bool;\n+}\n+\n+impl<T> SliceExt2 for [T] {\n+    type Item = T;\n+\n+    fn split2<P>(&self, pred: P) -> Splits<T, P> where P: FnMut(&T) -> bool {\n+        loop {}\n+    }\n+\n+    fn splitn2<P>(&self, n: uint, pred: P) -> SplitsN<Splits<T, P>> where P: FnMut(&T) -> bool {\n+        self.split2(pred);\n+        loop {}\n+    }\n+}\n+\n+fn main() { }"}]}