{"sha": "485397e49a02a3b7ff77c17e4a3f16c653925cb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NTM5N2U0OWEwMmEzYjdmZjc3YzE3ZTRhM2YxNmM2NTM5MjVjYjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-13T07:04:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-13T07:04:14Z"}, "message": "Auto merge of #55589 - oli-obk:min_length_\ud83d\udca3, r=pnkfelix\n\nAdd `VariantIdx` type and use instead of `usize`", "tree": {"sha": "a8386662a025a2d9eb81c4a9e797bcf589b3894c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8386662a025a2d9eb81c4a9e797bcf589b3894c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/485397e49a02a3b7ff77c17e4a3f16c653925cb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/485397e49a02a3b7ff77c17e4a3f16c653925cb3", "html_url": "https://github.com/rust-lang/rust/commit/485397e49a02a3b7ff77c17e4a3f16c653925cb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/485397e49a02a3b7ff77c17e4a3f16c653925cb3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4371c854f5c7f734563f61a666e0ae230024c17", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4371c854f5c7f734563f61a666e0ae230024c17", "html_url": "https://github.com/rust-lang/rust/commit/c4371c854f5c7f734563f61a666e0ae230024c17"}, {"sha": "d46a2078b4e450e163a44502c42fc4a326943d03", "url": "https://api.github.com/repos/rust-lang/rust/commits/d46a2078b4e450e163a44502c42fc4a326943d03", "html_url": "https://github.com/rust-lang/rust/commit/d46a2078b4e450e163a44502c42fc4a326943d03"}], "stats": {"total": 497, "additions": 308, "deletions": 189}, "files": [{"sha": "a4246b26c22689ac02c948749edd0eeae6fbcba7", "filename": "src/Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -2246,6 +2246,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"rustc_target 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -2400,6 +2401,7 @@ dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"serialize 0.0.0\",\n ]\n "}, {"sha": "d2be0e4dcb9b9cef74b204431ba00b4df0e17a83", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -11,9 +11,10 @@\n use hir::def::Def;\n use hir::def_id::DefId;\n use ty::{self, Ty, TyCtxt};\n-use ty::layout::{LayoutError, Pointer, SizeSkeleton};\n+use ty::layout::{LayoutError, Pointer, SizeSkeleton, VariantIdx};\n \n use rustc_target::spec::abi::Abi::RustIntrinsic;\n+use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir;\n@@ -48,10 +49,13 @@ fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if def.variants.len() == 2 && !def.repr.c() && def.repr.int.is_none() {\n         let data_idx;\n \n-        if def.variants[0].fields.is_empty() {\n-            data_idx = 1;\n-        } else if def.variants[1].fields.is_empty() {\n-            data_idx = 0;\n+        let one = VariantIdx::new(1);\n+        let zero = VariantIdx::new(0);\n+\n+        if def.variants[zero].fields.is_empty() {\n+            data_idx = one;\n+        } else if def.variants[one].fields.is_empty() {\n+            data_idx = zero;\n         } else {\n             return ty;\n         }"}, {"sha": "59ef8fa14484b6837876aa25b56323df03e4e6f9", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -76,6 +76,7 @@ use hir::def::{Def, CtorKind};\n use ty::adjustment;\n use ty::{self, Ty, TyCtxt};\n use ty::fold::TypeFoldable;\n+use ty::layout::VariantIdx;\n \n use hir::{MutImmutable, MutMutable, PatKind};\n use hir::pat_util::EnumerateAndAdjustIterator;\n@@ -87,6 +88,7 @@ use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::indexed_vec::Idx;\n use std::rc::Rc;\n use util::nodemap::ItemLocalSet;\n \n@@ -227,7 +229,7 @@ impl<'tcx> cmt_<'tcx> {\n             }\n             _ => {\n                 assert_eq!(adt_def.variants.len(), 1);\n-                &adt_def.variants[0]\n+                &adt_def.variants[VariantIdx::new(0)]\n             }\n         };\n         Some((adt_def, &variant_def.fields[field_index]))"}, {"sha": "9a0b1c68ddcd54eaa805953c515335affba7e686", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -40,6 +40,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use ty::subst::{CanonicalUserSubsts, Subst, Substs};\n use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt};\n+use ty::layout::VariantIdx;\n use util::ppaux;\n \n pub use mir::interpret::AssertMessage;\n@@ -1753,7 +1754,7 @@ pub enum StatementKind<'tcx> {\n     /// Write the discriminant for a variant to the enum Place.\n     SetDiscriminant {\n         place: Place<'tcx>,\n-        variant_index: usize,\n+        variant_index: VariantIdx,\n     },\n \n     /// Start a live range for the storage of the local.\n@@ -1939,7 +1940,7 @@ pub enum ProjectionElem<'tcx, V, T> {\n     /// \"Downcast\" to a variant of an ADT. Currently, we only introduce\n     /// this for ADTs with more than one variant. It may be better to\n     /// just introduce it always, or always for enums.\n-    Downcast(&'tcx AdtDef, usize),\n+    Downcast(&'tcx AdtDef, VariantIdx),\n }\n \n /// Alias for projections as they appear in places, where the base is a place\n@@ -1950,6 +1951,11 @@ pub type PlaceProjection<'tcx> = Projection<'tcx, Place<'tcx>, Local, Ty<'tcx>>;\n /// and the index is a local.\n pub type PlaceElem<'tcx> = ProjectionElem<'tcx, Local, Ty<'tcx>>;\n \n+// at least on 64 bit systems, `PlaceElem` should not be larger than two pointers\n+static_assert!(PROJECTION_ELEM_IS_2_PTRS_LARGE:\n+    mem::size_of::<PlaceElem<'_>>() <= 16\n+);\n+\n /// Alias for projections as they appear in `UserTypeProjection`, where we\n /// need neither the `V` parameter for `Index` nor the `T` for `Field`.\n pub type ProjectionKind<'tcx> = ProjectionElem<'tcx, (), ()>;\n@@ -1969,7 +1975,7 @@ impl<'tcx> Place<'tcx> {\n         self.elem(ProjectionElem::Deref)\n     }\n \n-    pub fn downcast(self, adt_def: &'tcx AdtDef, variant_index: usize) -> Place<'tcx> {\n+    pub fn downcast(self, adt_def: &'tcx AdtDef, variant_index: VariantIdx) -> Place<'tcx> {\n         self.elem(ProjectionElem::Downcast(adt_def, variant_index))\n     }\n \n@@ -2211,7 +2217,7 @@ pub enum AggregateKind<'tcx> {\n     /// active field index would identity the field `c`\n     Adt(\n         &'tcx AdtDef,\n-        usize,\n+        VariantIdx,\n         &'tcx Substs<'tcx>,\n         Option<UserTypeAnnotation<'tcx>>,\n         Option<usize>,"}, {"sha": "baa88dba459156b49fb5aae9b7efdf054817c0f1", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -16,6 +16,7 @@\n use mir::*;\n use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, Ty, TyCtxt};\n+use ty::layout::VariantIdx;\n use hir;\n use ty::util::IntTypeExt;\n \n@@ -27,9 +28,13 @@ pub enum PlaceTy<'tcx> {\n     /// Downcast to a particular variant of an enum.\n     Downcast { adt_def: &'tcx AdtDef,\n                substs: &'tcx Substs<'tcx>,\n-               variant_index: usize },\n+               variant_index: VariantIdx },\n }\n \n+static_assert!(PLACE_TY_IS_3_PTRS_LARGE:\n+    mem::size_of::<PlaceTy<'_>>() <= 24\n+);\n+\n impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     pub fn from_ty(ty: Ty<'tcx>) -> PlaceTy<'tcx> {\n         PlaceTy::Ty { ty }\n@@ -54,7 +59,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     pub fn field_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, f: &Field) -> Ty<'tcx>\n     {\n         // Pass `0` here so it can be used as a \"default\" variant_index in first arm below\n-        let answer = match (self, 0) {\n+        let answer = match (self, VariantIdx::new(0)) {\n             (PlaceTy::Ty {\n                 ty: &ty::TyS { sty: ty::TyKind::Adt(adt_def, substs), .. } }, variant_index) |\n             (PlaceTy::Downcast { adt_def, substs, variant_index }, _) => {\n@@ -134,7 +139,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n                 match self.to_ty(tcx).sty {\n                     ty::Adt(adt_def, substs) => {\n                         assert!(adt_def.is_enum());\n-                        assert!(index < adt_def.variants.len());\n+                        assert!(index.as_usize() < adt_def.variants.len());\n                         assert_eq!(adt_def, adt_def1);\n                         PlaceTy::Downcast { adt_def,\n                                             substs,"}, {"sha": "a86a56a45cd646bc56832ef21023b86d55aac616", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -45,7 +45,7 @@ use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TyKind::*;\n use ty::GenericParamDefKind;\n-use ty::layout::{LayoutDetails, TargetDataLayout};\n+use ty::layout::{LayoutDetails, TargetDataLayout, VariantIdx};\n use ty::query;\n use ty::steal::Steal;\n use ty::BindingMode;\n@@ -1009,7 +1009,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn alloc_adt_def(self,\n                          did: DefId,\n                          kind: AdtKind,\n-                         variants: Vec<ty::VariantDef>,\n+                         variants: IndexVec<VariantIdx, ty::VariantDef>,\n                          repr: ReprOptions)\n                          -> &'gcx ty::AdtDef {\n         let def = ty::AdtDef::new(self, did, kind, variants, repr);"}, {"sha": "877bd5a82e6a045441dfc1b002ddc5c7495a5d24", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 45, "deletions": 26, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -23,6 +23,7 @@ use std::mem;\n use std::ops::Bound;\n \n use ich::StableHashingContext;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n \n@@ -229,7 +230,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             let b_offset = a.value.size(dl).abi_align(b.value.align(dl));\n             let size = (b_offset + b.value.size(dl)).abi_align(align);\n             LayoutDetails {\n-                variants: Variants::Single { index: 0 },\n+                variants: Variants::Single { index: VariantIdx::new(0) },\n                 fields: FieldPlacement::Arbitrary {\n                     offsets: vec![Size::ZERO, b_offset],\n                     memory_index: vec![0, 1]\n@@ -454,7 +455,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             Ok(LayoutDetails {\n-                variants: Variants::Single { index: 0 },\n+                variants: Variants::Single { index: VariantIdx::new(0) },\n                 fields: FieldPlacement::Arbitrary {\n                     offsets,\n                     memory_index\n@@ -499,7 +500,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             // The never type.\n             ty::Never => {\n                 tcx.intern_layout(LayoutDetails {\n-                    variants: Variants::Single { index: 0 },\n+                    variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Union(0),\n                     abi: Abi::Uninhabited,\n                     align: dl.i8_align,\n@@ -555,7 +556,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n \n                 tcx.intern_layout(LayoutDetails {\n-                    variants: Variants::Single { index: 0 },\n+                    variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Array {\n                         stride: element.size,\n                         count\n@@ -568,7 +569,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             ty::Slice(element) => {\n                 let element = self.layout_of(element)?;\n                 tcx.intern_layout(LayoutDetails {\n-                    variants: Variants::Single { index: 0 },\n+                    variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Array {\n                         stride: element.size,\n                         count: 0\n@@ -580,7 +581,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n             ty::Str => {\n                 tcx.intern_layout(LayoutDetails {\n-                    variants: Variants::Single { index: 0 },\n+                    variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Array {\n                         stride: Size::from_bytes(1),\n                         count: 0\n@@ -650,7 +651,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let size = size.abi_align(align);\n \n                 tcx.intern_layout(LayoutDetails {\n-                    variants: Variants::Single { index: 0 },\n+                    variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Array {\n                         stride: element.size,\n                         count\n@@ -671,7 +672,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     v.fields.iter().map(|field| {\n                         self.layout_of(field.ty(tcx, substs))\n                     }).collect::<Result<Vec<_>, _>>()\n-                }).collect::<Result<Vec<_>, _>>()?;\n+                }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n                 if def.is_union() {\n                     let packed = def.repr.packed();\n@@ -697,7 +698,8 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     }\n \n                     let mut size = Size::ZERO;\n-                    for field in &variants[0] {\n+                    let index = VariantIdx::new(0);\n+                    for field in &variants[index] {\n                         assert!(!field.is_unsized());\n \n                         if packed {\n@@ -710,8 +712,8 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     }\n \n                     return Ok(tcx.intern_layout(LayoutDetails {\n-                        variants: Variants::Single { index: 0 },\n-                        fields: FieldPlacement::Union(variants[0].len()),\n+                        variants: Variants::Single { index },\n+                        fields: FieldPlacement::Union(variants[index].len()),\n                         abi: Abi::Aggregate { sized: true },\n                         align,\n                         size: size.abi_align(align)\n@@ -729,8 +731,12 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     uninhabited && is_zst\n                 };\n                 let (present_first, present_second) = {\n-                    let mut present_variants = (0..variants.len()).filter(|&v| {\n-                        !absent(&variants[v])\n+                    let mut present_variants = variants.iter_enumerated().filter_map(|(i, v)| {\n+                        if absent(v) {\n+                            None\n+                        } else {\n+                            Some(i)\n+                        }\n                     });\n                     (present_variants.next(), present_variants.next())\n                 };\n@@ -792,16 +798,16 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 // The current code for niche-filling relies on variant indices\n                 // instead of actual discriminants, so dataful enums with\n                 // explicit discriminants (RFC #2363) would misbehave.\n-                let no_explicit_discriminants = def.variants.iter().enumerate()\n-                    .all(|(i, v)| v.discr == ty::VariantDiscr::Relative(i));\n+                let no_explicit_discriminants = def.variants.iter_enumerated()\n+                    .all(|(i, v)| v.discr == ty::VariantDiscr::Relative(i.as_u32()));\n \n                 // Niche-filling enum optimization.\n                 if !def.repr.inhibit_enum_layout_opt() && no_explicit_discriminants {\n                     let mut dataful_variant = None;\n-                    let mut niche_variants = usize::max_value()..=0;\n+                    let mut niche_variants = VariantIdx::MAX..=VariantIdx::new(0);\n \n                     // Find one non-ZST variant.\n-                    'variants: for (v, fields) in variants.iter().enumerate() {\n+                    'variants: for (v, fields) in variants.iter_enumerated() {\n                         if absent(fields) {\n                             continue 'variants;\n                         }\n@@ -824,7 +830,9 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     }\n \n                     if let Some(i) = dataful_variant {\n-                        let count = (niche_variants.end() - niche_variants.start() + 1) as u128;\n+                        let count = (\n+                            niche_variants.end().as_u32() - niche_variants.start().as_u32() + 1\n+                        ) as u128;\n                         for (field_index, &field) in variants[i].iter().enumerate() {\n                             let niche = match self.find_niche(field)? {\n                                 Some(niche) => niche,\n@@ -836,15 +844,15 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                             };\n \n                             let mut align = dl.aggregate_align;\n-                            let st = variants.iter().enumerate().map(|(j, v)| {\n+                            let st = variants.iter_enumerated().map(|(j, v)| {\n                                 let mut st = univariant_uninterned(v,\n                                     &def.repr, StructKind::AlwaysSized)?;\n                                 st.variants = Variants::Single { index: j };\n \n                                 align = align.max(st.align);\n \n                                 Ok(st)\n-                            }).collect::<Result<Vec<_>, _>>()?;\n+                            }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n                             let offset = st[i].fields.offset(field_index) + niche.offset;\n                             let size = st[i].size;\n@@ -899,7 +907,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let (mut min, mut max) = (i128::max_value(), i128::min_value());\n                 let discr_type = def.repr.discr_type();\n                 let bits = Integer::from_attr(self, discr_type).size().bits();\n-                for (i, discr) in def.discriminants(tcx).enumerate() {\n+                for (i, discr) in def.discriminants(tcx) {\n                     if variants[i].iter().any(|f| f.abi.is_uninhabited()) {\n                         continue;\n                     }\n@@ -941,7 +949,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n \n                 // Create the set of structs that represent each variant.\n-                let mut layout_variants = variants.iter().enumerate().map(|(i, field_layouts)| {\n+                let mut layout_variants = variants.iter_enumerated().map(|(i, field_layouts)| {\n                     let mut st = univariant_uninterned(&field_layouts,\n                         &def.repr, StructKind::Prefixed(min_ity.size(), prefix_align))?;\n                     st.variants = Variants::Single { index: i };\n@@ -956,7 +964,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     size = cmp::max(size, st.size);\n                     align = align.max(st.align);\n                     Ok(st)\n-                }).collect::<Result<Vec<_>, _>>()?;\n+                }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n                 // Align the maximum variant size to the largest alignment.\n                 size = size.abi_align(align);\n@@ -1259,7 +1267,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 debug!(\"print-type-size `{:#?}` adt general variants def {}\",\n                        layout.ty, adt_def.variants.len());\n                 let variant_infos: Vec<_> =\n-                    adt_def.variants.iter().enumerate().map(|(i, variant_def)| {\n+                    adt_def.variants.iter_enumerated().map(|(i, variant_def)| {\n                         let fields: Vec<_> =\n                             variant_def.fields.iter().map(|f| f.ident.name).collect();\n                         build_variant_info(Some(variant_def.name),\n@@ -1339,7 +1347,8 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n                 }\n \n                 // Get a zero-sized variant or a pointer newtype.\n-                let zero_or_ptr_variant = |i: usize| {\n+                let zero_or_ptr_variant = |i| {\n+                    let i = VariantIdx::new(i);\n                     let fields = def.variants[i].fields.iter().map(|field| {\n                         SizeSkeleton::compute(field.ty(tcx, substs), tcx, param_env)\n                     });\n@@ -1562,7 +1571,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n     where C: LayoutOf<Ty = Ty<'tcx>> + HasTyCtxt<'tcx>,\n           C::TyLayout: MaybeResult<TyLayout<'tcx>>\n {\n-    fn for_variant(this: TyLayout<'tcx>, cx: &C, variant_index: usize) -> TyLayout<'tcx> {\n+    fn for_variant(this: TyLayout<'tcx>, cx: &C, variant_index: VariantIdx) -> TyLayout<'tcx> {\n         let details = match this.variants {\n             Variants::Single { index } if index == variant_index => this.details,\n \n@@ -1882,6 +1891,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for FieldPlacement {\n     }\n }\n \n+impl<'a> HashStable<StableHashingContext<'a>> for VariantIdx {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n+        self.as_u32().hash_stable(hcx, hasher)\n+    }\n+}\n+\n impl<'a> HashStable<StableHashingContext<'a>> for Abi {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,"}, {"sha": "83feadd50d77fa4e15b3b55feb5e8a8ad391ec3e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -32,6 +32,7 @@ use mir::GeneratorLayout;\n use session::CrateDisambiguator;\n use traits::{self, Reveal};\n use ty;\n+use ty::layout::VariantIdx;\n use ty::subst::{Subst, Substs};\n use ty::util::{IntTypeExt, Discr};\n use ty::walk::TypeWalker;\n@@ -57,7 +58,7 @@ use syntax::symbol::{keywords, Symbol, LocalInternedString, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n use smallvec;\n-use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n \n@@ -1785,7 +1786,7 @@ pub enum VariantDiscr {\n     /// For efficiency reasons, the distance from the\n     /// last `Explicit` discriminant is being stored,\n     /// or `0` for the first variant, if it has none.\n-    Relative(usize),\n+    Relative(u32),\n }\n \n #[derive(Debug)]\n@@ -1801,7 +1802,7 @@ pub struct FieldDef {\n /// table.\n pub struct AdtDef {\n     pub did: DefId,\n-    pub variants: Vec<VariantDef>,\n+    pub variants: IndexVec<self::layout::VariantIdx, VariantDef>,\n     flags: AdtFlags,\n     pub repr: ReprOptions,\n }\n@@ -1999,7 +2000,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     fn new(tcx: TyCtxt<'_, '_, '_>,\n            did: DefId,\n            kind: AdtKind,\n-           variants: Vec<VariantDef>,\n+           variants: IndexVec<VariantIdx, VariantDef>,\n            repr: ReprOptions) -> Self {\n         debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n@@ -2121,7 +2122,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Asserts this is a struct or union and returns its unique variant.\n     pub fn non_enum_variant(&self) -> &VariantDef {\n         assert!(self.is_struct() || self.is_union());\n-        &self.variants[0]\n+        &self.variants[VariantIdx::new(0)]\n     }\n \n     #[inline]\n@@ -2148,11 +2149,12 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             .expect(\"variant_with_id: unknown variant\")\n     }\n \n-    pub fn variant_index_with_id(&self, vid: DefId) -> usize {\n+    pub fn variant_index_with_id(&self, vid: DefId) -> VariantIdx {\n         self.variants\n-            .iter()\n-            .position(|v| v.did == vid)\n+            .iter_enumerated()\n+            .find(|(_, v)| v.did == vid)\n             .expect(\"variant_index_with_id: unknown variant\")\n+            .0\n     }\n \n     pub fn variant_of_def(&self, def: Def) -> &VariantDef {\n@@ -2216,11 +2218,11 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     pub fn discriminants(\n         &'a self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    ) -> impl Iterator<Item=Discr<'tcx>> + Captures<'gcx> + 'a {\n+    ) -> impl Iterator<Item=(VariantIdx, Discr<'tcx>)> + Captures<'gcx> + 'a {\n         let repr_type = self.repr.discr_type();\n         let initial = repr_type.initial_discriminant(tcx.global_tcx());\n         let mut prev_discr = None::<Discr<'tcx>>;\n-        self.variants.iter().map(move |v| {\n+        self.variants.iter_enumerated().map(move |(i, v)| {\n             let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n                 if let Some(new_discr) = self.eval_explicit_discr(tcx, expr_did) {\n@@ -2229,7 +2231,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             }\n             prev_discr = Some(discr);\n \n-            discr\n+            (i, discr)\n         })\n     }\n \n@@ -2240,7 +2242,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// assuming there are no constant-evaluation errors there.\n     pub fn discriminant_for_variant(&self,\n                                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                    variant_index: usize)\n+                                    variant_index: VariantIdx)\n                                     -> Discr<'tcx> {\n         let (val, offset) = self.discriminant_def_for_variant(variant_index);\n         let explicit_value = val\n@@ -2254,12 +2256,12 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// inferred discriminant directly\n     pub fn discriminant_def_for_variant(\n         &self,\n-        variant_index: usize,\n-    ) -> (Option<DefId>, usize) {\n-        let mut explicit_index = variant_index;\n+        variant_index: VariantIdx,\n+    ) -> (Option<DefId>, u32) {\n+        let mut explicit_index = variant_index.as_u32();\n         let expr_did;\n         loop {\n-            match self.variants[explicit_index].discr {\n+            match self.variants[VariantIdx::from_u32(explicit_index)].discr {\n                 ty::VariantDiscr::Relative(0) => {\n                     expr_did = None;\n                     break;\n@@ -2273,7 +2275,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 }\n             }\n         }\n-        (expr_did, variant_index - explicit_index)\n+        (expr_did, variant_index.as_u32() - explicit_index)\n     }\n \n     pub fn destructor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Destructor> {"}, {"sha": "e92f92dce63d06e3bd3df0c6850170110cc2a0cd", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -33,6 +33,7 @@ CloneTypeFoldableAndLiftImpls! {\n     (),\n     bool,\n     usize,\n+    ::ty::layout::VariantIdx,\n     u64,\n     ::middle::region::Scope,\n     ::syntax::ast::FloatTy,"}, {"sha": "821b074cd68c6925f63f8bbb15cb8979cb1d67ac", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -39,7 +39,7 @@ use rustc::middle::weak_lang_items;\n use rustc::mir::mono::{Linkage, Visibility, Stats, CodegenUnitNameBuilder};\n use rustc::middle::cstore::{EncodedMetadata};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{self, Align, TyLayout, LayoutOf};\n+use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty::query::Providers;\n use rustc::middle::cstore::{self, LinkagePreference};\n use rustc::middle::exported_symbols;\n@@ -73,6 +73,7 @@ use rustc::util::nodemap::FxHashMap;\n use CrateInfo;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::indexed_vec::Idx;\n \n use std::any::Any;\n use std::cmp;\n@@ -309,7 +310,7 @@ pub fn coerce_unsized_into(\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n-            for i in 0..def_a.variants[0].fields.len() {\n+            for i in 0..def_a.variants[VariantIdx::new(0)].fields.len() {\n                 let src_f = src.project_field(bx, i);\n                 let dst_f = dst.project_field(bx, i);\n "}, {"sha": "d6fd069071548cf2b259479923d44417ba215893", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -29,7 +29,7 @@ use rustc_data_structures::small_c_str::SmallCStr;\n use rustc::mir::mono::Stats;\n use rustc::session::config::{self, DebugInfo};\n use rustc::session::Session;\n-use rustc::ty::layout::{LayoutError, LayoutOf, Size, TyLayout};\n+use rustc::ty::layout::{LayoutError, LayoutOf, Size, TyLayout, VariantIdx};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n use rustc_target::spec::{HasTargetSpec, Target};\n@@ -87,7 +87,7 @@ pub struct CodegenCx<'a, 'tcx: 'a> {\n     /// See http://llvm.org/docs/LangRef.html#the-llvm-used-global-variable for details\n     pub used_statics: RefCell<Vec<&'a Value>>,\n \n-    pub lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), &'a Type>>,\n+    pub lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<VariantIdx>), &'a Type>>,\n     pub scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, &'a Type>>,\n     pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n     pub isize_ty: &'a Type,"}, {"sha": "97a3ae9c9faf4e534956892826d4026d241bbed0", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -1241,7 +1241,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     // This doesn't matter in this case.\n                     NoDiscriminant\n                 };\n-                (0..variants.len()).map(|i| {\n+                variants.iter_enumerated().map(|(i, _)| {\n                     let variant = self.layout.for_variant(cx, i);\n                     let (variant_type_metadata, member_desc_factory) =\n                         describe_enum_variant(cx,\n@@ -1341,7 +1341,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         }\n                     ]\n                 } else {\n-                    (0..variants.len()).map(|i| {\n+                    variants.iter_enumerated().map(|(i, _)| {\n                         let variant = self.layout.for_variant(cx, i);\n                         let (variant_type_metadata, member_desc_factory) =\n                             describe_enum_variant(cx,\n@@ -1361,8 +1361,8 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         let niche_value = if i == dataful_variant {\n                             None\n                         } else {\n-                            let value = (i as u128)\n-                                .wrapping_sub(*niche_variants.start() as u128)\n+                            let value = (i.as_u32() as u128)\n+                                .wrapping_sub(niche_variants.start().as_u32() as u128)\n                                 .wrapping_add(niche_start);\n                             let value = value & ((1u128 << niche.value.size(cx).bits()) - 1);\n                             Some(value as u64)\n@@ -1530,7 +1530,7 @@ fn prepare_enum_metadata(\n         let def = enum_type.ty_adt_def().unwrap();\n         let enumerators_metadata: Vec<_> = def.discriminants(cx.tcx)\n             .zip(&def.variants)\n-            .map(|(discr, v)| {\n+            .map(|((_, discr), v)| {\n                 let name = SmallCStr::new(&v.name.as_str());\n                 unsafe {\n                     Some(llvm::LLVMRustDIBuilderCreateEnumerator("}, {"sha": "75ec5ead243f9a00bf4f70fbea73189d80358c74", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::{self, LLVMConstInBoundsGEP};\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, Size};\n+use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, Size, VariantIdx};\n use rustc::mir;\n use rustc::mir::tcx::PlaceTy;\n use base;\n@@ -281,7 +281,7 @@ impl PlaceRef<'ll, 'tcx> {\n         match self.layout.variants {\n             layout::Variants::Single { index } => {\n                 let discr_val = self.layout.ty.ty_adt_def().map_or(\n-                    index as u128,\n+                    index.as_u32() as u128,\n                     |def| def.discriminant_for_variant(bx.cx.tcx, index).val);\n                 return C_uint_big(cast_to, discr_val);\n             }\n@@ -320,24 +320,24 @@ impl PlaceRef<'ll, 'tcx> {\n                         C_uint_big(niche_llty, niche_start)\n                     };\n                     bx.select(bx.icmp(llvm::IntEQ, lldiscr, niche_llval),\n-                        C_uint(cast_to, *niche_variants.start() as u64),\n-                        C_uint(cast_to, dataful_variant as u64))\n+                        C_uint(cast_to, niche_variants.start().as_u32() as u64),\n+                        C_uint(cast_to, dataful_variant.as_u32() as u64))\n                 } else {\n                     // Rebase from niche values to discriminant values.\n-                    let delta = niche_start.wrapping_sub(*niche_variants.start() as u128);\n+                    let delta = niche_start.wrapping_sub(niche_variants.start().as_u32() as u128);\n                     let lldiscr = bx.sub(lldiscr, C_uint_big(niche_llty, delta));\n-                    let lldiscr_max = C_uint(niche_llty, *niche_variants.end() as u64);\n+                    let lldiscr_max = C_uint(niche_llty, niche_variants.end().as_u32() as u64);\n                     bx.select(bx.icmp(llvm::IntULE, lldiscr, lldiscr_max),\n                         bx.intcast(lldiscr, cast_to, false),\n-                        C_uint(cast_to, dataful_variant as u64))\n+                        C_uint(cast_to, dataful_variant.as_u32() as u64))\n                 }\n             }\n         }\n     }\n \n     /// Set the discriminant for a new value of the given case of the given\n     /// representation.\n-    pub fn codegen_set_discr(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: usize) {\n+    pub fn codegen_set_discr(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: VariantIdx) {\n         if self.layout.for_variant(bx.cx, variant_index).abi.is_uninhabited() {\n             return;\n         }\n@@ -376,7 +376,8 @@ impl PlaceRef<'ll, 'tcx> {\n \n                     let niche = self.project_field(bx, 0);\n                     let niche_llty = niche.layout.immediate_llvm_type(bx.cx);\n-                    let niche_value = ((variant_index - *niche_variants.start()) as u128)\n+                    let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n+                    let niche_value = (niche_value as u128)\n                         .wrapping_add(niche_start);\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_value == 0 {\n@@ -401,7 +402,7 @@ impl PlaceRef<'ll, 'tcx> {\n         }\n     }\n \n-    pub fn project_downcast(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: usize)\n+    pub fn project_downcast(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: VariantIdx)\n                             -> PlaceRef<'ll, 'tcx> {\n         let mut downcast = *self;\n         downcast.layout = self.layout.for_variant(bx.cx, variant_index);"}, {"sha": "fe197e3e2e28caf72d3a4c69e24d97c5cfd20a3d", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -16,3 +16,4 @@ rustc_mir = { path = \"../librustc_mir\"}\n rustc_target = { path = \"../librustc_target\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "57cbecb5c67be31333e7582b493f26f580f42f5b", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -40,6 +40,7 @@ extern crate log;\n extern crate rustc_mir;\n extern crate rustc_target;\n extern crate syntax_pos;\n+extern crate rustc_data_structures;\n \n use rustc::lint;\n use rustc::lint::{LateContext, LateLintPass, LintPass, LintArray};"}, {"sha": "0e2d041b1ffdb72e1cc48bf9b4051db0bf0d1f2f", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -13,7 +13,8 @@\n use rustc::hir::Node;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n-use rustc::ty::layout::{self, IntegerExt, LayoutOf};\n+use rustc::ty::layout::{self, IntegerExt, LayoutOf, VariantIdx};\n+use rustc_data_structures::indexed_vec::Idx;\n use util::nodemap::FxHashSet;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n@@ -452,10 +453,13 @@ fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if def.variants.len() == 2 {\n         let data_idx;\n \n-        if def.variants[0].fields.is_empty() {\n-            data_idx = 1;\n-        } else if def.variants[1].fields.is_empty() {\n-            data_idx = 0;\n+        let zero = VariantIdx::new(0);\n+        let one = VariantIdx::new(1);\n+\n+        if def.variants[zero].fields.is_empty() {\n+            data_idx = one;\n+        } else if def.variants[one].fields.is_empty() {\n+            data_idx = zero;\n         } else {\n             return false;\n         }"}, {"sha": "1c7e3c95d147058bbc8a0871ff1c1199eef05f3e", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -601,7 +601,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 })\n                 .collect()\n         } else {\n-            vec![self.get_variant(tcx, &item, item_id, kind)]\n+            std::iter::once(self.get_variant(tcx, &item, item_id, kind)).collect()\n         };\n \n         tcx.alloc_adt_def(did, kind, variants, repr)"}, {"sha": "5421972a4adcbd528803a1e11dbb1bca44796f86", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -27,6 +27,7 @@ use rustc::mir::{self, interpret};\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt, ReprOptions, SymbolName};\n use rustc::ty::codec::{self as ty_codec, TyEncoder};\n+use rustc::ty::layout::VariantIdx;\n \n use rustc::session::config::{self, CrateType};\n use rustc::util::nodemap::FxHashMap;\n@@ -580,7 +581,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     /// the right to access any information in the adt-def (including,\n     /// e.g., the length of the various vectors).\n     fn encode_enum_variant_info(&mut self,\n-                                (enum_did, Untracked(index)): (DefId, Untracked<usize>))\n+                                (enum_did, Untracked(index)): (DefId, Untracked<VariantIdx>))\n                                 -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def = tcx.adt_def(enum_did);\n@@ -675,7 +676,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     /// vectors).\n     fn encode_field(&mut self,\n                     (adt_def_id, Untracked((variant_index, field_index))): (DefId,\n-                                                                            Untracked<(usize,\n+                                                                            Untracked<(VariantIdx,\n                                                                                        usize)>))\n                     -> Entry<'tcx> {\n         let tcx = self.tcx;\n@@ -1667,7 +1668,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_fields(&mut self, adt_def_id: DefId) {\n         let def = self.tcx.adt_def(adt_def_id);\n-        for (variant_index, variant) in def.variants.iter().enumerate() {\n+        for (variant_index, variant) in def.variants.iter_enumerated() {\n             for (field_index, field) in variant.fields.iter().enumerate() {\n                 self.record(field.did,\n                             IsolatedEncoder::encode_field,\n@@ -1734,7 +1735,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 self.encode_fields(def_id);\n \n                 let def = self.tcx.adt_def(def_id);\n-                for (i, variant) in def.variants.iter().enumerate() {\n+                for (i, variant) in def.variants.iter_enumerated() {\n                     self.record(variant.did,\n                                 IsolatedEncoder::encode_enum_variant_info,\n                                 (def_id, Untracked(i)));"}, {"sha": "c8d2bcd8b931543324a5786bc4524f4e826f768a", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -47,7 +47,8 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc::ty::layout::VariantIdx;\n use std::rc::Rc;\n use std::{fmt, iter};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -574,7 +575,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             },\n             ProjectionElem::Downcast(adt_def1, index) => match base_ty.sty {\n                 ty::Adt(adt_def, substs) if adt_def.is_enum() && adt_def == adt_def1 => {\n-                    if index >= adt_def.variants.len() {\n+                    if index.as_usize() >= adt_def.variants.len() {\n                         PlaceTy::Ty {\n                             ty: span_mirbug_and_err!(\n                                 self,\n@@ -654,7 +655,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 variant_index,\n             } => (&adt_def.variants[variant_index], substs),\n             PlaceTy::Ty { ty } => match ty.sty {\n-                ty::Adt(adt_def, substs) if !adt_def.is_enum() => (&adt_def.variants[0], substs),\n+                ty::Adt(adt_def, substs) if !adt_def.is_enum() =>\n+                    (&adt_def.variants[VariantIdx::new(0)], substs),\n                 ty::Closure(def_id, substs) => {\n                     return match substs.upvar_tys(def_id, tcx).nth(field.index()) {\n                         Some(ty) => Ok(ty),\n@@ -1280,7 +1282,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         );\n                     }\n                 };\n-                if variant_index >= adt.variants.len() {\n+                if variant_index.as_usize() >= adt.variants.len() {\n                     span_bug!(\n                         stmt.source_info.span,\n                         \"bad set discriminant ({:?} = {:?}): value of of range\","}, {"sha": "342aaf9039d1001f9b3b7c1291abeda82037933f", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -22,6 +22,7 @@ use hair::pattern::PatternTypeProjections;\n use rustc::hir;\n use rustc::mir::*;\n use rustc::ty::{self, Ty};\n+use rustc::ty::layout::VariantIdx;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::{Name, NodeId};\n@@ -663,7 +664,7 @@ enum TestKind<'tcx> {\n     // test the branches of enum\n     Switch {\n         adt_def: &'tcx ty::AdtDef,\n-        variants: BitSet<usize>,\n+        variants: BitSet<VariantIdx>,\n     },\n \n     // test the branches of enum"}, {"sha": "cfea357334fa81eff56daff3fef8cc728e39db61", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             PatternKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n-                let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n+                let irrefutable = adt_def.variants.iter_enumerated().all(|(i, v)| {\n                     i == variant_index || {\n                         self.hir.tcx().features().never_type &&\n                         self.hir.tcx().features().exhaustive_patterns &&"}, {"sha": "177c71b80d1f5284065d159185fff13f63a7f9e9", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -22,6 +22,7 @@ use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::FxHashMap;\n use rustc::ty::{self, Ty};\n use rustc::ty::util::IntTypeExt;\n+use rustc::ty::layout::VariantIdx;\n use rustc::mir::*;\n use rustc::hir::{RangeEnd, Mutability};\n use syntax_pos::Span;\n@@ -152,7 +153,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn add_variants_to_switch<'pat>(&mut self,\n                                         test_place: &Place<'tcx>,\n                                         candidate: &Candidate<'pat, 'tcx>,\n-                                        variants: &mut BitSet<usize>)\n+                                        variants: &mut BitSet<VariantIdx>)\n                                         -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.place == *test_place) {\n@@ -196,7 +197,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let mut targets = Vec::with_capacity(used_variants + 1);\n                 let mut values = Vec::with_capacity(used_variants);\n                 let tcx = self.hir.tcx();\n-                for (idx, discr) in adt_def.discriminants(tcx).enumerate() {\n+                for (idx, discr) in adt_def.discriminants(tcx) {\n                     target_blocks.push(if variants.contains(idx) {\n                         values.push(discr.val);\n                         targets.push(self.cfg.start_new_block());\n@@ -512,7 +513,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                                         variant_index,\n                                                         subpatterns,\n                                                         candidate);\n-                resulting_candidates[variant_index].push(new_candidate);\n+                resulting_candidates[variant_index.as_usize()].push(new_candidate);\n                 true\n             }\n             (&TestKind::Switch { .. }, _) => false,\n@@ -673,7 +674,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn candidate_after_variant_switch<'pat>(&mut self,\n                                             match_pair_index: usize,\n                                             adt_def: &'tcx ty::AdtDef,\n-                                            variant_index: usize,\n+                                            variant_index: VariantIdx,\n                                             subpatterns: &'pat [FieldPattern<'tcx>],\n                                             candidate: &Candidate<'pat, 'tcx>)\n                                             -> Candidate<'pat, 'tcx> {"}, {"sha": "a87660db2d313b1dcb809433cc11d960778f1750", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -13,6 +13,7 @@ use build::matches::MatchPair;\n use hair::*;\n use rustc::mir::*;\n use std::u32;\n+use std::convert::TryInto;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn field_match_pairs<'pat>(&mut self,\n@@ -35,8 +36,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      opt_slice: Option<&'pat Pattern<'tcx>>,\n                                      suffix: &'pat [Pattern<'tcx>]) {\n         let min_length = prefix.len() + suffix.len();\n-        assert!(min_length < u32::MAX as usize);\n-        let min_length = min_length as u32;\n+        let min_length = min_length.try_into().unwrap();\n \n         match_pairs.extend(\n             prefix.iter()"}, {"sha": "222920f1ad65ad374787c420a2cbc8b61f55ce09", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -21,7 +21,7 @@ use rustc::hir::def::Def;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, Instance, query::TyCtxtAt};\n-use rustc::ty::layout::{self, LayoutOf, TyLayout};\n+use rustc::ty::layout::{self, LayoutOf, TyLayout, VariantIdx};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -481,7 +481,7 @@ pub fn const_field<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     instance: ty::Instance<'tcx>,\n-    variant: Option<usize>,\n+    variant: Option<VariantIdx>,\n     field: mir::Field,\n     value: &'tcx ty::Const<'tcx>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n@@ -513,7 +513,7 @@ pub fn const_variant_index<'a, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     instance: ty::Instance<'tcx>,\n     val: &'tcx ty::Const<'tcx>,\n-) -> EvalResult<'tcx, usize> {\n+) -> EvalResult<'tcx, VariantIdx> {\n     trace!(\"const_variant_index: {:?}, {:?}\", instance, val);\n     let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let op = ecx.const_to_op(val)?;"}, {"sha": "656a467fb4912827fb5f560e73afcacbbea622f3", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -284,7 +284,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n                             }\n                             Def::StructCtor(_, CtorKind::Fn) |\n-                            Def::SelfCtor(..) => Some((adt_def, 0)),\n+                            Def::SelfCtor(..) => Some((adt_def, VariantIdx::new(0))),\n                             _ => None,\n                         }\n                     })\n@@ -468,7 +468,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         AdtKind::Struct | AdtKind::Union => {\n                             ExprKind::Adt {\n                                 adt_def: adt,\n-                                variant_index: 0,\n+                                variant_index: VariantIdx::new(0),\n                                 substs,\n                                 user_ty: cx.user_substs_applied_to_adt(expr.hir_id, adt),\n                                 fields: field_refs(cx, fields),"}, {"sha": "733580b3ce2fd4acfd8c7beb64807012651724e4", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -25,6 +25,7 @@ use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Substs};\n+use rustc::ty::layout::VariantIdx;\n use syntax::ast::{self, LitKind};\n use syntax::attr;\n use syntax::symbol::Symbol;\n@@ -228,7 +229,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         bug!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id);\n     }\n \n-    pub fn all_fields(&mut self, adt_def: &ty::AdtDef, variant_index: usize) -> Vec<Field> {\n+    pub fn all_fields(&mut self, adt_def: &ty::AdtDef, variant_index: VariantIdx) -> Vec<Field> {\n         (0..adt_def.variants[variant_index].fields.len())\n             .map(Field::new)\n             .collect()"}, {"sha": "460afba38d67427aa231f1c62d0ff92c17731a49", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -19,6 +19,7 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n use rustc::ty::subst::Substs;\n use rustc::ty::{AdtDef, UpvarSubsts, Region, Ty, Const};\n+use rustc::ty::layout::VariantIdx;\n use rustc::hir;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -264,7 +265,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Adt {\n         adt_def: &'tcx AdtDef,\n-        variant_index: usize,\n+        variant_index: VariantIdx,\n         substs: &'tcx Substs<'tcx>,\n \n         /// Optional user-given substs: for something like `let x ="}, {"sha": "08736330acbe72b46d23d1a0a5ae701b9d0ac610", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -179,7 +179,7 @@ use super::{PatternFoldable, PatternFolder, compare_const_vals};\n use rustc::hir::def_id::DefId;\n use rustc::hir::RangeEnd;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::layout::{Integer, IntegerExt};\n+use rustc::ty::layout::{Integer, IntegerExt, VariantIdx};\n \n use rustc::mir::Field;\n use rustc::mir::interpret::ConstValue;\n@@ -422,12 +422,12 @@ pub enum Constructor<'tcx> {\n }\n \n impl<'tcx> Constructor<'tcx> {\n-    fn variant_index_for_adt(&self, adt: &'tcx ty::AdtDef) -> usize {\n+    fn variant_index_for_adt(&self, adt: &'tcx ty::AdtDef) -> VariantIdx {\n         match self {\n             &Variant(vid) => adt.variant_index_with_id(vid),\n             &Single => {\n                 assert!(!adt.is_enum());\n-                0\n+                VariantIdx::new(0)\n             }\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt)\n         }"}, {"sha": "941744c0aab7cc285c1e8bfd5a8173fede1933f5", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -25,6 +25,7 @@ use rustc::mir::{ProjectionElem, UserTypeAnnotation, UserTypeProjection, UserTyp\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty};\n use rustc::ty::subst::{Substs, Kind};\n+use rustc::ty::layout::VariantIdx;\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n@@ -111,7 +112,7 @@ impl<'tcx> PatternTypeProjections<'tcx> {\n \n     pub(crate) fn variant(&self,\n                           adt_def: &'tcx AdtDef,\n-                          variant_index: usize,\n+                          variant_index: VariantIdx,\n                           field: Field) -> Self {\n         self.map_projs(|pat_ty_proj| pat_ty_proj.variant(adt_def, variant_index, field))\n     }\n@@ -153,7 +154,7 @@ impl<'tcx> PatternTypeProjection<'tcx> {\n \n     pub(crate) fn variant(&self,\n                           adt_def: &'tcx AdtDef,\n-                          variant_index: usize,\n+                          variant_index: VariantIdx,\n                           field: Field) -> Self {\n         let mut new = self.clone();\n         new.0.projs.push(ProjectionElem::Downcast(adt_def, variant_index));\n@@ -200,7 +201,7 @@ pub enum PatternKind<'tcx> {\n     Variant {\n         adt_def: &'tcx AdtDef,\n         substs: &'tcx Substs<'tcx>,\n-        variant_index: usize,\n+        variant_index: VariantIdx,\n         subpatterns: Vec<FieldPattern<'tcx>>,\n     },\n \n@@ -273,7 +274,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                     }\n                     _ => if let ty::Adt(adt, _) = self.ty.sty {\n                         if !adt.is_enum() {\n-                            Some(&adt.variants[0])\n+                            Some(&adt.variants[VariantIdx::new(0)])\n                         } else {\n                             None\n                         }\n@@ -1160,7 +1161,7 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n             } => PatternKind::Variant {\n                 adt_def: adt_def.fold_with(folder),\n                 substs: substs.fold_with(folder),\n-                variant_index: variant_index.fold_with(folder),\n+                variant_index,\n                 subpatterns: subpatterns.fold_with(folder)\n             },\n             PatternKind::Leaf {"}, {"sha": "402632ef46a542ea4a5ff811af6845d3411f4fbd", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -14,7 +14,7 @@\n use std::convert::TryInto;\n \n use rustc::{mir, ty};\n-use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt};\n+use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt, VariantIdx};\n \n use rustc::mir::interpret::{\n     GlobalId, AllocId,\n@@ -417,7 +417,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub fn operand_downcast(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n-        variant: usize,\n+        variant: VariantIdx,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n         Ok(match op.try_as_mplace() {\n@@ -596,13 +596,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub fn read_discriminant(\n         &self,\n         rval: OpTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, (u128, usize)> {\n+    ) -> EvalResult<'tcx, (u128, VariantIdx)> {\n         trace!(\"read_discriminant_value {:#?}\", rval.layout);\n \n         match rval.layout.variants {\n             layout::Variants::Single { index } => {\n                 let discr_val = rval.layout.ty.ty_adt_def().map_or(\n-                    index as u128,\n+                    index.as_u32() as u128,\n                     |def| def.discriminant_for_variant(*self.tcx, index).val);\n                 return Ok((discr_val, index));\n             }\n@@ -645,43 +645,42 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     .ty_adt_def()\n                     .expect(\"tagged layout for non adt\")\n                     .discriminants(self.tcx.tcx)\n-                    .position(|var| var.val == real_discr)\n+                    .find(|(_, var)| var.val == real_discr)\n                     .ok_or_else(|| EvalErrorKind::InvalidDiscriminant(raw_discr.erase_tag()))?;\n-                (real_discr, index)\n+                (real_discr, index.0)\n             },\n             layout::Variants::NicheFilling {\n                 dataful_variant,\n                 ref niche_variants,\n                 niche_start,\n                 ..\n             } => {\n-                let variants_start = *niche_variants.start() as u128;\n-                let variants_end = *niche_variants.end() as u128;\n-                let real_discr = match raw_discr {\n+                let variants_start = niche_variants.start().as_u32() as u128;\n+                let variants_end = niche_variants.end().as_u32() as u128;\n+                match raw_discr {\n                     Scalar::Ptr(_) => {\n                         // The niche must be just 0 (which a pointer value never is)\n                         assert!(niche_start == 0);\n                         assert!(variants_start == variants_end);\n-                        dataful_variant as u128\n+                        (dataful_variant.as_u32() as u128, dataful_variant)\n                     },\n                     Scalar::Bits { bits: raw_discr, size } => {\n                         assert_eq!(size as u64, discr_val.layout.size.bytes());\n                         let discr = raw_discr.wrapping_sub(niche_start)\n                             .wrapping_add(variants_start);\n                         if variants_start <= discr && discr <= variants_end {\n-                            discr\n+                            let index = discr as usize;\n+                            assert_eq!(index as u128, discr);\n+                            assert!(index < rval.layout.ty\n+                                .ty_adt_def()\n+                                .expect(\"tagged layout for non adt\")\n+                                .variants.len());\n+                            (discr, VariantIdx::from_usize(index))\n                         } else {\n-                            dataful_variant as u128\n+                            (dataful_variant.as_u32() as u128, dataful_variant)\n                         }\n                     },\n-                };\n-                let index = real_discr as usize;\n-                assert_eq!(index as u128, real_discr);\n-                assert!(index < rval.layout.ty\n-                    .ty_adt_def()\n-                    .expect(\"tagged layout for non adt\")\n-                    .variants.len());\n-                (real_discr, index)\n+                }\n             }\n         })\n     }"}, {"sha": "c9ec83a7adb2789f538f8f51b2d11d5cf13c7513", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -18,7 +18,7 @@ use std::hash::Hash;\n use rustc::hir;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout};\n+use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx};\n \n use rustc::mir::interpret::{\n     GlobalId, AllocId, Allocation, Scalar, EvalResult, Pointer, PointerArithmetic\n@@ -431,7 +431,7 @@ where\n     pub fn mplace_downcast(\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n-        variant: usize,\n+        variant: VariantIdx,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n         assert!(base.meta.is_none());\n@@ -498,7 +498,7 @@ where\n     pub fn place_downcast(\n         &self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n-        variant: usize,\n+        variant: VariantIdx,\n     ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // Downcast just changes the layout\n         Ok(match base.place {\n@@ -901,7 +901,7 @@ where\n \n     pub fn write_discriminant_index(\n         &mut self,\n-        variant_index: usize,\n+        variant_index: VariantIdx,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         match dest.layout.variants {\n@@ -910,7 +910,7 @@ where\n             }\n             layout::Variants::Tagged { ref tag, .. } => {\n                 let adt_def = dest.layout.ty.ty_adt_def().unwrap();\n-                assert!(variant_index < adt_def.variants.len());\n+                assert!(variant_index.as_usize() < adt_def.variants.len());\n                 let discr_val = adt_def\n                     .discriminant_for_variant(*self.tcx, variant_index)\n                     .val;\n@@ -931,11 +931,14 @@ where\n                 niche_start,\n                 ..\n             } => {\n-                assert!(variant_index < dest.layout.ty.ty_adt_def().unwrap().variants.len());\n+                assert!(\n+                    variant_index.as_usize() < dest.layout.ty.ty_adt_def().unwrap().variants.len(),\n+                );\n                 if variant_index != dataful_variant {\n                     let niche_dest =\n                         self.place_field(dest, 0)?;\n-                    let niche_value = ((variant_index - niche_variants.start()) as u128)\n+                    let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n+                    let niche_value = (niche_value as u128)\n                         .wrapping_add(niche_start);\n                     self.write_scalar(\n                         Scalar::from_uint(niche_value, niche_dest.layout.size),"}, {"sha": "3d00dce8b0428f51d403e09b56d92b9e8b336598", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -13,7 +13,7 @@ use std::hash::Hash;\n use std::ops::RangeInclusive;\n \n use syntax_pos::symbol::Symbol;\n-use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf};\n+use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n@@ -74,6 +74,7 @@ macro_rules! try_validation {\n #[derive(Copy, Clone, Debug)]\n pub enum PathElem {\n     Field(Symbol),\n+    Variant(Symbol),\n     ClosureVar(Symbol),\n     ArrayElem(usize),\n     TupleElem(usize),\n@@ -107,6 +108,7 @@ fn path_format(path: &Vec<PathElem>) -> String {\n     for elem in path.iter() {\n         match elem {\n             Field(name) => write!(out, \".{}\", name),\n+            Variant(name) => write!(out, \".<downcast-variant({})>\", name),\n             ClosureVar(name) => write!(out, \".<closure-var({})>\", name),\n             TupleElem(idx) => write!(out, \".{}\", idx),\n             ArrayElem(idx) => write!(out, \"[{}]\", idx),\n@@ -165,12 +167,12 @@ struct ValidityVisitor<'rt, 'a: 'rt, 'mir: 'rt, 'tcx: 'a+'rt+'mir, M: Machine<'a\n }\n \n impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, 'mir, 'tcx, M> {\n-    fn push_aggregate_field_path_elem(\n+    fn aggregate_field_path_elem(\n         &mut self,\n         layout: TyLayout<'tcx>,\n         field: usize,\n-    ) {\n-        let elem = match layout.ty.sty {\n+    ) -> PathElem {\n+        match layout.ty.sty {\n             // generators and closures.\n             ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                 if let Some(upvar) = self.ecx.tcx.optimized_mir(def_id).upvar_decls.get(field) {\n@@ -192,9 +194,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, '\n                     layout::Variants::Single { index } =>\n                         // Inside a variant\n                         PathElem::Field(def.variants[index].fields[field].ident.name),\n-                    _ =>\n-                        // To a variant\n-                        PathElem::Field(def.variants[field].name)\n+                    _ => bug!(),\n                 }\n             }\n \n@@ -209,8 +209,22 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, '\n \n             // nothing else has an aggregate layout\n             _ => bug!(\"aggregate_field_path_elem: got non-aggregate type {:?}\", layout.ty),\n-        };\n+        }\n+    }\n+\n+    fn visit_elem(\n+        &mut self,\n+        new_op: OpTy<'tcx, M::PointerTag>,\n+        elem: PathElem,\n+    ) -> EvalResult<'tcx> {\n+        // Remember the old state\n+        let path_len = self.path.len();\n+        // Perform operation\n         self.path.push(elem);\n+        self.visit_value(new_op)?;\n+        // Undo changes\n+        self.path.truncate(path_len);\n+        Ok(())\n     }\n }\n \n@@ -231,14 +245,19 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         field: usize,\n         new_op: OpTy<'tcx, M::PointerTag>\n     ) -> EvalResult<'tcx> {\n-        // Remember the old state\n-        let path_len = self.path.len();\n-        // Perform operation\n-        self.push_aggregate_field_path_elem(old_op.layout, field);\n-        self.visit_value(new_op)?;\n-        // Undo changes\n-        self.path.truncate(path_len);\n-        Ok(())\n+        let elem = self.aggregate_field_path_elem(old_op.layout, field);\n+        self.visit_elem(new_op, elem)\n+    }\n+\n+    #[inline]\n+    fn visit_variant(\n+        &mut self,\n+        old_op: OpTy<'tcx, M::PointerTag>,\n+        variant_id: VariantIdx,\n+        new_op: OpTy<'tcx, M::PointerTag>\n+    ) -> EvalResult<'tcx> {\n+        let name = old_op.layout.ty.ty_adt_def().unwrap().variants[variant_id].name;\n+        self.visit_elem(new_op, PathElem::Variant(name))\n     }\n \n     #[inline]"}, {"sha": "4a470456432533fb1a13f4835508fe07a709385c", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -1,7 +1,7 @@\n //! Visitor for a run-time value with a given layout: Traverse enums, structs and other compound\n //! types until we arrive at the leaves, with custom handling for primitive types.\n \n-use rustc::ty::layout::{self, TyLayout};\n+use rustc::ty::layout::{self, TyLayout, VariantIdx};\n use rustc::ty;\n use rustc::mir::interpret::{\n     EvalResult,\n@@ -32,7 +32,7 @@ pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n     fn project_downcast(\n         self,\n         ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n-        variant: usize,\n+        variant: VariantIdx,\n     ) -> EvalResult<'tcx, Self>;\n \n     /// Project to the n-th field.\n@@ -70,7 +70,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     fn project_downcast(\n         self,\n         ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n-        variant: usize,\n+        variant: VariantIdx,\n     ) -> EvalResult<'tcx, Self> {\n         ecx.operand_downcast(self, variant)\n     }\n@@ -109,7 +109,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     fn project_downcast(\n         self,\n         ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n-        variant: usize,\n+        variant: VariantIdx,\n     ) -> EvalResult<'tcx, Self> {\n         ecx.mplace_downcast(self, variant)\n     }\n@@ -171,6 +171,16 @@ macro_rules! make_value_visitor {\n                 self.visit_value(new_val)\n             }\n \n+            #[inline(always)]\n+            fn visit_variant(\n+                &mut self,\n+                _old_val: Self::V,\n+                _variant: VariantIdx,\n+                new_val: Self::V,\n+            ) -> EvalResult<'tcx> {\n+                self.visit_value(new_val)\n+            }\n+\n             /// Called whenever we reach a value with uninhabited layout.\n             /// Recursing to fields will *always* continue after this!  This is not meant to control\n             /// whether and how we descend recursively/ into the scalar's fields if there are any,\n@@ -221,7 +231,7 @@ macro_rules! make_value_visitor {\n                         let inner = v.project_downcast(self.ecx(), idx)?;\n                         trace!(\"walk_value: variant layout: {:#?}\", inner.layout());\n                         // recurse with the inner type\n-                        return self.visit_field(v, idx, inner);\n+                        return self.visit_variant(v, idx, inner);\n                     }\n                     layout::Variants::Single { .. } => {}\n                 }"}, {"sha": "e99af56c22c0088b6e1b3b8ecda7ed25b9430f3e", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -13,6 +13,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer;\n use rustc::mir::*;\n use rustc::ty::{self, Ty, TyCtxt, GenericParamDefKind};\n+use rustc::ty::layout::VariantIdx;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::query::Providers;\n \n@@ -291,7 +292,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n     fn deref_subpath(&self, _path: Self::Path) -> Option<Self::Path> {\n         None\n     }\n-    fn downcast_subpath(&self, _path: Self::Path, _variant: usize) -> Option<Self::Path> {\n+    fn downcast_subpath(&self, _path: Self::Path, _variant: VariantIdx) -> Option<Self::Path> {\n         Some(())\n     }\n     fn array_subpath(&self, _path: Self::Path, _index: u32, _size: u32) -> Option<Self::Path> {\n@@ -867,7 +868,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n     let variant_no = if adt_def.is_enum() {\n         adt_def.variant_index_with_id(def_id)\n     } else {\n-        0\n+        VariantIdx::new(0)\n     };\n \n     // return = ADT(arg0, arg1, ...); return"}, {"sha": "2b3fd552e0faa9cd119f3f021793e805fef37383", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -16,6 +16,7 @@ use dataflow::{drop_flag_effects_for_location, on_lookup_result_bits};\n use dataflow::MoveDataParamEnv;\n use dataflow::{self, do_dataflow, DebugFormatted};\n use rustc::ty::{self, TyCtxt};\n+use rustc::ty::layout::VariantIdx;\n use rustc::mir::*;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::bit_set::BitSet;\n@@ -282,7 +283,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n         })\n     }\n \n-    fn downcast_subpath(&self, path: Self::Path, variant: usize) -> Option<Self::Path> {\n+    fn downcast_subpath(&self, path: Self::Path, variant: VariantIdx) -> Option<Self::Path> {\n         dataflow::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n             match p {\n                 &Projection {"}, {"sha": "9d633fa2b0b7c1d14ad5044ae1586c8f9854d503", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -64,6 +64,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutVisitor};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty};\n+use rustc::ty::layout::VariantIdx;\n use rustc::ty::subst::Substs;\n use util::dump_mir;\n use util::liveness::{self, IdentityMap};\n@@ -158,7 +159,7 @@ struct TransformVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n     // Make a GeneratorState rvalue\n-    fn make_state(&self, idx: usize, val: Operand<'tcx>) -> Rvalue<'tcx> {\n+    fn make_state(&self, idx: VariantIdx, val: Operand<'tcx>) -> Rvalue<'tcx> {\n         let adt = AggregateKind::Adt(self.state_adt_ref, idx, self.state_substs, None, None);\n         Rvalue::Aggregate(box adt, vec![val])\n     }\n@@ -229,11 +230,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n         });\n \n         let ret_val = match data.terminator().kind {\n-            TerminatorKind::Return => Some((1,\n+            TerminatorKind::Return => Some((VariantIdx::new(1),\n                 None,\n                 Operand::Move(Place::Local(self.new_ret_local)),\n                 None)),\n-            TerminatorKind::Yield { ref value, resume, drop } => Some((0,\n+            TerminatorKind::Yield { ref value, resume, drop } => Some((VariantIdx::new(0),\n                 Some(resume),\n                 value.clone(),\n                 drop)),"}, {"sha": "2c7f337b3b1c0a677595feb39f60ee73db5d5df6", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -14,6 +14,7 @@ use rustc::mir::*;\n use rustc::middle::lang_items;\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::VariantIdx;\n use rustc::ty::subst::Substs;\n use rustc::ty::util::IntTypeExt;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -94,7 +95,7 @@ pub trait DropElaborator<'a, 'tcx: 'a> : fmt::Debug {\n \n     fn field_subpath(&self, path: Self::Path, field: Field) -> Option<Self::Path>;\n     fn deref_subpath(&self, path: Self::Path) -> Option<Self::Path>;\n-    fn downcast_subpath(&self, path: Self::Path, variant: usize) -> Option<Self::Path>;\n+    fn downcast_subpath(&self, path: Self::Path, variant: VariantIdx) -> Option<Self::Path>;\n     fn array_subpath(&self, path: Self::Path, index: u32, size: u32) -> Option<Self::Path>;\n }\n \n@@ -392,7 +393,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             let fields = self.move_paths_for_fields(\n                 self.place,\n                 self.path,\n-                &adt.variants[0],\n+                &adt.variants[VariantIdx::new(0)],\n                 substs\n             );\n             self.drop_ladder(fields, succ, unwind)\n@@ -416,7 +417,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         let mut have_otherwise = false;\n \n-        for (variant_index, discr) in adt.discriminants(self.tcx()).enumerate() {\n+        for (variant_index, discr) in adt.discriminants(self.tcx()) {\n             let subpath = self.elaborator.downcast_subpath(\n                 self.path, variant_index);\n             if let Some(variant_path) = subpath {\n@@ -894,7 +895,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let tcx = self.tcx();\n         let unit_temp = Place::Local(self.new_temp(tcx.mk_unit()));\n         let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n-        let args = adt.variants[0].fields.iter().enumerate().map(|(i, f)| {\n+        let args = adt.variants[VariantIdx::new(0)].fields.iter().enumerate().map(|(i, f)| {\n             let field = Field::new(i);\n             let field_ty = f.ty(self.tcx(), substs);\n             Operand::Move(self.place.clone().field(field, field_ty))"}, {"sha": "dfdd7f0ae58e5e0b810cdfc90ae1244c893d6b44", "filename": "src/librustc_target/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_target%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_target%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2FCargo.toml?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -12,4 +12,5 @@ crate-type = [\"dylib\"]\n bitflags = \"1.0\"\n log = \"0.4\"\n rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "88f22912fa6fc9d812fadc5d7f70a286faff2349", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -16,6 +16,8 @@ use spec::Target;\n use std::{cmp, fmt};\n use std::ops::{Add, Deref, Sub, Mul, AddAssign, Range, RangeInclusive};\n \n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+\n pub mod call;\n \n /// Parsed [Data layout](http://llvm.org/docs/LangRef.html#data-layout)\n@@ -825,19 +827,23 @@ impl Abi {\n     }\n }\n \n+newtype_index! {\n+    pub struct VariantIdx { .. }\n+}\n+\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub enum Variants {\n     /// Single enum variants, structs/tuples, unions, and all non-ADTs.\n     Single {\n-        index: usize\n+        index: VariantIdx,\n     },\n \n     /// General-case enums: for each case there is a struct, and they all have\n     /// all space reserved for the tag, and their first field starts\n     /// at a non-0 offset, after where the tag would go.\n     Tagged {\n         tag: Scalar,\n-        variants: Vec<LayoutDetails>,\n+        variants: IndexVec<VariantIdx, LayoutDetails>,\n     },\n \n     /// Multiple cases distinguished by a niche (values invalid for a type):\n@@ -849,11 +855,11 @@ pub enum Variants {\n     /// `None` has a null pointer for the second tuple field, and\n     /// `Some` is the identity function (with a non-null reference).\n     NicheFilling {\n-        dataful_variant: usize,\n-        niche_variants: RangeInclusive<usize>,\n+        dataful_variant: VariantIdx,\n+        niche_variants: RangeInclusive<VariantIdx>,\n         niche: Scalar,\n         niche_start: u128,\n-        variants: Vec<LayoutDetails>,\n+        variants: IndexVec<VariantIdx, LayoutDetails>,\n     }\n }\n \n@@ -871,7 +877,7 @@ impl LayoutDetails {\n         let size = scalar.value.size(cx);\n         let align = scalar.value.align(cx);\n         LayoutDetails {\n-            variants: Variants::Single { index: 0 },\n+            variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldPlacement::Union(0),\n             abi: Abi::Scalar(scalar),\n             size,\n@@ -908,12 +914,16 @@ pub trait LayoutOf {\n }\n \n pub trait TyLayoutMethods<'a, C: LayoutOf<Ty = Self>>: Sized {\n-    fn for_variant(this: TyLayout<'a, Self>, cx: &C, variant_index: usize) -> TyLayout<'a, Self>;\n+    fn for_variant(\n+        this: TyLayout<'a, Self>,\n+        cx: &C,\n+        variant_index: VariantIdx,\n+    ) -> TyLayout<'a, Self>;\n     fn field(this: TyLayout<'a, Self>, cx: &C, i: usize) -> C::TyLayout;\n }\n \n impl<'a, Ty> TyLayout<'a, Ty> {\n-    pub fn for_variant<C>(self, cx: &C, variant_index: usize) -> Self\n+    pub fn for_variant<C>(self, cx: &C, variant_index: VariantIdx) -> Self\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> {\n         Ty::for_variant(self, cx, variant_index)\n     }"}, {"sha": "813b39de064131d6ff16e7ad1db65d4eb1c715b7", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -23,7 +23,9 @@\n \n #![feature(box_syntax)]\n #![feature(nll)]\n+#![feature(rustc_attrs)]\n #![feature(slice_patterns)]\n+#![feature(step_trait)]\n \n #[macro_use]\n extern crate bitflags;\n@@ -36,5 +38,8 @@ extern crate serialize as rustc_serialize; // used by deriving\n #[allow(unused_extern_crates)]\n extern crate rustc_cratesio_shim;\n \n+#[macro_use]\n+extern crate rustc_data_structures;\n+\n pub mod abi;\n pub mod spec;"}, {"sha": "2e6797ef23ad22c3f89fb6286b06bbf0bab0e229", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -103,6 +103,8 @@ use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoB\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n+use rustc::ty::layout::VariantIdx;\n+use rustc_data_structures::indexed_vec::Idx;\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n \n use require_c_abi_if_variadic;\n@@ -1837,10 +1839,11 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let mut disr_vals: Vec<Discr<'tcx>> = Vec::with_capacity(vs.len());\n-    for (discr, v) in def.discriminants(tcx).zip(vs) {\n+    for ((_, discr), v) in def.discriminants(tcx).zip(vs) {\n         // Check for duplicate discriminant values\n         if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n-            let variant_i_node_id = tcx.hir.as_local_node_id(def.variants[i].did).unwrap();\n+            let variant_did = def.variants[VariantIdx::new(i)].did;\n+            let variant_i_node_id = tcx.hir.as_local_node_id(variant_did).unwrap();\n             let variant_i = tcx.hir.expect_variant(variant_i_node_id);\n             let i_span = match variant_i.node.disr_expr {\n                 Some(ref expr) => tcx.hir.span(expr.id),"}, {"sha": "70af837076f1acce56eadb31ae47b1d71c076d6d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -651,28 +651,28 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n             };\n             (\n                 AdtKind::Struct,\n-                vec![convert_variant(\n+                std::iter::once(convert_variant(\n                     tcx,\n                     ctor_id.unwrap_or(def_id),\n                     item.name,\n                     ty::VariantDiscr::Relative(0),\n                     def,\n                     AdtKind::Struct,\n                     def_id\n-                )],\n+                )).collect(),\n             )\n         }\n         ItemKind::Union(ref def, _) => (\n             AdtKind::Union,\n-            vec![convert_variant(\n+            std::iter::once(convert_variant(\n                 tcx,\n                 def_id,\n                 item.name,\n                 ty::VariantDiscr::Relative(0),\n                 def,\n                 AdtKind::Union,\n                 def_id\n-            )],\n+            )).collect(),\n         ),\n         _ => bug!(),\n     };"}, {"sha": "f514cb83a1fed636489797a9291ddf5962022a13", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -38,10 +38,12 @@ use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n+use rustc::ty::layout::VariantIdx;\n use rustc::middle::stability;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_typeck::hir_ty_to_ty;\n use rustc::infer::region_constraints::{RegionConstraintData, Constraint};\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n use std::collections::hash_map::Entry;\n use std::fmt;\n@@ -98,6 +100,12 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for [T] {\n     }\n }\n \n+impl<T: Clean<U>, U, V: Idx> Clean<IndexVec<V, U>> for IndexVec<V, T> {\n+    fn clean(&self, cx: &DocContext) -> IndexVec<V, U> {\n+        self.iter().map(|x| x.clean(cx)).collect()\n+    }\n+}\n+\n impl<T: Clean<U>, U> Clean<U> for P<T> {\n     fn clean(&self, cx: &DocContext) -> U {\n         (**self).clean(cx)\n@@ -2886,7 +2894,7 @@ impl Clean<VariantStruct> for ::rustc::hir::VariantData {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Enum {\n-    pub variants: Vec<Item>,\n+    pub variants: IndexVec<VariantIdx, Item>,\n     pub generics: Generics,\n     pub variants_stripped: bool,\n }\n@@ -2902,7 +2910,7 @@ impl Clean<Item> for doctree::Enum {\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n             inner: EnumItem(Enum {\n-                variants: self.variants.clean(cx),\n+                variants: self.variants.iter().map(|v| v.clean(cx)).collect(),\n                 generics: self.generics.clean(cx),\n                 variants_stripped: false,\n             }),"}, {"sha": "d36e96b08174a125cfb6f30bcca976d39587ef58", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=485397e49a02a3b7ff77c17e4a3f16c653925cb3", "patch": "@@ -42,7 +42,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:61:1\n    |\n LL | const BAD_ENUM_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .Some.0.1, but expected something less or equal to 1114111\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .<downcast-variant(Some)>.0.1, but expected something less or equal to 1114111\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}]}