{"sha": "287b6be5ca0e153383fdc13e44a7be540606e957", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4N2I2YmU1Y2EwZTE1MzM4M2ZkYzEzZTQ0YTdiZTU0MDYwNmU5NTc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-13T04:06:57Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-13T04:06:57Z"}, "message": "track alignment also for ByRef values", "tree": {"sha": "c50aa2a6045de506e67fc9102a426fca40d91df2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c50aa2a6045de506e67fc9102a426fca40d91df2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/287b6be5ca0e153383fdc13e44a7be540606e957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/287b6be5ca0e153383fdc13e44a7be540606e957", "html_url": "https://github.com/rust-lang/rust/commit/287b6be5ca0e153383fdc13e44a7be540606e957", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/287b6be5ca0e153383fdc13e44a7be540606e957/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "454fc854ab5d5fb349dbb1408867d1817a180206", "url": "https://api.github.com/repos/rust-lang/rust/commits/454fc854ab5d5fb349dbb1408867d1817a180206", "html_url": "https://github.com/rust-lang/rust/commit/454fc854ab5d5fb349dbb1408867d1817a180206"}], "stats": {"total": 276, "additions": 176, "deletions": 100}, "files": [{"sha": "a4ce1d327e3a826503eda0ea36425005f71d45f7", "filename": "src/eval_context.rs", "status": "modified", "additions": 43, "deletions": 32, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=287b6be5ca0e153383fdc13e44a7be540606e957", "patch": "@@ -352,7 +352,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     .expect(\"global should have been cached (static)\");\n                 match global_value.value {\n                     // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n-                    Value::ByRef(ptr) => self.memory.mark_static_initalized(ptr.to_ptr()?.alloc_id, mutable)?,\n+                    Value::ByRef(ptr, _aligned) =>\n+                        // Alignment does not matter for this call\n+                        self.memory.mark_static_initalized(ptr.to_ptr()?.alloc_id, mutable)?,\n                     Value::ByVal(val) => if let PrimVal::Ptr(ptr) = val {\n                         self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n                     },\n@@ -408,7 +410,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     pub fn deallocate_local(&mut self, local: Option<Value>) -> EvalResult<'tcx> {\n-        if let Some(Value::ByRef(ptr)) = local {\n+        if let Some(Value::ByRef(ptr, _aligned)) = local {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n             self.memory.dump_alloc(ptr.alloc_id);\n@@ -497,10 +499,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc::mir::Rvalue::*;\n         match *rvalue {\n             Use(ref operand) => {\n-                let (value, aligned) = self.eval_operand_maybe_unaligned(operand)?;\n-                self.memory.reads_are_aligned = aligned;\n+                let value = self.eval_operand(operand)?;\n                 self.write_value(value, dest, dest_ty)?;\n-                self.memory.reads_are_aligned = true;\n             }\n \n             BinaryOp(bin_op, ref left, ref right) => {\n@@ -725,7 +725,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let src_ty = self.operand_ty(operand);\n                         if self.type_is_fat_ptr(src_ty) {\n                             match (src, self.type_is_fat_ptr(dest_ty)) {\n-                                (Value::ByRef(_), _) |\n+                                (Value::ByRef(..), _) |\n                                 (Value::ByValPair(..), true) => {\n                                     self.write_value(src, dest, dest_ty)?;\n                                 },\n@@ -955,7 +955,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.value_to_primval(value, ty)\n     }\n \n-    pub(super) fn eval_operand_maybe_unaligned(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, (Value, bool)> {\n+    pub(super) fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Value> {\n         use rustc::mir::Operand::*;\n         match *op {\n             Consume(ref lvalue) => self.eval_and_read_lvalue(lvalue),\n@@ -981,16 +981,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 };\n \n-                Ok((value, true))\n+                Ok(value)\n             }\n         }\n     }\n \n-    pub(super) fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Value> {\n-        // This is called when the packed flag is not taken into account. Ignore alignment.\n-        Ok(self.eval_operand_maybe_unaligned(op)?.0)\n-    }\n-\n     pub(super) fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(operand.ty(self.mir(), self.tcx), self.substs())\n     }\n@@ -1011,15 +1006,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // -1 since we don't store the return value\n                 match self.stack[frame].locals[local.index() - 1] {\n                     None => return Err(EvalError::DeadLocal),\n-                    Some(Value::ByRef(ptr)) => {\n-                        Lvalue::from_primval_ptr(ptr)\n+                    Some(Value::ByRef(ptr, aligned)) => {\n+                        Lvalue::Ptr { ptr, aligned, extra: LvalueExtra::None }\n                     },\n                     Some(val) => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n                         let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n                         let substs = self.stack[frame].instance.substs;\n                         let ptr = self.alloc_ptr_with_substs(ty, substs)?;\n-                        self.stack[frame].locals[local.index() - 1] = Some(Value::ByRef(ptr.into())); // it stays live\n+                        self.stack[frame].locals[local.index() - 1] = Some(Value::by_ref(ptr.into())); // it stays live\n                         self.write_value_to_ptr(val, ptr.into(), ty)?;\n                         Lvalue::from_ptr(ptr)\n                     }\n@@ -1029,7 +1024,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Lvalue::Global(cid) => {\n                 let global_val = *self.globals.get(&cid).expect(\"global not cached\");\n                 match global_val.value {\n-                    Value::ByRef(ptr) => Lvalue::from_primval_ptr(ptr),\n+                    Value::ByRef(ptr, aligned) =>\n+                        Lvalue::Ptr { ptr, aligned, extra: LvalueExtra::None },\n                     _ => {\n                         let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.instance.substs)?;\n                         self.memory.mark_static(ptr.alloc_id);\n@@ -1040,7 +1036,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         }\n                         let lval = self.globals.get_mut(&cid).expect(\"already checked\");\n                         *lval = Global {\n-                            value: Value::ByRef(ptr.into()),\n+                            value: Value::by_ref(ptr.into()),\n                             .. global_val\n                         };\n                         Lvalue::from_ptr(ptr)\n@@ -1054,14 +1050,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     /// ensures this Value is not a ByRef\n     pub(super) fn follow_by_ref_value(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         match value {\n-            Value::ByRef(ptr) => self.read_value(ptr, ty),\n+            Value::ByRef(ptr, aligned) => {\n+                self.memory.begin_unaligned_read(aligned);\n+                let r = self.read_value(ptr, ty);\n+                self.memory.end_unaligned_read();\n+                r\n+            }\n             other => Ok(other),\n         }\n     }\n \n     pub(super) fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         match self.follow_by_ref_value(value, ty)? {\n-            Value::ByRef(_) => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n+            Value::ByRef(..) => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n \n             Value::ByVal(primval) => {\n                 self.ensure_valid_value(primval, ty)?;\n@@ -1126,9 +1127,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Lvalue::Ptr { ptr, extra, aligned } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                self.memory.writes_are_aligned = aligned;\n+                self.memory.begin_unaligned_write(aligned);\n                 let r = self.write_value_to_ptr(src_val, ptr, dest_ty);\n-                self.memory.writes_are_aligned = true;\n+                self.memory.end_unaligned_write();\n                 r\n             }\n \n@@ -1152,17 +1153,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         old_dest_val: Value,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        if let Value::ByRef(dest_ptr) = old_dest_val {\n+        if let Value::ByRef(dest_ptr, aligned) = old_dest_val {\n             // If the value is already `ByRef` (that is, backed by an `Allocation`),\n             // then we must write the new value into this allocation, because there may be\n             // other pointers into the allocation. These other pointers are logically\n             // pointers into the local variable, and must be able to observe the change.\n             //\n             // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n             // knew for certain that there were no outstanding pointers to this allocation.\n+            self.memory.begin_unaligned_write(aligned);\n             self.write_value_to_ptr(src_val, dest_ptr, dest_ty)?;\n+            self.memory.end_unaligned_write();\n \n-        } else if let Value::ByRef(src_ptr) = src_val {\n+        } else if let Value::ByRef(src_ptr, aligned) = src_val {\n             // If the value is not `ByRef`, then we know there are no pointers to it\n             // and we can simply overwrite the `Value` in the locals array directly.\n             //\n@@ -1174,13 +1177,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // It is a valid optimization to attempt reading a primitive value out of the\n             // source and write that into the destination without making an allocation, so\n             // we do so here.\n+            self.memory.begin_unaligned_read(aligned);\n             if let Ok(Some(src_val)) = self.try_read_value(src_ptr, dest_ty) {\n                 write_dest(self, src_val)?;\n             } else {\n                 let dest_ptr = self.alloc_ptr(dest_ty)?.into();\n                 self.copy(src_ptr, dest_ptr, dest_ty)?;\n-                write_dest(self, Value::ByRef(dest_ptr))?;\n+                write_dest(self, Value::by_ref(dest_ptr))?;\n             }\n+            self.memory.end_unaligned_read();\n \n         } else {\n             // Finally, we have the simple case where neither source nor destination are\n@@ -1197,7 +1202,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match value {\n-            Value::ByRef(ptr) => self.copy(ptr, dest, dest_ty),\n+            Value::ByRef(ptr, aligned) => {\n+                self.memory.begin_unaligned_read(aligned);\n+                let r = self.copy(ptr, dest, dest_ty);\n+                self.memory.end_unaligned_read();\n+                r\n+            },\n             Value::ByVal(primval) => {\n                 let size = self.type_size(dest_ty)?.expect(\"dest type must be sized\");\n                 self.memory.write_primval(dest, primval, size)\n@@ -1460,7 +1470,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n-                let ptr = src.into_ptr(&self.memory)?;\n+                let ptr = src.into_ptr(&mut self.memory)?;\n                 // u64 cast is from usize to u64, which is always good\n                 self.write_value(ptr.to_value_with_len(length as u64), dest, dest_ty)\n             }\n@@ -1474,7 +1484,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let trait_ref = data.principal().unwrap().with_self_ty(self.tcx, src_pointee_ty);\n                 let trait_ref = self.tcx.erase_regions(&trait_ref);\n                 let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n-                let ptr = src.into_ptr(&self.memory)?;\n+                let ptr = src.into_ptr(&mut self.memory)?;\n                 self.write_value(ptr.to_value_with_vtable(vtable), dest, dest_ty)\n             },\n \n@@ -1517,8 +1527,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 //let src = adt::MaybeSizedValue::sized(src);\n                 //let dst = adt::MaybeSizedValue::sized(dst);\n                 let src_ptr = match src {\n-                    Value::ByRef(ptr) => ptr,\n-                    _ => bug!(\"expected pointer, got {:?}\", src),\n+                    Value::ByRef(ptr, true) => ptr,\n+                    // TODO: Is it possible for unaligned pointers to occur here?\n+                    _ => bug!(\"expected aligned pointer, got {:?}\", src),\n                 };\n \n                 // FIXME(solson)\n@@ -1537,7 +1548,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     if src_fty == dst_fty {\n                         self.copy(src_f_ptr, dst_f_ptr.into(), src_fty)?;\n                     } else {\n-                        self.unsize_into(Value::ByRef(src_f_ptr), src_fty, Lvalue::from_ptr(dst_f_ptr), dst_fty)?;\n+                        self.unsize_into(Value::by_ref(src_f_ptr), src_fty, Lvalue::from_ptr(dst_f_ptr), dst_fty)?;\n                     }\n                 }\n                 Ok(())\n@@ -1564,7 +1575,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Err(err) => {\n                     panic!(\"Failed to access local: {:?}\", err);\n                 }\n-                Ok(Value::ByRef(ptr)) => match ptr.into_inner_primval() {\n+                Ok(Value::ByRef(ptr, _aligned)) => match ptr.into_inner_primval() {\n                     PrimVal::Ptr(ptr) => {\n                         write!(msg, \" by ref:\").unwrap();\n                         allocs.push(ptr.alloc_id);"}, {"sha": "b042baa2696c9f4bb393d40884962e19e5c3f784", "filename": "src/lvalue.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=287b6be5ca0e153383fdc13e44a7be540606e957", "patch": "@@ -179,13 +179,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     /// Returns a value and (in case of a ByRef) if we are supposed to use aligned accesses.\n-    pub(super) fn eval_and_read_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, (Value, bool)> {\n+    pub(super) fn eval_and_read_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n         let ty = self.lvalue_ty(lvalue);\n         // Shortcut for things like accessing a fat pointer's field,\n         // which would otherwise (in the `eval_lvalue` path) require moving a `ByValPair` to memory\n         // and returning an `Lvalue::Ptr` to it\n         if let Some(val) = self.try_read_lvalue(lvalue)? {\n-            return Ok((val, true));\n+            return Ok(val);\n         }\n         let lvalue = self.eval_lvalue(lvalue)?;\n \n@@ -196,13 +196,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match lvalue {\n             Lvalue::Ptr { ptr, extra, aligned } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                Ok((Value::ByRef(ptr), aligned))\n+                Ok(Value::ByRef(ptr, aligned))\n             }\n             Lvalue::Local { frame, local } => {\n-                Ok((self.stack[frame].get_local(local)?, true))\n+                Ok(self.stack[frame].get_local(local)?)\n             }\n             Lvalue::Global(cid) => {\n-                Ok((self.globals.get(&cid).expect(\"global not cached\").value, true))\n+                Ok(self.globals.get(&cid).expect(\"global not cached\").value)\n             }\n         }\n     }\n@@ -301,7 +301,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     assert_eq!(offset.bytes(), 0, \"ByVal can only have 1 non zst field with offset 0\");\n                     return Ok(base);\n                 },\n-                Value::ByRef(_) |\n+                Value::ByRef(..) |\n                 Value::ByValPair(..) |\n                 Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n             },\n@@ -311,7 +311,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     assert_eq!(offset.bytes(), 0, \"ByVal can only have 1 non zst field with offset 0\");\n                     return Ok(base);\n                 },\n-                Value::ByRef(_) |\n+                Value::ByRef(..) |\n                 Value::ByValPair(..) |\n                 Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n             },\n@@ -376,9 +376,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Deref => {\n                 let base_ty = self.lvalue_ty(&proj.base);\n-                let (val, _aligned) = self.eval_and_read_lvalue(&proj.base)?;\n-                // Conservatively, the intermediate accesses of a Deref lvalue do not take into account the packed flag.\n-                // Hence we ignore alignment here.\n+                let val = self.eval_and_read_lvalue(&proj.base)?;\n \n                 let pointee_type = match base_ty.sty {\n                     ty::TyRawPtr(ref tam) |\n@@ -398,7 +396,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let (ptr, len) = val.into_slice(&self.memory)?;\n                         (ptr, LvalueExtra::Length(len), true)\n                     },\n-                    _ => (val.into_ptr(&self.memory)?, LvalueExtra::None, true),\n+                    _ => (val.into_ptr(&mut self.memory)?, LvalueExtra::None, true),\n                 }\n             }\n "}, {"sha": "bc0940e270b2f6f2759f3e2f130537c2d99f9594", "filename": "src/memory.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=287b6be5ca0e153383fdc13e44a7be540606e957", "patch": "@@ -136,8 +136,8 @@ pub struct Memory<'a, 'tcx> {\n \n     /// To avoid having to pass flags to every single memory access, we have some global state saying whether\n     /// alignment checking is currently enforced for read and/or write accesses.\n-    pub reads_are_aligned: bool,\n-    pub writes_are_aligned: bool,\n+    reads_are_aligned: bool,\n+    writes_are_aligned: bool,\n }\n \n impl<'a, 'tcx> Memory<'a, 'tcx> {\n@@ -384,6 +384,33 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n         return Ok(None);\n     }\n+\n+    #[inline]\n+    pub(crate) fn begin_unaligned_read(&mut self, aligned: bool) {\n+        assert!(self.reads_are_aligned, \"Unaligned reads must not be nested\");\n+        self.reads_are_aligned = aligned;\n+    }\n+\n+    #[inline]\n+    pub(crate) fn end_unaligned_read(&mut self) {\n+        self.reads_are_aligned = true;\n+    }\n+\n+    #[inline]\n+    pub(crate) fn begin_unaligned_write(&mut self, aligned: bool) {\n+        assert!(self.writes_are_aligned, \"Unaligned writes must not be nested\");\n+        self.writes_are_aligned = aligned;\n+    }\n+\n+    #[inline]\n+    pub(crate) fn end_unaligned_write(&mut self) {\n+        self.writes_are_aligned = true;\n+    }\n+\n+    #[inline]\n+    pub(crate) fn assert_all_aligned(&mut self) {\n+        assert!(self.reads_are_aligned && self.writes_are_aligned, \"Someone forgot to clear the 'unaligned' flag\");\n+    }\n }\n \n /// Allocation accessors"}, {"sha": "f1d32ec69d81f519094b087eaa3db5e49c77e8e7", "filename": "src/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=287b6be5ca0e153383fdc13e44a7be540606e957", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     /// Returns true as long as there are more things to do.\n     pub fn step(&mut self) -> EvalResult<'tcx, bool> {\n-        assert!(self.memory.reads_are_aligned && self.memory.writes_are_aligned, \"Someone forgot to clear the 'unaligned' flag\");\n+        self.memory.assert_all_aligned();\n         self.inc_step_counter_and_check_limit(1)?;\n         if self.stack.is_empty() {\n             return Ok(false);"}, {"sha": "ce40672839b137b2aca843d5c2c91b0dda656fee", "filename": "src/terminator/drop.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=287b6be5ca0e153383fdc13e44a7be540606e957", "patch": "@@ -11,10 +11,11 @@ use value::Value;\n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(crate) fn drop_lvalue(&mut self, lval: Lvalue<'tcx>, instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n         trace!(\"drop_lvalue: {:#?}\", lval);\n+        // We take the address of the object.\n         let val = match self.force_allocation(lval)? {\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable), aligned: true } => ptr.to_value_with_vtable(vtable),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len), aligned: true } => ptr.to_value_with_len(len),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true } => ptr.to_value(),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable), aligned: _ } => ptr.to_value_with_vtable(vtable),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len), aligned: _ } => ptr.to_value_with_len(len),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: _ } => ptr.to_value(),\n             _ => bug!(\"force_allocation broken\"),\n         };\n         self.drop(val, instance, ty, span)"}, {"sha": "c37974caecb54af7b8eed8a6da32b2206d401006", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=287b6be5ca0e153383fdc13e44a7be540606e957", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"arith_offset\" => {\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n                 let result_ptr = self.wrapping_pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_ptr(dest, result_ptr, dest_ty)?;\n             }\n@@ -60,16 +60,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_load_acq\" |\n             \"volatile_load\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n-                self.write_value(Value::ByRef(ptr), dest, ty)?;\n+                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                self.write_value(Value::by_ref(ptr), dest, ty)?;\n             }\n \n             \"atomic_store\" |\n             \"atomic_store_relaxed\" |\n             \"atomic_store_rel\" |\n             \"volatile_store\" => {\n                 let ty = substs.type_at(0);\n-                let dest = arg_vals[0].into_ptr(&self.memory)?;\n+                let dest = arg_vals[0].into_ptr(&mut self.memory)?;\n                 self.write_value_to_ptr(arg_vals[1], dest, ty)?;\n             }\n \n@@ -79,12 +79,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n-                    Value::ByRef(_) => bug!(\"just read the value, can't be byref\"),\n+                    Value::ByRef(..) => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_xchg doesn't work with nonprimitives\"),\n                 };\n                 self.write_primval(dest, old, ty)?;\n@@ -93,13 +93,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n                 let expect_old = self.value_to_primval(arg_vals[1], ty)?;\n                 let change = self.value_to_primval(arg_vals[2], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n-                    Value::ByRef(_) => bug!(\"just read the value, can't be byref\"),\n+                    Value::ByRef(..) => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_cxchg doesn't work with nonprimitives\"),\n                 };\n                 let (val, _) = self.binary_op(mir::BinOp::Eq, old, ty, expect_old, ty)?;\n@@ -114,12 +114,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_xadd\" | \"atomic_xadd_acq\" | \"atomic_xadd_rel\" | \"atomic_xadd_acqrel\" | \"atomic_xadd_relaxed\" |\n             \"atomic_xsub\" | \"atomic_xsub_acq\" | \"atomic_xsub_rel\" | \"atomic_xsub_acqrel\" | \"atomic_xsub_relaxed\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n-                    Value::ByRef(_) => bug!(\"just read the value, can't be byref\"),\n+                    Value::ByRef(..) => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_xadd_relaxed doesn't work with nonprimitives\"),\n                 };\n                 self.write_primval(dest, old, ty)?;\n@@ -144,8 +144,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let elem_size = self.type_size(elem_ty)?.expect(\"cannot copy unsized value\");\n                 if elem_size != 0 {\n                     let elem_align = self.type_align(elem_ty)?;\n-                    let src = arg_vals[0].into_ptr(&self.memory)?;\n-                    let dest = arg_vals[1].into_ptr(&self.memory)?;\n+                    let src = arg_vals[0].into_ptr(&mut self.memory)?;\n+                    let dest = arg_vals[1].into_ptr(&mut self.memory)?;\n                     let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                     self.memory.copy(src, dest, count * elem_size, elem_align, intrinsic_name.ends_with(\"_nonoverlapping\"))?;\n                 }\n@@ -173,7 +173,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n-                let adt_ptr = arg_vals[0].into_ptr(&self.memory)?.to_ptr()?;\n+                let adt_ptr = arg_vals[0].into_ptr(&mut self.memory)?.to_ptr()?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n                 self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n             }\n@@ -248,9 +248,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let size = self.type_size(dest_ty)?.expect(\"cannot zero unsized value\");\n                 let init = |this: &mut Self, val: Value| {\n                     let zero_val = match val {\n-                        Value::ByRef(ptr) => {\n+                        Value::ByRef(ptr, aligned) => {\n+                            // These writes have no alignment restriction anyway.\n                             this.memory.write_repeat(ptr, 0, size)?;\n-                            Value::ByRef(ptr)\n+                            Value::ByRef(ptr, aligned)\n                         },\n                         // TODO(solson): Revisit this, it's fishy to check for Undef here.\n                         Value::ByVal(PrimVal::Undef) => match this.ty_to_primval_kind(dest_ty) {\n@@ -259,7 +260,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 let ptr = this.alloc_ptr_with_substs(dest_ty, substs)?;\n                                 let ptr = Pointer::from(PrimVal::Ptr(ptr));\n                                 this.memory.write_repeat(ptr, 0, size)?;\n-                                Value::ByRef(ptr)\n+                                Value::by_ref(ptr)\n                             }\n                         },\n                         Value::ByVal(_) => Value::ByVal(PrimVal::Bytes(0)),\n@@ -293,7 +294,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"move_val_init\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n                 self.write_value_to_ptr(arg_vals[1], ptr, ty)?;\n             }\n \n@@ -306,7 +307,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"offset\" => {\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n                 let result_ptr = self.pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_ptr(dest, result_ptr, dest_ty)?;\n             }\n@@ -395,9 +396,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"transmute\" => {\n                 let src_ty = substs.type_at(0);\n                 let ptr = self.force_allocation(dest)?.to_ptr()?;\n-                self.memory.writes_are_aligned = false;\n+                self.memory.begin_unaligned_read(false);\n                 self.write_value_to_ptr(arg_vals[0], ptr.into(), src_ty)?;\n-                self.memory.writes_are_aligned = true;\n+                self.memory.end_unaligned_read();\n             }\n \n             \"unchecked_shl\" => {\n@@ -438,9 +439,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let size = dest_layout.size(&self.tcx.data_layout).bytes();\n                 let uninit = |this: &mut Self, val: Value| {\n                     match val {\n-                        Value::ByRef(ptr) => {\n+                        Value::ByRef(ptr, aligned) => {\n                             this.memory.mark_definedness(ptr, size, false)?;\n-                            Ok(Value::ByRef(ptr))\n+                            Ok(Value::ByRef(ptr, aligned))\n                         },\n                         _ => Ok(Value::ByVal(PrimVal::Undef)),\n                     }\n@@ -460,7 +461,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty_align = self.type_align(ty)?;\n                 let val_byte = self.value_to_primval(arg_vals[1], u8)?.to_u128()? as u8;\n                 let size = self.type_size(ty)?.expect(\"write_bytes() type must be sized\");\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n                 let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                 if count > 0 {\n                     // TODO: Should we, at least, validate the alignment? (Also see memory::copy)"}, {"sha": "cb6a2ff3456152221e10170d636d1981d25e0067", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=287b6be5ca0e153383fdc13e44a7be540606e957", "patch": "@@ -310,9 +310,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             if self.frame().mir.args_iter().count() == fields.len() + 1 {\n                                 let offsets = variant.offsets.iter().map(|s| s.bytes());\n                                 match arg_val {\n-                                    Value::ByRef(ptr) => {\n+                                    Value::ByRef(ptr, aligned) => {\n+                                        assert!(aligned, \"Unaligned ByRef-values cannot occur as function arguments\");\n                                         for ((offset, ty), arg_local) in offsets.zip(fields).zip(arg_locals) {\n-                                            let arg = Value::ByRef(ptr.offset(offset, self.memory.layout)?);\n+                                            let arg = Value::ByRef(ptr.offset(offset, self.memory.layout)?, true);\n                                             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                                             trace!(\"writing arg {:?} to {:?} (type: {})\", arg, dest, ty);\n                                             self.write_value(arg, dest, ty)?;\n@@ -572,7 +573,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::heap::::__rust_dealloc\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n+                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n                 let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if old_size == 0 {\n@@ -584,7 +585,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.deallocate(ptr, Some((old_size, align)))?;\n             }\n             \"alloc::heap::::__rust_realloc\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n+                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n                 let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n                 let old_align = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 let new_size = self.value_to_primval(args[3], usize)?.to_u64()?;\n@@ -660,7 +661,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"free\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?;\n+                let ptr = args[0].into_ptr(&mut self.memory)?;\n                 if !ptr.is_null()? {\n                     self.memory.deallocate(ptr.to_ptr()?, None)?;\n                 }\n@@ -674,8 +675,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"dlsym\" => {\n-                let _handle = args[0].into_ptr(&self.memory)?;\n-                let symbol = args[1].into_ptr(&self.memory)?.to_ptr()?;\n+                let _handle = args[0].into_ptr(&mut self.memory)?;\n+                let symbol = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n                 let symbol_name = self.memory.read_c_str(symbol)?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n@@ -686,8 +687,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n                 // We abort on panic, so not much is going on here, but we still have to call the closure\n                 let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                let f = args[0].into_ptr(&self.memory)?.to_ptr()?;\n-                let data = args[1].into_ptr(&self.memory)?;\n+                let f = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let data = args[1].into_ptr(&mut self.memory)?;\n                 let f_instance = self.memory.get_fn(f)?;\n                 self.write_null(dest, dest_ty)?;\n \n@@ -718,8 +719,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"memcmp\" => {\n-                let left = args[0].into_ptr(&self.memory)?;\n-                let right = args[1].into_ptr(&self.memory)?;\n+                let left = args[0].into_ptr(&mut self.memory)?;\n+                let right = args[1].into_ptr(&mut self.memory)?;\n                 let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n \n                 let result = {\n@@ -738,7 +739,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"memrchr\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?;\n+                let ptr = args[0].into_ptr(&mut self.memory)?;\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n@@ -750,7 +751,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"memchr\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?;\n+                let ptr = args[0].into_ptr(&mut self.memory)?;\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n@@ -763,7 +764,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"getenv\" => {\n                 let result = {\n-                    let name_ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n+                    let name_ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n                     let name = self.memory.read_c_str(name_ptr)?;\n                     match self.env_vars.get(name) {\n                         Some(&var) => PrimVal::Ptr(var),\n@@ -776,7 +777,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"unsetenv\" => {\n                 let mut success = None;\n                 {\n-                    let name_ptr = args[0].into_ptr(&self.memory)?;\n+                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n                     if !name_ptr.is_null()? {\n                         let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n@@ -797,8 +798,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"setenv\" => {\n                 let mut new = None;\n                 {\n-                    let name_ptr = args[0].into_ptr(&self.memory)?;\n-                    let value_ptr = args[1].into_ptr(&self.memory)?.to_ptr()?;\n+                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n+                    let value_ptr = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n                     let value = self.memory.read_c_str(value_ptr)?;\n                     if !name_ptr.is_null()? {\n                         let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n@@ -823,7 +824,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"write\" => {\n                 let fd = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let buf = args[1].into_ptr(&self.memory)?;\n+                let buf = args[1].into_ptr(&mut self.memory)?;\n                 let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n                 let result = if fd == 1 || fd == 2 { // stdout/stderr\n@@ -840,7 +841,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"strlen\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n+                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n                 let n = self.memory.read_c_str(ptr)?.len();\n                 self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n             }\n@@ -863,10 +864,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n-                let key_ptr = args[0].into_ptr(&self.memory)?;\n+                let key_ptr = args[0].into_ptr(&mut self.memory)?;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n-                let dtor = match args[1].into_ptr(&self.memory)?.into_inner_primval() {\n+                let dtor = match args[1].into_ptr(&mut self.memory)?.into_inner_primval() {\n                     PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n                     PrimVal::Bytes(0) => None,\n                     PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n@@ -908,7 +909,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"pthread_setspecific\" => {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n                 let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n-                let new_ptr = args[1].into_ptr(&self.memory)?;\n+                let new_ptr = args[1].into_ptr(&mut self.memory)?;\n                 self.memory.store_tls(key, new_ptr)?;\n                 \n                 // Return success (0)"}, {"sha": "42d12e0cdcf064de7fed644b83d41ac18b39f34e", "filename": "src/value.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287b6be5ca0e153383fdc13e44a7be540606e957/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=287b6be5ca0e153383fdc13e44a7be540606e957", "patch": "@@ -26,14 +26,15 @@ pub(super) fn f64_to_bytes(f: f64) -> u128 {\n /// A `Value` represents a single self-contained Rust value.\n ///\n /// A `Value` can either refer to a block of memory inside an allocation (`ByRef`) or to a primitve\n-/// value held directly, outside of any allocation (`ByVal`).\n+/// value held directly, outside of any allocation (`ByVal`).  For `ByRef`-values, we remember\n+/// whether the pointer is supposed to be aligned or not (also see Lvalue).\n ///\n /// For optimization of a few very common cases, there is also a representation for a pair of\n /// primitive values (`ByValPair`). It allows Miri to avoid making allocations for checked binary\n /// operations and fat pointers. This idea was taken from rustc's trans.\n #[derive(Clone, Copy, Debug)]\n pub enum Value {\n-    ByRef(Pointer),\n+    ByRef(Pointer, bool),\n     ByVal(PrimVal),\n     ByValPair(PrimVal, PrimVal),\n }\n@@ -158,12 +159,22 @@ pub enum PrimValKind {\n }\n \n impl<'a, 'tcx: 'a> Value {\n+    #[inline]\n+    pub(super) fn by_ref(ptr: Pointer) -> Self {\n+        Value::ByRef(ptr, true)\n+    }\n+\n     /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n     /// this may have to perform a load.\n-    pub(super) fn into_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n+    pub(super) fn into_ptr(&self, mem: &mut Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n-            ByRef(ptr) => mem.read_ptr(ptr.to_ptr()?),\n+            ByRef(ptr, aligned) => {\n+                mem.begin_unaligned_read(aligned);\n+                let r = mem.read_ptr(ptr.to_ptr()?);\n+                mem.end_unaligned_read();\n+                r\n+            },\n             ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr.into()),\n         }\n     }\n@@ -174,7 +185,10 @@ impl<'a, 'tcx: 'a> Value {\n     ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n         use self::Value::*;\n         match *self {\n-            ByRef(ref_ptr) => {\n+            ByRef(ref_ptr, aligned) => {\n+                if !aligned {\n+                    return Err(EvalError::Unimplemented(format!(\"Unaligned fat-pointers are not implemented\")));\n+                }\n                 let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n                 let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n                 Ok((ptr, vtable.to_ptr()?))\n@@ -189,7 +203,10 @@ impl<'a, 'tcx: 'a> Value {\n     pub(super) fn into_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (Pointer, u64)> {\n         use self::Value::*;\n         match *self {\n-            ByRef(ref_ptr) => {\n+            ByRef(ref_ptr, aligned) => {\n+                if !aligned {\n+                    return Err(EvalError::Unimplemented(format!(\"Unaligned fat-pointers are not implemented\")));\n+                }\n                 let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n                 let len = mem.read_usize(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n                 Ok((ptr, len))"}, {"sha": "ec1533304c1e98c90a562d86e6c02b25181fbf22", "filename": "tests/run-pass/packed_struct.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/287b6be5ca0e153383fdc13e44a7be540606e957/tests%2Frun-pass%2Fpacked_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287b6be5ca0e153383fdc13e44a7be540606e957/tests%2Frun-pass%2Fpacked_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpacked_struct.rs?ref=287b6be5ca0e153383fdc13e44a7be540606e957", "patch": "@@ -1,9 +1,27 @@\n+#![allow(dead_code)]\n #[repr(packed)]\n struct S {\n     a: i32,\n     b: i64,\n }\n \n+#[repr(packed)]\n+struct Test1<'a> {\n+    x: u8,\n+    other: &'a u32,\n+}\n+\n+#[repr(packed)]\n+struct Test2<'a> {\n+    x: u8,\n+    other: &'a Test1<'a>,\n+}\n+\n+fn test(t: Test2) {\n+    let x = *t.other.other;\n+    assert_eq!(x, 42);\n+}\n+\n fn main() {\n     let mut x = S {\n         a: 42,\n@@ -19,4 +37,6 @@ fn main() {\n \n     x.b = 77;\n     assert_eq!({x.b}, 77);\n+\n+    test(Test2 { x: 0, other: &Test1 { x: 0, other: &42 }});\n }"}]}