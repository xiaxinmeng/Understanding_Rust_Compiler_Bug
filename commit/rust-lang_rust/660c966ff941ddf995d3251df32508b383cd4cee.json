{"sha": "660c966ff941ddf995d3251df32508b383cd4cee", "node_id": "C_kwDOAAsO6NoAKDY2MGM5NjZmZjk0MWRkZjk5NWQzMjUxZGYzMjUwOGIzODNjZDRjZWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-14T15:06:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-14T15:06:51Z"}, "message": "Auto merge of #110324 - JohnTitor:rollup-jq31pd1, r=JohnTitor\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #103682 (Stabilize rustdoc `--test-run-directory`)\n - #106249 (Create \"suggested tests\" tool in `rustbuild`)\n - #110047 (Add link to `collections` docs to `extend` trait)\n - #110269 (Add `tidy-alphabetical` to features in `core`)\n - #110292 (Add `tidy-alphabetical` to features in `alloc` & `std`)\n - #110305 (rustdoc-search: use ES6 `Map` and `Set` where they make sense)\n - #110315 (Add a stable MIR way to get the main function)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "a3fe0d1d5a9da6629ff5a3a4f18af694eb4d5d32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3fe0d1d5a9da6629ff5a3a4f18af694eb4d5d32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/660c966ff941ddf995d3251df32508b383cd4cee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/660c966ff941ddf995d3251df32508b383cd4cee", "html_url": "https://github.com/rust-lang/rust/commit/660c966ff941ddf995d3251df32508b383cd4cee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/660c966ff941ddf995d3251df32508b383cd4cee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0884a3528c45a5d575e182f407c759d243fdcba", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0884a3528c45a5d575e182f407c759d243fdcba", "html_url": "https://github.com/rust-lang/rust/commit/b0884a3528c45a5d575e182f407c759d243fdcba"}, {"sha": "425913367b79680068d7cb358b7609ea2be0da14", "url": "https://api.github.com/repos/rust-lang/rust/commits/425913367b79680068d7cb358b7609ea2be0da14", "html_url": "https://github.com/rust-lang/rust/commit/425913367b79680068d7cb358b7609ea2be0da14"}], "stats": {"total": 716, "additions": 577, "deletions": 139}, "files": [{"sha": "12be36ef8612672afe7cac650126c840101c853b", "filename": "Cargo.lock", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -3451,9 +3451,9 @@ dependencies = [\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.16.0\"\n+version = \"1.17.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"86f0b0d4bf799edbc74508c1e8bf170ff5f41238e5f8225603ca7caaae2b7860\"\n+checksum = \"b7e5500299e16ebb147ae15a00a942af264cf3688f47923b8fc2cd5858f23ad3\"\n \n [[package]]\n name = \"opener\"\n@@ -6101,6 +6101,15 @@ version = \"2.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"6bdef32e8150c2a081110b42772ffe7d7c9032b606bc226c8260fd97e0976601\"\n \n+[[package]]\n+name = \"suggest-tests\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"build_helper\",\n+ \"glob\",\n+ \"once_cell\",\n+]\n+\n [[package]]\n name = \"syn\"\n version = \"1.0.102\""}, {"sha": "1fcaaf6ddc4d0a09b417bf1bfd1ecc6b63c8e2d0", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -44,6 +44,7 @@ members = [\n   \"src/tools/lld-wrapper\",\n   \"src/tools/collect-license-metadata\",\n   \"src/tools/generate-copyright\",\n+  \"src/tools/suggest-tests\",\n ]\n \n exclude = ["}, {"sha": "4dad3c6bce7f1c508ee9cd502d60de4f804a5a47", "filename": "compiler/rustc_smir/src/rustc_smir/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -40,6 +40,10 @@ pub fn all_local_items() -> stable_mir::CrateItems {\n     with(|tcx| tcx.mir_keys(()).iter().map(|item| crate_item(item.to_def_id())).collect())\n }\n \n+pub fn entry_fn() -> Option<stable_mir::CrateItem> {\n+    with(|tcx| Some(crate_item(tcx.entry_fn(())?.0)))\n+}\n+\n /// Build a stable mir crate from a given crate number.\n fn smir_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> stable_mir::Crate {\n     let crate_name = tcx.crate_name(crate_num).to_string();"}, {"sha": "1d2efb5eab9475617ca1ad5fc96ed4d8dd4eca71", "filename": "compiler/rustc_smir/src/stable_mir/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmod.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -45,6 +45,13 @@ impl CrateItem {\n     }\n }\n \n+/// Return the function where execution starts if the current\n+/// crate defines that. This is usually `main`, but could be\n+/// `start` if the crate is a no-std crate.\n+pub fn entry_fn() -> Option<CrateItem> {\n+    crate::rustc_smir::entry_fn()\n+}\n+\n /// Access to the local crate.\n pub fn local_crate() -> Crate {\n     crate::rustc_smir::local_crate()"}, {"sha": "aa240c37e84427a512d2a792bebb3dfd4324a50a", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -90,6 +90,11 @@\n #![warn(multiple_supertrait_upcastable)]\n //\n // Library features:\n+// tidy-alphabetical-start\n+#![cfg_attr(not(no_global_oom_handling), feature(const_alloc_error))]\n+#![cfg_attr(not(no_global_oom_handling), feature(const_btree_len))]\n+#![cfg_attr(test, feature(is_sorted))]\n+#![cfg_attr(test, feature(new_uninit))]\n #![feature(alloc_layout_extra)]\n #![feature(allocator_api)]\n #![feature(array_chunks)]\n@@ -99,23 +104,21 @@\n #![feature(assert_matches)]\n #![feature(async_iterator)]\n #![feature(coerce_unsized)]\n-#![cfg_attr(not(no_global_oom_handling), feature(const_alloc_error))]\n+#![feature(const_align_of_val)]\n #![feature(const_box)]\n-#![cfg_attr(not(no_global_oom_handling), feature(const_btree_len))]\n-#![feature(const_cow_is_borrowed)]\n #![feature(const_convert)]\n-#![feature(const_size_of_val)]\n-#![feature(const_align_of_val)]\n-#![feature(const_ptr_read)]\n-#![feature(const_maybe_uninit_zeroed)]\n-#![feature(const_maybe_uninit_write)]\n+#![feature(const_cow_is_borrowed)]\n+#![feature(const_eval_select)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n+#![feature(const_maybe_uninit_write)]\n+#![feature(const_maybe_uninit_zeroed)]\n+#![feature(const_pin)]\n+#![feature(const_ptr_read)]\n #![feature(const_refs_to_cell)]\n+#![feature(const_size_of_val)]\n+#![feature(const_waker)]\n #![feature(core_intrinsics)]\n #![feature(core_panic)]\n-#![feature(const_eval_select)]\n-#![feature(const_pin)]\n-#![feature(const_waker)]\n #![feature(dispatch_from_dyn)]\n #![feature(error_generic_member_access)]\n #![feature(error_in_core)]\n@@ -126,15 +129,13 @@\n #![feature(hasher_prefixfree_extras)]\n #![feature(inline_const)]\n #![feature(inplace_iteration)]\n-#![cfg_attr(test, feature(is_sorted))]\n #![feature(iter_advance_by)]\n #![feature(iter_next_chunk)]\n #![feature(iter_repeat_n)]\n #![feature(layout_for_ptr)]\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(maybe_uninit_uninit_array_transpose)]\n-#![cfg_attr(test, feature(new_uninit))]\n #![feature(pattern)]\n #![feature(pointer_byte_offsets)]\n #![feature(provide_any)]\n@@ -150,6 +151,7 @@\n #![feature(slice_ptr_get)]\n #![feature(slice_ptr_len)]\n #![feature(slice_range)]\n+#![feature(std_internals)]\n #![feature(str_internals)]\n #![feature(strict_provenance)]\n #![feature(trusted_len)]\n@@ -160,41 +162,43 @@\n #![feature(unicode_internals)]\n #![feature(unsize)]\n #![feature(utf8_chunks)]\n-#![feature(std_internals)]\n+// tidy-alphabetical-end\n //\n // Language features:\n+// tidy-alphabetical-start\n+#![cfg_attr(not(test), feature(generator_trait))]\n+#![cfg_attr(test, feature(panic_update_hook))]\n+#![cfg_attr(test, feature(test))]\n #![feature(allocator_internals)]\n #![feature(allow_internal_unstable)]\n #![feature(associated_type_bounds)]\n+#![feature(c_unwind)]\n #![feature(cfg_sanitize)]\n #![feature(const_deref)]\n #![feature(const_mut_refs)]\n-#![feature(const_ptr_write)]\n #![feature(const_precise_live_drops)]\n+#![feature(const_ptr_write)]\n #![feature(const_trait_impl)]\n #![feature(const_try)]\n #![feature(dropck_eyepatch)]\n #![feature(exclusive_range_pattern)]\n #![feature(fundamental)]\n-#![cfg_attr(not(test), feature(generator_trait))]\n #![feature(hashmap_internals)]\n #![feature(lang_items)]\n #![feature(min_specialization)]\n+#![feature(multiple_supertrait_upcastable)]\n #![feature(negative_impls)]\n #![feature(never_type)]\n+#![feature(pointer_is_aligned)]\n #![feature(rustc_allow_const_fn_unstable)]\n #![feature(rustc_attrs)]\n-#![feature(pointer_is_aligned)]\n #![feature(slice_internals)]\n #![feature(staged_api)]\n #![feature(stmt_expr_attributes)]\n-#![cfg_attr(test, feature(test))]\n #![feature(unboxed_closures)]\n #![feature(unsized_fn_params)]\n-#![feature(c_unwind)]\n #![feature(with_negative_coherence)]\n-#![cfg_attr(test, feature(panic_update_hook))]\n-#![feature(multiple_supertrait_upcastable)]\n+// tidy-alphabetical-end\n //\n // Rustdoc features:\n #![feature(doc_cfg)]"}, {"sha": "04243544b83599203ee606dfd75843481a6dcac1", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -98,11 +98,14 @@\n #![warn(multiple_supertrait_upcastable)]\n //\n // Library features:\n-#![feature(const_align_offset)]\n+// tidy-alphabetical-start\n+#![feature(char_indices_offset)]\n #![feature(const_align_of_val)]\n #![feature(const_align_of_val_raw)]\n+#![feature(const_align_offset)]\n #![feature(const_alloc_layout)]\n #![feature(const_arguments_as_str)]\n+#![feature(const_array_from_ref)]\n #![feature(const_array_into_iter_constructors)]\n #![feature(const_bigint_helper_methods)]\n #![feature(const_black_box)]\n@@ -111,6 +114,9 @@\n #![feature(const_char_from_u32_unchecked)]\n #![feature(const_clone)]\n #![feature(const_cmp)]\n+#![feature(const_convert)]\n+#![feature(const_cstr_methods)]\n+#![feature(const_default_impls)]\n #![feature(const_discriminant)]\n #![feature(const_eval_select)]\n #![feature(const_exact_div)]\n@@ -119,17 +125,17 @@\n #![feature(const_fmt_arguments_new)]\n #![feature(const_hash)]\n #![feature(const_heap)]\n-#![feature(const_convert)]\n #![feature(const_index_range_slice_index)]\n #![feature(const_inherent_unchecked_arith)]\n #![feature(const_int_unchecked_arith)]\n #![feature(const_intrinsic_forget)]\n #![feature(const_ipv4)]\n #![feature(const_ipv6)]\n+#![feature(const_is_char_boundary)]\n #![feature(const_likely)]\n-#![feature(const_maybe_uninit_uninit_array)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n #![feature(const_maybe_uninit_assume_init)]\n+#![feature(const_maybe_uninit_uninit_array)]\n #![feature(const_nonnull_new)]\n #![feature(const_num_from_num)]\n #![feature(const_ops)]\n@@ -138,58 +144,57 @@\n #![feature(const_pin)]\n #![feature(const_pointer_byte_offsets)]\n #![feature(const_pointer_is_aligned)]\n-#![feature(const_ptr_sub_ptr)]\n-#![feature(const_replace)]\n-#![feature(const_result_drop)]\n #![feature(const_ptr_as_ref)]\n #![feature(const_ptr_is_null)]\n #![feature(const_ptr_read)]\n+#![feature(const_ptr_sub_ptr)]\n #![feature(const_ptr_write)]\n #![feature(const_raw_ptr_comparison)]\n+#![feature(const_replace)]\n+#![feature(const_result_drop)]\n #![feature(const_size_of_val)]\n #![feature(const_size_of_val_raw)]\n #![feature(const_slice_from_raw_parts_mut)]\n+#![feature(const_slice_from_ref)]\n+#![feature(const_slice_index)]\n #![feature(const_slice_ptr_len)]\n #![feature(const_slice_split_at_mut)]\n #![feature(const_str_from_utf8_unchecked_mut)]\n #![feature(const_swap)]\n #![feature(const_trait_impl)]\n+#![feature(const_transmute_copy)]\n #![feature(const_try)]\n #![feature(const_type_id)]\n #![feature(const_type_name)]\n-#![feature(const_default_impls)]\n #![feature(const_unicode_case_lookup)]\n #![feature(const_unsafecell_get_mut)]\n #![feature(const_waker)]\n #![feature(core_panic)]\n-#![feature(char_indices_offset)]\n #![feature(duration_consts_float)]\n+#![feature(ip)]\n+#![feature(is_ascii_octdigit)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(ptr_alignment_type)]\n #![feature(ptr_metadata)]\n #![feature(set_ptr_value)]\n #![feature(slice_ptr_get)]\n #![feature(slice_split_at_unchecked)]\n #![feature(str_internals)]\n-#![feature(str_split_remainder)]\n #![feature(str_split_inclusive_remainder)]\n+#![feature(str_split_remainder)]\n #![feature(strict_provenance)]\n #![feature(utf16_extra)]\n #![feature(utf16_extra_const)]\n #![feature(variant_count)]\n-#![feature(const_array_from_ref)]\n-#![feature(const_slice_from_ref)]\n-#![feature(const_slice_index)]\n-#![feature(const_is_char_boundary)]\n-#![feature(const_cstr_methods)]\n-#![feature(ip)]\n-#![feature(is_ascii_octdigit)]\n+// tidy-alphabetical-end\n //\n // Language features:\n+// tidy-alphabetical-start\n #![feature(abi_unadjusted)]\n #![feature(adt_const_params)]\n #![feature(allow_internal_unsafe)]\n #![feature(allow_internal_unstable)]\n+#![feature(asm_const)]\n #![feature(associated_type_bounds)]\n #![feature(auto_traits)]\n #![feature(c_unwind)]\n@@ -206,13 +211,12 @@\n #![feature(deprecated_suggestion)]\n #![feature(derive_const)]\n #![feature(doc_cfg)]\n+#![feature(doc_cfg_hide)]\n #![feature(doc_notable_trait)]\n-#![feature(generic_arg_infer)]\n-#![feature(rustdoc_internals)]\n #![feature(exhaustive_patterns)]\n-#![feature(doc_cfg_hide)]\n #![feature(extern_types)]\n #![feature(fundamental)]\n+#![feature(generic_arg_infer)]\n #![feature(if_let_guard)]\n #![feature(inline_const)]\n #![feature(intra_doc_pointers)]\n@@ -221,6 +225,7 @@\n #![feature(link_llvm_intrinsics)]\n #![feature(macro_metavar_expr)]\n #![feature(min_specialization)]\n+#![feature(multiple_supertrait_upcastable)]\n #![feature(must_not_suspend)]\n #![feature(negative_impls)]\n #![feature(never_type)]\n@@ -231,6 +236,7 @@\n #![feature(repr_simd)]\n #![feature(rustc_allow_const_fn_unstable)]\n #![feature(rustc_attrs)]\n+#![feature(rustdoc_internals)]\n #![feature(simd_ffi)]\n #![feature(staged_api)]\n #![feature(stmt_expr_attributes)]\n@@ -240,11 +246,10 @@\n #![feature(try_blocks)]\n #![feature(unboxed_closures)]\n #![feature(unsized_fn_params)]\n-#![feature(asm_const)]\n-#![feature(const_transmute_copy)]\n-#![feature(multiple_supertrait_upcastable)]\n+// tidy-alphabetical-end\n //\n // Target features:\n+// tidy-alphabetical-start\n #![feature(arm_target_feature)]\n #![feature(avx512_target_feature)]\n #![feature(hexagon_target_feature)]\n@@ -255,6 +260,7 @@\n #![feature(sse4a_target_feature)]\n #![feature(tbm_target_feature)]\n #![feature(wasm_target_feature)]\n+// tidy-alphabetical-end\n \n // allow using `core::` in intra-doc links\n #[allow(unused_extern_crates)]"}, {"sha": "23ed577ea609aaab2a01456428ddadf3b6a62832", "filename": "library/std/src/collections/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -172,7 +172,8 @@\n //!\n //! ## Iterators\n //!\n-//! Iterators are a powerful and robust mechanism used throughout Rust's\n+//! [Iterators][crate::iter]\n+//! are a powerful and robust mechanism used throughout Rust's\n //! standard libraries. Iterators provide a sequence of values in a generic,\n //! safe, efficient and convenient way. The contents of an iterator are usually\n //! *lazily* evaluated, so that only the values that are actually needed are\n@@ -252,7 +253,9 @@\n //!\n //! Several other collection methods also return iterators to yield a sequence\n //! of results but avoid allocating an entire collection to store the result in.\n-//! This provides maximum flexibility as `collect` or `extend` can be called to\n+//! This provides maximum flexibility as\n+//! [`collect`][crate::iter::Iterator::collect] or\n+//! [`extend`][crate::iter::Extend::extend] can be called to\n //! \"pipe\" the sequence into any collection if desired. Otherwise, the sequence\n //! can be looped over with a `for` loop. The iterator can also be discarded\n //! after partial use, preventing the computation of the unused items."}, {"sha": "98fcc76aa98f66982b864f809e94b97b2e9b6955", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -235,6 +235,7 @@\n #![cfg_attr(windows, feature(round_char_boundary))]\n //\n // Language features:\n+// tidy-alphabetical-start\n #![feature(alloc_error_handler)]\n #![feature(allocator_internals)]\n #![feature(allow_internal_unsafe)]\n@@ -256,8 +257,8 @@\n #![feature(intra_doc_pointers)]\n #![feature(lang_items)]\n #![feature(let_chains)]\n-#![feature(linkage)]\n #![feature(link_cfg)]\n+#![feature(linkage)]\n #![feature(min_specialization)]\n #![feature(must_not_suspend)]\n #![feature(needs_panic_runtime)]\n@@ -271,8 +272,10 @@\n #![feature(thread_local)]\n #![feature(try_blocks)]\n #![feature(utf8_chunks)]\n+// tidy-alphabetical-end\n //\n // Library features (core):\n+// tidy-alphabetical-start\n #![feature(char_internals)]\n #![feature(core_intrinsics)]\n #![feature(duration_constants)]\n@@ -289,6 +292,7 @@\n #![feature(ip)]\n #![feature(ip_in_core)]\n #![feature(maybe_uninit_slice)]\n+#![feature(maybe_uninit_uninit_array)]\n #![feature(maybe_uninit_write_slice)]\n #![feature(panic_can_unwind)]\n #![feature(panic_info_message)]\n@@ -306,25 +310,28 @@\n #![feature(std_internals)]\n #![feature(str_internals)]\n #![feature(strict_provenance)]\n-#![feature(maybe_uninit_uninit_array)]\n-#![feature(const_maybe_uninit_uninit_array)]\n-#![feature(const_waker)]\n+// tidy-alphabetical-end\n //\n // Library features (alloc):\n+// tidy-alphabetical-start\n #![feature(alloc_layout_extra)]\n #![feature(allocator_api)]\n #![feature(get_mut_unchecked)]\n #![feature(map_try_insert)]\n #![feature(new_uninit)]\n+#![feature(slice_concat_trait)]\n #![feature(thin_box)]\n #![feature(try_reserve_kind)]\n #![feature(vec_into_raw_parts)]\n-#![feature(slice_concat_trait)]\n+// tidy-alphabetical-end\n //\n // Library features (unwind):\n+// tidy-alphabetical-start\n #![feature(panic_unwind)]\n+// tidy-alphabetical-end\n //\n // Only for re-exporting:\n+// tidy-alphabetical-start\n #![feature(assert_matches)]\n #![feature(async_iterator)]\n #![feature(c_variadic)]\n@@ -336,24 +343,29 @@\n #![feature(custom_test_frameworks)]\n #![feature(edition_panic)]\n #![feature(format_args_nl)]\n-#![feature(log_syntax)]\n+#![feature(get_many_mut)]\n #![feature(lazy_cell)]\n+#![feature(log_syntax)]\n #![feature(saturating_int_impl)]\n #![feature(stdsimd)]\n #![feature(test)]\n #![feature(trace_macros)]\n-#![feature(get_many_mut)]\n+// tidy-alphabetical-end\n //\n // Only used in tests/benchmarks:\n //\n // Only for const-ness:\n+// tidy-alphabetical-start\n #![feature(const_collections_with_hasher)]\n #![feature(const_hash)]\n #![feature(const_io_structs)]\n #![feature(const_ip)]\n #![feature(const_ipv4)]\n #![feature(const_ipv6)]\n+#![feature(const_maybe_uninit_uninit_array)]\n+#![feature(const_waker)]\n #![feature(thread_local_internals)]\n+// tidy-alphabetical-end\n //\n #![default_lib_allocator]\n "}, {"sha": "e959ea06f8b69c50ab0572e56723a90aa70f0c4e", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -591,6 +591,7 @@ pub enum Kind {\n     Install,\n     Run,\n     Setup,\n+    Suggest,\n }\n \n impl Kind {\n@@ -610,6 +611,7 @@ impl Kind {\n             \"install\" => Kind::Install,\n             \"run\" | \"r\" => Kind::Run,\n             \"setup\" => Kind::Setup,\n+            \"suggest\" => Kind::Suggest,\n             _ => return None,\n         })\n     }\n@@ -629,6 +631,7 @@ impl Kind {\n             Kind::Install => \"install\",\n             Kind::Run => \"run\",\n             Kind::Setup => \"setup\",\n+            Kind::Suggest => \"suggest\",\n         }\n     }\n }\n@@ -709,6 +712,7 @@ impl<'a> Builder<'a> {\n                 test::CrateRustdoc,\n                 test::CrateRustdocJsonTypes,\n                 test::CrateJsonDocLint,\n+                test::SuggestTestsCrate,\n                 test::Linkcheck,\n                 test::TierCheck,\n                 test::ReplacePlaceholderTest,\n@@ -827,7 +831,7 @@ impl<'a> Builder<'a> {\n             Kind::Setup => describe!(setup::Profile, setup::Hook, setup::Link, setup::Vscode),\n             Kind::Clean => describe!(clean::CleanAll, clean::Rustc, clean::Std),\n             // special-cased in Build::build()\n-            Kind::Format => vec![],\n+            Kind::Format | Kind::Suggest => vec![],\n         }\n     }\n \n@@ -891,6 +895,7 @@ impl<'a> Builder<'a> {\n             Subcommand::Run { ref paths, .. } => (Kind::Run, &paths[..]),\n             Subcommand::Clean { ref paths, .. } => (Kind::Clean, &paths[..]),\n             Subcommand::Format { .. } => (Kind::Format, &[][..]),\n+            Subcommand::Suggest { .. } => (Kind::Suggest, &[][..]),\n             Subcommand::Setup { profile: ref path } => (\n                 Kind::Setup,\n                 path.as_ref().map_or([].as_slice(), |path| std::slice::from_ref(path)),\n@@ -900,6 +905,21 @@ impl<'a> Builder<'a> {\n         Self::new_internal(build, kind, paths.to_owned())\n     }\n \n+    /// Creates a new standalone builder for use outside of the normal process\n+    pub fn new_standalone(\n+        build: &mut Build,\n+        kind: Kind,\n+        paths: Vec<PathBuf>,\n+        stage: Option<u32>,\n+    ) -> Builder<'_> {\n+        // FIXME: don't mutate `build`\n+        if let Some(stage) = stage {\n+            build.config.stage = stage;\n+        }\n+\n+        Self::new_internal(build, kind, paths.to_owned())\n+    }\n+\n     pub fn execute_cli(&self) {\n         self.run_step_descriptions(&Builder::get_step_descriptions(self.kind), &self.paths);\n     }"}, {"sha": "cc3b3bc25f3d53bfba0c14fb57909972e70b0ed6", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -56,8 +56,7 @@ pub enum DryRun {\n /// filled out from the decoded forms of the structs below. For documentation\n /// each field, see the corresponding fields in\n /// `config.example.toml`.\n-#[derive(Default)]\n-#[cfg_attr(test, derive(Clone))]\n+#[derive(Default, Clone)]\n pub struct Config {\n     pub changelog_seen: Option<usize>,\n     pub ccache: Option<String>,\n@@ -240,32 +239,28 @@ pub struct Config {\n     pub initial_rustfmt: RefCell<RustfmtState>,\n }\n \n-#[derive(Default, Deserialize)]\n-#[cfg_attr(test, derive(Clone))]\n+#[derive(Default, Deserialize, Clone)]\n pub struct Stage0Metadata {\n     pub compiler: CompilerMetadata,\n     pub config: Stage0Config,\n     pub checksums_sha256: HashMap<String, String>,\n     pub rustfmt: Option<RustfmtMetadata>,\n }\n-#[derive(Default, Deserialize)]\n-#[cfg_attr(test, derive(Clone))]\n+#[derive(Default, Deserialize, Clone)]\n pub struct CompilerMetadata {\n     pub date: String,\n     pub version: String,\n }\n \n-#[derive(Default, Deserialize)]\n-#[cfg_attr(test, derive(Clone))]\n+#[derive(Default, Deserialize, Clone)]\n pub struct Stage0Config {\n     pub dist_server: String,\n     pub artifacts_server: String,\n     pub artifacts_with_llvm_assertions_server: String,\n     pub git_merge_commit_email: String,\n     pub nightly_branch: String,\n }\n-#[derive(Default, Deserialize)]\n-#[cfg_attr(test, derive(Clone))]\n+#[derive(Default, Deserialize, Clone)]\n pub struct RustfmtMetadata {\n     pub date: String,\n     pub version: String,\n@@ -443,8 +438,7 @@ impl PartialEq<&str> for TargetSelection {\n }\n \n /// Per-target configuration stored in the global configuration structure.\n-#[derive(Default)]\n-#[cfg_attr(test, derive(Clone))]\n+#[derive(Default, Clone)]\n pub struct Target {\n     /// Some(path to llvm-config) if using an external LLVM.\n     pub llvm_config: Option<PathBuf>,\n@@ -1396,7 +1390,8 @@ impl Config {\n             | Subcommand::Fix { .. }\n             | Subcommand::Run { .. }\n             | Subcommand::Setup { .. }\n-            | Subcommand::Format { .. } => flags.stage.unwrap_or(0),\n+            | Subcommand::Format { .. }\n+            | Subcommand::Suggest { .. } => flags.stage.unwrap_or(0),\n         };\n \n         // CI should always run stage 2 builds, unless it specifically states otherwise\n@@ -1421,7 +1416,8 @@ impl Config {\n                 | Subcommand::Fix { .. }\n                 | Subcommand::Run { .. }\n                 | Subcommand::Setup { .. }\n-                | Subcommand::Format { .. } => {}\n+                | Subcommand::Format { .. }\n+                | Subcommand::Suggest { .. } => {}\n             }\n         }\n "}, {"sha": "b6f5f31039838e6e8bf2e261c8a089b7dfe1ca6c", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -84,8 +84,7 @@ pub struct Flags {\n     pub free_args: Option<Vec<String>>,\n }\n \n-#[derive(Debug)]\n-#[cfg_attr(test, derive(Clone))]\n+#[derive(Debug, Clone)]\n pub enum Subcommand {\n     Build {\n         paths: Vec<PathBuf>,\n@@ -149,6 +148,9 @@ pub enum Subcommand {\n     Setup {\n         profile: Option<PathBuf>,\n     },\n+    Suggest {\n+        run: bool,\n+    },\n }\n \n impl Default for Subcommand {\n@@ -183,6 +185,7 @@ Subcommands:\n     install     Install distribution artifacts\n     run, r      Run tools contained in this repository\n     setup       Create a config.toml (making it easier to use `x.py` itself)\n+    suggest     Suggest a subset of tests to run, based on modified files\n \n To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         );\n@@ -349,6 +352,9 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             Kind::Run => {\n                 opts.optmulti(\"\", \"args\", \"arguments for the tool\", \"ARGS\");\n             }\n+            Kind::Suggest => {\n+                opts.optflag(\"\", \"run\", \"run suggested tests\");\n+            }\n             _ => {}\n         };\n \n@@ -565,7 +571,7 @@ Arguments:\n                     Profile::all_for_help(\"        \").trim_end()\n                 ));\n             }\n-            Kind::Bench | Kind::Clean | Kind::Dist | Kind::Install => {}\n+            Kind::Bench | Kind::Clean | Kind::Dist | Kind::Install | Kind::Suggest => {}\n         };\n         // Get any optional paths which occur after the subcommand\n         let mut paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n@@ -626,6 +632,7 @@ Arguments:\n             Kind::Format => Subcommand::Format { check: matches.opt_present(\"check\"), paths },\n             Kind::Dist => Subcommand::Dist { paths },\n             Kind::Install => Subcommand::Install { paths },\n+            Kind::Suggest => Subcommand::Suggest { run: matches.opt_present(\"run\") },\n             Kind::Run => {\n                 if paths.is_empty() {\n                     println!(\"\\nrun requires at least a path!\\n\");\n@@ -734,6 +741,7 @@ impl Subcommand {\n             Subcommand::Install { .. } => Kind::Install,\n             Subcommand::Run { .. } => Kind::Run,\n             Subcommand::Setup { .. } => Kind::Setup,\n+            Subcommand::Suggest { .. } => Kind::Suggest,\n         }\n     }\n "}, {"sha": "1ecb52e75f190b31bebe166b8ab903f0120380a4", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -58,6 +58,7 @@ mod render_tests;\n mod run;\n mod sanity;\n mod setup;\n+mod suggest;\n mod tarball;\n mod test;\n mod tool;\n@@ -190,6 +191,7 @@ pub enum GitRepo {\n /// although most functions are implemented as free functions rather than\n /// methods specifically on this structure itself (to make it easier to\n /// organize).\n+#[cfg_attr(not(feature = \"build-metrics\"), derive(Clone))]\n pub struct Build {\n     /// User-specified configuration from `config.toml`.\n     config: Config,\n@@ -243,7 +245,7 @@ pub struct Build {\n     metrics: metrics::BuildMetrics,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n struct Crate {\n     name: Interned<String>,\n     deps: HashSet<Interned<String>>,\n@@ -657,13 +659,20 @@ impl Build {\n             job::setup(self);\n         }\n \n-        if let Subcommand::Format { check, paths } = &self.config.cmd {\n-            return format::format(&builder::Builder::new(&self), *check, &paths);\n-        }\n-\n         // Download rustfmt early so that it can be used in rust-analyzer configs.\n         let _ = &builder::Builder::new(&self).initial_rustfmt();\n \n+        // hardcoded subcommands\n+        match &self.config.cmd {\n+            Subcommand::Format { check, paths } => {\n+                return format::format(&builder::Builder::new(&self), *check, &paths);\n+            }\n+            Subcommand::Suggest { run } => {\n+                return suggest::suggest(&builder::Builder::new(&self), *run);\n+            }\n+            _ => (),\n+        }\n+\n         {\n             let builder = builder::Builder::new(&self);\n             if let Some(path) = builder.paths.get(0) {"}, {"sha": "ff20ebec267720cf1ae1479c2a0009dae193c233", "filename": "src/bootstrap/suggest.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fbootstrap%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fbootstrap%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsuggest.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -0,0 +1,80 @@\n+#![cfg_attr(feature = \"build-metrics\", allow(unused))]\n+\n+use std::str::FromStr;\n+\n+use std::path::PathBuf;\n+\n+use crate::{\n+    builder::{Builder, Kind},\n+    tool::Tool,\n+};\n+\n+#[cfg(feature = \"build-metrics\")]\n+pub fn suggest(builder: &Builder<'_>, run: bool) {\n+    panic!(\"`x suggest` is not supported with `build-metrics`\")\n+}\n+\n+/// Suggests a list of possible `x.py` commands to run based on modified files in branch.\n+#[cfg(not(feature = \"build-metrics\"))]\n+pub fn suggest(builder: &Builder<'_>, run: bool) {\n+    let suggestions =\n+        builder.tool_cmd(Tool::SuggestTests).output().expect(\"failed to run `suggest-tests` tool\");\n+\n+    if !suggestions.status.success() {\n+        println!(\"failed to run `suggest-tests` tool ({})\", suggestions.status);\n+        println!(\n+            \"`suggest_tests` stdout:\\n{}`suggest_tests` stderr:\\n{}\",\n+            String::from_utf8(suggestions.stdout).unwrap(),\n+            String::from_utf8(suggestions.stderr).unwrap()\n+        );\n+        panic!(\"failed to run `suggest-tests`\");\n+    }\n+\n+    let suggestions = String::from_utf8(suggestions.stdout).unwrap();\n+    let suggestions = suggestions\n+        .lines()\n+        .map(|line| {\n+            let mut sections = line.split_ascii_whitespace();\n+\n+            // this code expects one suggestion per line in the following format:\n+            // <x_subcommand> {some number of flags} [optional stage number]\n+            let cmd = sections.next().unwrap();\n+            let stage = sections.next_back().map(|s| str::parse(s).ok()).flatten();\n+            let paths: Vec<PathBuf> = sections.map(|p| PathBuf::from_str(p).unwrap()).collect();\n+\n+            (cmd, stage, paths)\n+        })\n+        .collect::<Vec<_>>();\n+\n+    if !suggestions.is_empty() {\n+        println!(\"==== SUGGESTIONS ====\");\n+        for sug in &suggestions {\n+            print!(\"x {} \", sug.0);\n+            if let Some(stage) = sug.1 {\n+                print!(\"--stage {stage} \");\n+            }\n+\n+            for path in &sug.2 {\n+                print!(\"{} \", path.display());\n+            }\n+            println!();\n+        }\n+        println!(\"=====================\");\n+    } else {\n+        println!(\"No suggestions found!\");\n+        return;\n+    }\n+\n+    if run {\n+        for sug in suggestions {\n+            let mut build = builder.build.clone();\n+\n+            let builder =\n+                Builder::new_standalone(&mut build, Kind::parse(&sug.0).unwrap(), sug.2, sug.1);\n+\n+            builder.execute_cli()\n+        }\n+    } else {\n+        println!(\"help: consider using the `--run` flag to automatically run suggested tests\");\n+    }\n+}"}, {"sha": "aedf1ecab13c43b558d8c6596be2ea454dad7880", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -128,6 +128,42 @@ impl Step for CrateJsonDocLint {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct SuggestTestsCrate {\n+    host: TargetSelection,\n+}\n+\n+impl Step for SuggestTestsCrate {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/suggest-tests\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(SuggestTestsCrate { host: run.target });\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) {\n+        let bootstrap_host = builder.config.build;\n+        let compiler = builder.compiler(0, bootstrap_host);\n+\n+        let suggest_tests = tool::prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            Mode::ToolBootstrap,\n+            bootstrap_host,\n+            \"test\",\n+            \"src/tools/suggest-tests\",\n+            SourceType::InTree,\n+            &[],\n+        );\n+        add_flags_and_try_run_tests(builder, &mut suggest_tests.into());\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Linkcheck {\n     host: TargetSelection,"}, {"sha": "d1fd2e8c42cb0edb46fc9db2df573a5fa446ebf3", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -433,6 +433,7 @@ bootstrap_tool!(\n     ReplaceVersionPlaceholder, \"src/tools/replace-version-placeholder\", \"replace-version-placeholder\";\n     CollectLicenseMetadata, \"src/tools/collect-license-metadata\", \"collect-license-metadata\";\n     GenerateCopyright, \"src/tools/generate-copyright\", \"generate-copyright\";\n+    SuggestTests, \"src/tools/suggest-tests\", \"suggest-tests\";\n );\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]"}, {"sha": "b46d80eb362e26209328ba6e045a33e7c586435e", "filename": "src/doc/rustdoc/src/command-line-arguments.md", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -179,7 +179,7 @@ $ rustdoc src/lib.rs --test\n This flag will run your code examples as tests. For more, see [the chapter\n on documentation tests](write-documentation/documentation-tests.md).\n \n-See also `--test-args`.\n+See also `--test-args` and `--test-run-directory`.\n \n ## `--test-args`: pass options to test runner\n \n@@ -194,6 +194,19 @@ For more, see [the chapter on documentation tests](write-documentation/documenta\n \n See also `--test`.\n \n+## `--test-run-directory`: run code examples in a specific directory\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs --test --test-run-directory=/path/to/working/directory\n+```\n+\n+This flag will run your code examples in the specified working directory.\n+For more, see [the chapter on documentation tests](write-documentation/documentation-tests.md).\n+\n+See also `--test`.\n+\n ## `--target`: generate documentation for the specified target triple\n \n Using this flag looks like this:"}, {"sha": "a7d3186fb78b7afcea61203d90046840fa405aa2", "filename": "src/doc/rustdoc/src/write-documentation/documentation-tests.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Fdocumentation-tests.md?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -443,3 +443,15 @@ pub struct ReadmeDoctests;\n \n This will include your README as documentation on the hidden struct `ReadmeDoctests`, which will\n then be tested alongside the rest of your doctests.\n+\n+## Controlling the compilation and run directories\n+\n+By default, `rustdoc --test` will compile and run documentation test examples\n+from the same working directory.\n+The compilation directory is being used for compiler diagnostics, the `file!()` macro and\n+the output of `rustdoc` test runner itself, whereas the run directory has an influence on file-system\n+operations within documentation test examples, such as `std::fs::read_to_string`.\n+\n+The `--test-run-directory` flag allows controlling the run directory separately from the compilation directory.\n+This is particularly useful in workspaces, where compiler invocations and thus diagnostics should be\n+relative to the workspace directory, but documentation test examples should run relative to the crate directory."}, {"sha": "4c81a0979c1a7f6a7c50b007a3c3d1ee4fc1f194", "filename": "src/librustdoc/html/static/js/externs.js", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -65,6 +65,11 @@ let Row;\n  */\n let ResultsTable;\n \n+/**\n+ * @typedef {Map<String, ResultObject>}\n+ */\n+let Results;\n+\n /**\n  * @typedef {{\n  *     desc: string,\n@@ -80,7 +85,7 @@ let ResultsTable;\n  *     ty: number,\n  * }}\n  */\n-let Results;\n+let ResultObject;\n \n /**\n  * A pair of [inputs, outputs], or 0 for null. This is stored in the search index."}, {"sha": "40cdc55bbc3becc8f3a203e86ba8209627f044c1", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 67, "deletions": 57, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -191,7 +191,7 @@ function initSearch(rawSearchIndex) {\n      */\n     let searchIndex;\n     let currentResults;\n-    const ALIASES = Object.create(null);\n+    const ALIASES = new Map();\n \n     function isWhitespace(c) {\n         return \" \\t\\n\\r\".indexOf(c) !== -1;\n@@ -903,10 +903,18 @@ function initSearch(rawSearchIndex) {\n      * @return {ResultsTable}\n      */\n     function execQuery(parsedQuery, searchWords, filterCrates, currentCrate) {\n-        const results_others = {}, results_in_args = {}, results_returned = {};\n+        const results_others = new Map(), results_in_args = new Map(),\n+            results_returned = new Map();\n \n+        /**\n+         * Add extra data to result objects, and filter items that have been\n+         * marked for removal.\n+         *\n+         * @param {[ResultObject]} results\n+         * @returns {[ResultObject]}\n+         */\n         function transformResults(results) {\n-            const duplicates = {};\n+            const duplicates = new Set();\n             const out = [];\n \n             for (const result of results) {\n@@ -919,10 +927,10 @@ function initSearch(rawSearchIndex) {\n                     // To be sure than it some items aren't considered as duplicate.\n                     obj.fullPath += \"|\" + obj.ty;\n \n-                    if (duplicates[obj.fullPath]) {\n+                    if (duplicates.has(obj.fullPath)) {\n                         continue;\n                     }\n-                    duplicates[obj.fullPath] = true;\n+                    duplicates.add(obj.fullPath);\n \n                     obj.href = res[1];\n                     out.push(obj);\n@@ -934,24 +942,30 @@ function initSearch(rawSearchIndex) {\n             return out;\n         }\n \n+        /**\n+         * This function takes a result map, and sorts it by various criteria, including edit\n+         * distance, substring match, and the crate it comes from.\n+         *\n+         * @param {Results} results\n+         * @param {boolean} isType\n+         * @param {string} preferredCrate\n+         * @returns {[ResultObject]}\n+         */\n         function sortResults(results, isType, preferredCrate) {\n-            const userQuery = parsedQuery.userQuery;\n-            const ar = [];\n-            for (const entry in results) {\n-                if (hasOwnPropertyRustdoc(results, entry)) {\n-                    const result = results[entry];\n-                    result.word = searchWords[result.id];\n-                    result.item = searchIndex[result.id] || {};\n-                    ar.push(result);\n-                }\n-            }\n-            results = ar;\n             // if there are no results then return to default and fail\n-            if (results.length === 0) {\n+            if (results.size === 0) {\n                 return [];\n             }\n \n-            results.sort((aaa, bbb) => {\n+            const userQuery = parsedQuery.userQuery;\n+            const result_list = [];\n+            for (const result of results.values()) {\n+                result.word = searchWords[result.id];\n+                result.item = searchIndex[result.id] || {};\n+                result_list.push(result);\n+            }\n+\n+            result_list.sort((aaa, bbb) => {\n                 let a, b;\n \n                 // sort by exact match with regard to the last word (mismatch goes later)\n@@ -1060,7 +1074,7 @@ function initSearch(rawSearchIndex) {\n                 nameSplit = hasPath ? null : parsedQuery.elems[0].path;\n             }\n \n-            for (const result of results) {\n+            for (const result of result_list) {\n                 // this validation does not make sense when searching by types\n                 if (result.dontValidate) {\n                     continue;\n@@ -1073,7 +1087,7 @@ function initSearch(rawSearchIndex) {\n                     result.id = -1;\n                 }\n             }\n-            return transformResults(results);\n+            return transformResults(result_list);\n         }\n \n         /**\n@@ -1096,7 +1110,7 @@ function initSearch(rawSearchIndex) {\n             // The names match, but we need to be sure that all generics kinda\n             // match as well.\n             if (elem.generics.length > 0 && row.generics.length >= elem.generics.length) {\n-                const elems = Object.create(null);\n+                const elems = new Map();\n                 for (const entry of row.generics) {\n                     if (entry.name === \"\") {\n                         // Pure generic, needs to check into it.\n@@ -1106,39 +1120,30 @@ function initSearch(rawSearchIndex) {\n                         }\n                         continue;\n                     }\n-                    if (elems[entry.name] === undefined) {\n-                        elems[entry.name] = [];\n+                    let currentEntryElems;\n+                    if (elems.has(entry.name)) {\n+                        currentEntryElems = elems.get(entry.name);\n+                    } else {\n+                        currentEntryElems = [];\n+                        elems.set(entry.name, currentEntryElems);\n                     }\n-                    elems[entry.name].push(entry.ty);\n+                    currentEntryElems.push(entry.ty);\n                 }\n                 // We need to find the type that matches the most to remove it in order\n                 // to move forward.\n                 const handleGeneric = generic => {\n-                    let match = null;\n-                    if (elems[generic.name]) {\n-                        match = generic.name;\n-                    } else {\n-                        for (const elem_name in elems) {\n-                            if (!hasOwnPropertyRustdoc(elems, elem_name)) {\n-                                continue;\n-                            }\n-                            if (elem_name === generic) {\n-                                match = elem_name;\n-                                break;\n-                            }\n-                        }\n-                    }\n-                    if (match === null) {\n+                    if (!elems.has(generic.name)) {\n                         return false;\n                     }\n-                    const matchIdx = elems[match].findIndex(tmp_elem =>\n+                    const matchElems = elems.get(generic.name);\n+                    const matchIdx = matchElems.findIndex(tmp_elem =>\n                         typePassesFilter(generic.typeFilter, tmp_elem));\n                     if (matchIdx === -1) {\n                         return false;\n                     }\n-                    elems[match].splice(matchIdx, 1);\n-                    if (elems[match].length === 0) {\n-                        delete elems[match];\n+                    matchElems.splice(matchIdx, 1);\n+                    if (matchElems.length === 0) {\n+                        elems.delete(generic.name);\n                     }\n                     return true;\n                 };\n@@ -1424,22 +1429,22 @@ function initSearch(rawSearchIndex) {\n             const aliases = [];\n             const crateAliases = [];\n             if (filterCrates !== null) {\n-                if (ALIASES[filterCrates] && ALIASES[filterCrates][lowerQuery]) {\n-                    const query_aliases = ALIASES[filterCrates][lowerQuery];\n+                if (ALIASES.has(filterCrates) && ALIASES.get(filterCrates).has(lowerQuery)) {\n+                    const query_aliases = ALIASES.get(filterCrates).get(lowerQuery);\n                     for (const alias of query_aliases) {\n                         aliases.push(createAliasFromItem(searchIndex[alias]));\n                     }\n                 }\n             } else {\n-                Object.keys(ALIASES).forEach(crate => {\n-                    if (ALIASES[crate][lowerQuery]) {\n+                for (const [crate, crateAliasesIndex] of ALIASES) {\n+                    if (crateAliasesIndex.has(lowerQuery)) {\n                         const pushTo = crate === currentCrate ? crateAliases : aliases;\n-                        const query_aliases = ALIASES[crate][lowerQuery];\n+                        const query_aliases = crateAliasesIndex.get(lowerQuery);\n                         for (const alias of query_aliases) {\n                             pushTo.push(createAliasFromItem(searchIndex[alias]));\n                         }\n                     }\n-                });\n+                }\n             }\n \n             const sortFunc = (aaa, bbb) => {\n@@ -1496,19 +1501,19 @@ function initSearch(rawSearchIndex) {\n         function addIntoResults(results, fullId, id, index, dist, path_dist, maxEditDistance) {\n             const inBounds = dist <= maxEditDistance || index !== -1;\n             if (dist === 0 || (!parsedQuery.literalSearch && inBounds)) {\n-                if (results[fullId] !== undefined) {\n-                    const result = results[fullId];\n+                if (results.has(fullId)) {\n+                    const result = results.get(fullId);\n                     if (result.dontValidate || result.dist <= dist) {\n                         return;\n                     }\n                 }\n-                results[fullId] = {\n+                results.set(fullId, {\n                     id: id,\n                     index: index,\n                     dontValidate: parsedQuery.literalSearch,\n                     dist: dist,\n                     path_dist: path_dist,\n-                };\n+                });\n             }\n         }\n \n@@ -2345,17 +2350,22 @@ function initSearch(rawSearchIndex) {\n             }\n \n             if (aliases) {\n-                ALIASES[crate] = Object.create(null);\n+                const currentCrateAliases = new Map();\n+                ALIASES.set(crate, currentCrateAliases);\n                 for (const alias_name in aliases) {\n                     if (!hasOwnPropertyRustdoc(aliases, alias_name)) {\n                         continue;\n                     }\n \n-                    if (!hasOwnPropertyRustdoc(ALIASES[crate], alias_name)) {\n-                        ALIASES[crate][alias_name] = [];\n+                    let currentNameAliases;\n+                    if (currentCrateAliases.has(alias_name)) {\n+                        currentNameAliases = currentCrateAliases.get(alias_name);\n+                    } else {\n+                        currentNameAliases = [];\n+                        currentCrateAliases.set(alias_name, currentNameAliases);\n                     }\n                     for (const local_alias of aliases[alias_name]) {\n-                        ALIASES[crate][alias_name].push(local_alias + currentIndex);\n+                        currentNameAliases.push(local_alias + currentIndex);\n                     }\n                 }\n             }"}, {"sha": "60c98cc3831bd8cf9b10626e783dcead1aec43b5", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -284,7 +284,7 @@ fn opts() -> Vec<RustcOptGroup> {\n         stable(\"test-args\", |o| {\n             o.optmulti(\"\", \"test-args\", \"arguments to pass to the test runner\", \"ARGS\")\n         }),\n-        unstable(\"test-run-directory\", |o| {\n+        stable(\"test-run-directory\", |o| {\n             o.optopt(\n                 \"\",\n                 \"test-run-directory\","}, {"sha": "f4f4d548bb79ecd5ba0386656fd991471efe4957", "filename": "src/tools/suggest-tests/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Ftools%2Fsuggest-tests%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Ftools%2Fsuggest-tests%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fsuggest-tests%2FCargo.toml?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+name = \"suggest-tests\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+[dependencies]\n+glob = \"0.3.0\"\n+build_helper = { version = \"0.1.0\", path = \"../build_helper\" }\n+once_cell = \"1.17.1\""}, {"sha": "2b0213cdc223c6a64d0771bef1b843f84f45c6a9", "filename": "src/tools/suggest-tests/src/dynamic_suggestions.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Ftools%2Fsuggest-tests%2Fsrc%2Fdynamic_suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Ftools%2Fsuggest-tests%2Fsrc%2Fdynamic_suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fsuggest-tests%2Fsrc%2Fdynamic_suggestions.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -0,0 +1,23 @@\n+use std::path::Path;\n+\n+use crate::Suggestion;\n+\n+type DynamicSuggestion = fn(&Path) -> Vec<Suggestion>;\n+\n+pub(crate) const DYNAMIC_SUGGESTIONS: &[DynamicSuggestion] = &[|path: &Path| -> Vec<Suggestion> {\n+    if path.starts_with(\"compiler/\") || path.starts_with(\"library/\") {\n+        let path = path.components().take(2).collect::<Vec<_>>();\n+\n+        vec![Suggestion::with_single_path(\n+            \"test\",\n+            None,\n+            &format!(\n+                \"{}/{}\",\n+                path[0].as_os_str().to_str().unwrap(),\n+                path[1].as_os_str().to_str().unwrap()\n+            ),\n+        )]\n+    } else {\n+        Vec::new()\n+    }\n+}];"}, {"sha": "44cd3c7f6a84d56c06735473c90fb7fc43605892", "filename": "src/tools/suggest-tests/src/lib.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Ftools%2Fsuggest-tests%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Ftools%2Fsuggest-tests%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fsuggest-tests%2Fsrc%2Flib.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -0,0 +1,96 @@\n+use std::{\n+    fmt::{self, Display},\n+    path::Path,\n+};\n+\n+use dynamic_suggestions::DYNAMIC_SUGGESTIONS;\n+use glob::Pattern;\n+use static_suggestions::STATIC_SUGGESTIONS;\n+\n+mod dynamic_suggestions;\n+mod static_suggestions;\n+\n+#[cfg(test)]\n+mod tests;\n+\n+macro_rules! sug {\n+    ($cmd:expr) => {\n+        Suggestion::new($cmd, None, &[])\n+    };\n+\n+    ($cmd:expr, $paths:expr) => {\n+        Suggestion::new($cmd, None, $paths.as_slice())\n+    };\n+\n+    ($cmd:expr, $stage:expr, $paths:expr) => {\n+        Suggestion::new($cmd, Some($stage), $paths.as_slice())\n+    };\n+}\n+\n+pub(crate) use sug;\n+\n+pub fn get_suggestions<T: AsRef<str>>(modified_files: &[T]) -> Vec<Suggestion> {\n+    let mut suggestions = Vec::new();\n+\n+    // static suggestions\n+    for sug in STATIC_SUGGESTIONS.iter() {\n+        let glob = Pattern::new(&sug.0).expect(\"Found invalid glob pattern!\");\n+\n+        for file in modified_files {\n+            if glob.matches(file.as_ref()) {\n+                suggestions.extend_from_slice(&sug.1);\n+            }\n+        }\n+    }\n+\n+    // dynamic suggestions\n+    for sug in DYNAMIC_SUGGESTIONS {\n+        for file in modified_files {\n+            let sugs = sug(Path::new(file.as_ref()));\n+\n+            suggestions.extend_from_slice(&sugs);\n+        }\n+    }\n+\n+    suggestions.sort();\n+    suggestions.dedup();\n+\n+    suggestions\n+}\n+\n+#[derive(Clone, PartialOrd, Ord, PartialEq, Eq, Debug)]\n+pub struct Suggestion {\n+    pub cmd: String,\n+    pub stage: Option<u32>,\n+    pub paths: Vec<String>,\n+}\n+\n+impl Suggestion {\n+    pub fn new(cmd: &str, stage: Option<u32>, paths: &[&str]) -> Self {\n+        Self { cmd: cmd.to_owned(), stage, paths: paths.iter().map(|p| p.to_string()).collect() }\n+    }\n+\n+    pub fn with_single_path(cmd: &str, stage: Option<u32>, path: &str) -> Self {\n+        Self::new(cmd, stage, &[path])\n+    }\n+}\n+\n+impl Display for Suggestion {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n+        write!(f, \"{} \", self.cmd)?;\n+\n+        for path in &self.paths {\n+            write!(f, \"{} \", path)?;\n+        }\n+\n+        if let Some(stage) = self.stage {\n+            write!(f, \"{}\", stage)?;\n+        } else {\n+            // write a sentinel value here (in place of a stage) to be consumed\n+            // by the shim in bootstrap, it will be read and ignored.\n+            write!(f, \"N/A\")?;\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "0b541b60cba98a83e93bd11e9d79023f7230725d", "filename": "src/tools/suggest-tests/src/main.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Ftools%2Fsuggest-tests%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Ftools%2Fsuggest-tests%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fsuggest-tests%2Fsrc%2Fmain.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -0,0 +1,27 @@\n+use std::process::ExitCode;\n+\n+use build_helper::git::get_git_modified_files;\n+use suggest_tests::get_suggestions;\n+\n+fn main() -> ExitCode {\n+    let modified_files = get_git_modified_files(None, &Vec::new());\n+    let modified_files = match modified_files {\n+        Ok(Some(files)) => files,\n+        Ok(None) => {\n+            eprintln!(\"git error\");\n+            return ExitCode::FAILURE;\n+        }\n+        Err(err) => {\n+            eprintln!(\"Could not get modified files from git: \\\"{err}\\\"\");\n+            return ExitCode::FAILURE;\n+        }\n+    };\n+\n+    let suggestions = get_suggestions(&modified_files);\n+\n+    for sug in &suggestions {\n+        println!(\"{sug}\");\n+    }\n+\n+    ExitCode::SUCCESS\n+}"}, {"sha": "d8166ead8c49d8d2d0597b0868a51e797aca87e5", "filename": "src/tools/suggest-tests/src/static_suggestions.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Ftools%2Fsuggest-tests%2Fsrc%2Fstatic_suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Ftools%2Fsuggest-tests%2Fsrc%2Fstatic_suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fsuggest-tests%2Fsrc%2Fstatic_suggestions.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -0,0 +1,24 @@\n+use crate::{sug, Suggestion};\n+\n+// FIXME: perhaps this could use `std::lazy` when it is stablizied\n+macro_rules! static_suggestions {\n+    ($( $glob:expr => [ $( $suggestion:expr ),* ] ),*) => {\n+        pub(crate) const STATIC_SUGGESTIONS: ::once_cell::unsync::Lazy<Vec<(&'static str, Vec<Suggestion>)>>\n+            = ::once_cell::unsync::Lazy::new(|| vec![ $( ($glob, vec![ $($suggestion),* ]) ),*]);\n+    }\n+}\n+\n+static_suggestions! {\n+    \"*.md\" => [\n+        sug!(\"test\", 0, [\"linkchecker\"])\n+    ],\n+\n+    \"compiler/*\" => [\n+        sug!(\"check\"),\n+        sug!(\"test\", 1, [\"src/test/ui\", \"src/test/run-make\"])\n+    ],\n+\n+    \"src/librustdoc/*\" => [\n+        sug!(\"test\", 1, [\"rustdoc\"])\n+    ]\n+}"}, {"sha": "5bc1a7df7ca156a4c8478c169dd11941ba5b7c50", "filename": "src/tools/suggest-tests/src/tests.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/src%2Ftools%2Fsuggest-tests%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/src%2Ftools%2Fsuggest-tests%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fsuggest-tests%2Fsrc%2Ftests.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -0,0 +1,21 @@\n+macro_rules! sugg_test {\n+    ( $( $name:ident: $paths:expr => $suggestions:expr ),* ) => {\n+        $(\n+            #[test]\n+            fn $name() {\n+                let suggestions = crate::get_suggestions(&$paths).into_iter().map(|s| s.to_string()).collect::<Vec<_>>();\n+                assert_eq!(suggestions, $suggestions);\n+            }\n+        )*\n+    };\n+}\n+\n+sugg_test! {\n+    test_error_code_docs: [\"compiler/rustc_error_codes/src/error_codes/E0000.md\"] =>\n+        [\"check N/A\", \"test compiler/rustc_error_codes N/A\", \"test linkchecker 0\", \"test src/test/ui src/test/run-make 1\"],\n+\n+    test_rustdoc: [\"src/librustdoc/src/lib.rs\"] => [\"test rustdoc 1\"],\n+\n+    test_rustdoc_and_libstd: [\"src/librustdoc/src/lib.rs\", \"library/std/src/lib.rs\"] =>\n+        [\"test library/std N/A\", \"test rustdoc 1\"]\n+}"}, {"sha": "b8d0647f08d8e0d8a35e70f78febb154da8fa0ab", "filename": "tests/rustdoc-ui/run-directory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/tests%2Frustdoc-ui%2Frun-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/tests%2Frustdoc-ui%2Frun-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Frun-directory.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -2,8 +2,8 @@\n \n // revisions: correct incorrect\n // check-pass\n-// [correct]compile-flags:--test --test-run-directory={{src-base}} -Zunstable-options\n-// [incorrect]compile-flags:--test --test-run-directory={{src-base}}/coverage -Zunstable-options\n+// [correct]compile-flags:--test --test-run-directory={{src-base}}\n+// [incorrect]compile-flags:--test --test-run-directory={{src-base}}/coverage\n // normalize-stdout-test: \"tests/rustdoc-ui\" -> \"$$DIR\"\n // normalize-stdout-test \"finished in \\d+\\.\\d+s\" -> \"finished in $$TIME\"\n "}, {"sha": "dfde8c97ec264beab7187b79191e94b07bb5c478", "filename": "tests/ui-fulldeps/stable-mir/crate-info.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/660c966ff941ddf995d3251df32508b383cd4cee/tests%2Fui-fulldeps%2Fstable-mir%2Fcrate-info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660c966ff941ddf995d3251df32508b383cd4cee/tests%2Fui-fulldeps%2Fstable-mir%2Fcrate-info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fstable-mir%2Fcrate-info.rs?ref=660c966ff941ddf995d3251df32508b383cd4cee", "patch": "@@ -29,6 +29,8 @@ fn test_stable_mir(tcx: TyCtxt<'_>) {\n     let local = stable_mir::local_crate();\n     assert_eq!(&local.name, CRATE_NAME);\n \n+    assert_eq!(stable_mir::entry_fn(), None);\n+\n     // Find items in the local crate.\n     let items = stable_mir::all_local_items();\n     assert!(get_item(tcx, &items, (DefKind::Fn, \"foo_bar\")).is_some());"}]}