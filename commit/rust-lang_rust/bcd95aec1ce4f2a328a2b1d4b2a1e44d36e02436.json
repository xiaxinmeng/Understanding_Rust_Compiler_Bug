{"sha": "bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZDk1YWVjMWNlNGYyYTMyOGEyYjFkNGIyYTFlNDRkMzZlMDI0MzY=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-12T08:46:49Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-12T08:47:09Z"}, "message": "all: make style of lint messages consistent\n\n* start first sentence lowercased\n* use backticks to delimit code snippets\n* use \"this is wrong. Consider doing X.\" consistently", "tree": {"sha": "28d2850cad0d254a4fa7773bf74c18f710a41db1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28d2850cad0d254a4fa7773bf74c18f710a41db1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "html_url": "https://github.com/rust-lang/rust/commit/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ec933377cb528628bc33225b9d2a7223332e731", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ec933377cb528628bc33225b9d2a7223332e731", "html_url": "https://github.com/rust-lang/rust/commit/2ec933377cb528628bc33225b9d2a7223332e731"}], "stats": {"total": 140, "additions": 69, "deletions": 71}, "files": [{"sha": "594348bf93faf52b4e24c67859ff9aae84696d91", "filename": "src/approx_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -53,7 +53,7 @@ fn check_known_consts(cx: &Context, span: Span, str: &str, module: &str) {\n         for &(constant, name) in KNOWN_CONSTS {\n             if within_epsilon(constant, value) {\n                 span_lint(cx, APPROX_CONSTANT, span, &format!(\n-                    \"Approximate value of {}::{} found, consider using it directly.\", module, &name));\n+                    \"approximate value of `{}::{}` found. Consider using it directly.\", module, &name));\n             }\n         }\n     }"}, {"sha": "789a992e3a5c937cd80ffd80c9a27b5b08675a86", "filename": "src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -101,7 +101,7 @@ fn check_attrs(cx: &Context, info: Option<&ExpnInfo>, ident: &Ident,\n             if let MetaWord(ref always) = values[0].node {\n                 if always != &\"always\" { continue; }\n                 span_lint(cx, INLINE_ALWAYS, attr.span, &format!(\n-                    \"You have declared #[inline(always)] on {}. This \\\n+                    \"you have declared `#[inline(always)]` on `{}`. This \\\n                      is usually a bad idea. Are you sure?\",\n                     ident.name.as_str()));\n             }"}, {"sha": "b5f088c23ef5e968341c61f2a269466c50eac4e5", "filename": "src/bit_mask.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -97,7 +97,7 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n             BiBitAnd => if mask_value & cmp_value != mask_value {\n                 if cmp_value != 0 {\n                     span_lint(cx, BAD_BIT_MASK, *span, &format!(\n-                        \"incompatible bit mask: _ & {} can never be equal to {}\",\n+                        \"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n                         mask_value, cmp_value));\n                 }\n             } else {\n@@ -108,15 +108,15 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n             },\n             BiBitOr => if mask_value | cmp_value != cmp_value {\n                 span_lint(cx, BAD_BIT_MASK, *span, &format!(\n-                    \"incompatible bit mask: _ | {} can never be equal to {}\",\n+                    \"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n                     mask_value, cmp_value));\n             },\n             _ => ()\n         },\n         BiLt | BiGe => match bit_op {\n             BiBitAnd => if mask_value < cmp_value {\n                 span_lint(cx, BAD_BIT_MASK, *span, &format!(\n-                    \"incompatible bit mask: _ & {} will always be lower than {}\",\n+                    \"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n                     mask_value, cmp_value));\n             } else {\n                 if mask_value == 0 {\n@@ -126,12 +126,12 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n             },\n             BiBitOr => if mask_value >= cmp_value {\n                 span_lint(cx, BAD_BIT_MASK, *span, &format!(\n-                    \"incompatible bit mask: _ | {} will never be lower than {}\",\n+                    \"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n                     mask_value, cmp_value));\n             } else {\n                 if mask_value < cmp_value {\n                     span_lint(cx, INEFFECTIVE_BIT_MASK, *span, &format!(\n-                        \"ineffective bit mask: x | {} compared to {} is the same as x compared directly\",\n+                        \"ineffective bit mask: `x | {}` compared to `{}` is the same as x compared directly\",\n                         mask_value, cmp_value));\n                 }\n             },\n@@ -140,7 +140,7 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n         BiLe | BiGt => match bit_op {\n             BiBitAnd => if mask_value <= cmp_value {\n                 span_lint(cx, BAD_BIT_MASK, *span, &format!(\n-                    \"incompatible bit mask: _ & {} will never be higher than {}\",\n+                    \"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n                     mask_value, cmp_value));\n             } else {\n                 if mask_value == 0 {\n@@ -150,12 +150,12 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n             },\n             BiBitOr => if mask_value > cmp_value {\n                 span_lint(cx, BAD_BIT_MASK, *span, &format!(\n-                    \"incompatible bit mask: _ | {} will always be higher than {}\",\n+                    \"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n                     mask_value, cmp_value));\n             } else {\n                 if mask_value < cmp_value {\n                     span_lint(cx, INEFFECTIVE_BIT_MASK, *span, &format!(\n-                        \"ineffective bit mask: x | {} compared to {} is the same as x compared directly\",\n+                        \"ineffective bit mask: `x | {}` compared to `{}` is the same as x compared directly\",\n                         mask_value, cmp_value));\n                 }\n             },"}, {"sha": "f1c82f3eef8afa147ef193ea2f7dd583990445f9", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -48,7 +48,7 @@ fn check_expr_expd(cx: &Context, e: &Expr, info: Option<&ExpnInfo>) {\n         if let Some(&Expr{ node: ExprIf(ref check_inner, _, None), ..}) =\n             single_stmt_of_block(then) {\n                 span_lint(cx, COLLAPSIBLE_IF, e.span, &format!(\n-                    \"This if statement can be collapsed. Try: if {} && {}\\n{:?}\",\n+                    \"this if statement can be collapsed. Try: `if {} && {}`\\n{:?}\",\n                     check_to_string(check), check_to_string(check_inner), e));\n             }\n     }"}, {"sha": "00c5a5239819d88df574e2d64f93b61a02decdd7", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -51,7 +51,7 @@ impl LintPass for EtaPass {\n                         }\n                     }\n                     span_lint(cx, REDUNDANT_CLOSURE, expr.span,\n-                                 &format!(\"Redundant closure found, consider using `{}` in its place\",\n+                                 &format!(\"redundant closure found. Consider using `{}` in its place.\",\n                                           expr_to_string(caller))[..])\n                 }\n             }"}, {"sha": "e043ac63026b71a9559b6bfac0a5dfe92044db20", "filename": "src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fidentity_op.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -49,7 +49,7 @@ impl LintPass for IdentityOp {\n fn check(cx: &Context, e: &Expr, m: i8, span: Span, arg: Span) {\n     if have_lit(cx, e, m) {\n         span_lint(cx, IDENTITY_OP, span, &format!(\n-            \"The operation is ineffective. Consider reducing it to '{}'\",\n+            \"the operation is ineffective. Consider reducing it to `{}`.\",\n            snippet(cx, arg, \"..\")));\n     }\n }"}, {"sha": "dea713180f50ee89b8d4ea7b29ac1b8b6a00e599", "filename": "src/len_zero.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -58,8 +58,8 @@ fn check_trait_items(cx: &Context, item: &Item, trait_items: &[P<TraitItem>]) {\n         for i in trait_items {\n             if is_named_self(i, \"len\") {\n                 span_lint(cx, LEN_WITHOUT_IS_EMPTY, i.span,\n-                          &format!(\"Trait '{}' has a '.len(_: &Self)' method, but no \\\n-                                    '.is_empty(_: &Self)' method. Consider adding one.\",\n+                          &format!(\"trait `{}` has a `.len(_: &Self)` method, but no \\\n+                                    `.is_empty(_: &Self)` method. Consider adding one.\",\n                                    item.ident.name));\n             }\n         };\n@@ -78,8 +78,8 @@ fn check_impl_items(cx: &Context, item: &Item, impl_items: &[P<ImplItem>]) {\n                 let s = i.span;\n                 span_lint(cx, LEN_WITHOUT_IS_EMPTY,\n                           Span{ lo: s.lo, hi: s.lo, expn_id: s.expn_id },\n-                          &format!(\"Item '{}' has a '.len(_: &Self)' method, but no \\\n-                                    '.is_empty(_: &Self)' method. Consider adding one.\",\n+                          &format!(\"item `{}` has a `.len(_: &Self)` method, but no \\\n+                                    `.is_empty(_: &Self)` method. Consider adding one.\",\n                                    item.ident.name));\n                 return;\n             }\n@@ -108,7 +108,7 @@ fn check_len_zero(cx: &Context, span: Span, method: &SpannedIdent,\n         if method.node.name == \"len\" && args.len() == 1 &&\n             has_is_empty(cx, &*args[0]) {\n                 span_lint(cx, LEN_ZERO, span, &format!(\n-                    \"Consider replacing the len comparison with '{}_.is_empty()'\",\n+                    \"consider replacing the len comparison with `{}_.is_empty()`\",\n                     empty))\n             }\n     }"}, {"sha": "fa1847aad9a24d5b61a5a75cd5e168bb1660bc7b", "filename": "src/misc.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -43,10 +43,10 @@ impl LintPass for MiscPass {\n                             format!(\"{{ {} }}\", body_code)\n                         };\n                         span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n-                              \"You seem to be trying to use match for \\\n+                              \"you seem to be trying to use match for \\\n                               destructuring a single pattern. Did you mean to \\\n                               use `if let`?\",\n-                              &*format!(\"Try\\nif let {} = {} {}\",\n+                              &*format!(\"try\\nif let {} = {} {}\",\n                                         snippet(cx, arms[0].pats[0].span, \"..\"),\n                                         snippet(cx, ex.span, \"..\"),\n                                         suggestion)\n@@ -74,7 +74,7 @@ impl LintPass for StrToStringPass {\n             ast::ExprMethodCall(ref method, _, ref args)\n                 if method.node.name == \"to_string\"\n                 && is_str(cx, &*args[0]) => {\n-                span_lint(cx, STR_TO_STRING, expr.span, \"str.to_owned() is faster\");\n+                span_lint(cx, STR_TO_STRING, expr.span, \"`str.to_owned()` is faster\");\n             },\n             _ => ()\n         }\n@@ -105,7 +105,7 @@ impl LintPass for TopLevelRefPass {\n                 span_lint(cx,\n                     TOPLEVEL_REF_ARG,\n                     arg.pat.span,\n-                    \"`ref` directly on a function argument is ignored. Have you considered using a reference type instead?\"\n+                    \"`ref` directly on a function argument is ignored. Consider using a reference type instead.\"\n                 );\n             }\n         }\n@@ -139,7 +139,7 @@ impl LintPass for CmpNan {\n fn check_nan(cx: &Context, path: &Path, span: Span) {\n     path.segments.last().map(|seg| if seg.identifier.name == \"NAN\" {\n         span_lint(cx, CMP_NAN, span,\n-                  \"Doomed comparison with NAN, use std::{f32,f64}::is_nan instead\");\n+                  \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n     });\n }\n \n@@ -159,7 +159,7 @@ impl LintPass for FloatCmp {\n             let op = cmp.node;\n             if (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n                 span_lint(cx, FLOAT_CMP, expr.span, &format!(\n-                    \"{}-Comparison of f32 or f64 detected. You may want to change this to 'abs({} - {}) < epsilon' for some suitable value of epsilon\",\n+                    \"{}-comparison of f32 or f64 detected. Consider changing this to `abs({} - {}) < epsilon` for some suitable value of epsilon.\",\n                     binop_to_string(op), snippet(cx, left.span, \"..\"),\n                     snippet(cx, right.span, \"..\")));\n             }\n@@ -190,7 +190,7 @@ impl LintPass for Precedence {\n         if let ExprBinary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n             if is_bit_op(op) && (is_arith_expr(left) || is_arith_expr(right)) {\n                 span_lint(cx, PRECEDENCE, expr.span,\n-                    \"Operator precedence can trip the unwary. Consider adding parenthesis to the subexpression.\");\n+                    \"operator precedence can trip the unwary. Consider adding parenthesis to the subexpression.\");\n             }\n         }\n     }\n@@ -246,7 +246,7 @@ fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n                 name == \"to_owned\" && is_str_arg(cx, args) {\n                     span_lint(cx, CMP_OWNED, expr.span, &format!(\n                         \"this creates an owned instance just for comparison. \\\n-                         Consider using {}.as_slice() to compare without allocation\",\n+                         Consider using `{}.as_slice()` to compare without allocation.\",\n                         snippet(cx, other_span, \"..\")))\n                 }\n         },\n@@ -256,7 +256,7 @@ fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n                     match_path(path, &[\"String\", \"from\"]) {\n                         span_lint(cx, CMP_OWNED, expr.span, &format!(\n                             \"this creates an owned instance just for comparison. \\\n-                             Consider using {}.as_slice() to compare without allocation\",\n+                             Consider using `{}.as_slice()` to compare without allocation.\",\n                             snippet(cx, other_span, \"..\")))\n                     }\n             }\n@@ -284,7 +284,7 @@ impl LintPass for ModuloOne {\n         if let ExprBinary(ref cmp, _, ref right) = expr.node {\n             if let &Spanned {node: BinOp_::BiRem, ..} = cmp {\n                 if is_lit_one(right) {\n-                    cx.span_lint(MODULO_ONE, expr.span, \"Any number modulo 1 will be 0\");\n+                    cx.span_lint(MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n                 }\n             }\n         }"}, {"sha": "469a14a94520dc210263b8491164a268b36c77a4", "filename": "src/mut_mut.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -23,7 +23,7 @@ impl LintPass for MutMut {\n \n     fn check_ty(&mut self, cx: &Context, ty: &Ty) {\n         unwrap_mut(ty).and_then(unwrap_mut).map_or((), |_| span_lint(cx, MUT_MUT,\n-            ty.span, \"Generally you want to avoid &mut &mut _ if possible.\"))\n+            ty.span, \"generally you want to avoid `&mut &mut _` if possible\"))\n     }\n }\n \n@@ -40,13 +40,13 @@ fn check_expr_expd(cx: &Context, expr: &Expr, info: Option<&ExpnInfo>) {\n     unwrap_addr(expr).map_or((), |e| {\n         unwrap_addr(e).map(|_| {\n             span_lint(cx, MUT_MUT, expr.span,\n-                      \"Generally you want to avoid &mut &mut _ if possible.\")\n+                      \"generally you want to avoid `&mut &mut _` if possible\")\n         }).unwrap_or_else(|| {\n             if let TyRef(_, TypeAndMut{ty: _, mutbl: MutMutable}) =\n                 cx.tcx.expr_ty(e).sty {\n                     span_lint(cx, MUT_MUT, expr.span,\n-                              \"This expression mutably borrows a mutable reference. \\\n-                               Consider reborrowing\")\n+                              \"this expression mutably borrows a mutable reference. \\\n+                               Consider reborrowing.\")\n                 }\n         })\n     })"}, {"sha": "fcbc287e30fca14aebe80370152e23d43bc2f2e4", "filename": "src/needless_bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -34,10 +34,10 @@ impl LintPass for NeedlessBool {\n                               \"your if-then-else expression will always return true\"); },\n                 (Option::Some(true), Option::Some(false)) => {\n                     span_lint(cx, NEEDLESS_BOOL, e.span,\n-                              \"you can reduce your if-statement to its predicate\"); },\n+                              \"you can reduce your if statement to its predicate\"); },\n                 (Option::Some(false), Option::Some(true)) => {\n                     span_lint(cx, NEEDLESS_BOOL, e.span,\n-                              \"you can reduce your if-statement to '!' + your predicate\"); },\n+                              \"you can reduce your if statement to `!` + your predicate\"); },\n                 (Option::Some(false), Option::Some(false)) => {\n                     span_lint(cx, NEEDLESS_BOOL, e.span,\n                               \"your if-then-else expression will always return false\"); },"}, {"sha": "ed37c1120405ed23ba1d8a39746c475a8e0f8976", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -60,10 +60,10 @@ fn check_ptr_subtype(cx: &Context, span: Span, ty: &Ty) {\n     match_ty_unwrap(ty, &[\"Vec\"]).map_or_else(|| match_ty_unwrap(ty,\n         &[\"String\"]).map_or((), |_| {\n             span_lint(cx, PTR_ARG, span,\n-                      \"Writing '&String' instead of '&str' involves a new Object \\\n-                       where a slices will do. Consider changing the type to &str\")\n+                      \"writing `&String` instead of `&str` involves a new object \\\n+                       where a slice will do. Consider changing the type to `&str`.\")\n         }), |_| span_lint(cx, PTR_ARG, span,\n-                          \"Writing '&Vec<_>' instead of \\\n-                           '&[_]' involves one more reference and cannot be used with \\\n-                           non-vec-based slices. Consider changing the type to &[...]\"))\n+                          \"writing `&Vec<_>` instead of \\\n+                           `&[_]` involves one more reference and cannot be used with \\\n+                           non-Vec-based slices. Consider changing the type to `&[...]`.\"))\n }"}, {"sha": "70af37d5181e21ac0dcc27811eb843d32de763ce", "filename": "src/returns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freturns.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -59,7 +59,7 @@ impl ReturnPass {\n \n     fn emit_return_lint(&mut self, cx: &Context, spans: (Span, Span)) {\n         span_lint(cx, NEEDLESS_RETURN, spans.0, &format!(\n-            \"unneeded return statement. Consider using {} \\\n+            \"unneeded return statement. Consider using `{}` \\\n              without the trailing semicolon\",\n             snippet(cx, spans.1, \"..\")))\n     }"}, {"sha": "97016f362681e41d61491c4768475b7e3d4f66a3", "filename": "src/strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -29,8 +29,8 @@ impl LintPass for StringAdd {\n         if let &ExprAssign(ref target, ref  src) = &e.node {\n             if is_string(cx, target) && is_add(src, target) {\n                 span_lint(cx, STRING_ADD_ASSIGN, e.span,\n-                    \"You assign the result of adding something to this string. \\\n-                    Consider using `String::push_str(..) instead.\")\n+                    \"you assign the result of adding something to this string. \\\n+                    Consider using `String::push_str()` instead.\")\n             }\n         }\n     }"}, {"sha": "b03829660dcc85caf48cc91a35fc9c150281e7ed", "filename": "src/types.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -1,5 +1,3 @@\n-\n-\n use syntax::ptr::P;\n use syntax::ast;\n use syntax::ast::*;\n@@ -55,8 +53,8 @@ impl LintPass for TypePass {\n           .and_then(|t| match_ty_unwrap(&**t, &[\"std\", \"vec\", \"Vec\"]))\n           .map(|_| {\n             span_help_and_lint(cx, BOX_VEC, ty.span,\n-                              \"You seem to be trying to use Box<Vec<T>>. Did you mean to use Vec<T>?\",\n-                              \"Vec<T> is already on the heap, Box<Vec<T>> makes an extra allocation\");\n+                              \"you seem to be trying to use `Box<Vec<T>>`. Did you mean to use `Vec<T>`?\",\n+                              \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\");\n           });\n         {\n             // In case stuff gets moved around\n@@ -71,7 +69,7 @@ impl LintPass for TypePass {\n             if match_ty_unwrap(ty, &path[..]).is_some() {\n                 span_help_and_lint(cx, LINKEDLIST, ty.span,\n                                    \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                                   \"A RingBuf might work.\");\n+                                   \"a RingBuf might work\");\n                 return;\n             }\n         }"}, {"sha": "af48c9b99ad5232c44ba8c92c817b875eb0628e4", "filename": "src/unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/src%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funicode.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -41,6 +41,6 @@ fn lint_zero_width(cx: &Context, span: Span, start: Option<usize>) {\n             lo: span.lo + BytePos(index as u32),\n             hi: span.lo + BytePos(index as u32),\n             expn_id: span.expn_id,\n-        }, \"Zero-width space detected. Consider using \\\\u{200B}\")\n+        }, \"zero-width space detected. Consider using `\\\\u{200B}`.\")\n     });\n }"}, {"sha": "ca7a0d5c07b0f6a10737166472a8e0246857d58c", "filename": "tests/compile-fail/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fattrs.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -3,7 +3,7 @@\n \n #![deny(inline_always)]\n \n-#[inline(always)] //~ERROR You have declared #[inline(always)] on test_attr_lint.\n+#[inline(always)] //~ERROR you have declared `#[inline(always)]` on `test_attr_lint`.\n fn test_attr_lint() {\n     assert!(true)\n }"}, {"sha": "58e780f190ce89c9b7dfe231d9f248f36dadee00", "filename": "tests/compile-fail/box_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Fbox_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Fbox_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbox_vec.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -3,7 +3,7 @@\n #![plugin(clippy)]\n #![deny(clippy)]\n \n-pub fn test(foo: Box<Vec<bool>>) { //~ ERROR You seem to be trying to use Box<Vec<T>>\n+pub fn test(foo: Box<Vec<bool>>) { //~ ERROR you seem to be trying to use `Box<Vec<T>>`\n     println!(\"{:?}\", foo.get(0))\n }\n "}, {"sha": "cc63e895f1c1f245179257c307abc12da3cabae6", "filename": "tests/compile-fail/collapsible_if.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcollapsible_if.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -5,13 +5,13 @@\n fn main() {\n     let x = \"hello\";\n     let y = \"world\";\n-    if x == \"hello\" { //~ERROR This if statement can be collapsed\n+    if x == \"hello\" { //~ERROR this if statement can be collapsed\n         if y == \"world\" {\n             println!(\"Hello world!\");\n         }\n     }\n \n-    if x == \"hello\" || x == \"world\" { //~ERROR This if statement can be collapsed\n+    if x == \"hello\" || x == \"world\" { //~ERROR this if statement can be collapsed\n         if y == \"world\" || y == \"hello\" {\n             println!(\"Hello world!\");\n         }"}, {"sha": "9e48ec1c3a5169029fdcd305751671b4d0543689", "filename": "tests/compile-fail/eta.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Feta.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -5,11 +5,11 @@\n \n fn main() {\n     let a = |a, b| foo(a, b);\n-    //~^ ERROR Redundant closure found, consider using `foo` in its place\n+    //~^ ERROR redundant closure found. Consider using `foo` in its place\n     let c = |a, b| {1+2; foo}(a, b);\n-    //~^ ERROR Redundant closure found, consider using `{ 1 + 2; foo }` in its place\n+    //~^ ERROR redundant closure found. Consider using `{ 1 + 2; foo }` in its place\n     let d = |a, b| foo((|c, d| foo2(c,d))(a,b), b);\n-    //~^ ERROR Redundant closure found, consider using `foo2` in its place\n+    //~^ ERROR redundant closure found. Consider using `foo2` in its place\n }\n \n fn foo(_: u8, _: u8) {\n@@ -18,4 +18,4 @@ fn foo(_: u8, _: u8) {\n \n fn foo2(_: u8, _: u8) -> u8 {\n     1u8\n-}\n\\ No newline at end of file\n+}"}, {"sha": "3785a518e2b313b5ddf374593bfc55612666d470", "filename": "tests/compile-fail/len_zero.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flen_zero.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -5,14 +5,14 @@ struct One;\n \n #[deny(len_without_is_empty)]\n impl One {\n-    fn len(self: &Self) -> isize { //~ERROR Item 'One' has a '.len(_: &Self)'\n+    fn len(self: &Self) -> isize { //~ERROR item `One` has a `.len(_: &Self)`\n         1\n     }\n }\n \n #[deny(len_without_is_empty)]\n trait TraitsToo {\n-    fn len(self: &Self) -> isize; //~ERROR Trait 'TraitsToo' has a '.len(_:\n+    fn len(self: &Self) -> isize; //~ERROR trait `TraitsToo` has a `.len(_:\n }\n \n impl TraitsToo for One {\n@@ -56,7 +56,7 @@ struct HasWrongIsEmpty;\n \n #[deny(len_without_is_empty)]\n impl HasWrongIsEmpty {\n-    fn len(self: &Self) -> isize { //~ERROR Item 'HasWrongIsEmpty' has a '.len(_: &Self)'\n+    fn len(self: &Self) -> isize { //~ERROR item `HasWrongIsEmpty` has a `.len(_: &Self)`\n         1\n     }\n \n@@ -69,7 +69,7 @@ impl HasWrongIsEmpty {\n #[deny(len_zero)]\n fn main() {\n     let x = [1, 2];\n-    if x.len() == 0 { //~ERROR Consider replacing the len comparison\n+    if x.len() == 0 { //~ERROR consider replacing the len comparison\n         println!(\"This should not happen!\");\n     }\n \n@@ -84,13 +84,13 @@ fn main() {\n     }\n \n     let hie = HasIsEmpty;\n-    if hie.len() == 0 { //~ERROR Consider replacing the len comparison\n+    if hie.len() == 0 { //~ERROR consider replacing the len comparison\n         println!(\"Or this!\");\n     }\n     assert!(!hie.is_empty());\n \n     let wie : &WithIsEmpty = &Wither;\n-    if wie.len() == 0 { //~ERROR Consider replacing the len comparison\n+    if wie.len() == 0 { //~ERROR consider replacing the len comparison\n         println!(\"Or this!\");\n     }\n     assert!(!wie.is_empty());"}, {"sha": "01bfe7447136e43984e83825be2fb6aabdfcba31", "filename": "tests/compile-fail/match_if_let.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Fmatch_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Fmatch_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatch_if_let.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -5,8 +5,8 @@\n \n fn main(){\n     let x = Some(1u8);\n-    match x {  //~ ERROR You seem to be trying to use match\n-               //~^ HELP Try\n+    match x {  //~ ERROR you seem to be trying to use match\n+               //~^ HELP try\n         Some(y) => {\n             println!(\"{:?}\", y);\n         }\n@@ -18,8 +18,8 @@ fn main(){\n         None => ()\n     }\n     let z = (1u8,1u8);\n-    match z { //~ ERROR You seem to be trying to use match\n-              //~^ HELP Try\n+    match z { //~ ERROR you seem to be trying to use match\n+              //~^ HELP try\n         (2...3, 7...9) => println!(\"{:?}\", z),\n         _ => {}\n     }"}, {"sha": "1301b4e499c336be25fbecb3ae9a347e6fcec58a", "filename": "tests/compile-fail/modulo_one.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Fmodulo_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Fmodulo_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmodulo_one.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -3,6 +3,6 @@\n #![deny(modulo_one)]\n \n fn main() {\n-    10 % 1; //~ERROR Any number modulo 1 will be 0\n+    10 % 1; //~ERROR any number modulo 1 will be 0\n     10 % 2;\n }"}, {"sha": "d56ea735a1d9d2a99f6261373b1aeed9115cad72", "filename": "tests/compile-fail/ptr_arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_arg.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -3,7 +3,7 @@\n \n #[deny(ptr_arg)]\n #[allow(unused)]\n-fn do_vec(x: &Vec<i64>) { //~ERROR: Writing '&Vec<_>' instead of '&[_]'\n+fn do_vec(x: &Vec<i64>) { //~ERROR: writing `&Vec<_>` instead of `&[_]`\n     //Nothing here\n }\n "}, {"sha": "60edf2577e73c0c9198156a6f984e3967851567b", "filename": "tests/compile-fail/unicode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436/tests%2Fcompile-fail%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funicode.rs?ref=bcd95aec1ce4f2a328a2b1d4b2a1e44d36e02436", "patch": "@@ -4,13 +4,13 @@\n #[deny(zero_width_space)]\n fn zero() {\n     print!(\"Here >\u200b< is a ZWS, and \u200banother\");\n-                            //~^ ERROR Zero-width space detected. Consider using \\u{200B}\n-                              //~^^ ERROR Zero-width space detected. Consider using \\u{200B}\n+                            //~^ ERROR zero-width space detected. Consider using `\\u{200B}`\n+                              //~^^ ERROR zero-width space detected. Consider using `\\u{200B}`\n }\n \n //#[deny(unicode_canon)]\n fn canon() {\n-    print!(\"\u0300ah?\"); //not yet ~ERROR Non-canonical unicode sequence detected. Consider using \u00e0\n+    print!(\"\u0300ah?\"); //not yet ~ERROR non-canonical unicode sequence detected. Consider using \u00e0\n }\n \n //#[deny(ascii_only)]"}]}