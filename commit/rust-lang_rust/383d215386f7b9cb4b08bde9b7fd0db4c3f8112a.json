{"sha": "383d215386f7b9cb4b08bde9b7fd0db4c3f8112a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4M2QyMTUzODZmN2I5Y2I0YjA4YmRlOWI3ZmQwZGI0YzNmODExMmE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-11T13:18:51Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-11T13:18:51Z"}, "message": "make some functions private to StackedBorrows", "tree": {"sha": "92dfadc7fd354bf1c5bf215f1c29bc7b5d2461ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92dfadc7fd354bf1c5bf215f1c29bc7b5d2461ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/383d215386f7b9cb4b08bde9b7fd0db4c3f8112a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/383d215386f7b9cb4b08bde9b7fd0db4c3f8112a", "html_url": "https://github.com/rust-lang/rust/commit/383d215386f7b9cb4b08bde9b7fd0db4c3f8112a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/383d215386f7b9cb4b08bde9b7fd0db4c3f8112a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9de605b32f830ece9abaf3476bba418ab3b3d213", "url": "https://api.github.com/repos/rust-lang/rust/commits/9de605b32f830ece9abaf3476bba418ab3b3d213", "html_url": "https://github.com/rust-lang/rust/commit/9de605b32f830ece9abaf3476bba418ab3b3d213"}], "stats": {"total": 149, "additions": 76, "deletions": 73}, "files": [{"sha": "748ac020d6a81eb1e63a873f9691b2d75274d100", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 76, "deletions": 73, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/383d215386f7b9cb4b08bde9b7fd0db4c3f8112a/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383d215386f7b9cb4b08bde9b7fd0db4c3f8112a/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=383d215386f7b9cb4b08bde9b7fd0db4c3f8112a", "patch": "@@ -516,6 +516,82 @@ impl<'tcx> Stacks {\n     }\n }\n \n+impl<'a, 'mir, 'tcx> EvalContextPrivExt<'a, 'mir, 'tcx> for crate::MiriEvalContext<'a, 'mir, 'tcx> {}\n+trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a, 'mir, 'tcx> {\n+    fn reborrow(\n+        &mut self,\n+        place: MPlaceTy<'tcx, Borrow>,\n+        size: Size,\n+        fn_barrier: bool,\n+        new_bor: Borrow\n+    ) -> EvalResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let ptr = place.ptr.to_ptr()?;\n+        let barrier = if fn_barrier { Some(this.frame().extra) } else { None };\n+        trace!(\"reborrow: Creating new reference for {:?} (pointee {}): {:?}\",\n+            ptr, place.layout.ty, new_bor);\n+\n+        // Get the allocation.  It might not be mutable, so we cannot use `get_mut`.\n+        let alloc = this.memory().get(ptr.alloc_id)?;\n+        alloc.check_bounds(this, ptr, size)?;\n+        // Update the stacks.\n+        if let Borrow::Shr(Some(_)) = new_bor {\n+            // Reference that cares about freezing. We need a frozen-sensitive reborrow.\n+            this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n+                let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n+                alloc.extra.reborrow(cur_ptr, size, barrier, new_bor, kind)\n+            })?;\n+        } else {\n+            // Just treat this as one big chunk.\n+            let kind = if new_bor.is_unique() { RefKind::Unique } else { RefKind::Raw };\n+            alloc.extra.reborrow(ptr, size, barrier, new_bor, kind)?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Retag an indidual pointer, returning the retagged version.\n+    fn retag_reference(\n+        &mut self,\n+        val: ImmTy<'tcx, Borrow>,\n+        mutbl: Mutability,\n+        fn_barrier: bool,\n+        two_phase: bool,\n+    ) -> EvalResult<'tcx, Immediate<Borrow>> {\n+        let this = self.eval_context_mut();\n+        // We want a place for where the ptr *points to*, so we get one.\n+        let place = this.ref_to_mplace(val)?;\n+        let size = this.size_and_align_of_mplace(place)?\n+            .map(|(size, _)| size)\n+            .unwrap_or_else(|| place.layout.size);\n+        if size == Size::ZERO {\n+            // Nothing to do for ZSTs.\n+            return Ok(*val);\n+        }\n+\n+        // Compute new borrow.\n+        let time = this.machine.stacked_borrows.increment_clock();\n+        let new_bor = match mutbl {\n+            MutMutable => Borrow::Uniq(time),\n+            MutImmutable => Borrow::Shr(Some(time)),\n+        };\n+\n+        // Reborrow.\n+        this.reborrow(place, size, fn_barrier, new_bor)?;\n+        let new_place = place.with_tag(new_bor);\n+        // Handle two-phase borrows.\n+        if two_phase {\n+            assert!(mutbl == MutMutable, \"two-phase shared borrows make no sense\");\n+            // We immediately share it, to allow read accesses\n+            let two_phase_time = this.machine.stacked_borrows.increment_clock();\n+            let two_phase_bor = Borrow::Shr(Some(two_phase_time));\n+            this.reborrow(new_place, size, /*fn_barrier*/false, two_phase_bor)?;\n+        }\n+\n+        // Return new ptr.\n+        Ok(new_place.to_ref())\n+    }\n+}\n+\n impl<'a, 'mir, 'tcx> EvalContextExt<'a, 'mir, 'tcx> for crate::MiriEvalContext<'a, 'mir, 'tcx> {}\n pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a, 'mir, 'tcx> {\n     fn tag_new_allocation(\n@@ -601,79 +677,6 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         Ok(())\n     }\n \n-    fn reborrow(\n-        &mut self,\n-        place: MPlaceTy<'tcx, Borrow>,\n-        size: Size,\n-        fn_barrier: bool,\n-        new_bor: Borrow\n-    ) -> EvalResult<'tcx> {\n-        let this = self.eval_context_mut();\n-        let ptr = place.ptr.to_ptr()?;\n-        let barrier = if fn_barrier { Some(this.frame().extra) } else { None };\n-        trace!(\"reborrow: Creating new reference for {:?} (pointee {}): {:?}\",\n-            ptr, place.layout.ty, new_bor);\n-\n-        // Get the allocation.  It might not be mutable, so we cannot use `get_mut`.\n-        let alloc = this.memory().get(ptr.alloc_id)?;\n-        alloc.check_bounds(this, ptr, size)?;\n-        // Update the stacks.\n-        if let Borrow::Shr(Some(_)) = new_bor {\n-            // Reference that cares about freezing. We need a frozen-sensitive reborrow.\n-            this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n-                let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n-                alloc.extra.reborrow(cur_ptr, size, barrier, new_bor, kind)\n-            })?;\n-        } else {\n-            // Just treat this as one big chunk.\n-            let kind = if new_bor.is_unique() { RefKind::Unique } else { RefKind::Raw };\n-            alloc.extra.reborrow(ptr, size, barrier, new_bor, kind)?;\n-        }\n-        Ok(())\n-    }\n-\n-    /// Retag an indidual pointer, returning the retagged version.\n-    fn retag_reference(\n-        &mut self,\n-        val: ImmTy<'tcx, Borrow>,\n-        mutbl: Mutability,\n-        fn_barrier: bool,\n-        two_phase: bool,\n-    ) -> EvalResult<'tcx, Immediate<Borrow>> {\n-        let this = self.eval_context_mut();\n-        // We want a place for where the ptr *points to*, so we get one.\n-        let place = this.ref_to_mplace(val)?;\n-        let size = this.size_and_align_of_mplace(place)?\n-            .map(|(size, _)| size)\n-            .unwrap_or_else(|| place.layout.size);\n-        if size == Size::ZERO {\n-            // Nothing to do for ZSTs.\n-            return Ok(*val);\n-        }\n-\n-        // Compute new borrow.\n-        let time = this.machine.stacked_borrows.increment_clock();\n-        let new_bor = match mutbl {\n-            MutMutable => Borrow::Uniq(time),\n-            MutImmutable => Borrow::Shr(Some(time)),\n-        };\n-\n-        // Reborrow.\n-        this.reborrow(place, size, fn_barrier, new_bor)?;\n-        let new_place = place.with_tag(new_bor);\n-        // Handle two-phase borrows.\n-        if two_phase {\n-            assert!(mutbl == MutMutable, \"two-phase shared borrows make no sense\");\n-            // We immediately share it, to allow read accesses\n-            let two_phase_time = this.machine.stacked_borrows.increment_clock();\n-            let two_phase_bor = Borrow::Shr(Some(two_phase_time));\n-            this.reborrow(new_place, size, /*fn_barrier*/false, two_phase_bor)?;\n-        }\n-\n-        // Return new ptr.\n-        Ok(new_place.to_ref())\n-    }\n-\n     fn retag(\n         &mut self,\n         fn_entry: bool,"}]}