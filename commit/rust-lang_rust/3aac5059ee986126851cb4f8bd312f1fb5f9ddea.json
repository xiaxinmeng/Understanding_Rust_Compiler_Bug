{"sha": "3aac5059ee986126851cb4f8bd312f1fb5f9ddea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYWM1MDU5ZWU5ODYxMjY4NTFjYjRmOGJkMzEyZjFmYjVmOWRkZWE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-11T01:25:11Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-11T01:30:08Z"}, "message": "Move the glue code to a .o file. This reduces how much asm we print\nin each \"translation unit\".\n\nPart of it is not repetitive and should probably be moved to a .ll file, but\nfor now we autogen all of it.\n\n(Modified somewhat by graydon while integrating).", "tree": {"sha": "d451418a7792e1f170a6b5e2b5713627b6aa04b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d451418a7792e1f170a6b5e2b5713627b6aa04b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3aac5059ee986126851cb4f8bd312f1fb5f9ddea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3aac5059ee986126851cb4f8bd312f1fb5f9ddea", "html_url": "https://github.com/rust-lang/rust/commit/3aac5059ee986126851cb4f8bd312f1fb5f9ddea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3aac5059ee986126851cb4f8bd312f1fb5f9ddea/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7454b534112e8cb7b0192d28c8b8685db31ed283", "url": "https://api.github.com/repos/rust-lang/rust/commits/7454b534112e8cb7b0192d28c8b8685db31ed283", "html_url": "https://github.com/rust-lang/rust/commit/7454b534112e8cb7b0192d28c8b8685db31ed283"}], "stats": {"total": 195, "additions": 123, "deletions": 72}, "files": [{"sha": "5d3057b5ebcf2cadfe3606a58fd453d907c88373", "filename": "src/Makefile", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3aac5059ee986126851cb4f8bd312f1fb5f9ddea/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/3aac5059ee986126851cb4f8bd312f1fb5f9ddea/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=3aac5059ee986126851cb4f8bd312f1fb5f9ddea", "patch": "@@ -86,7 +86,6 @@ ifdef CFG_WINDOWSY\n   endif\n   CFG_RUNTIME := rustrt.dll\n   CFG_STDLIB := std.dll\n-  CFG_OBJ_SUFFIX := .o\n   CFG_EXE_SUFFIX := .exe\n   CFG_BOOT := ./rustboot.exe\n   CFG_RUSTC := ./rustc.exe\n@@ -101,7 +100,6 @@ ifdef CFG_UNIXY\n   CFG_INFO := $(info cfg: unix-y environment)\n   CFG_BOOT := ./rustboot\n   CFG_RUSTC := ./rustc\n-  CFG_OBJ_SUFFIX := .o\n   CFG_RUN_TARG = LD_LIBRARY_PATH=. $(CFG_VALGRIND) $(1)\n   CFG_GCC := 1\n   ifdef MINGW_CROSS\n@@ -114,7 +112,6 @@ ifdef CFG_UNIXY\n     ifdef CFG_VALGRIND\n       CFG_VALGRIND += wine\n     endif\n-    CFG_OBJ_SUFFIX := .o\n     CFG_EXE_SUFFIX := .exe\n     CFG_GCC_CFLAGS := -march=i686\n     CFG_GCC_LINK_FLAGS := -shared\n@@ -302,15 +299,15 @@ RUNTIME_HDR := rt/globals.h \\\n                rt/test/rust_test_util.h\n \n RUNTIME_INCS := -Irt/isaac -Irt/uthash\n-RUNTIME_OBJS := $(RUNTIME_CS:.cpp=$(CFG_OBJ_SUFFIX))\n+RUNTIME_OBJS := $(RUNTIME_CS:.cpp=.o)\n RUNTIME_LIBS := $(CFG_RUNTIME_LIBS)\n \n STDLIB_CRATE := lib/std.rc\n STDLIB_INPUTS := $(wildcard lib/*.rc lib/*.rs lib/*/*.rs)\n COMPILER_CRATE := comp/rustc.rc\n-COMPILER_INPUTS := $(wildcard comp/*.rc comp/*.rs comp/*/*.rs)\n+COMPILER_INPUTS := $(wildcard comp/rustc.rc comp/*.rs comp/*/*.rs)\n \n-GENERATED := boot/fe/lexer.ml boot/util/version.ml\n+GENERATED := boot/fe/lexer.ml boot/util/version.ml glue.o\n \n all: $(CFG_RUSTC) $(MKFILES) $(GENERATED)\n \n@@ -329,7 +326,7 @@ $(CFG_STDLIB): $(STDLIB_CRATE) $(CFG_BOOT) $(MKFILES)\n \t@$(call CFG_ECHO, compile: $<)\n \t$(BOOT) -shared -o $@ $(STDLIB_CRATE)\n \n-%$(CFG_OBJ_SUFFIX): %.cpp $(MKFILES)\n+%.o: %.cpp $(MKFILES)\n \t@$(call CFG_ECHO, compile: $<)\n \t$(CFG_QUIET)$(call CFG_COMPILE_C, $@, $(RUNTIME_INCS)) $<\n \n@@ -368,8 +365,12 @@ $(CFG_RUSTC): $(COMPILER_INPUTS) $(CFG_BOOT) $(CFG_RUNTIME) $(CFG_STDLIB)\n \t$(BOOT) -minimal -o $@ $<\n \t$(CFG_QUIET)chmod 0755 $@\n \n+glue.bc: $(CFG_RUSTC)\n+\t@$(call CFG_ECHO, generate: $@)\n+\t$(RUSTC) -o $@ -glue\n+\n self: $(CFG_RUSTC)\n-\t@$(call CFG_ECHO, compile: $<)\n+\t@$(call CFG_ECHO, compile: $(COMPILER_CRATE))\n \t$(RUSTC) $(COMPILER_CRATE)\n \n \n@@ -758,9 +759,9 @@ test/bench/shootout/%.boot$(CFG_EXE_SUFFIX): \\\n \t@$(call CFG_ECHO, assemble [llvm]: $<)\n \t$(CFG_QUIET)gcc $(CFG_GCC_CFLAGS) -o $@ -c $<\n \n-%.rustc$(CFG_EXE_SUFFIX): %.o $(CFG_RUNTIME)\n+%.rustc$(CFG_EXE_SUFFIX): %.o $(CFG_RUNTIME) glue.o\n \t@$(call CFG_ECHO, link [llvm]: $<)\n-\t$(CFG_QUIET)gcc $(CFG_GCC_CFLAGS) -o $@ $< -L. -lrustrt\n+\t$(CFG_QUIET)gcc $(CFG_GCC_CFLAGS) glue.o -o $@ $< -L. -lrustrt\n \t@# dsymutil sometimes fails or prints a warning, but the\n \t@# program still runs.  Since it simplifies debugging other\n \t@# programs, I\\'ll live with the noise.\n@@ -797,7 +798,7 @@ C_DEPFILES := $(RUNTIME_CS:%.cpp=%.d)\n %.d: %.cpp $(MKFILES)\n \t@$(call CFG_ECHO, dep: $<)\n \t$(CFG_QUIET)$(call CFG_DEPEND_C, $@ \\\n-      $(patsubst %.cpp, %$(CFG_OBJ_SUFFIX), $<), \\\n+      $(patsubst %.cpp, %.o, $<), \\\n       $(RUNTIME_INCS)) $< $(CFG_PATH_MUNGE) >$@.tmp \\\n       && mv $@.tmp $@\n \n@@ -914,12 +915,12 @@ clean:\n \t$(CFG_QUIET)rm -f $(ML_DEPFILES:%.d=%.d.tmp)\n \t$(CFG_QUIET)rm -f $(C_DEPFILES:%.d=%.d.tmp)\n \t$(CFG_QUIET)rm -f $(CRATE_DEPFILES:%.d=%.d.tmp)\n-\t$(CFG_QUIET)rm -f $(GENERATED)\n+\t$(CFG_QUIET)rm -f $(GENERATED) glue.bc glue.s\n \t$(CFG_QUIET)rm -f $(CFG_BOOT) $(CFG_RUNTIME) $(CFG_STDLIB)\n \t$(CFG_QUIET)rm -Rf $(PKG_NAME)-*.tar.gz dist\n-\t$(CFG_QUIET)rm -f $(foreach ext,cmx cmi cmo cma o a d exe,\\\n+\t$(CFG_QUIET)rm -f $(foreach ext,cmx cmi cmo cma bc o a d exe,\\\n                         $(wildcard boot/*/*.$(ext) boot/*/*/*.$(ext)))\n-\t$(CFG_QUIET)rm -Rf $(foreach ext,out llvm x86 boot rustc o s exe dSYM,\\\n+\t$(CFG_QUIET)rm -Rf $(foreach ext,out llvm x86 boot rustc bc o s exe dSYM,\\\n                         $(wildcard test/*/*.$(ext)))\n \n "}, {"sha": "00d41fff42d8ef95548198baf382e063e77efe8e", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3aac5059ee986126851cb4f8bd312f1fb5f9ddea/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aac5059ee986126851cb4f8bd312f1fb5f9ddea/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=3aac5059ee986126851cb4f8bd312f1fb5f9ddea", "patch": "@@ -84,6 +84,7 @@ fn usage(session.session sess, str argv0) {\n     log \"\";\n     log \"    -o <filename>      write output to <filename>\";\n     log \"    -nowarn            suppress wrong-compiler warning\";\n+    log \"    -glue              generate glue.bc file\";\n     log \"    -shared            compile a shared-library crate\";\n     log \"    -pp                pretty-print the input instead of compiling\";\n     log \"    -h                 display this message\";\n@@ -113,6 +114,7 @@ impure fn main(vec[str] args) {\n     let bool do_warn = true;\n     let bool shared = false;\n     let bool pretty = false;\n+    let bool glue = false;\n \n     auto i = 1u;\n     auto len = _vec.len[str](args);\n@@ -123,6 +125,8 @@ impure fn main(vec[str] args) {\n         if (_str.byte_len(arg) > 0u && arg.(0) == '-' as u8) {\n             if (_str.eq(arg, \"-nowarn\")) {\n                 do_warn = false;\n+            } else if (_str.eq(arg, \"-glue\")) {\n+                glue = true;\n             } else if (_str.eq(arg, \"-shared\")) {\n                 shared = true;\n             } else if (_str.eq(arg, \"-pp\")) {\n@@ -159,6 +163,18 @@ impure fn main(vec[str] args) {\n         warn_wrong_compiler();\n     }\n \n+    if (glue) {\n+        alt (output_file) {\n+            case (none[str]) {\n+                middle.trans.make_common_glue(\"glue.bc\");\n+            }\n+            case (some[str](?s)) {\n+                middle.trans.make_common_glue(s);\n+            }\n+        }\n+        ret;\n+    }\n+\n     alt (input_file) {\n         case (none[str]) {\n             usage(sess, args.(0));"}, {"sha": "936a12f30dce9036799f1e86bb8d1e79ce20c411", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 92, "deletions": 58, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/3aac5059ee986126851cb4f8bd312f1fb5f9ddea/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aac5059ee986126851cb4f8bd312f1fb5f9ddea/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=3aac5059ee986126851cb4f8bd312f1fb5f9ddea", "patch": "@@ -839,32 +839,44 @@ fn decl_upcall_glue(ModuleRef llmod, type_names tn, uint _n) -> ValueRef {\n     ret decl_fastcall_fn(llmod, s, T_fn(args, T_int()));\n }\n \n-fn get_upcall(@crate_ctxt cx, str name, int n_args) -> ValueRef {\n-    if (cx.upcalls.contains_key(name)) {\n-        ret cx.upcalls.get(name);\n+fn get_upcall(&hashmap[str, ValueRef] upcalls,\n+              type_names tn, ModuleRef llmod,\n+              str name, int n_args) -> ValueRef {\n+    if (upcalls.contains_key(name)) {\n+        ret upcalls.get(name);\n     }\n-    auto inputs = vec(T_taskptr(cx.tn));\n+    auto inputs = vec(T_taskptr(tn));\n     inputs += _vec.init_elt[TypeRef](T_int(), n_args as uint);\n     auto output = T_int();\n-    auto f = decl_cdecl_fn(cx.llmod, name, T_fn(inputs, output));\n-    cx.upcalls.insert(name, f);\n+    auto f = decl_cdecl_fn(llmod, name, T_fn(inputs, output));\n+    upcalls.insert(name, f);\n     ret f;\n }\n \n fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> result {\n+    auto cxx = cx.fcx.ccx;\n+    auto t = trans_upcall2(cx.build, cxx.glues, cx.fcx.lltaskptr,\n+                           cxx.upcalls, cxx.tn, cxx.llmod, name, args);\n+    ret res(cx, t);\n+}\n+\n+fn trans_upcall2(builder b, @glue_fns glues, ValueRef lltaskptr,\n+                 &hashmap[str, ValueRef] upcalls,\n+                 type_names tn, ModuleRef llmod, str name,\n+                 vec[ValueRef] args) -> ValueRef {\n     let int n = _vec.len[ValueRef](args) as int;\n-    let ValueRef llupcall = get_upcall(cx.fcx.ccx, name, n);\n+    let ValueRef llupcall = get_upcall(upcalls, tn, llmod, name, n);\n     llupcall = llvm.LLVMConstPointerCast(llupcall, T_int());\n \n-    let ValueRef llglue = cx.fcx.ccx.glues.upcall_glues.(n);\n+    let ValueRef llglue = glues.upcall_glues.(n);\n     let vec[ValueRef] call_args = vec(llupcall);\n-    call_args += cx.build.PtrToInt(cx.fcx.lltaskptr, T_int());\n+    call_args += b.PtrToInt(lltaskptr, T_int());\n \n     for (ValueRef a in args) {\n-        call_args += cx.build.ZExtOrBitCast(a, T_int());\n+        call_args += b.ZExtOrBitCast(a, T_int());\n     }\n \n-    ret res(cx, cx.build.FastCall(llglue, call_args));\n+    ret b.FastCall(llglue, call_args);\n }\n \n fn trans_non_gc_free(@block_ctxt cx, ValueRef v) -> result {\n@@ -5537,28 +5549,21 @@ fn i2p(ValueRef v, TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstIntToPtr(v, t);\n }\n \n-fn trans_exit_task_glue(@crate_ctxt cx) {\n+fn trans_exit_task_glue(@glue_fns glues,\n+                        &hashmap[str, ValueRef] upcalls,\n+                        type_names tn, ModuleRef llmod) {\n     let vec[TypeRef] T_args = vec();\n     let vec[ValueRef] V_args = vec();\n \n-    auto llfn = cx.glues.exit_task_glue;\n+    auto llfn = glues.exit_task_glue;\n     let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 3u);\n-    auto fcx = @rec(llfn=llfn,\n-                    lltaskptr=lltaskptr,\n-                    llenv=C_null(T_opaque_closure_ptr(cx.tn)),\n-                    llretptr=C_null(T_ptr(T_nil())),\n-                    mutable llself=none[ValueRef],\n-                    mutable lliterbody=none[ValueRef],\n-                    llargs=new_def_hash[ValueRef](),\n-                    llobjfields=new_def_hash[ValueRef](),\n-                    lllocals=new_def_hash[ValueRef](),\n-                    llupvars=new_def_hash[ValueRef](),\n-                    lltydescs=new_def_hash[ValueRef](),\n-                    ccx=cx);\n \n-    auto bcx = new_top_block_ctxt(fcx);\n-    trans_upcall(bcx, \"upcall_exit\", V_args);\n-    bcx.build.RetVoid();\n+    auto entrybb = llvm.LLVMAppendBasicBlock(llfn, _str.buf(\"entry\"));\n+    auto build = new_builder(entrybb);\n+\n+    trans_upcall2(build, glues, lltaskptr,\n+                  upcalls, tn, llmod, \"upcall_exit\", V_args);\n+    build.RetVoid();\n }\n \n fn create_typedefs(@crate_ctxt cx) {\n@@ -5567,22 +5572,22 @@ fn create_typedefs(@crate_ctxt cx) {\n     llvm.LLVMAddTypeName(cx.llmod, _str.buf(\"tydesc\"), T_tydesc(cx.tn));\n }\n \n-fn create_crate_constant(@crate_ctxt cx) {\n+fn create_crate_constant(ValueRef crate_ptr, @glue_fns glues) {\n \n-    let ValueRef crate_addr = p2i(cx.crate_ptr);\n+    let ValueRef crate_addr = p2i(crate_ptr);\n \n     let ValueRef activate_glue_off =\n-        llvm.LLVMConstSub(p2i(cx.glues.activate_glue), crate_addr);\n+        llvm.LLVMConstSub(p2i(glues.activate_glue), crate_addr);\n \n     let ValueRef yield_glue_off =\n-        llvm.LLVMConstSub(p2i(cx.glues.yield_glue), crate_addr);\n+        llvm.LLVMConstSub(p2i(glues.yield_glue), crate_addr);\n \n     let ValueRef exit_task_glue_off =\n-        llvm.LLVMConstSub(p2i(cx.glues.exit_task_glue), crate_addr);\n+        llvm.LLVMConstSub(p2i(glues.exit_task_glue), crate_addr);\n \n     let ValueRef crate_val =\n         C_struct(vec(C_null(T_int()),     // ptrdiff_t image_base_off\n-                     p2i(cx.crate_ptr),   // uintptr_t self_addr\n+                     p2i(crate_ptr),   // uintptr_t self_addr\n                      C_null(T_int()),     // ptrdiff_t debug_abbrev_off\n                      C_null(T_int()),     // size_t debug_abbrev_sz\n                      C_null(T_int()),     // ptrdiff_t debug_info_off\n@@ -5598,7 +5603,7 @@ fn create_crate_constant(@crate_ctxt cx) {\n                      C_int(abi.abi_x86_rustc_fastcall) // uintptr_t abi_tag\n                      ));\n \n-    llvm.LLVMSetInitializer(cx.crate_ptr, crate_val);\n+    llvm.LLVMSetInitializer(crate_ptr, crate_val);\n }\n \n fn find_main_fn(@crate_ctxt cx) -> ValueRef {\n@@ -5700,26 +5705,28 @@ fn check_module(ModuleRef llmod) {\n     // TODO: run the linter here also, once there are llvm-c bindings for it.\n }\n \n-fn make_no_op_type_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n+fn decl_no_op_type_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n     auto ty = T_fn(vec(T_taskptr(tn), T_ptr(T_i8())), T_void());\n-    auto fun = decl_fastcall_fn(llmod, abi.no_op_type_glue_name(), ty);\n+    ret decl_fastcall_fn(llmod, abi.no_op_type_glue_name(), ty);\n+}\n+\n+fn make_no_op_type_glue(ValueRef fun) {\n     auto bb_name = _str.buf(\"_rust_no_op_type_glue_bb\");\n     auto llbb = llvm.LLVMAppendBasicBlock(fun, bb_name);\n     new_builder(llbb).RetVoid();\n-    ret fun;\n }\n \n-fn make_memcpy_glue(ModuleRef llmod) -> ValueRef {\n-\n-    // We're not using the LLVM memcpy intrinsic. It appears to call through\n-    // to the platform memcpy in some cases, which is not terribly safe to run\n-    // on a rust stack.\n-\n+fn decl_memcpy_glue(ModuleRef llmod) -> ValueRef {\n     auto p8 = T_ptr(T_i8());\n \n     auto ty = T_fn(vec(p8, p8, T_int()), T_void());\n-    auto fun = decl_fastcall_fn(llmod, abi.memcpy_glue_name(), ty);\n+    ret decl_fastcall_fn(llmod, abi.memcpy_glue_name(), ty);\n+}\n \n+fn make_memcpy_glue(ValueRef fun) {\n+    // We're not using the LLVM memcpy intrinsic. It appears to call through\n+    // to the platform memcpy in some cases, which is not terribly safe to run\n+    // on a rust stack.\n     auto initbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"init\"));\n     auto hdrbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"hdr\"));\n     auto loopbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"loop\"));\n@@ -5751,18 +5758,18 @@ fn make_memcpy_glue(ModuleRef llmod) -> ValueRef {\n     // End block\n     auto eb = new_builder(endbb);\n     eb.RetVoid();\n-    ret fun;\n }\n \n-fn make_bzero_glue(ModuleRef llmod) -> ValueRef {\n-\n-    // We're not using the LLVM memset intrinsic. Same as with memcpy.\n-\n+fn decl_bzero_glue(ModuleRef llmod) -> ValueRef {\n     auto p8 = T_ptr(T_i8());\n \n     auto ty = T_fn(vec(p8, T_int()), T_void());\n-    auto fun = decl_fastcall_fn(llmod, abi.bzero_glue_name(), ty);\n+    ret decl_fastcall_fn(llmod, abi.bzero_glue_name(), ty);\n+}\n \n+fn make_bzero_glue(ModuleRef llmod) -> ValueRef {\n+    // We're not using the LLVM memset intrinsic. Same as with memcpy.\n+    auto fun = decl_bzero_glue(llmod);\n     auto initbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"init\"));\n     auto hdrbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"hdr\"));\n     auto loopbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"loop\"));\n@@ -6008,14 +6015,16 @@ fn make_glues(ModuleRef llmod, type_names tn) -> @glue_fns {\n              upcall_glues =\n              _vec.init_fn[ValueRef](bind decl_upcall_glue(llmod, tn, _),\n                                     abi.n_upcall_glues as uint),\n-             no_op_type_glue = make_no_op_type_glue(llmod, tn),\n-             memcpy_glue = make_memcpy_glue(llmod),\n-             bzero_glue = make_bzero_glue(llmod),\n+             no_op_type_glue = decl_no_op_type_glue(llmod, tn),\n+             memcpy_glue = decl_memcpy_glue(llmod),\n+             bzero_glue = decl_bzero_glue(llmod),\n              vec_append_glue = make_vec_append_glue(llmod, tn));\n }\n \n-fn trans_crate(session.session sess, @ast.crate crate, str output,\n-               bool shared) {\n+fn make_common_glue(str output) {\n+    // FIXME: part of this is repetitive and is probably a good idea\n+    // to autogen it, but things like the memcpy implementation are not\n+    // and it might be better to just check in a .ll file.\n     auto llmod =\n         llvm.LLVMModuleCreateWithNameInContext(_str.buf(\"rust_out\"),\n                                                llvm.LLVMGetGlobalContext());\n@@ -6027,8 +6036,35 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n     let ValueRef crate_ptr =\n         llvm.LLVMAddGlobal(llmod, T_crate(tn), _str.buf(\"rust_crate\"));\n \n+    auto intrinsics = declare_intrinsics(llmod);\n+\n     llvm.LLVMSetModuleInlineAsm(llmod, _str.buf(x86.get_module_asm()));\n \n+    auto glues = make_glues(llmod, tn);\n+    create_crate_constant(crate_ptr, glues);\n+    make_memcpy_glue(glues.memcpy_glue);\n+\n+    trans_exit_task_glue(glues, new_str_hash[ValueRef](), tn, llmod);\n+\n+    check_module(llmod);\n+\n+    llvm.LLVMWriteBitcodeToFile(llmod, _str.buf(output));\n+    llvm.LLVMDisposeModule(llmod);\n+}\n+\n+fn trans_crate(session.session sess, @ast.crate crate, str output,\n+               bool shared) {\n+    auto llmod =\n+        llvm.LLVMModuleCreateWithNameInContext(_str.buf(\"rust_out\"),\n+                                               llvm.LLVMGetGlobalContext());\n+\n+    llvm.LLVMSetDataLayout(llmod, _str.buf(x86.get_data_layout()));\n+    llvm.LLVMSetTarget(llmod, _str.buf(x86.get_target_triple()));\n+    auto td = mk_target_data(x86.get_data_layout());\n+    auto tn = mk_type_names();\n+    let ValueRef crate_ptr =\n+        llvm.LLVMAddGlobal(llmod, T_crate(tn), _str.buf(\"rust_crate\"));\n+\n     auto intrinsics = declare_intrinsics(llmod);\n \n     auto glues = make_glues(llmod, tn);\n@@ -6069,9 +6105,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n     trans_constants(cx, crate);\n \n     trans_mod(cx, crate.node.module);\n-    trans_exit_task_glue(cx);\n     trans_vec_append_glue(cx);\n-    create_crate_constant(cx);\n     if (!shared) {\n         trans_main_fn(cx, cx.crate_ptr);\n     }"}]}