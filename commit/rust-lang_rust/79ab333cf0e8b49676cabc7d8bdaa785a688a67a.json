{"sha": "79ab333cf0e8b49676cabc7d8bdaa785a688a67a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5YWIzMzNjZjBlOGI0OTY3NmNhYmM3ZDhiZGFhNzg1YTY4OGE2N2E=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-12T02:57:48Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-17T16:36:00Z"}, "message": "Move `run_renderer` into the main `global_ctxt` closure", "tree": {"sha": "4eb03a29115212cc7ed800e57b27c6f5b8cef8fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eb03a29115212cc7ed800e57b27c6f5b8cef8fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79ab333cf0e8b49676cabc7d8bdaa785a688a67a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79ab333cf0e8b49676cabc7d8bdaa785a688a67a", "html_url": "https://github.com/rust-lang/rust/commit/79ab333cf0e8b49676cabc7d8bdaa785a688a67a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79ab333cf0e8b49676cabc7d8bdaa785a688a67a/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34e8b0aae1fe66e0e0c0f70957cc647361a79ff5", "url": "https://api.github.com/repos/rust-lang/rust/commits/34e8b0aae1fe66e0e0c0f70957cc647361a79ff5", "html_url": "https://github.com/rust-lang/rust/commit/34e8b0aae1fe66e0e0c0f70957cc647361a79ff5"}], "stats": {"total": 152, "additions": 81, "deletions": 71}, "files": [{"sha": "3b789dfd66f4c8e4c4af65a6c1b1605bbd43e684", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 46, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/79ab333cf0e8b49676cabc7d8bdaa785a688a67a/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79ab333cf0e8b49676cabc7d8bdaa785a688a67a/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=79ab333cf0e8b49676cabc7d8bdaa785a688a67a", "patch": "@@ -274,7 +274,7 @@ where\n }\n \n /// Parse, resolve, and typecheck the given crate.\n-fn create_config(\n+crate fn create_config(\n     RustdocOptions {\n         input,\n         crate_name,\n@@ -406,50 +406,7 @@ fn create_config(\n     }\n }\n \n-crate fn run_core(\n-    options: RustdocOptions,\n-) -> (clean::Crate, RenderInfo, RenderOptions, Lrc<Session>) {\n-    let default_passes = options.default_passes;\n-    let output_format = options.output_format;\n-    // TODO: fix this clone (especially render_options)\n-    let externs = options.externs.clone();\n-    let manual_passes = options.manual_passes.clone();\n-    let render_options = options.render_options.clone();\n-    let config = create_config(options);\n-\n-    interface::create_compiler_and_run(config, |compiler| {\n-        compiler.enter(|queries| {\n-            let sess = compiler.session();\n-\n-            // We need to hold on to the complete resolver, so we cause everything to be\n-            // cloned for the analysis passes to use. Suboptimal, but necessary in the\n-            // current architecture.\n-            let resolver = create_resolver(externs, queries, &sess);\n-\n-            if sess.has_errors() {\n-                sess.fatal(\"Compilation failed, aborting rustdoc\");\n-            }\n-\n-            let mut global_ctxt = abort_on_err(queries.global_ctxt(), sess).take();\n-\n-            let (krate, render_info, opts) = sess.time(\"run_global_ctxt\", || {\n-                global_ctxt.enter(|tcx| {\n-                    run_global_ctxt(\n-                        tcx,\n-                        resolver,\n-                        default_passes,\n-                        manual_passes,\n-                        render_options,\n-                        output_format,\n-                    )\n-                })\n-            });\n-            (krate, render_info, opts, Lrc::clone(sess))\n-        })\n-    })\n-}\n-\n-fn create_resolver<'a>(\n+crate fn create_resolver<'a>(\n     externs: config::Externs,\n     queries: &Queries<'a>,\n     sess: &Session,\n@@ -489,7 +446,7 @@ fn create_resolver<'a>(\n     resolver.clone()\n }\n \n-fn run_global_ctxt(\n+crate fn run_global_ctxt(\n     tcx: TyCtxt<'_>,\n     resolver: Rc<RefCell<interface::BoxedResolver>>,\n     mut default_passes: passes::DefaultPassOption,"}, {"sha": "93c849859aba52a7913480ab1cc2d31e343df775", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 78, "deletions": 25, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/79ab333cf0e8b49676cabc7d8bdaa785a688a67a/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79ab333cf0e8b49676cabc7d8bdaa785a688a67a/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=79ab333cf0e8b49676cabc7d8bdaa785a688a67a", "patch": "@@ -63,7 +63,9 @@ use std::env;\n use std::process;\n \n use rustc_data_structures::sync::Lrc;\n+use rustc_driver::abort_on_err;\n use rustc_errors::ErrorReported;\n+use rustc_interface::interface;\n use rustc_session::config::{make_crate_type_option, ErrorOutputType, RustcOptGroup};\n use rustc_session::getopts;\n use rustc_session::Session;\n@@ -520,34 +522,85 @@ fn main_options(options: config::Options) -> MainResult {\n     // then generated from the cleaned AST of the crate. This runs all the\n     // plug/cleaning passes.\n     let crate_version = options.crate_version.clone();\n+\n+    let default_passes = options.default_passes;\n     let output_format = options.output_format;\n-    let (mut krate, renderinfo, renderopts, sess) = core::run_core(options);\n+    // TODO: fix this clone (especially render_options)\n+    let externs = options.externs.clone();\n+    let manual_passes = options.manual_passes.clone();\n+    let render_options = options.render_options.clone();\n+    let config = core::create_config(options);\n \n-    info!(\"finished with rustc\");\n+    interface::create_compiler_and_run(config, |compiler| {\n+        compiler.enter(|queries| {\n+            let sess = compiler.session();\n \n-    krate.version = crate_version;\n+            // We need to hold on to the complete resolver, so we cause everything to be\n+            // cloned for the analysis passes to use. Suboptimal, but necessary in the\n+            // current architecture.\n+            let resolver = core::create_resolver(externs, queries, &sess);\n \n-    if show_coverage {\n-        // if we ran coverage, bail early, we don't need to also generate docs at this point\n-        // (also we didn't load in any of the useful passes)\n-        return Ok(());\n-    } else if run_check {\n-        // Since we're in \"check\" mode, no need to generate anything beyond this point.\n-        return Ok(());\n-    }\n+            if sess.has_errors() {\n+                sess.fatal(\"Compilation failed, aborting rustdoc\");\n+            }\n \n-    info!(\"going to format\");\n-    let (error_format, edition, debugging_options) = diag_opts;\n-    let diag = core::new_handler(error_format, None, &debugging_options);\n-    let sess_time = sess.clone();\n-    match output_format {\n-        None | Some(config::OutputFormat::Html) => sess_time.time(\"render_html\", || {\n-            run_renderer::<html::render::Context>(\n-                krate, renderopts, renderinfo, &diag, edition, sess,\n-            )\n-        }),\n-        Some(config::OutputFormat::Json) => sess_time.time(\"render_json\", || {\n-            run_renderer::<json::JsonRenderer>(krate, renderopts, renderinfo, &diag, edition, sess)\n-        }),\n-    }\n+            let mut global_ctxt = abort_on_err(queries.global_ctxt(), sess).take();\n+\n+            global_ctxt.enter(|tcx| {\n+                let (mut krate, render_info, render_opts) = sess.time(\"run_global_ctxt\", || {\n+                    core::run_global_ctxt(\n+                        tcx,\n+                        resolver,\n+                        default_passes,\n+                        manual_passes,\n+                        render_options,\n+                        output_format,\n+                    )\n+                });\n+                info!(\"finished with rustc\");\n+\n+                if let Some(name) = crate_name {\n+                    krate.name = name\n+                }\n+\n+                krate.version = crate_version;\n+\n+                if show_coverage {\n+                    // if we ran coverage, bail early, we don't need to also generate docs at this point\n+                    // (also we didn't load in any of the useful passes)\n+                    return Ok(());\n+                } else if run_check {\n+                    // Since we're in \"check\" mode, no need to generate anything beyond this point.\n+                    return Ok(());\n+                }\n+\n+                info!(\"going to format\");\n+                let (error_format, edition, debugging_options) = diag_opts;\n+                let diag = core::new_handler(error_format, None, &debugging_options);\n+                let sess_format = sess.clone();\n+                match output_format {\n+                    None | Some(config::OutputFormat::Html) => sess.time(\"render_html\", || {\n+                        run_renderer::<html::render::Context>(\n+                            krate,\n+                            render_opts,\n+                            render_info,\n+                            &diag,\n+                            edition,\n+                            sess_format,\n+                        )\n+                    }),\n+                    Some(config::OutputFormat::Json) => sess.time(\"render_json\", || {\n+                        run_renderer::<json::JsonRenderer>(\n+                            krate,\n+                            render_opts,\n+                            render_info,\n+                            &diag,\n+                            edition,\n+                            sess_format,\n+                        )\n+                    }),\n+                }\n+            })\n+        })\n+    })\n }"}]}