{"sha": "854d95f9ffe83c8f77782b5dc76d18799579ba95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1NGQ5NWY5ZmZlODNjOGY3Nzc4MmI1ZGM3NmQxODc5OTU3OWJhOTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-10T20:53:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-16T06:22:06Z"}, "message": "syntax: Add a macro, format_args_method!()\n\nCurrently, the format_args!() macro takes as its first argument an expression\nwhich is the callee of an ExprCall. This means that if format_args!() is used\nwith calling a method a closure must be used. Consider this code, however:\n\n    format_args!(|args| { foo.writer.write_fmt(args) }, \"{}\", foo.field)\n\nThe closure borrows the entire `foo` structure, disallowing the later borrow of\n`foo.field`. To preserve the semantics of the `write!` macro, it is also\nimpossible to borrow specifically the `writer` field of the `foo` structure\nbecause it must be borrowed mutably, but the `foo` structure is not guaranteed\nto be mutable itself.\n\nThis new macro is invoked like:\n\n    format_args_method!(foo.writer, write_fmt, \"{}\", foo.field)\n\nThis macro will generate an ExprMethodCall which allows the borrow checker to\nunderstand that `writer` and `field` should be borrowed separately.\n\nThis macro is not strictly necessary, with DST or possibly UFCS other\nworkarounds could be used. For now, though, it looks like this is required to\nimplement the `write!` macro.", "tree": {"sha": "9b4f11bf0ad81ae05e004ccc4fca3c9e30f2d548", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b4f11bf0ad81ae05e004ccc4fca3c9e30f2d548"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/854d95f9ffe83c8f77782b5dc76d18799579ba95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/854d95f9ffe83c8f77782b5dc76d18799579ba95", "html_url": "https://github.com/rust-lang/rust/commit/854d95f9ffe83c8f77782b5dc76d18799579ba95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/854d95f9ffe83c8f77782b5dc76d18799579ba95/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00f9263914da3d18c556d7ebc3941f9638721ac2", "url": "https://api.github.com/repos/rust-lang/rust/commits/00f9263914da3d18c556d7ebc3941f9638721ac2", "html_url": "https://github.com/rust-lang/rust/commit/00f9263914da3d18c556d7ebc3941f9638721ac2"}], "stats": {"total": 91, "additions": 62, "deletions": 29}, "files": [{"sha": "06b56bbe472a250e804a429ff29596d4371884d9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/854d95f9ffe83c8f77782b5dc76d18799579ba95/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/854d95f9ffe83c8f77782b5dc76d18799579ba95/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=854d95f9ffe83c8f77782b5dc76d18799579ba95", "patch": "@@ -281,7 +281,10 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                                 ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(intern(\"format_args\"),\n                             builtin_normal_expander(\n-                                ext::format::expand_args));\n+                                ext::format::expand_format_args));\n+    syntax_expanders.insert(intern(\"format_args_method\"),\n+                            builtin_normal_expander(\n+                                ext::format::expand_format_args_method));\n     syntax_expanders.insert(intern(\"env\"),\n                             builtin_normal_expander(\n                                     ext::env::expand_env));"}, {"sha": "343100d3a8ef6194b0100edca159c0fdb2628dd6", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/854d95f9ffe83c8f77782b5dc76d18799579ba95/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/854d95f9ffe83c8f77782b5dc76d18799579ba95/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=854d95f9ffe83c8f77782b5dc76d18799579ba95", "patch": "@@ -120,23 +120,18 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     // AST construction!\n     // we're basically calling\n     //\n-    // format_arg!(|__args| ::std::fmt::write(fmt.buf, __args), \"<format_string>\", exprs...)\n+    // format_arg_method!(fmt, write_fmt, \"<format_string>\", exprs...)\n     //\n     // but doing it directly via ext::format.\n     let formatter = substr.nonself_args[0];\n-    let buf = cx.expr_field_access(span, formatter, cx.ident_of(\"buf\"));\n-\n-    let std_write = vec!(cx.ident_of(\"std\"), cx.ident_of(\"fmt\"), cx.ident_of(\"write\"));\n-    let args = cx.ident_of(\"__args\");\n-    let write_call = cx.expr_call_global(span, std_write, vec!(buf, cx.expr_ident(span, args)));\n-    let format_closure = cx.lambda_expr(span, vec!(args), write_call);\n \n+    let meth = cx.ident_of(\"write_fmt\");\n     let s = token::intern_and_get_ident(format_string.as_slice());\n     let format_string = cx.expr_str(span, s);\n \n     // phew, not our responsibility any more!\n     format::expand_preparsed_format_args(cx, span,\n-                                         format_closure,\n+                                         format::MethodCall(formatter, meth),\n                                          format_string, exprs, Vec::new(),\n                                          HashMap::new())\n }"}, {"sha": "e92ce139d007036fa8d533c6727b6976709ee256", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/854d95f9ffe83c8f77782b5dc76d18799579ba95/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/854d95f9ffe83c8f77782b5dc76d18799579ba95/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=854d95f9ffe83c8f77782b5dc76d18799579ba95", "patch": "@@ -59,6 +59,11 @@ struct Context<'a, 'b> {\n     next_arg: uint,\n }\n \n+pub enum Invocation {\n+    Call(@ast::Expr),\n+    MethodCall(@ast::Expr, ast::Ident),\n+}\n+\n /// Parses the arguments from the given list of tokens, returning None\n /// if there's a parse error so we can continue parsing other format!\n /// expressions.\n@@ -67,8 +72,9 @@ struct Context<'a, 'b> {\n ///\n ///     Some((fmtstr, unnamed arguments, ordering of named arguments,\n ///           named arguments))\n-fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> (@ast::Expr, Option<(@ast::Expr, Vec<@ast::Expr>, Vec<StrBuf>,\n+fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n+              tts: &[ast::TokenTree])\n+    -> (Invocation, Option<(@ast::Expr, Vec<@ast::Expr>, Vec<StrBuf>,\n                             HashMap<StrBuf, @ast::Expr>)>) {\n     let mut args = Vec::new();\n     let mut names = HashMap::<StrBuf, @ast::Expr>::new();\n@@ -80,22 +86,31 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                                                 .map(|x| (*x).clone())\n                                                 .collect());\n     // Parse the leading function expression (maybe a block, maybe a path)\n-    let extra = p.parse_expr();\n+    let invocation = if allow_method {\n+        let e = p.parse_expr();\n+        if !p.eat(&token::COMMA) {\n+            ecx.span_err(sp, \"expected token: `,`\");\n+            return (Call(e), None);\n+        }\n+        MethodCall(e, p.parse_ident())\n+    } else {\n+        Call(p.parse_expr())\n+    };\n     if !p.eat(&token::COMMA) {\n         ecx.span_err(sp, \"expected token: `,`\");\n-        return (extra, None);\n+        return (invocation, None);\n     }\n \n     if p.token == token::EOF {\n         ecx.span_err(sp, \"requires at least a format string argument\");\n-        return (extra, None);\n+        return (invocation, None);\n     }\n     let fmtstr = p.parse_expr();\n     let mut named = false;\n     while p.token != token::EOF {\n         if !p.eat(&token::COMMA) {\n             ecx.span_err(sp, \"expected token: `,`\");\n-            return (extra, None);\n+            return (invocation, None);\n         }\n         if p.token == token::EOF { break } // accept trailing commas\n         if named || (token::is_ident(&p.token) &&\n@@ -110,13 +125,13 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     ecx.span_err(p.span,\n                                  \"expected ident, positional arguments \\\n                                  cannot follow named arguments\");\n-                    return (extra, None);\n+                    return (invocation, None);\n                 }\n                 _ => {\n                     ecx.span_err(p.span,\n                                  format!(\"expected ident for named argument, but found `{}`\",\n                                          p.this_token_to_str()));\n-                    return (extra, None);\n+                    return (invocation, None);\n                 }\n             };\n             let interned_name = token::get_ident(ident);\n@@ -137,7 +152,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             args.push(p.parse_expr());\n         }\n     }\n-    return (extra, Some((fmtstr, args, order, names)));\n+    return (invocation, Some((fmtstr, args, order, names)));\n }\n \n impl<'a, 'b> Context<'a, 'b> {\n@@ -595,7 +610,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// Actually builds the expression which the iformat! block will be expanded\n     /// to\n-    fn to_expr(&self, extra: @ast::Expr) -> @ast::Expr {\n+    fn to_expr(&self, invocation: Invocation) -> @ast::Expr {\n         let mut lets = Vec::new();\n         let mut locals = Vec::new();\n         let mut names = Vec::from_fn(self.name_positions.len(), |_| None);\n@@ -699,8 +714,16 @@ impl<'a, 'b> Context<'a, 'b> {\n         let resname = self.ecx.ident_of(\"__args\");\n         lets.push(self.ecx.stmt_let(self.fmtsp, false, resname, result));\n         let res = self.ecx.expr_ident(self.fmtsp, resname);\n-        let result = self.ecx.expr_call(extra.span, extra, vec!(\n-                            self.ecx.expr_addr_of(extra.span, res)));\n+        let result = match invocation {\n+            Call(e) => {\n+                self.ecx.expr_call(e.span, e,\n+                                   vec!(self.ecx.expr_addr_of(e.span, res)))\n+            }\n+            MethodCall(e, m) => {\n+                self.ecx.expr_method_call(e.span, e, m,\n+                                          vec!(self.ecx.expr_addr_of(e.span, res)))\n+            }\n+        };\n         let body = self.ecx.expr_block(self.ecx.block(self.fmtsp, lets,\n                                                       Some(result)));\n \n@@ -794,13 +817,25 @@ impl<'a, 'b> Context<'a, 'b> {\n     }\n }\n \n-pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n-                   tts: &[ast::TokenTree]) -> Box<base::MacResult> {\n+pub fn expand_format_args(ecx: &mut ExtCtxt, sp: Span,\n+                          tts: &[ast::TokenTree]) -> Box<base::MacResult> {\n+\n+    match parse_args(ecx, sp, false, tts) {\n+        (invocation, Some((efmt, args, order, names))) => {\n+            MacExpr::new(expand_preparsed_format_args(ecx, sp, invocation, efmt,\n+                                                      args, order, names))\n+        }\n+        (_, None) => MacExpr::new(ecx.expr_uint(sp, 2))\n+    }\n+}\n+\n+pub fn expand_format_args_method(ecx: &mut ExtCtxt, sp: Span,\n+                                 tts: &[ast::TokenTree]) -> Box<base::MacResult> {\n \n-    match parse_args(ecx, sp, tts) {\n-        (extra, Some((efmt, args, order, names))) => {\n-            MacExpr::new(expand_preparsed_format_args(ecx, sp, extra, efmt, args,\n-                                                order, names))\n+    match parse_args(ecx, sp, true, tts) {\n+        (invocation, Some((efmt, args, order, names))) => {\n+            MacExpr::new(expand_preparsed_format_args(ecx, sp, invocation, efmt,\n+                                                      args, order, names))\n         }\n         (_, None) => MacExpr::new(ecx.expr_uint(sp, 2))\n     }\n@@ -810,7 +845,7 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n /// name=names...)` and construct the appropriate formatting\n /// expression.\n pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n-                                    extra: @ast::Expr,\n+                                    invocation: Invocation,\n                                     efmt: @ast::Expr, args: Vec<@ast::Expr>,\n                                     name_ordering: Vec<StrBuf>,\n                                     names: HashMap<StrBuf, @ast::Expr>) -> @ast::Expr {\n@@ -869,5 +904,5 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         }\n     }\n \n-    cx.to_expr(extra)\n+    cx.to_expr(invocation)\n }"}]}