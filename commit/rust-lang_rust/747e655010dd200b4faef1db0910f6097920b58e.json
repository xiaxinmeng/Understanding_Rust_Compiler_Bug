{"sha": "747e655010dd200b4faef1db0910f6097920b58e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0N2U2NTUwMTBkZDIwMGI0ZmFlZjFkYjA5MTBmNjA5NzkyMGI1OGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-01T16:16:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-01T16:16:30Z"}, "message": "Auto merge of #50340 - Emerentius:master, r=alexcrichton\n\noptimize joining for slices\n\nThis improves the speed of string joining up to 3x.\nIt removes the boolean flag check every iteration, eliminates repeated bounds checks and adds a fast paths for small separators up to a len of 4 bytes\nThese optimizations gave me ~10%, ~50% and ~80% improvements respectively over the previous speed. Those are multiplicative.\n\n3x improvement happens for the optimal case of joining many small strings together in my microbenchmarks. Improvements flatten out for larger strings of course as more time is spent copying bits around. I've run a few benchmarks [with this code](https://github.com/Emerentius/join_bench). They are pretty noise despite high iteration counts, but in total one can see the trends.\n\n```\nlen_separator  len_string   n_strings     speedup\n           4          10          10        2.38\n           4          10         100        3.41\n           4          10        1000        3.43\n           4          10       10000        3.25\n           4         100          10        2.23\n           4         100         100        2.73\n           4         100        1000        1.33\n           4         100       10000        1.14\n           4        1000          10        1.33\n           4        1000         100        1.15\n           4        1000        1000        1.08\n           4        1000       10000        1.04\n          10          10          10        1.61\n          10          10         100        1.74\n          10          10        1000        1.77\n          10          10       10000        1.75\n          10         100          10        1.58\n          10         100         100        1.65\n          10         100        1000        1.24\n          10         100       10000        1.12\n          10        1000          10        1.23\n          10        1000         100        1.11\n          10        1000        1000        1.05\n          10        1000       10000       0.997\n         100          10          10        1.66\n         100          10         100        1.78\n         100          10        1000        1.28\n         100          10       10000        1.16\n         100         100          10        1.37\n         100         100         100        1.26\n         100         100        1000        1.09\n         100         100       10000         1.0\n         100        1000          10        1.19\n         100        1000         100        1.12\n         100        1000        1000        1.05\n         100        1000       10000        1.12\n```\n\nThe string joining with small or empty separators is now ~50% faster than the old concatenation (small strings). The same approach can also improve the performance of joining into vectors.\n\nIf this approach is acceptable, I can apply it for concatenation and for vectors as well. Alternatively, concat could just call `.join(\"\")`.", "tree": {"sha": "5231dffae509e7321a329ef6d3a3db25bdedd939", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5231dffae509e7321a329ef6d3a3db25bdedd939"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/747e655010dd200b4faef1db0910f6097920b58e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/747e655010dd200b4faef1db0910f6097920b58e", "html_url": "https://github.com/rust-lang/rust/commit/747e655010dd200b4faef1db0910f6097920b58e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/747e655010dd200b4faef1db0910f6097920b58e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f91323129000b20a5e3590d03fb3775bf73d5082", "url": "https://api.github.com/repos/rust-lang/rust/commits/f91323129000b20a5e3590d03fb3775bf73d5082", "html_url": "https://github.com/rust-lang/rust/commit/f91323129000b20a5e3590d03fb3775bf73d5082"}, {"sha": "12bd28874697d600d347518c8636053b92e81801", "url": "https://api.github.com/repos/rust-lang/rust/commits/12bd28874697d600d347518c8636053b92e81801", "html_url": "https://github.com/rust-lang/rust/commit/12bd28874697d600d347518c8636053b92e81801"}], "stats": {"total": 164, "additions": 122, "deletions": 42}, "files": [{"sha": "90bc2f9769c882fb34bbefb0909ec019e1bb881f", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/747e655010dd200b4faef1db0910f6097920b58e/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/747e655010dd200b4faef1db0910f6097920b58e/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=747e655010dd200b4faef1db0910f6097920b58e", "patch": "@@ -566,15 +566,17 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n     }\n \n     fn join(&self, sep: &T) -> Vec<T> {\n+        let mut iter = self.iter();\n+        let first = match iter.next() {\n+            Some(first) => first,\n+            None => return vec![],\n+        };\n         let size = self.iter().fold(0, |acc, v| acc + v.borrow().len());\n         let mut result = Vec::with_capacity(size + self.len());\n-        let mut first = true;\n-        for v in self {\n-            if first {\n-                first = false\n-            } else {\n-                result.push(sep.clone())\n-            }\n+        result.extend_from_slice(first.borrow());\n+\n+        for v in iter {\n+            result.push(sep.clone());\n             result.extend_from_slice(v.borrow())\n         }\n         result"}, {"sha": "32ca8d1fa5eba835c83378ac15c52589310e72d5", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 91, "deletions": 35, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/747e655010dd200b4faef1db0910f6097920b58e/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/747e655010dd200b4faef1db0910f6097920b58e/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=747e655010dd200b4faef1db0910f6097920b58e", "patch": "@@ -86,52 +86,108 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n     type Output = String;\n \n     fn concat(&self) -> String {\n-        if self.is_empty() {\n-            return String::new();\n-        }\n-\n-        // `len` calculation may overflow but push_str will check boundaries\n-        let len = self.iter().map(|s| s.borrow().len()).sum();\n-        let mut result = String::with_capacity(len);\n-\n-        for s in self {\n-            result.push_str(s.borrow())\n-        }\n-\n-        result\n+        self.join(\"\")\n     }\n \n     fn join(&self, sep: &str) -> String {\n-        if self.is_empty() {\n-            return String::new();\n-        }\n-\n-        // concat is faster\n-        if sep.is_empty() {\n-            return self.concat();\n+        unsafe {\n+            String::from_utf8_unchecked( join_generic_copy(self, sep.as_bytes()) )\n         }\n+    }\n \n-        // this is wrong without the guarantee that `self` is non-empty\n-        // `len` calculation may overflow but push_str but will check boundaries\n-        let len = sep.len() * (self.len() - 1) +\n-                  self.iter().map(|s| s.borrow().len()).sum::<usize>();\n-        let mut result = String::with_capacity(len);\n-        let mut first = true;\n+    fn connect(&self, sep: &str) -> String {\n+        self.join(sep)\n+    }\n+}\n \n-        for s in self {\n-            if first {\n-                first = false;\n-            } else {\n-                result.push_str(sep);\n+macro_rules! spezialize_for_lengths {\n+    ($separator:expr, $target:expr, $iter:expr; $($num:expr),*) => {\n+        let mut target = $target;\n+        let iter = $iter;\n+        let sep_bytes = $separator;\n+        match $separator.len() {\n+            $(\n+                // loops with hardcoded sizes run much faster\n+                // specialize the cases with small separator lengths\n+                $num => {\n+                    for s in iter {\n+                        copy_slice_and_advance!(target, sep_bytes);\n+                        copy_slice_and_advance!(target, s.borrow().as_ref());\n+                    }\n+                },\n+            )*\n+            _ => {\n+                // arbitrary non-zero size fallback\n+                for s in iter {\n+                    copy_slice_and_advance!(target, sep_bytes);\n+                    copy_slice_and_advance!(target, s.borrow().as_ref());\n+                }\n             }\n-            result.push_str(s.borrow());\n         }\n-        result\n+    };\n+}\n+\n+macro_rules! copy_slice_and_advance {\n+    ($target:expr, $bytes:expr) => {\n+        let len = $bytes.len();\n+        let (head, tail) = {$target}.split_at_mut(len);\n+        head.copy_from_slice($bytes);\n+        $target = tail;\n     }\n+}\n \n-    fn connect(&self, sep: &str) -> String {\n-        self.join(sep)\n+// Optimized join implementation that works for both Vec<T> (T: Copy) and String's inner vec\n+// Currently (2018-05-13) there is a bug with type inference and specialization (see issue #36262)\n+// For this reason SliceConcatExt<T> is not specialized for T: Copy and SliceConcatExt<str> is the\n+// only user of this function. It is left in place for the time when that is fixed.\n+//\n+// the bounds for String-join are S: Borrow<str> and for Vec-join Borrow<[T]>\n+// [T] and str both impl AsRef<[T]> for some T\n+// => s.borrow().as_ref() and we always have slices\n+fn join_generic_copy<B, T, S>(slice: &[S], sep: &[T]) -> Vec<T>\n+where\n+    T: Copy,\n+    B: AsRef<[T]> + ?Sized,\n+    S: Borrow<B>,\n+{\n+    let sep_len = sep.len();\n+    let mut iter = slice.iter();\n+\n+    // the first slice is the only one without a separator preceding it\n+    let first = match iter.next() {\n+        Some(first) => first,\n+        None => return vec![],\n+    };\n+\n+    // compute the exact total length of the joined Vec\n+    // if the `len` calculation overflows, we'll panic\n+    // we would have run out of memory anyway and the rest of the function requires\n+    // the entire Vec pre-allocated for safety\n+    let len =  sep_len.checked_mul(iter.len()).and_then(|n| {\n+            slice.iter()\n+                .map(|s| s.borrow().as_ref().len())\n+                .try_fold(n, usize::checked_add)\n+        }).expect(\"attempt to join into collection with len > usize::MAX\");\n+\n+    // crucial for safety\n+    let mut result = Vec::with_capacity(len);\n+    assert!(result.capacity() >= len);\n+\n+    result.extend_from_slice(first.borrow().as_ref());\n+\n+    unsafe {\n+        {\n+            let pos = result.len();\n+            let target = result.get_unchecked_mut(pos..len);\n+\n+            // copy separator and slices over without bounds checks\n+            // generate loops with hardcoded offsets for small separators\n+            // massive improvements possible (~ x2)\n+            spezialize_for_lengths!(sep, target, iter; 0, 1, 2, 3, 4);\n+        }\n+        result.set_len(len);\n     }\n+    result\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "3b7eec38609d0b45c94bca198f7cf998e7daa51a", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/747e655010dd200b4faef1db0910f6097920b58e/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/747e655010dd200b4faef1db0910f6097920b58e/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=747e655010dd200b4faef1db0910f6097920b58e", "patch": "@@ -609,6 +609,15 @@ fn test_join() {\n     assert_eq!(v.join(&0), [1, 0, 2, 0, 3]);\n }\n \n+#[test]\n+fn test_join_nocopy() {\n+    let v: [String; 0] = [];\n+    assert_eq!(v.join(\",\"), \"\");\n+    assert_eq!([\"a\".to_string(), \"ab\".into()].join(\",\"), \"a,ab\");\n+    assert_eq!([\"a\".to_string(), \"ab\".into(), \"abc\".into()].join(\",\"), \"a,ab,abc\");\n+    assert_eq!([\"a\".to_string(), \"ab\".into(), \"\".into()].join(\",\"), \"a,ab,\");\n+}\n+\n #[test]\n fn test_insert() {\n     let mut a = vec![1, 2, 4];"}, {"sha": "03d295d16e6a0776e831dd5e3741df5f35f5e0bc", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/747e655010dd200b4faef1db0910f6097920b58e/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/747e655010dd200b4faef1db0910f6097920b58e/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=747e655010dd200b4faef1db0910f6097920b58e", "patch": "@@ -162,6 +162,19 @@ fn test_join_for_different_lengths() {\n     test_join!(\"-a-bc\", [\"\", \"a\", \"bc\"], \"-\");\n }\n \n+// join has fast paths for small separators up to 4 bytes\n+// this tests the slow paths.\n+#[test]\n+fn test_join_for_different_lengths_with_long_separator() {\n+    assert_eq!(\"\uff5e\uff5e\uff5e\uff5e\uff5e\".len(), 15);\n+\n+    let empty: &[&str] = &[];\n+    test_join!(\"\", empty, \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n+    test_join!(\"a\", [\"a\"], \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n+    test_join!(\"a\uff5e\uff5e\uff5e\uff5e\uff5eb\", [\"a\", \"b\"], \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n+    test_join!(\"\uff5e\uff5e\uff5e\uff5e\uff5ea\uff5e\uff5e\uff5e\uff5e\uff5ebc\", [\"\", \"a\", \"bc\"], \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n+}\n+\n #[test]\n fn test_unsafe_slice() {\n     assert_eq!(\"ab\", unsafe {\"abc\".slice_unchecked(0, 2)});"}]}