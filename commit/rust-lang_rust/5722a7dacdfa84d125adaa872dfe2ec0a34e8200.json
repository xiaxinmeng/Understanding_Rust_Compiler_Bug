{"sha": "5722a7dacdfa84d125adaa872dfe2ec0a34e8200", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3MjJhN2RhY2RmYTg0ZDEyNWFkYWE4NzJkZmUyZWMwYTM0ZTgyMDA=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-08-26T15:05:33Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-09-02T11:38:59Z"}, "message": "Fix manual_match with let-expressions", "tree": {"sha": "9c8837cc0f737dfb96e02cd88849d20fd2501d56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c8837cc0f737dfb96e02cd88849d20fd2501d56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5722a7dacdfa84d125adaa872dfe2ec0a34e8200", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmEwt9MACgkQHKDfKvWd\naKW7QQ/+JLY/ObLstfQp/M4/widRQvFoZYRMBdStsQ9K344f8ugyRPJT4Mra3NZi\n0GVYT1q9l4u38bjKYS9CbtEofqSqREIdcMqfUk3Ug4Qfvbt23xgD0UT4B3Dzk6JM\n/fp4v+0MdIhUtV43zdupIJiLfhwYrL+oPUa6LBTC0sHR725KV1sol5R1vjvfJgwe\nxEUrTWdyHJxgB8AfRrri9gu8Mz5LOQkpASEJWoJrMlhwG9Ri7Oi2k2L8pTmyn3uu\n6jw/2q++7y9jeMev+1H9aGPqhXiCN+3MrcLrGa2rbuG5BTCfi94d7pPUEcF2yT8l\nBc4neLrc/wQ/pvMeru1YJzuP5srvhh3JmTpIAsW/PwjOj67FWOtFpAn7KwXCPJCb\nmoK3qJtUWJDcb17y4nik7Z/ySImMpzsqwkINbEHXhT+bkGICOpVsbB+GtRTVeuWq\nWNCdSJN+KNeGflPRpl4SbUVcnsWcYFm8NZeKs1XhaJCxFrHRhn3Wvy+69YoqTqWj\nrQEInDj4AaOLuMGlUyjNcT5YZT6CEyJjHteyFnDiFf06YV8D4IlXAuW1KASj/SWp\nM//g4cj3SXT7g9BSWxhTiHc/WHnpRBwasGlE+Nzfd3v5WEdff0V/4LoeZgHzMibQ\nAiMt27D5tnDmZkNOvVYuORVhGIYqndmo+xtAiVRWbjXnOg1fb5I=\n=MRB5\n-----END PGP SIGNATURE-----", "payload": "tree 9c8837cc0f737dfb96e02cd88849d20fd2501d56\nparent 61bb96738ce020cd21d144be24da8d840a9a4f59\nauthor Cameron Steffen <cam.steffen94@gmail.com> 1629990333 -0500\ncommitter flip1995 <philipp.krones@embecosm.com> 1630582739 +0100\n\nFix manual_match with let-expressions\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5722a7dacdfa84d125adaa872dfe2ec0a34e8200", "html_url": "https://github.com/rust-lang/rust/commit/5722a7dacdfa84d125adaa872dfe2ec0a34e8200", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5722a7dacdfa84d125adaa872dfe2ec0a34e8200/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61bb96738ce020cd21d144be24da8d840a9a4f59", "url": "https://api.github.com/repos/rust-lang/rust/commits/61bb96738ce020cd21d144be24da8d840a9a4f59", "html_url": "https://github.com/rust-lang/rust/commit/61bb96738ce020cd21d144be24da8d840a9a4f59"}], "stats": {"total": 402, "additions": 191, "deletions": 211}, "files": [{"sha": "86226be715d3fabb4a5269d5bde3986378caf6f7", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5722a7dacdfa84d125adaa872dfe2ec0a34e8200/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5722a7dacdfa84d125adaa872dfe2ec0a34e8200/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=5722a7dacdfa84d125adaa872dfe2ec0a34e8200", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{higher, is_lang_ctor, is_unit_expr, path_to_local, peel_ref_operators, SpanlessEq};\n+use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, MatchSource, Pat, PatKind, StmtKind};\n+use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{MultiSpan, Span};\n@@ -149,33 +150,6 @@ fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir>\n     expr\n }\n \n-enum IfLetOrMatch<'hir> {\n-    Match(&'hir Expr<'hir>, &'hir [Arm<'hir>], MatchSource),\n-    /// scrutinee, pattern, then block, else block\n-    IfLet(\n-        &'hir Expr<'hir>,\n-        &'hir Pat<'hir>,\n-        &'hir Expr<'hir>,\n-        Option<&'hir Expr<'hir>>,\n-    ),\n-}\n-\n-impl<'hir> IfLetOrMatch<'hir> {\n-    fn parse(cx: &LateContext<'_>, expr: &Expr<'hir>) -> Option<Self> {\n-        match expr.kind {\n-            ExprKind::Match(expr, arms, source) => Some(Self::Match(expr, arms, source)),\n-            _ => higher::IfLet::hir(cx, expr).map(\n-                |higher::IfLet {\n-                     let_expr,\n-                     let_pat,\n-                     if_then,\n-                     if_else,\n-                 }| { Self::IfLet(let_expr, let_pat, if_then, if_else) },\n-            ),\n-        }\n-    }\n-}\n-\n /// A \"wild-like\" arm has a wild (`_`) or `None` pattern and no guard. Such arms can be \"collapsed\"\n /// into a single wild arm without any significant loss in semantics or readability.\n fn arm_is_wild_like(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {"}, {"sha": "b5f573cb104e914a6cde3eab296f7da9b7842b0c", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 153, "deletions": 181, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/5722a7dacdfa84d125adaa872dfe2ec0a34e8200/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5722a7dacdfa84d125adaa872dfe2ec0a34e8200/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=5722a7dacdfa84d125adaa872dfe2ec0a34e8200", "patch": "@@ -1,6 +1,6 @@\n use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher;\n+use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n use clippy_utils::{\n@@ -46,190 +46,169 @@ declare_lint_pass!(ManualMap => [MANUAL_MAP]);\n impl LateLintPass<'_> for ManualMap {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some(higher::IfLet {\n-            let_pat,\n-            let_expr,\n-            if_then,\n-            if_else: Some(if_else),\n-        }) = higher::IfLet::hir(cx, expr)\n-        {\n-            manage_lint(cx, expr, (&let_pat.kind, if_then), (&PatKind::Wild, if_else), let_expr);\n+        let (scrutinee, then_pat, then_body, else_pat, else_body) = match IfLetOrMatch::parse(cx, expr) {\n+            Some(IfLetOrMatch::IfLet(scrutinee, pat, body, Some(r#else))) => (scrutinee, pat, body, None, r#else),\n+            Some(IfLetOrMatch::Match(\n+                scrutinee,\n+                [arm1 @ Arm { guard: None, .. }, arm2 @ Arm { guard: None, .. }],\n+                _,\n+            )) => (scrutinee, arm1.pat, arm1.body, Some(arm2.pat), arm2.body),\n+            _ => return,\n+        };\n+        if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n+            return;\n         }\n \n-        if let ExprKind::Match(scrutinee, [then @ Arm { guard: None, .. }, r#else @ Arm { guard: None, .. }], _) =\n-            expr.kind\n+        let (scrutinee_ty, ty_ref_count, ty_mutability) =\n+            peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n+        if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n+            && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type))\n         {\n-            manage_lint(\n-                cx,\n-                expr,\n-                (&then.pat.kind, then.body),\n-                (&r#else.pat.kind, r#else.body),\n-                scrutinee,\n-            );\n+            return;\n         }\n-    }\n-}\n-\n-fn manage_lint<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx Expr<'_>,\n-    then: (&'tcx PatKind<'_>, &'tcx Expr<'_>),\n-    r#else: (&'tcx PatKind<'_>, &'tcx Expr<'_>),\n-    scrut: &'tcx Expr<'_>,\n-) {\n-    if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n-        return;\n-    }\n-\n-    let (scrutinee_ty, ty_ref_count, ty_mutability) = peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrut));\n-    if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n-        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type))\n-    {\n-        return;\n-    }\n-\n-    let (then_pat, then_expr) = then;\n-    let (else_pat, else_expr) = r#else;\n \n-    let expr_ctxt = expr.span.ctxt();\n-    let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n-        try_parse_pattern(cx, then_pat, expr_ctxt),\n-        try_parse_pattern(cx, else_pat, expr_ctxt),\n-    ) {\n-        (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_expr) => {\n-            (else_expr, pattern, ref_count, true)\n-        },\n-        (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_expr) => {\n-            (else_expr, pattern, ref_count, false)\n-        },\n-        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_expr) => {\n-            (then_expr, pattern, ref_count, true)\n-        },\n-        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_expr) => {\n-            (then_expr, pattern, ref_count, false)\n-        },\n-        _ => return,\n-    };\n+        let expr_ctxt = expr.span.ctxt();\n+        let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n+            try_parse_pattern(cx, then_pat, expr_ctxt),\n+            else_pat.map_or(Some(OptionPat::Wild), |p| try_parse_pattern(cx, p, expr_ctxt)),\n+        ) {\n+            (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+                (else_body, pattern, ref_count, true)\n+            },\n+            (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+                (else_body, pattern, ref_count, false)\n+            },\n+            (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_body) => {\n+                (then_body, pattern, ref_count, true)\n+            },\n+            (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_body) => {\n+                (then_body, pattern, ref_count, false)\n+            },\n+            _ => return,\n+        };\n \n-    // Top level or patterns aren't allowed in closures.\n-    if matches!(some_pat.kind, PatKind::Or(_)) {\n-        return;\n-    }\n+        // Top level or patterns aren't allowed in closures.\n+        if matches!(some_pat.kind, PatKind::Or(_)) {\n+            return;\n+        }\n \n-    let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n-        Some(expr) => expr,\n-        None => return,\n-    };\n+        let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n+            Some(expr) => expr,\n+            None => return,\n+        };\n \n-    if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit\n-        && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n-    {\n-        return;\n-    }\n+        // These two lints will go back and forth with each other.\n+        if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit\n+            && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n+        {\n+            return;\n+        }\n \n-    // `map` won't perform any adjustments.\n-    if !cx.typeck_results().expr_adjustments(some_expr).is_empty() {\n-        return;\n-    }\n+        // `map` won't perform any adjustments.\n+        if !cx.typeck_results().expr_adjustments(some_expr).is_empty() {\n+            return;\n+        }\n \n-    // Determine which binding mode to use.\n-    let explicit_ref = some_pat.contains_explicit_ref_binding();\n-    let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n+        // Determine which binding mode to use.\n+        let explicit_ref = some_pat.contains_explicit_ref_binding();\n+        let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n \n-    let as_ref_str = match binding_ref {\n-        Some(Mutability::Mut) => \".as_mut()\",\n-        Some(Mutability::Not) => \".as_ref()\",\n-        None => \"\",\n-    };\n+        let as_ref_str = match binding_ref {\n+            Some(Mutability::Mut) => \".as_mut()\",\n+            Some(Mutability::Not) => \".as_ref()\",\n+            None => \"\",\n+        };\n \n-    match can_move_expr_to_closure(cx, some_expr) {\n-        Some(captures) => {\n-            // Check if captures the closure will need conflict with borrows made in the scrutinee.\n-            // TODO: check all the references made in the scrutinee expression. This will require interacting\n-            // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n-            if let Some(binding_ref_mutability) = binding_ref {\n-                let e = peel_hir_expr_while(scrut, |e| match e.kind {\n-                    ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n-                    _ => None,\n-                });\n-                if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n-                    match captures.get(l) {\n-                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return,\n-                        Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n-                            return;\n-                        },\n-                        Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n+        match can_move_expr_to_closure(cx, some_expr) {\n+            Some(captures) => {\n+                // Check if captures the closure will need conflict with borrows made in the scrutinee.\n+                // TODO: check all the references made in the scrutinee expression. This will require interacting\n+                // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n+                if let Some(binding_ref_mutability) = binding_ref {\n+                    let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n+                        ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n+                        _ => None,\n+                    });\n+                    if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n+                        match captures.get(l) {\n+                            Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return,\n+                            Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n+                                return;\n+                            },\n+                            Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n+                        }\n                     }\n                 }\n-            }\n-        },\n-        None => return,\n-    };\n-\n-    let mut app = Applicability::MachineApplicable;\n+            },\n+            None => return,\n+        };\n \n-    // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n-    // it's being passed by value.\n-    let scrutinee = peel_hir_expr_refs(scrut).0;\n-    let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n-    let scrutinee_str = if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n-        format!(\"({})\", scrutinee_str)\n-    } else {\n-        scrutinee_str.into()\n-    };\n+        let mut app = Applicability::MachineApplicable;\n \n-    let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n-        match can_pass_as_func(cx, id, some_expr) {\n-            Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n-                snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n-            },\n-            _ => {\n-                if path_to_local_id(some_expr, id)\n-                    && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n-                    && binding_ref.is_some()\n-                {\n-                    return;\n-                }\n+        // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n+        // it's being passed by value.\n+        let scrutinee = peel_hir_expr_refs(scrutinee).0;\n+        let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n+        let scrutinee_str =\n+            if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n+                format!(\"({})\", scrutinee_str)\n+            } else {\n+                scrutinee_str.into()\n+            };\n \n-                // `ref` and `ref mut` annotations were handled earlier.\n-                let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n-                    \"mut \"\n-                } else {\n-                    \"\"\n-                };\n-                format!(\n-                    \"|{}{}| {}\",\n-                    annotation,\n-                    some_binding,\n-                    snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n-                )\n-            },\n-        }\n-    } else if !is_wild_none && explicit_ref.is_none() {\n-        // TODO: handle explicit reference annotations.\n-        format!(\n-            \"|{}| {}\",\n-            snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n-            snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n-        )\n-    } else {\n-        // Refutable bindings and mixed reference annotations can't be handled by `map`.\n-        return;\n-    };\n+        let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n+            match can_pass_as_func(cx, id, some_expr) {\n+                Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n+                    snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+                },\n+                _ => {\n+                    if path_to_local_id(some_expr, id)\n+                        && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                        && binding_ref.is_some()\n+                    {\n+                        return;\n+                    }\n \n-    span_lint_and_sugg(\n-        cx,\n-        MANUAL_MAP,\n-        expr.span,\n-        \"manual implementation of `Option::map`\",\n-        \"try this\",\n-        if is_else_clause(cx.tcx, expr) {\n-            format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n+                    // `ref` and `ref mut` annotations were handled earlier.\n+                    let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n+                        \"mut \"\n+                    } else {\n+                        \"\"\n+                    };\n+                    format!(\n+                        \"|{}{}| {}\",\n+                        annotation,\n+                        some_binding,\n+                        snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n+                    )\n+                },\n+            }\n+        } else if !is_wild_none && explicit_ref.is_none() {\n+            // TODO: handle explicit reference annotations.\n+            format!(\n+                \"|{}| {}\",\n+                snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n+                snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n+            )\n         } else {\n-            format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)\n-        },\n-        app,\n-    );\n+            // Refutable bindings and mixed reference annotations can't be handled by `map`.\n+            return;\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            MANUAL_MAP,\n+            expr.span,\n+            \"manual implementation of `Option::map`\",\n+            \"try this\",\n+            if else_pat.is_none() && is_else_clause(cx.tcx, expr) {\n+                format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n+            } else {\n+                format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)\n+            },\n+            app,\n+        );\n+    }\n }\n \n // Checks whether the expression could be passed as a function, or whether a closure is needed.\n@@ -259,28 +238,21 @@ enum OptionPat<'a> {\n \n // Try to parse into a recognized `Option` pattern.\n // i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n-fn try_parse_pattern(\n-    cx: &LateContext<'tcx>,\n-    pat_kind: &'tcx PatKind<'_>,\n-    ctxt: SyntaxContext,\n-) -> Option<OptionPat<'tcx>> {\n-    fn f(\n-        cx: &LateContext<'tcx>,\n-        pat_kind: &'tcx PatKind<'_>,\n-        ref_count: usize,\n-        ctxt: SyntaxContext,\n-    ) -> Option<OptionPat<'tcx>> {\n-        match pat_kind {\n+fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n+    fn f(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ref_count: usize, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n+        match pat.kind {\n             PatKind::Wild => Some(OptionPat::Wild),\n-            PatKind::Ref(ref_pat, _) => f(cx, &ref_pat.kind, ref_count + 1, ctxt),\n+            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n             PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone) => Some(OptionPat::None),\n-            PatKind::TupleStruct(ref qpath, [pattern], _) if is_lang_ctor(cx, qpath, OptionSome) => {\n+            PatKind::TupleStruct(ref qpath, [pattern], _)\n+                if is_lang_ctor(cx, qpath, OptionSome) && pat.span.ctxt() == ctxt =>\n+            {\n                 Some(OptionPat::Some { pattern, ref_count })\n             },\n             _ => None,\n         }\n     }\n-    f(cx, pat_kind, 0, ctxt)\n+    f(cx, pat, 0, ctxt)\n }\n \n // Checks for an expression wrapped by the `Some` constructor. Returns the contained expression."}, {"sha": "61e672781f8409a5ff010e2fe459a9f7f37f5b69", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5722a7dacdfa84d125adaa872dfe2ec0a34e8200/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5722a7dacdfa84d125adaa872dfe2ec0a34e8200/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=5722a7dacdfa84d125adaa872dfe2ec0a34e8200", "patch": "@@ -6,7 +6,7 @@ use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::{self, LitKind};\n use rustc_hir as hir;\n-use rustc_hir::{Block, BorrowKind, Expr, ExprKind, LoopSource, Node, Pat, StmtKind, UnOp};\n+use rustc_hir::{Arm, Block, BorrowKind, Expr, ExprKind, LoopSource, MatchSource, Node, Pat, StmtKind, UnOp};\n use rustc_lint::LateContext;\n use rustc_span::{sym, ExpnKind, Span, Symbol};\n \n@@ -115,6 +115,33 @@ impl<'hir> IfLet<'hir> {\n     }\n }\n \n+pub enum IfLetOrMatch<'hir> {\n+    Match(&'hir Expr<'hir>, &'hir [Arm<'hir>], MatchSource),\n+    /// scrutinee, pattern, then block, else block\n+    IfLet(\n+        &'hir Expr<'hir>,\n+        &'hir Pat<'hir>,\n+        &'hir Expr<'hir>,\n+        Option<&'hir Expr<'hir>>,\n+    ),\n+}\n+\n+impl<'hir> IfLetOrMatch<'hir> {\n+    pub fn parse(cx: &LateContext<'_>, expr: &Expr<'hir>) -> Option<Self> {\n+        match expr.kind {\n+            ExprKind::Match(expr, arms, source) => Some(Self::Match(expr, arms, source)),\n+            _ => IfLet::hir(cx, expr).map(\n+                |IfLet {\n+                     let_expr,\n+                     let_pat,\n+                     if_then,\n+                     if_else,\n+                 }| { Self::IfLet(let_expr, let_pat, if_then, if_else) },\n+            ),\n+        }\n+    }\n+}\n+\n pub struct IfOrIfLet<'hir> {\n     pub cond: &'hir Expr<'hir>,\n     pub r#else: Option<&'hir Expr<'hir>>,"}, {"sha": "6cecdd6b1996395685299f9070af006b4648f527", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5722a7dacdfa84d125adaa872dfe2ec0a34e8200/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5722a7dacdfa84d125adaa872dfe2ec0a34e8200/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=5722a7dacdfa84d125adaa872dfe2ec0a34e8200", "patch": "@@ -808,6 +808,13 @@ pub fn capture_local_usage(cx: &LateContext<'tcx>, e: &Expr<'_>) -> CaptureKind\n                         capture_expr_ty = e;\n                     }\n                 },\n+                ExprKind::Let(pat, ..) => {\n+                    let mutability = match pat_capture_kind(cx, pat) {\n+                        CaptureKind::Value => Mutability::Not,\n+                        CaptureKind::Ref(m) => m,\n+                    };\n+                    return CaptureKind::Ref(mutability);\n+                },\n                 ExprKind::Match(_, arms, _) => {\n                     let mut mutability = Mutability::Not;\n                     for capture in arms.iter().map(|arm| pat_capture_kind(cx, arm.pat)) {"}]}