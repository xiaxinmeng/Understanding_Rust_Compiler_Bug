{"sha": "e80f2470b710838aefd1020c09562e275bdcb28e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MGYyNDcwYjcxMDgzOGFlZmQxMDIwYzA5NTYyZTI3NWJkY2IyOGU=", "commit": {"author": {"name": "R.Chavignat", "email": "r.chavignat@gmail.com", "date": "2015-08-22T22:08:16Z"}, "committer": {"name": "R.Chavignat", "email": "r.chavignat@gmail.com", "date": "2015-08-22T22:08:16Z"}, "message": "Merge branch 'master' into cast_iusize_improvements", "tree": {"sha": "11d5769be0971f90df55bfc7690b0c68d29046ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11d5769be0971f90df55bfc7690b0c68d29046ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e80f2470b710838aefd1020c09562e275bdcb28e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e80f2470b710838aefd1020c09562e275bdcb28e", "html_url": "https://github.com/rust-lang/rust/commit/e80f2470b710838aefd1020c09562e275bdcb28e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e80f2470b710838aefd1020c09562e275bdcb28e/comments", "author": {"login": "Robzz", "id": 304428, "node_id": "MDQ6VXNlcjMwNDQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/304428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Robzz", "html_url": "https://github.com/Robzz", "followers_url": "https://api.github.com/users/Robzz/followers", "following_url": "https://api.github.com/users/Robzz/following{/other_user}", "gists_url": "https://api.github.com/users/Robzz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Robzz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Robzz/subscriptions", "organizations_url": "https://api.github.com/users/Robzz/orgs", "repos_url": "https://api.github.com/users/Robzz/repos", "events_url": "https://api.github.com/users/Robzz/events{/privacy}", "received_events_url": "https://api.github.com/users/Robzz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Robzz", "id": 304428, "node_id": "MDQ6VXNlcjMwNDQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/304428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Robzz", "html_url": "https://github.com/Robzz", "followers_url": "https://api.github.com/users/Robzz/followers", "following_url": "https://api.github.com/users/Robzz/following{/other_user}", "gists_url": "https://api.github.com/users/Robzz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Robzz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Robzz/subscriptions", "organizations_url": "https://api.github.com/users/Robzz/orgs", "repos_url": "https://api.github.com/users/Robzz/repos", "events_url": "https://api.github.com/users/Robzz/events{/privacy}", "received_events_url": "https://api.github.com/users/Robzz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79ef13592e617e58b84146ba568c43bad81e77bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/79ef13592e617e58b84146ba568c43bad81e77bf", "html_url": "https://github.com/rust-lang/rust/commit/79ef13592e617e58b84146ba568c43bad81e77bf"}, {"sha": "5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "html_url": "https://github.com/rust-lang/rust/commit/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90"}], "stats": {"total": 641, "additions": 419, "deletions": 222}, "files": [{"sha": "66881b522903a1d8f4411586b53f11c5fbaa457b", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -30,6 +30,7 @@ len_zero                 | warn    | checking `.len() == 0` or `.len() > 0` (or\n let_and_return           | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a function\n let_unit_value           | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n linkedlist               | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a RingBuf\n+match_ref_pats           | warn    | a match has all arms prefixed with `&`; the match expression can be dereferenced instead\n modulo_one               | warn    | taking a number modulo 1, which always returns 0\n mut_mut                  | warn    | usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, or shows a fundamental misunderstanding of references)\n needless_bool            | warn    | if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`\n@@ -49,6 +50,7 @@ string_add               | allow   | using `x + ..` where x is a `String`; sugge\n string_add_assign        | allow   | using `x = x + ..` where x is a `String`; suggests using `push_str()` instead\n string_to_string         | warn    | calling `String.to_string()` which is a no-op\n toplevel_ref_arg         | warn    | a function argument is declared `ref` (i.e. `fn foo(ref x: u8)`, but not `fn foo((ref x, ref y): (u8, u8))`)\n+type_complexity          | warn    | usage of very complex types; recommends factoring out parts into `type` definitions\n unit_cmp                 | warn    | comparing unit values (which is always `true` or `false`, respectively)\n zero_width_space         | deny    | using a zero-width space in a string literal, which is confusing\n "}, {"sha": "3e0ba4eb669f8e20941033c4c6b3558da1c2f5e6", "filename": "src/approx_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -37,10 +37,10 @@ impl LintPass for ApproxConstant {\n }\n \n fn check_lit(cx: &Context, lit: &Lit, span: Span) {\n-    match &lit.node {\n-        &LitFloat(ref str, TyF32) => check_known_consts(cx, span, str, \"f32\"),\n-        &LitFloat(ref str, TyF64) => check_known_consts(cx, span, str, \"f64\"),\n-        &LitFloatUnsuffixed(ref str) => check_known_consts(cx, span, str, \"f{32, 64}\"),\n+    match lit.node {\n+        LitFloat(ref str, TyF32) => check_known_consts(cx, span, str, \"f32\"),\n+        LitFloat(ref str, TyF64) => check_known_consts(cx, span, str, \"f64\"),\n+        LitFloatUnsuffixed(ref str) => check_known_consts(cx, span, str, \"f{32, 64}\"),\n         _ => ()\n     }\n }"}, {"sha": "6537fcf4c1abb77be0211a1e01cdf0b26c969491", "filename": "src/bit_mask.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -82,9 +82,9 @@ fn invert_cmp(cmp : BinOp_) -> BinOp_ {\n \n \n fn check_compare(cx: &Context, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u64, span: &Span) {\n-    match &bit_op.node {\n-        &ExprParen(ref subexp) => check_compare(cx, subexp, cmp_op, cmp_value, span),\n-        &ExprBinary(ref op, ref left, ref right) => {\n+    match bit_op.node {\n+        ExprParen(ref subexp) => check_compare(cx, subexp, cmp_op, cmp_value, span),\n+        ExprBinary(ref op, ref left, ref right) => {\n             if op.node != BiBitAnd && op.node != BiBitOr { return; }\n             fetch_int_literal(cx, right).or_else(|| fetch_int_literal(\n                 cx, left)).map_or((), |mask| check_bit_mask(cx, op.node,\n@@ -182,13 +182,13 @@ fn check_ineffective_gt(cx: &Context, span: Span, m: u64, c: u64, op: &str) {\n }\n \n fn fetch_int_literal(cx: &Context, lit : &Expr) -> Option<u64> {\n-    match &lit.node {\n-        &ExprLit(ref lit_ptr) => {\n+    match lit.node {\n+        ExprLit(ref lit_ptr) => {\n             if let &LitInt(value, _) = &lit_ptr.node {\n                 Option::Some(value) //TODO: Handle sign\n             } else { Option::None }\n         },\n-        &ExprPath(_, _) => {\n+        ExprPath(_, _) => {\n             // Important to let the borrow expire before the const lookup to avoid double\n             // borrowing.\n             let def_map = cx.tcx.def_map.borrow();"}, {"sha": "e54ac77b599f25f8dfeb27760f4c071e97fb7a5f", "filename": "src/consts.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -330,8 +330,13 @@ impl<'c, 'cc> ConstEvalContext<'c, 'cc> {\n     /// lookup a possibly constant expression from a ExprPath\n     fn fetch_path(&mut self, e: &Expr) -> Option<Constant> {\n         if let Some(lcx) = self.lcx {\n+            let mut maybe_id = None;\n             if let Some(&PathResolution { base_def: DefConst(id), ..}) =\n                 lcx.tcx.def_map.borrow().get(&e.id) {\n+                maybe_id = Some(id);\n+            }\n+            // separate if lets to avoid doubleborrowing the defmap\n+            if let Some(id) = maybe_id {\n                 if let Some(const_expr) = lookup_const_by_id(lcx.tcx, id, None) {\n                     let ret = self.expr(const_expr);\n                     if ret.is_some() {"}, {"sha": "25e967b07e54d45df7b50349a2aa3e85ea5d2f36", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -18,9 +18,9 @@ impl LintPass for EtaPass {\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        match &expr.node {\n-            &ExprCall(_, ref args) |\n-            &ExprMethodCall(_, _, ref args) => {\n+        match expr.node {\n+            ExprCall(_, ref args) |\n+            ExprMethodCall(_, _, ref args) => {\n                 for arg in args {\n                     check_closure(cx, &*arg)\n                 }"}, {"sha": "5eaa0256402df186e0d37341cfc55e862ac11a11", "filename": "src/len_zero.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -22,10 +22,10 @@ impl LintPass for LenZero {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &Item) {\n-        match &item.node {\n-            &ItemTrait(_, _, _, ref trait_items) =>\n+        match item.node {\n+            ItemTrait(_, _, _, ref trait_items) =>\n                 check_trait_items(cx, item, trait_items),\n-            &ItemImpl(_, _, _, None, _, ref impl_items) => // only non-trait\n+            ItemImpl(_, _, _, None, _, ref impl_items) => // only non-trait\n                 check_impl_items(cx, item, impl_items),\n             _ => ()\n         }\n@@ -100,7 +100,7 @@ fn check_cmp(cx: &Context, span: Span, left: &Expr, right: &Expr, op: &str) {\n \n fn check_len_zero(cx: &Context, span: Span, method: &SpannedIdent,\n                   args: &[P<Expr>], lit: &Lit, op: &str) {\n-    if let &Spanned{node: LitInt(0, _), ..} = lit {\n+    if let Spanned{node: LitInt(0, _), ..} = *lit {\n         if method.node.name == \"len\" && args.len() == 1 &&\n             has_is_empty(cx, &*args[0]) {\n                 span_lint(cx, LEN_ZERO, span, &format!("}, {"sha": "863ba2624dddb233b188139dd89edd4ae6343f27", "filename": "src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -38,11 +38,11 @@ pub mod returns;\n pub mod lifetimes;\n pub mod loops;\n pub mod ranges;\n+pub mod matches;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box types::TypePass as LintPassObject);\n-    reg.register_lint_pass(box misc::MiscPass as LintPassObject);\n     reg.register_lint_pass(box misc::TopLevelRefPass as LintPassObject);\n     reg.register_lint_pass(box misc::CmpNan as LintPassObject);\n     reg.register_lint_pass(box eq_op::EqOp as LintPassObject);\n@@ -70,6 +70,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box lifetimes::LifetimePass as LintPassObject);\n     reg.register_lint_pass(box ranges::StepByZero as LintPassObject);\n     reg.register_lint_pass(box types::CastPass as LintPassObject);\n+    reg.register_lint_pass(box types::TypeComplexityPass as LintPassObject);\n+    reg.register_lint_pass(box matches::MatchPass as LintPassObject);\n \n     reg.register_lint_group(\"clippy\", vec![\n         approx_const::APPROX_CONSTANT,\n@@ -86,6 +88,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         loops::EXPLICIT_ITER_LOOP,\n         loops::ITER_NEXT_LOOP,\n         loops::NEEDLESS_RANGE_LOOP,\n+        matches::MATCH_REF_PATS,\n+        matches::SINGLE_MATCH,\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n         methods::STR_TO_STRING,\n@@ -95,7 +99,6 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         misc::FLOAT_CMP,\n         misc::MODULO_ONE,\n         misc::PRECEDENCE,\n-        misc::SINGLE_MATCH,\n         misc::TOPLEVEL_REF_ARG,\n         mut_mut::MUT_MUT,\n         needless_bool::NEEDLESS_BOOL,\n@@ -112,6 +115,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         types::CAST_SIGN_LOSS,\n         types::LET_UNIT_VALUE,\n         types::LINKEDLIST,\n+        types::TYPE_COMPLEXITY,\n         types::UNIT_CMP,\n         unicode::NON_ASCII_LITERAL,\n         unicode::ZERO_WIDTH_SPACE,"}, {"sha": "002da07f50b7180b38eb6e4b815c6c98b5f59604", "filename": "src/matches.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -0,0 +1,86 @@\n+use rustc::lint::*;\n+use syntax::ast;\n+use syntax::ast::*;\n+use std::borrow::Cow;\n+\n+use utils::{snippet, snippet_block, span_lint, span_help_and_lint};\n+\n+declare_lint!(pub SINGLE_MATCH, Warn,\n+              \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n+               is `_ => {}`) is used; recommends `if let` instead\");\n+declare_lint!(pub MATCH_REF_PATS, Warn,\n+              \"a match has all arms prefixed with `&`; the match expression can be \\\n+               dereferenced instead\");\n+\n+#[allow(missing_copy_implementations)]\n+pub struct MatchPass;\n+\n+impl LintPass for MatchPass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(SINGLE_MATCH, MATCH_REF_PATS)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        if let ExprMatch(ref ex, ref arms, ast::MatchSource::Normal) = expr.node {\n+            // check preconditions for SINGLE_MATCH\n+                // only two arms\n+            if arms.len() == 2 &&\n+                // both of the arms have a single pattern and no guard\n+                arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n+                // and the second pattern is a `_` wildcard: this is not strictly necessary,\n+                // since the exhaustiveness check will ensure the last one is a catch-all,\n+                // but in some cases, an explicit match is preferred to catch situations\n+                // when an enum is extended, so we don't consider these cases\n+                arms[1].pats[0].node == PatWild(PatWildSingle) &&\n+                // finally, we don't want any content in the second arm (unit or empty block)\n+                is_unit_expr(&*arms[1].body)\n+            {\n+                let body_code = snippet_block(cx, arms[0].body.span, \"..\");\n+                let body_code = if let ExprBlock(_) = arms[0].body.node {\n+                    body_code\n+                } else {\n+                    Cow::Owned(format!(\"{{ {} }}\", body_code))\n+                };\n+                span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n+                      \"you seem to be trying to use match for \\\n+                      destructuring a single pattern. Did you mean to \\\n+                      use `if let`?\",\n+                      &*format!(\"try\\nif let {} = {} {}\",\n+                                snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                snippet(cx, ex.span, \"..\"),\n+                                body_code)\n+                );\n+            }\n+\n+            // check preconditions for MATCH_REF_PATS\n+            if has_only_ref_pats(arms) {\n+                if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n+                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n+                        \"you don't need to add `&` to both the expression to match \\\n+                         and the patterns: use `match {} {{ ...`\", snippet(cx, inner.span, \"..\")));\n+                } else {\n+                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n+                        \"instead of prefixing all patterns with `&`, you can dereference the \\\n+                         expression to match: `match *{} {{ ...`\", snippet(cx, ex.span, \"..\")));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn is_unit_expr(expr: &Expr) -> bool {\n+    match expr.node {\n+        ExprTup(ref v) if v.is_empty() => true,\n+        ExprBlock(ref b) if b.stmts.is_empty() && b.expr.is_none() => true,\n+        _ => false,\n+    }\n+}\n+\n+fn has_only_ref_pats(arms: &[Arm]) -> bool {\n+    arms.iter().flat_map(|a| &a.pats).all(|p| match p.node {\n+        PatRegion(..) => true,  // &-patterns\n+        PatWild(..) => true,    // an \"anything\" wildcard is also fine\n+        _ => false,\n+    })\n+}"}, {"sha": "df8e35d98fbcc14c19bf1166e0f60669d88bba7a", "filename": "src/methods.rs", "status": "modified", "additions": 15, "deletions": 28, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -2,7 +2,8 @@ use syntax::ast::*;\n use rustc::lint::*;\n use rustc::middle::ty;\n \n-use utils::{span_lint, match_def_path, walk_ptrs_ty};\n+use utils::{span_lint, match_type, walk_ptrs_ty};\n+use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n \n #[derive(Copy,Clone)]\n pub struct MethodsPass;\n@@ -16,45 +17,31 @@ declare_lint!(pub STR_TO_STRING, Warn,\n declare_lint!(pub STRING_TO_STRING, Warn,\n               \"calling `String.to_string()` which is a no-op\");\n \n-#[allow(unused_imports)]\n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        {\n-            // In case stuff gets moved around\n-            use core::option::Option;\n-            use core::result::Result;\n-            use collections::string::String;\n-        }\n         if let ExprMethodCall(ref ident, _, ref args) = expr.node {\n-            let ref obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(&*args[0])).sty;\n+            let obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(&*args[0]));\n             if ident.node.name == \"unwrap\" {\n-                if let ty::TyEnum(did, _) = *obj_ty {\n-                    if match_def_path(cx, did.did, &[\"core\", \"option\", \"Option\"]) {\n-                        span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n-                                  \"used unwrap() on an Option value. If you don't want \\\n-                                   to handle the None case gracefully, consider using\n-                                   expect() to provide a better panic message\");\n-                    }\n-                    else if match_def_path(cx, did.did, &[\"core\", \"result\", \"Result\"]) {\n-                        span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n-                                  \"used unwrap() on a Result value. Graceful handling \\\n-                                   of Err values is preferred\");\n-                    }\n+                if match_type(cx, obj_ty, &OPTION_PATH) {\n+                    span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n+                              \"used unwrap() on an Option value. If you don't want \\\n+                               to handle the None case gracefully, consider using \\\n+                               expect() to provide a better panic message\");\n+                } else if match_type(cx, obj_ty, &RESULT_PATH) {\n+                    span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n+                              \"used unwrap() on a Result value. Graceful handling \\\n+                               of Err values is preferred\");\n                 }\n             }\n             else if ident.node.name == \"to_string\" {\n-                if let ty::TyStr = *obj_ty {\n+                if obj_ty.sty == ty::TyStr {\n                     span_lint(cx, STR_TO_STRING, expr.span, \"`str.to_owned()` is faster\");\n-                }\n-                else if let ty::TyStruct(did, _) = *obj_ty {\n-                    if match_def_path(cx, did.did, &[\"collections\", \"string\", \"String\"]) {\n-                        span_lint(cx, STRING_TO_STRING, expr.span,\n-                                  \"`String.to_string()` is a no-op\")\n-                    }\n+                } else if match_type(cx, obj_ty, &STRING_PATH) {\n+                    span_lint(cx, STRING_TO_STRING, expr.span, \"`String.to_string()` is a no-op\");\n                 }\n             }\n         }"}, {"sha": "81b03db5e143eabf04b214428d515f55aaab65a2", "filename": "src/misc.rs", "status": "modified", "additions": 4, "deletions": 65, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -1,75 +1,14 @@\n use rustc::lint::*;\n use syntax::ptr::P;\n-use syntax::ast;\n use syntax::ast::*;\n use syntax::ast_util::{is_comparison_binop, binop_to_string};\n use syntax::codemap::{Span, Spanned};\n use syntax::visit::FnKind;\n use rustc::middle::ty;\n-use std::borrow::Cow;\n \n-use utils::{match_path, snippet, snippet_block, span_lint, span_help_and_lint, walk_ptrs_ty};\n+use utils::{match_path, snippet, span_lint, walk_ptrs_ty};\n use consts::constant;\n \n-/// Handles uncategorized lints\n-/// Currently handles linting of if-let-able matches\n-#[allow(missing_copy_implementations)]\n-pub struct MiscPass;\n-\n-\n-declare_lint!(pub SINGLE_MATCH, Warn,\n-              \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n-               is `_ => {}`) is used; recommends `if let` instead\");\n-\n-impl LintPass for MiscPass {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(SINGLE_MATCH)\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        if let ExprMatch(ref ex, ref arms, ast::MatchSource::Normal) = expr.node {\n-            // check preconditions: only two arms\n-            if arms.len() == 2 &&\n-                // both of the arms have a single pattern and no guard\n-                arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n-                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n-                // and the second pattern is a `_` wildcard: this is not strictly necessary,\n-                // since the exhaustiveness check will ensure the last one is a catch-all,\n-                // but in some cases, an explicit match is preferred to catch situations\n-                // when an enum is extended, so we don't consider these cases\n-                arms[1].pats[0].node == PatWild(PatWildSingle) &&\n-                // finally, we don't want any content in the second arm (unit or empty block)\n-                is_unit_expr(&*arms[1].body)\n-            {\n-                let body_code = snippet_block(cx, arms[0].body.span, \"..\");\n-                let body_code = if let ExprBlock(_) = arms[0].body.node {\n-                    body_code\n-                } else {\n-                    Cow::Owned(format!(\"{{ {} }}\", body_code))\n-                };\n-                span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n-                      \"you seem to be trying to use match for \\\n-                      destructuring a single pattern. Did you mean to \\\n-                      use `if let`?\",\n-                      &*format!(\"try\\nif let {} = {} {}\",\n-                                snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                snippet(cx, ex.span, \"..\"),\n-                                body_code)\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn is_unit_expr(expr: &Expr) -> bool {\n-    match expr.node {\n-        ExprTup(ref v) if v.is_empty() => true,\n-        ExprBlock(ref b) if b.stmts.is_empty() && b.expr.is_none() => true,\n-        _ => false,\n-    }\n-}\n-\n-\n declare_lint!(pub TOPLEVEL_REF_ARG, Warn,\n               \"a function argument is declared `ref` (i.e. `fn foo(ref x: u8)`, but not \\\n                `fn foo((ref x, ref y): (u8, u8))`)\");\n@@ -236,8 +175,8 @@ impl LintPass for CmpOwned {\n }\n \n fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n-    match &expr.node {\n-        &ExprMethodCall(Spanned{node: ref ident, ..}, _, ref args) => {\n+    match expr.node {\n+        ExprMethodCall(Spanned{node: ref ident, ..}, _, ref args) => {\n             let name = ident.name;\n             if name == \"to_string\" ||\n                 name == \"to_owned\" && is_str_arg(cx, args) {\n@@ -247,7 +186,7 @@ fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n                         snippet(cx, other_span, \"..\")))\n                 }\n         },\n-        &ExprCall(ref path, _) => {\n+        ExprCall(ref path, _) => {\n             if let &ExprPath(None, ref path) = &path.node {\n                 if match_path(path, &[\"String\", \"from_str\"]) ||\n                     match_path(path, &[\"String\", \"from\"]) {"}, {"sha": "7671d63a35d4fde92ed9aaf90de040759c311b70", "filename": "src/needless_bool.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -60,9 +60,9 @@ fn fetch_bool_block(block: &Block) -> Option<bool> {\n }\n \n fn fetch_bool_expr(expr: &Expr) -> Option<bool> {\n-    match &expr.node {\n-        &ExprBlock(ref block) => fetch_bool_block(block),\n-        &ExprLit(ref lit_ptr) => if let &LitBool(value) = &lit_ptr.node {\n+    match expr.node {\n+        ExprBlock(ref block) => fetch_bool_block(block),\n+        ExprLit(ref lit_ptr) => if let LitBool(value) = lit_ptr.node {\n             Some(value) } else { None },\n         _ => None\n     }"}, {"sha": "2d09fcbcca952e4e49bcbfae964756bc0ae998e8", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -4,10 +4,10 @@\n \n use rustc::lint::*;\n use syntax::ast::*;\n-use syntax::codemap::Span;\n+use rustc::middle::ty;\n \n-use types::match_ty_unwrap;\n-use utils::span_lint;\n+use utils::{span_lint, match_type};\n+use utils::{STRING_PATH, VEC_PATH};\n \n declare_lint! {\n     pub PTR_ARG,\n@@ -45,22 +45,19 @@ impl LintPass for PtrArg {\n \n fn check_fn(cx: &Context, decl: &FnDecl) {\n     for arg in &decl.inputs {\n-        match &arg.ty.node {\n-            &TyPtr(ref p) | &TyRptr(_, ref p) =>\n-                check_ptr_subtype(cx, arg.ty.span, &p.ty),\n-            _ => ()\n+        if let Some(pat_ty) = cx.tcx.pat_ty_opt(&*arg.pat) {\n+            if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = pat_ty.sty {\n+                if match_type(cx, ty, &VEC_PATH) {\n+                    span_lint(cx, PTR_ARG, arg.ty.span,\n+                              \"writing `&Vec<_>` instead of `&[_]` involves one more reference \\\n+                               and cannot be used with non-Vec-based slices. Consider changing \\\n+                               the type to `&[...]`\");\n+                } else if match_type(cx, ty, &STRING_PATH) {\n+                    span_lint(cx, PTR_ARG, arg.ty.span,\n+                              \"writing `&String` instead of `&str` involves a new object \\\n+                               where a slice will do. Consider changing the type to `&str`\");\n+                }\n+            }\n         }\n     }\n }\n-\n-fn check_ptr_subtype(cx: &Context, span: Span, ty: &Ty) {\n-    match_ty_unwrap(ty, &[\"Vec\"]).map_or_else(|| match_ty_unwrap(ty,\n-        &[\"String\"]).map_or((), |_| {\n-            span_lint(cx, PTR_ARG, span,\n-                      \"writing `&String` instead of `&str` involves a new object \\\n-                       where a slice will do. Consider changing the type to `&str`\")\n-        }), |_| span_lint(cx, PTR_ARG, span,\n-                          \"writing `&Vec<_>` instead of \\\n-                           `&[_]` involves one more reference and cannot be used with \\\n-                           non-Vec-based slices. Consider changing the type to `&[...]`\"))\n-}"}, {"sha": "d1a0a7e702e4ba0d63e4b40e034a48566f8dee88", "filename": "src/ranges.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -1,8 +1,7 @@\n use rustc::lint::{Context, LintArray, LintPass};\n-use rustc::middle::ty::TypeVariants::TyStruct;\n use syntax::ast::*;\n use syntax::codemap::Spanned;\n-use utils::{match_def_path};\n+use utils::match_type;\n \n declare_lint! {\n     pub RANGE_STEP_BY_ZERO, Warn,\n@@ -34,11 +33,9 @@ impl LintPass for StepByZero {\n fn is_range(cx: &Context, expr: &Expr) -> bool {\n     // No need for walk_ptrs_ty here because step_by moves self, so it\n     // can't be called on a borrowed range.\n-    if let TyStruct(did, _) = cx.tcx.expr_ty(expr).sty {\n-        // Note: RangeTo and RangeFull don't have step_by\n-        match_def_path(cx, did.did, &[\"core\", \"ops\", \"Range\"]) ||\n-        match_def_path(cx, did.did, &[\"core\", \"ops\", \"RangeFrom\"])\n-    } else { false }\n+    let ty = cx.tcx.expr_ty(expr);\n+    // Note: RangeTo and RangeFull don't have step_by\n+    match_type(cx, ty, &[\"core\", \"ops\", \"Range\"]) || match_type(cx, ty, &[\"core\", \"ops\", \"RangeFrom\"])\n }\n \n fn is_lit_zero(expr: &Expr) -> bool {"}, {"sha": "b24ea345244aeedbb9d13281558393cc0afa2b3e", "filename": "src/strings.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -4,12 +4,12 @@\n //! disable the subsumed lint unless it has a higher level\n \n use rustc::lint::*;\n-use rustc::middle::ty::TypeVariants::TyStruct;\n use syntax::ast::*;\n use syntax::codemap::Spanned;\n \n use eq_op::is_exp_equal;\n-use utils::{match_def_path, span_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::{match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::STRING_PATH;\n \n declare_lint! {\n     pub STRING_ADD_ASSIGN,\n@@ -61,20 +61,17 @@ impl LintPass for StringAdd {\n }\n \n fn is_string(cx: &Context, e: &Expr) -> bool {\n-    let ty = walk_ptrs_ty(cx.tcx.expr_ty(e));\n-    if let TyStruct(did, _) = ty.sty {\n-        match_def_path(cx, did.did, &[\"collections\", \"string\", \"String\"])\n-    } else { false }\n+    match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(e)), &STRING_PATH)\n }\n \n fn is_add(cx: &Context, src: &Expr, target: &Expr) -> bool {\n-    match &src.node {\n-        &ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) =>\n+    match src.node {\n+        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) =>\n             is_exp_equal(cx, target, left),\n-        &ExprBlock(ref block) => block.stmts.is_empty() &&\n+        ExprBlock(ref block) => block.stmts.is_empty() &&\n             block.expr.as_ref().map_or(false,\n                 |expr| is_add(cx, &*expr, target)),\n-        &ExprParen(ref expr) => is_add(cx, &*expr, target),\n+        ExprParen(ref expr) => is_add(cx, &*expr, target),\n         _ => false\n     }\n }"}, {"sha": "47ee51e98ef28017eaabe11a0412eb1be18f77f0", "filename": "src/types.rs", "status": "modified", "additions": 152, "deletions": 62, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -2,11 +2,13 @@ use rustc::lint::*;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::ast_util::{is_comparison_binop, binop_to_string};\n-use syntax::ptr::P;\n+use syntax::codemap::Span;\n+use syntax::visit::{FnKind, Visitor, walk_ty};\n use rustc::middle::ty;\n use syntax::codemap::ExpnInfo;\n \n-use utils::{in_macro, snippet, span_lint, span_help_and_lint, in_external_macro};\n+use utils::{in_macro, match_type, snippet, span_lint, span_help_and_lint, in_external_macro};\n+use utils::{LL_PATH, VEC_PATH};\n \n /// Handles all the linting of funky types\n #[allow(missing_copy_implementations)]\n@@ -18,61 +20,26 @@ declare_lint!(pub LINKEDLIST, Warn,\n               \"usage of LinkedList, usually a vector is faster, or a more specialized data \\\n                structure like a RingBuf\");\n \n-/// Matches a type with a provided string, and returns its type parameters if successful\n-pub fn match_ty_unwrap<'a>(ty: &'a Ty, segments: &[&str]) -> Option<&'a [P<Ty>]> {\n-    match ty.node {\n-        TyPath(_, Path {segments: ref seg, ..}) => {\n-            // So ast::Path isn't the full path, just the tokens that were provided.\n-            // I could muck around with the maps and find the full path\n-            // however the more efficient way is to simply reverse the iterators and zip them\n-            // which will compare them in reverse until one of them runs out of segments\n-            if seg.iter().rev().zip(segments.iter().rev()).all(|(a,b)| a.identifier.name == b) {\n-                match seg[..].last() {\n-                    Some(&PathSegment {parameters: AngleBracketedParameters(ref a), ..}) => {\n-                        Some(&a.types[..])\n-                    }\n-                    _ => None\n-                }\n-            } else {\n-                None\n-            }\n-        },\n-        _ => None\n-    }\n-}\n-\n-#[allow(unused_imports)]\n impl LintPass for TypePass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(BOX_VEC, LINKEDLIST)\n     }\n \n-    fn check_ty(&mut self, cx: &Context, ty: &ast::Ty) {\n-        {\n-            // In case stuff gets moved around\n-            use std::boxed::Box;\n-            use std::vec::Vec;\n-        }\n-        match_ty_unwrap(ty, &[\"std\", \"boxed\", \"Box\"]).and_then(|t| t.first())\n-          .and_then(|t| match_ty_unwrap(&**t, &[\"std\", \"vec\", \"Vec\"]))\n-          .map(|_| {\n-            span_help_and_lint(cx, BOX_VEC, ty.span,\n-                              \"you seem to be trying to use `Box<Vec<T>>`. Did you mean to use `Vec<T>`?\",\n-                              \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\");\n-          });\n-        {\n-            // In case stuff gets moved around\n-            use collections::linked_list::LinkedList as DL1;\n-            use std::collections::linked_list::LinkedList as DL2;\n-        }\n-        let dlists = [vec![\"std\",\"collections\",\"linked_list\",\"LinkedList\"],\n-                      vec![\"collections\",\"linked_list\",\"LinkedList\"]];\n-        for path in &dlists {\n-            if match_ty_unwrap(ty, &path[..]).is_some() {\n-                span_help_and_lint(cx, LINKEDLIST, ty.span,\n-                                   \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                                   \"a RingBuf might work\");\n-                return;\n+    fn check_ty(&mut self, cx: &Context, ast_ty: &ast::Ty) {\n+        if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&ast_ty.id) {\n+            if let ty::TyBox(ref inner) = ty.sty {\n+                if match_type(cx, inner, &VEC_PATH) {\n+                    span_help_and_lint(\n+                        cx, BOX_VEC, ast_ty.span,\n+                        \"you seem to be trying to use `Box<Vec<T>>`. Did you mean to use `Vec<T>`?\",\n+                        \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\");\n+                }\n+            }\n+            else if match_type(cx, ty, &LL_PATH) {\n+                span_help_and_lint(\n+                    cx, LINKEDLIST, ast_ty.span,\n+                    \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n+                    \"a RingBuf might work\");\n             }\n         }\n     }\n@@ -151,18 +118,18 @@ declare_lint!(pub CAST_POSSIBLE_WRAP, Allow,\n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n-    let n = match &typ.sty {\n-        &ty::TyInt(i) =>  4 << (i as usize),\n-        &ty::TyUint(u) => 4 << (u as usize),\n+    let n = match typ.sty {\n+        ty::TyInt(i) =>  4 << (i as usize),\n+        ty::TyUint(u) => 4 << (u as usize),\n         _ => 0\n     };\n     // n == 4 is the usize/isize case\n     if n == 4 { ::std::usize::BITS } else { n }\n }\n \n fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n-    match &typ.sty {\n-        &ty::TyInt(ast::TyIs) | &ty::TyUint(ast::TyUs) => true,\n+    match typ.sty {\n+        ty::TyInt(ast::TyIs) | ty::TyUint(ast::TyUs) => true,\n         _ => false\n     }\n }\n@@ -182,9 +149,9 @@ impl LintPass for CastPass {\n                 match (cast_from.is_integral(), cast_to.is_integral()) {\n                     (true, false) => {\n                         let from_nbits = int_ty_to_nbits(cast_from);\n-                        let to_nbits : usize = match &cast_to.sty {\n-                            &ty::TyFloat(ast::TyF32) => 32,\n-                            &ty::TyFloat(ast::TyF64) => 64,\n+                        let to_nbits : usize = match cast_to.sty {\n+                            ty::TyFloat(ast::TyF32) => 32,\n+                            ty::TyFloat(ast::TyF64) => 64,\n                             _ => 0\n                         };\n                         if from_nbits != 0 {\n@@ -206,13 +173,12 @@ impl LintPass for CastPass {\n                             else if from_nbits >= to_nbits {\n                                 span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n                                           &format!(\"casting {0} to {1} causes a loss of precision \\\n-                                          \t\t\t({0} is {2} bits wide, but {1}'s mantissa is only {3} bits wide)\",\n+                                          \t    ({0} is {2} bits wide, but {1}'s mantissa is only {3} bits wide)\",\n                                                    cast_from, cast_to, from_nbits, if to_nbits == 64 {52} else {23} ));\n                             }\n                         }\n                     },\n                     (false, true) => {\n-                        // Nothing to add there as long as UB in involved when the cast overflows\n                         span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n                                   &format!(\"casting {} to {} may truncate the value\", cast_from, cast_to));\n                         if !cast_to.is_signed() {\n@@ -283,3 +249,127 @@ impl LintPass for CastPass {\n         }\n     }\n }\n+\n+declare_lint!(pub TYPE_COMPLEXITY, Warn,\n+              \"usage of very complex types; recommends factoring out parts into `type` definitions\");\n+\n+#[allow(missing_copy_implementations)]\n+pub struct TypeComplexityPass;\n+\n+impl LintPass for TypeComplexityPass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(TYPE_COMPLEXITY)\n+    }\n+\n+    fn check_fn(&mut self, cx: &Context, _: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n+        check_fndecl(cx, decl);\n+    }\n+\n+    fn check_struct_field(&mut self, cx: &Context, field: &StructField) {\n+        check_type(cx, &*field.node.ty);\n+    }\n+\n+    fn check_variant(&mut self, cx: &Context, var: &Variant, _: &Generics) {\n+        // StructVariant is covered by check_struct_field\n+        if let TupleVariantKind(ref args) = var.node.kind {\n+            for arg in args {\n+                check_type(cx, &*arg.ty);\n+            }\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, item: &Item) {\n+        match item.node {\n+            ItemStatic(ref ty, _, _) |\n+            ItemConst(ref ty, _) => check_type(cx, ty),\n+            // functions, enums, structs, impls and traits are covered\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n+        match item.node {\n+            ConstTraitItem(ref ty, _) |\n+            TypeTraitItem(_, Some(ref ty)) => check_type(cx, ty),\n+            MethodTraitItem(MethodSig { ref decl, .. }, None) => check_fndecl(cx, decl),\n+            // methods with default impl are covered by check_fn\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) {\n+        match item.node {\n+            ConstImplItem(ref ty, _) |\n+            TypeImplItem(ref ty) => check_type(cx, ty),\n+            // methods are covered by check_fn\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_local(&mut self, cx: &Context, local: &Local) {\n+        if let Some(ref ty) = local.ty {\n+            check_type(cx, ty);\n+        }\n+    }\n+}\n+\n+fn check_fndecl(cx: &Context, decl: &FnDecl) {\n+    for arg in &decl.inputs {\n+        check_type(cx, &*arg.ty);\n+    }\n+    if let Return(ref ty) = decl.output {\n+        check_type(cx, ty);\n+    }\n+}\n+\n+fn check_type(cx: &Context, ty: &ast::Ty) {\n+    if in_external_macro(cx, ty.span) { return; }\n+    let score = {\n+        let mut visitor = TypeComplexityVisitor { score: 0, nest: 1 };\n+        visitor.visit_ty(ty);\n+        visitor.score\n+    };\n+    // println!(\"{:?} --> {}\", ty, score);\n+    if score > 250 {\n+        span_lint(cx, TYPE_COMPLEXITY, ty.span, &format!(\n+            \"very complex type used. Consider factoring parts into `type` definitions\"));\n+    }\n+}\n+\n+/// Walks a type and assigns a complexity score to it.\n+struct TypeComplexityVisitor {\n+    /// total complexity score of the type\n+    score: u32,\n+    /// current nesting level\n+    nest: u32,\n+}\n+\n+impl<'v> Visitor<'v> for TypeComplexityVisitor {\n+    fn visit_ty(&mut self, ty: &'v ast::Ty) {\n+        let (add_score, sub_nest) = match ty.node {\n+            // _, &x and *x have only small overhead; don't mess with nesting level\n+            TyInfer |\n+            TyPtr(..) |\n+            TyRptr(..) => (1, 0),\n+\n+            // the \"normal\" components of a type: named types, arrays/tuples\n+            TyPath(..) |\n+            TyVec(..) |\n+            TyTup(..) |\n+            TyFixedLengthVec(..) => (10 * self.nest, 1),\n+\n+            // \"Sum\" of trait bounds\n+            TyObjectSum(..) => (20 * self.nest, 0),\n+\n+            // function types and \"for<...>\" bring a lot of overhead\n+            TyBareFn(..) |\n+            TyPolyTraitRef(..) => (50 * self.nest, 1),\n+\n+            _ => (0, 0)\n+        };\n+        self.score += add_score;\n+        self.nest += sub_nest;\n+        walk_ty(self, ty);\n+        self.nest -= sub_nest;\n+    }\n+}"}, {"sha": "4fd36fb91d4174b32f75aee5ae61c2c0edbfbba2", "filename": "src/utils.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -6,6 +6,13 @@ use rustc::ast_map::Node::NodeExpr;\n use rustc::middle::ty;\n use std::borrow::Cow;\n \n+// module DefPaths for certain structs/enums we check for\n+pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n+pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n+pub const VEC_PATH:    [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n+pub const LL_PATH:     [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n+\n /// returns true if the macro that expanded the crate was outside of\n /// the current crate or was a compiler plugin\n pub fn in_macro(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n@@ -37,6 +44,18 @@ pub fn match_def_path(cx: &Context, def_id: DefId, path: &[&str]) -> bool {\n         .zip(path.iter()).all(|(nm, p)| nm == p))\n }\n \n+/// check if type is struct or enum type with given def path\n+pub fn match_type(cx: &Context, ty: ty::Ty, path: &[&str]) -> bool {\n+    match ty.sty {\n+        ty::TyEnum(ref adt, _) | ty::TyStruct(ref adt, _) => {\n+            match_def_path(cx, adt.did, path)\n+        }\n+        _ => {\n+            false\n+        }\n+    }\n+}\n+\n /// match a Path against a slice of segment string literals, e.g.\n /// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {"}, {"sha": "995132ba88c9420961cd2d2cbaa33e8008110dfa", "filename": "tests/compile-fail/complex_types.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/tests%2Fcompile-fail%2Fcomplex_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/tests%2Fcompile-fail%2Fcomplex_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcomplex_types.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -0,0 +1,44 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![deny(clippy)]\n+#![allow(unused)]\n+#![feature(associated_consts, associated_type_defaults)]\n+\n+type Alias = Vec<Vec<Box<(u32, u32, u32, u32)>>>; // no warning here\n+\n+const CST: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0)))); //~ERROR very complex type\n+static ST: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0)))); //~ERROR very complex type\n+\n+struct S {\n+    f: Vec<Vec<Box<(u32, u32, u32, u32)>>>, //~ERROR very complex type\n+}\n+\n+struct TS(Vec<Vec<Box<(u32, u32, u32, u32)>>>); //~ERROR very complex type\n+\n+enum E {\n+    V1(Vec<Vec<Box<(u32, u32, u32, u32)>>>), //~ERROR very complex type\n+    V2 { f: Vec<Vec<Box<(u32, u32, u32, u32)>>> }, //~ERROR very complex type\n+}\n+\n+impl S {\n+    const A: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0)))); //~ERROR very complex type\n+    fn impl_method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>) { } //~ERROR very complex type\n+}\n+\n+trait T {\n+    const A: Vec<Vec<Box<(u32, u32, u32, u32)>>>; //~ERROR very complex type\n+    type B = Vec<Vec<Box<(u32, u32, u32, u32)>>>; //~ERROR very complex type\n+    fn method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>); //~ERROR very complex type\n+    fn def_method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>) { } //~ERROR very complex type\n+}\n+\n+fn test1() -> Vec<Vec<Box<(u32, u32, u32, u32)>>> { vec![] } //~ERROR very complex type\n+\n+fn test2(_x: Vec<Vec<Box<(u32, u32, u32, u32)>>>) { } //~ERROR very complex type\n+\n+fn test3() {\n+    let _y: Vec<Vec<Box<(u32, u32, u32, u32)>>> = vec![]; //~ERROR very complex type\n+}\n+\n+fn main() {\n+}"}, {"sha": "a800c045a502a8e6843792e30fab3b3d4b3bca73", "filename": "tests/compile-fail/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/tests%2Fcompile-fail%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/tests%2Fcompile-fail%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdlist.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -12,4 +12,4 @@ pub fn test(foo: LinkedList<u8>) {  //~ ERROR I see you're using a LinkedList!\n \n fn main(){\n     test(LinkedList::new());\n-}\n\\ No newline at end of file\n+}"}, {"sha": "3cc540992c99c5629561f4197fc072355ddb52e3", "filename": "tests/compile-fail/matches.rs", "status": "renamed", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/tests%2Fcompile-fail%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/tests%2Fcompile-fail%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatches.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -2,8 +2,9 @@\n \n #![plugin(clippy)]\n #![deny(clippy)]\n+#![allow(unused)]\n \n-fn main(){\n+fn single_match(){\n     let x = Some(1u8);\n     match x {  //~ ERROR you seem to be trying to use match\n                //~^ HELP try\n@@ -36,3 +37,29 @@ fn main(){\n         _ => println!(\"nope\"),\n     }\n }\n+\n+fn ref_pats() {\n+    let ref v = Some(0);\n+    match v {  //~ERROR instead of prefixing all patterns with `&`\n+        &Some(v) => println!(\"{:?}\", v),\n+        &None => println!(\"none\"),\n+    }\n+    match v {  // this doesn't trigger, we have a different pattern\n+        &Some(v) => println!(\"some\"),\n+        other => println!(\"other\"),\n+    }\n+    let ref tup = (1, 2);\n+    match tup {  //~ERROR instead of prefixing all patterns with `&`\n+        &(v, 1) => println!(\"{}\", v),\n+        _ => println!(\"none\"),\n+    }\n+    // special case: using & both in expr and pats\n+    let w = Some(0);\n+    match &w {  //~ERROR you don't need to add `&` to both\n+        &Some(v) => println!(\"{:?}\", v),\n+        &None => println!(\"none\"),\n+    }\n+}\n+\n+fn main() {\n+}", "previous_filename": "tests/compile-fail/match_if_let.rs"}, {"sha": "d0615be492b01e4d49d5ff0e8524c5cde46566e0", "filename": "tests/compile-fail/ptr_arg.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e80f2470b710838aefd1020c09562e275bdcb28e/tests%2Fcompile-fail%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80f2470b710838aefd1020c09562e275bdcb28e/tests%2Fcompile-fail%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_arg.rs?ref=e80f2470b710838aefd1020c09562e275bdcb28e", "patch": "@@ -1,20 +1,23 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n+#![allow(unused)]\n+#![deny(ptr_arg)]\n \n-#[deny(ptr_arg)]\n-#[allow(unused)]\n fn do_vec(x: &Vec<i64>) { //~ERROR writing `&Vec<_>` instead of `&[_]`\n     //Nothing here\n }\n \n-#[deny(ptr_arg)]\n-#[allow(unused)]\n+fn do_vec_mut(x: &mut Vec<i64>) { // no error here\n+    //Nothing here\n+}\n+\n fn do_str(x: &String) { //~ERROR writing `&String` instead of `&str`\n     //Nothing here either\n }\n \n+fn do_str_mut(x: &mut String) { // no error here\n+    //Nothing here either\n+}\n+\n fn main() {\n-    let x = vec![1i64, 2, 3];\n-    do_vec(&x);\n-    do_str(&\"hello\".to_owned());\n }"}]}