{"sha": "2246d56e7149402f18041d05e3c0ecf598671904", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNDZkNTZlNzE0OTQwMmYxODA0MWQwNWUzYzBlY2Y1OTg2NzE5MDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-19T16:12:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-19T16:12:03Z"}, "message": "auto merge of #8619 : pnkfelix/rust/fsk-visitor-vpar-defaults-step3, r=nmatsakis\n\nFollow up to #8539 (step 2 of 5).\r\n\r\n(See  #8527, which was step 1 of 5, for the full outline.)\r\n\r\nPart of #7081.", "tree": {"sha": "24a672ea70e8cfced5ea7c74b5b6db5fff7b9a47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24a672ea70e8cfced5ea7c74b5b6db5fff7b9a47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2246d56e7149402f18041d05e3c0ecf598671904", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2246d56e7149402f18041d05e3c0ecf598671904", "html_url": "https://github.com/rust-lang/rust/commit/2246d56e7149402f18041d05e3c0ecf598671904", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2246d56e7149402f18041d05e3c0ecf598671904/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d597f54fc2b864bcdf110fecb120758dc2feb5f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d597f54fc2b864bcdf110fecb120758dc2feb5f6", "html_url": "https://github.com/rust-lang/rust/commit/d597f54fc2b864bcdf110fecb120758dc2feb5f6"}, {"sha": "14830209c8278a7372ab91181ebb8d62879c4a0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/14830209c8278a7372ab91181ebb8d62879c4a0c", "html_url": "https://github.com/rust-lang/rust/commit/14830209c8278a7372ab91181ebb8d62879c4a0c"}], "stats": {"total": 721, "additions": 405, "deletions": 316}, "files": [{"sha": "edb805cfc40aeb37e3fc08992f25345028adad95", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 68, "deletions": 52, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=2246d56e7149402f18041d05e3c0ecf598671904", "patch": "@@ -119,9 +119,8 @@ use syntax::ast::*;\n use syntax::codemap::span;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust::{expr_to_str, block_to_str};\n-use syntax::oldvisit::{fk_anon, fk_fn_block, fk_item_fn, fk_method};\n-use syntax::oldvisit::{vt};\n-use syntax::{oldvisit, ast_util};\n+use syntax::{visit, ast_util};\n+use syntax::visit::{Visitor,fn_kind};\n \n #[deriving(Eq)]\n struct Variable(uint);\n@@ -152,22 +151,27 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n     }\n }\n \n+struct LivenessVisitor;\n+\n+impl Visitor<@mut IrMaps> for LivenessVisitor {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:span, n:NodeId, e:@mut IrMaps) {\n+        visit_fn(self, fk, fd, b, s, n, e);\n+    }\n+    fn visit_local(&mut self, l:@Local, e:@mut IrMaps) { visit_local(self, l, e); }\n+    fn visit_expr(&mut self, ex:@expr, e:@mut IrMaps) { visit_expr(self, ex, e); }\n+    fn visit_arm(&mut self, a:&arm, e:@mut IrMaps) { visit_arm(self, a, e); }\n+}\n+\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n                    capture_map: moves::CaptureMap,\n                    crate: &Crate) {\n-    let visitor = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_fn: visit_fn,\n-        visit_local: visit_local,\n-        visit_expr: visit_expr,\n-        visit_arm: visit_arm,\n-        .. *oldvisit::default_visitor()\n-    });\n+    let mut visitor = LivenessVisitor;\n \n     let initial_maps = @mut IrMaps(tcx,\n                                    method_map,\n                                    capture_map);\n-    oldvisit::visit_crate(crate, (initial_maps, visitor));\n+    visit::walk_crate(&mut visitor, crate, initial_maps);\n     tcx.sess.abort_if_errors();\n }\n \n@@ -341,13 +345,30 @@ impl IrMaps {\n     }\n }\n \n-fn visit_fn(fk: &oldvisit::fn_kind,\n+struct ErrorCheckVisitor;\n+\n+impl Visitor<@Liveness> for ErrorCheckVisitor {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:span, n:NodeId, e:@Liveness) {\n+        check_fn(self, fk, fd, b, s, n, e);\n+    }\n+    fn visit_local(&mut self, l:@Local, e:@Liveness) {\n+        check_local(self, l, e);\n+    }\n+    fn visit_expr(&mut self, ex:@expr, e:@Liveness) {\n+        check_expr(self, ex, e);\n+    }\n+    fn visit_arm(&mut self, a:&arm, e:@Liveness) {\n+        check_arm(self, a, e);\n+    }\n+}\n+\n+fn visit_fn(v: &mut LivenessVisitor,\n+            fk: &visit::fn_kind,\n             decl: &fn_decl,\n             body: &Block,\n             sp: span,\n             id: NodeId,\n-            (this, v): (@mut IrMaps,\n-                        vt<@mut IrMaps>)) {\n+            this: @mut IrMaps) {\n     debug!(\"visit_fn: id=%d\", id);\n     let _i = ::util::common::indenter();\n \n@@ -371,7 +392,7 @@ fn visit_fn(fk: &oldvisit::fn_kind,\n \n     // Add `this`, whether explicit or implicit.\n     match *fk {\n-        fk_method(_, _, method) => {\n+        visit::fk_method(_, _, method) => {\n             match method.explicit_self.node {\n                 sty_value | sty_region(*) | sty_box(_) | sty_uniq => {\n                     fn_maps.add_variable(Arg(method.self_id,\n@@ -380,12 +401,12 @@ fn visit_fn(fk: &oldvisit::fn_kind,\n                 sty_static => {}\n             }\n         }\n-        fk_item_fn(*) | fk_anon(*) | fk_fn_block(*) => {}\n+        visit::fk_item_fn(*) | visit::fk_anon(*) | visit::fk_fn_block(*) => {}\n     }\n \n     // gather up the various local variables, significant expressions,\n     // and so forth:\n-    oldvisit::visit_fn(fk, decl, body, sp, id, (fn_maps, v));\n+    visit::walk_fn(v, fk, decl, body, sp, id, fn_maps);\n \n     // Special nodes and variables:\n     // - exit_ln represents the end of the fn, either by return or fail\n@@ -402,19 +423,13 @@ fn visit_fn(fk: &oldvisit::fn_kind,\n     let entry_ln = (*lsets).compute(decl, body);\n \n     // check for various error conditions\n-    let check_vt = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_fn: check_fn,\n-        visit_local: check_local,\n-        visit_expr: check_expr,\n-        visit_arm: check_arm,\n-        .. *oldvisit::default_visitor()\n-    });\n-    (check_vt.visit_block)(body, (lsets, check_vt));\n+    let mut check_vt = ErrorCheckVisitor;\n+    check_vt.visit_block(body, lsets);\n     lsets.check_ret(id, sp, fk, entry_ln);\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(local: @Local, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n+fn visit_local(v: &mut LivenessVisitor, local: @Local, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n     do pat_util::pat_bindings(def_map, local.pat) |_bm, p_id, sp, path| {\n         debug!(\"adding local variable %d\", p_id);\n@@ -431,10 +446,10 @@ fn visit_local(local: @Local, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n           kind: kind\n         }));\n     }\n-    oldvisit::visit_local(local, (this, vt));\n+    visit::walk_local(v, local, this);\n }\n \n-fn visit_arm(arm: &arm, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n+fn visit_arm(v: &mut LivenessVisitor, arm: &arm, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n     for pat in arm.pats.iter() {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n@@ -450,10 +465,10 @@ fn visit_arm(arm: &arm, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n             }));\n         }\n     }\n-    oldvisit::visit_arm(arm, (this, vt));\n+    visit::walk_arm(v, arm, this);\n }\n \n-fn visit_expr(expr: @expr, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n+fn visit_expr(v: &mut LivenessVisitor, expr: @expr, this: @mut IrMaps) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       expr_path(_) | expr_self => {\n@@ -462,7 +477,7 @@ fn visit_expr(expr: @expr, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n         if moves::moved_variable_node_id_from_def(def).is_some() {\n             this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(v, expr, this);\n       }\n       expr_fn_block(*) => {\n         // Interesting control flow (for loops can contain labeled\n@@ -495,18 +510,18 @@ fn visit_expr(expr: @expr, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n         }\n         this.set_captures(expr.id, call_caps);\n \n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(v, expr, this);\n       }\n \n       // live nodes required for interesting control flow:\n       expr_if(*) | expr_match(*) | expr_while(*) | expr_loop(*) => {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(v, expr, this);\n       }\n       expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\"),\n       expr_binary(_, op, _, _) if ast_util::lazy_binop(op) => {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(v, expr, this);\n       }\n \n       // otherwise, live nodes are not required:\n@@ -518,7 +533,7 @@ fn visit_expr(expr: @expr, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n       expr_assign(*) | expr_assign_op(*) | expr_mac(*) |\n       expr_struct(*) | expr_repeat(*) | expr_paren(*) |\n       expr_inline_asm(*) => {\n-          oldvisit::visit_expr(expr, (this, vt));\n+          visit::walk_expr(v, expr, this);\n       }\n     }\n }\n@@ -1408,7 +1423,7 @@ impl Liveness {\n // _______________________________________________________________________\n // Checking for error conditions\n \n-fn check_local(local: @Local, (this, vt): (@Liveness, vt<@Liveness>)) {\n+fn check_local(vt: &mut ErrorCheckVisitor, local: @Local, this: @Liveness) {\n     match local.init {\n       Some(_) => {\n         this.warn_about_unused_or_dead_vars_in_pat(local.pat);\n@@ -1434,34 +1449,34 @@ fn check_local(local: @Local, (this, vt): (@Liveness, vt<@Liveness>)) {\n       }\n     }\n \n-    oldvisit::visit_local(local, (this, vt));\n+    visit::walk_local(vt, local, this);\n }\n \n-fn check_arm(arm: &arm, (this, vt): (@Liveness, vt<@Liveness>)) {\n+fn check_arm(vt: &mut ErrorCheckVisitor, arm: &arm, this: @Liveness) {\n     do this.arm_pats_bindings(arm.pats) |ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     }\n-    oldvisit::visit_arm(arm, (this, vt));\n+    visit::walk_arm(vt, arm, this);\n }\n \n-fn check_expr(expr: @expr, (this, vt): (@Liveness, vt<@Liveness>)) {\n+fn check_expr(vt: &mut ErrorCheckVisitor, expr: @expr, this: @Liveness) {\n     match expr.node {\n       expr_assign(l, r) => {\n         this.check_lvalue(l, vt);\n-        (vt.visit_expr)(r, (this, vt));\n+        vt.visit_expr(r, this);\n \n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(vt, expr, this);\n       }\n \n       expr_assign_op(_, _, l, _) => {\n         this.check_lvalue(l, vt);\n \n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(vt, expr, this);\n       }\n \n       expr_inline_asm(ref ia) => {\n         for &(_, input) in ia.inputs.iter() {\n-          (vt.visit_expr)(input, (this, vt));\n+          vt.visit_expr(input, this);\n         }\n \n         // Output operands must be lvalues\n@@ -1472,10 +1487,10 @@ fn check_expr(expr: @expr, (this, vt): (@Liveness, vt<@Liveness>)) {\n             }\n             _ => {}\n           }\n-          (vt.visit_expr)(out, (this, vt));\n+          vt.visit_expr(out, this);\n         }\n \n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(vt, expr, this);\n       }\n \n       // no correctness conditions related to liveness\n@@ -1487,18 +1502,19 @@ fn check_expr(expr: @expr, (this, vt): (@Liveness, vt<@Liveness>)) {\n       expr_again(*) | expr_lit(_) | expr_block(*) |\n       expr_mac(*) | expr_addr_of(*) | expr_struct(*) | expr_repeat(*) |\n       expr_paren(*) | expr_fn_block(*) | expr_path(*) | expr_self(*) => {\n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(vt, expr, this);\n       }\n       expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\")\n     }\n }\n \n-fn check_fn(_fk: &oldvisit::fn_kind,\n+fn check_fn(_v: &mut ErrorCheckVisitor,\n+            _fk: &visit::fn_kind,\n             _decl: &fn_decl,\n             _body: &Block,\n             _sp: span,\n             _id: NodeId,\n-            (_self, _v): (@Liveness, vt<@Liveness>)) {\n+            _self: @Liveness) {\n     // do not check contents of nested fns\n }\n \n@@ -1513,7 +1529,7 @@ impl Liveness {\n     pub fn check_ret(&self,\n                      id: NodeId,\n                      sp: span,\n-                     _fk: &oldvisit::fn_kind,\n+                     _fk: &visit::fn_kind,\n                      entry_ln: LiveNode) {\n         if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             // if no_ret_var is live, then we fall off the end of the\n@@ -1533,7 +1549,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn check_lvalue(@self, expr: @expr, vt: vt<@Liveness>) {\n+    pub fn check_lvalue(@self, expr: @expr, vt: &mut ErrorCheckVisitor) {\n         match expr.node {\n           expr_path(_) => {\n             match self.tcx.def_map.get_copy(&expr.id) {\n@@ -1562,7 +1578,7 @@ impl Liveness {\n           _ => {\n             // For other kinds of lvalues, no checks are required,\n             // and any embedded expressions are actually rvalues\n-            oldvisit::visit_expr(expr, (self, vt));\n+            visit::walk_expr(vt, expr, self);\n           }\n        }\n     }"}, {"sha": "9654bf3fc01fbeacf60076c7fc0e12267b5026f6", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 123, "deletions": 97, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=2246d56e7149402f18041d05e3c0ecf598671904", "patch": "@@ -27,17 +27,14 @@ use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n use syntax::ast_util::{Privacy, Public, Private};\n use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n use syntax::attr;\n-use syntax::oldvisit::{mk_simple_visitor, default_simple_visitor};\n-use syntax::oldvisit::{default_visitor, mk_vt, Visitor, visit_block};\n-use syntax::oldvisit::{visit_crate, visit_expr, visit_expr_opt};\n-use syntax::oldvisit::{visit_foreign_item, visit_item};\n-use syntax::oldvisit::{visit_mod, visit_ty, vt, SimpleVisitor};\n use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust::path_to_str;\n use syntax::codemap::{span, dummy_sp, BytePos};\n use syntax::opt_vec::OptVec;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n \n use std::str;\n use std::uint;\n@@ -131,7 +128,30 @@ pub enum SelfBinding {\n     HasSelfBinding(NodeId, bool /* is implicit */)\n }\n \n-pub type ResolveVisitor = vt<()>;\n+struct ResolveVisitor {\n+    resolver: @mut Resolver,\n+}\n+\n+impl Visitor<()> for ResolveVisitor {\n+    fn visit_item(&mut self, item:@item, _:()) {\n+        self.resolver.resolve_item(item, self);\n+    }\n+    fn visit_arm(&mut self, arm:&arm, _:()) {\n+        self.resolver.resolve_arm(arm, self);\n+    }\n+    fn visit_block(&mut self, block:&Block, _:()) {\n+        self.resolver.resolve_block(block, self);\n+    }\n+    fn visit_expr(&mut self, expr:@expr, _:()) {\n+        self.resolver.resolve_expr(expr, self);\n+    }\n+    fn visit_local(&mut self, local:@Local, _:()) {\n+        self.resolver.resolve_local(local, self);\n+    }\n+    fn visit_ty(&mut self, ty:&Ty, _:()) {\n+        self.resolver.resolve_type(ty, self);\n+    }\n+}\n \n /// Contains data for specific types of import directives.\n pub enum ImportDirectiveSubclass {\n@@ -871,6 +891,45 @@ pub struct Resolver {\n     used_imports: HashSet<NodeId>,\n }\n \n+struct BuildReducedGraphVisitor {\n+    resolver: @mut Resolver,\n+}\n+\n+impl Visitor<ReducedGraphParent> for BuildReducedGraphVisitor {\n+\n+    fn visit_item(&mut self, item:@item, context:ReducedGraphParent) {\n+        self.resolver.build_reduced_graph_for_item(item, (context, self));\n+    }\n+\n+    fn visit_foreign_item(&mut self, foreign_item:@foreign_item, context:ReducedGraphParent) {\n+        self.resolver.build_reduced_graph_for_foreign_item(foreign_item,\n+                                                             (context,\n+                                                              self));\n+    }\n+\n+    fn visit_view_item(&mut self, view_item:&view_item, context:ReducedGraphParent) {\n+        self.resolver.build_reduced_graph_for_view_item(view_item,\n+                                                          (context,\n+                                                           self));\n+    }\n+\n+    fn visit_block(&mut self, block:&Block, context:ReducedGraphParent) {\n+        self.resolver.build_reduced_graph_for_block(block,\n+                                                      (context,\n+                                                       self));\n+    }\n+\n+}\n+\n+struct UnusedImportCheckVisitor { resolver: @mut Resolver }\n+\n+impl Visitor<()> for UnusedImportCheckVisitor {\n+    fn visit_view_item(&mut self, vi:&view_item, _:()) {\n+        self.resolver.check_for_item_unused_imports(vi);\n+        visit::walk_view_item(self, vi, ());\n+    }\n+}\n+\n impl Resolver {\n     /// The main name resolution procedure.\n     pub fn resolve(@mut self) {\n@@ -900,27 +959,9 @@ impl Resolver {\n     pub fn build_reduced_graph(@mut self) {\n         let initial_parent =\n             ModuleReducedGraphParent(self.graph_root.get_module());\n-        visit_crate(self.crate, (initial_parent, mk_vt(@Visitor {\n-            visit_item: |item, (context, visitor)|\n-                self.build_reduced_graph_for_item(item, (context, visitor)),\n-\n-            visit_foreign_item: |foreign_item, (context, visitor)|\n-                self.build_reduced_graph_for_foreign_item(foreign_item,\n-                                                             (context,\n-                                                              visitor)),\n-\n-            visit_view_item: |view_item, (context, visitor)|\n-                self.build_reduced_graph_for_view_item(view_item,\n-                                                          (context,\n-                                                           visitor)),\n-\n-            visit_block: |block, (context, visitor)|\n-                self.build_reduced_graph_for_block(block,\n-                                                      (context,\n-                                                       visitor)),\n \n-            .. *default_visitor()\n-        })));\n+        let mut visitor = BuildReducedGraphVisitor { resolver: self, };\n+        visit::walk_crate(&mut visitor, self.crate, initial_parent);\n     }\n \n     /// Returns the current module tracked by the reduced graph parent.\n@@ -1094,7 +1135,7 @@ impl Resolver {\n     pub fn build_reduced_graph_for_item(@mut self,\n                                         item: @item,\n                                         (parent, visitor): (ReducedGraphParent,\n-                                                            vt<ReducedGraphParent>)) {\n+                                                            &mut BuildReducedGraphVisitor)) {\n         let ident = item.ident;\n         let sp = item.span;\n         let privacy = visibility_to_privacy(item.vis);\n@@ -1115,7 +1156,7 @@ impl Resolver {\n                 let new_parent =\n                     ModuleReducedGraphParent(name_bindings.get_module());\n \n-                visit_mod(module_, sp, item.id, (new_parent, visitor));\n+                visit::walk_mod(visitor, module_, new_parent);\n             }\n \n             item_foreign_mod(ref fm) => {\n@@ -1142,7 +1183,7 @@ impl Resolver {\n                     anonymous => parent\n                 };\n \n-                visit_item(item, (new_parent, visitor));\n+                visit::walk_item(visitor, item, new_parent);\n             }\n \n             // These items live in the value namespace.\n@@ -1160,7 +1201,7 @@ impl Resolver {\n \n                 let def = def_fn(local_def(item.id), purity);\n                 name_bindings.define_value(privacy, def, sp);\n-                visit_item(item, (new_parent, visitor));\n+                visit::walk_item(visitor, item, new_parent);\n             }\n \n             // These items live in the type namespace.\n@@ -1186,7 +1227,7 @@ impl Resolver {\n                         // inherited => privacy of the enum item\n                         variant_visibility_to_privacy(variant.node.vis,\n                                                       privacy == Public),\n-                        (new_parent, visitor));\n+                        new_parent, visitor);\n                 }\n             }\n \n@@ -1213,7 +1254,7 @@ impl Resolver {\n                 // Record the def ID of this struct.\n                 self.structs.insert(local_def(item.id));\n \n-                visit_item(item, (new_parent, visitor));\n+                visit::walk_item(visitor, item, new_parent);\n             }\n \n             item_impl(_, None, ref ty, ref methods) => {\n@@ -1293,11 +1334,11 @@ impl Resolver {\n                     _ => {}\n                 }\n \n-                visit_item(item, (parent, visitor));\n+                visit::walk_item(visitor, item, parent);\n             }\n \n             item_impl(_, Some(_), _, _) => {\n-                visit_item(item, (parent, visitor));\n+                visit::walk_item(visitor, item, parent);\n             }\n \n             item_trait(_, _, ref methods) => {\n@@ -1364,7 +1405,7 @@ impl Resolver {\n                 }\n \n                 name_bindings.define_type(privacy, def_trait(def_id), sp);\n-                visit_item(item, (new_parent, visitor));\n+                visit::walk_item(visitor, item, new_parent);\n             }\n \n             item_mac(*) => {\n@@ -1379,9 +1420,8 @@ impl Resolver {\n                                            variant: &variant,\n                                            item_id: def_id,\n                                            parent_privacy: Privacy,\n-                                           (parent, _visitor):\n-                                           (ReducedGraphParent,\n-                                            vt<ReducedGraphParent>)) {\n+                                           parent: ReducedGraphParent,\n+                                           _: &mut BuildReducedGraphVisitor) {\n         let ident = variant.node.name;\n \n         let privacy =\n@@ -1418,7 +1458,7 @@ impl Resolver {\n                                              view_item: &view_item,\n                                              (parent, _):\n                                              (ReducedGraphParent,\n-                                              vt<ReducedGraphParent>)) {\n+                                              &mut BuildReducedGraphVisitor)) {\n         let privacy = visibility_to_privacy(view_item.vis);\n         match view_item.node {\n             view_item_use(ref view_paths) => {\n@@ -1517,7 +1557,7 @@ impl Resolver {\n                                                 foreign_item: @foreign_item,\n                                                 (parent, visitor):\n                                                 (ReducedGraphParent,\n-                                                 vt<ReducedGraphParent>)) {\n+                                                 &mut BuildReducedGraphVisitor)) {\n         let name = foreign_item.ident;\n         let (name_bindings, new_parent) =\n             self.add_child(name, parent, ForbidDuplicateValues,\n@@ -1532,14 +1572,14 @@ impl Resolver {\n                     HasTypeParameters(\n                         generics, foreign_item.id, 0, NormalRibKind))\n                 {\n-                    visit_foreign_item(foreign_item, (new_parent, visitor));\n+                    visit::walk_foreign_item(visitor, foreign_item, new_parent);\n                 }\n             }\n             foreign_item_static(_, m) => {\n                 let def = def_static(local_def(foreign_item.id), m);\n                 name_bindings.define_value(Public, def, foreign_item.span);\n \n-                visit_foreign_item(foreign_item, (new_parent, visitor));\n+                visit::walk_foreign_item(visitor, foreign_item, new_parent);\n             }\n         }\n     }\n@@ -1548,7 +1588,7 @@ impl Resolver {\n                                          block: &Block,\n                                          (parent, visitor):\n                                          (ReducedGraphParent,\n-                                          vt<ReducedGraphParent>)) {\n+                                          &mut BuildReducedGraphVisitor)) {\n         let new_parent;\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.id;\n@@ -1568,7 +1608,7 @@ impl Resolver {\n             new_parent = parent;\n         }\n \n-        visit_block(block, (new_parent, visitor));\n+        visit::walk_block(visitor, block, new_parent);\n     }\n \n     pub fn handle_external_def(@mut self,\n@@ -3454,24 +3494,11 @@ impl Resolver {\n     pub fn resolve_crate(@mut self) {\n         debug!(\"(resolving crate) starting\");\n \n-        visit_crate(self.crate, ((), mk_vt(@Visitor {\n-            visit_item: |item, (_context, visitor)|\n-                self.resolve_item(item, visitor),\n-            visit_arm: |arm, (_context, visitor)|\n-                self.resolve_arm(arm, visitor),\n-            visit_block: |block, (_context, visitor)|\n-                self.resolve_block(block, visitor),\n-            visit_expr: |expr, (_context, visitor)|\n-                self.resolve_expr(expr, visitor),\n-            visit_local: |local, (_context, visitor)|\n-                self.resolve_local(local, visitor),\n-            visit_ty: |ty, (_context, visitor)|\n-                self.resolve_type(ty, visitor),\n-            .. *default_visitor()\n-        })));\n+        let mut visitor = ResolveVisitor{ resolver: self };\n+        visit::walk_crate(&mut visitor, self.crate, ());\n     }\n \n-    pub fn resolve_item(@mut self, item: @item, visitor: ResolveVisitor) {\n+    pub fn resolve_item(@mut self, item: @item, visitor: &mut ResolveVisitor) {\n         debug!(\"(resolving item) resolving %s\",\n                self.session.str_of(item.ident));\n \n@@ -3503,7 +3530,7 @@ impl Resolver {\n                 do self.with_type_parameter_rib(\n                     HasTypeParameters(\n                         generics, item.id, 0, NormalRibKind)) {\n-                    visit_item(item, ((), visitor));\n+                    visit::walk_item(visitor, item, ());\n                 }\n             }\n \n@@ -3513,7 +3540,7 @@ impl Resolver {\n                                            NormalRibKind))\n                         || {\n \n-                    visit_item(item, ((), visitor));\n+                    visit::walk_item(visitor, item, ());\n                 }\n             }\n \n@@ -3613,12 +3640,14 @@ impl Resolver {\n                                     HasTypeParameters(\n                                         generics, foreign_item.id, 0,\n                                         NormalRibKind),\n-                                    || visit_foreign_item(*foreign_item,\n-                                                          ((), visitor)));\n+                                    || visit::walk_foreign_item(visitor,\n+                                                                *foreign_item,\n+                                                                ()));\n                             }\n                             foreign_item_static(*) => {\n-                                visit_foreign_item(*foreign_item,\n-                                                   ((), visitor));\n+                                visit::walk_foreign_item(visitor,\n+                                                         *foreign_item,\n+                                                         ());\n                             }\n                         }\n                     }\n@@ -3640,7 +3669,7 @@ impl Resolver {\n \n             item_static(*) => {\n                 self.with_constant_rib(|| {\n-                    visit_item(item, ((), visitor));\n+                    visit::walk_item(visitor, item, ());\n                 });\n             }\n \n@@ -3713,7 +3742,7 @@ impl Resolver {\n                             type_parameters: TypeParameters,\n                             block: &Block,\n                             self_binding: SelfBinding,\n-                            visitor: ResolveVisitor) {\n+                            visitor: &mut ResolveVisitor) {\n         // Create a value rib for the function.\n         let function_value_rib = @Rib(rib_kind);\n         self.value_ribs.push(function_value_rib);\n@@ -3784,7 +3813,7 @@ impl Resolver {\n \n     pub fn resolve_type_parameters(@mut self,\n                                    type_parameters: &OptVec<TyParam>,\n-                                   visitor: ResolveVisitor) {\n+                                   visitor: &mut ResolveVisitor) {\n         for type_parameter in type_parameters.iter() {\n             for bound in type_parameter.bounds.iter() {\n                 self.resolve_type_parameter_bound(type_parameter.id, bound, visitor);\n@@ -3795,7 +3824,7 @@ impl Resolver {\n     pub fn resolve_type_parameter_bound(@mut self,\n                                         id: NodeId,\n                                         type_parameter_bound: &TyParamBound,\n-                                        visitor: ResolveVisitor) {\n+                                        visitor: &mut ResolveVisitor) {\n         match *type_parameter_bound {\n             TraitTyParamBound(ref tref) => {\n                 self.resolve_trait_reference(id, tref, visitor, TraitBoundingTypeParameter)\n@@ -3807,7 +3836,7 @@ impl Resolver {\n     pub fn resolve_trait_reference(@mut self,\n                                    id: NodeId,\n                                    trait_reference: &trait_ref,\n-                                   visitor: ResolveVisitor,\n+                                   visitor: &mut ResolveVisitor,\n                                    reference_type: TraitReferenceType) {\n         match self.resolve_path(id, &trait_reference.path, TypeNS, true, visitor) {\n             None => {\n@@ -3833,7 +3862,7 @@ impl Resolver {\n                           id: NodeId,\n                           generics: &Generics,\n                           fields: &[@struct_field],\n-                          visitor: ResolveVisitor) {\n+                          visitor: &mut ResolveVisitor) {\n         let mut ident_map = HashMap::new::<ast::ident, @struct_field>();\n         for &field in fields.iter() {\n             match field.node.kind {\n@@ -3876,7 +3905,7 @@ impl Resolver {\n                           rib_kind: RibKind,\n                           method: @method,\n                           outer_type_parameter_count: uint,\n-                          visitor: ResolveVisitor) {\n+                          visitor: &mut ResolveVisitor) {\n         let method_generics = &method.generics;\n         let type_parameters =\n             HasTypeParameters(method_generics,\n@@ -3903,7 +3932,7 @@ impl Resolver {\n                                   opt_trait_reference: &Option<trait_ref>,\n                                   self_type: &Ty,\n                                   methods: &[@method],\n-                                  visitor: ResolveVisitor) {\n+                                  visitor: &mut ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n         let outer_type_parameter_count = generics.ty_params.len();\n         do self.with_type_parameter_rib(HasTypeParameters\n@@ -3976,16 +4005,16 @@ impl Resolver {\n \n     pub fn resolve_module(@mut self,\n                           module_: &_mod,\n-                          span: span,\n+                          _span: span,\n                           _name: ident,\n                           id: NodeId,\n-                          visitor: ResolveVisitor) {\n+                          visitor: &mut ResolveVisitor) {\n         // Write the implementations in scope into the module metadata.\n         debug!(\"(resolving module) resolving module ID %d\", id);\n-        visit_mod(module_, span, id, ((), visitor));\n+        visit::walk_mod(visitor, module_, ());\n     }\n \n-    pub fn resolve_local(@mut self, local: @Local, visitor: ResolveVisitor) {\n+    pub fn resolve_local(@mut self, local: @Local, visitor: &mut ResolveVisitor) {\n         let mutability = if local.is_mutbl {Mutable} else {Immutable};\n \n         // Resolve the type.\n@@ -4056,7 +4085,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_arm(@mut self, arm: &arm, visitor: ResolveVisitor) {\n+    pub fn resolve_arm(@mut self, arm: &arm, visitor: &mut ResolveVisitor) {\n         self.value_ribs.push(@Rib(NormalRibKind));\n \n         let bindings_list = @mut HashMap::new();\n@@ -4069,13 +4098,13 @@ impl Resolver {\n         // pat_idents are variants\n         self.check_consistent_bindings(arm);\n \n-        visit_expr_opt(arm.guard, ((), visitor));\n+        visit::walk_expr_opt(visitor, arm.guard, ());\n         self.resolve_block(&arm.body, visitor);\n \n         self.value_ribs.pop();\n     }\n \n-    pub fn resolve_block(@mut self, block: &Block, visitor: ResolveVisitor) {\n+    pub fn resolve_block(@mut self, block: &Block, visitor: &mut ResolveVisitor) {\n         debug!(\"(resolving block) entering block\");\n         self.value_ribs.push(@Rib(NormalRibKind));\n \n@@ -4091,7 +4120,7 @@ impl Resolver {\n         }\n \n         // Descend into the block.\n-        visit_block(block, ((), visitor));\n+        visit::walk_block(visitor, block, ());\n \n         // Move back up.\n         self.current_module = orig_module;\n@@ -4100,7 +4129,7 @@ impl Resolver {\n         debug!(\"(resolving block) leaving block\");\n     }\n \n-    pub fn resolve_type(@mut self, ty: &Ty, visitor: ResolveVisitor) {\n+    pub fn resolve_type(@mut self, ty: &Ty, visitor: &mut ResolveVisitor) {\n         match ty.node {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n@@ -4178,12 +4207,12 @@ impl Resolver {\n                         self.resolve_type_parameter_bound(ty.id, bound, visitor);\n                     }\n                 };\n-                visit_ty(ty, ((), visitor));\n+                visit::walk_ty(visitor, ty, ());\n             }\n \n             _ => {\n                 // Just resolve embedded types.\n-                visit_ty(ty, ((), visitor));\n+                visit::walk_ty(visitor, ty, ());\n             }\n         }\n     }\n@@ -4195,7 +4224,7 @@ impl Resolver {\n                            // Maps idents to the node ID for the (outermost)\n                            // pattern that binds them\n                            bindings_list: Option<@mut HashMap<ident,NodeId>>,\n-                           visitor: ResolveVisitor) {\n+                           visitor: &mut ResolveVisitor) {\n         let pat_id = pattern.id;\n         do walk_pat(pattern) |pattern| {\n             match pattern.node {\n@@ -4477,7 +4506,7 @@ impl Resolver {\n                         path: &Path,\n                         namespace: Namespace,\n                         check_ribs: bool,\n-                        visitor: ResolveVisitor)\n+                        visitor: &mut ResolveVisitor)\n                         -> Option<def> {\n         // First, resolve the types.\n         for ty in path.types.iter() {\n@@ -4903,7 +4932,7 @@ impl Resolver {\n       return false;\n     }\n \n-    pub fn resolve_expr(@mut self, expr: @expr, visitor: ResolveVisitor) {\n+    pub fn resolve_expr(@mut self, expr: @expr, visitor: &mut ResolveVisitor) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n \n@@ -4971,7 +5000,7 @@ impl Resolver {\n                     }\n                 }\n \n-                visit_expr(expr, ((), visitor));\n+                visit::walk_expr(visitor, expr, ());\n             }\n \n             expr_fn_block(ref fn_decl, ref block) => {\n@@ -5005,7 +5034,7 @@ impl Resolver {\n                     }\n                 }\n \n-                visit_expr(expr, ((), visitor));\n+                visit::walk_expr(visitor, expr, ());\n             }\n \n             expr_loop(_, Some(label)) => {\n@@ -5017,7 +5046,7 @@ impl Resolver {\n                         rib.bindings.insert(label, def_like);\n                     }\n \n-                    visit_expr(expr, ((), visitor));\n+                    visit::walk_expr(visitor, expr, ());\n                 }\n             }\n \n@@ -5055,7 +5084,7 @@ impl Resolver {\n             }\n \n             _ => {\n-                visit_expr(expr, ((), visitor));\n+                visit::walk_expr(visitor, expr, ());\n             }\n         }\n     }\n@@ -5293,11 +5322,8 @@ impl Resolver {\n     //\n \n     pub fn check_for_unused_imports(@mut self) {\n-        let vt = mk_simple_visitor(@SimpleVisitor {\n-            visit_view_item: |vi| self.check_for_item_unused_imports(vi),\n-            .. *default_simple_visitor()\n-        });\n-        visit_crate(self.crate, ((), vt));\n+        let mut visitor = UnusedImportCheckVisitor{ resolver: self };\n+        visit::walk_crate(&mut visitor, self.crate, ());\n     }\n \n     pub fn check_for_item_unused_imports(&mut self, vi: &view_item) {"}, {"sha": "f4d52c3aa31e014ef46b634c7337c8cf2818d70c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2246d56e7149402f18041d05e3c0ecf598671904", "patch": "@@ -85,7 +85,7 @@ use syntax::codemap::span;\n use syntax::parse::token;\n use syntax::parse::token::{special_idents};\n use syntax::print::pprust::stmt_to_str;\n-use syntax::oldvisit;\n+use syntax::visit;\n use syntax::{ast, ast_util, codemap, ast_map};\n use syntax::abi::{X86, X86_64, Arm, Mips};\n \n@@ -2646,13 +2646,18 @@ pub fn trans_constant(ccx: &mut CrateContext, it: @ast::item) {\n     }\n }\n \n+struct TransConstantsVisitor { ccx: @mut CrateContext }\n+\n+impl visit::Visitor<()> for TransConstantsVisitor {\n+    fn visit_item(&mut self, i:@ast::item, _:()) {\n+        trans_constant(self.ccx, i);\n+        visit::walk_item(self, i, ());\n+    }\n+}\n+\n pub fn trans_constants(ccx: @mut CrateContext, crate: &ast::Crate) {\n-    oldvisit::visit_crate(\n-        crate, ((),\n-        oldvisit::mk_simple_visitor(@oldvisit::SimpleVisitor {\n-            visit_item: |a| trans_constant(ccx, a),\n-            ..*oldvisit::default_simple_visitor()\n-        })));\n+    let mut v = TransConstantsVisitor { ccx: ccx };\n+    visit::walk_crate(&mut v, crate, ());\n }\n \n pub fn vp2i(cx: @mut Block, v: ValueRef) -> ValueRef {"}, {"sha": "ab5f3289cc7226619160e52f8dd18df918570dd5", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=2246d56e7149402f18041d05e3c0ecf598671904", "patch": "@@ -49,7 +49,8 @@ use middle::trans::type_::Type;\n use syntax::ast;\n use syntax::abi::AbiSet;\n use syntax::ast_map;\n-use syntax::oldvisit;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n \n // Represents a (possibly monomorphized) top-level fn item or method\n // item.  Note that this is just the fn-ptr and is not a Rust closure\n@@ -556,21 +557,29 @@ pub fn trans_lang_call_with_type_params(bcx: @mut Block,\n         ArgVals(args), Some(dest), DontAutorefArg).bcx;\n }\n \n-pub fn body_contains_ret(body: &ast::Block) -> bool {\n-    let cx = @mut false;\n-    oldvisit::visit_block(body, (cx, oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_item: |_i, (_cx, _v)| { },\n-        visit_expr: |e: @ast::expr,\n-                     (cx, v): (@mut bool, oldvisit::vt<@mut bool>)| {\n+\n+struct CalleeTranslationVisitor;\n+\n+impl Visitor<@mut bool> for CalleeTranslationVisitor {\n+\n+    fn visit_item(&mut self, _:@ast::item, _:@mut bool) { }\n+\n+    fn visit_expr(&mut self, e:@ast::expr, cx:@mut bool) {\n+\n             if !*cx {\n                 match e.node {\n                   ast::expr_ret(_) => *cx = true,\n-                  _ => oldvisit::visit_expr(e, (cx, v)),\n+                  _ => visit::walk_expr(self, e, cx),\n                 }\n             }\n-        },\n-        ..*oldvisit::default_visitor()\n-    })));\n+    }\n+\n+}\n+\n+pub fn body_contains_ret(body: &ast::Block) -> bool {\n+    let cx = @mut false;\n+    let mut v = CalleeTranslationVisitor;\n+    visit::walk_block(&mut v, body, cx);\n     *cx\n }\n "}, {"sha": "c67035021a3aab9f282abac4491cfefbd450a661", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=2246d56e7149402f18041d05e3c0ecf598671904", "patch": "@@ -42,15 +42,16 @@ use syntax::ast::*;\n use syntax::ast_map;\n use syntax::ast_util;\n use syntax::parse::token;\n-use syntax::oldvisit;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n \n pub type type_uses = uint; // Bitmask\n pub static use_repr: uint = 1;   /* Dependency on size/alignment/mode and\n                                      take/drop glue */\n pub static use_tydesc: uint = 2; /* Takes the tydesc, or compares */\n pub static use_all: uint = use_repr|use_tydesc;\n \n-\n+#[deriving(Clone)]\n pub struct Context {\n     ccx: @mut CrateContext,\n     uses: @mut ~[type_uses]\n@@ -416,28 +417,39 @@ pub fn mark_for_expr(cx: &Context, e: &expr) {\n     }\n }\n \n-pub fn handle_body(cx: &Context, body: &Block) {\n-    let v = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_expr: |e, (cx, v)| {\n-            oldvisit::visit_expr(e, (cx, v));\n+struct TypeUseVisitor;\n+\n+impl<'self> Visitor<&'self Context> for TypeUseVisitor {\n+\n+    fn visit_expr<'a>(&mut self, e:@expr, cx: &'a Context) {\n+            visit::walk_expr(self, e, cx);\n             mark_for_expr(cx, e);\n-        },\n-        visit_local: |l, (cx, v)| {\n-            oldvisit::visit_local(l, (cx, v));\n+    }\n+\n+    fn visit_local<'a>(&mut self, l:@Local, cx: &'a Context) {\n+            visit::walk_local(self, l, cx);\n             node_type_needs(cx, use_repr, l.id);\n-        },\n-        visit_pat: |p, (cx, v)| {\n-            oldvisit::visit_pat(p, (cx, v));\n+    }\n+\n+    fn visit_pat<'a>(&mut self, p:@pat, cx: &'a Context) {\n+            visit::walk_pat(self, p, cx);\n             node_type_needs(cx, use_repr, p.id);\n-        },\n-        visit_block: |b, (cx, v)| {\n-            oldvisit::visit_block(b, (cx, v));\n+    }\n+\n+    fn visit_block<'a>(&mut self, b:&Block, cx: &'a Context) {\n+            visit::walk_block(self, b, cx);\n             for e in b.expr.iter() {\n                 node_type_needs(cx, use_repr, e.id);\n             }\n-        },\n-        visit_item: |_i, (_cx, _v)| { },\n-        ..*oldvisit::default_visitor()\n-    });\n-    (v.visit_block)(body, (cx, v));\n+    }\n+\n+    fn visit_item<'a>(&mut self, _:@item, _: &'a Context) {\n+        // do nothing\n+    }\n+\n+}\n+\n+pub fn handle_body(cx: &Context, body: &Block) {\n+    let mut v = TypeUseVisitor;\n+    v.visit_block(body, cx);\n }"}, {"sha": "ad6bf69d55ad6c22a439223bf7ab86efc8be2569", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 87, "deletions": 82, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=2246d56e7149402f18041d05e3c0ecf598671904", "patch": "@@ -129,7 +129,8 @@ use syntax::opt_vec;\n use syntax::parse::token;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust;\n-use syntax::oldvisit;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n use syntax;\n \n pub mod _match;\n@@ -296,12 +297,18 @@ impl ExprTyProvider for FnCtxt {\n     }\n }\n \n+struct CheckItemTypesVisitor { ccx: @mut CrateCtxt }\n+\n+impl Visitor<()> for CheckItemTypesVisitor {\n+    fn visit_item(&mut self, i:@ast::item, _:()) {\n+        check_item(self.ccx, i);\n+        visit::walk_item(self, i, ());\n+    }\n+}\n+\n pub fn check_item_types(ccx: @mut CrateCtxt, crate: &ast::Crate) {\n-    let visit = oldvisit::mk_simple_visitor(@oldvisit::SimpleVisitor {\n-        visit_item: |a| check_item(ccx, a),\n-        .. *oldvisit::default_simple_visitor()\n-    });\n-    oldvisit::visit_crate(crate, ((), visit));\n+    let mut visit = CheckItemTypesVisitor { ccx: ccx };\n+    visit::walk_crate(&mut visit, crate, ());\n }\n \n pub fn check_bare_fn(ccx: @mut CrateCtxt,\n@@ -326,6 +333,76 @@ pub fn check_bare_fn(ccx: @mut CrateCtxt,\n     }\n }\n \n+struct GatherLocalsVisitor {\n+                     fcx: @mut FnCtxt,\n+                     tcx: ty::ctxt,\n+}\n+\n+impl GatherLocalsVisitor {\n+    fn assign(&mut self, nid: ast::NodeId, ty_opt: Option<ty::t>) {\n+            match ty_opt {\n+                None => {\n+                    // infer the variable's type\n+                    let var_id = self.fcx.infcx().next_ty_var_id();\n+                    let var_ty = ty::mk_var(self.fcx.tcx(), var_id);\n+                    self.fcx.inh.locals.insert(nid, var_ty);\n+                }\n+                Some(typ) => {\n+                    // take type that the user specified\n+                    self.fcx.inh.locals.insert(nid, typ);\n+                }\n+            }\n+    }\n+}\n+\n+impl Visitor<()> for GatherLocalsVisitor {\n+        // Add explicitly-declared locals.\n+    fn visit_local(&mut self, local:@ast::Local, _:()) {\n+            let o_ty = match local.ty.node {\n+              ast::ty_infer => None,\n+              _ => Some(self.fcx.to_ty(&local.ty))\n+            };\n+            self.assign(local.id, o_ty);\n+            debug!(\"Local variable %s is assigned type %s\",\n+                   self.fcx.pat_to_str(local.pat),\n+                   self.fcx.infcx().ty_to_str(\n+                       self.fcx.inh.locals.get_copy(&local.id)));\n+            visit::walk_local(self, local, ());\n+\n+    }\n+        // Add pattern bindings.\n+    fn visit_pat(&mut self, p:@ast::pat, _:()) {\n+            match p.node {\n+              ast::pat_ident(_, ref path, _)\n+                  if pat_util::pat_is_binding(self.fcx.ccx.tcx.def_map, p) => {\n+                self.assign(p.id, None);\n+                debug!(\"Pattern binding %s is assigned to %s\",\n+                       self.tcx.sess.str_of(path.idents[0]),\n+                       self.fcx.infcx().ty_to_str(\n+                           self.fcx.inh.locals.get_copy(&p.id)));\n+              }\n+              _ => {}\n+            }\n+            visit::walk_pat(self, p, ());\n+\n+    }\n+\n+    fn visit_block(&mut self, b:&ast::Block, _:()) {\n+            // non-obvious: the `blk` variable maps to region lb, so\n+            // we have to keep this up-to-date.  This\n+            // is... unfortunate.  It'd be nice to not need this.\n+            do self.fcx.with_region_lb(b.id) {\n+                visit::walk_block(self, b, ());\n+            }\n+    }\n+\n+        // Don't descend into fns and items\n+    fn visit_fn(&mut self, _:&visit::fn_kind, _:&ast::fn_decl,\n+                _:&ast::Block, _:span, _:ast::NodeId, _:()) { }\n+    fn visit_item(&mut self, _:@ast::item, _:()) { }\n+\n+}\n+\n pub fn check_fn(ccx: @mut CrateCtxt,\n                 opt_self_info: Option<SelfInfo>,\n                 purity: ast::purity,\n@@ -429,24 +506,11 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                      opt_self_info: Option<SelfInfo>) {\n         let tcx = fcx.ccx.tcx;\n \n-        let assign: @fn(ast::NodeId, Option<ty::t>) = |nid, ty_opt| {\n-            match ty_opt {\n-                None => {\n-                    // infer the variable's type\n-                    let var_id = fcx.infcx().next_ty_var_id();\n-                    let var_ty = ty::mk_var(fcx.tcx(), var_id);\n-                    fcx.inh.locals.insert(nid, var_ty);\n-                }\n-                Some(typ) => {\n-                    // take type that the user specified\n-                    fcx.inh.locals.insert(nid, typ);\n-                }\n-            }\n-        };\n+        let mut visit = GatherLocalsVisitor { fcx: fcx, tcx: tcx, };\n \n         // Add the self parameter\n         for self_info in opt_self_info.iter() {\n-            assign(self_info.self_id, Some(self_info.self_ty));\n+            visit.assign(self_info.self_id, Some(self_info.self_ty));\n             debug!(\"self is assigned to %s\",\n                    fcx.infcx().ty_to_str(\n                        fcx.inh.locals.get_copy(&self_info.self_id)));\n@@ -457,7 +521,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             // Create type variables for each argument.\n             do pat_util::pat_bindings(tcx.def_map, input.pat)\n                     |_bm, pat_id, _sp, _path| {\n-                assign(pat_id, None);\n+                visit.assign(pat_id, None);\n             }\n \n             // Check the pattern.\n@@ -468,66 +532,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             _match::check_pat(&pcx, input.pat, *arg_ty);\n         }\n \n-        // Add explicitly-declared locals.\n-        let visit_local: @fn(@ast::Local, ((), oldvisit::vt<()>)) =\n-                |local, (e, v)| {\n-            let o_ty = match local.ty.node {\n-              ast::ty_infer => None,\n-              _ => Some(fcx.to_ty(&local.ty))\n-            };\n-            assign(local.id, o_ty);\n-            debug!(\"Local variable %s is assigned type %s\",\n-                   fcx.pat_to_str(local.pat),\n-                   fcx.infcx().ty_to_str(\n-                       fcx.inh.locals.get_copy(&local.id)));\n-            oldvisit::visit_local(local, (e, v));\n-        };\n-\n-        // Add pattern bindings.\n-        let visit_pat: @fn(@ast::pat, ((), oldvisit::vt<()>)) = |p, (e, v)| {\n-            match p.node {\n-              ast::pat_ident(_, ref path, _)\n-                  if pat_util::pat_is_binding(fcx.ccx.tcx.def_map, p) => {\n-                assign(p.id, None);\n-                debug!(\"Pattern binding %s is assigned to %s\",\n-                       tcx.sess.str_of(path.idents[0]),\n-                       fcx.infcx().ty_to_str(\n-                           fcx.inh.locals.get_copy(&p.id)));\n-              }\n-              _ => {}\n-            }\n-            oldvisit::visit_pat(p, (e, v));\n-        };\n-\n-        let visit_block:\n-                @fn(&ast::Block, ((), oldvisit::vt<()>)) = |b, (e, v)| {\n-            // non-obvious: the `blk` variable maps to region lb, so\n-            // we have to keep this up-to-date.  This\n-            // is... unfortunate.  It'd be nice to not need this.\n-            do fcx.with_region_lb(b.id) {\n-                oldvisit::visit_block(b, (e, v));\n-            }\n-        };\n-\n-        // Don't descend into fns and items\n-        fn visit_fn(_fk: &oldvisit::fn_kind,\n-                    _decl: &ast::fn_decl,\n-                    _body: &ast::Block,\n-                    _sp: span,\n-                    _id: ast::NodeId,\n-                    (_t,_v): ((), oldvisit::vt<()>)) {\n-        }\n-        fn visit_item(_i: @ast::item, (_e,_v): ((), oldvisit::vt<()>)) { }\n-\n-        let visit = oldvisit::mk_vt(\n-            @oldvisit::Visitor {visit_local: visit_local,\n-                             visit_pat: visit_pat,\n-                             visit_fn: visit_fn,\n-                             visit_item: visit_item,\n-                             visit_block: visit_block,\n-                             ..*oldvisit::default_visitor()});\n-\n-        (visit.visit_block)(body, ((), visit));\n+        visit.visit_block(body, ());\n     }\n }\n "}, {"sha": "05f1323805b3527a4479bced18fc026e0f023375", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 45, "deletions": 39, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=2246d56e7149402f18041d05e3c0ecf598671904", "patch": "@@ -43,7 +43,8 @@ use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n use syntax::ast::{def_arg, def_binding, def_local, def_self, def_upvar};\n use syntax::ast;\n use syntax::codemap::span;\n-use syntax::oldvisit;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n \n pub struct Rcx {\n     fcx: @mut FnCtxt,\n@@ -53,8 +54,6 @@ pub struct Rcx {\n     repeating_scope: ast::NodeId,\n }\n \n-pub type rvt = oldvisit::vt<@mut Rcx>;\n-\n fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::def) -> ty::Region {\n     let tcx = fcx.tcx();\n     match def {\n@@ -146,8 +145,8 @@ pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::expr) {\n                          repeating_scope: e.id };\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n-        let v = regionck_visitor();\n-        (v.visit_expr)(e, (rcx, v));\n+        let mut v = regionck_visitor();\n+        v.visit_expr(e, rcx);\n     }\n     fcx.infcx().resolve_regions();\n }\n@@ -157,55 +156,62 @@ pub fn regionck_fn(fcx: @mut FnCtxt, blk: &ast::Block) {\n                          repeating_scope: blk.id };\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n-        let v = regionck_visitor();\n-        (v.visit_block)(blk, (rcx, v));\n+        let mut v = regionck_visitor();\n+        v.visit_block(blk, rcx);\n     }\n     fcx.infcx().resolve_regions();\n }\n \n-fn regionck_visitor() -> rvt {\n+struct RegionckVisitor;\n+\n+impl Visitor<@mut Rcx> for RegionckVisitor {\n     // (*) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n     // However, right now we run into an issue whereby some free\n     // regions are not properly related if they appear within the\n     // types of arguments that must be inferred. This could be\n     // addressed by deferring the construction of the region\n     // hierarchy, and in particular the relationships between free\n     // regions, until regionck, as described in #3238.\n-    oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_item: visit_item,\n-        visit_expr: visit_expr,\n+\n+    fn visit_item(&mut self, i:@ast::item, e:@mut Rcx) { visit_item(self, i, e); }\n+\n+    fn visit_expr(&mut self, ex:@ast::expr, e:@mut Rcx) { visit_expr(self, ex, e); }\n \n         //visit_pat: visit_pat, // (*) see above\n-        visit_arm: visit_arm,\n-        visit_local: visit_local,\n \n-        visit_block: visit_block,\n-        .. *oldvisit::default_visitor()\n-    })\n+    fn visit_arm(&mut self, a:&ast::arm, e:@mut Rcx) { visit_arm(self, a, e); }\n+\n+    fn visit_local(&mut self, l:@ast::Local, e:@mut Rcx) { visit_local(self, l, e); }\n+\n+    fn visit_block(&mut self, b:&ast::Block, e:@mut Rcx) { visit_block(self, b, e); }\n+}\n+\n+fn regionck_visitor() -> RegionckVisitor {\n+    RegionckVisitor\n }\n \n-fn visit_item(_item: @ast::item, (_rcx, _v): (@mut Rcx, rvt)) {\n+fn visit_item(_v: &mut RegionckVisitor, _item: @ast::item, _rcx: @mut Rcx) {\n     // Ignore items\n }\n \n-fn visit_block(b: &ast::Block, (rcx, v): (@mut Rcx, rvt)) {\n+fn visit_block(v: &mut RegionckVisitor, b: &ast::Block, rcx: @mut Rcx) {\n     rcx.fcx.tcx().region_maps.record_cleanup_scope(b.id);\n-    oldvisit::visit_block(b, (rcx, v));\n+    visit::walk_block(v, b, rcx);\n }\n \n-fn visit_arm(arm: &ast::arm, (rcx, v): (@mut Rcx, rvt)) {\n+fn visit_arm(v: &mut RegionckVisitor, arm: &ast::arm, rcx: @mut Rcx) {\n     // see above\n     for &p in arm.pats.iter() {\n         constrain_bindings_in_pat(p, rcx);\n     }\n \n-    oldvisit::visit_arm(arm, (rcx, v));\n+    visit::walk_arm(v, arm, rcx);\n }\n \n-fn visit_local(l: @ast::Local, (rcx, v): (@mut Rcx, rvt)) {\n+fn visit_local(v: &mut RegionckVisitor, l: @ast::Local, rcx: @mut Rcx) {\n     // see above\n     constrain_bindings_in_pat(l.pat, rcx);\n-    oldvisit::visit_local(l, (rcx, v));\n+    visit::walk_local(v, l, rcx);\n }\n \n fn constrain_bindings_in_pat(pat: @ast::pat, rcx: @mut Rcx) {\n@@ -242,7 +248,7 @@ fn constrain_bindings_in_pat(pat: @ast::pat, rcx: @mut Rcx) {\n     }\n }\n \n-fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n+fn visit_expr(v: &mut RegionckVisitor, expr: @ast::expr, rcx: @mut Rcx) {\n     debug!(\"regionck::visit_expr(e=%s, repeating_scope=%?)\",\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n@@ -330,13 +336,13 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n             constrain_callee(rcx, callee.id, expr, callee);\n             constrain_call(rcx, callee.id, expr, None, *args, false);\n \n-            oldvisit::visit_expr(expr, (rcx, v));\n+            visit::walk_expr(v, expr, rcx);\n         }\n \n         ast::expr_method_call(callee_id, arg0, _, _, ref args, _) => {\n             constrain_call(rcx, callee_id, expr, Some(arg0), *args, false);\n \n-            oldvisit::visit_expr(expr, (rcx, v));\n+            visit::walk_expr(v,expr, rcx);\n         }\n \n         ast::expr_index(callee_id, lhs, rhs) |\n@@ -348,30 +354,30 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n             // should be converted to an adjustment!\n             constrain_call(rcx, callee_id, expr, Some(lhs), [rhs], true);\n \n-            oldvisit::visit_expr(expr, (rcx, v));\n+            visit::walk_expr(v, expr, rcx);\n         }\n \n         ast::expr_unary(callee_id, _, lhs) if has_method_map => {\n             // As above.\n             constrain_call(rcx, callee_id, expr, Some(lhs), [], true);\n \n-            oldvisit::visit_expr(expr, (rcx, v));\n+            visit::walk_expr(v, expr, rcx);\n         }\n \n         ast::expr_unary(_, ast::deref, base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let base_ty = rcx.resolve_node_type(base.id);\n             constrain_derefs(rcx, expr, 1, base_ty);\n \n-            oldvisit::visit_expr(expr, (rcx, v));\n+            visit::walk_expr(v, expr, rcx);\n         }\n \n         ast::expr_index(_, vec_expr, _) => {\n             // For a[b], the lifetime of a must enclose the deref\n             let vec_type = rcx.resolve_expr_type_adjusted(vec_expr);\n             constrain_index(rcx, expr, vec_type);\n \n-            oldvisit::visit_expr(expr, (rcx, v));\n+            visit::walk_expr(v, expr, rcx);\n         }\n \n         ast::expr_cast(source, _) => {\n@@ -401,7 +407,7 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n                 _ => ()\n             }\n \n-            oldvisit::visit_expr(expr, (rcx, v));\n+            visit::walk_expr(v, expr, rcx);\n         }\n \n         ast::expr_addr_of(_, base) => {\n@@ -417,13 +423,13 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n             let ty0 = rcx.resolve_node_type(expr.id);\n             constrain_regions_in_type(rcx, ty::re_scope(expr.id),\n                                       infer::AddrOf(expr.span), ty0);\n-            oldvisit::visit_expr(expr, (rcx, v));\n+            visit::walk_expr(v, expr, rcx);\n         }\n \n         ast::expr_match(discr, ref arms) => {\n             guarantor::for_match(rcx, discr, *arms);\n \n-            oldvisit::visit_expr(expr, (rcx, v));\n+            visit::walk_expr(v, expr, rcx);\n         }\n \n         ast::expr_fn_block(*) => {\n@@ -432,29 +438,29 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n \n         ast::expr_loop(ref body, _) => {\n             let repeating_scope = rcx.set_repeating_scope(body.id);\n-            oldvisit::visit_expr(expr, (rcx, v));\n+            visit::walk_expr(v, expr, rcx);\n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n         ast::expr_while(cond, ref body) => {\n             let repeating_scope = rcx.set_repeating_scope(cond.id);\n-            (v.visit_expr)(cond, (rcx, v));\n+            v.visit_expr(cond, rcx);\n \n             rcx.set_repeating_scope(body.id);\n-            (v.visit_block)(body, (rcx, v));\n+            v.visit_block(body, rcx);\n \n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n         _ => {\n-            oldvisit::visit_expr(expr, (rcx, v));\n+            visit::walk_expr(v, expr, rcx);\n         }\n     }\n }\n \n fn check_expr_fn_block(rcx: @mut Rcx,\n                        expr: @ast::expr,\n-                       v: rvt) {\n+                       v: &mut RegionckVisitor) {\n     let tcx = rcx.fcx.tcx();\n     match expr.node {\n         ast::expr_fn_block(_, ref body) => {\n@@ -483,7 +489,7 @@ fn check_expr_fn_block(rcx: @mut Rcx,\n             }\n \n             let repeating_scope = rcx.set_repeating_scope(body.id);\n-            oldvisit::visit_expr(expr, (rcx, v));\n+            visit::walk_expr(v, expr, rcx);\n             rcx.set_repeating_scope(repeating_scope);\n         }\n "}, {"sha": "7678a12b78a5f2ad34d164751bf627eb2ca482e0", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2246d56e7149402f18041d05e3c0ecf598671904/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=2246d56e7149402f18041d05e3c0ecf598671904", "patch": "@@ -56,11 +56,26 @@ use syntax::ast_util::{local_def, split_trait_methods};\n use syntax::codemap::span;\n use syntax::codemap;\n use syntax::print::pprust::{path_to_str, explicit_self_to_str};\n-use syntax::oldvisit;\n+use syntax::visit;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n \n+struct CollectItemTypesVisitor {\n+    ccx: @mut CrateCtxt\n+}\n+\n+impl visit::Visitor<()> for CollectItemTypesVisitor {\n+    fn visit_item(&mut self, i:@ast::item, _:()) {\n+        convert(self.ccx, i);\n+        visit::walk_item(self, i, ());\n+    }\n+    fn visit_foreign_item(&mut self, i:@ast::foreign_item, _:()) {\n+        convert_foreign(self.ccx, i);\n+        visit::walk_foreign_item(self, i, ());\n+    }\n+}\n+\n pub fn collect_item_types(ccx: @mut CrateCtxt, crate: &ast::Crate) {\n     fn collect_intrinsic_type(ccx: &CrateCtxt,\n                               lang_item: ast::def_id) {\n@@ -76,13 +91,8 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: &ast::Crate) {\n         Some(id) => { collect_intrinsic_type(ccx, id); } None => {}\n     }\n \n-    oldvisit::visit_crate(\n-        crate, ((),\n-        oldvisit::mk_simple_visitor(@oldvisit::SimpleVisitor {\n-            visit_item: |a| convert(ccx, a),\n-            visit_foreign_item: |a|convert_foreign(ccx, a),\n-            .. *oldvisit::default_simple_visitor()\n-        })));\n+    let mut visitor = CollectItemTypesVisitor{ ccx: ccx };\n+    visit::walk_crate(&mut visitor, crate, ());\n }\n \n pub trait ToTy {"}]}