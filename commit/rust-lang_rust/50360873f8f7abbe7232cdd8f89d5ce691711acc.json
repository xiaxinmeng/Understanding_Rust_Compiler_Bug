{"sha": "50360873f8f7abbe7232cdd8f89d5ce691711acc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMzYwODczZjhmN2FiYmU3MjMyY2RkOGY4OWQ1Y2U2OTE3MTFhY2M=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-02-11T13:03:03Z"}, "committer": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-02-12T00:39:39Z"}, "message": "(core::str) added rindex and rewrote pop_char with char_range_at_reverse", "tree": {"sha": "98ca5b72ac85a0acd6dfdd68e8b83f7a86008284", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98ca5b72ac85a0acd6dfdd68e8b83f7a86008284"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50360873f8f7abbe7232cdd8f89d5ce691711acc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50360873f8f7abbe7232cdd8f89d5ce691711acc", "html_url": "https://github.com/rust-lang/rust/commit/50360873f8f7abbe7232cdd8f89d5ce691711acc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50360873f8f7abbe7232cdd8f89d5ce691711acc/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27161f4415e484680cf404b9819bf37d66c26783", "url": "https://api.github.com/repos/rust-lang/rust/commits/27161f4415e484680cf404b9819bf37d66c26783", "html_url": "https://github.com/rust-lang/rust/commit/27161f4415e484680cf404b9819bf37d66c26783"}], "stats": {"total": 104, "additions": 91, "deletions": 13}, "files": [{"sha": "5a879fb0cf83fde1a9266160dea7e5d8b15e4af0", "filename": "src/libcore/str.rs", "status": "modified", "additions": 91, "deletions": 13, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/50360873f8f7abbe7232cdd8f89d5ce691711acc/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50360873f8f7abbe7232cdd8f89d5ce691711acc/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=50360873f8f7abbe7232cdd8f89d5ce691711acc", "patch": "@@ -71,7 +71,7 @@ export\n \n    // Searching\n    index,\n-   //rindex,\n+   rindex,\n    index_byte,\n    rindex_byte,\n    find,\n@@ -255,15 +255,12 @@ Function: pop_char\n Remove the final character from a string and return it.\n \n Failure:\n-\n If the string does not contain any characters.\n */\n fn pop_char(&s: str) -> char unsafe {\n     let end = byte_len(s);\n-    while end > 0u && s[end - 1u] & 192u8 == tag_cont_u8 { end -= 1u; }\n-    assert (end > 0u);\n-    let ch = char_at(s, end - 1u);\n-    s = unsafe::slice_bytes(s, 0u, end - 1u);\n+    let {ch:ch, prev:end} = char_range_at_reverse(s, end);\n+    s = unsafe::slice_bytes(s, 0u, end);\n     ret ch;\n }\n \n@@ -894,6 +891,28 @@ fn index(ss: str, cc: char) -> option<uint> {\n     ret option::none;\n }\n \n+// Function: rindex\n+//\n+// Returns the index of the first matching char\n+// (as option some/none)\n+fn rindex(ss: str, cc: char) -> option<uint> {\n+    let bii = byte_len(ss);\n+    let cii = char_len(ss);\n+    while bii > 0u {\n+        let {ch, prev} = char_range_at_reverse(ss, bii);\n+        cii -= 1u;\n+        bii = prev;\n+\n+        // found here?\n+        if ch == cc {\n+            ret option::some(cii);\n+        }\n+    }\n+\n+    // wasn't found\n+    ret option::none;\n+}\n+\n /*\n Function: index\n \n@@ -1259,6 +1278,25 @@ Pluck a character out of a string\n */\n fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n \n+// Function: char_range_at_reverse\n+//\n+// Given a byte position and a str, return the previous char and its position\n+// This function can be used to iterate over a unicode string in reverse.\n+fn char_range_at_reverse(ss: str, start: uint) -> {ch: char, prev: uint} {\n+    let prev = start;\n+\n+    // while there is a previous byte == 10......\n+    while prev > 0u && ss[prev - 1u] & 192u8 == tag_cont_u8 {\n+        prev -= 1u;\n+    }\n+\n+    // now refer to the initial byte of previous char\n+    prev -= 1u;\n+\n+    let ch = char_at(ss, prev);\n+    ret {ch:ch, prev:prev};\n+}\n+\n /*\n Function: substr_all\n \n@@ -1468,18 +1506,58 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_index_and_rindex() {\n-        assert (index_byte(\"hello\", 'e' as u8) == 1);\n-        assert (index_byte(\"hello\", 'o' as u8) == 4);\n-        assert (index_byte(\"hello\", 'z' as u8) == -1);\n-        assert (index(\"hello\", 'e') == option::some(1u));\n-        assert (index(\"hello\", 'o') == option::some(4u));\n-        assert (index(\"hello\", 'z') == option::none);\n+    fn test_index() {\n+        assert ( index(\"hello\", 'h') == option::some(0u));\n+        assert ( index(\"hello\", 'e') == option::some(1u));\n+        assert ( index(\"hello\", 'o') == option::some(4u));\n+        assert ( index(\"hello\", 'z') == option::none);\n+    }\n+\n+    #[test]\n+    fn test_rindex() {\n+        assert (rindex(\"hello\", 'l') == option::some(3u));\n+        assert (rindex(\"hello\", 'o') == option::some(4u));\n+        assert (rindex(\"hello\", 'h') == option::some(0u));\n+        assert (rindex(\"hello\", 'z') == option::none);\n+    }\n+\n+    #[test]\n+    fn test_index_byte() {\n+        assert ( index_byte(\"hello\", 'e' as u8) == 1);\n+        assert ( index_byte(\"hello\", 'o' as u8) == 4);\n+        assert ( index_byte(\"hello\", 'z' as u8) == -1);\n+    }\n+\n+    #[test]\n+    fn test_rindex_byte() {\n         assert (rindex_byte(\"hello\", 'l' as u8) == 3);\n         assert (rindex_byte(\"hello\", 'h' as u8) == 0);\n         assert (rindex_byte(\"hello\", 'z' as u8) == -1);\n     }\n \n+    #[test]\n+    fn test_pop_char() {\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let cc = pop_char(data);\n+        assert \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\" == data;\n+        assert '\u534e' == cc;\n+    }\n+\n+    #[test]\n+    fn test_pop_char_2() {\n+        let data2 = \"\u534e\";\n+        let cc2 = pop_char(data2);\n+        assert \"\" == data2;\n+        assert '\u534e' == cc2;\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_pop_char_fail() {\n+        let data = \"\";\n+        let _cc3 = pop_char(data);\n+    }\n+\n     #[test]\n     fn test_split_byte() {\n         fn t(s: str, c: char, u: [str]) {"}]}