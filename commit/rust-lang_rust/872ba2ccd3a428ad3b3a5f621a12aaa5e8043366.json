{"sha": "872ba2ccd3a428ad3b3a5f621a12aaa5e8043366", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MmJhMmNjZDNhNDI4YWQzYjNhNWY2MjFhMTJhYWE1ZTgwNDMzNjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-11T00:11:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-11T00:11:23Z"}, "message": "auto merge of #19294 : huonw/rust/transmute-inplace, r=nikomatsakis\n\nThis detects (a subset of) the cases when `transmute::<T, U>(x)` can be\r\nlowered to a direct `bitcast T x to U` in LLVM. This assists with\r\nefficiently handling a SIMD vector as multiple different types,\r\ne.g. swapping bytes/words/double words around inside some larger vector\r\ntype.\r\n\r\nC compilers like GCC and Clang handle integer vector types as `__m128i`\r\nfor all widths, and implicitly insert bitcasts as required. This patch\r\nallows Rust to express this, even if it takes a bit of `unsafe`, whereas\r\npreviously it was impossible to do at all without inline assembly.\r\n\r\nExample:\r\n\r\n    pub fn reverse_u32s(u: u64x2) -> u64x2 {\r\n        unsafe {\r\n            let tmp = mem::transmute::<_, u32x4>(u);\r\n            let swapped = u32x4(tmp.3, tmp.2, tmp.1, tmp.0);\r\n            mem::transmute::<_, u64x2>(swapped)\r\n        }\r\n    }\r\n\r\nCompiling with `--opt-level=3` gives:\r\n\r\nBefore\r\n\r\n    define <2 x i64> @_ZN12reverse_u32s20hbdb206aba18a03d8tbaE(<2 x i64>) unnamed_addr #0 {\r\n    entry-block:\r\n      %1 = bitcast <2 x i64> %0 to i128\r\n      %u.0.extract.trunc = trunc i128 %1 to i32\r\n      %u.4.extract.shift = lshr i128 %1, 32\r\n      %u.4.extract.trunc = trunc i128 %u.4.extract.shift to i32\r\n      %u.8.extract.shift = lshr i128 %1, 64\r\n      %u.8.extract.trunc = trunc i128 %u.8.extract.shift to i32\r\n      %u.12.extract.shift = lshr i128 %1, 96\r\n      %u.12.extract.trunc = trunc i128 %u.12.extract.shift to i32\r\n      %2 = insertelement <4 x i32> undef, i32 %u.12.extract.trunc, i64 0\r\n      %3 = insertelement <4 x i32> %2, i32 %u.8.extract.trunc, i64 1\r\n      %4 = insertelement <4 x i32> %3, i32 %u.4.extract.trunc, i64 2\r\n      %5 = insertelement <4 x i32> %4, i32 %u.0.extract.trunc, i64 3\r\n      %6 = bitcast <4 x i32> %5 to <2 x i64>\r\n      ret <2 x i64> %6\r\n    }\r\n\r\n    _ZN12reverse_u32s20hbdb206aba18a03d8tbaE:\r\n    \t.cfi_startproc\r\n    \tmovd\t%xmm0, %rax\r\n    \tpunpckhqdq\t%xmm0, %xmm0\r\n    \tmovd\t%xmm0, %rcx\r\n    \tmovq\t%rcx, %rdx\r\n    \tshrq\t$32, %rdx\r\n    \tmovq\t%rax, %rsi\r\n    \tshrq\t$32, %rsi\r\n    \tmovd\t%eax, %xmm0\r\n    \tmovd\t%ecx, %xmm1\r\n    \tpunpckldq\t%xmm0, %xmm1\r\n    \tmovd\t%esi, %xmm2\r\n    \tmovd\t%edx, %xmm0\r\n    \tpunpckldq\t%xmm2, %xmm0\r\n    \tpunpckldq\t%xmm1, %xmm0\r\n    \tretq\r\n\r\nAfter\r\n\r\n    define <2 x i64> @_ZN12reverse_u32s20hbdb206aba18a03d8tbaE(<2 x i64>) unnamed_addr #0 {\r\n    entry-block:\r\n      %1 = bitcast <2 x i64> %0 to <4 x i32>\r\n      %2 = shufflevector <4 x i32> %1, <4 x i32> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\r\n      %3 = bitcast <4 x i32> %2 to <2 x i64>\r\n      ret <2 x i64> %3\r\n    }\r\n\r\n    _ZN12reverse_u32s20hbdb206aba18a03d8tbaE:\r\n    \t.cfi_startproc\r\n    \tpshufd\t$27, %xmm0, %xmm0\r\n    \tretq", "tree": {"sha": "ccd700156e01a314f5b5efd337bb35d1c38ab086", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccd700156e01a314f5b5efd337bb35d1c38ab086"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/872ba2ccd3a428ad3b3a5f621a12aaa5e8043366", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/872ba2ccd3a428ad3b3a5f621a12aaa5e8043366", "html_url": "https://github.com/rust-lang/rust/commit/872ba2ccd3a428ad3b3a5f621a12aaa5e8043366", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/872ba2ccd3a428ad3b3a5f621a12aaa5e8043366/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c38e73fef53e8520e5170c40713e32ab965a8abe", "url": "https://api.github.com/repos/rust-lang/rust/commits/c38e73fef53e8520e5170c40713e32ab965a8abe", "html_url": "https://github.com/rust-lang/rust/commit/c38e73fef53e8520e5170c40713e32ab965a8abe"}, {"sha": "1a620661b7ef7bbee10e56895e6ee081504b7378", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a620661b7ef7bbee10e56895e6ee081504b7378", "html_url": "https://github.com/rust-lang/rust/commit/1a620661b7ef7bbee10e56895e6ee081504b7378"}], "stats": {"total": 65, "additions": 59, "deletions": 6}, "files": [{"sha": "890652401d7eb11cfe9605be74e14133d2dd8ac7", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 59, "deletions": 6, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/872ba2ccd3a428ad3b3a5f621a12aaa5e8043366/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/872ba2ccd3a428ad3b3a5f621a12aaa5e8043366/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=872ba2ccd3a428ad3b3a5f621a12aaa5e8043366", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_upper_case_globals)]\n \n use llvm;\n-use llvm::{SequentiallyConsistent, Acquire, Release, AtomicXchg, ValueRef};\n+use llvm::{SequentiallyConsistent, Acquire, Release, AtomicXchg, ValueRef, TypeKind};\n use middle::subst;\n use middle::subst::FnSpace;\n use trans::base::*;\n@@ -174,12 +174,65 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 // This should be caught by the intrinsicck pass\n                 assert_eq!(in_type_size, out_type_size);\n \n-                // We need to cast the dest so the types work out\n-                let dest = match dest {\n-                    expr::SaveIn(d) => expr::SaveIn(PointerCast(bcx, d, llintype.ptr_to())),\n-                    expr::Ignore => expr::Ignore\n+                let nonpointer_nonaggregate = |llkind: TypeKind| -> bool {\n+                    use llvm::TypeKind::*;\n+                    match llkind {\n+                        Half | Float | Double | X86_FP80 | FP128 |\n+                            PPC_FP128 | Integer | Vector | X86_MMX => true,\n+                        _ => false\n+                    }\n+                };\n+\n+                // An approximation to which types can be directly cast via\n+                // LLVM's bitcast.  This doesn't cover pointer -> pointer casts,\n+                // but does, importantly, cover SIMD types.\n+                let in_kind = llintype.kind();\n+                let ret_kind = llret_ty.kind();\n+                let bitcast_compatible =\n+                    (nonpointer_nonaggregate(in_kind) && nonpointer_nonaggregate(ret_kind)) || {\n+                        in_kind == TypeKind::Pointer && ret_kind == TypeKind::Pointer\n+                    };\n+\n+                let dest = if bitcast_compatible {\n+                    // if we're here, the type is scalar-like (a primitive, a\n+                    // SIMD type or a pointer), and so can be handled as a\n+                    // by-value ValueRef and can also be directly bitcast to the\n+                    // target type.  Doing this special case makes conversions\n+                    // like `u32x4` -> `u64x2` much nicer for LLVM and so more\n+                    // efficient (these are done efficiently implicitly in C\n+                    // with the `__m128i` type and so this means Rust doesn't\n+                    // lose out there).\n+                    let expr = &*arg_exprs[0];\n+                    let datum = unpack_datum!(bcx, expr::trans(bcx, expr));\n+                    let datum = unpack_datum!(bcx, datum.to_rvalue_datum(bcx, \"transmute_temp\"));\n+                    let val = if datum.kind.is_by_ref() {\n+                        load_ty(bcx, datum.val, datum.ty)\n+                    } else {\n+                        datum.val\n+                    };\n+\n+                    let cast_val = BitCast(bcx, val, llret_ty);\n+\n+                    match dest {\n+                        expr::SaveIn(d) => {\n+                            // this often occurs in a sequence like `Store(val,\n+                            // d); val2 = Load(d)`, so disappears easily.\n+                            Store(bcx, cast_val, d);\n+                        }\n+                        expr::Ignore => {}\n+                    }\n+                    dest\n+                } else {\n+                    // The types are too complicated to do with a by-value\n+                    // bitcast, so pointer cast instead. We need to cast the\n+                    // dest so the types work out.\n+                    let dest = match dest {\n+                        expr::SaveIn(d) => expr::SaveIn(PointerCast(bcx, d, llintype.ptr_to())),\n+                        expr::Ignore => expr::Ignore\n+                    };\n+                    bcx = expr::trans_into(bcx, &*arg_exprs[0], dest);\n+                    dest\n                 };\n-                bcx = expr::trans_into(bcx, &*arg_exprs[0], dest);\n \n                 fcx.pop_custom_cleanup_scope(cleanup_scope);\n "}]}