{"sha": "6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjZmM2MDMzOTU1ZGQyNjg1ZGZhN2JhZWVjNmY2YmMzYmZkZmUyZjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-05T09:48:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-05T09:48:46Z"}, "message": "Auto merge of #55515 - QuietMisdreavus:rustdoc-config, r=GuillaumeGomez\n\nrustdoc: refactor: centralize all command-line argument parsing\n\nThis is something i've wanted to do for a while, since we keep having to add new arguments to places like `rust_input` or `core::run_core` whenever we add a new CLI flag or the like. Those functions have inflated up to 11-19, and in some cases hiding away the locations where some CLI flags were being parsed, obscuring their use. Now, we have a central place where all command-line configuration occurs, including argument validation.\n\nOne note about the design: i grouped together all the arguments that `html::render::run` needed, so that i could pass them on from compilation in one lump instead of trying to thread through individual items or clone the entire blob ahead of time.\n\nOne other thing this adds is that rustdoc also now recognizes all the `-Z` options that rustc does, since we were manually grabbing a few previously. Now we parse a full `DebuggingOptions` struct and hand it directly to rustc when scraping docs.", "tree": {"sha": "00f3540234142caf99fa78c0c04fcbf11d6ad154", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00f3540234142caf99fa78c0c04fcbf11d6ad154"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1", "html_url": "https://github.com/rust-lang/rust/commit/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56ac2c4fc3a287c189abb2db5fd26a53f30ef9e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/56ac2c4fc3a287c189abb2db5fd26a53f30ef9e7", "html_url": "https://github.com/rust-lang/rust/commit/56ac2c4fc3a287c189abb2db5fd26a53f30ef9e7"}, {"sha": "560a01c795923d7ae9e4dafa8bce7261d6450ade", "url": "https://api.github.com/repos/rust-lang/rust/commits/560a01c795923d7ae9e4dafa8bce7261d6450ade", "html_url": "https://github.com/rust-lang/rust/commit/560a01c795923d7ae9e4dafa8bce7261d6450ade"}], "stats": {"total": 1283, "additions": 729, "deletions": 554}, "files": [{"sha": "903aafed64116db84093377ec9f96d0dfd138ff8", "filename": "src/librustdoc/config.rs", "status": "added", "additions": 560, "deletions": 0, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1", "patch": "@@ -0,0 +1,560 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::{BTreeMap, BTreeSet};\n+use std::fmt;\n+use std::path::PathBuf;\n+\n+use errors;\n+use errors::emitter::ColorConfig;\n+use getopts;\n+use rustc::lint::Level;\n+use rustc::session::early_error;\n+use rustc::session::config::{CodegenOptions, DebuggingOptions, ErrorOutputType, Externs};\n+use rustc::session::config::{nightly_options, build_codegen_options, build_debugging_options,\n+                             get_cmd_lint_options};\n+use rustc::session::search_paths::SearchPaths;\n+use rustc_driver;\n+use rustc_target::spec::TargetTriple;\n+use syntax::edition::Edition;\n+\n+use core::new_handler;\n+use externalfiles::ExternalHtml;\n+use html;\n+use html::markdown::IdMap;\n+use opts;\n+use passes::{self, DefaultPassOption};\n+use theme;\n+\n+/// Configuration options for rustdoc.\n+#[derive(Clone)]\n+pub struct Options {\n+    // Basic options / Options passed directly to rustc\n+\n+    /// The crate root or Markdown file to load.\n+    pub input: PathBuf,\n+    /// The name of the crate being documented.\n+    pub crate_name: Option<String>,\n+    /// How to format errors and warnings.\n+    pub error_format: ErrorOutputType,\n+    /// Library search paths to hand to the compiler.\n+    pub libs: SearchPaths,\n+    /// The list of external crates to link against.\n+    pub externs: Externs,\n+    /// List of `cfg` flags to hand to the compiler. Always includes `rustdoc`.\n+    pub cfgs: Vec<String>,\n+    /// Codegen options to hand to the compiler.\n+    pub codegen_options: CodegenOptions,\n+    /// Debugging (`-Z`) options to pass to the compiler.\n+    pub debugging_options: DebuggingOptions,\n+    /// The target used to compile the crate against.\n+    pub target: Option<TargetTriple>,\n+    /// Edition used when reading the crate. Defaults to \"2015\". Also used by default when\n+    /// compiling doctests from the crate.\n+    pub edition: Edition,\n+    /// The path to the sysroot. Used during the compilation process.\n+    pub maybe_sysroot: Option<PathBuf>,\n+    /// Linker to use when building doctests.\n+    pub linker: Option<PathBuf>,\n+    /// Lint information passed over the command-line.\n+    pub lint_opts: Vec<(String, Level)>,\n+    /// Whether to ask rustc to describe the lints it knows. Practically speaking, this will not be\n+    /// used, since we abort if we have no input file, but it's included for completeness.\n+    pub describe_lints: bool,\n+    /// What level to cap lints at.\n+    pub lint_cap: Option<Level>,\n+\n+    // Options specific to running doctests\n+\n+    /// Whether we should run doctests instead of generating docs.\n+    pub should_test: bool,\n+    /// List of arguments to pass to the test harness, if running tests.\n+    pub test_args: Vec<String>,\n+\n+    // Options that affect the documentation process\n+\n+    /// The selected default set of passes to use.\n+    ///\n+    /// Be aware: This option can come both from the CLI and from crate attributes!\n+    pub default_passes: DefaultPassOption,\n+    /// Any passes manually selected by the user.\n+    ///\n+    /// Be aware: This option can come both from the CLI and from crate attributes!\n+    pub manual_passes: Vec<String>,\n+    /// Whether to display warnings during doc generation or while gathering doctests. By default,\n+    /// all non-rustdoc-specific lints are allowed when generating docs.\n+    pub display_warnings: bool,\n+\n+    // Options that alter generated documentation pages\n+\n+    /// Crate version to note on the sidebar of generated docs.\n+    pub crate_version: Option<String>,\n+    /// Collected options specific to outputting final pages.\n+    pub render_options: RenderOptions,\n+}\n+\n+impl fmt::Debug for Options {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        struct FmtExterns<'a>(&'a Externs);\n+\n+        impl<'a> fmt::Debug for FmtExterns<'a> {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                f.debug_map()\n+                    .entries(self.0.iter())\n+                    .finish()\n+            }\n+        }\n+\n+        f.debug_struct(\"Options\")\n+            .field(\"input\", &self.input)\n+            .field(\"crate_name\", &self.crate_name)\n+            .field(\"error_format\", &self.error_format)\n+            .field(\"libs\", &self.libs)\n+            .field(\"externs\", &FmtExterns(&self.externs))\n+            .field(\"cfgs\", &self.cfgs)\n+            .field(\"codegen_options\", &\"...\")\n+            .field(\"debugging_options\", &\"...\")\n+            .field(\"target\", &self.target)\n+            .field(\"edition\", &self.edition)\n+            .field(\"maybe_sysroot\", &self.maybe_sysroot)\n+            .field(\"linker\", &self.linker)\n+            .field(\"lint_opts\", &self.lint_opts)\n+            .field(\"describe_lints\", &self.describe_lints)\n+            .field(\"lint_cap\", &self.lint_cap)\n+            .field(\"should_test\", &self.should_test)\n+            .field(\"test_args\", &self.test_args)\n+            .field(\"default_passes\", &self.default_passes)\n+            .field(\"manual_passes\", &self.manual_passes)\n+            .field(\"display_warnings\", &self.display_warnings)\n+            .field(\"crate_version\", &self.crate_version)\n+            .field(\"render_options\", &self.render_options)\n+            .finish()\n+    }\n+}\n+\n+/// Configuration options for the HTML page-creation process.\n+#[derive(Clone, Debug)]\n+pub struct RenderOptions {\n+    /// Output directory to generate docs into. Defaults to `doc`.\n+    pub output: PathBuf,\n+    /// External files to insert into generated pages.\n+    pub external_html: ExternalHtml,\n+    /// A pre-populated `IdMap` with the default headings and any headings added by Markdown files\n+    /// processed by `external_html`.\n+    pub id_map: IdMap,\n+    /// If present, playground URL to use in the \"Run\" button added to code samples.\n+    ///\n+    /// Be aware: This option can come both from the CLI and from crate attributes!\n+    pub playground_url: Option<String>,\n+    /// Whether to sort modules alphabetically on a module page instead of using declaration order.\n+    /// `true` by default.\n+    ///\n+    /// FIXME(misdreavus): the flag name is `--sort-modules-by-appearance` but the meaning is\n+    /// inverted once read\n+    pub sort_modules_alphabetically: bool,\n+    /// List of themes to extend the docs with. Original argument name is included to assist in\n+    /// displaying errors if it fails a theme check.\n+    pub themes: Vec<PathBuf>,\n+    /// If present, CSS file that contains rules to add to the default CSS.\n+    pub extension_css: Option<PathBuf>,\n+    /// A map of crate names to the URL to use instead of querying the crate's `html_root_url`.\n+    pub extern_html_root_urls: BTreeMap<String, String>,\n+    /// If present, suffix added to CSS/JavaScript files when referencing them in generated pages.\n+    pub resource_suffix: String,\n+    /// Whether to run the static CSS/JavaScript through a minifier when outputting them. `true` by\n+    /// default.\n+    ///\n+    /// FIXME(misdreavus): the flag name is `--disable-minification` but the meaning is inverted\n+    /// once read\n+    pub enable_minification: bool,\n+    /// Whether to create an index page in the root of the output directory. If this is true but\n+    /// `enable_index_page` is None, generate a static listing of crates instead.\n+    pub enable_index_page: bool,\n+    /// A file to use as the index page at the root of the output directory. Overrides\n+    /// `enable_index_page` to be true if set.\n+    pub index_page: Option<PathBuf>,\n+\n+    // Options specific to reading standalone Markdown files\n+\n+    /// Whether to generate a table of contents on the output file when reading a standalone\n+    /// Markdown file.\n+    pub markdown_no_toc: bool,\n+    /// Additional CSS files to link in pages generated from standlone Markdown files.\n+    pub markdown_css: Vec<String>,\n+    /// If present, playground URL to use in the \"Run\" button added to code samples generated from\n+    /// standalone Markdown files. If not present, `playground_url` is used.\n+    pub markdown_playground_url: Option<String>,\n+}\n+\n+impl Options {\n+    /// Parses the given command-line for options. If an error message or other early-return has\n+    /// been printed, returns `Err` with the exit code.\n+    pub fn from_matches(matches: &getopts::Matches) -> Result<Options, isize> {\n+        // Check for unstable options.\n+        nightly_options::check_nightly_options(&matches, &opts());\n+\n+        if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n+            ::usage(\"rustdoc\");\n+            return Err(0);\n+        } else if matches.opt_present(\"version\") {\n+            rustc_driver::version(\"rustdoc\", &matches);\n+            return Err(0);\n+        }\n+\n+        if matches.opt_strs(\"passes\") == [\"list\"] {\n+            println!(\"Available passes for running rustdoc:\");\n+            for pass in passes::PASSES {\n+                println!(\"{:>20} - {}\", pass.name(), pass.description());\n+            }\n+            println!(\"\\nDefault passes for rustdoc:\");\n+            for &name in passes::DEFAULT_PASSES {\n+                println!(\"{:>20}\", name);\n+            }\n+            println!(\"\\nPasses run with `--document-private-items`:\");\n+            for &name in passes::DEFAULT_PRIVATE_PASSES {\n+                println!(\"{:>20}\", name);\n+            }\n+            return Err(0);\n+        }\n+\n+        let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n+            Some(\"auto\") => ColorConfig::Auto,\n+            Some(\"always\") => ColorConfig::Always,\n+            Some(\"never\") => ColorConfig::Never,\n+            None => ColorConfig::Auto,\n+            Some(arg) => {\n+                early_error(ErrorOutputType::default(),\n+                            &format!(\"argument for --color must be `auto`, `always` or `never` \\\n+                                      (instead was `{}`)\", arg));\n+            }\n+        };\n+        let error_format = match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n+            Some(\"human\") => ErrorOutputType::HumanReadable(color),\n+            Some(\"json\") => ErrorOutputType::Json(false),\n+            Some(\"pretty-json\") => ErrorOutputType::Json(true),\n+            Some(\"short\") => ErrorOutputType::Short(color),\n+            None => ErrorOutputType::HumanReadable(color),\n+            Some(arg) => {\n+                early_error(ErrorOutputType::default(),\n+                            &format!(\"argument for --error-format must be `human`, `json` or \\\n+                                      `short` (instead was `{}`)\", arg));\n+            }\n+        };\n+\n+        let codegen_options = build_codegen_options(matches, error_format);\n+        let debugging_options = build_debugging_options(matches, error_format);\n+\n+        let diag = new_handler(error_format,\n+                               None,\n+                               debugging_options.treat_err_as_bug,\n+                               debugging_options.ui_testing);\n+\n+        // check for deprecated options\n+        check_deprecated_options(&matches, &diag);\n+\n+        let to_check = matches.opt_strs(\"theme-checker\");\n+        if !to_check.is_empty() {\n+            let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/light.css\"));\n+            let mut errors = 0;\n+\n+            println!(\"rustdoc: [theme-checker] Starting tests!\");\n+            for theme_file in to_check.iter() {\n+                print!(\" - Checking \\\"{}\\\"...\", theme_file);\n+                let (success, differences) = theme::test_theme_against(theme_file, &paths, &diag);\n+                if !differences.is_empty() || !success {\n+                    println!(\" FAILED\");\n+                    errors += 1;\n+                    if !differences.is_empty() {\n+                        println!(\"{}\", differences.join(\"\\n\"));\n+                    }\n+                } else {\n+                    println!(\" OK\");\n+                }\n+            }\n+            if errors != 0 {\n+                return Err(1);\n+            }\n+            return Err(0);\n+        }\n+\n+        if matches.free.is_empty() {\n+            diag.struct_err(\"missing file operand\").emit();\n+            return Err(1);\n+        }\n+        if matches.free.len() > 1 {\n+            diag.struct_err(\"too many file operands\").emit();\n+            return Err(1);\n+        }\n+        let input = PathBuf::from(&matches.free[0]);\n+\n+        let mut libs = SearchPaths::new();\n+        for s in &matches.opt_strs(\"L\") {\n+            libs.add_path(s, error_format);\n+        }\n+        let externs = match parse_externs(&matches) {\n+            Ok(ex) => ex,\n+            Err(err) => {\n+                diag.struct_err(&err).emit();\n+                return Err(1);\n+            }\n+        };\n+        let extern_html_root_urls = match parse_extern_html_roots(&matches) {\n+            Ok(ex) => ex,\n+            Err(err) => {\n+                diag.struct_err(err).emit();\n+                return Err(1);\n+            }\n+        };\n+\n+        let test_args = matches.opt_strs(\"test-args\");\n+        let test_args: Vec<String> = test_args.iter()\n+                                              .flat_map(|s| s.split_whitespace())\n+                                              .map(|s| s.to_string())\n+                                              .collect();\n+\n+        let should_test = matches.opt_present(\"test\");\n+\n+        let output = matches.opt_str(\"o\")\n+                            .map(|s| PathBuf::from(&s))\n+                            .unwrap_or_else(|| PathBuf::from(\"doc\"));\n+        let mut cfgs = matches.opt_strs(\"cfg\");\n+        cfgs.push(\"rustdoc\".to_string());\n+\n+        let extension_css = matches.opt_str(\"e\").map(|s| PathBuf::from(&s));\n+\n+        if let Some(ref p) = extension_css {\n+            if !p.is_file() {\n+                diag.struct_err(\"option --extend-css argument must be a file\").emit();\n+                return Err(1);\n+            }\n+        }\n+\n+        let mut themes = Vec::new();\n+        if matches.opt_present(\"themes\") {\n+            let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/light.css\"));\n+\n+            for (theme_file, theme_s) in matches.opt_strs(\"themes\")\n+                                                .iter()\n+                                                .map(|s| (PathBuf::from(&s), s.to_owned())) {\n+                if !theme_file.is_file() {\n+                    diag.struct_err(\"option --themes arguments must all be files\").emit();\n+                    return Err(1);\n+                }\n+                let (success, ret) = theme::test_theme_against(&theme_file, &paths, &diag);\n+                if !success || !ret.is_empty() {\n+                    diag.struct_err(&format!(\"invalid theme: \\\"{}\\\"\", theme_s))\n+                        .help(\"check what's wrong with the --theme-checker option\")\n+                        .emit();\n+                    return Err(1);\n+                }\n+                themes.push(theme_file);\n+            }\n+        }\n+\n+        let mut id_map = html::markdown::IdMap::new();\n+        id_map.populate(html::render::initial_ids());\n+        let external_html = match ExternalHtml::load(\n+                &matches.opt_strs(\"html-in-header\"),\n+                &matches.opt_strs(\"html-before-content\"),\n+                &matches.opt_strs(\"html-after-content\"),\n+                &matches.opt_strs(\"markdown-before-content\"),\n+                &matches.opt_strs(\"markdown-after-content\"), &diag, &mut id_map) {\n+            Some(eh) => eh,\n+            None => return Err(3),\n+        };\n+\n+        let edition = matches.opt_str(\"edition\").unwrap_or(\"2015\".to_string());\n+        let edition = match edition.parse() {\n+            Ok(e) => e,\n+            Err(_) => {\n+                diag.struct_err(\"could not parse edition\").emit();\n+                return Err(1);\n+            }\n+        };\n+\n+        match matches.opt_str(\"r\").as_ref().map(|s| &**s) {\n+            Some(\"rust\") | None => {}\n+            Some(s) => {\n+                diag.struct_err(&format!(\"unknown input format: {}\", s)).emit();\n+                return Err(1);\n+            }\n+        }\n+\n+        match matches.opt_str(\"w\").as_ref().map(|s| &**s) {\n+            Some(\"html\") | None => {}\n+            Some(s) => {\n+                diag.struct_err(&format!(\"unknown output format: {}\", s)).emit();\n+                return Err(1);\n+            }\n+        }\n+\n+        let index_page = matches.opt_str(\"index-page\").map(|s| PathBuf::from(&s));\n+        if let Some(ref index_page) = index_page {\n+            if !index_page.is_file() {\n+                diag.struct_err(\"option `--index-page` argument must be a file\").emit();\n+                return Err(1);\n+            }\n+        }\n+\n+        let target = matches.opt_str(\"target\").map(|target| {\n+            if target.ends_with(\".json\") {\n+                TargetTriple::TargetPath(PathBuf::from(target))\n+            } else {\n+                TargetTriple::TargetTriple(target)\n+            }\n+        });\n+\n+        let default_passes = if matches.opt_present(\"no-defaults\") {\n+            passes::DefaultPassOption::None\n+        } else if matches.opt_present(\"document-private-items\") {\n+            passes::DefaultPassOption::Private\n+        } else {\n+            passes::DefaultPassOption::Default\n+        };\n+        let manual_passes = matches.opt_strs(\"passes\");\n+\n+        let crate_name = matches.opt_str(\"crate-name\");\n+        let playground_url = matches.opt_str(\"playground-url\");\n+        let maybe_sysroot = matches.opt_str(\"sysroot\").map(PathBuf::from);\n+        let display_warnings = matches.opt_present(\"display-warnings\");\n+        let linker = matches.opt_str(\"linker\").map(PathBuf::from);\n+        let sort_modules_alphabetically = !matches.opt_present(\"sort-modules-by-appearance\");\n+        let resource_suffix = matches.opt_str(\"resource-suffix\").unwrap_or_default();\n+        let enable_minification = !matches.opt_present(\"disable-minification\");\n+        let markdown_no_toc = matches.opt_present(\"markdown-no-toc\");\n+        let markdown_css = matches.opt_strs(\"markdown-css\");\n+        let markdown_playground_url = matches.opt_str(\"markdown-playground-url\");\n+        let crate_version = matches.opt_str(\"crate-version\");\n+        let enable_index_page = matches.opt_present(\"enable-index-page\") || index_page.is_some();\n+\n+        let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n+\n+        Ok(Options {\n+            input,\n+            crate_name,\n+            error_format,\n+            libs,\n+            externs,\n+            cfgs,\n+            codegen_options,\n+            debugging_options,\n+            target,\n+            edition,\n+            maybe_sysroot,\n+            linker,\n+            lint_opts,\n+            describe_lints,\n+            lint_cap,\n+            should_test,\n+            test_args,\n+            default_passes,\n+            manual_passes,\n+            display_warnings,\n+            crate_version,\n+            render_options: RenderOptions {\n+                output,\n+                external_html,\n+                id_map,\n+                playground_url,\n+                sort_modules_alphabetically,\n+                themes,\n+                extension_css,\n+                extern_html_root_urls,\n+                resource_suffix,\n+                enable_minification,\n+                enable_index_page,\n+                index_page,\n+                markdown_no_toc,\n+                markdown_css,\n+                markdown_playground_url,\n+            }\n+        })\n+    }\n+\n+    /// Returns whether the file given as `self.input` is a Markdown file.\n+    pub fn markdown_input(&self) -> bool {\n+        self.input.extension()\n+            .map_or(false, |e| e == \"md\" || e == \"markdown\")\n+    }\n+}\n+\n+/// Prints deprecation warnings for deprecated options\n+fn check_deprecated_options(matches: &getopts::Matches, diag: &errors::Handler) {\n+    let deprecated_flags = [\n+       \"input-format\",\n+       \"output-format\",\n+       \"no-defaults\",\n+       \"passes\",\n+    ];\n+\n+    for flag in deprecated_flags.into_iter() {\n+        if matches.opt_present(flag) {\n+            let mut err = diag.struct_warn(&format!(\"the '{}' flag is considered deprecated\",\n+                                                    flag));\n+            err.warn(\"please see https://github.com/rust-lang/rust/issues/44136\");\n+\n+            if *flag == \"no-defaults\" {\n+                err.help(\"you may want to use --document-private-items\");\n+            }\n+\n+            err.emit();\n+        }\n+    }\n+\n+    let removed_flags = [\n+        \"plugins\",\n+        \"plugin-path\",\n+    ];\n+\n+    for &flag in removed_flags.iter() {\n+        if matches.opt_present(flag) {\n+            diag.struct_warn(&format!(\"the '{}' flag no longer functions\", flag))\n+                .warn(\"see CVE-2018-1000622\")\n+                .emit();\n+        }\n+    }\n+}\n+\n+/// Extracts `--extern-html-root-url` arguments from `matches` and returns a map of crate names to\n+/// the given URLs. If an `--extern-html-root-url` argument was ill-formed, returns an error\n+/// describing the issue.\n+fn parse_extern_html_roots(\n+    matches: &getopts::Matches,\n+) -> Result<BTreeMap<String, String>, &'static str> {\n+    let mut externs = BTreeMap::new();\n+    for arg in &matches.opt_strs(\"extern-html-root-url\") {\n+        let mut parts = arg.splitn(2, '=');\n+        let name = parts.next().ok_or(\"--extern-html-root-url must not be empty\")?;\n+        let url = parts.next().ok_or(\"--extern-html-root-url must be of the form name=url\")?;\n+        externs.insert(name.to_string(), url.to_string());\n+    }\n+\n+    Ok(externs)\n+}\n+\n+/// Extracts `--extern CRATE=PATH` arguments from `matches` and\n+/// returns a map mapping crate names to their paths or else an\n+/// error message.\n+// FIXME(eddyb) This shouldn't be duplicated with `rustc::session`.\n+fn parse_externs(matches: &getopts::Matches) -> Result<Externs, String> {\n+    let mut externs: BTreeMap<_, BTreeSet<_>> = BTreeMap::new();\n+    for arg in &matches.opt_strs(\"extern\") {\n+        let mut parts = arg.splitn(2, '=');\n+        let name = parts.next().ok_or(\"--extern value must not be empty\".to_string())?;\n+        let location = parts.next().map(|s| s.to_string());\n+        if location.is_none() && !nightly_options::is_unstable_enabled(matches) {\n+            return Err(\"the `-Z unstable-options` flag must also be passed to \\\n+                        enable `--extern crate_name` without `=path`\".to_string());\n+        }\n+        let name = name.to_string();\n+        externs.entry(name).or_default().insert(location);\n+    }\n+    Ok(Externs::new(externs))\n+}"}, {"sha": "0bd6f6bf8a2f42495640ebfee3ad3676a1783a26", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1", "patch": "@@ -28,7 +28,6 @@ use rustc_target::spec::TargetTriple;\n \n use syntax::ast::{self, Ident, NodeId};\n use syntax::source_map;\n-use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::json::JsonEmitter;\n use syntax::ptr::P;\n@@ -43,9 +42,9 @@ use std::mem;\n use rustc_data_structures::sync::{self, Lrc};\n use std::rc::Rc;\n use std::sync::Arc;\n-use std::path::PathBuf;\n \n use visit_ast::RustdocVisitor;\n+use config::{Options as RustdocOptions, RenderOptions};\n use clean;\n use clean::{get_path_for_type, Clean, MAX_DEF_ID, AttributesExt};\n use html::render::RenderInfo;\n@@ -320,32 +319,33 @@ pub fn new_handler(error_format: ErrorOutputType,\n     )\n }\n \n-pub fn run_core(search_paths: SearchPaths,\n-                cfgs: Vec<String>,\n-                externs: config::Externs,\n-                input: Input,\n-                triple: Option<TargetTriple>,\n-                maybe_sysroot: Option<PathBuf>,\n-                allow_warnings: bool,\n-                crate_name: Option<String>,\n-                force_unstable_if_unmarked: bool,\n-                edition: Edition,\n-                cg: CodegenOptions,\n-                error_format: ErrorOutputType,\n-                cmd_lints: Vec<(String, lint::Level)>,\n-                lint_cap: Option<lint::Level>,\n-                describe_lints: bool,\n-                mut manual_passes: Vec<String>,\n-                mut default_passes: passes::DefaultPassOption,\n-                treat_err_as_bug: bool,\n-                ui_testing: bool,\n-) -> (clean::Crate, RenderInfo, Vec<String>) {\n+pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOptions, Vec<String>) {\n     // Parse, resolve, and typecheck the given crate.\n \n-    let cpath = match input {\n-        Input::File(ref p) => Some(p.clone()),\n-        _ => None\n-    };\n+    let RustdocOptions {\n+        input,\n+        crate_name,\n+        error_format,\n+        libs,\n+        externs,\n+        cfgs,\n+        codegen_options,\n+        debugging_options,\n+        target,\n+        edition,\n+        maybe_sysroot,\n+        lint_opts,\n+        describe_lints,\n+        lint_cap,\n+        mut default_passes,\n+        mut manual_passes,\n+        display_warnings,\n+        render_options,\n+        ..\n+    } = options;\n+\n+    let cpath = Some(input.clone());\n+    let input = Input::File(input);\n \n     let intra_link_resolution_failure_name = lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE.name;\n     let warnings_lint_name = lint::builtin::WARNINGS.name;\n@@ -359,7 +359,7 @@ pub fn run_core(search_paths: SearchPaths,\n                                      missing_docs.to_owned(),\n                                      missing_doc_example.to_owned()];\n \n-    whitelisted_lints.extend(cmd_lints.iter().map(|(lint, _)| lint).cloned());\n+    whitelisted_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n \n     let lints = lint::builtin::HardwiredLints.get_lints()\n                     .into_iter()\n@@ -372,33 +372,28 @@ pub fn run_core(search_paths: SearchPaths,\n                             Some((lint.name_lower(), lint::Allow))\n                         }\n                     })\n-                    .chain(cmd_lints.into_iter())\n+                    .chain(lint_opts.into_iter())\n                     .collect::<Vec<_>>();\n \n     let host_triple = TargetTriple::from_triple(config::host_triple());\n     // plays with error output here!\n     let sessopts = config::Options {\n         maybe_sysroot,\n-        search_paths,\n+        search_paths: libs,\n         crate_types: vec![config::CrateType::Rlib],\n-        lint_opts: if !allow_warnings {\n+        lint_opts: if !display_warnings {\n             lints\n         } else {\n             vec![]\n         },\n         lint_cap: Some(lint_cap.unwrap_or_else(|| lint::Forbid)),\n-        cg,\n+        cg: codegen_options,\n         externs,\n-        target_triple: triple.unwrap_or(host_triple),\n+        target_triple: target.unwrap_or(host_triple),\n         // Ensure that rustdoc works even if rustc is feature-staged\n         unstable_features: UnstableFeatures::Allow,\n         actually_rustdoc: true,\n-        debugging_opts: config::DebuggingOptions {\n-            force_unstable_if_unmarked,\n-            treat_err_as_bug,\n-            ui_testing,\n-            ..config::basic_debugging_options()\n-        },\n+        debugging_opts: debugging_options.clone(),\n         error_format,\n         edition,\n         describe_lints,\n@@ -408,8 +403,8 @@ pub fn run_core(search_paths: SearchPaths,\n         let source_map = Lrc::new(source_map::SourceMap::new(sessopts.file_path_mapping()));\n         let diagnostic_handler = new_handler(error_format,\n                                              Some(source_map.clone()),\n-                                             treat_err_as_bug,\n-                                             ui_testing);\n+                                             debugging_options.treat_err_as_bug,\n+                                             debugging_options.ui_testing);\n \n         let mut sess = session::build_session_(\n             sessopts, cpath, diagnostic_handler, source_map,\n@@ -621,7 +616,7 @@ pub fn run_core(search_paths: SearchPaths,\n \n             ctxt.sess().abort_if_errors();\n \n-            (krate, ctxt.renderinfo.into_inner(), passes)\n+            (krate, ctxt.renderinfo.into_inner(), render_options, passes)\n         }), &sess)\n     })\n }"}, {"sha": "c7a2dd6da3f754126b6861eef4e2a0d6cdf33f20", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1", "patch": "@@ -16,7 +16,7 @@ use syntax::feature_gate::UnstableFeatures;\n use html::markdown::{IdMap, ErrorCodes, Markdown};\n use std::cell::RefCell;\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct ExternalHtml {\n     /// Content that will be included inline in the <head> section of a\n     /// rendered Markdown file or generated documentation"}, {"sha": "649a5c7ff33b698f7e6912bf5ca93e5476296ab2", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1", "patch": "@@ -905,7 +905,7 @@ pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n     links\n }\n \n-#[derive(Default)]\n+#[derive(Clone, Default, Debug)]\n pub struct IdMap {\n     map: FxHashMap<String, usize>,\n }"}, {"sha": "efd71ad0763e0e61abcbeb638f1e15c6118952d7", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 42, "deletions": 47, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1", "patch": "@@ -52,11 +52,7 @@ use std::str;\n use std::sync::Arc;\n use std::rc::Rc;\n \n-use externalfiles::ExternalHtml;\n-\n use errors;\n-use getopts;\n-\n use serialize::json::{ToJson, Json, as_json};\n use syntax::ast;\n use syntax::ext::base::MacroKind;\n@@ -70,6 +66,7 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::flock;\n \n use clean::{self, AttributesExt, GetDefId, SelfTy, Mutability};\n+use config::RenderOptions;\n use doctree;\n use fold::DocFolder;\n use html::escape::Escape;\n@@ -109,8 +106,6 @@ struct Context {\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     id_map: Rc<RefCell<IdMap>>,\n     pub shared: Arc<SharedContext>,\n-    pub enable_index_page: bool,\n-    pub index_page: Option<PathBuf>,\n }\n \n struct SharedContext {\n@@ -495,23 +490,25 @@ pub fn initial_ids() -> Vec<String> {\n \n /// Generates the documentation for `crate` into the directory `dst`\n pub fn run(mut krate: clean::Crate,\n-           extern_urls: BTreeMap<String, String>,\n-           external_html: &ExternalHtml,\n-           playground_url: Option<String>,\n-           dst: PathBuf,\n-           resource_suffix: String,\n+           options: RenderOptions,\n            passes: FxHashSet<String>,\n-           css_file_extension: Option<PathBuf>,\n            renderinfo: RenderInfo,\n-           sort_modules_alphabetically: bool,\n-           themes: Vec<PathBuf>,\n-           enable_minification: bool,\n-           id_map: IdMap,\n-           enable_index_page: bool,\n-           index_page: Option<PathBuf>,\n-           matches: &getopts::Matches,\n-           diag: &errors::Handler,\n-) -> Result<(), Error> {\n+           diag: &errors::Handler) -> Result<(), Error> {\n+    // need to save a copy of the options for rendering the index page\n+    let md_opts = options.clone();\n+    let RenderOptions {\n+        output,\n+        external_html,\n+        id_map,\n+        playground_url,\n+        sort_modules_alphabetically,\n+        themes,\n+        extension_css,\n+        extern_html_root_urls,\n+        resource_suffix,\n+        ..\n+    } = options;\n+\n     let src_root = match krate.src {\n         FileName::Real(ref p) => match p.parent() {\n             Some(p) => p.to_path_buf(),\n@@ -528,10 +525,10 @@ pub fn run(mut krate: clean::Crate,\n         layout: layout::Layout {\n             logo: String::new(),\n             favicon: String::new(),\n-            external_html: external_html.clone(),\n+            external_html,\n             krate: krate.name.clone(),\n         },\n-        css_file_extension,\n+        css_file_extension: extension_css,\n         created_dirs: Default::default(),\n         sort_modules_alphabetically,\n         themes,\n@@ -573,6 +570,7 @@ pub fn run(mut krate: clean::Crate,\n             }\n         }\n     }\n+    let dst = output;\n     try_err!(fs::create_dir_all(&dst), &dst);\n     krate = render_sources(&dst, &mut scx, krate)?;\n     let cx = Context {\n@@ -582,8 +580,6 @@ pub fn run(mut krate: clean::Crate,\n         codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n         id_map: Rc::new(RefCell::new(id_map)),\n         shared: Arc::new(scx),\n-        enable_index_page,\n-        index_page,\n     };\n \n     // Crawl the crate to build various caches used for the output\n@@ -637,7 +633,7 @@ pub fn run(mut krate: clean::Crate,\n             },\n             _ => PathBuf::new(),\n         };\n-        let extern_url = extern_urls.get(&e.name).map(|u| &**u);\n+        let extern_url = extern_html_root_urls.get(&e.name).map(|u| &**u);\n         cache.extern_locations.insert(n, (e.name.clone(), src_root,\n                                           extern_location(e, extern_url, &cx.dst)));\n \n@@ -678,7 +674,7 @@ pub fn run(mut krate: clean::Crate,\n     CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n     CURRENT_LOCATION_KEY.with(|s| s.borrow_mut().clear());\n \n-    write_shared(&cx, &krate, &*cache, index, enable_minification, matches, diag)?;\n+    write_shared(&cx, &krate, &*cache, index, &md_opts, diag)?;\n \n     // And finally render the whole crate's documentation\n     cx.krate(krate)\n@@ -759,8 +755,7 @@ fn write_shared(\n     krate: &clean::Crate,\n     cache: &Cache,\n     search_index: String,\n-    enable_minification: bool,\n-    matches: &getopts::Matches,\n+    options: &RenderOptions,\n     diag: &errors::Handler,\n ) -> Result<(), Error> {\n     // Write out the shared files. Note that these are shared among all rustdoc\n@@ -773,10 +768,10 @@ fn write_shared(\n \n     write_minify(cx.dst.join(&format!(\"rustdoc{}.css\", cx.shared.resource_suffix)),\n                  include_str!(\"static/rustdoc.css\"),\n-                 enable_minification)?;\n+                 options.enable_minification)?;\n     write_minify(cx.dst.join(&format!(\"settings{}.css\", cx.shared.resource_suffix)),\n                  include_str!(\"static/settings.css\"),\n-                 enable_minification)?;\n+                 options.enable_minification)?;\n \n     // To avoid \"light.css\" to be overwritten, we'll first run over the received themes and only\n     // then we'll run over the \"official\" styles.\n@@ -800,11 +795,11 @@ fn write_shared(\n           include_bytes!(\"static/wheel.svg\"))?;\n     write_minify(cx.dst.join(&format!(\"light{}.css\", cx.shared.resource_suffix)),\n                  include_str!(\"static/themes/light.css\"),\n-                 enable_minification)?;\n+                 options.enable_minification)?;\n     themes.insert(\"light\".to_owned());\n     write_minify(cx.dst.join(&format!(\"dark{}.css\", cx.shared.resource_suffix)),\n                  include_str!(\"static/themes/dark.css\"),\n-                 enable_minification)?;\n+                 options.enable_minification)?;\n     themes.insert(\"dark\".to_owned());\n \n     let mut themes: Vec<&String> = themes.iter().collect();\n@@ -860,35 +855,35 @@ themePicker.onblur = handleThemeButtonsBlur;\n \n     write_minify(cx.dst.join(&format!(\"main{}.js\", cx.shared.resource_suffix)),\n                  include_str!(\"static/main.js\"),\n-                 enable_minification)?;\n+                 options.enable_minification)?;\n     write_minify(cx.dst.join(&format!(\"settings{}.js\", cx.shared.resource_suffix)),\n                  include_str!(\"static/settings.js\"),\n-                 enable_minification)?;\n+                 options.enable_minification)?;\n \n     {\n         let mut data = format!(\"var resourcesSuffix = \\\"{}\\\";\\n\",\n                                cx.shared.resource_suffix);\n         data.push_str(include_str!(\"static/storage.js\"));\n         write_minify(cx.dst.join(&format!(\"storage{}.js\", cx.shared.resource_suffix)),\n                      &data,\n-                     enable_minification)?;\n+                     options.enable_minification)?;\n     }\n \n     if let Some(ref css) = cx.shared.css_file_extension {\n         let out = cx.dst.join(&format!(\"theme{}.css\", cx.shared.resource_suffix));\n-        if !enable_minification {\n+        if !options.enable_minification {\n             try_err!(fs::copy(css, out), css);\n         } else {\n             let mut f = try_err!(File::open(css), css);\n             let mut buffer = String::with_capacity(1000);\n \n             try_err!(f.read_to_string(&mut buffer), css);\n-            write_minify(out, &buffer, enable_minification)?;\n+            write_minify(out, &buffer, options.enable_minification)?;\n         }\n     }\n     write_minify(cx.dst.join(&format!(\"normalize{}.css\", cx.shared.resource_suffix)),\n                  include_str!(\"static/normalize.css\"),\n-                 enable_minification)?;\n+                 options.enable_minification)?;\n     write(cx.dst.join(\"FiraSans-Regular.woff\"),\n           include_bytes!(\"static/FiraSans-Regular.woff\"))?;\n     write(cx.dst.join(\"FiraSans-Medium.woff\"),\n@@ -984,19 +979,19 @@ themePicker.onblur = handleThemeButtonsBlur;\n     let mut w = try_err!(File::create(&dst), &dst);\n     try_err!(writeln!(&mut w, \"var N = null;var searchIndex = {{}};\"), &dst);\n     for index in &all_indexes {\n-        try_err!(write_minify_replacer(&mut w, &*index, enable_minification,\n+        try_err!(write_minify_replacer(&mut w, &*index, options.enable_minification,\n                                        &[(minifier::js::Keyword::Null, \"N\")]),\n                  &dst);\n     }\n     try_err!(writeln!(&mut w, \"initSearch(searchIndex);\"), &dst);\n \n-    if cx.enable_index_page == true {\n-        if let Some(ref index_page) = cx.index_page {\n-            ::markdown::render(index_page,\n-                               cx.dst.clone(),\n-                               &matches, &(*cx.shared).layout.external_html,\n-                               !matches.opt_present(\"markdown-no-toc\"),\n-                               diag);\n+    if options.enable_index_page {\n+        if let Some(index_page) = options.index_page.clone() {\n+            let mut md_opts = options.clone();\n+            md_opts.output = cx.dst.clone();\n+            md_opts.external_html = (*cx.shared).layout.external_html.clone();\n+\n+            ::markdown::render(index_page, md_opts, diag);\n         } else {\n             let dst = cx.dst.join(\"index.html\");\n             let mut w = BufWriter::new(try_err!(File::create(&dst), &dst));"}, {"sha": "f0f36f0355ed6bef960b767854a52b5b8abf9fae", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 37, "deletions": 399, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1", "patch": "@@ -53,29 +53,20 @@ extern crate parking_lot;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n-use errors::ColorConfig;\n-\n-use std::collections::{BTreeMap, BTreeSet};\n use std::default::Default;\n use std::env;\n use std::panic;\n-use std::path::{Path, PathBuf};\n use std::process;\n use std::sync::mpsc::channel;\n \n-use syntax::edition::Edition;\n-use externalfiles::ExternalHtml;\n use rustc::session::{early_warn, early_error};\n-use rustc::session::search_paths::SearchPaths;\n-use rustc::session::config::{ErrorOutputType, RustcOptGroup, Externs, CodegenOptions};\n-use rustc::session::config::{nightly_options, build_codegen_options};\n-use rustc_target::spec::TargetTriple;\n-use rustc::session::config::get_cmd_lint_options;\n+use rustc::session::config::{ErrorOutputType, RustcOptGroup};\n \n #[macro_use]\n mod externalfiles;\n \n mod clean;\n+mod config;\n mod core;\n mod doctree;\n mod fold;\n@@ -99,6 +90,7 @@ mod theme;\n struct Output {\n     krate: clean::Crate,\n     renderinfo: html::render::RenderInfo,\n+    renderopts: config::RenderOptions,\n     passes: Vec<String>,\n }\n \n@@ -367,383 +359,57 @@ fn main_args(args: &[String]) -> isize {\n             early_error(ErrorOutputType::default(), &err.to_string());\n         }\n     };\n-    // Check for unstable options.\n-    nightly_options::check_nightly_options(&matches, &opts());\n-\n-    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        usage(\"rustdoc\");\n-        return 0;\n-    } else if matches.opt_present(\"version\") {\n-        rustc_driver::version(\"rustdoc\", &matches);\n-        return 0;\n-    }\n-\n-    if matches.opt_strs(\"passes\") == [\"list\"] {\n-        println!(\"Available passes for running rustdoc:\");\n-        for pass in passes::PASSES {\n-            println!(\"{:>20} - {}\", pass.name(), pass.description());\n-        }\n-        println!(\"\\nDefault passes for rustdoc:\");\n-        for &name in passes::DEFAULT_PASSES {\n-            println!(\"{:>20}\", name);\n-        }\n-        println!(\"\\nPasses run with `--document-private-items`:\");\n-        for &name in passes::DEFAULT_PRIVATE_PASSES {\n-            println!(\"{:>20}\", name);\n-        }\n-        return 0;\n-    }\n-\n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n-        Some(\"auto\") => ColorConfig::Auto,\n-        Some(\"always\") => ColorConfig::Always,\n-        Some(\"never\") => ColorConfig::Never,\n-        None => ColorConfig::Auto,\n-        Some(arg) => {\n-            early_error(ErrorOutputType::default(),\n-                        &format!(\"argument for --color must be `auto`, `always` or `never` \\\n-                                  (instead was `{}`)\", arg));\n-        }\n+    let options = match config::Options::from_matches(&matches) {\n+        Ok(opts) => opts,\n+        Err(code) => return code,\n     };\n-    let error_format = match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n-        Some(\"human\") => ErrorOutputType::HumanReadable(color),\n-        Some(\"json\") => ErrorOutputType::Json(false),\n-        Some(\"pretty-json\") => ErrorOutputType::Json(true),\n-        Some(\"short\") => ErrorOutputType::Short(color),\n-        None => ErrorOutputType::HumanReadable(color),\n-        Some(arg) => {\n-            early_error(ErrorOutputType::default(),\n-                        &format!(\"argument for --error-format must be `human`, `json` or \\\n-                                  `short` (instead was `{}`)\", arg));\n-        }\n-    };\n-    let treat_err_as_bug = matches.opt_strs(\"Z\").iter().any(|x| {\n-        *x == \"treat-err-as-bug\"\n-    });\n-    let ui_testing = matches.opt_strs(\"Z\").iter().any(|x| {\n-        *x == \"ui-testing\"\n-    });\n-\n-    let diag = core::new_handler(error_format, None, treat_err_as_bug, ui_testing);\n-\n-    // check for deprecated options\n-    check_deprecated_options(&matches, &diag);\n-\n-    let to_check = matches.opt_strs(\"theme-checker\");\n-    if !to_check.is_empty() {\n-        let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/light.css\"));\n-        let mut errors = 0;\n-\n-        println!(\"rustdoc: [theme-checker] Starting tests!\");\n-        for theme_file in to_check.iter() {\n-            print!(\" - Checking \\\"{}\\\"...\", theme_file);\n-            let (success, differences) = theme::test_theme_against(theme_file, &paths, &diag);\n-            if !differences.is_empty() || !success {\n-                println!(\" FAILED\");\n-                errors += 1;\n-                if !differences.is_empty() {\n-                    println!(\"{}\", differences.join(\"\\n\"));\n-                }\n-            } else {\n-                println!(\" OK\");\n-            }\n-        }\n-        if errors != 0 {\n-            return 1;\n-        }\n-        return 0;\n-    }\n-\n-    if matches.free.is_empty() {\n-        diag.struct_err(\"missing file operand\").emit();\n-        return 1;\n-    }\n-    if matches.free.len() > 1 {\n-        diag.struct_err(\"too many file operands\").emit();\n-        return 1;\n-    }\n-    let input = matches.free[0].clone();\n-\n-    let mut libs = SearchPaths::new();\n-    for s in &matches.opt_strs(\"L\") {\n-        libs.add_path(s, error_format);\n-    }\n-    let externs = match parse_externs(&matches) {\n-        Ok(ex) => ex,\n-        Err(err) => {\n-            diag.struct_err(&err).emit();\n-            return 1;\n-        }\n-    };\n-    let extern_urls = match parse_extern_html_roots(&matches) {\n-        Ok(ex) => ex,\n-        Err(err) => {\n-            diag.struct_err(err).emit();\n-            return 1;\n-        }\n-    };\n-\n-    let test_args = matches.opt_strs(\"test-args\");\n-    let test_args: Vec<String> = test_args.iter()\n-                                          .flat_map(|s| s.split_whitespace())\n-                                          .map(|s| s.to_string())\n-                                          .collect();\n-\n-    let should_test = matches.opt_present(\"test\");\n-    let markdown_input = Path::new(&input).extension()\n-        .map_or(false, |e| e == \"md\" || e == \"markdown\");\n-\n-    let output = matches.opt_str(\"o\").map(|s| PathBuf::from(&s));\n-    let css_file_extension = matches.opt_str(\"e\").map(|s| PathBuf::from(&s));\n-    let mut cfgs = matches.opt_strs(\"cfg\");\n-    cfgs.push(\"rustdoc\".to_string());\n-\n-    if let Some(ref p) = css_file_extension {\n-        if !p.is_file() {\n-            diag.struct_err(\"option --extend-css argument must be a file\").emit();\n-            return 1;\n-        }\n-    }\n-\n-    let mut themes = Vec::new();\n-    if matches.opt_present(\"themes\") {\n-        let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/light.css\"));\n-\n-        for (theme_file, theme_s) in matches.opt_strs(\"themes\")\n-                                            .iter()\n-                                            .map(|s| (PathBuf::from(&s), s.to_owned())) {\n-            if !theme_file.is_file() {\n-                diag.struct_err(\"option --themes arguments must all be files\").emit();\n-                return 1;\n-            }\n-            let (success, ret) = theme::test_theme_against(&theme_file, &paths, &diag);\n-            if !success || !ret.is_empty() {\n-                diag.struct_err(&format!(\"invalid theme: \\\"{}\\\"\", theme_s))\n-                    .help(\"check what's wrong with the --theme-checker option\")\n-                    .emit();\n-                return 1;\n-            }\n-            themes.push(theme_file);\n-        }\n-    }\n-\n-    let mut id_map = html::markdown::IdMap::new();\n-    id_map.populate(html::render::initial_ids());\n-    let external_html = match ExternalHtml::load(\n-            &matches.opt_strs(\"html-in-header\"),\n-            &matches.opt_strs(\"html-before-content\"),\n-            &matches.opt_strs(\"html-after-content\"),\n-            &matches.opt_strs(\"markdown-before-content\"),\n-            &matches.opt_strs(\"markdown-after-content\"), &diag, &mut id_map) {\n-        Some(eh) => eh,\n-        None => return 3,\n-    };\n-    let crate_name = matches.opt_str(\"crate-name\");\n-    let playground_url = matches.opt_str(\"playground-url\");\n-    let maybe_sysroot = matches.opt_str(\"sysroot\").map(PathBuf::from);\n-    let display_warnings = matches.opt_present(\"display-warnings\");\n-    let linker = matches.opt_str(\"linker\").map(PathBuf::from);\n-    let sort_modules_alphabetically = !matches.opt_present(\"sort-modules-by-appearance\");\n-    let resource_suffix = matches.opt_str(\"resource-suffix\");\n-    let index_page = matches.opt_str(\"index-page\").map(|s| PathBuf::from(&s));\n-    let enable_index_page = matches.opt_present(\"enable-index-page\") || index_page.is_some();\n-    let enable_minification = !matches.opt_present(\"disable-minification\");\n-\n-    let edition = matches.opt_str(\"edition\").unwrap_or(\"2015\".to_string());\n-    let edition = match edition.parse() {\n-        Ok(e) => e,\n-        Err(_) => {\n-            diag.struct_err(\"could not parse edition\").emit();\n-            return 1;\n-        }\n-    };\n-    if let Some(ref index_page) = index_page {\n-        if !index_page.is_file() {\n-            diag.struct_err(\"option `--index-page` argument must be a file\").emit();\n-            return 1;\n-        }\n-    }\n \n-    let cg = build_codegen_options(&matches, ErrorOutputType::default());\n+    let diag = core::new_handler(options.error_format,\n+                                 None,\n+                                 options.debugging_options.treat_err_as_bug,\n+                                 options.debugging_options.ui_testing);\n \n-    match (should_test, markdown_input) {\n-        (true, true) => {\n-            return markdown::test(&input, cfgs, libs, externs, test_args, maybe_sysroot,\n-                                  display_warnings, linker, edition, cg, &diag)\n-        }\n-        (true, false) => {\n-            return test::run(Path::new(&input), cfgs, libs, externs, test_args, crate_name,\n-                             maybe_sysroot, display_warnings, linker, edition, cg)\n-        }\n-        (false, true) => return markdown::render(Path::new(&input),\n-                                                 output.unwrap_or(PathBuf::from(\"doc\")),\n-                                                 &matches, &external_html,\n-                                                 !matches.opt_present(\"markdown-no-toc\"), &diag),\n+    match (options.should_test, options.markdown_input()) {\n+        (true, true) => return markdown::test(options, &diag),\n+        (true, false) => return test::run(options),\n+        (false, true) => return markdown::render(options.input, options.render_options, &diag),\n         (false, false) => {}\n     }\n \n-    let output_format = matches.opt_str(\"w\");\n-\n-    let res = acquire_input(PathBuf::from(input), externs, edition, cg, matches, error_format,\n-                            move |out, matches| {\n-        let Output { krate, passes, renderinfo } = out;\n-        let diag = core::new_handler(error_format, None, treat_err_as_bug, ui_testing);\n+    // need to move these items separately because we lose them by the time the closure is called,\n+    // but we can't crates the Handler ahead of time because it's not Send\n+    let diag_opts = (options.error_format,\n+                     options.debugging_options.treat_err_as_bug,\n+                     options.debugging_options.ui_testing);\n+    rust_input(options, move |out| {\n+        let Output { krate, passes, renderinfo, renderopts } = out;\n         info!(\"going to format\");\n-        match output_format.as_ref().map(|s| &**s) {\n-            Some(\"html\") | None => {\n-                html::render::run(krate, extern_urls, &external_html, playground_url,\n-                                  output.unwrap_or(PathBuf::from(\"doc\")),\n-                                  resource_suffix.unwrap_or(String::new()),\n-                                  passes.into_iter().collect(),\n-                                  css_file_extension,\n-                                  renderinfo,\n-                                  sort_modules_alphabetically,\n-                                  themes,\n-                                  enable_minification, id_map,\n-                                  enable_index_page, index_page,\n-                                  &matches,\n-                                  &diag)\n-                    .expect(\"failed to generate documentation\");\n-                0\n-            }\n-            Some(s) => {\n-                diag.struct_err(&format!(\"unknown output format: {}\", s)).emit();\n-                1\n-            }\n-        }\n-    });\n-    res.unwrap_or_else(|s| {\n-        diag.struct_err(&format!(\"input error: {}\", s)).emit();\n-        1\n+        let (error_format, treat_err_as_bug, ui_testing) = diag_opts;\n+        let diag = core::new_handler(error_format, None, treat_err_as_bug, ui_testing);\n+        html::render::run(krate, renderopts, passes.into_iter().collect(), renderinfo, &diag)\n+            .expect(\"failed to generate documentation\");\n+        0\n     })\n }\n \n-/// Looks inside the command line arguments to extract the relevant input format\n-/// and files and then generates the necessary rustdoc output for formatting.\n-fn acquire_input<R, F>(input: PathBuf,\n-                       externs: Externs,\n-                       edition: Edition,\n-                       cg: CodegenOptions,\n-                       matches: getopts::Matches,\n-                       error_format: ErrorOutputType,\n-                       f: F)\n-                       -> Result<R, String>\n-where R: 'static + Send, F: 'static + Send + FnOnce(Output, &getopts::Matches) -> R {\n-    match matches.opt_str(\"r\").as_ref().map(|s| &**s) {\n-        Some(\"rust\") => Ok(rust_input(input, externs, edition, cg, matches, error_format, f)),\n-        Some(s) => Err(format!(\"unknown input format: {}\", s)),\n-        None => Ok(rust_input(input, externs, edition, cg, matches, error_format, f))\n-    }\n-}\n-\n-/// Extracts `--extern CRATE=PATH` arguments from `matches` and\n-/// returns a map mapping crate names to their paths or else an\n-/// error message.\n-// FIXME(eddyb) This shouldn't be duplicated with `rustc::session`.\n-fn parse_externs(matches: &getopts::Matches) -> Result<Externs, String> {\n-    let mut externs: BTreeMap<_, BTreeSet<_>> = BTreeMap::new();\n-    for arg in &matches.opt_strs(\"extern\") {\n-        let mut parts = arg.splitn(2, '=');\n-        let name = parts.next().ok_or(\"--extern value must not be empty\".to_string())?;\n-        let location = parts.next().map(|s| s.to_string());\n-        if location.is_none() && !nightly_options::is_unstable_enabled(matches) {\n-            return Err(\"the `-Z unstable-options` flag must also be passed to \\\n-                        enable `--extern crate_name` without `=path`\".to_string());\n-        }\n-        let name = name.to_string();\n-        externs.entry(name).or_default().insert(location);\n-    }\n-    Ok(Externs::new(externs))\n-}\n-\n-/// Extracts `--extern-html-root-url` arguments from `matches` and returns a map of crate names to\n-/// the given URLs. If an `--extern-html-root-url` argument was ill-formed, returns an error\n-/// describing the issue.\n-fn parse_extern_html_roots(matches: &getopts::Matches)\n-    -> Result<BTreeMap<String, String>, &'static str>\n-{\n-    let mut externs = BTreeMap::new();\n-    for arg in &matches.opt_strs(\"extern-html-root-url\") {\n-        let mut parts = arg.splitn(2, '=');\n-        let name = parts.next().ok_or(\"--extern-html-root-url must not be empty\")?;\n-        let url = parts.next().ok_or(\"--extern-html-root-url must be of the form name=url\")?;\n-        externs.insert(name.to_string(), url.to_string());\n-    }\n-\n-    Ok(externs)\n-}\n-\n /// Interprets the input file as a rust source file, passing it through the\n /// compiler all the way through the analysis passes. The rustdoc output is then\n /// generated from the cleaned AST of the crate.\n ///\n /// This form of input will run all of the plug/cleaning passes\n-fn rust_input<R, F>(cratefile: PathBuf,\n-                    externs: Externs,\n-                    edition: Edition,\n-                    cg: CodegenOptions,\n-                    matches: getopts::Matches,\n-                    error_format: ErrorOutputType,\n-                    f: F) -> R\n+fn rust_input<R, F>(options: config::Options, f: F) -> R\n where R: 'static + Send,\n-      F: 'static + Send + FnOnce(Output, &getopts::Matches) -> R\n+      F: 'static + Send + FnOnce(Output) -> R\n {\n-    let default_passes = if matches.opt_present(\"no-defaults\") {\n-        passes::DefaultPassOption::None\n-    } else if matches.opt_present(\"document-private-items\") {\n-        passes::DefaultPassOption::Private\n-    } else {\n-        passes::DefaultPassOption::Default\n-    };\n-\n-    let manual_passes = matches.opt_strs(\"passes\");\n-    let plugins = matches.opt_strs(\"plugins\");\n-\n     // First, parse the crate and extract all relevant information.\n-    let mut paths = SearchPaths::new();\n-    for s in &matches.opt_strs(\"L\") {\n-        paths.add_path(s, ErrorOutputType::default());\n-    }\n-    let mut cfgs = matches.opt_strs(\"cfg\");\n-    cfgs.push(\"rustdoc\".to_string());\n-    let triple = matches.opt_str(\"target\").map(|target| {\n-        if target.ends_with(\".json\") {\n-            TargetTriple::TargetPath(PathBuf::from(target))\n-        } else {\n-            TargetTriple::TargetTriple(target)\n-        }\n-    });\n-    let maybe_sysroot = matches.opt_str(\"sysroot\").map(PathBuf::from);\n-    let crate_name = matches.opt_str(\"crate-name\");\n-    let crate_version = matches.opt_str(\"crate-version\");\n-    let plugin_path = matches.opt_str(\"plugin-path\");\n-\n     info!(\"starting to run rustc\");\n-    let display_warnings = matches.opt_present(\"display-warnings\");\n-\n-    let force_unstable_if_unmarked = matches.opt_strs(\"Z\").iter().any(|x| {\n-        *x == \"force-unstable-if-unmarked\"\n-    });\n-    let treat_err_as_bug = matches.opt_strs(\"Z\").iter().any(|x| {\n-        *x == \"treat-err-as-bug\"\n-    });\n-    let ui_testing = matches.opt_strs(\"Z\").iter().any(|x| {\n-        *x == \"ui-testing\"\n-    });\n-\n-    let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(&matches, error_format);\n \n     let (tx, rx) = channel();\n \n     let result = rustc_driver::monitor(move || syntax::with_globals(move || {\n-        use rustc::session::config::Input;\n-\n-        let (mut krate, renderinfo, passes) =\n-            core::run_core(paths, cfgs, externs, Input::File(cratefile), triple, maybe_sysroot,\n-                           display_warnings, crate_name.clone(),\n-                           force_unstable_if_unmarked, edition, cg, error_format,\n-                           lint_opts, lint_cap, describe_lints, manual_passes, default_passes,\n-                           treat_err_as_bug, ui_testing);\n+        let crate_name = options.crate_name.clone();\n+        let crate_version = options.crate_version.clone();\n+        let (mut krate, renderinfo, renderopts, passes) = core::run_core(options);\n \n         info!(\"finished with rustc\");\n \n@@ -753,14 +419,6 @@ where R: 'static + Send,\n \n         krate.version = crate_version;\n \n-        if !plugins.is_empty() {\n-            eprintln!(\"WARNING: --plugins no longer functions; see CVE-2018-1000622\");\n-        }\n-\n-        if !plugin_path.is_none() {\n-            eprintln!(\"WARNING: --plugin-path no longer functions; see CVE-2018-1000622\");\n-        }\n-\n         info!(\"Executing passes\");\n \n         for pass in &passes {\n@@ -783,36 +441,16 @@ where R: 'static + Send,\n             krate = pass(krate);\n         }\n \n-        tx.send(f(Output { krate: krate, renderinfo: renderinfo, passes: passes },\n-                  &matches)).unwrap();\n+        tx.send(f(Output {\n+            krate: krate,\n+            renderinfo: renderinfo,\n+            renderopts,\n+            passes: passes\n+        })).unwrap();\n     }));\n \n     match result {\n         Ok(()) => rx.recv().unwrap(),\n         Err(_) => panic::resume_unwind(Box::new(errors::FatalErrorMarker)),\n     }\n }\n-\n-/// Prints deprecation warnings for deprecated options\n-fn check_deprecated_options(matches: &getopts::Matches, diag: &errors::Handler) {\n-    let deprecated_flags = [\n-       \"input-format\",\n-       \"output-format\",\n-       \"no-defaults\",\n-       \"passes\",\n-    ];\n-\n-    for flag in deprecated_flags.into_iter() {\n-        if matches.opt_present(flag) {\n-            let mut err = diag.struct_warn(&format!(\"the '{}' flag is considered deprecated\",\n-                                                    flag));\n-            err.warn(\"please see https://github.com/rust-lang/rust/issues/44136\");\n-\n-            if *flag == \"no-defaults\" {\n-                err.help(\"you may want to use --document-private-items\");\n-            }\n-\n-            err.emit();\n-        }\n-    }\n-}"}, {"sha": "8008f8848d45d054f0c80b68820350005f8a6e98", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1", "patch": "@@ -11,20 +11,17 @@\n use std::default::Default;\n use std::fs::File;\n use std::io::prelude::*;\n-use std::path::{PathBuf, Path};\n+use std::path::PathBuf;\n use std::cell::RefCell;\n \n use errors;\n-use getopts;\n use testing;\n-use rustc::session::search_paths::SearchPaths;\n-use rustc::session::config::{Externs, CodegenOptions};\n use syntax::source_map::DUMMY_SP;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax::edition::Edition;\n \n-use externalfiles::{ExternalHtml, LoadStringError, load_string};\n+use externalfiles::{LoadStringError, load_string};\n \n+use config::{Options, RenderOptions};\n use html::escape::Escape;\n use html::markdown;\n use html::markdown::{ErrorCodes, IdMap, Markdown, MarkdownWithToc, find_testable_code};\n@@ -51,24 +48,25 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n \n /// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n /// (e.g. output = \"bar\" => \"bar/foo.html\").\n-pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n-              external_html: &ExternalHtml, include_toc: bool, diag: &errors::Handler) -> isize {\n+pub fn render(input: PathBuf, options: RenderOptions, diag: &errors::Handler) -> isize {\n+    let mut output = options.output;\n     output.push(input.file_stem().unwrap());\n     output.set_extension(\"html\");\n \n     let mut css = String::new();\n-    for name in &matches.opt_strs(\"markdown-css\") {\n+    for name in &options.markdown_css {\n         let s = format!(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\\n\", name);\n         css.push_str(&s)\n     }\n \n-    let input_str = match load_string(input, diag) {\n+    let input_str = match load_string(&input, diag) {\n         Ok(s) => s,\n         Err(LoadStringError::ReadFail) => return 1,\n         Err(LoadStringError::BadUtf8) => return 2,\n     };\n-    if let Some(playground) = matches.opt_str(\"markdown-playground-url\").or(\n-                              matches.opt_str(\"playground-url\")) {\n+    let playground_url = options.markdown_playground_url\n+                            .or(options.playground_url);\n+    if let Some(playground) = playground_url {\n         markdown::PLAYGROUND.with(|s| { *s.borrow_mut() = Some((None, playground)); });\n     }\n \n@@ -89,7 +87,7 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n \n     let mut ids = IdMap::new();\n     let error_codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n-    let text = if include_toc {\n+    let text = if !options.markdown_no_toc {\n         MarkdownWithToc(text, RefCell::new(&mut ids), error_codes).to_string()\n     } else {\n         Markdown(text, &[], RefCell::new(&mut ids), error_codes).to_string()\n@@ -124,10 +122,10 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n </html>\"#,\n         title = Escape(title),\n         css = css,\n-        in_header = external_html.in_header,\n-        before_content = external_html.before_content,\n+        in_header = options.external_html.in_header,\n+        before_content = options.external_html.before_content,\n         text = text,\n-        after_content = external_html.after_content,\n+        after_content = options.external_html.after_content,\n     );\n \n     match err {\n@@ -140,31 +138,29 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n }\n \n /// Run any tests/code examples in the markdown file `input`.\n-pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n-            mut test_args: Vec<String>, maybe_sysroot: Option<PathBuf>,\n-            display_warnings: bool, linker: Option<PathBuf>, edition: Edition,\n-            cg: CodegenOptions, diag: &errors::Handler) -> isize {\n-    let input_str = match load_string(input, diag) {\n+pub fn test(mut options: Options, diag: &errors::Handler) -> isize {\n+    let input_str = match load_string(&options.input, diag) {\n         Ok(s) => s,\n         Err(LoadStringError::ReadFail) => return 1,\n         Err(LoadStringError::BadUtf8) => return 2,\n     };\n \n     let mut opts = TestOptions::default();\n     opts.no_crate_inject = true;\n-    opts.display_warnings = display_warnings;\n-    let mut collector = Collector::new(input.to_owned(), cfgs, libs, cg, externs,\n-                                       true, opts, maybe_sysroot, None,\n-                                       Some(PathBuf::from(input)),\n-                                       linker, edition);\n+    opts.display_warnings = options.display_warnings;\n+    let mut collector = Collector::new(options.input.display().to_string(), options.cfgs,\n+                                       options.libs, options.codegen_options, options.externs,\n+                                       true, opts, options.maybe_sysroot, None,\n+                                       Some(options.input),\n+                                       options.linker, options.edition);\n     collector.set_position(DUMMY_SP);\n     let codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n     let res = find_testable_code(&input_str, &mut collector, codes);\n     if let Err(err) = res {\n         diag.span_warn(DUMMY_SP, &err.to_string());\n     }\n-    test_args.insert(0, \"rustdoctest\".to_string());\n-    testing::test_main(&test_args, collector.tests,\n-                       testing::Options::new().display_output(display_warnings));\n+    options.test_args.insert(0, \"rustdoctest\".to_string());\n+    testing::test_main(&options.test_args, collector.tests,\n+                       testing::Options::new().display_output(options.display_warnings));\n     0\n }"}, {"sha": "d9bab91fd0c7892b8b79e70333f7a16b84035e90", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1", "patch": "@@ -12,7 +12,7 @@ use std::env;\n use std::ffi::OsString;\n use std::io::prelude::*;\n use std::io;\n-use std::path::{Path, PathBuf};\n+use std::path::PathBuf;\n use std::panic::{self, AssertUnwindSafe};\n use std::process::Command;\n use std::str;\n@@ -42,6 +42,7 @@ use errors;\n use errors::emitter::ColorConfig;\n \n use clean::Attributes;\n+use config::Options;\n use html::markdown::{self, ErrorCodes, LangString};\n \n #[derive(Clone, Default)]\n@@ -55,34 +56,23 @@ pub struct TestOptions {\n     pub attrs: Vec<String>,\n }\n \n-pub fn run(input_path: &Path,\n-           cfgs: Vec<String>,\n-           libs: SearchPaths,\n-           externs: Externs,\n-           mut test_args: Vec<String>,\n-           crate_name: Option<String>,\n-           maybe_sysroot: Option<PathBuf>,\n-           display_warnings: bool,\n-           linker: Option<PathBuf>,\n-           edition: Edition,\n-           cg: CodegenOptions)\n-           -> isize {\n-    let input = config::Input::File(input_path.to_owned());\n+pub fn run(mut options: Options) -> isize {\n+    let input = config::Input::File(options.input.clone());\n \n     let sessopts = config::Options {\n-        maybe_sysroot: maybe_sysroot.clone().or_else(\n+        maybe_sysroot: options.maybe_sysroot.clone().or_else(\n             || Some(env::current_exe().unwrap().parent().unwrap().parent().unwrap().to_path_buf())),\n-        search_paths: libs.clone(),\n+        search_paths: options.libs.clone(),\n         crate_types: vec![config::CrateType::Dylib],\n-        cg: cg.clone(),\n-        externs: externs.clone(),\n+        cg: options.codegen_options.clone(),\n+        externs: options.externs.clone(),\n         unstable_features: UnstableFeatures::from_environment(),\n         lint_cap: Some(::rustc::lint::Level::Allow),\n         actually_rustdoc: true,\n         debugging_opts: config::DebuggingOptions {\n             ..config::basic_debugging_options()\n         },\n-        edition,\n+        edition: options.edition,\n         ..config::Options::default()\n     };\n     driver::spawn_thread_pool(sessopts, |sessopts| {\n@@ -93,13 +83,14 @@ pub fn run(input_path: &Path,\n                                             Some(source_map.clone()));\n \n         let mut sess = session::build_session_(\n-            sessopts, Some(input_path.to_owned()), handler, source_map.clone(),\n+            sessopts, Some(options.input), handler, source_map.clone(),\n         );\n         let codegen_backend = rustc_driver::get_codegen_backend(&sess);\n         let cstore = CStore::new(codegen_backend.metadata_loader());\n         rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n-        let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n+        let mut cfg = config::build_configuration(&sess,\n+                                                  config::parse_cfgspecs(options.cfgs.clone()));\n         target_features::add_configuration(&mut cfg, &sess, &*codegen_backend);\n         sess.parse_sess.config = cfg;\n \n@@ -119,24 +110,24 @@ pub fn run(input_path: &Path,\n             ).expect(\"phase_2_configure_and_expand aborted in rustdoc!\")\n         };\n \n-        let crate_name = crate_name.unwrap_or_else(|| {\n+        let crate_name = options.crate_name.unwrap_or_else(|| {\n             ::rustc_codegen_utils::link::find_crate_name(None, &hir_forest.krate().attrs, &input)\n         });\n         let mut opts = scrape_test_config(hir_forest.krate());\n-        opts.display_warnings |= display_warnings;\n+        opts.display_warnings |= options.display_warnings;\n         let mut collector = Collector::new(\n             crate_name,\n-            cfgs,\n-            libs,\n-            cg,\n-            externs,\n+            options.cfgs,\n+            options.libs,\n+            options.codegen_options,\n+            options.externs,\n             false,\n             opts,\n-            maybe_sysroot,\n+            options.maybe_sysroot,\n             Some(source_map),\n-             None,\n-            linker,\n-            edition\n+            None,\n+            options.linker,\n+            options.edition\n         );\n \n         {\n@@ -153,11 +144,11 @@ pub fn run(input_path: &Path,\n             });\n         }\n \n-        test_args.insert(0, \"rustdoctest\".to_string());\n+        options.test_args.insert(0, \"rustdoctest\".to_string());\n \n-        testing::test_main(&test_args,\n+        testing::test_main(&options.test_args,\n                         collector.tests.into_iter().collect(),\n-                        testing::Options::new().display_output(display_warnings));\n+                        testing::Options::new().display_output(options.display_warnings));\n         0\n     })\n }"}, {"sha": "527f1355a9ef716970daf46650e748d219a4a8ba", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1", "patch": "@@ -12,7 +12,7 @@ error[E0425]: cannot find value `no` in this scope\n 3 | no\n   | ^^ not found in this scope\n \n-thread '$DIR/failed-doctest-output.rs - OtherStruct (line 27)' panicked at 'couldn't compile the test', librustdoc/test.rs:332:13\n+thread '$DIR/failed-doctest-output.rs - OtherStruct (line 27)' panicked at 'couldn't compile the test', librustdoc/test.rs:323:13\n note: Run with `RUST_BACKTRACE=1` for a backtrace.\n \n ---- $DIR/failed-doctest-output.rs - SomeStruct (line 21) stdout ----\n@@ -21,7 +21,7 @@ thread '$DIR/failed-doctest-output.rs - SomeStruct (line 21)' panicked at 'test\n thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:3:1\n note: Run with `RUST_BACKTRACE=1` for a backtrace.\n \n-', librustdoc/test.rs:367:17\n+', librustdoc/test.rs:358:17\n \n \n failures:"}]}