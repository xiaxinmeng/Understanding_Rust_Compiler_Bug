{"sha": "a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNjRmNWI3ZThkZjM0YzRiZjdmMTBkMGM2YzdmOWFiODA1ZWU2NzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-22T10:41:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-22T10:41:29Z"}, "message": "Auto merge of #33089 - nrc:hir-name-res, r=eddyb\n\nMove def id collection and extern crate handling to before AST->HIR lowering\n\nr? @jseyfried, @eddyb, or @nikomatsakis", "tree": {"sha": "743248e467259818ca3117fc86c445fa1ef12430", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/743248e467259818ca3117fc86c445fa1ef12430"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "html_url": "https://github.com/rust-lang/rust/commit/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "887e9471783ff3f5edc920a85b6110486dc063c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/887e9471783ff3f5edc920a85b6110486dc063c0", "html_url": "https://github.com/rust-lang/rust/commit/887e9471783ff3f5edc920a85b6110486dc063c0"}, {"sha": "0be3c8c56977c1f0d875461279e00bca7b4e5ebf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0be3c8c56977c1f0d875461279e00bca7b4e5ebf", "html_url": "https://github.com/rust-lang/rust/commit/0be3c8c56977c1f0d875461279e00bca7b4e5ebf"}], "stats": {"total": 1203, "additions": 765, "deletions": 438}, "files": [{"sha": "0a01cc91f0e30a05443633004f589f76fde33b63", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 148, "deletions": 70, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -62,6 +62,9 @@\n // in the HIR, especially for multiple identifiers.\n \n use hir;\n+use hir::map::Definitions;\n+use hir::map::definitions::DefPathData;\n+use hir::def_id::DefIndex;\n \n use std::collections::BTreeMap;\n use std::collections::HashMap;\n@@ -92,10 +95,20 @@ pub struct LoweringContext<'a> {\n     // A copy of cached_id, but is also set to an id while a node is lowered for\n     // the first time.\n     gensym_key: Cell<u32>,\n+    // We must keep the set of definitions up to date as we add nodes that\n+    // weren't in the AST.\n+    definitions: Option<&'a RefCell<Definitions>>,\n+    // As we walk the AST we must keep track of the current 'parent' def id (in\n+    // the form of a DefIndex) so that if we create a new node which introduces\n+    // a definition, then we can properly create the def id.\n+    parent_def: Cell<Option<DefIndex>>,\n }\n \n impl<'a, 'hir> LoweringContext<'a> {\n-    pub fn new(id_assigner: &'a NodeIdAssigner, c: Option<&Crate>) -> LoweringContext<'a> {\n+    pub fn new(id_assigner: &'a NodeIdAssigner,\n+               c: Option<&Crate>,\n+               defs: &'a RefCell<Definitions>)\n+               -> LoweringContext<'a> {\n         let crate_root = c.and_then(|c| {\n             if std_inject::no_core(c) {\n                 None\n@@ -113,6 +126,23 @@ impl<'a, 'hir> LoweringContext<'a> {\n             cached_id: Cell::new(0),\n             gensym_cache: RefCell::new(HashMap::new()),\n             gensym_key: Cell::new(0),\n+            definitions: Some(defs),\n+            parent_def: Cell::new(None),\n+        }\n+    }\n+\n+    // Only use this when you want a LoweringContext for testing and won't look\n+    // up def ids for anything created during lowering.\n+    pub fn testing_context(id_assigner: &'a NodeIdAssigner) -> LoweringContext<'a> {\n+        LoweringContext {\n+            crate_root: None,\n+            id_cache: RefCell::new(HashMap::new()),\n+            id_assigner: id_assigner,\n+            cached_id: Cell::new(0),\n+            gensym_cache: RefCell::new(HashMap::new()),\n+            gensym_key: Cell::new(0),\n+            definitions: None,\n+            parent_def: Cell::new(None),\n         }\n     }\n \n@@ -146,6 +176,25 @@ impl<'a, 'hir> LoweringContext<'a> {\n     fn diagnostic(&self) -> &Handler {\n         self.id_assigner.diagnostic()\n     }\n+\n+    fn with_parent_def<T, F: FnOnce() -> T>(&self, parent_id: NodeId, f: F) -> T {\n+        if self.definitions.is_none() {\n+            // This should only be used for testing.\n+            return f();\n+        }\n+\n+        let old_def = self.parent_def.get();\n+        self.parent_def.set(Some(self.get_def(parent_id)));\n+        let result = f();\n+        self.parent_def.set(old_def);\n+\n+        result\n+    }\n+\n+    fn get_def(&self, id: NodeId) -> DefIndex {\n+        let defs = self.definitions.unwrap().borrow();\n+        defs.opt_def_index(id).unwrap()\n+    }\n }\n \n // Utility fn for setting and unsetting the cached id.\n@@ -733,47 +782,51 @@ pub fn lower_item_kind(lctx: &LoweringContext, i: &ItemKind) -> hir::Item_ {\n }\n \n pub fn lower_trait_item(lctx: &LoweringContext, i: &TraitItem) -> hir::TraitItem {\n-    hir::TraitItem {\n-        id: i.id,\n-        name: i.ident.name,\n-        attrs: lower_attrs(lctx, &i.attrs),\n-        node: match i.node {\n-            TraitItemKind::Const(ref ty, ref default) => {\n-                hir::ConstTraitItem(lower_ty(lctx, ty),\n-                                    default.as_ref().map(|x| lower_expr(lctx, x)))\n-            }\n-            TraitItemKind::Method(ref sig, ref body) => {\n-                hir::MethodTraitItem(lower_method_sig(lctx, sig),\n-                                     body.as_ref().map(|x| lower_block(lctx, x)))\n-            }\n-            TraitItemKind::Type(ref bounds, ref default) => {\n-                hir::TypeTraitItem(lower_bounds(lctx, bounds),\n-                                   default.as_ref().map(|x| lower_ty(lctx, x)))\n-            }\n-        },\n-        span: i.span,\n-    }\n+    lctx.with_parent_def(i.id, || {\n+        hir::TraitItem {\n+            id: i.id,\n+            name: i.ident.name,\n+            attrs: lower_attrs(lctx, &i.attrs),\n+            node: match i.node {\n+                TraitItemKind::Const(ref ty, ref default) => {\n+                    hir::ConstTraitItem(lower_ty(lctx, ty),\n+                                        default.as_ref().map(|x| lower_expr(lctx, x)))\n+                }\n+                TraitItemKind::Method(ref sig, ref body) => {\n+                    hir::MethodTraitItem(lower_method_sig(lctx, sig),\n+                                         body.as_ref().map(|x| lower_block(lctx, x)))\n+                }\n+                TraitItemKind::Type(ref bounds, ref default) => {\n+                    hir::TypeTraitItem(lower_bounds(lctx, bounds),\n+                                       default.as_ref().map(|x| lower_ty(lctx, x)))\n+                }\n+            },\n+            span: i.span,\n+        }\n+    })\n }\n \n pub fn lower_impl_item(lctx: &LoweringContext, i: &ImplItem) -> hir::ImplItem {\n-    hir::ImplItem {\n-        id: i.id,\n-        name: i.ident.name,\n-        attrs: lower_attrs(lctx, &i.attrs),\n-        vis: lower_visibility(lctx, &i.vis),\n-        defaultness: lower_defaultness(lctx, i.defaultness),\n-        node: match i.node {\n-            ImplItemKind::Const(ref ty, ref expr) => {\n-                hir::ImplItemKind::Const(lower_ty(lctx, ty), lower_expr(lctx, expr))\n-            }\n-            ImplItemKind::Method(ref sig, ref body) => {\n-                hir::ImplItemKind::Method(lower_method_sig(lctx, sig), lower_block(lctx, body))\n-            }\n-            ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(lower_ty(lctx, ty)),\n-            ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n-        },\n-        span: i.span,\n-    }\n+    lctx.with_parent_def(i.id, || {\n+        hir::ImplItem {\n+            id: i.id,\n+            name: i.ident.name,\n+            attrs: lower_attrs(lctx, &i.attrs),\n+            vis: lower_visibility(lctx, &i.vis),\n+            defaultness: lower_defaultness(lctx, i.defaultness),\n+            node: match i.node {\n+                ImplItemKind::Const(ref ty, ref expr) => {\n+                    hir::ImplItemKind::Const(lower_ty(lctx, ty), lower_expr(lctx, expr))\n+                }\n+                ImplItemKind::Method(ref sig, ref body) => {\n+                    hir::ImplItemKind::Method(lower_method_sig(lctx, sig), lower_block(lctx, body))\n+                }\n+                ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(lower_ty(lctx, ty)),\n+                ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n+            },\n+            span: i.span,\n+        }\n+    })\n }\n \n pub fn lower_mod(lctx: &LoweringContext, m: &Mod) -> hir::Mod {\n@@ -831,7 +884,9 @@ pub fn lower_item_id(_lctx: &LoweringContext, i: &Item) -> hir::ItemId {\n }\n \n pub fn lower_item(lctx: &LoweringContext, i: &Item) -> hir::Item {\n-    let node = lower_item_kind(lctx, &i.node);\n+    let node = lctx.with_parent_def(i.id, || {\n+        lower_item_kind(lctx, &i.node)\n+    });\n \n     hir::Item {\n         id: i.id,\n@@ -844,21 +899,23 @@ pub fn lower_item(lctx: &LoweringContext, i: &Item) -> hir::Item {\n }\n \n pub fn lower_foreign_item(lctx: &LoweringContext, i: &ForeignItem) -> hir::ForeignItem {\n-    hir::ForeignItem {\n-        id: i.id,\n-        name: i.ident.name,\n-        attrs: lower_attrs(lctx, &i.attrs),\n-        node: match i.node {\n-            ForeignItemKind::Fn(ref fdec, ref generics) => {\n-                hir::ForeignItemFn(lower_fn_decl(lctx, fdec), lower_generics(lctx, generics))\n-            }\n-            ForeignItemKind::Static(ref t, m) => {\n-                hir::ForeignItemStatic(lower_ty(lctx, t), m)\n-            }\n-        },\n-        vis: lower_visibility(lctx, &i.vis),\n-        span: i.span,\n-    }\n+    lctx.with_parent_def(i.id, || {\n+        hir::ForeignItem {\n+            id: i.id,\n+            name: i.ident.name,\n+            attrs: lower_attrs(lctx, &i.attrs),\n+            node: match i.node {\n+                ForeignItemKind::Fn(ref fdec, ref generics) => {\n+                    hir::ForeignItemFn(lower_fn_decl(lctx, fdec), lower_generics(lctx, generics))\n+                }\n+                ForeignItemKind::Static(ref t, m) => {\n+                    hir::ForeignItemStatic(lower_ty(lctx, t), m)\n+                }\n+            },\n+            vis: lower_visibility(lctx, &i.vis),\n+            span: i.span,\n+        }\n+    })\n }\n \n pub fn lower_method_sig(lctx: &LoweringContext, sig: &MethodSig) -> hir::MethodSig {\n@@ -926,9 +983,11 @@ pub fn lower_pat(lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n         node: match p.node {\n             PatKind::Wild => hir::PatKind::Wild,\n             PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n-                hir::PatKind::Ident(lower_binding_mode(lctx, binding_mode),\n-                              respan(pth1.span, lower_ident(lctx, pth1.node)),\n-                              sub.as_ref().map(|x| lower_pat(lctx, x)))\n+                lctx.with_parent_def(p.id, || {\n+                    hir::PatKind::Ident(lower_binding_mode(lctx, binding_mode),\n+                                  respan(pth1.span, lower_ident(lctx, pth1.node)),\n+                                  sub.as_ref().map(|x| lower_pat(lctx, x)))\n+                })\n             }\n             PatKind::Lit(ref e) => hir::PatKind::Lit(lower_expr(lctx, e)),\n             PatKind::TupleStruct(ref pth, ref pats) => {\n@@ -1202,9 +1261,11 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                hir::MatchSource::Normal)\n             }\n             ExprKind::Closure(capture_clause, ref decl, ref body) => {\n-                hir::ExprClosure(lower_capture_clause(lctx, capture_clause),\n-                                 lower_fn_decl(lctx, decl),\n-                                 lower_block(lctx, body))\n+                lctx.with_parent_def(e.id, || {\n+                    hir::ExprClosure(lower_capture_clause(lctx, capture_clause),\n+                                     lower_fn_decl(lctx, decl),\n+                                     lower_block(lctx, body))\n+                })\n             }\n             ExprKind::Block(ref blk) => hir::ExprBlock(lower_block(lctx, blk)),\n             ExprKind::Assign(ref el, ref er) => {\n@@ -1602,7 +1663,12 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     // `{ let _result = ...; _result }`\n                     // underscore prevents an unused_variables lint if the head diverges\n                     let result_ident = lctx.str_to_ident(\"_result\");\n-                    let let_stmt = stmt_let(lctx, e.span, false, result_ident, match_expr, None);\n+                    let let_stmt = stmt_let(lctx,\n+                                            e.span,\n+                                            false,\n+                                            result_ident,\n+                                            match_expr,\n+                                            None);\n                     let result = expr_ident(lctx, e.span, result_ident, None);\n                     let block = block_all(lctx, e.span, hir_vec![let_stmt], Some(result));\n                     // add the attributes to the outer returned expr node\n@@ -1655,7 +1721,8 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                             let err_ctor = expr_path(lctx, path, None);\n                             expr_call(lctx, e.span, err_ctor, hir_vec![from_expr], None)\n                         };\n-                        let err_pat = pat_err(lctx, e.span, pat_ident(lctx, e.span, err_ident));\n+                        let err_pat = pat_err(lctx, e.span,\n+                                              pat_ident(lctx, e.span, err_ident));\n                         let ret_expr = expr(lctx, e.span,\n                                             hir::Expr_::ExprRet(Some(err_expr)), None);\n \n@@ -1938,12 +2005,22 @@ fn pat_ident_binding_mode(lctx: &LoweringContext,\n                           bm: hir::BindingMode)\n                           -> P<hir::Pat> {\n     let pat_ident = hir::PatKind::Ident(bm,\n-                                  Spanned {\n-                                      span: span,\n-                                      node: ident,\n-                                  },\n-                                  None);\n-    pat(lctx, span, pat_ident)\n+                                        Spanned {\n+                                            span: span,\n+                                            node: ident,\n+                                        },\n+                                        None);\n+\n+    let pat = pat(lctx, span, pat_ident);\n+\n+    if let Some(defs) = lctx.definitions {\n+        let mut defs = defs.borrow_mut();\n+        defs.create_def_with_parent(lctx.parent_def.get(),\n+                                    pat.id,\n+                                    DefPathData::Binding(ident.name));\n+    }\n+\n+    pat\n }\n \n fn pat_wild(lctx: &LoweringContext, span: Span) -> P<hir::Pat> {\n@@ -2130,7 +2207,8 @@ mod test {\n         let ast_in = quote_expr!(&cx, in HEAP { foo() });\n         let ast_in = assigner.fold_expr(ast_in);\n \n-        let lctx = LoweringContext::new(&assigner, None);\n+        let lctx = LoweringContext::testing_context(&assigner);\n+\n         let hir1 = lower_expr(&lctx, &ast_if_let);\n         let hir2 = lower_expr(&lctx, &ast_if_let);\n         assert!(hir1 == hir2);"}, {"sha": "9f55f46541cfde4c007f99fb587ad0173e1cc42e", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 68, "deletions": 201, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015-2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,18 +13,16 @@ use super::MapEntry::*;\n \n use hir::*;\n use hir::intravisit::Visitor;\n-use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n+use hir::def_id::DefId;\n use middle::cstore::InlinedItem;\n use std::iter::repeat;\n-use syntax::ast::{NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n+use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax::codemap::Span;\n \n-/// A Visitor that walks over an AST and collects Node's into an AST\n-/// Map.\n+/// A Visitor that walks over the HIR and collects Node's into a HIR map.\n pub struct NodeCollector<'ast> {\n     pub krate: &'ast Crate,\n     pub map: Vec<MapEntry<'ast>>,\n-    pub definitions: Definitions,\n     pub parent_node: NodeId,\n }\n \n@@ -33,16 +31,10 @@ impl<'ast> NodeCollector<'ast> {\n         let mut collector = NodeCollector {\n             krate: krate,\n             map: vec![],\n-            definitions: Definitions::new(),\n             parent_node: CRATE_NODE_ID,\n         };\n         collector.insert_entry(CRATE_NODE_ID, RootCrate);\n \n-        let result = collector.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n-        assert_eq!(result, CRATE_DEF_INDEX);\n-\n-        collector.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n-\n         collector\n     }\n \n@@ -51,53 +43,20 @@ impl<'ast> NodeCollector<'ast> {\n                   parent_node: NodeId,\n                   parent_def_path: DefPath,\n                   parent_def_id: DefId,\n-                  map: Vec<MapEntry<'ast>>,\n-                  definitions: Definitions)\n+                  map: Vec<MapEntry<'ast>>)\n                   -> NodeCollector<'ast> {\n         let mut collector = NodeCollector {\n             krate: krate,\n             map: map,\n             parent_node: parent_node,\n-            definitions: definitions,\n         };\n \n         assert_eq!(parent_def_path.krate, parent_def_id.krate);\n-        let root_path = Box::new(InlinedRootPath {\n-            data: parent_def_path.data,\n-            def_id: parent_def_id,\n-        });\n-\n         collector.insert_entry(parent_node, RootInlinedParent(parent));\n-        collector.create_def(parent_node, DefPathData::InlinedRoot(root_path));\n \n         collector\n     }\n \n-    fn parent_def(&self) -> Option<DefIndex> {\n-        let mut parent_node = Some(self.parent_node);\n-        while let Some(p) = parent_node {\n-            if let Some(q) = self.definitions.opt_def_index(p) {\n-                return Some(q);\n-            }\n-            parent_node = self.map[p as usize].parent_node();\n-        }\n-        None\n-    }\n-\n-    fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n-        let parent_def = self.parent_def();\n-        debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n-        self.definitions.create_def_with_parent(parent_def, node_id, data)\n-    }\n-\n-    fn create_def_with_parent(&mut self,\n-                              parent: Option<DefIndex>,\n-                              node_id: NodeId,\n-                              data: DefPathData)\n-                              -> DefIndex {\n-        self.definitions.create_def_with_parent(parent, node_id, data)\n-    }\n-\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n         debug!(\"ast_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n@@ -107,15 +66,17 @@ impl<'ast> NodeCollector<'ast> {\n         self.map[id as usize] = entry;\n     }\n \n-    fn insert_def(&mut self, id: NodeId, node: Node<'ast>, data: DefPathData) -> DefIndex {\n-        self.insert(id, node);\n-        self.create_def(id, data)\n-    }\n-\n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n         let entry = MapEntry::from_node(self.parent_node, node);\n         self.insert_entry(id, entry);\n     }\n+\n+    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_id: NodeId, f: F) {\n+        let parent_node = self.parent_node;\n+        self.parent_node = parent_id;\n+        f(self);\n+        self.parent_node = parent_node;\n+    }\n }\n \n impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n@@ -130,188 +91,104 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     fn visit_item(&mut self, i: &'ast Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n-        // Pick the def data. This need not be unique, but the more\n-        // information we encapsulate into\n-        let def_data = match i.node {\n-            ItemDefaultImpl(..) | ItemImpl(..) =>\n-                DefPathData::Impl,\n-            ItemEnum(..) | ItemStruct(..) | ItemTrait(..) |\n-            ItemExternCrate(..) | ItemForeignMod(..) | ItemTy(..) =>\n-                DefPathData::TypeNs(i.name),\n-            ItemMod(..) =>\n-                DefPathData::Module(i.name),\n-            ItemStatic(..) | ItemConst(..) | ItemFn(..) =>\n-                DefPathData::ValueNs(i.name),\n-            ItemUse(..) =>\n-                DefPathData::Misc,\n-        };\n-\n-        self.insert_def(i.id, NodeItem(i), def_data);\n+        self.insert(i.id, NodeItem(i));\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = i.id;\n-\n-        match i.node {\n-            ItemImpl(..) => {}\n-            ItemEnum(ref enum_definition, _) => {\n-                for v in &enum_definition.variants {\n-                    let variant_def_index =\n-                        self.insert_def(v.node.data.id(),\n-                                        NodeVariant(v),\n-                                        DefPathData::EnumVariant(v.node.name));\n-\n-                    for field in v.node.data.fields() {\n-                        self.create_def_with_parent(\n-                            Some(variant_def_index),\n-                            field.id,\n-                            DefPathData::Field(field.name));\n+        self.with_parent(i.id, |this| {\n+            match i.node {\n+                ItemEnum(ref enum_definition, _) => {\n+                    for v in &enum_definition.variants {\n+                        this.insert(v.node.data.id(), NodeVariant(v));\n                     }\n                 }\n-            }\n-            ItemForeignMod(..) => {\n-            }\n-            ItemStruct(ref struct_def, _) => {\n-                // If this is a tuple-like struct, register the constructor.\n-                if !struct_def.is_struct() {\n-                    self.insert_def(struct_def.id(),\n-                                    NodeStructCtor(struct_def),\n-                                    DefPathData::StructCtor);\n-                }\n-\n-                for field in struct_def.fields() {\n-                    self.create_def(field.id, DefPathData::Field(field.name));\n+                ItemStruct(ref struct_def, _) => {\n+                    // If this is a tuple-like struct, register the constructor.\n+                    if !struct_def.is_struct() {\n+                        this.insert(struct_def.id(), NodeStructCtor(struct_def));\n+                    }\n                 }\n-            }\n-            ItemTrait(_, _, ref bounds, _) => {\n-                for b in bounds.iter() {\n-                    if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n-                        self.insert(t.trait_ref.ref_id, NodeItem(i));\n+                ItemTrait(_, _, ref bounds, _) => {\n+                    for b in bounds.iter() {\n+                        if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n+                            this.insert(t.trait_ref.ref_id, NodeItem(i));\n+                        }\n                     }\n                 }\n-            }\n-            ItemUse(ref view_path) => {\n-                match view_path.node {\n-                    ViewPathList(_, ref paths) => {\n-                        for path in paths {\n-                            self.insert(path.node.id(), NodeItem(i));\n+                ItemUse(ref view_path) => {\n+                    match view_path.node {\n+                        ViewPathList(_, ref paths) => {\n+                            for path in paths {\n+                                this.insert(path.node.id(), NodeItem(i));\n+                            }\n                         }\n+                        _ => ()\n                     }\n-                    _ => ()\n                 }\n+                _ => {}\n             }\n-            _ => {}\n-        }\n-        intravisit::walk_item(self, i);\n-        self.parent_node = parent_node;\n+            intravisit::walk_item(this, i);\n+        });\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n-        self.insert_def(foreign_item.id,\n-                        NodeForeignItem(foreign_item),\n-                        DefPathData::ValueNs(foreign_item.name));\n+        self.insert(foreign_item.id, NodeForeignItem(foreign_item));\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = foreign_item.id;\n-        intravisit::walk_foreign_item(self, foreign_item);\n-        self.parent_node = parent_node;\n+        self.with_parent(foreign_item.id, |this| {\n+            intravisit::walk_foreign_item(this, foreign_item);\n+        });\n     }\n \n     fn visit_generics(&mut self, generics: &'ast Generics) {\n         for ty_param in generics.ty_params.iter() {\n-            self.insert_def(ty_param.id,\n-                            NodeTyParam(ty_param),\n-                            DefPathData::TypeParam(ty_param.name));\n+            self.insert(ty_param.id, NodeTyParam(ty_param));\n         }\n \n         intravisit::walk_generics(self, generics);\n     }\n \n     fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n-        let def_data = match ti.node {\n-            MethodTraitItem(..) | ConstTraitItem(..) => DefPathData::ValueNs(ti.name),\n-            TypeTraitItem(..) => DefPathData::TypeNs(ti.name),\n-        };\n-\n         self.insert(ti.id, NodeTraitItem(ti));\n-        self.create_def(ti.id, def_data);\n-\n-        let parent_node = self.parent_node;\n-        self.parent_node = ti.id;\n \n-        match ti.node {\n-            ConstTraitItem(_, Some(ref expr)) => {\n-                self.create_def(expr.id, DefPathData::Initializer);\n-            }\n-            _ => { }\n-        }\n-\n-        intravisit::walk_trait_item(self, ti);\n-\n-        self.parent_node = parent_node;\n+        self.with_parent(ti.id, |this| {\n+            intravisit::walk_trait_item(this, ti);\n+        });\n     }\n \n     fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n-        let def_data = match ii.node {\n-            ImplItemKind::Method(..) | ImplItemKind::Const(..) => DefPathData::ValueNs(ii.name),\n-            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name),\n-        };\n-\n-        self.insert_def(ii.id, NodeImplItem(ii), def_data);\n-\n-        let parent_node = self.parent_node;\n-        self.parent_node = ii.id;\n+        self.insert(ii.id, NodeImplItem(ii));\n \n-        match ii.node {\n-            ImplItemKind::Const(_, ref expr) => {\n-                self.create_def(expr.id, DefPathData::Initializer);\n-            }\n-            _ => { }\n-        }\n-\n-        intravisit::walk_impl_item(self, ii);\n-\n-        self.parent_node = parent_node;\n+        self.with_parent(ii.id, |this| {\n+            intravisit::walk_impl_item(this, ii);\n+        });\n     }\n \n     fn visit_pat(&mut self, pat: &'ast Pat) {\n-        let maybe_binding = match pat.node {\n-            PatKind::Ident(_, id, _) => Some(id.node),\n-            _ => None\n-        };\n-\n-        if let Some(id) = maybe_binding {\n-            self.insert_def(pat.id, NodeLocal(pat), DefPathData::Binding(id.name));\n+        let node = if let PatKind::Ident(..) = pat.node {\n+            NodeLocal(pat)\n         } else {\n-            self.insert(pat.id, NodePat(pat));\n-        }\n+            NodePat(pat)\n+        };\n+        self.insert(pat.id, node);\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = pat.id;\n-        intravisit::walk_pat(self, pat);\n-        self.parent_node = parent_node;\n+        self.with_parent(pat.id, |this| {\n+            intravisit::walk_pat(this, pat);\n+        });\n     }\n \n     fn visit_expr(&mut self, expr: &'ast Expr) {\n         self.insert(expr.id, NodeExpr(expr));\n \n-        match expr.node {\n-            ExprClosure(..) => { self.create_def(expr.id, DefPathData::ClosureExpr); }\n-            _ => { }\n-        }\n-\n-        let parent_node = self.parent_node;\n-        self.parent_node = expr.id;\n-        intravisit::walk_expr(self, expr);\n-        self.parent_node = parent_node;\n+        self.with_parent(expr.id, |this| {\n+            intravisit::walk_expr(this, expr);\n+        });\n     }\n \n     fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n         let id = stmt.node.id();\n         self.insert(id, NodeStmt(stmt));\n-        let parent_node = self.parent_node;\n-        self.parent_node = id;\n-        intravisit::walk_stmt(self, stmt);\n-        self.parent_node = parent_node;\n+\n+        self.with_parent(id, |this| {\n+            intravisit::walk_stmt(this, stmt);\n+        });\n     }\n \n     fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n@@ -322,22 +199,12 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n     fn visit_block(&mut self, block: &'ast Block) {\n         self.insert(block.id, NodeBlock(block));\n-        let parent_node = self.parent_node;\n-        self.parent_node = block.id;\n-        intravisit::walk_block(self, block);\n-        self.parent_node = parent_node;\n+        self.with_parent(block.id, |this| {\n+            intravisit::walk_block(this, block);\n+        });\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n         self.insert(lifetime.id, NodeLifetime(lifetime));\n     }\n-\n-    fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n-        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n-        self.visit_lifetime(&def.lifetime);\n-    }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n-        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name));\n-    }\n }"}, {"sha": "053d32305be03328c5396f4ac06acc9157e7840f", "filename": "src/librustc/hir/map/def_collector.rs", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -0,0 +1,384 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+use hir;\n+use hir::intravisit;\n+use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n+\n+use middle::cstore::InlinedItem;\n+\n+use syntax::ast::*;\n+use syntax::visit;\n+use syntax::parse::token;\n+\n+/// Creates def ids for nodes in the HIR.\n+pub struct DefCollector<'ast> {\n+    // If we are walking HIR (c.f., AST), we need to keep a reference to the\n+    // crate.\n+    hir_crate: Option<&'ast hir::Crate>,\n+    pub definitions: Definitions,\n+    parent_def: Option<DefIndex>,\n+}\n+\n+impl<'ast> DefCollector<'ast> {\n+    pub fn root() -> DefCollector<'ast> {\n+        let mut collector = DefCollector {\n+            hir_crate: None,\n+            definitions: Definitions::new(),\n+            parent_def: None,\n+        };\n+        let root = collector.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n+        assert_eq!(root, CRATE_DEF_INDEX);\n+        collector.parent_def = Some(root);\n+\n+        collector.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n+\n+        collector\n+    }\n+\n+    pub fn extend(parent_node: NodeId,\n+                  parent_def_path: DefPath,\n+                  parent_def_id: DefId,\n+                  definitions: Definitions)\n+                  -> DefCollector<'ast> {\n+        let mut collector = DefCollector {\n+            hir_crate: None,\n+            parent_def: None,\n+            definitions: definitions,\n+        };\n+\n+        assert_eq!(parent_def_path.krate, parent_def_id.krate);\n+        let root_path = Box::new(InlinedRootPath {\n+            data: parent_def_path.data,\n+            def_id: parent_def_id,\n+        });\n+\n+        let def = collector.create_def(parent_node, DefPathData::InlinedRoot(root_path));\n+        collector.parent_def = Some(def);\n+\n+        collector\n+    }\n+\n+    pub fn walk_item(&mut self, ii: &'ast InlinedItem, krate: &'ast hir::Crate) {\n+        self.hir_crate = Some(krate);\n+        ii.visit(self);\n+    }\n+\n+    fn parent_def(&self) -> Option<DefIndex> {\n+        self.parent_def\n+    }\n+\n+    fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n+        let parent_def = self.parent_def();\n+        debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n+        self.definitions.create_def_with_parent(parent_def, node_id, data)\n+    }\n+\n+    fn create_def_with_parent(&mut self,\n+                              parent: Option<DefIndex>,\n+                              node_id: NodeId,\n+                              data: DefPathData)\n+                              -> DefIndex {\n+        self.definitions.create_def_with_parent(parent, node_id, data)\n+    }\n+\n+    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n+        let parent = self.parent_def;\n+        self.parent_def = Some(parent_def);\n+        f(self);\n+        self.parent_def = parent;\n+    }\n+}\n+\n+impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n+    fn visit_item(&mut self, i: &'ast Item) {\n+        debug!(\"visit_item: {:?}\", i);\n+\n+        // Pick the def data. This need not be unique, but the more\n+        // information we encapsulate into\n+        let def_data = match i.node {\n+            ItemKind::DefaultImpl(..) | ItemKind::Impl(..) =>\n+                DefPathData::Impl,\n+            ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Trait(..) |\n+            ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) | ItemKind::Ty(..) =>\n+                DefPathData::TypeNs(i.ident.name),\n+            ItemKind::Mod(..) => DefPathData::Module(i.ident.name),\n+            ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n+                DefPathData::ValueNs(i.ident.name),\n+            ItemKind::Mac(..) => DefPathData::MacroDef(i.ident.name),\n+            ItemKind::Use(..) => DefPathData::Misc,\n+        };\n+        let def = self.create_def(i.id, def_data);\n+\n+        self.with_parent(def, |this| {\n+            match i.node {\n+                ItemKind::Enum(ref enum_definition, _) => {\n+                    for v in &enum_definition.variants {\n+                        let variant_def_index =\n+                            this.create_def(v.node.data.id(),\n+                                            DefPathData::EnumVariant(v.node.name.name));\n+\n+                        for (index, field) in v.node.data.fields().iter().enumerate() {\n+                            let name = field.ident.map(|ident| ident.name)\n+                                .unwrap_or(token::intern(&index.to_string()));\n+                            this.create_def_with_parent(Some(variant_def_index),\n+                                                        field.id,\n+                                                        DefPathData::Field(name));\n+                        }\n+                    }\n+                }\n+                ItemKind::Struct(ref struct_def, _) => {\n+                    // If this is a tuple-like struct, register the constructor.\n+                    if !struct_def.is_struct() {\n+                        this.create_def(struct_def.id(),\n+                                        DefPathData::StructCtor);\n+                    }\n+\n+                    for (index, field) in struct_def.fields().iter().enumerate() {\n+                        let name = field.ident.map(|ident| ident.name)\n+                            .unwrap_or(token::intern(&index.to_string()));\n+                        this.create_def(field.id, DefPathData::Field(name));\n+                    }\n+                }\n+                _ => {}\n+            }\n+            visit::walk_item(this, i);\n+        });\n+    }\n+\n+    fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n+        let def = self.create_def(foreign_item.id, DefPathData::ValueNs(foreign_item.ident.name));\n+\n+        self.with_parent(def, |this| {\n+            visit::walk_foreign_item(this, foreign_item);\n+        });\n+    }\n+\n+    fn visit_generics(&mut self, generics: &'ast Generics) {\n+        for ty_param in generics.ty_params.iter() {\n+            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.ident.name));\n+        }\n+\n+        visit::walk_generics(self, generics);\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n+        let def_data = match ti.node {\n+            TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n+                DefPathData::ValueNs(ti.ident.name),\n+            TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name),\n+        };\n+\n+        let def = self.create_def(ti.id, def_data);\n+        self.with_parent(def, |this| {\n+            if let TraitItemKind::Const(_, Some(ref expr)) = ti.node {\n+                this.create_def(expr.id, DefPathData::Initializer);\n+            }\n+\n+            visit::walk_trait_item(this, ti);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n+        let def_data = match ii.node {\n+            ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n+                DefPathData::ValueNs(ii.ident.name),\n+            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.name),\n+            ImplItemKind::Macro(..) => DefPathData::MacroDef(ii.ident.name),\n+        };\n+\n+        let def = self.create_def(ii.id, def_data);\n+        self.with_parent(def, |this| {\n+            if let ImplItemKind::Const(_, ref expr) = ii.node {\n+                this.create_def(expr.id, DefPathData::Initializer);\n+            }\n+\n+            visit::walk_impl_item(this, ii);\n+        });\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'ast Pat) {\n+        let parent_def = self.parent_def;\n+\n+        if let PatKind::Ident(_, id, _) = pat.node {\n+            let def = self.create_def(pat.id, DefPathData::Binding(id.node.name));\n+            self.parent_def = Some(def);\n+        }\n+\n+        visit::walk_pat(self, pat);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'ast Expr) {\n+        let parent_def = self.parent_def;\n+\n+        if let ExprKind::Closure(..) = expr.node {\n+            let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n+            self.parent_def = Some(def);\n+        }\n+\n+        visit::walk_expr(self, expr);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n+        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n+    }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n+        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.ident.name));\n+    }\n+}\n+\n+// We walk the HIR rather than the AST when reading items from metadata.\n+impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n+    /// Because we want to track parent items and so forth, enable\n+    /// deep walking so that we walk nested items in the context of\n+    /// their outer items.\n+    fn visit_nested_item(&mut self, item_id: hir::ItemId) {\n+        debug!(\"visit_nested_item: {:?}\", item_id);\n+        let item = self.hir_crate.unwrap().item(item_id.id);\n+        self.visit_item(item)\n+    }\n+\n+    fn visit_item(&mut self, i: &'ast hir::Item) {\n+        debug!(\"visit_item: {:?}\", i);\n+\n+        // Pick the def data. This need not be unique, but the more\n+        // information we encapsulate into\n+        let def_data = match i.node {\n+            hir::ItemDefaultImpl(..) | hir::ItemImpl(..) =>\n+                DefPathData::Impl,\n+            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemTrait(..) |\n+            hir::ItemExternCrate(..) | hir::ItemMod(..) | hir::ItemForeignMod(..) |\n+            hir::ItemTy(..) =>\n+                DefPathData::TypeNs(i.name),\n+            hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) =>\n+                DefPathData::ValueNs(i.name),\n+            hir::ItemUse(..) => DefPathData::Misc,\n+        };\n+        let def = self.create_def(i.id, def_data);\n+\n+        self.with_parent(def, |this| {\n+            match i.node {\n+                hir::ItemEnum(ref enum_definition, _) => {\n+                    for v in &enum_definition.variants {\n+                        let variant_def_index =\n+                            this.create_def(v.node.data.id(),\n+                                            DefPathData::EnumVariant(v.node.name));\n+\n+                        for field in v.node.data.fields() {\n+                            this.create_def_with_parent(Some(variant_def_index),\n+                                                        field.id,\n+                                                        DefPathData::Field(field.name));\n+                        }\n+                    }\n+                }\n+                hir::ItemStruct(ref struct_def, _) => {\n+                    // If this is a tuple-like struct, register the constructor.\n+                    if !struct_def.is_struct() {\n+                        this.create_def(struct_def.id(),\n+                                        DefPathData::StructCtor);\n+                    }\n+\n+                    for field in struct_def.fields() {\n+                        this.create_def(field.id, DefPathData::Field(field.name));\n+                    }\n+                }\n+                _ => {}\n+            }\n+            intravisit::walk_item(this, i);\n+        });\n+    }\n+\n+    fn visit_foreign_item(&mut self, foreign_item: &'ast hir::ForeignItem) {\n+        let def = self.create_def(foreign_item.id, DefPathData::ValueNs(foreign_item.name));\n+\n+        self.with_parent(def, |this| {\n+            intravisit::walk_foreign_item(this, foreign_item);\n+        });\n+    }\n+\n+    fn visit_generics(&mut self, generics: &'ast hir::Generics) {\n+        for ty_param in generics.ty_params.iter() {\n+            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.name));\n+        }\n+\n+        intravisit::walk_generics(self, generics);\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n+        let def_data = match ti.node {\n+            hir::MethodTraitItem(..) | hir::ConstTraitItem(..) =>\n+                DefPathData::ValueNs(ti.name),\n+            hir::TypeTraitItem(..) => DefPathData::TypeNs(ti.name),\n+        };\n+\n+        let def = self.create_def(ti.id, def_data);\n+        self.with_parent(def, |this| {\n+            if let hir::ConstTraitItem(_, Some(ref expr)) = ti.node {\n+                this.create_def(expr.id, DefPathData::Initializer);\n+            }\n+\n+            intravisit::walk_trait_item(this, ti);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n+        let def_data = match ii.node {\n+            hir::ImplItemKind::Method(..) | hir::ImplItemKind::Const(..) =>\n+                DefPathData::ValueNs(ii.name),\n+            hir::ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name),\n+        };\n+\n+        let def = self.create_def(ii.id, def_data);\n+        self.with_parent(def, |this| {\n+            if let hir::ImplItemKind::Const(_, ref expr) = ii.node {\n+                this.create_def(expr.id, DefPathData::Initializer);\n+            }\n+\n+            intravisit::walk_impl_item(this, ii);\n+        });\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'ast hir::Pat) {\n+        let parent_def = self.parent_def;\n+\n+        if let hir::PatKind::Ident(_, id, _) = pat.node {\n+            let def = self.create_def(pat.id, DefPathData::Binding(id.node.name));\n+            self.parent_def = Some(def);\n+        }\n+\n+        intravisit::walk_pat(self, pat);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'ast hir::Expr) {\n+        let parent_def = self.parent_def;\n+\n+        if let hir::ExprClosure(..) = expr.node {\n+            let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n+            self.parent_def = Some(def);\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_lifetime_def(&mut self, def: &'ast hir::LifetimeDef) {\n+        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n+    }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'ast hir::MacroDef) {\n+        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name));\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "92f8c9249c842937e45b55585d16faf9489aed80", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -11,6 +11,7 @@\n pub use self::Node::*;\n use self::MapEntry::*;\n use self::collector::NodeCollector;\n+use self::def_collector::DefCollector;\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n                             DisambiguatedDefPathData, InlinedRootPath};\n \n@@ -21,9 +22,10 @@ use middle::cstore::InlinedItem as II;\n use hir::def_id::{CRATE_DEF_INDEX, DefId};\n \n use syntax::abi::Abi;\n-use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID};\n+use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, };\n use syntax::attr::ThinAttributesExt;\n use syntax::codemap::{Span, Spanned};\n+use syntax::visit;\n \n use hir::*;\n use hir::fold::Folder;\n@@ -36,6 +38,7 @@ use std::mem;\n \n pub mod blocks;\n mod collector;\n+mod def_collector;\n pub mod definitions;\n \n #[derive(Copy, Clone, Debug)]\n@@ -193,7 +196,7 @@ pub struct Map<'ast> {\n     /// plain old integers.\n     map: RefCell<Vec<MapEntry<'ast>>>,\n \n-    definitions: RefCell<Definitions>,\n+    definitions: &'ast RefCell<Definitions>,\n }\n \n impl<'ast> Map<'ast> {\n@@ -780,12 +783,18 @@ impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n     }\n }\n \n-pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n-    let (map, definitions) = {\n-        let mut collector = NodeCollector::root(&forest.krate);\n-        intravisit::walk_crate(&mut collector, &forest.krate);\n-        (collector.map, collector.definitions)\n-    };\n+pub fn collect_definitions<'ast>(krate: &'ast ast::Crate) -> Definitions {\n+    let mut def_collector = DefCollector::root();\n+    visit::walk_crate(&mut def_collector, krate);\n+    def_collector.definitions\n+}\n+\n+pub fn map_crate<'ast>(forest: &'ast mut Forest,\n+                       definitions: &'ast RefCell<Definitions>)\n+                       -> Map<'ast> {\n+    let mut collector = NodeCollector::root(&forest.krate);\n+    intravisit::walk_crate(&mut collector, &forest.krate);\n+    let map = collector.map;\n \n     if log_enabled!(::log::DEBUG) {\n         // This only makes sense for ordered stores; note the\n@@ -807,7 +816,7 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n         map: RefCell::new(map),\n-        definitions: RefCell::new(definitions),\n+        definitions: definitions,\n     }\n }\n \n@@ -834,21 +843,24 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     };\n \n     let ii = map.forest.inlined_items.alloc(ii);\n-\n     let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n-    let mut collector =\n-        NodeCollector::extend(\n-            map.krate(),\n-            ii,\n-            ii_parent_id,\n-            parent_def_path,\n-            parent_def_id,\n-            mem::replace(&mut *map.map.borrow_mut(), vec![]),\n-            mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new()));\n-    ii.visit(&mut collector);\n \n+    let defs = mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new());\n+    let mut def_collector = DefCollector::extend(ii_parent_id,\n+                                                 parent_def_path.clone(),\n+                                                 parent_def_id,\n+                                                 defs);\n+    def_collector.walk_item(ii, map.krate());\n+    *map.definitions.borrow_mut() = def_collector.definitions;\n+\n+    let mut collector = NodeCollector::extend(map.krate(),\n+                                              ii,\n+                                              ii_parent_id,\n+                                              parent_def_path,\n+                                              parent_def_id,\n+                                              mem::replace(&mut *map.map.borrow_mut(), vec![]));\n+    ii.visit(&mut collector);\n     *map.map.borrow_mut() = collector.map;\n-    *map.definitions.borrow_mut() = collector.definitions;\n \n     ii\n }"}, {"sha": "5fc2a955c0602ed5a713413065f5c2abe7f0018a", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -43,6 +43,7 @@ use super::Compilation;\n \n use serialize::json;\n \n+use std::cell::RefCell;\n use std::collections::HashMap;\n use std::env;\n use std::ffi::{OsString, OsStr};\n@@ -120,13 +121,24 @@ pub fn compile_input(sess: &Session,\n                                 Ok(()));\n \n         let expanded_crate = assign_node_ids(sess, expanded_crate);\n-        // Lower ast -> hir.\n-        let lcx = LoweringContext::new(sess, Some(&expanded_crate));\n         let dep_graph = DepGraph::new(sess.opts.build_dep_graph());\n-        let mut hir_forest = time(sess.time_passes(),\n-                                  \"lowering ast -> hir\",\n-                                  || hir_map::Forest::new(lower_crate(&lcx, &expanded_crate),\n-                                                          dep_graph));\n+\n+        // Collect defintions for def ids.\n+        let defs = &RefCell::new(time(sess.time_passes(),\n+                                 \"collecting defs\",\n+                                 || hir_map::collect_definitions(&expanded_crate)));\n+\n+        time(sess.time_passes(),\n+             \"external crate/lib resolution\",\n+             || LocalCrateReader::new(sess, &cstore, &defs, &expanded_crate, &id)\n+                    .read_crates(&dep_graph));\n+\n+        // Lower ast -> hir.\n+        let lcx = LoweringContext::new(sess, Some(&expanded_crate), defs);\n+        let hir_forest = &mut time(sess.time_passes(),\n+                                   \"lowering ast -> hir\",\n+                                   || hir_map::Forest::new(lower_crate(&lcx, &expanded_crate),\n+                                                           dep_graph));\n \n         // Discard MTWT tables that aren't required past lowering to HIR.\n         if !sess.opts.debugging_opts.keep_mtwt_tables &&\n@@ -135,7 +147,12 @@ pub fn compile_input(sess: &Session,\n         }\n \n         let arenas = ty::CtxtArenas::new();\n-        let hir_map = make_map(sess, &mut hir_forest);\n+\n+        // Construct the HIR map\n+        let hir_map = time(sess.time_passes(),\n+                           \"indexing hir\",\n+                           move || hir_map::map_crate(hir_forest, defs));\n+\n \n         write_out_deps(sess, &outputs, &id);\n \n@@ -171,7 +188,6 @@ pub fn compile_input(sess: &Session,\n         };\n \n         phase_3_run_analysis_passes(sess,\n-                                    &cstore,\n                                     hir_map,\n                                     &arenas,\n                                     &id,\n@@ -726,20 +742,10 @@ pub fn assign_node_ids(sess: &Session, krate: ast::Crate) -> ast::Crate {\n     krate\n }\n \n-pub fn make_map<'ast>(sess: &Session,\n-                      forest: &'ast mut hir_map::Forest)\n-                      -> hir_map::Map<'ast> {\n-    // Construct the HIR map\n-    time(sess.time_passes(),\n-         \"indexing hir\",\n-         move || hir_map::map_crate(forest))\n-}\n-\n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n-                                               cstore: &CStore,\n                                                hir_map: hir_map::Map<'tcx>,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                name: &str,\n@@ -762,10 +768,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let time_passes = sess.time_passes();\n \n-    time(time_passes,\n-         \"external crate/lib resolution\",\n-         || LocalCrateReader::new(sess, cstore, &hir_map, name).read_crates());\n-\n     let lang_items = time(time_passes, \"language item collection\", || {\n         sess.track_errors(|| {\n             middle::lang_items::collect_language_items(&sess, &hir_map)\n@@ -778,8 +780,8 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         export_map,\n         trait_map,\n         glob_map,\n-    } = time(time_passes,\n-             \"resolution\",\n+    } = time(sess.time_passes(),\n+             \"name resolution\",\n              || resolve::resolve_crate(sess, &hir_map, make_glob_map));\n \n     let mut analysis = ty::CrateAnalysis {"}, {"sha": "0e100f48ac38d64488defa10f3e3d7775c0e49ff", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -199,14 +199,9 @@ pub fn run_compiler<'a>(args: &[String],\n     // It is somewhat unfortunate that this is hardwired in - this is forced by\n     // the fact that pretty_print_input requires the session by value.\n     let pretty = callbacks.parse_pretty(&sess, &matches);\n-    match pretty {\n-        Some((ppm, opt_uii)) => {\n-            pretty::pretty_print_input(sess, &cstore, cfg, &input, ppm, opt_uii, ofile);\n-            return (Ok(()), None);\n-        }\n-        None => {\n-            // continue\n-        }\n+    if let Some((ppm, opt_uii)) = pretty {\n+        pretty::pretty_print_input(sess, &cstore, cfg, &input, ppm, opt_uii, ofile);\n+        return (Ok(()), None);\n     }\n \n     let plugins = sess.opts.debugging_opts.extra_plugins.clone();"}, {"sha": "b1143fd3e845463339783d224442c3b191d1c6b0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -29,6 +29,7 @@ use rustc_borrowck as borrowck;\n use rustc_borrowck::graphviz as borrowck_dot;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n+use rustc_metadata::creader::LocalCrateReader;\n \n use rustc_mir::pretty::write_mir_pretty;\n use rustc_mir::graphviz::write_mir_graphviz;\n@@ -43,6 +44,7 @@ use syntax::util::small_vector::SmallVector;\n \n use graphviz as dot;\n \n+use std::cell::RefCell;\n use std::fs::File;\n use std::io::{self, Write};\n use std::iter;\n@@ -179,7 +181,6 @@ impl PpSourceMode {\n     }\n     fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n                                                sess: &'tcx Session,\n-                                               cstore: &CStore,\n                                                ast_map: &hir_map::Map<'tcx>,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                id: &str,\n@@ -206,7 +207,6 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 abort_on_err(driver::phase_3_run_analysis_passes(sess,\n-                                                                 cstore,\n                                                                  ast_map.clone(),\n                                                                  arenas,\n                                                                  id,\n@@ -721,7 +721,7 @@ pub fn pretty_print_input(sess: Session,\n     let is_expanded = needs_expansion(&ppm);\n     let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n     let krate = if compute_ast_map {\n-        match driver::phase_2_configure_and_expand(&sess, &cstore, krate, &id[..], None) {\n+        match driver::phase_2_configure_and_expand(&sess, &cstore, krate, &id, None) {\n             Err(_) => return,\n             Ok(k) => driver::assign_node_ids(&sess, k),\n         }\n@@ -732,14 +732,18 @@ pub fn pretty_print_input(sess: Session,\n     // There is some twisted, god-forsaken tangle of lifetimes here which makes\n     // the ordering of stuff super-finicky.\n     let mut hir_forest;\n-    let lcx = LoweringContext::new(&sess, Some(&krate));\n-    let arenas = ty::CtxtArenas::new();\n+    let mut _defs = None;\n     let dep_graph = DepGraph::new(false);\n+    let arenas = ty::CtxtArenas::new();\n     let _ignore = dep_graph.in_ignore();\n     let ast_map = if compute_ast_map {\n+        _defs = Some(RefCell::new(hir_map::collect_definitions(&krate)));\n+        let defs = _defs.as_ref().unwrap();\n+        LocalCrateReader::new(&sess, &cstore, defs, &krate, &id).read_crates(&dep_graph);\n+        let lcx = LoweringContext::new(&sess, Some(&krate), defs);\n+\n         hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate), dep_graph.clone());\n-        let map = driver::make_map(&sess, &mut hir_forest);\n-        Some(map)\n+        Some(hir_map::map_crate(&mut hir_forest, defs))\n     } else {\n         None\n     };\n@@ -752,7 +756,7 @@ pub fn pretty_print_input(sess: Session,\n                   .unwrap()\n                   .as_bytes()\n                   .to_vec();\n-    let mut rdr = &src[..];\n+    let mut rdr = &*src;\n \n     let mut out = Vec::new();\n \n@@ -777,7 +781,6 @@ pub fn pretty_print_input(sess: Session,\n         (PpmHir(s), None) => {\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(&sess,\n-                                       cstore,\n                                        &ast_map.unwrap(),\n                                        &arenas,\n                                        &id,\n@@ -799,7 +802,6 @@ pub fn pretty_print_input(sess: Session,\n         (PpmHir(s), Some(uii)) => {\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(&sess,\n-                                       cstore,\n                                        &ast_map.unwrap(),\n                                        &arenas,\n                                        &id,\n@@ -840,7 +842,6 @@ pub fn pretty_print_input(sess: Session,\n                 None\n             };\n             abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n-                                                             &cstore,\n                                                              ast_map,\n                                                              &arenas,\n                                                              &id,\n@@ -887,7 +888,6 @@ pub fn pretty_print_input(sess: Session,\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n                     abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n-                                                                     &cstore,\n                                                                      ast_map,\n                                                                      &arenas,\n                                                                      &id,"}, {"sha": "ce92dd158c969e4b33a80b05125f25fe471f2518", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -27,8 +27,10 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::relate::TypeRelation;\n use rustc::infer::{self, InferOk, InferResult, TypeOrigin};\n use rustc_metadata::cstore::CStore;\n+use rustc_metadata::creader::LocalCrateReader;\n use rustc::hir::map as hir_map;\n use rustc::session::{self, config};\n+use std::cell::RefCell;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::abi::Abi;\n@@ -119,13 +121,15 @@ fn test_env<F>(source_string: &str,\n     let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate, \"test\", None)\n                     .expect(\"phase 2 aborted\");\n \n-    let krate = driver::assign_node_ids(&sess, krate);\n-    let lcx = LoweringContext::new(&sess, Some(&krate));\n     let dep_graph = DepGraph::new(false);\n+    let krate = driver::assign_node_ids(&sess, krate);\n+    let defs = &RefCell::new(hir_map::collect_definitions(&krate));\n+    LocalCrateReader::new(&sess, &cstore, defs, &krate, \"test_crate\").read_crates(&dep_graph);\n+    let lcx = LoweringContext::new(&sess, Some(&krate), defs);\n     let _ignore = dep_graph.in_ignore();\n-    let mut hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate), dep_graph.clone());\n+    let mut hir_forest = &mut hir_map::Forest::new(lower_crate(&lcx, &krate), dep_graph.clone());\n     let arenas = ty::CtxtArenas::new();\n-    let ast_map = driver::make_map(&sess, &mut hir_forest);\n+    let ast_map = hir_map::map_crate(hir_forest, defs);\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(&sess, &ast_map);"}, {"sha": "2d6a043e34aeb88fb280fb58bfdf03039d2f04d0", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -1339,7 +1339,7 @@ fn roundtrip(in_item: hir::Item) {\n fn test_basic() {\n     let cx = mk_ctxt();\n     let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::new(&fnia, None);\n+    let lcx = LoweringContext::testing_context(&fnia);\n     roundtrip(lower_item(&lcx, &quote_item!(&cx,\n         fn foo() {}\n     ).unwrap()));\n@@ -1349,7 +1349,7 @@ fn test_basic() {\n fn test_smalltalk() {\n     let cx = mk_ctxt();\n     let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::new(&fnia, None);\n+    let lcx = LoweringContext::testing_context(&fnia);\n     roundtrip(lower_item(&lcx, &quote_item!(&cx,\n         fn foo() -> isize { 3 + 4 } // first smalltalk program ever executed.\n     ).unwrap()));\n@@ -1359,7 +1359,7 @@ fn test_smalltalk() {\n fn test_more() {\n     let cx = mk_ctxt();\n     let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::new(&fnia, None);\n+    let lcx = LoweringContext::testing_context(&fnia);\n     roundtrip(lower_item(&lcx, &quote_item!(&cx,\n         fn foo(x: usize, y: usize) -> usize {\n             let z = x + y;\n@@ -1378,7 +1378,7 @@ fn test_simplification() {\n         }\n     ).unwrap();\n     let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::new(&fnia, None);\n+    let lcx = LoweringContext::testing_context(&fnia);\n     let hir_item = lower_item(&lcx, &item);\n     let item_in = InlinedItemRef::Item(&hir_item);\n     let item_out = simplify_ast(item_in);"}, {"sha": "635ef4ab3583619b4a74475625e4b0451362d380", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 37, "deletions": 63, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -18,7 +18,7 @@ use decoder;\n use loader::{self, CratePaths};\n \n use rustc::hir::svh::Svh;\n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepGraph, DepNode};\n use rustc::session::{config, Session};\n use rustc::session::search_paths::PathKind;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n@@ -37,15 +37,15 @@ use syntax::parse;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::InternedString;\n-use rustc::hir::intravisit::Visitor;\n-use rustc::hir;\n+use syntax::visit;\n use log;\n \n-pub struct LocalCrateReader<'a, 'b:'a> {\n+pub struct LocalCrateReader<'a> {\n     sess: &'a Session,\n     cstore: &'a CStore,\n     creader: CrateReader<'a>,\n-    ast_map: &'a hir_map::Map<'b>,\n+    krate: &'a ast::Crate,\n+    defintions: &'a RefCell<hir_map::Definitions>,\n }\n \n pub struct CrateReader<'a> {\n@@ -56,9 +56,10 @@ pub struct CrateReader<'a> {\n     local_crate_name: String,\n }\n \n-impl<'a, 'b, 'hir> Visitor<'hir> for LocalCrateReader<'a, 'b> {\n-    fn visit_item(&mut self, a: &'hir hir::Item) {\n+impl<'a, 'ast> visit::Visitor<'ast> for LocalCrateReader<'a> {\n+    fn visit_item(&mut self, a: &'ast ast::Item) {\n         self.process_item(a);\n+        visit::walk_item(self, a);\n     }\n }\n \n@@ -80,11 +81,8 @@ fn dump_crates(cstore: &CStore) {\n fn should_link(i: &ast::Item) -> bool {\n     !attr::contains_name(&i.attrs, \"no_link\")\n }\n-// Dup for the hir\n-fn should_link_hir(i: &hir::Item) -> bool {\n-    !attr::contains_name(&i.attrs, \"no_link\")\n-}\n \n+#[derive(Debug)]\n struct CrateInfo {\n     ident: String,\n     name: String,\n@@ -181,31 +179,6 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n-    // Dup of the above, but for the hir\n-    fn extract_crate_info_hir(&self, i: &hir::Item) -> Option<CrateInfo> {\n-        match i.node {\n-            hir::ItemExternCrate(ref path_opt) => {\n-                debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n-                       i.name, path_opt);\n-                let name = match *path_opt {\n-                    Some(name) => {\n-                        validate_crate_name(Some(self.sess), &name.as_str(),\n-                                            Some(i.span));\n-                        name.to_string()\n-                    }\n-                    None => i.name.to_string(),\n-                };\n-                Some(CrateInfo {\n-                    ident: i.name.to_string(),\n-                    name: name,\n-                    id: i.id,\n-                    should_link: should_link_hir(i),\n-                })\n-            }\n-            _ => None\n-        }\n-    }\n-\n     fn existing_match(&self, name: &str, hash: Option<&Svh>, kind: PathKind)\n                       -> Option<ast::CrateNum> {\n         let mut ret = None;\n@@ -776,29 +749,30 @@ impl<'a> CrateReader<'a> {\n     }\n }\n \n-impl<'a, 'b> LocalCrateReader<'a, 'b> {\n+impl<'a> LocalCrateReader<'a> {\n     pub fn new(sess: &'a Session,\n                cstore: &'a CStore,\n-               map: &'a hir_map::Map<'b>,\n+               defs: &'a RefCell<hir_map::Definitions>,\n+               krate: &'a ast::Crate,\n                local_crate_name: &str)\n-               -> LocalCrateReader<'a, 'b> {\n+               -> LocalCrateReader<'a> {\n         LocalCrateReader {\n             sess: sess,\n             cstore: cstore,\n             creader: CrateReader::new(sess, cstore, local_crate_name),\n-            ast_map: map,\n+            krate: krate,\n+            defintions: defs,\n         }\n     }\n \n     // Traverses an AST, reading all the information about use'd crates and\n     // extern libraries necessary for later resolving, typechecking, linking,\n     // etc.\n-    pub fn read_crates(&mut self) {\n-        let _task = self.ast_map.dep_graph.in_task(DepNode::CrateReader);\n-        let krate = self.ast_map.krate();\n+    pub fn read_crates(&mut self, dep_graph: &DepGraph) {\n+        let _task = dep_graph.in_task(DepNode::CrateReader);\n \n-        self.process_crate(krate);\n-        krate.visit_all_items(self);\n+        self.process_crate(self.krate);\n+        visit::walk_crate(self, self.krate);\n         self.creader.inject_allocator_crate();\n \n         if log_enabled!(log::INFO) {\n@@ -811,34 +785,34 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n         self.creader.register_statically_included_foreign_items();\n     }\n \n-    fn process_crate(&self, c: &hir::Crate) {\n+    fn process_crate(&self, c: &ast::Crate) {\n         for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n-            match a.value_str() {\n-                Some(ref linkarg) => self.cstore.add_used_link_args(&linkarg),\n-                None => { /* fallthrough */ }\n+            if let Some(ref linkarg) = a.value_str() {\n+                self.cstore.add_used_link_args(&linkarg);\n             }\n         }\n     }\n \n-    fn process_item(&mut self, i: &hir::Item) {\n+    fn process_item(&mut self, i: &ast::Item) {\n         match i.node {\n-            hir::ItemExternCrate(_) => {\n-                if !should_link_hir(i) {\n+            ast::ItemKind::ExternCrate(_) => {\n+                if !should_link(i) {\n                     return;\n                 }\n \n-                match self.creader.extract_crate_info_hir(i) {\n+                match self.creader.extract_crate_info(i) {\n                     Some(info) => {\n                         let (cnum, _, _) = self.creader.resolve_crate(&None,\n-                                                                          &info.ident,\n-                                                                          &info.name,\n-                                                                          None,\n-                                                                          i.span,\n-                                                                          PathKind::Crate,\n-                                                                          true);\n-                        let def_id = self.ast_map.local_def_id(i.id);\n+                                                                      &info.ident,\n+                                                                      &info.name,\n+                                                                      None,\n+                                                                      i.span,\n+                                                                      PathKind::Crate,\n+                                                                      true);\n \n-                        let len = self.ast_map.def_path(def_id).data.len();\n+                        let defs = self.defintions.borrow();\n+                        let def_id = defs.opt_local_def_id(i.id).unwrap();\n+                        let len = defs.def_path(def_id.index).data.len();\n \n                         self.creader.update_extern_crate(cnum,\n                                                          ExternCrate {\n@@ -852,12 +826,12 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n                     None => ()\n                 }\n             }\n-            hir::ItemForeignMod(ref fm) => self.process_foreign_mod(i, fm),\n+            ast::ItemKind::ForeignMod(ref fm) => self.process_foreign_mod(i, fm),\n             _ => { }\n         }\n     }\n \n-    fn process_foreign_mod(&mut self, i: &hir::Item, fm: &hir::ForeignMod) {\n+    fn process_foreign_mod(&mut self, i: &ast::Item, fm: &ast::ForeignMod) {\n         if fm.abi == Abi::Rust || fm.abi == Abi::RustIntrinsic || fm.abi == Abi::PlatformIntrinsic {\n             return;\n         }"}, {"sha": "45ec9a97a11844308d27cc0a05eeaefcec7dd8d4", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -17,10 +17,10 @@ use super::data::*;\n use super::dump::Dump;\n use super::span_utils::SpanUtils;\n \n-pub struct CsvDumper<'a, 'b, W: 'b> {\n+pub struct CsvDumper<'tcx, 'b, W: 'b> {\n     output: &'b mut W,\n     dump_spans: bool,\n-    span: SpanUtils<'a>\n+    span: SpanUtils<'tcx>\n }\n \n impl<'a, 'b, W: Write> CsvDumper<'a, 'b, W> {"}, {"sha": "bf6ad7039636e97697c919b34de5f10f6bcd27f5", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -42,7 +42,7 @@ use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{path_to_string, ty_to_string};\n use syntax::ptr::P;\n \n-use rustc::hir::lowering::{lower_expr, LoweringContext};\n+use rustc::hir::lowering::lower_expr;\n \n use super::{escape, generated_code, SaveContext, PathCollector};\n use super::data::*;\n@@ -60,12 +60,12 @@ macro_rules! down_cast_data {\n     };\n }\n \n-pub struct DumpVisitor<'l, 'tcx: 'l, D: 'l> {\n+pub struct DumpVisitor<'l, 'tcx: 'l, 'll, D: 'll> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n     sess: &'l Session,\n     tcx: &'l TyCtxt<'tcx>,\n     analysis: &'l ty::CrateAnalysis<'l>,\n-    dumper: &'l mut D,\n+    dumper: &'ll mut D,\n \n     span: SpanUtils<'l>,\n \n@@ -77,22 +77,19 @@ pub struct DumpVisitor<'l, 'tcx: 'l, D: 'l> {\n     // one macro use per unique callsite span.\n     mac_defs: HashSet<Span>,\n     mac_uses: HashSet<Span>,\n-\n }\n \n-impl <'l, 'tcx, D> DumpVisitor<'l, 'tcx, D>\n-where D: Dump\n-{\n+impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     pub fn new(tcx: &'l TyCtxt<'tcx>,\n-               lcx: &'l LoweringContext<'l>,\n+               save_ctxt: SaveContext<'l, 'tcx>,\n                analysis: &'l ty::CrateAnalysis<'l>,\n-               dumper: &'l mut D)\n-               -> DumpVisitor<'l, 'tcx, D> {\n+               dumper: &'ll mut D)\n+               -> DumpVisitor<'l, 'tcx, 'll, D> {\n         let span_utils = SpanUtils::new(&tcx.sess);\n         DumpVisitor {\n             sess: &tcx.sess,\n             tcx: tcx,\n-            save_ctxt: SaveContext::from_span_utils(tcx, lcx, span_utils.clone()),\n+            save_ctxt: save_ctxt,\n             analysis: analysis,\n             dumper: dumper,\n             span: span_utils.clone(),\n@@ -103,7 +100,7 @@ where D: Dump\n     }\n \n     fn nest<F>(&mut self, scope_id: NodeId, f: F)\n-        where F: FnOnce(&mut DumpVisitor<'l, 'tcx, D>)\n+        where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, D>)\n     {\n         let parent_scope = self.cur_scope;\n         self.cur_scope = scope_id;\n@@ -982,7 +979,7 @@ where D: Dump\n     }\n }\n \n-impl<'l, 'tcx, 'v, D: Dump + 'l> Visitor<'v> for DumpVisitor<'l, 'tcx, D> {\n+impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx, 'll, D> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         use syntax::ast::ItemKind::*;\n         self.process_macro_use(item.span, item.id);"}, {"sha": "9148b53322bfe61b125620c0d80f1e3011bdf097", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -73,7 +73,7 @@ pub mod recorder {\n pub struct SaveContext<'l, 'tcx: 'l> {\n     tcx: &'l TyCtxt<'tcx>,\n     lcx: &'l lowering::LoweringContext<'l>,\n-    span_utils: SpanUtils<'l>,\n+    span_utils: SpanUtils<'tcx>,\n }\n \n macro_rules! option_try(\n@@ -90,7 +90,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn from_span_utils(tcx: &'l TyCtxt<'tcx>,\n                            lcx: &'l lowering::LoweringContext<'l>,\n-                           span_utils: SpanUtils<'l>)\n+                           span_utils: SpanUtils<'tcx>)\n                            -> SaveContext<'l, 'tcx> {\n         SaveContext {\n             tcx: tcx,\n@@ -680,7 +680,7 @@ impl<'v> Visitor<'v> for PathCollector {\n pub fn process_crate<'l, 'tcx>(tcx: &'l TyCtxt<'tcx>,\n                                lcx: &'l lowering::LoweringContext<'l>,\n                                krate: &ast::Crate,\n-                               analysis: &ty::CrateAnalysis,\n+                               analysis: &'l ty::CrateAnalysis<'l>,\n                                cratename: &str,\n                                odir: Option<&Path>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n@@ -726,9 +726,10 @@ pub fn process_crate<'l, 'tcx>(tcx: &'l TyCtxt<'tcx>,\n     });\n     root_path.pop();\n \n-    let utils = SpanUtils::new(&tcx.sess);\n+    let utils: SpanUtils<'tcx> = SpanUtils::new(&tcx.sess);\n+    let save_ctxt = SaveContext::new(tcx, lcx);\n     let mut dumper = CsvDumper::new(&mut output_file, utils);\n-    let mut visitor = DumpVisitor::new(tcx, lcx, analysis, &mut dumper);\n+    let mut visitor = DumpVisitor::new(tcx, save_ctxt, analysis, &mut dumper);\n     // FIXME: we don't write anything!\n \n     visitor.dump_crate_info(cratename, krate);"}, {"sha": "c64eeb92737e05ebcdbe2c62db8eeeb3f45d9bde", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -26,6 +26,8 @@ use syntax::parse::token::{keywords, Token};\n #[derive(Clone)]\n pub struct SpanUtils<'a> {\n     pub sess: &'a Session,\n+    // FIXME given that we clone SpanUtils all over the place, this err_count is\n+    // probably useless and any logic relying on it is bogus.\n     pub err_count: Cell<isize>,\n }\n "}, {"sha": "6d1e91a687e586074115bd8bb07654073643c28d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -22,6 +22,7 @@ use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc::hir::lowering::{lower_crate, LoweringContext};\n use rustc_metadata::cstore::CStore;\n+use rustc_metadata::creader::LocalCrateReader;\n \n use syntax::{ast, codemap, errors};\n use syntax::errors::emitter::ColorConfig;\n@@ -151,14 +152,18 @@ pub fn run_core(search_paths: SearchPaths,\n                     .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let krate = driver::assign_node_ids(&sess, krate);\n+    let dep_graph = DepGraph::new(false);\n+\n+    let defs = &RefCell::new(hir_map::collect_definitions(&krate));\n+    LocalCrateReader::new(&sess, &cstore, &defs, &krate, &name).read_crates(&dep_graph);\n+    let lcx = LoweringContext::new(&sess, Some(&krate), defs);\n+\n     // Lower ast -> hir.\n-    let lcx = LoweringContext::new(&sess, Some(&krate));\n-    let mut hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate), DepGraph::new(false));\n+    let mut hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate), dep_graph);\n     let arenas = ty::CtxtArenas::new();\n-    let hir_map = driver::make_map(&sess, &mut hir_forest);\n+    let hir_map = hir_map::map_crate(&mut hir_forest, defs);\n \n     abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n-                                                     &cstore,\n                                                      hir_map,\n                                                      &arenas,\n                                                      &name,"}, {"sha": "487aac1806ea7291e7e1e7122af1f4f604a4a1ed", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -94,15 +94,17 @@ pub fn run(input: &str,\n                                                      \"rustdoc-test\", None)\n         .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n     let krate = driver::assign_node_ids(&sess, krate);\n-    let lcx = LoweringContext::new(&sess, Some(&krate));\n+    let dep_graph = DepGraph::new(false);\n+    let defs = &RefCell::new(hir_map::collect_definitions(&krate));\n+\n+    let lcx = LoweringContext::new(&sess, Some(&krate), defs);\n     let krate = lower_crate(&lcx, &krate);\n \n     let opts = scrape_test_config(&krate);\n \n-    let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n     let mut forest = hir_map::Forest::new(krate, dep_graph.clone());\n-    let map = hir_map::map_crate(&mut forest);\n+    let map = hir_map::map_crate(&mut forest, defs);\n \n     let ctx = core::DocContext {\n         map: &map,"}, {"sha": "b9a45c09626a79455484af90f1d6bcb886a04d4c", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "patch": "@@ -20,6 +20,7 @@ extern crate rustc_metadata;\n extern crate rustc_resolve;\n #[macro_use] extern crate syntax;\n \n+use std::cell::RefCell;\n use std::ffi::{CStr, CString};\n use std::mem::transmute;\n use std::path::PathBuf;\n@@ -35,6 +36,7 @@ use rustc::session::build_session;\n use rustc_driver::{driver, abort_on_err};\n use rustc::hir::lowering::{lower_crate, LoweringContext};\n use rustc_resolve::MakeGlobMap;\n+use rustc_metadata::creader::LocalCrateReader;\n use rustc_metadata::cstore::CStore;\n use libc::c_void;\n \n@@ -237,15 +239,17 @@ fn compile_program(input: &str, sysroot: PathBuf)\n         let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate, &id, None)\n             .expect(\"phase_2 returned `None`\");\n \n-        let krate = driver::assign_node_ids(&sess, krate);\n-        let lcx = LoweringContext::new(&sess, Some(&krate));\n         let dep_graph = DepGraph::new(sess.opts.build_dep_graph());\n+        let krate = driver::assign_node_ids(&sess, krate);\n+        let defs = RefCell::new(ast_map::collect_definitions(&krate));\n+        LocalCrateReader::new(&sess, &cstore, &defs, &krate, &id).read_crates(&dep_graph);\n+        let lcx = LoweringContext::new(&sess, Some(&krate), &defs);\n         let mut hir_forest = ast_map::Forest::new(lower_crate(&lcx, &krate), dep_graph);\n         let arenas = ty::CtxtArenas::new();\n-        let ast_map = driver::make_map(&sess, &mut hir_forest);\n+        let ast_map = ast_map::map_crate(&mut hir_forest, &defs);\n \n         abort_on_err(driver::phase_3_run_analysis_passes(\n-            &sess, &cstore, ast_map, &arenas, &id,\n+            &sess, ast_map, &arenas, &id,\n             MakeGlobMap::No, |tcx, mir_map, analysis, _| {\n \n             let trans = driver::phase_4_translate_to_llvm(tcx, mir_map.unwrap(), analysis);"}]}