{"sha": "aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "node_id": "C_kwDOAAsO6NoAKGFhYTk5ODljMmZjZjEwYWI0N2Q4OWJlMWZmOTg4N2E0ZmRiOGU3YjY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-22T18:49:35Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-26T00:40:22Z"}, "message": "Remove some explicit self.infcx for fcx, which derefs into infcx", "tree": {"sha": "eed00ce2bc1d6b1c8b2210e9625526e84828585a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eed00ce2bc1d6b1c8b2210e9625526e84828585a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "html_url": "https://github.com/rust-lang/rust/commit/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dbae3ad19309bb541d9e76638e6aa4b5449f29a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dbae3ad19309bb541d9e76638e6aa4b5449f29a", "html_url": "https://github.com/rust-lang/rust/commit/6dbae3ad19309bb541d9e76638e6aa4b5449f29a"}], "stats": {"total": 145, "additions": 68, "deletions": 77}, "files": [{"sha": "147d87e7594c5be5e06d977087e65ba85dfea8ad", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "patch": "@@ -488,17 +488,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n                                     trait_ref: ty::TraitRef {\n                                         def_id: t.def_id(),\n-                                        substs: self.infcx.tcx.mk_substs_trait(outer_ty, &[]),\n+                                        substs: self.tcx.mk_substs_trait(outer_ty, &[]),\n                                     },\n                                     constness: t.constness,\n                                     polarity: t.polarity,\n                                 }));\n                             let obl = Obligation::new(\n                                 o.cause.clone(),\n                                 self.param_env,\n-                                pred.to_predicate(self.infcx.tcx),\n+                                pred.to_predicate(self.tcx),\n                             );\n-                            suggest_box &= self.infcx.predicate_must_hold_modulo_regions(&obl);\n+                            suggest_box &= self.predicate_must_hold_modulo_regions(&obl);\n                             if !suggest_box {\n                                 // We've encountered some obligation that didn't hold, so the\n                                 // return expression can't just be boxed. We don't need to"}, {"sha": "0836f15a1221bf27e2f2eb285bbd1c9dc13c4939", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "patch": "@@ -376,7 +376,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             self.param_env,\n                             *predicate,\n                         );\n-                        let result = self.infcx.evaluate_obligation(&obligation);\n+                        let result = self.evaluate_obligation(&obligation);\n                         self.tcx\n                             .sess\n                             .struct_span_err("}, {"sha": "fee872155f5b2d1fa86c3ca4958a8c5d0384ce3a", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.tcx.typeck_root_def_id(expr_def_id.to_def_id()),\n         );\n \n-        let tupled_upvars_ty = self.infcx.next_ty_var(TypeVariableOrigin {\n+        let tupled_upvars_ty = self.next_ty_var(TypeVariableOrigin {\n             kind: TypeVariableOriginKind::ClosureSynthetic,\n             span: self.tcx.hir().span(expr.hir_id),\n         });\n@@ -141,7 +141,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Create a type variable (for now) to represent the closure kind.\n             // It will be unified during the upvar inference phase (`upvar.rs`)\n-            None => self.infcx.next_ty_var(TypeVariableOrigin {\n+            None => self.next_ty_var(TypeVariableOrigin {\n                 // FIXME(eddyb) distinguish closure kind inference variables from the rest.\n                 kind: TypeVariableOriginKind::ClosureSynthetic,\n                 span: expr.span,\n@@ -531,7 +531,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         //\n         // [c1]: https://github.com/rust-lang/rust/pull/45072#issuecomment-341089706\n         // [c2]: https://github.com/rust-lang/rust/pull/45072#issuecomment-341096796\n-        self.infcx.commit_if_ok(|_| {\n+        self.commit_if_ok(|_| {\n             let mut all_obligations = vec![];\n \n             // The liberated version of this signature should be a subtype\n@@ -544,7 +544,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 expected_sigs.liberated_sig.inputs(), // `liberated_sig` is E'.\n             ) {\n                 // Instantiate (this part of..) S to S', i.e., with fresh variables.\n-                let supplied_ty = self.infcx.replace_bound_vars_with_fresh_vars(\n+                let supplied_ty = self.replace_bound_vars_with_fresh_vars(\n                     hir_ty.span,\n                     LateBoundRegionConversionTime::FnCall,\n                     supplied_sig.inputs().rebind(supplied_ty),\n@@ -557,7 +557,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 all_obligations.extend(obligations);\n             }\n \n-            let supplied_output_ty = self.infcx.replace_bound_vars_with_fresh_vars(\n+            let supplied_output_ty = self.replace_bound_vars_with_fresh_vars(\n                 decl.output.span(),\n                 LateBoundRegionConversionTime::FnCall,\n                 supplied_sig.output(),"}, {"sha": "639cab98f1741f02175482d65b658417c12cb8e0", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "patch": "@@ -241,13 +241,13 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         make_adjustments: impl FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n     ) -> CoerceResult<'tcx> {\n         debug!(\"coerce_from_inference_variable(a={:?}, b={:?})\", a, b);\n-        assert!(a.is_ty_var() && self.infcx.shallow_resolve(a) == a);\n-        assert!(self.infcx.shallow_resolve(b) == b);\n+        assert!(a.is_ty_var() && self.shallow_resolve(a) == a);\n+        assert!(self.shallow_resolve(b) == b);\n \n         if b.is_ty_var() {\n             // Two unresolved type variables: create a `Coerce` predicate.\n             let target_ty = if self.use_lub {\n-                self.infcx.next_ty_var(TypeVariableOrigin {\n+                self.next_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::LatticeVariable,\n                     span: self.cause.span,\n                 })\n@@ -991,7 +991,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.autoderef(rustc_span::DUMMY_SP, expr_ty).nth(1).and_then(|(deref_ty, _)| {\n             self.infcx\n                 .type_implements_trait(\n-                    self.infcx.tcx.lang_items().deref_mut_trait()?,\n+                    self.tcx.lang_items().deref_mut_trait()?,\n                     expr_ty,\n                     ty::List::empty(),\n                     self.param_env,"}, {"sha": "9f7ceda4e9cb92b2f89b054bef13efc16b31db80", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "patch": "@@ -815,7 +815,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref expr),\n                 _,\n                 &ty::Ref(_, checked, _),\n-            ) if self.infcx.can_sub(self.param_env, checked, expected).is_ok() => {\n+            ) if self.can_sub(self.param_env, checked, expected).is_ok() => {\n                 // We have `&T`, check if what was expected was `T`. If so,\n                 // we may want to suggest removing a `&`.\n                 if sm.is_imported(expr.span) {\n@@ -959,7 +959,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     // For this suggestion to make sense, the type would need to be `Copy`,\n                     // or we have to be moving out of a `Box<T>`\n-                    if self.infcx.type_is_copy_modulo_regions(self.param_env, expected, sp)\n+                    if self.type_is_copy_modulo_regions(self.param_env, expected, sp)\n                         // FIXME(compiler-errors): We can actually do this if the checked_ty is\n                         // `steps` layers of boxes, not just one, but this is easier and most likely.\n                         || (checked_ty.is_box() && steps == 1)"}, {"sha": "ba5ef5edc8630cd803cbe4379652e48f992ef578", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "patch": "@@ -2235,7 +2235,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base: &'tcx hir::Expr<'tcx>,\n         ty: Ty<'tcx>,\n     ) {\n-        let output_ty = match self.infcx.get_impl_future_output_ty(ty) {\n+        let output_ty = match self.get_impl_future_output_ty(ty) {\n             Some(output_ty) => self.resolve_vars_if_possible(output_ty),\n             _ => return,\n         };"}, {"sha": "4059b3403b19fe4851db0658c6d1fe870b8a9a3d", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "patch": "@@ -218,9 +218,9 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             .diverging_type_vars\n             .borrow()\n             .iter()\n-            .map(|&ty| self.infcx.shallow_resolve(ty))\n+            .map(|&ty| self.shallow_resolve(ty))\n             .filter_map(|ty| ty.ty_vid())\n-            .map(|vid| self.infcx.root_var(vid))\n+            .map(|vid| self.root_var(vid))\n             .collect();\n         debug!(\n             \"calculate_diverging_fallback: diverging_type_vars={:?}\",\n@@ -236,7 +236,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         let mut diverging_vids = vec![];\n         let mut non_diverging_vids = vec![];\n         for unsolved_vid in unsolved_vids {\n-            let root_vid = self.infcx.root_var(unsolved_vid);\n+            let root_vid = self.root_var(unsolved_vid);\n             debug!(\n                 \"calculate_diverging_fallback: unsolved_vid={:?} root_vid={:?} diverges={:?}\",\n                 unsolved_vid,\n@@ -271,7 +271,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // variables. (Note that this set consists of \"root variables\".)\n         let mut roots_reachable_from_non_diverging = DepthFirstSearch::new(&coercion_graph);\n         for &non_diverging_vid in &non_diverging_vids {\n-            let root_vid = self.infcx.root_var(non_diverging_vid);\n+            let root_vid = self.root_var(non_diverging_vid);\n             if roots_reachable_from_diverging.visited(root_vid) {\n                 continue;\n             }\n@@ -294,15 +294,15 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         diverging_fallback.reserve(diverging_vids.len());\n         for &diverging_vid in &diverging_vids {\n             let diverging_ty = self.tcx.mk_ty_var(diverging_vid);\n-            let root_vid = self.infcx.root_var(diverging_vid);\n+            let root_vid = self.root_var(diverging_vid);\n             let can_reach_non_diverging = coercion_graph\n                 .depth_first_search(root_vid)\n                 .any(|n| roots_reachable_from_non_diverging.visited(n));\n \n             let mut relationship = ty::FoundRelationships { self_in_trait: false, output: false };\n \n             for (vid, rel) in relationships.iter() {\n-                if self.infcx.root_var(*vid) == root_vid {\n+                if self.root_var(*vid) == root_vid {\n                     relationship.self_in_trait |= rel.self_in_trait;\n                     relationship.output |= rel.output;\n                 }\n@@ -387,12 +387,12 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             })\n             .collect();\n         debug!(\"create_coercion_graph: coercion_edges={:?}\", coercion_edges);\n-        let num_ty_vars = self.infcx.num_ty_vars();\n+        let num_ty_vars = self.num_ty_vars();\n         VecGraph::new(num_ty_vars, coercion_edges)\n     }\n \n     /// If `ty` is an unresolved type variable, returns its root vid.\n     fn root_vid(&self, ty: Ty<'tcx>) -> Option<ty::TyVid> {\n-        Some(self.infcx.root_var(self.infcx.shallow_resolve(ty).ty_vid()?))\n+        Some(self.root_var(self.shallow_resolve(ty).ty_vid()?))\n     }\n }"}, {"sha": "d1c10a3b63c65cdf15cb637757e5e9d185f831e7", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "patch": "@@ -185,20 +185,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if !method.substs.is_empty() {\n             let method_generics = self.tcx.generics_of(method.def_id);\n             if !method_generics.params.is_empty() {\n-                let user_type_annotation = self.infcx.probe(|_| {\n+                let user_type_annotation = self.probe(|_| {\n                     let user_substs = UserSubsts {\n                         substs: InternalSubsts::for_item(self.tcx, method.def_id, |param, _| {\n                             let i = param.index as usize;\n                             if i < method_generics.parent_count {\n-                                self.infcx.var_for_def(DUMMY_SP, param)\n+                                self.var_for_def(DUMMY_SP, param)\n                             } else {\n                                 method.substs[i]\n                             }\n                         }),\n                         user_self_ty: None, // not relevant here\n                     };\n \n-                    self.infcx.canonicalize_user_type_annotation(UserType::TypeOf(\n+                    self.canonicalize_user_type_annotation(UserType::TypeOf(\n                         method.def_id,\n                         user_substs,\n                     ))\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"fcx {}\", self.tag());\n \n         if Self::can_contain_user_lifetime_bounds((substs, user_self_ty)) {\n-            let canonicalized = self.infcx.canonicalize_user_type_annotation(UserType::TypeOf(\n+            let canonicalized = self.canonicalize_user_type_annotation(UserType::TypeOf(\n                 def_id,\n                 UserSubsts { substs, user_self_ty },\n             ));\n@@ -480,7 +480,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"to_ty_saving_user_provided_ty: ty={:?}\", ty);\n \n         if Self::can_contain_user_lifetime_bounds(ty) {\n-            let c_ty = self.infcx.canonicalize_response(UserType::Ty(ty));\n+            let c_ty = self.canonicalize_response(UserType::Ty(ty));\n             debug!(\"to_ty_saving_user_provided_ty: c_ty={:?}\", c_ty);\n             self.typeck_results.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n         }\n@@ -764,7 +764,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let ty::subst::GenericArgKind::Type(ty) = ty.unpack()\n                     && let ty::Opaque(def_id, _) = *ty.kind()\n                     && let Some(def_id) = def_id.as_local()\n-                    && self.infcx.opaque_type_origin(def_id, DUMMY_SP).is_some() {\n+                    && self.opaque_type_origin(def_id, DUMMY_SP).is_some() {\n                     return None;\n                 }\n             }\n@@ -826,7 +826,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             self.tcx.bound_type_of(def_id)\n         };\n-        let substs = self.infcx.fresh_substs_for_item(span, def_id);\n+        let substs = self.fresh_substs_for_item(span, def_id);\n         let ty = item_ty.subst(self.tcx, substs);\n \n         self.write_resolution(hir_id, Ok((def_kind, def_id)));"}, {"sha": "498913ce546eb0c21e828a6d8dd1a65ace73a298", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "patch": "@@ -1520,21 +1520,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ```\n     fn get_expr_coercion_span(&self, expr: &hir::Expr<'_>) -> rustc_span::Span {\n         let check_in_progress = |elem: &hir::Expr<'_>| {\n-            self.in_progress_typeck_results\n-                .and_then(|typeck_results| typeck_results.borrow().node_type_opt(elem.hir_id))\n-                .and_then(|ty| {\n-                    if ty.is_never() {\n-                        None\n-                    } else {\n-                        Some(match elem.kind {\n-                            // Point at the tail expression when possible.\n-                            hir::ExprKind::Block(block, _) => {\n-                                block.expr.map_or(block.span, |e| e.span)\n-                            }\n-                            _ => elem.span,\n-                        })\n-                    }\n-                })\n+            self.typeck_results.borrow().node_type_opt(elem.hir_id).filter(|ty| !ty.is_never()).map(\n+                |_| match elem.kind {\n+                    // Point at the tail expression when possible.\n+                    hir::ExprKind::Block(block, _) => block.expr.map_or(block.span, |e| e.span),\n+                    _ => elem.span,\n+                },\n+            )\n         };\n \n         if let hir::ExprKind::If(_, _, Some(el)) = expr.kind {"}, {"sha": "8f5f3657fc972eb628875867fc33a9deae88124d", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "patch": "@@ -343,15 +343,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         OP: FnOnce(ProbeContext<'a, 'tcx>) -> Result<R, MethodError<'tcx>>,\n     {\n         let mut orig_values = OriginalQueryValues::default();\n-        let param_env_and_self_ty = self.infcx.canonicalize_query(\n+        let param_env_and_self_ty = self.canonicalize_query(\n             ParamEnvAnd { param_env: self.param_env, value: self_ty },\n             &mut orig_values,\n         );\n \n         let steps = if mode == Mode::MethodCall {\n             self.tcx.method_autoderef_steps(param_env_and_self_ty)\n         } else {\n-            self.infcx.probe(|_| {\n+            self.probe(|_| {\n                 // Mode::Path - the deref steps is \"trivial\". This turns\n                 // our CanonicalQuery into a \"trivial\" QueryResponse. This\n                 // is a bit inefficient, but I don't think that writing"}, {"sha": "93d34c72109cfdd51dddadbfa30d6049c5408f4b", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "patch": "@@ -865,27 +865,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .join(\"\\n\");\n                         let actual_prefix = actual.prefix_string(self.tcx);\n                         info!(\"unimplemented_traits.len() == {}\", unimplemented_traits.len());\n-                        let (primary_message, label) = if unimplemented_traits.len() == 1\n-                            && unimplemented_traits_only\n-                        {\n-                            unimplemented_traits\n-                                .into_iter()\n-                                .next()\n-                                .map(|(_, (trait_ref, obligation))| {\n-                                    if trait_ref.self_ty().references_error()\n-                                        || actual.references_error()\n-                                    {\n-                                        // Avoid crashing.\n-                                        return (None, None);\n-                                    }\n-                                    let OnUnimplementedNote { message, label, .. } =\n-                                        self.infcx.on_unimplemented_note(trait_ref, &obligation);\n-                                    (message, label)\n-                                })\n-                                .unwrap_or((None, None))\n-                        } else {\n-                            (None, None)\n-                        };\n+                        let (primary_message, label) =\n+                            if unimplemented_traits.len() == 1 && unimplemented_traits_only {\n+                                unimplemented_traits\n+                                    .into_iter()\n+                                    .next()\n+                                    .map(|(_, (trait_ref, obligation))| {\n+                                        if trait_ref.self_ty().references_error()\n+                                            || actual.references_error()\n+                                        {\n+                                            // Avoid crashing.\n+                                            return (None, None);\n+                                        }\n+                                        let OnUnimplementedNote { message, label, .. } =\n+                                            self.on_unimplemented_note(trait_ref, &obligation);\n+                                        (message, label)\n+                                    })\n+                                    .unwrap_or((None, None))\n+                            } else {\n+                                (None, None)\n+                            };\n                         let primary_message = primary_message.unwrap_or_else(|| format!(\n                             \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, but its trait bounds were not satisfied\"\n                         ));\n@@ -1648,7 +1647,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         call: &hir::Expr<'_>,\n         span: Span,\n     ) {\n-        let output_ty = match self.infcx.get_impl_future_output_ty(ty) {\n+        let output_ty = match self.get_impl_future_output_ty(ty) {\n             Some(output_ty) => self.resolve_vars_if_possible(output_ty).skip_binder(),\n             _ => return,\n         };"}, {"sha": "920b3e688089b1f1070c4737b695eaf47c7bf043", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "patch": "@@ -475,7 +475,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         suggest_deref_binop(lhs_deref_ty);\n                 } else if is_assign == IsAssign::No\n                     && let Ref(_, lhs_deref_ty, _) = lhs_ty.kind() {\n-                    if self.infcx.type_is_copy_modulo_regions(self.param_env, *lhs_deref_ty, lhs_expr.span) {\n+                    if self.type_is_copy_modulo_regions(self.param_env, *lhs_deref_ty, lhs_expr.span) {\n                         suggest_deref_binop(*lhs_deref_ty);\n                     }\n                 }\n@@ -523,7 +523,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         _ => None,\n                                     };\n \n-                                    self.infcx.suggest_restricting_param_bound(\n+                                    self.suggest_restricting_param_bound(\n                                         &mut err,\n                                         trait_pred,\n                                         proj_pred,\n@@ -740,7 +740,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 error.obligation.predicate.to_opt_poly_trait_pred()\n                             });\n                         for pred in predicates {\n-                            self.infcx.suggest_restricting_param_bound(\n+                            self.suggest_restricting_param_bound(\n                                 &mut err,\n                                 pred,\n                                 None,"}, {"sha": "d72e215934a0d8626bbd9980fd6b315ce1df039c", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "patch": "@@ -948,7 +948,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let root_var_min_capture_list = min_captures.and_then(|m| m.get(&var_hir_id))?;\n \n-        let ty = self.infcx.resolve_vars_if_possible(self.node_ty(var_hir_id));\n+        let ty = self.resolve_vars_if_possible(self.node_ty(var_hir_id));\n \n         let ty = match closure_clause {\n             hir::CaptureBy::Value => ty, // For move closure the capture kind should be by value\n@@ -1064,7 +1064,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         closure_clause: hir::CaptureBy,\n         var_hir_id: hir::HirId,\n     ) -> Option<FxHashSet<UpvarMigrationInfo>> {\n-        let ty = self.infcx.resolve_vars_if_possible(self.node_ty(var_hir_id));\n+        let ty = self.resolve_vars_if_possible(self.node_ty(var_hir_id));\n \n         if !ty.has_significant_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local())) {\n             debug!(\"does not have significant drop\");"}, {"sha": "fa6053ac39585be8eddb6b49b5e5540251dcba6b", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=aaa9989c2fcf10ab47d89be1ff9887a4fdb8e7b6", "patch": "@@ -748,7 +748,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n                 // (e.g. keep `for<'a>` named `for<'a>`).\n                 // This allows NLL to generate error messages that\n                 // refer to the higher-ranked lifetime names written by the user.\n-                EraseEarlyRegions { tcx: self.infcx.tcx }.fold_ty(t)\n+                EraseEarlyRegions { tcx: self.tcx }.fold_ty(t)\n             }\n             Err(_) => {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\", t);\n@@ -766,7 +766,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n \n     fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         match self.infcx.fully_resolve(ct) {\n-            Ok(ct) => self.infcx.tcx.erase_regions(ct),\n+            Ok(ct) => self.tcx.erase_regions(ct),\n             Err(_) => {\n                 debug!(\"Resolver::fold_const: input const `{:?}` not fully resolvable\", ct);\n                 self.report_const_error(ct);"}]}