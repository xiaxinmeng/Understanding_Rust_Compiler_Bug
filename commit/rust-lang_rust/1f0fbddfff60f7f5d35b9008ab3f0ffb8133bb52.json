{"sha": "1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmMGZiZGRmZmY2MGY3ZjVkMzViOTAwOGFiM2YwZmZiODEzM2JiNTI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-09-17T23:47:53Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-09-18T00:06:45Z"}, "message": "Fine tune dianostics for when a borrow conflicts with a destructor that needs exclusive access.\n\nIn particular:\n\n 1. Extend `WriteKind::StorageDeadOrDrop` with state to track whether\n    we are running a destructor or just freeing backing storage.  (As\n    part of this, when we drop a Box<..<Box<T>..> where `T` does not\n    need drop, we now signal that the drop of `T` is a kind of storage\n    dead rather than a drop.)\n\n 2. When reporting that a value does not live long enough, check if\n    we're doing an \"interesting\" drop, i.e. we aren't just trivally\n    freeing the borrowed state, but rather a user-defined dtor will\n    run and potentially require exclusive aces to the borrowed state.\n\n 3. Added a new diagnosic to describe the scenario here.", "tree": {"sha": "7fa67ff0f2a42bfb71d13c3e3977aa6f8aa93ddd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fa67ff0f2a42bfb71d13c3e3977aa6f8aa93ddd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52", "html_url": "https://github.com/rust-lang/rust/commit/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2224a42c353636db6ee53cc3f9b1a968e9d9c1f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2224a42c353636db6ee53cc3f9b1a968e9d9c1f6", "html_url": "https://github.com/rust-lang/rust/commit/2224a42c353636db6ee53cc3f9b1a968e9d9c1f6"}], "stats": {"total": 208, "additions": 187, "deletions": 21}, "files": [{"sha": "73db525eb56911ccf46e831f48e10a0a597216c6", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 92, "deletions": 1, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::WriteKind;\n+use borrow_check::{WriteKind, StorageDeadOrDrop};\n+use borrow_check::prefixes::IsPrefixOf;\n use rustc::middle::region::ScopeTree;\n use rustc::mir::VarBindingForm;\n use rustc::mir::{BindingForm, BorrowKind, ClearCrossCrate, Field, Local};\n@@ -374,13 +375,27 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.buffer(&mut self.errors_buffer);\n     }\n \n+    /// Reports StorageDeadOrDrop of `place` conflicts with `borrow`.\n+    ///\n+    /// This means that some data referenced by `borrow` needs to live\n+    /// past the point where the StorageDeadOrDrop of `place` occurs.\n+    /// This is usually interpreted as meaning that `place` has too\n+    /// short a lifetime. (But sometimes it is more useful to report\n+    /// it as a more direct conflict between the execution of a\n+    /// `Drop::drop` with an aliasing borrow.)\n     pub(super) fn report_borrowed_value_does_not_live_long_enough(\n         &mut self,\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n         place_span: (&Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n     ) {\n+        debug!(\"report_borrowed_value_does_not_live_long_enough(\\\n+                {:?}, {:?}, {:?}, {:?}\\\n+                )\",\n+               context, borrow, place_span, kind\n+        );\n+\n         let drop_span = place_span.1;\n         let scope_tree = self.tcx.region_scope_tree(self.mir_def_id);\n         let root_place = self\n@@ -412,6 +427,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         let borrow_reason = self.find_why_borrow_contains_point(context, borrow);\n \n+        if let Some(WriteKind::StorageDeadOrDrop(StorageDeadOrDrop::Destructor)) = kind\n+        {\n+            // If a borrow of path `B` conflicts with drop of `D` (and\n+            // we're not in the uninteresting case where `B` is a\n+            // prefix of `D`), then report this as a more interesting\n+            // destructor conflict.\n+            if !borrow.borrowed_place.is_prefix_of(place_span.0) {\n+                self.report_borrow_conflicts_with_destructor(\n+                    context, borrow, borrow_reason, place_span, kind);\n+                return;\n+            }\n+        }\n+\n         let mut err = match &self.describe_place(&borrow.borrowed_place) {\n             Some(_) if self.is_place_thread_local(root_place) => {\n                 self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span)\n@@ -475,6 +503,69 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err\n     }\n \n+    pub(super) fn report_borrow_conflicts_with_destructor(\n+        &mut self,\n+        context: Context,\n+        borrow: &BorrowData<'tcx>,\n+        borrow_reason: BorrowContainsPointReason<'tcx>,\n+        place_span: (&Place<'tcx>, Span),\n+        kind: Option<WriteKind>,\n+    ) {\n+        debug!(\n+            \"report_borrow_conflicts_with_destructor(\\\n+             {:?}, {:?}, {:?}, {:?} {:?}\\\n+             )\",\n+            context, borrow, borrow_reason, place_span, kind,\n+        );\n+\n+        let borrow_spans = self.retrieve_borrow_spans(borrow);\n+        let borrow_span = borrow_spans.var_or_use();\n+\n+        let mut err = self.tcx.cannot_borrow_across_destructor(borrow_span, Origin::Mir);\n+\n+        let drop_span = place_span.1;\n+\n+        let (what_was_dropped, dropped_ty) = {\n+            let place = place_span.0;\n+            let desc = match self.describe_place(place) {\n+                Some(name) => format!(\"`{}`\", name.as_str()),\n+                None => format!(\"temporary value\"),\n+            };\n+            let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n+            (desc, ty)\n+        };\n+\n+        let label = match dropped_ty.sty {\n+            ty::Adt(adt, _) if adt.has_dtor(self.tcx) && !adt.is_box() => {\n+                match self.describe_place(&borrow.borrowed_place) {\n+                    Some(borrowed) =>\n+                        format!(\"here, drop of {D} needs exclusive access to `{B}`, \\\n+                                 because the type `{T}` implements the `Drop` trait\",\n+                                D=what_was_dropped, T=dropped_ty, B=borrowed),\n+                    None =>\n+                        format!(\"here is drop of {D}; whose type `{T}` implements the `Drop` trait\",\n+                                D=what_was_dropped, T=dropped_ty),\n+                }\n+            }\n+            _ => format!(\"drop of {D} occurs here\", D=what_was_dropped),\n+        };\n+        err.span_label(drop_span, label);\n+\n+        // Only give this note and suggestion if they could be relevant\n+        match borrow_reason {\n+            BorrowContainsPointReason::Liveness {..}\n+            | BorrowContainsPointReason::DropLiveness {..} => {\n+                err.note(\"consider using a `let` binding to create a longer lived value\");\n+            }\n+            BorrowContainsPointReason::OutlivesFreeRegion {..} => (),\n+        }\n+\n+        self.report_why_borrow_contains_point(\n+            &mut err, borrow_reason, kind.map(|k| (k, place_span.0)));\n+\n+        err.buffer(&mut self.errors_buffer);\n+    }\n+\n     fn report_thread_local_value_does_not_live_long_enough(\n         &mut self,\n         drop_span: Span,"}, {"sha": "22cdc5d6f40eeb77db3af2db53a64a7ef5afca6e", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52", "patch": "@@ -551,7 +551,8 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 self.access_place(\n                     ContextKind::StorageDead.new(location),\n                     (&Place::Local(local), span),\n-                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n+                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop(\n+                        StorageDeadOrDrop::LocalStorageDead))),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,\n                 );\n@@ -778,12 +779,21 @@ enum ReadKind {\n /// (For informational purposes only)\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum WriteKind {\n-    StorageDeadOrDrop,\n+    StorageDeadOrDrop(StorageDeadOrDrop),\n     MutableBorrow(BorrowKind),\n     Mutate,\n     Move,\n }\n \n+/// Specify whether which case a StorageDeadOrDrop is in.\n+/// (For informational purposes only)\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum StorageDeadOrDrop {\n+    LocalStorageDead,\n+    BoxedStorageDead,\n+    Destructor,\n+}\n+\n /// When checking permissions for a place access, this flag is used to indicate that an immutable\n /// local place can be mutated.\n ///\n@@ -1012,7 +1022,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     self.access_place(\n                         ContextKind::Drop.new(loc),\n                         (drop_place, span),\n-                        (Deep, Write(WriteKind::StorageDeadOrDrop)),\n+                        (Deep, Write(WriteKind::StorageDeadOrDrop(\n+                            StorageDeadOrDrop::Destructor))),\n                         LocalMutationIsAllowed::Yes,\n                         flow_state,\n                     );\n@@ -1039,15 +1050,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     //   Why? Because we do not schedule/emit\n                     //   `Drop(x)` in the MIR unless `x` needs drop in\n                     //   the first place.\n-                    //\n-                    // FIXME: Its possible this logic actually should\n-                    // be attached to the `StorageDead` statement\n-                    // rather than the `Drop`. See discussion on PR\n-                    // #52782.\n                     self.access_place(\n                         ContextKind::Drop.new(loc),\n                         (drop_place, span),\n-                        (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n+                        (Shallow(None), Write(WriteKind::StorageDeadOrDrop(\n+                            // rust-lang/rust#52059: distinguish\n+                            // between invaliding the backing storage\n+                            // vs running a destructor.\n+                            //\n+                            // See also: rust-lang/rust#52782,\n+                            // specifically #discussion_r206658948\n+                            StorageDeadOrDrop::BoxedStorageDead))),\n                         LocalMutationIsAllowed::Yes,\n                         flow_state,\n                     );\n@@ -1215,14 +1228,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             error_reported = true;\n                             this.report_conflicting_borrow(context, place_span, bk, &borrow)\n                         }\n-                        WriteKind::StorageDeadOrDrop => {\n+                        WriteKind::StorageDeadOrDrop(_) => {\n                             error_reported = true;\n                             this.report_borrowed_value_does_not_live_long_enough(\n                                 context,\n                                 borrow,\n                                 place_span,\n-                                Some(kind),\n-                            );\n+                                Some(kind))\n                         }\n                         WriteKind::Mutate => {\n                             error_reported = true;\n@@ -1464,7 +1476,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns whether a borrow of this place is invalidated when the function\n+    /// Checks whether a borrow of this place is invalidated when the function\n     /// exits\n     fn check_for_invalidation_at_exit(\n         &mut self,\n@@ -1889,9 +1901,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             Reservation(wk @ WriteKind::Move)\n             | Write(wk @ WriteKind::Move)\n-            | Reservation(wk @ WriteKind::StorageDeadOrDrop)\n+            | Reservation(wk @ WriteKind::StorageDeadOrDrop(_))\n             | Reservation(wk @ WriteKind::MutableBorrow(BorrowKind::Shared))\n-            | Write(wk @ WriteKind::StorageDeadOrDrop)\n+            | Write(wk @ WriteKind::StorageDeadOrDrop(_))\n             | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shared)) => {\n                 if let Err(_place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n                     if self.tcx.migrate_borrowck() {\n@@ -1906,7 +1918,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         error_access = match wk {\n                             WriteKind::MutableBorrow(_) => AccessKind::MutableBorrow,\n                             WriteKind::Move => AccessKind::Move,\n-                            WriteKind::StorageDeadOrDrop |\n+                            WriteKind::StorageDeadOrDrop(_) |\n                             WriteKind::Mutate => AccessKind::Mutate,\n                         };\n                         self.report_mutability_error("}, {"sha": "8a44895a97c61ecce8fa84ce404c70e650c1a2eb", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52", "patch": "@@ -154,7 +154,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         format!(\"borrow later used here, when `{}` is dropped\", local_name),\n                     );\n \n-                    if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n+                    if let Some((WriteKind::StorageDeadOrDrop(_), place)) = kind_place {\n                         if let Place::Local(borrowed_local) = place {\n                             let dropped_local_scope = mir.local_decls[local].visibility_scope;\n                             let borrowed_local_scope ="}, {"sha": "81f7fa89e9945ca61c2d594951ec57eef0fe258a", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52", "patch": "@@ -16,7 +16,7 @@ use borrow_check::{ReadOrWrite, Activation, Read, Reservation, Write};\n use borrow_check::{Context, ContextKind};\n use borrow_check::{LocalMutationIsAllowed, MutateMode};\n use borrow_check::ArtificialField;\n-use borrow_check::{ReadKind, WriteKind};\n+use borrow_check::{ReadKind, WriteKind, StorageDeadOrDrop};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::path_utils::*;\n use dataflow::move_paths::indexes::BorrowIndex;\n@@ -154,7 +154,8 @@ impl<'cg, 'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cg, 'cx, 'tc\n                 self.access_place(\n                     ContextKind::StorageDead.new(location),\n                     &Place::Local(local),\n-                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n+                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop(\n+                        StorageDeadOrDrop::LocalStorageDead))),\n                     LocalMutationIsAllowed::Yes,\n                 );\n             }\n@@ -347,7 +348,8 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n                     self.access_place(\n                         ContextKind::Drop.new(loc),\n                         drop_place,\n-                        (Deep, Write(WriteKind::StorageDeadOrDrop)),\n+                        (Deep, Write(WriteKind::StorageDeadOrDrop(\n+                            StorageDeadOrDrop::Destructor))),\n                         LocalMutationIsAllowed::Yes,\n                     );\n                 }"}, {"sha": "a09eece02661600a2bca7ea7e6b284a4714cdec6", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52", "patch": "@@ -2187,6 +2187,51 @@ fn main() {\n ```\n \"##,\n \n+E0713: r##\"\n+This error occurs when an attempt is made to borrow state past the end of the\n+lifetime of a type that implements the `Drop` trait.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0713\n+pub struct S<'a> { data: &'a mut String }\n+\n+impl<'a> Drop for S<'a> {\n+    fn drop(&mut self) { self.data.push_str(\"being dropped\"); }\n+}\n+\n+fn demo(s: S) -> &mut String { let p = &mut *s.data; p }\n+```\n+\n+Here, `demo` tries to borrow the string data held within its\n+argument `s` and then return that borrow. However, `S` is\n+declared as implementing `Drop`.\n+\n+Structs implementing the `Drop` trait have an implicit destructor that\n+gets called when they go out of scope. This destructor gets exclusive\n+access to the fields of the struct when it runs.\n+\n+This means that when `s` reaches the end of `demo`, its destructor\n+gets exclusive access to its `&mut`-borrowed string data.  allowing\n+another borrow of that string data (`p`), to exist across the drop of\n+`s` would be a violation of the principle that `&mut`-borrows have\n+exclusive, unaliased access to their referenced data.\n+\n+This error can be fixed by changing `demo` so that the destructor does\n+not run while the string-data is borrowed; for example by taking `S`\n+by reference:\n+\n+```\n+pub struct S<'a> { data: &'a mut String }\n+\n+impl<'a> Drop for S<'a> {\n+    fn drop(&mut self) { self.data.push_str(\"being dropped\"); }\n+}\n+\n+fn demo(s: &mut S) -> &mut String { let p = &mut *(*s).data; p }\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "82617ee10747000c9a07cafc7d8b173d075345b8", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=1f0fbddfff60f7f5d35b9008ab3f0ffb8133bb52", "patch": "@@ -573,6 +573,22 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n+    fn cannot_borrow_across_destructor(\n+        self,\n+        borrow_span: Span,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            borrow_span,\n+            E0713,\n+            \"borrow may still be in use when destructor runs{OGN}\",\n+            OGN = o\n+        );\n+\n+        self.cancel_if_wrong_origin(err, o)\n+    }\n+\n     fn path_does_not_live_long_enough(\n         self,\n         span: Span,"}]}