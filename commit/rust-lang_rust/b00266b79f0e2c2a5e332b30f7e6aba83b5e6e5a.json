{"sha": "b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMDI2NmI3OWYwZTJjMmE1ZTMzMmIzMGY3ZTZhYmE4M2I1ZTZlNWE=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-04-01T17:46:43Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-04-01T17:46:43Z"}, "message": "Global TypeRef/TraitRef interning", "tree": {"sha": "c7e591ec8a1ec6b401a8a7ea00115120a4789db5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7e591ec8a1ec6b401a8a7ea00115120a4789db5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a", "html_url": "https://github.com/rust-lang/rust/commit/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25201b2dad7b4b0d41494e238ebf643ad7ad8cd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/25201b2dad7b4b0d41494e238ebf643ad7ad8cd6", "html_url": "https://github.com/rust-lang/rust/commit/25201b2dad7b4b0d41494e238ebf643ad7ad8cd6"}], "stats": {"total": 325, "additions": 205, "deletions": 120}, "files": [{"sha": "4344f8df5aa69aed33df1c4422d7f9500608cc94", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a", "patch": "@@ -500,6 +500,7 @@ dependencies = [\n  \"base_db\",\n  \"cfg\",\n  \"cov-mark\",\n+ \"dashmap\",\n  \"drop_bomb\",\n  \"either\",\n  \"expect-test\","}, {"sha": "ab04c55bc19e02498350bbc019599854eecbe4a2", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a", "patch": "@@ -91,7 +91,7 @@ impl HirDisplay for Function {\n         let ret_type = if !qual.is_async {\n             &data.ret_type\n         } else {\n-            match &data.ret_type {\n+            match &*data.ret_type {\n                 TypeRef::ImplTrait(bounds) => match &bounds[0] {\n                     TypeBound::Path(path) => {\n                         path.segments().iter().last().unwrap().args_and_bindings.unwrap().bindings"}, {"sha": "06fd6542d61c973d2601dee3f448e7bad9c82f3a", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a", "patch": "@@ -957,7 +957,7 @@ impl SelfParam {\n         func_data\n             .params\n             .first()\n-            .map(|param| match *param {\n+            .map(|param| match &**param {\n                 TypeRef::Reference(.., mutability) => match mutability {\n                     hir_def::type_ref::Mutability::Shared => Access::Shared,\n                     hir_def::type_ref::Mutability::Mut => Access::Exclusive,\n@@ -1011,7 +1011,7 @@ impl Const {\n     }\n \n     pub fn type_ref(self, db: &dyn HirDatabase) -> TypeRef {\n-        db.const_data(self.id).type_ref.clone()\n+        db.const_data(self.id).type_ref.as_ref().clone()\n     }\n }\n \n@@ -1101,7 +1101,7 @@ impl TypeAlias {\n     }\n \n     pub fn type_ref(self, db: &dyn HirDatabase) -> Option<TypeRef> {\n-        db.type_alias_data(self.id).type_ref.clone()\n+        db.type_alias_data(self.id).type_ref.as_deref().cloned()\n     }\n \n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n@@ -1615,7 +1615,7 @@ impl Impl {\n     // FIXME: the return type is wrong. This should be a hir version of\n     // `TraitRef` (ie, resolved `TypeRef`).\n     pub fn trait_(self, db: &dyn HirDatabase) -> Option<TraitRef> {\n-        db.impl_data(self.id).target_trait.clone()\n+        db.impl_data(self.id).target_trait.as_deref().cloned()\n     }\n \n     pub fn self_ty(self, db: &dyn HirDatabase) -> Type {"}, {"sha": "43324d8d9b160319a3c6c725383c429db3e12e5d", "filename": "crates/hir_def/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2FCargo.toml?ref=b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a", "patch": "@@ -11,6 +11,7 @@ doctest = false\n \n [dependencies]\n cov-mark = { version = \"1.1\", features = [\"thread-local\"] }\n+dashmap = { version = \"4.0.2\", features = [\"raw-api\"] }\n log = \"0.4.8\"\n once_cell = \"1.3.1\"\n rustc-hash = \"1.1.0\""}, {"sha": "402fb1d8dc61fee6f8da3f7482dc574edcdc63ee", "filename": "crates/hir_def/src/adt.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fadt.rs?ref=b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a", "patch": "@@ -15,6 +15,7 @@ use tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n use crate::{\n     body::{CfgExpander, LowerCtx},\n     db::DefDatabase,\n+    intern::Interned,\n     item_tree::{AttrOwner, Field, Fields, ItemTree, ModItem, RawVisibilityId},\n     src::HasChildSource,\n     src::HasSource,\n@@ -58,7 +59,7 @@ pub enum VariantData {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct FieldData {\n     pub name: Name,\n-    pub type_ref: TypeRef,\n+    pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibility,\n }\n \n@@ -292,7 +293,7 @@ fn lower_struct(\n                     || Either::Left(fd.clone()),\n                     || FieldData {\n                         name: Name::new_tuple_field(i),\n-                        type_ref: TypeRef::from_ast_opt(&ctx, fd.ty()),\n+                        type_ref: Interned::new(TypeRef::from_ast_opt(&ctx, fd.ty())),\n                         visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n                     },\n                 );\n@@ -309,7 +310,7 @@ fn lower_struct(\n                     || Either::Right(fd.clone()),\n                     || FieldData {\n                         name: fd.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n-                        type_ref: TypeRef::from_ast_opt(&ctx, fd.ty()),\n+                        type_ref: Interned::new(TypeRef::from_ast_opt(&ctx, fd.ty())),\n                         visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n                     },\n                 );\n@@ -358,7 +359,7 @@ fn lower_field(\n ) -> FieldData {\n     FieldData {\n         name: field.name.clone(),\n-        type_ref: item_tree[field.type_ref].clone(),\n+        type_ref: field.type_ref.clone(),\n         visibility: item_tree[override_visibility.unwrap_or(field.visibility)].clone(),\n     }\n }"}, {"sha": "31f994681960a893fc0a3759532937e9e4960696", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a", "patch": "@@ -9,6 +9,7 @@ use crate::{\n     attr::Attrs,\n     body::Expander,\n     db::DefDatabase,\n+    intern::Interned,\n     item_tree::{AssocItem, FunctionQualifier, ItemTreeId, ModItem, Param},\n     type_ref::{TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n@@ -19,8 +20,8 @@ use crate::{\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct FunctionData {\n     pub name: Name,\n-    pub params: Vec<TypeRef>,\n-    pub ret_type: TypeRef,\n+    pub params: Vec<Interned<TypeRef>>,\n+    pub ret_type: Interned<TypeRef>,\n     pub attrs: Attrs,\n     /// True if the first param is `self`. This is relevant to decide whether this\n     /// can be called as a method.\n@@ -57,11 +58,11 @@ impl FunctionData {\n             params: enabled_params\n                 .clone()\n                 .filter_map(|id| match &item_tree[id] {\n-                    Param::Normal(ty) => Some(item_tree[*ty].clone()),\n+                    Param::Normal(ty) => Some(ty.clone()),\n                     Param::Varargs => None,\n                 })\n                 .collect(),\n-            ret_type: item_tree[func.ret_type].clone(),\n+            ret_type: func.ret_type.clone(),\n             attrs: item_tree.attrs(db, krate, ModItem::from(loc.id.value).into()),\n             has_self_param: func.has_self_param,\n             has_body: func.has_body,\n@@ -76,7 +77,7 @@ impl FunctionData {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct TypeAliasData {\n     pub name: Name,\n-    pub type_ref: Option<TypeRef>,\n+    pub type_ref: Option<Interned<TypeRef>>,\n     pub visibility: RawVisibility,\n     pub is_extern: bool,\n     /// Bounds restricting the type alias itself (eg. `type Ty: Bound;` in a trait or impl).\n@@ -94,7 +95,7 @@ impl TypeAliasData {\n \n         Arc::new(TypeAliasData {\n             name: typ.name.clone(),\n-            type_ref: typ.type_ref.map(|id| item_tree[id].clone()),\n+            type_ref: typ.type_ref.clone(),\n             visibility: item_tree[typ.visibility].clone(),\n             is_extern: typ.is_extern,\n             bounds: typ.bounds.to_vec(),\n@@ -156,8 +157,8 @@ impl TraitData {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImplData {\n-    pub target_trait: Option<TraitRef>,\n-    pub self_ty: TypeRef,\n+    pub target_trait: Option<Interned<TraitRef>>,\n+    pub self_ty: Interned<TypeRef>,\n     pub items: Vec<AssocItemId>,\n     pub is_negative: bool,\n }\n@@ -169,8 +170,8 @@ impl ImplData {\n \n         let item_tree = impl_loc.id.item_tree(db);\n         let impl_def = &item_tree[impl_loc.id.value];\n-        let target_trait = impl_def.target_trait.map(|id| item_tree[id].clone());\n-        let self_ty = item_tree[impl_def.self_ty].clone();\n+        let target_trait = impl_def.target_trait.clone();\n+        let self_ty = impl_def.self_ty.clone();\n         let is_negative = impl_def.is_negative;\n         let module_id = impl_loc.container;\n         let container = AssocContainerId::ImplId(id);\n@@ -195,7 +196,7 @@ impl ImplData {\n pub struct ConstData {\n     /// const _: () = ();\n     pub name: Option<Name>,\n-    pub type_ref: TypeRef,\n+    pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibility,\n }\n \n@@ -207,7 +208,7 @@ impl ConstData {\n \n         Arc::new(ConstData {\n             name: konst.name.clone(),\n-            type_ref: item_tree[konst.type_ref].clone(),\n+            type_ref: konst.type_ref.clone(),\n             visibility: item_tree[konst.visibility].clone(),\n         })\n     }\n@@ -216,7 +217,7 @@ impl ConstData {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct StaticData {\n     pub name: Option<Name>,\n-    pub type_ref: TypeRef,\n+    pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibility,\n     pub mutable: bool,\n     pub is_extern: bool,\n@@ -230,7 +231,7 @@ impl StaticData {\n \n         Arc::new(StaticData {\n             name: Some(statik.name.clone()),\n-            type_ref: item_tree[statik.type_ref].clone(),\n+            type_ref: statik.type_ref.clone(),\n             visibility: item_tree[statik.visibility].clone(),\n             mutable: statik.mutable,\n             is_extern: statik.is_extern,"}, {"sha": "28ec72cffc08309513feeda1e67396cf01dc12b3", "filename": "crates/hir_def/src/intern.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_def%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_def%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fintern.rs?ref=b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a", "patch": "@@ -0,0 +1,157 @@\n+//! Global `Arc`-based object interning infrastructure.\n+//!\n+//! Eventually this should probably be replaced with salsa-based interning.\n+\n+use std::{\n+    fmt::{self, Debug},\n+    hash::{BuildHasherDefault, Hash},\n+    ops::Deref,\n+    sync::Arc,\n+};\n+\n+use dashmap::{DashMap, SharedValue};\n+use once_cell::sync::OnceCell;\n+use rustc_hash::FxHasher;\n+\n+type InternMap<T> = DashMap<Arc<T>, (), BuildHasherDefault<FxHasher>>;\n+\n+pub struct Interned<T: Internable> {\n+    arc: Arc<T>,\n+}\n+\n+impl<T: Internable> Interned<T> {\n+    pub fn new(obj: T) -> Self {\n+        let storage = T::storage().get();\n+        let shard_idx = storage.determine_map(&obj);\n+        let shard = &storage.shards()[shard_idx];\n+        let shard = shard.upgradeable_read();\n+\n+        // Atomically,\n+        // - check if `obj` is already in the map\n+        //   - if so, clone its `Arc` and return it\n+        //   - if not, box it up, insert it, and return a clone\n+        // This needs to be atomic (locking the shard) to avoid races with other thread, which could\n+        // insert the same object between us looking it up and inserting it.\n+\n+        // FIXME: avoid double lookup by using raw entry API (once stable, or when hashbrown can be\n+        // plugged into dashmap)\n+        if let Some((arc, _)) = shard.get_key_value(&obj) {\n+            return Self { arc: arc.clone() };\n+        }\n+\n+        let arc = Arc::new(obj);\n+        let arc2 = arc.clone();\n+\n+        {\n+            let mut shard = shard.upgrade();\n+            shard.insert(arc2, SharedValue::new(()));\n+        }\n+\n+        Self { arc }\n+    }\n+}\n+\n+impl<T: Internable> Drop for Interned<T> {\n+    fn drop(&mut self) {\n+        // When the last `Ref` is dropped, remove the object from the global map.\n+        if Arc::strong_count(&self.arc) == 2 {\n+            // Only `self` and the global map point to the object.\n+\n+            let storage = T::storage().get();\n+            let shard_idx = storage.determine_map(&self.arc);\n+            let shard = &storage.shards()[shard_idx];\n+            let mut shard = shard.write();\n+\n+            // FIXME: avoid double lookup\n+            let (arc, _) =\n+                shard.get_key_value(&self.arc).expect(\"interned value removed prematurely\");\n+\n+            if Arc::strong_count(arc) != 2 {\n+                // Another thread has interned another copy\n+                return;\n+            }\n+\n+            shard.remove(&self.arc);\n+\n+            // Shrink the backing storage if the shard is less than 50% occupied.\n+            if shard.len() * 2 < shard.capacity() {\n+                shard.shrink_to_fit();\n+            }\n+        }\n+    }\n+}\n+\n+/// Compares interned `Ref`s using pointer equality.\n+impl<T: Internable> PartialEq for Interned<T> {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        Arc::ptr_eq(&self.arc, &other.arc)\n+    }\n+}\n+\n+impl<T: Internable> Eq for Interned<T> {}\n+\n+impl<T: Internable> AsRef<T> for Interned<T> {\n+    #[inline]\n+    fn as_ref(&self) -> &T {\n+        &self.arc\n+    }\n+}\n+\n+impl<T: Internable> Deref for Interned<T> {\n+    type Target = T;\n+\n+    #[inline]\n+    fn deref(&self) -> &Self::Target {\n+        &self.arc\n+    }\n+}\n+\n+impl<T: Internable> Clone for Interned<T> {\n+    fn clone(&self) -> Self {\n+        Self { arc: self.arc.clone() }\n+    }\n+}\n+\n+impl<T: Debug + Internable> Debug for Interned<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (*self.arc).fmt(f)\n+    }\n+}\n+\n+pub struct InternStorage<T> {\n+    map: OnceCell<InternMap<T>>,\n+}\n+\n+impl<T> InternStorage<T> {\n+    pub const fn new() -> Self {\n+        Self { map: OnceCell::new() }\n+    }\n+}\n+\n+impl<T: Internable> InternStorage<T> {\n+    fn get(&self) -> &InternMap<T> {\n+        self.map.get_or_init(DashMap::default)\n+    }\n+}\n+\n+pub trait Internable: Hash + Eq + Sized + 'static {\n+    fn storage() -> &'static InternStorage<Self>;\n+}\n+\n+// region:`Internable` implementations\n+\n+macro_rules! impl_internable {\n+    ( $($t:ty),+ $(,)? ) => { $(\n+        impl Internable for $t {\n+            fn storage() -> &'static InternStorage<Self> {\n+                static STORAGE: InternStorage<$t> = InternStorage::new();\n+                &STORAGE\n+            }\n+        }\n+    )+ };\n+}\n+\n+impl_internable!(crate::type_ref::TypeRef, crate::type_ref::TraitRef);\n+\n+// endregion"}, {"sha": "9f6bb3a7cf8156e7d0859f839fcc9e218550582b", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 9, "deletions": 83, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a", "patch": "@@ -30,6 +30,7 @@ use crate::{\n     attr::{Attrs, RawAttrs},\n     db::DefDatabase,\n     generics::GenericParams,\n+    intern::Interned,\n     path::{path, AssociatedTypeBinding, GenericArgs, ImportAlias, ModPath, Path, PathKind},\n     type_ref::{Mutability, TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n@@ -146,8 +147,6 @@ impl ItemTree {\n                 macro_defs,\n                 vis,\n                 generics,\n-                type_refs,\n-                trait_refs,\n                 inner_items,\n             } = &mut **data;\n \n@@ -172,9 +171,6 @@ impl ItemTree {\n \n             vis.arena.shrink_to_fit();\n             generics.arena.shrink_to_fit();\n-            type_refs.arena.shrink_to_fit();\n-            type_refs.map.shrink_to_fit();\n-            trait_refs.map.shrink_to_fit();\n \n             inner_items.shrink_to_fit();\n         }\n@@ -271,58 +267,6 @@ static EMPTY_GENERICS: GenericParams = GenericParams {\n     where_predicates: Vec::new(),\n };\n \n-/// `TypeRef` interner.\n-#[derive(Default, Debug, Eq, PartialEq)]\n-struct TypeRefStorage {\n-    arena: Arena<Arc<TypeRef>>,\n-    map: FxHashMap<Arc<TypeRef>, Idx<Arc<TypeRef>>>,\n-}\n-\n-impl TypeRefStorage {\n-    // Note: We lie about the `Idx<TypeRef>` to hide the interner details.\n-\n-    fn intern(&mut self, ty: TypeRef) -> Idx<TypeRef> {\n-        if let Some(id) = self.map.get(&ty) {\n-            return Idx::from_raw(id.into_raw());\n-        }\n-\n-        let ty = Arc::new(ty);\n-        let idx = self.arena.alloc(ty.clone());\n-        self.map.insert(ty, idx);\n-        Idx::from_raw(idx.into_raw())\n-    }\n-\n-    fn lookup(&self, id: Idx<TypeRef>) -> &TypeRef {\n-        &self.arena[Idx::from_raw(id.into_raw())]\n-    }\n-}\n-\n-/// `TraitRef` interner.\n-#[derive(Default, Debug, Eq, PartialEq)]\n-struct TraitRefStorage {\n-    arena: Arena<Arc<TraitRef>>,\n-    map: FxHashMap<Arc<TraitRef>, Idx<Arc<TraitRef>>>,\n-}\n-\n-impl TraitRefStorage {\n-    // Note: We lie about the `Idx<TraitRef>` to hide the interner details.\n-\n-    fn intern(&mut self, ty: TraitRef) -> Idx<TraitRef> {\n-        if let Some(id) = self.map.get(&ty) {\n-            return Idx::from_raw(id.into_raw());\n-        }\n-\n-        let ty = Arc::new(ty);\n-        let idx = self.arena.alloc(ty.clone());\n-        self.map.insert(ty, idx);\n-        Idx::from_raw(idx.into_raw())\n-    }\n-\n-    fn lookup(&self, id: Idx<TraitRef>) -> &TraitRef {\n-        &self.arena[Idx::from_raw(id.into_raw())]\n-    }\n-}\n-\n #[derive(Default, Debug, Eq, PartialEq)]\n struct ItemTreeData {\n     imports: Arena<Import>,\n@@ -346,8 +290,6 @@ struct ItemTreeData {\n \n     vis: ItemVisibilities,\n     generics: GenericParamsStorage,\n-    type_refs: TypeRefStorage,\n-    trait_refs: TraitRefStorage,\n \n     inner_items: FxHashMap<FileAstId<ast::BlockExpr>, SmallVec<[ModItem; 1]>>,\n }\n@@ -577,22 +519,6 @@ impl Index<GenericParamsId> for ItemTree {\n     }\n }\n \n-impl Index<Idx<TypeRef>> for ItemTree {\n-    type Output = TypeRef;\n-\n-    fn index(&self, id: Idx<TypeRef>) -> &Self::Output {\n-        self.data().type_refs.lookup(id)\n-    }\n-}\n-\n-impl Index<Idx<TraitRef>> for ItemTree {\n-    type Output = TraitRef;\n-\n-    fn index(&self, id: Idx<TraitRef>) -> &Self::Output {\n-        self.data().trait_refs.lookup(id)\n-    }\n-}\n-\n impl<N: ItemTreeNode> Index<FileItemTreeId<N>> for ItemTree {\n     type Output = N;\n     fn index(&self, id: FileItemTreeId<N>) -> &N {\n@@ -637,13 +563,13 @@ pub struct Function {\n     /// `extern \"abi\" fn`).\n     pub is_in_extern_block: bool,\n     pub params: IdRange<Param>,\n-    pub ret_type: Idx<TypeRef>,\n+    pub ret_type: Interned<TypeRef>,\n     pub ast_id: FileAstId<ast::Fn>,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Param {\n-    Normal(Idx<TypeRef>),\n+    Normal(Interned<TypeRef>),\n     Varargs,\n }\n \n@@ -699,7 +625,7 @@ pub struct Const {\n     /// const _: () = ();\n     pub name: Option<Name>,\n     pub visibility: RawVisibilityId,\n-    pub type_ref: Idx<TypeRef>,\n+    pub type_ref: Interned<TypeRef>,\n     pub ast_id: FileAstId<ast::Const>,\n }\n \n@@ -710,7 +636,7 @@ pub struct Static {\n     pub mutable: bool,\n     /// Whether the static is in an `extern` block.\n     pub is_extern: bool,\n-    pub type_ref: Idx<TypeRef>,\n+    pub type_ref: Interned<TypeRef>,\n     pub ast_id: FileAstId<ast::Static>,\n }\n \n@@ -729,8 +655,8 @@ pub struct Trait {\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Impl {\n     pub generic_params: GenericParamsId,\n-    pub target_trait: Option<Idx<TraitRef>>,\n-    pub self_ty: Idx<TypeRef>,\n+    pub target_trait: Option<Interned<TraitRef>>,\n+    pub self_ty: Interned<TypeRef>,\n     pub is_negative: bool,\n     pub items: Box<[AssocItem]>,\n     pub ast_id: FileAstId<ast::Impl>,\n@@ -743,7 +669,7 @@ pub struct TypeAlias {\n     /// Bounds on the type alias itself. Only valid in trait declarations, eg. `type Assoc: Copy;`.\n     pub bounds: Box<[TypeBound]>,\n     pub generic_params: GenericParamsId,\n-    pub type_ref: Option<Idx<TypeRef>>,\n+    pub type_ref: Option<Interned<TypeRef>>,\n     pub is_extern: bool,\n     pub ast_id: FileAstId<ast::TypeAlias>,\n }\n@@ -933,6 +859,6 @@ pub enum Fields {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Field {\n     pub name: Name,\n-    pub type_ref: Idx<TypeRef>,\n+    pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibilityId,\n }"}, {"sha": "23d3dea7b68e4fa20c0abd8d88db5dbab293dece", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a", "patch": "@@ -362,7 +362,7 @@ impl Ctx {\n                         }\n                     }\n                 };\n-                let ty = self.data().type_refs.intern(self_type);\n+                let ty = Interned::new(self_type);\n                 let idx = self.data().params.alloc(Param::Normal(ty));\n                 self.add_attrs(idx.into(), RawAttrs::new(&self_param, &self.hygiene));\n                 has_self_param = true;\n@@ -372,7 +372,7 @@ impl Ctx {\n                     Some(_) => self.data().params.alloc(Param::Varargs),\n                     None => {\n                         let type_ref = TypeRef::from_ast_opt(&self.body_ctx, param.ty());\n-                        let ty = self.data().type_refs.intern(type_ref);\n+                        let ty = Interned::new(type_ref);\n                         self.data().params.alloc(Param::Normal(ty))\n                     }\n                 };\n@@ -395,8 +395,6 @@ impl Ctx {\n             ret_type\n         };\n \n-        let ret_type = self.data().type_refs.intern(ret_type);\n-\n         let has_body = func.body().is_some();\n \n         let ast_id = self.source_ast_id_map.ast_id(func);\n@@ -428,7 +426,7 @@ impl Ctx {\n             qualifier,\n             is_in_extern_block: false,\n             params,\n-            ret_type,\n+            ret_type: Interned::new(ret_type),\n             ast_id,\n         };\n         res.generic_params = self.lower_generic_params(GenericsOwner::Function(&res), func);\n@@ -694,8 +692,7 @@ impl Ctx {\n                 generics.fill(&self.body_ctx, sm, node);\n                 // lower `impl Trait` in arguments\n                 for id in func.params.clone() {\n-                    if let Param::Normal(ty) = self.data().params[id] {\n-                        let ty = self.data().type_refs.lookup(ty);\n+                    if let Param::Normal(ty) = &self.data().params[id] {\n                         generics.fill_implicit_impl_trait_args(ty);\n                     }\n                 }\n@@ -749,20 +746,20 @@ impl Ctx {\n         self.data().vis.alloc(vis)\n     }\n \n-    fn lower_trait_ref(&mut self, trait_ref: &ast::Type) -> Option<Idx<TraitRef>> {\n+    fn lower_trait_ref(&mut self, trait_ref: &ast::Type) -> Option<Interned<TraitRef>> {\n         let trait_ref = TraitRef::from_ast(&self.body_ctx, trait_ref.clone())?;\n-        Some(self.data().trait_refs.intern(trait_ref))\n+        Some(Interned::new(trait_ref))\n     }\n \n-    fn lower_type_ref(&mut self, type_ref: &ast::Type) -> Idx<TypeRef> {\n+    fn lower_type_ref(&mut self, type_ref: &ast::Type) -> Interned<TypeRef> {\n         let tyref = TypeRef::from_ast(&self.body_ctx, type_ref.clone());\n-        self.data().type_refs.intern(tyref)\n+        Interned::new(tyref)\n     }\n \n-    fn lower_type_ref_opt(&mut self, type_ref: Option<ast::Type>) -> Idx<TypeRef> {\n+    fn lower_type_ref_opt(&mut self, type_ref: Option<ast::Type>) -> Interned<TypeRef> {\n         match type_ref.map(|ty| self.lower_type_ref(&ty)) {\n             Some(it) => it,\n-            None => self.data().type_refs.intern(TypeRef::Error),\n+            None => Interned::new(TypeRef::Error),\n         }\n     }\n "}, {"sha": "f408e510ad24694f5a3db32c7f3fe47a0b06e519", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a", "patch": "@@ -49,6 +49,7 @@ pub mod import_map;\n \n #[cfg(test)]\n mod test_db;\n+mod intern;\n \n use std::{\n     hash::{Hash, Hasher},"}, {"sha": "a08f694d9df51ad42bbd40f3a27d76993b80c181", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=b00266b79f0e2c2a5e332b30f7e6aba83b5e6e5a", "patch": "@@ -1157,7 +1157,7 @@ fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n         Binders::new(0, TyKind::ForeignType(crate::to_foreign_def_id(t)).intern(&Interner))\n     } else {\n         let type_ref = &db.type_alias_data(t).type_ref;\n-        let inner = ctx.lower_ty(type_ref.as_ref().unwrap_or(&TypeRef::Error));\n+        let inner = ctx.lower_ty(type_ref.as_deref().unwrap_or(&TypeRef::Error));\n         Binders::new(generics.len(), inner)\n     }\n }"}]}