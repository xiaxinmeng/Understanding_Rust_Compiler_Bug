{"sha": "7f38581372ea23348c2b8b4a9c50733ae8e0dd74", "node_id": "C_kwDOAAsO6NoAKDdmMzg1ODEzNzJlYTIzMzQ4YzJiOGI0YTljNTA3MzNhZThlMGRkNzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-31T13:55:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-31T13:55:29Z"}, "message": "Auto merge of #13120 - Austaras:master, r=jonas-schievink\n\nturn `unwrap_or` into `unwrap_or_else` and vice versa\n\ncloses #12983", "tree": {"sha": "8990207d150a38c4a112289bbec490678f438af3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8990207d150a38c4a112289bbec490678f438af3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f38581372ea23348c2b8b4a9c50733ae8e0dd74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f38581372ea23348c2b8b4a9c50733ae8e0dd74", "html_url": "https://github.com/rust-lang/rust/commit/7f38581372ea23348c2b8b4a9c50733ae8e0dd74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f38581372ea23348c2b8b4a9c50733ae8e0dd74/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79a578ae840abc729be96604f925aa4af25a2cbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/79a578ae840abc729be96604f925aa4af25a2cbb", "html_url": "https://github.com/rust-lang/rust/commit/79a578ae840abc729be96604f925aa4af25a2cbb"}, {"sha": "43e8d9644f9e55b677e226dbfa0255d9a8af1303", "url": "https://api.github.com/repos/rust-lang/rust/commits/43e8d9644f9e55b677e226dbfa0255d9a8af1303", "html_url": "https://github.com/rust-lang/rust/commit/43e8d9644f9e55b677e226dbfa0255d9a8af1303"}], "stats": {"total": 407, "additions": 407, "deletions": 0}, "files": [{"sha": "7d91be621013653aca193b1f23fc8a0469eaf376", "filename": "crates/ide-assists/src/handlers/replace_or_with_or_else.rs", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/7f38581372ea23348c2b8b4a9c50733ae8e0dd74/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f38581372ea23348c2b8b4a9c50733ae8e0dd74/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs?ref=7f38581372ea23348c2b8b4a9c50733ae8e0dd74", "patch": "@@ -0,0 +1,364 @@\n+use ide_db::{\n+    assists::{AssistId, AssistKind},\n+    famous_defs::FamousDefs,\n+};\n+use syntax::{\n+    ast::{self, make, Expr, HasArgList},\n+    AstNode,\n+};\n+\n+use crate::{AssistContext, Assists};\n+\n+// Assist: replace_or_with_or_else\n+//\n+// Replace `unwrap_or` with `unwrap_or_else` and `ok_or` with `ok_or_else`.\n+//\n+// ```\n+// # //- minicore:option\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwra$0p_or(2);\n+// }\n+// ```\n+// ->\n+// ```\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwrap_or_else(|| 2);\n+// }\n+// ```\n+pub(crate) fn replace_or_with_or_else(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n+\n+    let kind = is_option_or_result(call.receiver()?, ctx)?;\n+\n+    let (name, arg_list) = (call.name_ref()?, call.arg_list()?);\n+\n+    let mut map_or = false;\n+\n+    let replace = match &*name.text() {\n+        \"unwrap_or\" => \"unwrap_or_else\".to_string(),\n+        \"or\" => \"or_else\".to_string(),\n+        \"ok_or\" if kind == Kind::Option => \"ok_or_else\".to_string(),\n+        \"map_or\" => {\n+            map_or = true;\n+            \"map_or_else\".to_string()\n+        }\n+        _ => return None,\n+    };\n+\n+    let arg = match arg_list.args().collect::<Vec<_>>().as_slice() {\n+        [] => make::arg_list(Vec::new()),\n+        [first] => {\n+            let param = into_closure(first);\n+            make::arg_list(vec![param])\n+        }\n+        [first, second] if map_or => {\n+            let param = into_closure(first);\n+            make::arg_list(vec![param, second.clone()])\n+        }\n+        _ => return None,\n+    };\n+\n+    acc.add(\n+        AssistId(\"replace_or_with_or_else\", AssistKind::RefactorRewrite),\n+        format!(\"Replace {} with {}\", name.text(), replace),\n+        call.syntax().text_range(),\n+        |builder| {\n+            builder.replace(name.syntax().text_range(), replace);\n+            builder.replace_ast(arg_list, arg)\n+        },\n+    )\n+}\n+\n+fn into_closure(param: &Expr) -> Expr {\n+    (|| {\n+        if let ast::Expr::CallExpr(call) = param {\n+            if call.arg_list()?.args().count() == 0 {\n+                Some(call.expr()?.clone())\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    })()\n+    .unwrap_or_else(|| make::expr_closure(None, param.clone()))\n+}\n+\n+// Assist: replace_or_else_with_or\n+//\n+// Replace `unwrap_or_else` with `unwrap_or` and `ok_or_else` with `ok_or`.\n+//\n+// ```\n+// # //- minicore:option\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwra$0p_or_else(|| 2);\n+// }\n+// ```\n+// ->\n+// ```\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwrap_or(2);\n+// }\n+// ```\n+pub(crate) fn replace_or_else_with_or(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n+\n+    let kind = is_option_or_result(call.receiver()?, ctx)?;\n+\n+    let (name, arg_list) = (call.name_ref()?, call.arg_list()?);\n+\n+    let mut map_or = false;\n+    let replace = match &*name.text() {\n+        \"unwrap_or_else\" => \"unwrap_or\".to_string(),\n+        \"or_else\" => \"or\".to_string(),\n+        \"ok_or_else\" if kind == Kind::Option => \"ok_or\".to_string(),\n+        \"map_or_else\" => {\n+            map_or = true;\n+            \"map_or\".to_string()\n+        }\n+        _ => return None,\n+    };\n+\n+    let arg = match arg_list.args().collect::<Vec<_>>().as_slice() {\n+        [] => make::arg_list(Vec::new()),\n+        [first] => {\n+            let param = into_call(first);\n+            make::arg_list(vec![param])\n+        }\n+        [first, second] if map_or => {\n+            let param = into_call(first);\n+            make::arg_list(vec![param, second.clone()])\n+        }\n+        _ => return None,\n+    };\n+\n+    acc.add(\n+        AssistId(\"replace_or_else_with_or\", AssistKind::RefactorRewrite),\n+        format!(\"Replace {} with {}\", name.text(), replace),\n+        call.syntax().text_range(),\n+        |builder| {\n+            builder.replace(name.syntax().text_range(), replace);\n+            builder.replace_ast(arg_list, arg)\n+        },\n+    )\n+}\n+\n+fn into_call(param: &Expr) -> Expr {\n+    (|| {\n+        if let ast::Expr::ClosureExpr(closure) = param {\n+            if closure.param_list()?.params().count() == 0 {\n+                Some(closure.body()?.clone())\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    })()\n+    .unwrap_or_else(|| make::expr_call(param.clone(), make::arg_list(Vec::new())))\n+}\n+\n+#[derive(PartialEq, Eq)]\n+enum Kind {\n+    Option,\n+    Result,\n+}\n+\n+fn is_option_or_result(receiver: Expr, ctx: &AssistContext<'_>) -> Option<Kind> {\n+    let ty = ctx.sema.type_of_expr(&receiver)?.adjusted().as_adt()?.as_enum()?;\n+    let option_enum =\n+        FamousDefs(&ctx.sema, ctx.sema.scope(receiver.syntax())?.krate()).core_option_Option();\n+\n+    if let Some(option_enum) = option_enum {\n+        if ty == option_enum {\n+            return Some(Kind::Option);\n+        }\n+    }\n+\n+    let result_enum =\n+        FamousDefs(&ctx.sema, ctx.sema.scope(receiver.syntax())?.krate()).core_result_Result();\n+\n+    if let Some(result_enum) = result_enum {\n+        if ty == result_enum {\n+            return Some(Kind::Result);\n+        }\n+    }\n+\n+    None\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn replace_or_with_or_else_simple() {\n+        check_assist(\n+            replace_or_with_or_else,\n+            r#\"\n+//- minicore: option\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or(2);\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or_else(|| 2);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_with_or_else_call() {\n+        check_assist(\n+            replace_or_with_or_else,\n+            r#\"\n+//- minicore: option\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or(x());\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or_else(x);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_with_or_else_block() {\n+        check_assist(\n+            replace_or_with_or_else,\n+            r#\"\n+//- minicore: option\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or({\n+        let mut x = bar();\n+        for i in 0..10 {\n+            x += i;\n+        }\n+        x\n+    });\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or_else(|| {\n+        let mut x = bar();\n+        for i in 0..10 {\n+            x += i;\n+        }\n+        x\n+    });\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_simple() {\n+        check_assist(\n+            replace_or_else_with_or,\n+            r#\"\n+//- minicore: option\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or_else(|| 2);\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or(2);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_call() {\n+        check_assist(\n+            replace_or_else_with_or,\n+            r#\"\n+//- minicore: option\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or_else(x);\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or(x());\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_result() {\n+        check_assist(\n+            replace_or_else_with_or,\n+            r#\"\n+//- minicore: result\n+fn foo() {\n+    let foo = Ok(1);\n+    return foo.unwrap_$0or_else(x);\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Ok(1);\n+    return foo.unwrap_or(x());\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_map() {\n+        check_assist(\n+            replace_or_else_with_or,\n+            r#\"\n+//- minicore: result\n+fn foo() {\n+    let foo = Ok(\"foo\");\n+    return foo.map$0_or_else(|| 42, |v| v.len());\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Ok(\"foo\");\n+    return foo.map_or(42, |v| v.len());\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_not_applicable() {\n+        check_assist_not_applicable(\n+            replace_or_else_with_or,\n+            r#\"\n+fn foo() {\n+    let foo = Ok(1);\n+    return foo.unwrap_$0or_else(x);\n+}\n+\"#,\n+        )\n+    }\n+}"}, {"sha": "e52544db5f530ff969735c4a25b305c64c5491ae", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f38581372ea23348c2b8b4a9c50733ae8e0dd74/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f38581372ea23348c2b8b4a9c50733ae8e0dd74/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=7f38581372ea23348c2b8b4a9c50733ae8e0dd74", "patch": "@@ -180,6 +180,7 @@ mod handlers {\n     mod replace_try_expr_with_match;\n     mod replace_derive_with_manual_impl;\n     mod replace_if_let_with_match;\n+    mod replace_or_with_or_else;\n     mod introduce_named_generic;\n     mod replace_let_with_if_let;\n     mod replace_qualified_name_with_use;\n@@ -276,6 +277,8 @@ mod handlers {\n             replace_if_let_with_match::replace_if_let_with_match,\n             replace_if_let_with_match::replace_match_with_if_let,\n             replace_let_with_if_let::replace_let_with_if_let,\n+            replace_or_with_or_else::replace_or_else_with_or,\n+            replace_or_with_or_else::replace_or_with_or_else,\n             replace_turbofish_with_explicit_type::replace_turbofish_with_explicit_type,\n             replace_qualified_name_with_use::replace_qualified_name_with_use,\n             sort_items::sort_items,"}, {"sha": "a8c8622c1c1d89cdcab5caf4d489f96f454112f2", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7f38581372ea23348c2b8b4a9c50733ae8e0dd74/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f38581372ea23348c2b8b4a9c50733ae8e0dd74/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=7f38581372ea23348c2b8b4a9c50733ae8e0dd74", "patch": "@@ -2029,6 +2029,46 @@ fn handle(action: Action) {\n     )\n }\n \n+#[test]\n+fn doctest_replace_or_else_with_or() {\n+    check_doc_test(\n+        \"replace_or_else_with_or\",\n+        r#####\"\n+//- minicore:option\n+fn foo() {\n+    let a = Some(1);\n+    a.unwra$0p_or_else(|| 2);\n+}\n+\"#####,\n+        r#####\"\n+fn foo() {\n+    let a = Some(1);\n+    a.unwrap_or(2);\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_replace_or_with_or_else() {\n+    check_doc_test(\n+        \"replace_or_with_or_else\",\n+        r#####\"\n+//- minicore:option\n+fn foo() {\n+    let a = Some(1);\n+    a.unwra$0p_or(2);\n+}\n+\"#####,\n+        r#####\"\n+fn foo() {\n+    let a = Some(1);\n+    a.unwrap_or_else(|| 2);\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_replace_qualified_name_with_use() {\n     check_doc_test("}]}