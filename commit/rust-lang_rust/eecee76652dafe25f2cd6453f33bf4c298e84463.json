{"sha": "eecee76652dafe25f2cd6453f33bf4c298e84463", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlY2VlNzY2NTJkYWZlMjVmMmNkNjQ1M2YzM2JmNGMyOThlODQ0NjM=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-27T12:25:53Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-01T22:08:35Z"}, "message": "Generate prebinding blocks lazily", "tree": {"sha": "7b5c8c072bf046d051c3b20fa99b9c2ce50f88b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b5c8c072bf046d051c3b20fa99b9c2ce50f88b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eecee76652dafe25f2cd6453f33bf4c298e84463", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eecee76652dafe25f2cd6453f33bf4c298e84463", "html_url": "https://github.com/rust-lang/rust/commit/eecee76652dafe25f2cd6453f33bf4c298e84463", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eecee76652dafe25f2cd6453f33bf4c298e84463/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "425e494fceb2f88bec344ef07d0f2db4c74dd2d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/425e494fceb2f88bec344ef07d0f2db4c74dd2d1", "html_url": "https://github.com/rust-lang/rust/commit/425e494fceb2f88bec344ef07d0f2db4c74dd2d1"}], "stats": {"total": 217, "additions": 100, "deletions": 117}, "files": [{"sha": "1eb0c2cb3e65ebd4c89c138948ca5e04dadcec32", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 100, "deletions": 117, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/eecee76652dafe25f2cd6453f33bf4c298e84463/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eecee76652dafe25f2cd6453f33bf4c298e84463/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=eecee76652dafe25f2cd6453f33bf4c298e84463", "patch": "@@ -26,7 +26,6 @@ mod simplify;\n mod test;\n mod util;\n \n-use itertools::Itertools;\n use std::convert::TryFrom;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n@@ -66,12 +65,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// We generate MIR in the following steps:\n     ///\n     /// 1. Evaluate the scrutinee and add the fake read of it ([Builder::lower_scrutinee]).\n-    /// 2. Create the prebinding and otherwise blocks ([Builder::create_match_candidates]).\n-    /// 3. Create the decision tree ([Builder::lower_match_tree]).\n-    /// 4. Determine the fake borrows that are needed from the places that were\n+    /// 2. Create the decision tree ([Builder::lower_match_tree]).\n+    /// 3. Determine the fake borrows that are needed from the places that were\n     ///    matched against and create the required temporaries for them\n     ///    ([Builder::calculate_fake_borrows]).\n-    /// 5. Create everything else: the guards and the arms ([Builder::lower_match_arms]).\n+    /// 4. Create everything else: the guards and the arms ([Builder::lower_match_arms]).\n     ///\n     /// ## False edges\n     ///\n@@ -148,13 +146,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         scrutinee: &Place<'tcx>,\n         arms: &'pat [Arm<'tcx>],\n     ) -> Vec<(&'pat Arm<'tcx>, Vec<Candidate<'pat, 'tcx>>)> {\n-        let candidate_count = arms.iter().map(|c| c.top_pats_hack().len()).sum::<usize>();\n-        let pre_binding_blocks: Vec<_> =\n-            (0..candidate_count).map(|_| self.cfg.start_new_block()).collect();\n-\n-        let mut candidate_pre_binding_blocks = pre_binding_blocks.iter();\n-        let mut next_candidate_pre_binding_blocks = pre_binding_blocks.iter().skip(1);\n-\n         // Assemble a list of candidates: there is one candidate per pattern,\n         // which means there may be more than one candidate *per arm*.\n         arms.iter()\n@@ -163,21 +154,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let arm_candidates: Vec<_> = arm\n                     .top_pats_hack()\n                     .iter()\n-                    .zip(candidate_pre_binding_blocks.by_ref())\n-                    .map(|(pattern, pre_binding_block)| Candidate {\n+                    .map(|pattern| Candidate {\n                         span: pattern.span,\n+                        has_guard: arm_has_guard,\n                         match_pairs: smallvec![MatchPair::new(*scrutinee, pattern)],\n                         bindings: vec![],\n                         ascriptions: vec![],\n-                        otherwise_block: if arm_has_guard {\n-                            Some(self.cfg.start_new_block())\n-                        } else {\n-                            None\n-                        },\n-                        pre_binding_block: *pre_binding_block,\n-                        next_candidate_pre_binding_block: next_candidate_pre_binding_blocks\n-                            .next()\n-                            .copied(),\n+                        otherwise_block: None,\n+                        pre_binding_block: None,\n+                        next_candidate_pre_binding_block: None,\n                     })\n                     .collect();\n                 (arm, arm_candidates)\n@@ -203,16 +188,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // them.\n         let mut fake_borrows = if match_has_guard { Some(FxHashSet::default()) } else { None };\n \n+        let mut otherwise = None;\n+\n         // This will generate code to test scrutinee_place and\n         // branch to the appropriate arm block\n         self.match_candidates(\n             scrutinee_span,\n-            &mut Some(block),\n-            None,\n+            block,\n+            &mut otherwise,\n             &mut candidates,\n             &mut fake_borrows,\n         );\n \n+        if let Some(otherwise_block) = otherwise {\n+            let source_info = self.source_info(scrutinee_span);\n+            self.cfg.terminate(otherwise_block, source_info, TerminatorKind::Unreachable);\n+        }\n+\n+        let mut next_prebinding_block = None;\n+\n+        for candidate in candidates.iter_mut().rev() {\n+            candidate.next_candidate_pre_binding_block = next_prebinding_block;\n+            next_prebinding_block = candidate.pre_binding_block;\n+        }\n+\n         if let Some(ref borrows) = fake_borrows {\n             self.calculate_fake_borrows(borrows, scrutinee_span)\n         } else {\n@@ -427,13 +426,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // create a dummy candidate\n         let mut candidate = Candidate {\n             span: irrefutable_pat.span,\n+            has_guard: false,\n             match_pairs: smallvec![MatchPair::new(*initializer, &irrefutable_pat)],\n             bindings: vec![],\n             ascriptions: vec![],\n \n             // since we don't call `match_candidates`, next fields are unused\n             otherwise_block: None,\n-            pre_binding_block: block,\n+            pre_binding_block: None,\n             next_candidate_pre_binding_block: None,\n         };\n \n@@ -645,6 +645,8 @@ crate struct Candidate<'pat, 'tcx> {\n     // span of the original pattern that gave rise to this candidate\n     span: Span,\n \n+    has_guard: bool,\n+\n     // all of these must be satisfied...\n     match_pairs: SmallVec<[MatchPair<'pat, 'tcx>; 1]>,\n \n@@ -658,7 +660,7 @@ crate struct Candidate<'pat, 'tcx> {\n     otherwise_block: Option<BasicBlock>,\n \n     // ...and the blocks for add false edges between candidates\n-    pre_binding_block: BasicBlock,\n+    pre_binding_block: Option<BasicBlock>,\n     next_candidate_pre_binding_block: Option<BasicBlock>,\n }\n \n@@ -758,13 +760,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// which of these candidates, if any, is the correct one. The\n     /// candidates are sorted such that the first item in the list\n     /// has the highest priority. When a candidate is found to match\n-    /// the value, we will generate a branch to the appropriate\n+    /// the value, we will set and generate a branch to the appropriate\n     /// prebinding block.\n     ///\n     /// If we find that *NONE* of the candidates apply, we branch to the\n-    /// `otherwise_block`. In principle, this means that the input list was not\n-    /// exhaustive, though at present we sometimes are not smart enough to\n-    /// recognize all exhaustive inputs.\n+    /// `otherwise_block`, setting it to `Some` if required. In principle, this\n+    /// means that the input list was not exhaustive, though at present we\n+    /// sometimes are not smart enough to recognize all exhaustive inputs.\n     ///\n     /// It might be surprising that the input can be inexhaustive.\n     /// Indeed, initially, it is not, because all matches are\n@@ -778,8 +780,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn match_candidates<'pat>(\n         &mut self,\n         span: Span,\n-        start_block: &mut Option<BasicBlock>,\n-        otherwise_block: Option<BasicBlock>,\n+        start_block: BasicBlock,\n+        otherwise_block: &mut Option<BasicBlock>,\n         candidates: &mut [&mut Candidate<'pat, 'tcx>],\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) {\n@@ -802,7 +804,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         debug!(\"match_candidates: {:?} candidates fully matched\", fully_matched);\n         let (matched_candidates, unmatched_candidates) = candidates.split_at_mut(fully_matched);\n \n-        let block: BasicBlock = if !matched_candidates.is_empty() {\n+        let block = if !matched_candidates.is_empty() {\n             let otherwise_block =\n                 self.select_matched_candidates(matched_candidates, start_block, fake_borrows);\n \n@@ -816,17 +818,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 self.cfg.start_new_block()\n             }\n         } else {\n-            *start_block.get_or_insert_with(|| self.cfg.start_new_block())\n+            start_block\n         };\n \n         // If there are no candidates that still need testing, we're\n         // done. Since all matches are exhaustive, execution should\n         // never reach this point.\n         if unmatched_candidates.is_empty() {\n             let source_info = self.source_info(span);\n-            match otherwise_block {\n-                Some(otherwise) => self.cfg.goto(block, source_info, otherwise),\n-                None => self.cfg.terminate(block, source_info, TerminatorKind::Unreachable),\n+            if let Some(otherwise) = *otherwise_block {\n+                self.cfg.goto(block, source_info, otherwise);\n+            } else {\n+                *otherwise_block = Some(block);\n             }\n             return;\n         }\n@@ -856,7 +859,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn select_matched_candidates(\n         &mut self,\n         matched_candidates: &mut [&mut Candidate<'_, 'tcx>],\n-        start_block: &mut Option<BasicBlock>,\n+        start_block: BasicBlock,\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) -> Option<BasicBlock> {\n         debug_assert!(\n@@ -899,66 +902,34 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let fully_matched_with_guard = matched_candidates\n             .iter()\n-            .position(|c| c.otherwise_block.is_none())\n+            .position(|c| !c.has_guard)\n             .unwrap_or(matched_candidates.len() - 1);\n \n         let (reachable_candidates, unreachable_candidates) =\n             matched_candidates.split_at_mut(fully_matched_with_guard + 1);\n \n-        let first_candidate = &reachable_candidates[0];\n-        let first_prebinding_block = first_candidate.pre_binding_block;\n+        let mut next_prebinding = start_block;\n \n-        // `goto -> first_prebinding_block` from the `start_block` if there is one.\n-        if let Some(start_block) = *start_block {\n-            let source_info = self.source_info(first_candidate.span);\n-            self.cfg.goto(start_block, source_info, first_prebinding_block);\n-        } else {\n-            *start_block = Some(first_prebinding_block);\n-        }\n-\n-        for (first_candidate, second_candidate) in reachable_candidates.iter().tuple_windows() {\n-            let source_info = self.source_info(first_candidate.span);\n-            if let Some(otherwise_block) = first_candidate.otherwise_block {\n-                self.false_edges(\n-                    otherwise_block,\n-                    second_candidate.pre_binding_block,\n-                    first_candidate.next_candidate_pre_binding_block,\n-                    source_info,\n-                );\n-            } else {\n-                bug!(\"candidate other than the last has no guard\");\n+        for candidate in reachable_candidates.iter_mut() {\n+            assert!(candidate.otherwise_block.is_none());\n+            assert!(candidate.pre_binding_block.is_none());\n+            candidate.pre_binding_block = Some(next_prebinding);\n+            if candidate.has_guard {\n+                next_prebinding = self.cfg.start_new_block();\n+                candidate.otherwise_block = Some(next_prebinding);\n             }\n         }\n \n-        debug!(\"match_candidates: add false edges for unreachable {:?}\", unreachable_candidates);\n+        debug!(\n+            \"match_candidates: add pre_binding_blocks for unreachable {:?}\",\n+            unreachable_candidates,\n+        );\n         for candidate in unreachable_candidates {\n-            if let Some(otherwise) = candidate.otherwise_block {\n-                let source_info = self.source_info(candidate.span);\n-                let unreachable = self.cfg.start_new_block();\n-                self.false_edges(\n-                    otherwise,\n-                    unreachable,\n-                    candidate.next_candidate_pre_binding_block,\n-                    source_info,\n-                );\n-                self.cfg.terminate(unreachable, source_info, TerminatorKind::Unreachable);\n-            }\n+            assert!(candidate.pre_binding_block.is_none());\n+            candidate.pre_binding_block = Some(self.cfg.start_new_block());\n         }\n \n-        let last_candidate = reachable_candidates.last().unwrap();\n-        if let Some(otherwise) = last_candidate.otherwise_block {\n-            let source_info = self.source_info(last_candidate.span);\n-            let block = self.cfg.start_new_block();\n-            self.false_edges(\n-                otherwise,\n-                block,\n-                last_candidate.next_candidate_pre_binding_block,\n-                source_info,\n-            );\n-            Some(block)\n-        } else {\n-            None\n-        }\n+        reachable_candidates.last_mut().unwrap().otherwise_block\n     }\n \n     /// This is the most subtle part of the matching algorithm. At\n@@ -1078,7 +1049,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span: Span,\n         mut candidates: &'b mut [&'c mut Candidate<'pat, 'tcx>],\n         block: BasicBlock,\n-        mut otherwise_block: Option<BasicBlock>,\n+        otherwise_block: &mut Option<BasicBlock>,\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) {\n         // extract the match-pair from the highest priority candidate\n@@ -1150,49 +1121,49 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // improves the speed of llvm when optimizing long string literal\n         // matches\n         let make_target_blocks = move |this: &mut Self| -> Vec<BasicBlock> {\n+            // The block that we should branch to if none of the\n+            // `target_candidates` match. This is either the block where we\n+            // start matching the untested candidates if there are any,\n+            // otherwise it's the `otherwise_block`.\n+            let remainder_start = &mut None;\n+            let remainder_start =\n+                if candidates.is_empty() { &mut *otherwise_block } else { remainder_start };\n+\n             // For each outcome of test, process the candidates that still\n             // apply. Collect a list of blocks where control flow will\n             // branch if one of the `target_candidate` sets is not\n             // exhaustive.\n-            if !candidates.is_empty() {\n-                let remainder_start = &mut None;\n-                this.match_candidates(\n-                    span,\n-                    remainder_start,\n-                    otherwise_block,\n-                    candidates,\n-                    fake_borrows,\n-                );\n-                otherwise_block = Some(remainder_start.unwrap());\n-            };\n-\n-            target_candidates\n+            let target_blocks: Vec<_> = target_candidates\n                 .into_iter()\n                 .map(|mut candidates| {\n                     if candidates.len() != 0 {\n-                        let candidate_start = &mut None;\n+                        let candidate_start = this.cfg.start_new_block();\n                         this.match_candidates(\n                             span,\n                             candidate_start,\n-                            otherwise_block,\n+                            remainder_start,\n                             &mut *candidates,\n                             fake_borrows,\n                         );\n-                        candidate_start.unwrap()\n+                        candidate_start\n                     } else {\n-                        *otherwise_block.get_or_insert_with(|| {\n-                            let unreachable = this.cfg.start_new_block();\n-                            let source_info = this.source_info(span);\n-                            this.cfg.terminate(\n-                                unreachable,\n-                                source_info,\n-                                TerminatorKind::Unreachable,\n-                            );\n-                            unreachable\n-                        })\n+                        *remainder_start.get_or_insert_with(|| this.cfg.start_new_block())\n                     }\n                 })\n-                .collect()\n+                .collect();\n+\n+            if !candidates.is_empty() {\n+                let remainder_start = remainder_start.unwrap_or_else(|| this.cfg.start_new_block());\n+                this.match_candidates(\n+                    span,\n+                    remainder_start,\n+                    otherwise_block,\n+                    candidates,\n+                    fake_borrows,\n+                );\n+            };\n+\n+            target_blocks\n         };\n \n         self.perform_test(block, &match_place, &test, make_target_blocks);\n@@ -1297,7 +1268,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let candidate_source_info = self.source_info(candidate.span);\n \n-        let mut block = candidate.pre_binding_block;\n+        let mut block = candidate.pre_binding_block.unwrap();\n \n         // If we are adding our own statements, then we need a fresh block.\n         let create_fresh_block = candidate.next_candidate_pre_binding_block.is_some()\n@@ -1437,11 +1408,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 self.cfg.push_fake_read(post_guard_block, guard_end, cause, Place::from(temp));\n             }\n \n+            let otherwise_block = candidate.otherwise_block.unwrap_or_else(|| {\n+                let unreachable = self.cfg.start_new_block();\n+                self.cfg.terminate(unreachable, source_info, TerminatorKind::Unreachable);\n+                unreachable\n+            });\n+            let outside_scope = self.cfg.start_new_block();\n             self.exit_scope(\n                 source_info.span,\n                 region_scope,\n                 otherwise_post_guard_block,\n-                candidate.otherwise_block.unwrap(),\n+                outside_scope,\n+            );\n+            self.false_edges(\n+                outside_scope,\n+                otherwise_block,\n+                candidate.next_candidate_pre_binding_block,\n+                source_info,\n             );\n \n             // We want to ensure that the matched candidates are bound"}]}