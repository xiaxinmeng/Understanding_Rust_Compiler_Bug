{"sha": "9a1a3b9013221b90a9b02ecd23614b6e2fcf6a2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMWEzYjkwMTMyMjFiOTBhOWIwMmVjZDIzNjE0YjZlMmZjZjZhMmQ=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-10-04T01:02:04Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-10-04T06:58:44Z"}, "message": "Combine two `match` arms in `specialize()`.\n\nThis reduces the number of call sites for\n`constructor_intersects_pattern()` from two to one, which the next\ncommit will take advantage of.", "tree": {"sha": "ed4b8d6da183c52cbe6ba00d86de37e70e38c3a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed4b8d6da183c52cbe6ba00d86de37e70e38c3a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a1a3b9013221b90a9b02ecd23614b6e2fcf6a2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a1a3b9013221b90a9b02ecd23614b6e2fcf6a2d", "html_url": "https://github.com/rust-lang/rust/commit/9a1a3b9013221b90a9b02ecd23614b6e2fcf6a2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a1a3b9013221b90a9b02ecd23614b6e2fcf6a2d/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2023ac599c38a59f86552089e6791c5a73412d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2023ac599c38a59f86552089e6791c5a73412d3", "html_url": "https://github.com/rust-lang/rust/commit/f2023ac599c38a59f86552089e6791c5a73412d3"}], "stats": {"total": 138, "additions": 68, "deletions": 70}, "files": [{"sha": "cf8ef8c769985fb455373b7616ef2f71acbf1769", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 68, "deletions": 70, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/9a1a3b9013221b90a9b02ecd23614b6e2fcf6a2d/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a1a3b9013221b90a9b02ecd23614b6e2fcf6a2d/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=9a1a3b9013221b90a9b02ecd23614b6e2fcf6a2d", "patch": "@@ -434,6 +434,13 @@ enum Constructor<'tcx> {\n }\n \n impl<'tcx> Constructor<'tcx> {\n+    fn is_slice(&self) -> bool {\n+        match self {\n+            Slice { .. } => true,\n+            _ => false,\n+        }\n+    }\n+\n     fn variant_index_for_adt<'a>(\n         &self,\n         cx: &MatchCheckCtxt<'a, 'tcx>,\n@@ -1766,85 +1773,76 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n             Some(smallvec![subpattern])\n         }\n \n-        PatKind::Constant { value } => {\n-            match *constructor {\n-                Slice(..) => {\n-                    // we extract an `Option` for the pointer because slices of zero elements don't\n-                    // necessarily point to memory, they are usually just integers. The only time\n-                    // they should be pointing to memory is when they are subslices of nonzero\n-                    // slices\n-                    let (alloc, offset, n, ty) = match value.ty.kind {\n-                        ty::Array(t, n) => {\n-                            match value.val {\n-                                ConstValue::ByRef { offset, alloc, .. } => (\n-                                    alloc,\n-                                    offset,\n-                                    n.eval_usize(cx.tcx, cx.param_env),\n-                                    t,\n-                                ),\n-                                _ => span_bug!(\n-                                    pat.span,\n-                                    \"array pattern is {:?}\", value,\n-                                ),\n-                            }\n-                        },\n-                        ty::Slice(t) => {\n-                            match value.val {\n-                                ConstValue::Slice { data, start, end } => (\n-                                    data,\n-                                    Size::from_bytes(start as u64),\n-                                    (end - start) as u64,\n-                                    t,\n-                                ),\n-                                ConstValue::ByRef { .. } => {\n-                                    // FIXME(oli-obk): implement `deref` for `ConstValue`\n-                                    return None;\n-                                },\n-                                _ => span_bug!(\n-                                    pat.span,\n-                                    \"slice pattern constant must be scalar pair but is {:?}\",\n-                                    value,\n-                                ),\n-                            }\n+        PatKind::Constant { value } if constructor.is_slice() => {\n+            // We extract an `Option` for the pointer because slices of zero\n+            // elements don't necessarily point to memory, they are usually\n+            // just integers. The only time they should be pointing to memory\n+            // is when they are subslices of nonzero slices.\n+            let (alloc, offset, n, ty) = match value.ty.kind {\n+                ty::Array(t, n) => {\n+                    match value.val {\n+                        ConstValue::ByRef { offset, alloc, .. } => (\n+                            alloc,\n+                            offset,\n+                            n.eval_usize(cx.tcx, cx.param_env),\n+                            t,\n+                        ),\n+                        _ => span_bug!(\n+                            pat.span,\n+                            \"array pattern is {:?}\", value,\n+                        ),\n+                    }\n+                },\n+                ty::Slice(t) => {\n+                    match value.val {\n+                        ConstValue::Slice { data, start, end } => (\n+                            data,\n+                            Size::from_bytes(start as u64),\n+                            (end - start) as u64,\n+                            t,\n+                        ),\n+                        ConstValue::ByRef { .. } => {\n+                            // FIXME(oli-obk): implement `deref` for `ConstValue`\n+                            return None;\n                         },\n                         _ => span_bug!(\n                             pat.span,\n-                            \"unexpected const-val {:?} with ctor {:?}\",\n+                            \"slice pattern constant must be scalar pair but is {:?}\",\n                             value,\n-                            constructor,\n                         ),\n-                    };\n-                    if wild_patterns.len() as u64 == n {\n-                        // convert a constant slice/array pattern to a list of patterns.\n-                        let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n-                        let ptr = Pointer::new(AllocId(0), offset);\n-                        (0..n).map(|i| {\n-                            let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n-                            let scalar = alloc.read_scalar(\n-                                &cx.tcx, ptr, layout.size,\n-                            ).ok()?;\n-                            let scalar = scalar.not_undef().ok()?;\n-                            let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n-                            let pattern = Pat {\n-                                ty,\n-                                span: pat.span,\n-                                kind: box PatKind::Constant { value },\n-                            };\n-                            Some(&*cx.pattern_arena.alloc(pattern))\n-                        }).collect()\n-                    } else {\n-                        None\n                     }\n-                }\n-                _ => {\n-                    // If the constructor is a:\n-                    //      Single value: add a row if the constructor equals the pattern.\n-                    //      Range: add a row if the constructor contains the pattern.\n-                    constructor_intersects_pattern(cx.tcx, cx.param_env, constructor, pat)\n-                }\n+                },\n+                _ => span_bug!(\n+                    pat.span,\n+                    \"unexpected const-val {:?} with ctor {:?}\",\n+                    value,\n+                    constructor,\n+                ),\n+            };\n+            if wild_patterns.len() as u64 == n {\n+                // convert a constant slice/array pattern to a list of patterns.\n+                let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n+                let ptr = Pointer::new(AllocId(0), offset);\n+                (0..n).map(|i| {\n+                    let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n+                    let scalar = alloc.read_scalar(\n+                        &cx.tcx, ptr, layout.size,\n+                    ).ok()?;\n+                    let scalar = scalar.not_undef().ok()?;\n+                    let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n+                    let pattern = Pat {\n+                        ty,\n+                        span: pat.span,\n+                        kind: box PatKind::Constant { value },\n+                    };\n+                    Some(&*cx.pattern_arena.alloc(pattern))\n+                }).collect()\n+            } else {\n+                None\n             }\n         }\n \n+        PatKind::Constant { .. } |\n         PatKind::Range { .. } => {\n             // If the constructor is a:\n             //      Single value: add a row if the pattern contains the constructor."}]}