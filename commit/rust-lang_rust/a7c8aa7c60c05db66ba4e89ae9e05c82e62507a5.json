{"sha": "a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3YzhhYTdjNjBjMDVkYjY2YmE0ZTg5YWU5ZTA1YzgyZTYyNTA3YTU=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-05-21T08:53:29Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-05-21T08:53:29Z"}, "message": "add support of feature flag for runnables #4464\n\nSigned-off-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "e848f47bdf5d031c408df94222f595d2efcb2070", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e848f47bdf5d031c408df94222f595d2efcb2070"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "html_url": "https://github.com/rust-lang/rust/commit/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6143742bd4e625d391ac3ea860be7578ab9f53f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6143742bd4e625d391ac3ea860be7578ab9f53f", "html_url": "https://github.com/rust-lang/rust/commit/c6143742bd4e625d391ac3ea860be7578ab9f53f"}, {"sha": "a4e6963a2313971fe7bbec97d03bc67266ef68a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4e6963a2313971fe7bbec97d03bc67266ef68a9", "html_url": "https://github.com/rust-lang/rust/commit/a4e6963a2313971fe7bbec97d03bc67266ef68a9"}], "stats": {"total": 4946, "additions": 2975, "deletions": 1971}, "files": [{"sha": "c062366923dd6c2856ff1b5d38414c7bb61be7ca", "filename": "Cargo.lock", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -2,9 +2,9 @@\n # It is not intended for manual editing.\n [[package]]\n name = \"addr2line\"\n-version = \"0.12.0\"\n+version = \"0.12.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"456d75cbb82da1ad150c8a9d97285ffcd21c9931dcb11e995903e7d75141b38b\"\n+checksum = \"a49806b9dadc843c61e7c97e72490ad7f7220ae249012fbda9ad0609457c0543\"\n dependencies = [\n  \"gimli\",\n ]\n@@ -20,9 +20,9 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.29\"\n+version = \"1.0.31\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dc98824304f5513bb8f862f9e5985219003de4d730689e59d8f28818283a6fe4\"\n+checksum = \"85bb70cc08ec97ca5450e6eba421deeea5f172c0fc61f78b5357b2a8e8be195f\"\n \n [[package]]\n name = \"anymap\"\n@@ -55,9 +55,9 @@ checksum = \"f8aac770f1885fd7e387acedd76065302551364496e46b3dd00860b2f8359b9d\"\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.47\"\n+version = \"0.3.48\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a5393cb2f40a6fae0014c9af00018e95846f3b241b331a6b7733c326d3e58108\"\n+checksum = \"0df2f85c8a2abbe3b7d7e748052fdd9b76a0458fdeb16ad4223f5eca78c7c130\"\n dependencies = [\n  \"addr2line\",\n  \"cfg-if\",\n@@ -101,9 +101,9 @@ dependencies = [\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.52\"\n+version = \"1.0.53\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c3d87b23d6a92cd03af510a5ade527033f6aa6fa92161e2d5863a907d4c5e31d\"\n+checksum = \"404b1fe4f65288577753b17e3b36a04596ee784493ec249bf81c7f2d2acd751c\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -360,9 +360,9 @@ checksum = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n \n [[package]]\n name = \"fnv\"\n-version = \"1.0.6\"\n+version = \"1.0.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3\"\n+checksum = \"3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1\"\n \n [[package]]\n name = \"fs_extra\"\n@@ -463,9 +463,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.12\"\n+version = \"0.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"61565ff7aaace3525556587bd2dc31d4a07071957be715e63ce7b1eccf51a8f4\"\n+checksum = \"91780f809e750b0a89f5544be56617ff6b1227ee485bcb06ebe10cdf89bd3b71\"\n dependencies = [\n  \"libc\",\n ]\n@@ -809,9 +809,9 @@ checksum = \"9cbca9424c482ee628fa549d9c812e2cd22f1180b9222c9200fdfa6eb31aecb2\"\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.3.1\"\n+version = \"1.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b1c601810575c99596d4afc46f78a678c80105117c379eb3650cf99b8a21ce5b\"\n+checksum = \"0b631f7e854af39a1739f401cf34a8a013dfe09eac4fa4dba91e9768bd28168d\"\n \n [[package]]\n name = \"ordermap\"\n@@ -895,9 +895,9 @@ checksum = \"b4596b6d070b27117e987119b4dac604f3c58cfb0b191112e24771b2faeac1a6\"\n \n [[package]]\n name = \"ppv-lite86\"\n-version = \"0.2.6\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"74490b50b9fbe561ac330df47c08f3f33073d2d00c150f719147d7c54522fa1b\"\n+checksum = \"237a5ed80e274dbc66f86bd59c1e25edc039660be53194b5fe0a482e0f2612ea\"\n \n [[package]]\n name = \"proc-macro-hack\"\n@@ -907,18 +907,18 @@ checksum = \"0d659fe7c6d27f25e9d80a1a094c223f5246f6a6596453e09d7229bf42750b63\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.12\"\n+version = \"1.0.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8872cf6f48eee44265156c111456a700ab3483686b3f96df4cf5481c89157319\"\n+checksum = \"53f5ffe53a6b28e37c9c1ce74893477864d64f74778a93a4beb43c8fa167f639\"\n dependencies = [\n  \"unicode-xid\",\n ]\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.5\"\n+version = \"1.0.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"42934bc9c8ab0d3b273a16d8551c8f0fcff46be73276ca083ec2414c15c4ba5e\"\n+checksum = \"54a21852a652ad6f610c9510194f398ff6f8692e334fd1145fed931f7fbe44ea\"\n dependencies = [\n  \"proc-macro2\",\n ]\n@@ -1610,9 +1610,9 @@ checksum = \"ab16ced94dbd8a46c82fd81e3ed9a8727dac2977ea869d217bcc4ea1f122e81f\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.21\"\n+version = \"1.0.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4696caa4048ac7ce2bcd2e484b3cef88c1004e41b8e945a277e2c25dc0b72060\"\n+checksum = \"1425de3c33b0941002740a420b1a906a350b88d08b82b2c8a01035a3f9447bac\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\","}, {"sha": "c0a0226fb247bb4aa96a57d501556ccfe32ae219", "filename": "crates/ra_assists/src/assist_config.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fassist_config.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fassist_config.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_config.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -0,0 +1,27 @@\n+//! Settings for tweaking assists.\n+//!\n+//! The fun thing here is `SnippetCap` -- this type can only be created in this\n+//! module, and we use to statically check that we only produce snippet\n+//! assists if we are allowed to.\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct AssistConfig {\n+    pub snippet_cap: Option<SnippetCap>,\n+}\n+\n+impl AssistConfig {\n+    pub fn allow_snippets(&mut self, yes: bool) {\n+        self.snippet_cap = if yes { Some(SnippetCap { _private: () }) } else { None }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub struct SnippetCap {\n+    _private: (),\n+}\n+\n+impl Default for AssistConfig {\n+    fn default() -> Self {\n+        AssistConfig { snippet_cap: Some(SnippetCap { _private: () }) }\n+    }\n+}"}, {"sha": "f3af70a3ec9e7d21f46a099f287de236e1b6e6ea", "filename": "crates/ra_assists/src/assist_context.rs", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_context.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -15,7 +15,10 @@ use ra_syntax::{\n };\n use ra_text_edit::TextEditBuilder;\n \n-use crate::{Assist, AssistId, GroupLabel, ResolvedAssist};\n+use crate::{\n+    assist_config::{AssistConfig, SnippetCap},\n+    Assist, AssistId, GroupLabel, ResolvedAssist,\n+};\n \n /// `AssistContext` allows to apply an assist or check if it could be applied.\n ///\n@@ -48,17 +51,22 @@ use crate::{Assist, AssistId, GroupLabel, ResolvedAssist};\n /// moment, because the LSP API is pretty awkward in this place, and it's much\n /// easier to just compute the edit eagerly :-)\n pub(crate) struct AssistContext<'a> {\n+    pub(crate) config: &'a AssistConfig,\n     pub(crate) sema: Semantics<'a, RootDatabase>,\n     pub(crate) db: &'a RootDatabase,\n     pub(crate) frange: FileRange,\n     source_file: SourceFile,\n }\n \n impl<'a> AssistContext<'a> {\n-    pub fn new(sema: Semantics<'a, RootDatabase>, frange: FileRange) -> AssistContext<'a> {\n+    pub(crate) fn new(\n+        sema: Semantics<'a, RootDatabase>,\n+        config: &'a AssistConfig,\n+        frange: FileRange,\n+    ) -> AssistContext<'a> {\n         let source_file = sema.parse(frange.file_id);\n         let db = sema.db;\n-        AssistContext { sema, db, frange, source_file }\n+        AssistContext { config, sema, db, frange, source_file }\n     }\n \n     // NB, this ignores active selection.\n@@ -163,13 +171,13 @@ impl Assists {\n \n pub(crate) struct AssistBuilder {\n     edit: TextEditBuilder,\n-    cursor_position: Option<TextSize>,\n     file: FileId,\n+    is_snippet: bool,\n }\n \n impl AssistBuilder {\n     pub(crate) fn new(file: FileId) -> AssistBuilder {\n-        AssistBuilder { edit: TextEditBuilder::default(), cursor_position: None, file }\n+        AssistBuilder { edit: TextEditBuilder::default(), file, is_snippet: false }\n     }\n \n     /// Remove specified `range` of text.\n@@ -180,10 +188,30 @@ impl AssistBuilder {\n     pub(crate) fn insert(&mut self, offset: TextSize, text: impl Into<String>) {\n         self.edit.insert(offset, text.into())\n     }\n+    /// Append specified `snippet` at the given `offset`\n+    pub(crate) fn insert_snippet(\n+        &mut self,\n+        _cap: SnippetCap,\n+        offset: TextSize,\n+        snippet: impl Into<String>,\n+    ) {\n+        self.is_snippet = true;\n+        self.insert(offset, snippet);\n+    }\n     /// Replaces specified `range` of text with a given string.\n     pub(crate) fn replace(&mut self, range: TextRange, replace_with: impl Into<String>) {\n         self.edit.replace(range, replace_with.into())\n     }\n+    /// Replaces specified `range` of text with a given `snippet`.\n+    pub(crate) fn replace_snippet(\n+        &mut self,\n+        _cap: SnippetCap,\n+        range: TextRange,\n+        snippet: impl Into<String>,\n+    ) {\n+        self.is_snippet = true;\n+        self.replace(range, snippet);\n+    }\n     pub(crate) fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n         algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n     }\n@@ -207,10 +235,6 @@ impl AssistBuilder {\n         algo::diff(&node, &new).into_text_edit(&mut self.edit)\n     }\n \n-    /// Specify desired position of the cursor after the assist is applied.\n-    pub(crate) fn set_cursor(&mut self, offset: TextSize) {\n-        self.cursor_position = Some(offset)\n-    }\n     // FIXME: better API\n     pub(crate) fn set_file(&mut self, assist_file: FileId) {\n         self.file = assist_file;\n@@ -224,10 +248,10 @@ impl AssistBuilder {\n \n     fn finish(self, change_label: String) -> SourceChange {\n         let edit = self.edit.finish();\n-        if edit.is_empty() && self.cursor_position.is_none() {\n-            panic!(\"Only call `add_assist` if the assist can be applied\")\n+        let mut res = SingleFileChange { label: change_label, edit }.into_source_change(self.file);\n+        if self.is_snippet {\n+            res.is_snippet = true;\n         }\n-        SingleFileChange { label: change_label, edit, cursor_position: self.cursor_position }\n-            .into_source_change(self.file)\n+        res\n     }\n }"}, {"sha": "fa70c849684a625b70989b0684358911f664ba0c", "filename": "crates/ra_assists/src/handlers/add_custom_impl.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -25,7 +25,7 @@ use crate::{\n // struct S;\n //\n // impl Debug for S {\n-//\n+//     $0\n // }\n // ```\n pub(crate) fn add_custom_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -52,7 +52,7 @@ pub(crate) fn add_custom_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         format!(\"Add custom impl `{}` for `{}`\", trait_token.text().as_str(), annotated_name);\n \n     let target = attr.syntax().text_range();\n-    acc.add(AssistId(\"add_custom_impl\"), label, target, |edit| {\n+    acc.add(AssistId(\"add_custom_impl\"), label, target, |builder| {\n         let new_attr_input = input\n             .syntax()\n             .descendants_with_tokens()\n@@ -63,35 +63,36 @@ pub(crate) fn add_custom_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         let has_more_derives = !new_attr_input.is_empty();\n         let new_attr_input = new_attr_input.iter().sep_by(\", \").surround_with(\"(\", \")\").to_string();\n \n-        let mut buf = String::new();\n-        buf.push_str(\"\\n\\nimpl \");\n-        buf.push_str(trait_token.text().as_str());\n-        buf.push_str(\" for \");\n-        buf.push_str(annotated_name.as_str());\n-        buf.push_str(\" {\\n\");\n-\n-        let cursor_delta = if has_more_derives {\n-            let delta = input.syntax().text_range().len() - TextSize::of(&new_attr_input);\n-            edit.replace(input.syntax().text_range(), new_attr_input);\n-            delta\n+        if has_more_derives {\n+            builder.replace(input.syntax().text_range(), new_attr_input);\n         } else {\n             let attr_range = attr.syntax().text_range();\n-            edit.delete(attr_range);\n+            builder.delete(attr_range);\n \n             let line_break_range = attr\n                 .syntax()\n                 .next_sibling_or_token()\n                 .filter(|t| t.kind() == WHITESPACE)\n                 .map(|t| t.text_range())\n                 .unwrap_or_else(|| TextRange::new(TextSize::from(0), TextSize::from(0)));\n-            edit.delete(line_break_range);\n-\n-            attr_range.len() + line_break_range.len()\n-        };\n-\n-        edit.set_cursor(start_offset + TextSize::of(&buf) - cursor_delta);\n-        buf.push_str(\"\\n}\");\n-        edit.insert(start_offset, buf);\n+            builder.delete(line_break_range);\n+        }\n+\n+        match ctx.config.snippet_cap {\n+            Some(cap) => {\n+                builder.insert_snippet(\n+                    cap,\n+                    start_offset,\n+                    format!(\"\\n\\nimpl {} for {} {{\\n    $0\\n}}\", trait_token, annotated_name),\n+                );\n+            }\n+            None => {\n+                builder.insert(\n+                    start_offset,\n+                    format!(\"\\n\\nimpl {} for {} {{\\n\\n}}\", trait_token, annotated_name),\n+                );\n+            }\n+        }\n     })\n }\n \n@@ -117,7 +118,7 @@ struct Foo {\n }\n \n impl Debug for Foo {\n-<|>\n+    $0\n }\n             \",\n         )\n@@ -139,7 +140,7 @@ pub struct Foo {\n }\n \n impl Debug for Foo {\n-<|>\n+    $0\n }\n             \",\n         )\n@@ -158,7 +159,7 @@ struct Foo {}\n struct Foo {}\n \n impl Debug for Foo {\n-<|>\n+    $0\n }\n             \",\n         )"}, {"sha": "b123b84988cf4e730a9a68b1488b69ddc16463dd", "filename": "crates/ra_assists/src/handlers/add_derive.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -18,31 +18,37 @@ use crate::{AssistContext, AssistId, Assists};\n // ```\n // ->\n // ```\n-// #[derive()]\n+// #[derive($0)]\n // struct Point {\n //     x: u32,\n //     y: u32,\n // }\n // ```\n pub(crate) fn add_derive(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let cap = ctx.config.snippet_cap?;\n     let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n     let node_start = derive_insertion_offset(&nominal)?;\n     let target = nominal.syntax().text_range();\n-    acc.add(AssistId(\"add_derive\"), \"Add `#[derive]`\", target, |edit| {\n+    acc.add(AssistId(\"add_derive\"), \"Add `#[derive]`\", target, |builder| {\n         let derive_attr = nominal\n             .attrs()\n             .filter_map(|x| x.as_simple_call())\n             .filter(|(name, _arg)| name == \"derive\")\n             .map(|(_name, arg)| arg)\n             .next();\n-        let offset = match derive_attr {\n+        match derive_attr {\n             None => {\n-                edit.insert(node_start, \"#[derive()]\\n\");\n-                node_start + TextSize::of(\"#[derive(\")\n+                builder.insert_snippet(cap, node_start, \"#[derive($0)]\\n\");\n+            }\n+            Some(tt) => {\n+                // Just move the cursor.\n+                builder.insert_snippet(\n+                    cap,\n+                    tt.syntax().text_range().end() - TextSize::of(')'),\n+                    \"$0\",\n+                )\n             }\n-            Some(tt) => tt.syntax().text_range().end() - TextSize::of(')'),\n         };\n-        edit.set_cursor(offset)\n     })\n }\n \n@@ -66,12 +72,12 @@ mod tests {\n         check_assist(\n             add_derive,\n             \"struct Foo { a: i32, <|>}\",\n-            \"#[derive(<|>)]\\nstruct Foo { a: i32, }\",\n+            \"#[derive($0)]\\nstruct Foo { a: i32, }\",\n         );\n         check_assist(\n             add_derive,\n             \"struct Foo { <|> a: i32, }\",\n-            \"#[derive(<|>)]\\nstruct Foo {  a: i32, }\",\n+            \"#[derive($0)]\\nstruct Foo {  a: i32, }\",\n         );\n     }\n \n@@ -80,7 +86,7 @@ mod tests {\n         check_assist(\n             add_derive,\n             \"#[derive(Clone)]\\nstruct Foo { a: i32<|>, }\",\n-            \"#[derive(Clone<|>)]\\nstruct Foo { a: i32, }\",\n+            \"#[derive(Clone$0)]\\nstruct Foo { a: i32, }\",\n         );\n     }\n \n@@ -96,7 +102,7 @@ struct Foo { a: i32<|>, }\n             \"\n /// `Foo` is a pretty important struct.\n /// It does stuff.\n-#[derive(<|>)]\n+#[derive($0)]\n struct Foo { a: i32, }\n             \",\n         );"}, {"sha": "ab20c66493c1b5213ac36d4cfe616dd30e013d86", "filename": "crates/ra_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -25,9 +25,8 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     let stmt = ctx.find_node_at_offset::<LetStmt>()?;\n     let module = ctx.sema.scope(stmt.syntax()).module()?;\n     let expr = stmt.initializer()?;\n-    let pat = stmt.pat()?;\n     // Must be a binding\n-    let pat = match pat {\n+    let pat = match stmt.pat()? {\n         ast::Pat::BindPat(bind_pat) => bind_pat,\n         _ => return None,\n     };\n@@ -46,7 +45,7 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     // Assist not applicable if the type has already been specified\n     // and it has no placeholders\n     let ascribed_ty = stmt.ascribed_type();\n-    if let Some(ref ty) = ascribed_ty {\n+    if let Some(ty) = &ascribed_ty {\n         if ty.syntax().descendants().find_map(ast::PlaceholderType::cast).is_none() {\n             return None;\n         }\n@@ -87,19 +86,15 @@ mod tests {\n \n     #[test]\n     fn add_explicit_type_works_for_simple_expr() {\n-        check_assist(\n-            add_explicit_type,\n-            \"fn f() { let a<|> = 1; }\",\n-            \"fn f() { let a<|>: i32 = 1; }\",\n-        );\n+        check_assist(add_explicit_type, \"fn f() { let a<|> = 1; }\", \"fn f() { let a: i32 = 1; }\");\n     }\n \n     #[test]\n     fn add_explicit_type_works_for_underscore() {\n         check_assist(\n             add_explicit_type,\n             \"fn f() { let a<|>: _ = 1; }\",\n-            \"fn f() { let a<|>: i32 = 1; }\",\n+            \"fn f() { let a: i32 = 1; }\",\n         );\n     }\n \n@@ -123,7 +118,7 @@ mod tests {\n             }\n \n             fn f() {\n-                let a<|>: Option<i32> = Option::Some(1);\n+                let a: Option<i32> = Option::Some(1);\n             }\"#,\n         );\n     }\n@@ -133,16 +128,16 @@ mod tests {\n         check_assist(\n             add_explicit_type,\n             r\"macro_rules! v { () => {0u64} } fn f() { let a<|> = v!(); }\",\n-            r\"macro_rules! v { () => {0u64} } fn f() { let a<|>: u64 = v!(); }\",\n+            r\"macro_rules! v { () => {0u64} } fn f() { let a: u64 = v!(); }\",\n         );\n     }\n \n     #[test]\n     fn add_explicit_type_works_for_macro_call_recursive() {\n         check_assist(\n             add_explicit_type,\n-            \"macro_rules! u { () => {0u64} } macro_rules! v { () => {u!()} } fn f() { let a<|> = v!(); }\",\n-            \"macro_rules! u { () => {0u64} } macro_rules! v { () => {u!()} } fn f() { let a<|>: u64 = v!(); }\",\n+            r#\"macro_rules! u { () => {0u64} } macro_rules! v { () => {u!()} } fn f() { let a<|> = v!(); }\"#,\n+            r#\"macro_rules! u { () => {0u64} } macro_rules! v { () => {u!()} } fn f() { let a: u64 = v!(); }\"#,\n         );\n     }\n \n@@ -209,7 +204,7 @@ struct Test<K, T = u8> {\n }\n \n fn main() {\n-    let test<|>: Test<i32> = Test { t: 23, k: 33 };\n+    let test: Test<i32> = Test { t: 23, k: 33 };\n }\"#,\n         );\n     }"}, {"sha": "6a675e8126dd812f0c0cdb66eefceb1e20a469e0", "filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,7 +1,6 @@\n use ra_ide_db::RootDatabase;\n use ra_syntax::ast::{self, AstNode, NameOwner};\n-use stdx::format_to;\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{utils::FamousDefs, AssistContext, AssistId, Assists};\n \n@@ -35,12 +34,12 @@ pub(crate) fn add_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) ->\n     }\n     let field_type = field_list.fields().next()?.type_ref()?;\n     let path = match field_type {\n-        ast::TypeRef::PathType(p) => p,\n+        ast::TypeRef::PathType(it) => it,\n         _ => return None,\n     };\n \n     if existing_from_impl(&ctx.sema, &variant).is_some() {\n-        tested_by!(test_add_from_impl_already_exists);\n+        mark::hit!(test_add_from_impl_already_exists);\n         return None;\n     }\n \n@@ -51,9 +50,7 @@ pub(crate) fn add_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) ->\n         target,\n         |edit| {\n             let start_offset = variant.parent_enum().syntax().text_range().end();\n-            let mut buf = String::new();\n-            format_to!(\n-                buf,\n+            let buf = format!(\n                 r#\"\n \n impl From<{0}> for {1} {{\n@@ -93,7 +90,7 @@ fn existing_from_impl(\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n     use crate::tests::{check_assist, check_assist_not_applicable};\n \n@@ -104,7 +101,7 @@ mod tests {\n         check_assist(\n             add_from_impl_for_enum,\n             \"enum A { <|>One(u32) }\",\n-            r#\"enum A { <|>One(u32) }\n+            r#\"enum A { One(u32) }\n \n impl From<u32> for A {\n     fn from(v: u32) -> Self {\n@@ -119,7 +116,7 @@ impl From<u32> for A {\n         check_assist(\n             add_from_impl_for_enum,\n             r#\"enum A { <|>One(foo::bar::baz::Boo) }\"#,\n-            r#\"enum A { <|>One(foo::bar::baz::Boo) }\n+            r#\"enum A { One(foo::bar::baz::Boo) }\n \n impl From<foo::bar::baz::Boo> for A {\n     fn from(v: foo::bar::baz::Boo) -> Self {\n@@ -152,7 +149,7 @@ impl From<foo::bar::baz::Boo> for A {\n \n     #[test]\n     fn test_add_from_impl_already_exists() {\n-        covers!(test_add_from_impl_already_exists);\n+        mark::check!(test_add_from_impl_already_exists);\n         check_not_applicable(\n             r#\"\n enum A { <|>One(u32), }\n@@ -181,7 +178,7 @@ impl From<String> for A {\n pub trait From<T> {\n     fn from(T) -> Self;\n }\"#,\n-            r#\"enum A { <|>One(u32), Two(String), }\n+            r#\"enum A { One(u32), Two(String), }\n \n impl From<u32> for A {\n     fn from(v: u32) -> Self {"}, {"sha": "24f931a85e195a8bc0cfd386c9084960bfad2980", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "modified", "additions": 87, "deletions": 58, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -4,13 +4,17 @@ use ra_syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n-        ArgListOwner, AstNode, ModuleItemOwner,\n+        make, ArgListOwner, AstNode, ModuleItemOwner,\n     },\n     SyntaxKind, SyntaxNode, TextSize,\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{\n+    assist_config::SnippetCap,\n+    utils::{render_snippet, Cursor},\n+    AssistContext, AssistId, Assists,\n+};\n \n // Assist: add_function\n //\n@@ -33,7 +37,7 @@ use crate::{AssistContext, AssistId, Assists};\n // }\n //\n // fn bar(arg: &str, baz: Baz) {\n-//     todo!()\n+//     ${0:todo!()}\n // }\n //\n // ```\n@@ -58,21 +62,40 @@ pub(crate) fn add_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let function_builder = FunctionBuilder::from_call(&ctx, &call, &path, target_module)?;\n \n     let target = call.syntax().text_range();\n-    acc.add(AssistId(\"add_function\"), \"Add function\", target, |edit| {\n+    acc.add(AssistId(\"add_function\"), \"Add function\", target, |builder| {\n         let function_template = function_builder.render();\n-        edit.set_file(function_template.file);\n-        edit.set_cursor(function_template.cursor_offset);\n-        edit.insert(function_template.insert_offset, function_template.fn_def.to_string());\n+        builder.set_file(function_template.file);\n+        let new_fn = function_template.to_string(ctx.config.snippet_cap);\n+        match ctx.config.snippet_cap {\n+            Some(cap) => builder.insert_snippet(cap, function_template.insert_offset, new_fn),\n+            None => builder.insert(function_template.insert_offset, new_fn),\n+        }\n     })\n }\n \n struct FunctionTemplate {\n     insert_offset: TextSize,\n-    cursor_offset: TextSize,\n-    fn_def: ast::SourceFile,\n+    placeholder_expr: ast::MacroCall,\n+    leading_ws: String,\n+    fn_def: ast::FnDef,\n+    trailing_ws: String,\n     file: FileId,\n }\n \n+impl FunctionTemplate {\n+    fn to_string(&self, cap: Option<SnippetCap>) -> String {\n+        let f = match cap {\n+            Some(cap) => render_snippet(\n+                cap,\n+                self.fn_def.syntax(),\n+                Cursor::Replace(self.placeholder_expr.syntax()),\n+            ),\n+            None => self.fn_def.to_string(),\n+        };\n+        format!(\"{}{}{}\", self.leading_ws, f, self.trailing_ws)\n+    }\n+}\n+\n struct FunctionBuilder {\n     target: GeneratedFunctionTarget,\n     fn_name: ast::Name,\n@@ -110,35 +133,41 @@ impl FunctionBuilder {\n     }\n \n     fn render(self) -> FunctionTemplate {\n-        let placeholder_expr = ast::make::expr_todo();\n-        let fn_body = ast::make::block_expr(vec![], Some(placeholder_expr));\n-        let mut fn_def = ast::make::fn_def(self.fn_name, self.type_params, self.params, fn_body);\n-        if self.needs_pub {\n-            fn_def = ast::make::add_pub_crate_modifier(fn_def);\n-        }\n-\n-        let (fn_def, insert_offset) = match self.target {\n+        let placeholder_expr = make::expr_todo();\n+        let fn_body = make::block_expr(vec![], Some(placeholder_expr));\n+        let visibility = if self.needs_pub { Some(make::visibility_pub_crate()) } else { None };\n+        let mut fn_def =\n+            make::fn_def(visibility, self.fn_name, self.type_params, self.params, fn_body);\n+        let leading_ws;\n+        let trailing_ws;\n+\n+        let insert_offset = match self.target {\n             GeneratedFunctionTarget::BehindItem(it) => {\n-                let with_leading_blank_line = ast::make::add_leading_newlines(2, fn_def);\n-                let indented = with_leading_blank_line.indent(IndentLevel::from_node(&it));\n-                (indented, it.text_range().end())\n+                let indent = IndentLevel::from_node(&it);\n+                leading_ws = format!(\"\\n\\n{}\", indent);\n+                fn_def = fn_def.indent(indent);\n+                trailing_ws = String::new();\n+                it.text_range().end()\n             }\n             GeneratedFunctionTarget::InEmptyItemList(it) => {\n-                let indent_once = IndentLevel(1);\n                 let indent = IndentLevel::from_node(it.syntax());\n-                let fn_def = ast::make::add_leading_newlines(1, fn_def);\n-                let fn_def = fn_def.indent(indent_once);\n-                let fn_def = ast::make::add_trailing_newlines(1, fn_def);\n-                let fn_def = fn_def.indent(indent);\n-                (fn_def, it.syntax().text_range().start() + TextSize::of('{'))\n+                leading_ws = format!(\"\\n{}\", indent + 1);\n+                fn_def = fn_def.indent(indent + 1);\n+                trailing_ws = format!(\"\\n{}\", indent);\n+                it.syntax().text_range().start() + TextSize::of('{')\n             }\n         };\n \n         let placeholder_expr =\n             fn_def.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-        let cursor_offset_from_fn_start = placeholder_expr.syntax().text_range().start();\n-        let cursor_offset = insert_offset + cursor_offset_from_fn_start;\n-        FunctionTemplate { insert_offset, cursor_offset, fn_def, file: self.file }\n+        FunctionTemplate {\n+            insert_offset,\n+            placeholder_expr,\n+            leading_ws,\n+            fn_def,\n+            trailing_ws,\n+            file: self.file,\n+        }\n     }\n }\n \n@@ -158,7 +187,7 @@ impl GeneratedFunctionTarget {\n \n fn fn_name(call: &ast::Path) -> Option<ast::Name> {\n     let name = call.segment()?.syntax().to_string();\n-    Some(ast::make::name(&name))\n+    Some(make::name(&name))\n }\n \n /// Computes the type variables and arguments required for the generated function\n@@ -180,8 +209,8 @@ fn fn_args(\n         });\n     }\n     deduplicate_arg_names(&mut arg_names);\n-    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| ast::make::param(name, ty));\n-    Some((None, ast::make::param_list(params)))\n+    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| make::param(name, ty));\n+    Some((None, make::param_list(params)))\n }\n \n /// Makes duplicate argument names unique by appending incrementing numbers.\n@@ -316,7 +345,7 @@ fn foo() {\n }\n \n fn bar() {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -343,7 +372,7 @@ impl Foo {\n }\n \n fn bar() {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -367,7 +396,7 @@ fn foo1() {\n }\n \n fn bar() {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \n fn foo2() {}\n@@ -393,7 +422,7 @@ mod baz {\n     }\n \n     fn bar() {\n-        <|>todo!()\n+        ${0:todo!()}\n     }\n }\n \",\n@@ -419,7 +448,7 @@ fn foo() {\n }\n \n fn bar(baz: Baz) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         );\n@@ -452,7 +481,7 @@ impl Baz {\n }\n \n fn bar(baz: Baz) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -473,7 +502,7 @@ fn foo() {\n }\n \n fn bar(arg: &str) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -494,7 +523,7 @@ fn foo() {\n }\n \n fn bar(arg: char) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -515,7 +544,7 @@ fn foo() {\n }\n \n fn bar(arg: i32) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -536,7 +565,7 @@ fn foo() {\n }\n \n fn bar(arg: u8) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -561,7 +590,7 @@ fn foo() {\n }\n \n fn bar(x: u8) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -584,7 +613,7 @@ fn foo() {\n }\n \n fn bar(worble: ()) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -613,7 +642,7 @@ fn baz() {\n }\n \n fn bar(foo: impl Foo) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -640,7 +669,7 @@ fn foo() {\n }\n \n fn bar(baz: &Baz) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -669,7 +698,7 @@ fn foo() {\n }\n \n fn bar(baz: Baz::Bof) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -692,7 +721,7 @@ fn foo<T>(t: T) {\n }\n \n fn bar<T>(t: T) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -723,7 +752,7 @@ fn foo() {\n }\n \n fn bar(arg: fn() -> Baz) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -748,7 +777,7 @@ fn foo() {\n }\n \n fn bar(closure: impl Fn(i64) -> i64) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -769,7 +798,7 @@ fn foo() {\n }\n \n fn bar(baz: ()) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -794,7 +823,7 @@ fn foo() {\n }\n \n fn bar(baz_1: Baz, baz_2: Baz) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -819,7 +848,7 @@ fn foo() {\n }\n \n fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -839,7 +868,7 @@ fn foo() {\n             r\"\n mod bar {\n     pub(crate) fn my_fn() {\n-        <|>todo!()\n+        ${0:todo!()}\n     }\n }\n \n@@ -878,7 +907,7 @@ fn bar() {\n }\n \n fn baz(foo: foo::Foo) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -902,7 +931,7 @@ mod bar {\n     fn something_else() {}\n \n     pub(crate) fn my_fn() {\n-        <|>todo!()\n+        ${0:todo!()}\n     }\n }\n \n@@ -930,7 +959,7 @@ fn foo() {\n mod bar {\n     mod baz {\n         pub(crate) fn my_fn() {\n-            <|>todo!()\n+            ${0:todo!()}\n         }\n     }\n }\n@@ -959,7 +988,7 @@ fn main() {\n \n \n pub(crate) fn bar() {\n-    <|>todo!()\n+    ${0:todo!()}\n }\",\n         )\n     }"}, {"sha": "eceba7d0ae671c11d8de5cb7aa29892762a2e4f7", "filename": "crates/ra_assists/src/handlers/add_impl.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,7 +1,4 @@\n-use ra_syntax::{\n-    ast::{self, AstNode, NameOwner, TypeParamsOwner},\n-    TextSize,\n-};\n+use ra_syntax::ast::{self, AstNode, NameOwner, TypeParamsOwner};\n use stdx::{format_to, SepBy};\n \n use crate::{AssistContext, AssistId, Assists};\n@@ -12,17 +9,17 @@ use crate::{AssistContext, AssistId, Assists};\n //\n // ```\n // struct Ctx<T: Clone> {\n-//      data: T,<|>\n+//     data: T,<|>\n // }\n // ```\n // ->\n // ```\n // struct Ctx<T: Clone> {\n-//      data: T,\n+//     data: T,\n // }\n //\n // impl<T: Clone> Ctx<T> {\n-//\n+//     $0\n // }\n // ```\n pub(crate) fn add_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -50,30 +47,37 @@ pub(crate) fn add_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n             let generic_params = lifetime_params.chain(type_params).sep_by(\", \");\n             format_to!(buf, \"<{}>\", generic_params)\n         }\n-        buf.push_str(\" {\\n\");\n-        edit.set_cursor(start_offset + TextSize::of(&buf));\n-        buf.push_str(\"\\n}\");\n-        edit.insert(start_offset, buf);\n+        match ctx.config.snippet_cap {\n+            Some(cap) => {\n+                buf.push_str(\" {\\n    $0\\n}\");\n+                edit.insert_snippet(cap, start_offset, buf);\n+            }\n+            None => {\n+                buf.push_str(\" {\\n}\");\n+                edit.insert(start_offset, buf);\n+            }\n+        }\n     })\n }\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n     use crate::tests::{check_assist, check_assist_target};\n \n+    use super::*;\n+\n     #[test]\n     fn test_add_impl() {\n-        check_assist(add_impl, \"struct Foo {<|>}\\n\", \"struct Foo {}\\n\\nimpl Foo {\\n<|>\\n}\\n\");\n+        check_assist(add_impl, \"struct Foo {<|>}\\n\", \"struct Foo {}\\n\\nimpl Foo {\\n    $0\\n}\\n\");\n         check_assist(\n             add_impl,\n             \"struct Foo<T: Clone> {<|>}\",\n-            \"struct Foo<T: Clone> {}\\n\\nimpl<T: Clone> Foo<T> {\\n<|>\\n}\",\n+            \"struct Foo<T: Clone> {}\\n\\nimpl<T: Clone> Foo<T> {\\n    $0\\n}\",\n         );\n         check_assist(\n             add_impl,\n             \"struct Foo<'a, T: Foo<'a>> {<|>}\",\n-            \"struct Foo<'a, T: Foo<'a>> {}\\n\\nimpl<'a, T: Foo<'a>> Foo<'a, T> {\\n<|>\\n}\",\n+            \"struct Foo<'a, T: Foo<'a>> {}\\n\\nimpl<'a, T: Foo<'a>> Foo<'a, T> {\\n    $0\\n}\",\n         );\n     }\n "}, {"sha": "abacd4065fc9f4a20fc93b0341f33362135e1aa3", "filename": "crates/ra_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 57, "deletions": 41, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n use crate::{\n     assist_context::{AssistContext, Assists},\n     ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n-    utils::{get_missing_assoc_items, resolve_target_trait},\n+    utils::{get_missing_assoc_items, render_snippet, resolve_target_trait, Cursor},\n     AssistId,\n };\n \n@@ -46,7 +46,7 @@ enum AddMissingImplMembersMode {\n //\n // impl Trait<u32> for () {\n //     fn foo(&self) -> u32 {\n-//         todo!()\n+//         ${0:todo!()}\n //     }\n //\n // }\n@@ -89,7 +89,7 @@ pub(crate) fn add_missing_impl_members(acc: &mut Assists, ctx: &AssistContext) -\n // impl Trait for () {\n //     Type X = ();\n //     fn foo(&self) {}\n-//     fn bar(&self) {}\n+//     $0fn bar(&self) {}\n //\n // }\n // ```\n@@ -147,7 +147,7 @@ fn add_missing_impl_members_inner(\n     }\n \n     let target = impl_def.syntax().text_range();\n-    acc.add(AssistId(assist_id), label, target, |edit| {\n+    acc.add(AssistId(assist_id), label, target, |builder| {\n         let n_existing_items = impl_item_list.assoc_items().count();\n         let source_scope = ctx.sema.scope_for_def(trait_);\n         let target_scope = ctx.sema.scope(impl_item_list.syntax());\n@@ -162,13 +162,29 @@ fn add_missing_impl_members_inner(\n             })\n             .map(|it| edit::remove_attrs_and_docs(&it));\n         let new_impl_item_list = impl_item_list.append_items(items);\n-        let cursor_position = {\n-            let first_new_item = new_impl_item_list.assoc_items().nth(n_existing_items).unwrap();\n-            first_new_item.syntax().text_range().start()\n+        let first_new_item = new_impl_item_list.assoc_items().nth(n_existing_items).unwrap();\n+\n+        let original_range = impl_item_list.syntax().text_range();\n+        match ctx.config.snippet_cap {\n+            None => builder.replace(original_range, new_impl_item_list.to_string()),\n+            Some(cap) => {\n+                let mut cursor = Cursor::Before(first_new_item.syntax());\n+                let placeholder;\n+                if let ast::AssocItem::FnDef(func) = &first_new_item {\n+                    if let Some(m) = func.syntax().descendants().find_map(ast::MacroCall::cast) {\n+                        if m.syntax().text() == \"todo!()\" {\n+                            placeholder = m;\n+                            cursor = Cursor::Replace(placeholder.syntax());\n+                        }\n+                    }\n+                }\n+                builder.replace_snippet(\n+                    cap,\n+                    original_range,\n+                    render_snippet(cap, new_impl_item_list.syntax(), cursor),\n+                )\n+            }\n         };\n-\n-        edit.replace_ast(impl_item_list, new_impl_item_list);\n-        edit.set_cursor(cursor_position);\n     })\n }\n \n@@ -222,7 +238,7 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n-    <|>type Output;\n+    $0type Output;\n     const CONST: usize = 42;\n     fn foo(&self) {\n         todo!()\n@@ -263,8 +279,8 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n-    <|>fn foo(&self) {\n-        todo!()\n+    fn foo(&self) {\n+        ${0:todo!()}\n     }\n \n }\"#,\n@@ -283,8 +299,8 @@ impl Foo for S { <|> }\"#,\n trait Foo { fn foo(&self); }\n struct S;\n impl Foo for S {\n-    <|>fn foo(&self) {\n-        todo!()\n+    fn foo(&self) {\n+        ${0:todo!()}\n     }\n }\"#,\n         );\n@@ -302,8 +318,8 @@ impl Foo<u32> for S { <|> }\"#,\n trait Foo<T> { fn foo(&self, t: T) -> &T; }\n struct S;\n impl Foo<u32> for S {\n-    <|>fn foo(&self, t: u32) -> &u32 {\n-        todo!()\n+    fn foo(&self, t: u32) -> &u32 {\n+        ${0:todo!()}\n     }\n }\"#,\n         );\n@@ -321,8 +337,8 @@ impl<U> Foo<U> for S { <|> }\"#,\n trait Foo<T> { fn foo(&self, t: T) -> &T; }\n struct S;\n impl<U> Foo<U> for S {\n-    <|>fn foo(&self, t: U) -> &U {\n-        todo!()\n+    fn foo(&self, t: U) -> &U {\n+        ${0:todo!()}\n     }\n }\"#,\n         );\n@@ -340,8 +356,8 @@ impl Foo for S {}<|>\"#,\n trait Foo { fn foo(&self); }\n struct S;\n impl Foo for S {\n-    <|>fn foo(&self) {\n-        todo!()\n+    fn foo(&self) {\n+        ${0:todo!()}\n     }\n }\"#,\n         )\n@@ -365,8 +381,8 @@ mod foo {\n }\n struct S;\n impl foo::Foo for S {\n-    <|>fn foo(&self, bar: foo::Bar) {\n-        todo!()\n+    fn foo(&self, bar: foo::Bar) {\n+        ${0:todo!()}\n     }\n }\"#,\n         );\n@@ -390,8 +406,8 @@ mod foo {\n }\n struct S;\n impl foo::Foo for S {\n-    <|>fn foo(&self, bar: foo::Bar<u32>) {\n-        todo!()\n+    fn foo(&self, bar: foo::Bar<u32>) {\n+        ${0:todo!()}\n     }\n }\"#,\n         );\n@@ -415,8 +431,8 @@ mod foo {\n }\n struct S;\n impl foo::Foo<u32> for S {\n-    <|>fn foo(&self, bar: foo::Bar<u32>) {\n-        todo!()\n+    fn foo(&self, bar: foo::Bar<u32>) {\n+        ${0:todo!()}\n     }\n }\"#,\n         );\n@@ -443,8 +459,8 @@ mod foo {\n struct Param;\n struct S;\n impl foo::Foo<Param> for S {\n-    <|>fn foo(&self, bar: Param) {\n-        todo!()\n+    fn foo(&self, bar: Param) {\n+        ${0:todo!()}\n     }\n }\"#,\n         );\n@@ -470,8 +486,8 @@ mod foo {\n }\n struct S;\n impl foo::Foo for S {\n-    <|>fn foo(&self, bar: foo::Bar<u32>::Assoc) {\n-        todo!()\n+    fn foo(&self, bar: foo::Bar<u32>::Assoc) {\n+        ${0:todo!()}\n     }\n }\"#,\n         );\n@@ -497,8 +513,8 @@ mod foo {\n }\n struct S;\n impl foo::Foo for S {\n-    <|>fn foo(&self, bar: foo::Bar<foo::Baz>) {\n-        todo!()\n+    fn foo(&self, bar: foo::Bar<foo::Baz>) {\n+        ${0:todo!()}\n     }\n }\"#,\n         );\n@@ -522,8 +538,8 @@ mod foo {\n }\n struct S;\n impl foo::Foo for S {\n-    <|>fn foo(&self, bar: dyn Fn(u32) -> i32) {\n-        todo!()\n+    fn foo(&self, bar: dyn Fn(u32) -> i32) {\n+        ${0:todo!()}\n     }\n }\"#,\n         );\n@@ -580,7 +596,7 @@ trait Foo {\n }\n struct S;\n impl Foo for S {\n-    <|>type Output;\n+    $0type Output;\n     fn foo(&self) {\n         todo!()\n     }\n@@ -614,7 +630,7 @@ trait Foo {\n }\n struct S;\n impl Foo for S {\n-    <|>fn valid(some: u32) -> bool { false }\n+    $0fn valid(some: u32) -> bool { false }\n }\"#,\n         )\n     }\n@@ -637,8 +653,8 @@ trait Foo<T = Self> {\n \n struct S;\n impl Foo for S {\n-    <|>fn bar(&self, other: &Self) {\n-        todo!()\n+    fn bar(&self, other: &Self) {\n+        ${0:todo!()}\n     }\n }\"#,\n         )\n@@ -662,8 +678,8 @@ trait Foo<T1, T2 = Self> {\n \n struct S<T>;\n impl Foo<T> for S<T> {\n-    <|>fn bar(&self, this: &T, that: &Self) {\n-        todo!()\n+    fn bar(&self, this: &T, that: &Self) {\n+        ${0:todo!()}\n     }\n }\"#,\n         )"}, {"sha": "837aa83774ee7fe384f5cc97f021c559b8a86b74", "filename": "crates/ra_assists/src/handlers/add_new.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{\n     ast::{\n         self, AstNode, NameOwner, StructKind, TypeAscriptionOwner, TypeParamsOwner, VisibilityOwner,\n     },\n-    TextSize, T,\n+    T,\n };\n use stdx::{format_to, SepBy};\n \n@@ -25,7 +25,7 @@ use crate::{AssistContext, AssistId, Assists};\n // }\n //\n // impl<T: Clone> Ctx<T> {\n-//     fn new(data: T) -> Self { Self { data } }\n+//     fn $0new(data: T) -> Self { Self { data } }\n // }\n //\n // ```\n@@ -42,31 +42,26 @@ pub(crate) fn add_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let impl_def = find_struct_impl(&ctx, &strukt)?;\n \n     let target = strukt.syntax().text_range();\n-    acc.add(AssistId(\"add_new\"), \"Add default constructor\", target, |edit| {\n+    acc.add(AssistId(\"add_new\"), \"Add default constructor\", target, |builder| {\n         let mut buf = String::with_capacity(512);\n \n         if impl_def.is_some() {\n             buf.push('\\n');\n         }\n \n-        let vis = strukt.visibility().map(|v| format!(\"{} \", v));\n-        let vis = vis.as_deref().unwrap_or(\"\");\n+        let vis = strukt.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n \n         let params = field_list\n             .fields()\n             .filter_map(|f| {\n-                Some(format!(\n-                    \"{}: {}\",\n-                    f.name()?.syntax().text(),\n-                    f.ascribed_type()?.syntax().text()\n-                ))\n+                Some(format!(\"{}: {}\", f.name()?.syntax(), f.ascribed_type()?.syntax()))\n             })\n             .sep_by(\", \");\n         let fields = field_list.fields().filter_map(|f| f.name()).sep_by(\", \");\n \n         format_to!(buf, \"    {}fn new({}) -> Self {{ Self {{ {} }} }}\", vis, params, fields);\n \n-        let (start_offset, end_offset) = impl_def\n+        let start_offset = impl_def\n             .and_then(|impl_def| {\n                 buf.push('\\n');\n                 let start = impl_def\n@@ -76,17 +71,20 @@ pub(crate) fn add_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n                     .text_range()\n                     .end();\n \n-                Some((start, TextSize::of(\"\\n\")))\n+                Some(start)\n             })\n             .unwrap_or_else(|| {\n                 buf = generate_impl_text(&strukt, &buf);\n-                let start = strukt.syntax().text_range().end();\n-\n-                (start, TextSize::of(\"\\n}\\n\"))\n+                strukt.syntax().text_range().end()\n             });\n \n-        edit.set_cursor(start_offset + TextSize::of(&buf) - end_offset);\n-        edit.insert(start_offset, buf);\n+        match ctx.config.snippet_cap {\n+            None => builder.insert(start_offset, buf),\n+            Some(cap) => {\n+                buf = buf.replace(\"fn new\", \"fn $0new\");\n+                builder.insert_snippet(cap, start_offset, buf);\n+            }\n+        }\n     })\n }\n \n@@ -191,7 +189,7 @@ mod tests {\n \"struct Foo {}\n \n impl Foo {\n-    fn new() -> Self { Self {  } }<|>\n+    fn $0new() -> Self { Self {  } }\n }\n \",\n         );\n@@ -201,7 +199,7 @@ impl Foo {\n \"struct Foo<T: Clone> {}\n \n impl<T: Clone> Foo<T> {\n-    fn new() -> Self { Self {  } }<|>\n+    fn $0new() -> Self { Self {  } }\n }\n \",\n         );\n@@ -211,7 +209,7 @@ impl<T: Clone> Foo<T> {\n \"struct Foo<'a, T: Foo<'a>> {}\n \n impl<'a, T: Foo<'a>> Foo<'a, T> {\n-    fn new() -> Self { Self {  } }<|>\n+    fn $0new() -> Self { Self {  } }\n }\n \",\n         );\n@@ -221,7 +219,7 @@ impl<'a, T: Foo<'a>> Foo<'a, T> {\n \"struct Foo { baz: String }\n \n impl Foo {\n-    fn new(baz: String) -> Self { Self { baz } }<|>\n+    fn $0new(baz: String) -> Self { Self { baz } }\n }\n \",\n         );\n@@ -231,7 +229,7 @@ impl Foo {\n \"struct Foo { baz: String, qux: Vec<i32> }\n \n impl Foo {\n-    fn new(baz: String, qux: Vec<i32>) -> Self { Self { baz, qux } }<|>\n+    fn $0new(baz: String, qux: Vec<i32>) -> Self { Self { baz, qux } }\n }\n \",\n         );\n@@ -243,7 +241,7 @@ impl Foo {\n \"struct Foo { pub baz: String, pub qux: Vec<i32> }\n \n impl Foo {\n-    fn new(baz: String, qux: Vec<i32>) -> Self { Self { baz, qux } }<|>\n+    fn $0new(baz: String, qux: Vec<i32>) -> Self { Self { baz, qux } }\n }\n \",\n         );\n@@ -258,7 +256,7 @@ impl Foo {}\n \"struct Foo {}\n \n impl Foo {\n-    fn new() -> Self { Self {  } }<|>\n+    fn $0new() -> Self { Self {  } }\n }\n \",\n         );\n@@ -273,7 +271,7 @@ impl Foo {\n \"struct Foo {}\n \n impl Foo {\n-    fn new() -> Self { Self {  } }<|>\n+    fn $0new() -> Self { Self {  } }\n \n     fn qux(&self) {}\n }\n@@ -294,7 +292,7 @@ impl Foo {\n \"struct Foo {}\n \n impl Foo {\n-    fn new() -> Self { Self {  } }<|>\n+    fn $0new() -> Self { Self {  } }\n \n     fn qux(&self) {}\n     fn baz() -> i32 {\n@@ -311,7 +309,7 @@ impl Foo {\n \"pub struct Foo {}\n \n impl Foo {\n-    pub fn new() -> Self { Self {  } }<|>\n+    pub fn $0new() -> Self { Self {  } }\n }\n \",\n         );\n@@ -321,7 +319,7 @@ impl Foo {\n \"pub(crate) struct Foo {}\n \n impl Foo {\n-    pub(crate) fn new() -> Self { Self {  } }<|>\n+    pub(crate) fn $0new() -> Self { Self {  } }\n }\n \",\n         );\n@@ -414,7 +412,7 @@ pub struct Source<T> {\n }\n \n impl<T> Source<T> {\n-    pub fn new(file_id: HirFileId, ast: T) -> Self { Self { file_id, ast } }<|>\n+    pub fn $0new(file_id: HirFileId, ast: T) -> Self { Self { file_id, ast } }\n \n     pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n         Source { file_id: self.file_id, ast: f(self.ast) }"}, {"sha": "26acf81f284bedf453899dde13478df1e63c8c85", "filename": "crates/ra_assists/src/handlers/add_turbo_fish.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -0,0 +1,134 @@\n+use ra_ide_db::defs::{classify_name_ref, Definition, NameRefClass};\n+use ra_syntax::{ast, AstNode, SyntaxKind, T};\n+use test_utils::mark;\n+\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n+\n+// Assist: add_turbo_fish\n+//\n+// Adds `::<_>` to a call of a generic method or function.\n+//\n+// ```\n+// fn make<T>() -> T { todo!() }\n+// fn main() {\n+//     let x = make<|>();\n+// }\n+// ```\n+// ->\n+// ```\n+// fn make<T>() -> T { todo!() }\n+// fn main() {\n+//     let x = make::<${0:_}>();\n+// }\n+// ```\n+pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let ident = ctx.find_token_at_offset(SyntaxKind::IDENT)?;\n+    let next_token = ident.next_token()?;\n+    if next_token.kind() == T![::] {\n+        mark::hit!(add_turbo_fish_one_fish_is_enough);\n+        return None;\n+    }\n+    let name_ref = ast::NameRef::cast(ident.parent())?;\n+    let def = match classify_name_ref(&ctx.sema, &name_ref)? {\n+        NameRefClass::Definition(def) => def,\n+        NameRefClass::FieldShorthand { .. } => return None,\n+    };\n+    let fun = match def {\n+        Definition::ModuleDef(hir::ModuleDef::Function(it)) => it,\n+        _ => return None,\n+    };\n+    let generics = hir::GenericDef::Function(fun).params(ctx.sema.db);\n+    if generics.is_empty() {\n+        mark::hit!(add_turbo_fish_non_generic);\n+        return None;\n+    }\n+    acc.add(AssistId(\"add_turbo_fish\"), \"Add `::<>`\", ident.text_range(), |builder| {\n+        match ctx.config.snippet_cap {\n+            Some(cap) => builder.insert_snippet(cap, ident.text_range().end(), \"::<${0:_}>\"),\n+            None => builder.insert(ident.text_range().end(), \"::<_>\"),\n+        }\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+    use test_utils::mark;\n+\n+    #[test]\n+    fn add_turbo_fish_function() {\n+        check_assist(\n+            add_turbo_fish,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    make<|>();\n+}\n+\"#,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    make::<${0:_}>();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_turbo_fish_method() {\n+        check_assist(\n+            add_turbo_fish,\n+            r#\"\n+struct S;\n+impl S {\n+    fn make<T>(&self) -> T {}\n+}\n+fn main() {\n+    S.make<|>();\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    fn make<T>(&self) -> T {}\n+}\n+fn main() {\n+    S.make::<${0:_}>();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_turbo_fish_one_fish_is_enough() {\n+        mark::check!(add_turbo_fish_one_fish_is_enough);\n+        check_assist_not_applicable(\n+            add_turbo_fish,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    make<|>::<()>();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_turbo_fish_non_generic() {\n+        mark::check!(add_turbo_fish_non_generic);\n+        check_assist_not_applicable(\n+            add_turbo_fish,\n+            r#\"\n+fn make() -> () {}\n+fn main() {\n+    make<|>();\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "233e8fb8e65ce2c91e3795648e764fd9675d70d3", "filename": "crates/ra_assists/src/handlers/apply_demorgan.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -63,22 +63,22 @@ mod tests {\n \n     #[test]\n     fn demorgan_turns_and_into_or() {\n-        check_assist(apply_demorgan, \"fn f() { !x &&<|> !x }\", \"fn f() { !(x ||<|> x) }\")\n+        check_assist(apply_demorgan, \"fn f() { !x &&<|> !x }\", \"fn f() { !(x || x) }\")\n     }\n \n     #[test]\n     fn demorgan_turns_or_into_and() {\n-        check_assist(apply_demorgan, \"fn f() { !x ||<|> !x }\", \"fn f() { !(x &&<|> x) }\")\n+        check_assist(apply_demorgan, \"fn f() { !x ||<|> !x }\", \"fn f() { !(x && x) }\")\n     }\n \n     #[test]\n     fn demorgan_removes_inequality() {\n-        check_assist(apply_demorgan, \"fn f() { x != x ||<|> !x }\", \"fn f() { !(x == x &&<|> x) }\")\n+        check_assist(apply_demorgan, \"fn f() { x != x ||<|> !x }\", \"fn f() { !(x == x && x) }\")\n     }\n \n     #[test]\n     fn demorgan_general_case() {\n-        check_assist(apply_demorgan, \"fn f() { x ||<|> x }\", \"fn f() { !(!x &&<|> !x) }\")\n+        check_assist(apply_demorgan, \"fn f() { x ||<|> x }\", \"fn f() { !(!x && !x) }\")\n     }\n \n     #[test]"}, {"sha": "edf96d50ec144de79f2453b3a1278a089e4776d8", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -50,7 +50,12 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n             format!(\"Import `{}`\", &import),\n             range,\n             |builder| {\n-                insert_use_statement(&auto_import_assets.syntax_under_caret, &import, ctx, builder);\n+                insert_use_statement(\n+                    &auto_import_assets.syntax_under_caret,\n+                    &import,\n+                    ctx,\n+                    builder.text_edit_builder(),\n+                );\n             },\n         );\n     }\n@@ -293,7 +298,7 @@ mod tests {\n             }\n             \",\n             r\"\n-            <|>use PubMod::PubStruct;\n+            use PubMod::PubStruct;\n \n             PubStruct\n \n@@ -324,7 +329,7 @@ mod tests {\n             macro_rules! foo {\n                 ($i:ident) => { fn foo(a: $i) {} }\n             }\n-            foo!(Pub<|>Struct);\n+            foo!(PubStruct);\n \n             pub mod PubMod {\n                 pub struct PubStruct;\n@@ -355,7 +360,7 @@ mod tests {\n             use PubMod::{PubStruct2, PubStruct1};\n \n             struct Test {\n-                test: Pub<|>Struct2<u8>,\n+                test: PubStruct2<u8>,\n             }\n \n             pub mod PubMod {\n@@ -388,7 +393,7 @@ mod tests {\n             r\"\n             use PubMod3::PubStruct;\n \n-            PubSt<|>ruct\n+            PubStruct\n \n             pub mod PubMod1 {\n                 pub struct PubStruct;\n@@ -469,7 +474,7 @@ mod tests {\n             r\"\n             use PubMod::test_function;\n \n-            test_function<|>\n+            test_function\n \n             pub mod PubMod {\n                 pub fn test_function() {};\n@@ -496,7 +501,7 @@ mod tests {\n             r\"use crate_with_macro::foo;\n \n fn main() {\n-    foo<|>\n+    foo\n }\n \",\n         );\n@@ -582,7 +587,7 @@ fn main() {\n             }\n \n             fn main() {\n-                TestStruct::test_function<|>\n+                TestStruct::test_function\n             }\n             \",\n         );\n@@ -615,7 +620,7 @@ fn main() {\n             }\n \n             fn main() {\n-                TestStruct::TEST_CONST<|>\n+                TestStruct::TEST_CONST\n             }\n             \",\n         );\n@@ -654,7 +659,7 @@ fn main() {\n             }\n \n             fn main() {\n-                test_mod::TestStruct::test_function<|>\n+                test_mod::TestStruct::test_function\n             }\n             \",\n         );\n@@ -725,7 +730,7 @@ fn main() {\n             }\n \n             fn main() {\n-                test_mod::TestStruct::TEST_CONST<|>\n+                test_mod::TestStruct::TEST_CONST\n             }\n             \",\n         );\n@@ -798,7 +803,7 @@ fn main() {\n \n             fn main() {\n                 let test_struct = test_mod::TestStruct {};\n-                test_struct.test_meth<|>od()\n+                test_struct.test_method()\n             }\n             \",\n         );"}, {"sha": "c6baa0a57c6c6d6eb5dd84c4ca1f93e9437e3b73", "filename": "crates/ra_assists/src/handlers/change_return_type_to_result.rs", "status": "modified", "additions": 44, "deletions": 54, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,8 +1,6 @@\n use ra_syntax::{\n     ast::{self, BlockExpr, Expr, LoopBodyOwner},\n-    AstNode,\n-    SyntaxKind::{COMMENT, WHITESPACE},\n-    SyntaxNode, TextSize,\n+    AstNode, SyntaxNode,\n };\n \n use crate::{AssistContext, AssistId, Assists};\n@@ -16,39 +14,40 @@ use crate::{AssistContext, AssistId, Assists};\n // ```\n // ->\n // ```\n-// fn foo() -> Result<i32, > { Ok(42i32) }\n+// fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n // ```\n pub(crate) fn change_return_type_to_result(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let fn_def = ctx.find_node_at_offset::<ast::FnDef>();\n-    let fn_def = &mut fn_def?;\n-    let ret_type = &fn_def.ret_type()?.type_ref()?;\n-    if ret_type.syntax().text().to_string().starts_with(\"Result<\") {\n+    let ret_type = ctx.find_node_at_offset::<ast::RetType>()?;\n+    // FIXME: extend to lambdas as well\n+    let fn_def = ret_type.syntax().parent().and_then(ast::FnDef::cast)?;\n+\n+    let type_ref = &ret_type.type_ref()?;\n+    if type_ref.syntax().text().to_string().starts_with(\"Result<\") {\n         return None;\n     }\n \n     let block_expr = &fn_def.body()?;\n-    let cursor_in_ret_type =\n-        fn_def.ret_type()?.syntax().text_range().contains_range(ctx.frange.range);\n-    if !cursor_in_ret_type {\n-        return None;\n-    }\n \n     acc.add(\n         AssistId(\"change_return_type_to_result\"),\n         \"Change return type to Result\",\n-        ret_type.syntax().text_range(),\n-        |edit| {\n+        type_ref.syntax().text_range(),\n+        |builder| {\n             let mut tail_return_expr_collector = TailReturnCollector::new();\n             tail_return_expr_collector.collect_jump_exprs(block_expr, false);\n             tail_return_expr_collector.collect_tail_exprs(block_expr);\n \n             for ret_expr_arg in tail_return_expr_collector.exprs_to_wrap {\n-                edit.replace_node_and_indent(&ret_expr_arg, format!(\"Ok({})\", ret_expr_arg));\n+                builder.replace_node_and_indent(&ret_expr_arg, format!(\"Ok({})\", ret_expr_arg));\n             }\n-            edit.replace_node_and_indent(ret_type.syntax(), format!(\"Result<{}, >\", ret_type));\n \n-            if let Some(node_start) = result_insertion_offset(&ret_type) {\n-                edit.set_cursor(node_start + TextSize::of(&format!(\"Result<{}, \", ret_type)));\n+            match ctx.config.snippet_cap {\n+                Some(cap) => {\n+                    let snippet = format!(\"Result<{}, ${{0:_}}>\", type_ref);\n+                    builder.replace_snippet(cap, type_ref.syntax().text_range(), snippet)\n+                }\n+                None => builder\n+                    .replace(type_ref.syntax().text_range(), format!(\"Result<{}, _>\", type_ref)),\n             }\n         },\n     )\n@@ -250,17 +249,8 @@ fn get_tail_expr_from_block(expr: &Expr) -> Option<Vec<NodeType>> {\n     }\n }\n \n-fn result_insertion_offset(ret_type: &ast::TypeRef) -> Option<TextSize> {\n-    let non_ws_child = ret_type\n-        .syntax()\n-        .children_with_tokens()\n-        .find(|it| it.kind() != COMMENT && it.kind() != WHITESPACE)?;\n-    Some(non_ws_child.text_range().start())\n-}\n-\n #[cfg(test)]\n mod tests {\n-\n     use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n@@ -273,7 +263,7 @@ mod tests {\n                 let test = \"test\";\n                 return 42i32;\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 let test = \"test\";\n                 return Ok(42i32);\n             }\"#,\n@@ -288,7 +278,7 @@ mod tests {\n                 let test = \"test\";\n                 return 42i32;\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 let test = \"test\";\n                 return Ok(42i32);\n             }\"#,\n@@ -314,7 +304,7 @@ mod tests {\n                 let test = \"test\";\n                 return 42i32;\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 let test = \"test\";\n                 return Ok(42i32);\n             }\"#,\n@@ -329,7 +319,7 @@ mod tests {\n                 let test = \"test\";\n                 42i32\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 let test = \"test\";\n                 Ok(42i32)\n             }\"#,\n@@ -343,7 +333,7 @@ mod tests {\n             r#\"fn foo() -> i32<|> {\n                 42i32\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 Ok(42i32)\n             }\"#,\n         );\n@@ -359,7 +349,7 @@ mod tests {\n                     24i32\n                 }\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 if true {\n                     Ok(42i32)\n                 } else {\n@@ -384,7 +374,7 @@ mod tests {\n                     24i32\n                 }\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 if true {\n                     if false {\n                         Ok(1)\n@@ -413,7 +403,7 @@ mod tests {\n                     24i32.await\n                 }\n             }\"#,\n-            r#\"async fn foo() -> Result<i32, <|>> {\n+            r#\"async fn foo() -> Result<i32, ${0:_}> {\n                 if true {\n                     if false {\n                         Ok(1.await)\n@@ -434,7 +424,7 @@ mod tests {\n             r#\"fn foo() -> [i32;<|> 3] {\n                 [1, 2, 3]\n             }\"#,\n-            r#\"fn foo() -> Result<[i32; 3], <|>> {\n+            r#\"fn foo() -> Result<[i32; 3], ${0:_}> {\n                 Ok([1, 2, 3])\n             }\"#,\n         );\n@@ -455,7 +445,7 @@ mod tests {\n                     24 as i32\n                 }\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 if true {\n                     if false {\n                         Ok(1 as i32)\n@@ -480,7 +470,7 @@ mod tests {\n                     _ => 24i32,\n                 }\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 let my_var = 5;\n                 match my_var {\n                     5 => Ok(42i32),\n@@ -503,7 +493,7 @@ mod tests {\n \n                 my_var\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 let my_var = 5;\n                 loop {\n                     println!(\"test\");\n@@ -526,7 +516,7 @@ mod tests {\n \n                 my_var\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 let my_var = let x = loop {\n                     break 1;\n                 };\n@@ -549,7 +539,7 @@ mod tests {\n \n                 res\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 let my_var = 5;\n                 let res = match my_var {\n                     5 => 42i32,\n@@ -572,7 +562,7 @@ mod tests {\n \n                 res\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 let my_var = 5;\n                 let res = if my_var == 5 {\n                     42i32\n@@ -608,7 +598,7 @@ mod tests {\n                     },\n                 }\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 let my_var = 5;\n                 match my_var {\n                     5 => {\n@@ -641,7 +631,7 @@ mod tests {\n                 }\n                 53i32\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 let test = \"test\";\n                 if test == \"test\" {\n                     return Ok(24i32);\n@@ -672,7 +662,7 @@ mod tests {\n \n                 the_field\n             }\"#,\n-            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n                 let true_closure = || {\n                     return true;\n                 };\n@@ -711,7 +701,7 @@ mod tests {\n \n                 t.unwrap_or_else(|| the_field)\n             }\"#,\n-            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n                 let true_closure = || {\n                     return true;\n                 };\n@@ -749,7 +739,7 @@ mod tests {\n                     i += 1;\n                 }\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 let test = \"test\";\n                 if test == \"test\" {\n                     return Ok(24i32);\n@@ -781,7 +771,7 @@ mod tests {\n                     }\n                 }\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 let test = \"test\";\n                 if test == \"test\" {\n                     return Ok(24i32);\n@@ -819,7 +809,7 @@ mod tests {\n                     }\n                 }\n             }\"#,\n-            r#\"fn foo() -> Result<i32, <|>> {\n+            r#\"fn foo() -> Result<i32, ${0:_}> {\n                 let test = \"test\";\n                 let other = 5;\n                 if test == \"test\" {\n@@ -860,7 +850,7 @@ mod tests {\n \n                 the_field\n             }\"#,\n-            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n                 if the_field < 5 {\n                     let mut i = 0;\n                     loop {\n@@ -894,7 +884,7 @@ mod tests {\n \n                 the_field\n             }\"#,\n-            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n                 if the_field < 5 {\n                     let mut i = 0;\n \n@@ -923,7 +913,7 @@ mod tests {\n \n                 the_field\n             }\"#,\n-            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n                 if the_field < 5 {\n                     let mut i = 0;\n \n@@ -953,7 +943,7 @@ mod tests {\n \n                 the_field\n             }\"#,\n-            r#\"fn foo(the_field: u32) -> Result<u32, <|>> {\n+            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n                 if the_field < 5 {\n                     let mut i = 0;\n "}, {"sha": "c21d75be080ca760b3074fbeda173963378032d7", "filename": "crates/ra_assists/src/handlers/change_visibility.rs", "status": "modified", "additions": 18, "deletions": 530, "changes": 548, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -5,14 +5,11 @@ use ra_syntax::{\n         ATTR, COMMENT, CONST_DEF, ENUM_DEF, FN_DEF, MODULE, STRUCT_DEF, TRAIT_DEF, VISIBILITY,\n         WHITESPACE,\n     },\n-    SyntaxNode, TextRange, TextSize, T,\n+    SyntaxNode, TextSize, T,\n };\n-\n-use hir::{db::HirDatabase, HasSource, HasVisibility, PathResolution};\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{AssistContext, AssistId, Assists};\n-use ra_db::FileId;\n \n // Assist: change_visibility\n //\n@@ -30,8 +27,6 @@ pub(crate) fn change_visibility(acc: &mut Assists, ctx: &AssistContext) -> Optio\n         return change_vis(acc, vis);\n     }\n     add_vis(acc, ctx)\n-        .or_else(|| add_vis_to_referenced_module_def(acc, ctx))\n-        .or_else(|| add_vis_to_referenced_record_field(acc, ctx))\n }\n \n fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -55,7 +50,7 @@ fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     } else if let Some(field_name) = ctx.find_node_at_offset::<ast::Name>() {\n         let field = field_name.syntax().ancestors().find_map(ast::RecordFieldDef::cast)?;\n         if field.name()? != field_name {\n-            tested_by!(change_visibility_field_false_positive);\n+            mark::hit!(change_visibility_field_false_positive);\n             return None;\n         }\n         if field.visibility().is_some() {\n@@ -73,147 +68,9 @@ fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n \n     acc.add(AssistId(\"change_visibility\"), \"Change visibility to pub(crate)\", target, |edit| {\n         edit.insert(offset, \"pub(crate) \");\n-        edit.set_cursor(offset);\n-    })\n-}\n-\n-fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let path: ast::Path = ctx.find_node_at_offset()?;\n-    let path_res = ctx.sema.resolve_path(&path)?;\n-    let def = match path_res {\n-        PathResolution::Def(def) => def,\n-        _ => return None,\n-    };\n-\n-    let current_module = ctx.sema.scope(&path.syntax()).module()?;\n-    let target_module = def.module(ctx.db)?;\n-\n-    let vis = target_module.visibility_of(ctx.db, &def)?;\n-    if vis.is_visible_from(ctx.db, current_module.into()) {\n-        return None;\n-    };\n-\n-    let (offset, target, target_file, target_name) = target_data_for_def(ctx.db, def)?;\n-\n-    let missing_visibility =\n-        if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n-\n-    let assist_label = match target_name {\n-        None => format!(\"Change visibility to {}\", missing_visibility),\n-        Some(name) => format!(\"Change visibility of {} to {}\", name, missing_visibility),\n-    };\n-\n-    acc.add(AssistId(\"change_visibility\"), assist_label, target, |edit| {\n-        edit.set_file(target_file);\n-        edit.insert(offset, format!(\"{} \", missing_visibility));\n-        edit.set_cursor(offset);\n-    })\n-}\n-\n-fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let record_field: ast::RecordField = ctx.find_node_at_offset()?;\n-    let (record_field_def, _) = ctx.sema.resolve_record_field(&record_field)?;\n-\n-    let current_module = ctx.sema.scope(record_field.syntax()).module()?;\n-    let visibility = record_field_def.visibility(ctx.db);\n-    if visibility.is_visible_from(ctx.db, current_module.into()) {\n-        return None;\n-    }\n-\n-    let parent = record_field_def.parent_def(ctx.db);\n-    let parent_name = parent.name(ctx.db);\n-    let target_module = parent.module(ctx.db);\n-\n-    let in_file_source = record_field_def.source(ctx.db);\n-    let (offset, target) = match in_file_source.value {\n-        hir::FieldSource::Named(it) => {\n-            let s = it.syntax();\n-            (vis_offset(s), s.text_range())\n-        }\n-        hir::FieldSource::Pos(it) => {\n-            let s = it.syntax();\n-            (vis_offset(s), s.text_range())\n-        }\n-    };\n-\n-    let missing_visibility =\n-        if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n-    let target_file = in_file_source.file_id.original_file(ctx.db);\n-\n-    let target_name = record_field_def.name(ctx.db);\n-    let assist_label =\n-        format!(\"Change visibility of {}.{} to {}\", parent_name, target_name, missing_visibility);\n-\n-    acc.add(AssistId(\"change_visibility\"), assist_label, target, |edit| {\n-        edit.set_file(target_file);\n-        edit.insert(offset, format!(\"{} \", missing_visibility));\n-        edit.set_cursor(offset)\n     })\n }\n \n-fn target_data_for_def(\n-    db: &dyn HirDatabase,\n-    def: hir::ModuleDef,\n-) -> Option<(TextSize, TextRange, FileId, Option<hir::Name>)> {\n-    fn offset_target_and_file_id<S, Ast>(\n-        db: &dyn HirDatabase,\n-        x: S,\n-    ) -> (TextSize, TextRange, FileId)\n-    where\n-        S: HasSource<Ast = Ast>,\n-        Ast: AstNode,\n-    {\n-        let source = x.source(db);\n-        let in_file_syntax = source.syntax();\n-        let file_id = in_file_syntax.file_id;\n-        let syntax = in_file_syntax.value;\n-        (vis_offset(syntax), syntax.text_range(), file_id.original_file(db.upcast()))\n-    }\n-\n-    let target_name;\n-    let (offset, target, target_file) = match def {\n-        hir::ModuleDef::Function(f) => {\n-            target_name = Some(f.name(db));\n-            offset_target_and_file_id(db, f)\n-        }\n-        hir::ModuleDef::Adt(adt) => {\n-            target_name = Some(adt.name(db));\n-            match adt {\n-                hir::Adt::Struct(s) => offset_target_and_file_id(db, s),\n-                hir::Adt::Union(u) => offset_target_and_file_id(db, u),\n-                hir::Adt::Enum(e) => offset_target_and_file_id(db, e),\n-            }\n-        }\n-        hir::ModuleDef::Const(c) => {\n-            target_name = c.name(db);\n-            offset_target_and_file_id(db, c)\n-        }\n-        hir::ModuleDef::Static(s) => {\n-            target_name = s.name(db);\n-            offset_target_and_file_id(db, s)\n-        }\n-        hir::ModuleDef::Trait(t) => {\n-            target_name = Some(t.name(db));\n-            offset_target_and_file_id(db, t)\n-        }\n-        hir::ModuleDef::TypeAlias(t) => {\n-            target_name = Some(t.name(db));\n-            offset_target_and_file_id(db, t)\n-        }\n-        hir::ModuleDef::Module(m) => {\n-            target_name = m.name(db);\n-            let in_file_source = m.declaration_source(db)?;\n-            let file_id = in_file_source.file_id.original_file(db.upcast());\n-            let syntax = in_file_source.value.syntax();\n-            (vis_offset(syntax), syntax.text_range(), file_id)\n-        }\n-        // Enum variants can't be private, we can't modify builtin types\n-        hir::ModuleDef::EnumVariant(_) | hir::ModuleDef::BuiltinType(_) => return None,\n-    };\n-\n-    Some((offset, target, target_file, target_name))\n-}\n-\n fn vis_offset(node: &SyntaxNode) -> TextSize {\n     node.children_with_tokens()\n         .skip_while(|it| match it.kind() {\n@@ -234,7 +91,6 @@ fn change_vis(acc: &mut Assists, vis: ast::Visibility) -> Option<()> {\n             target,\n             |edit| {\n                 edit.replace(vis.syntax().text_range(), \"pub(crate)\");\n-                edit.set_cursor(vis.syntax().text_range().start())\n             },\n         );\n     }\n@@ -246,7 +102,6 @@ fn change_vis(acc: &mut Assists, vis: ast::Visibility) -> Option<()> {\n             target,\n             |edit| {\n                 edit.replace(vis.syntax().text_range(), \"pub\");\n-                edit.set_cursor(vis.syntax().text_range().start());\n             },\n         );\n     }\n@@ -255,40 +110,36 @@ fn change_vis(acc: &mut Assists, vis: ast::Visibility) -> Option<()> {\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     use super::*;\n \n     #[test]\n     fn change_visibility_adds_pub_crate_to_items() {\n-        check_assist(change_visibility, \"<|>fn foo() {}\", \"<|>pub(crate) fn foo() {}\");\n-        check_assist(change_visibility, \"f<|>n foo() {}\", \"<|>pub(crate) fn foo() {}\");\n-        check_assist(change_visibility, \"<|>struct Foo {}\", \"<|>pub(crate) struct Foo {}\");\n-        check_assist(change_visibility, \"<|>mod foo {}\", \"<|>pub(crate) mod foo {}\");\n-        check_assist(change_visibility, \"<|>trait Foo {}\", \"<|>pub(crate) trait Foo {}\");\n-        check_assist(change_visibility, \"m<|>od {}\", \"<|>pub(crate) mod {}\");\n-        check_assist(\n-            change_visibility,\n-            \"unsafe f<|>n foo() {}\",\n-            \"<|>pub(crate) unsafe fn foo() {}\",\n-        );\n+        check_assist(change_visibility, \"<|>fn foo() {}\", \"pub(crate) fn foo() {}\");\n+        check_assist(change_visibility, \"f<|>n foo() {}\", \"pub(crate) fn foo() {}\");\n+        check_assist(change_visibility, \"<|>struct Foo {}\", \"pub(crate) struct Foo {}\");\n+        check_assist(change_visibility, \"<|>mod foo {}\", \"pub(crate) mod foo {}\");\n+        check_assist(change_visibility, \"<|>trait Foo {}\", \"pub(crate) trait Foo {}\");\n+        check_assist(change_visibility, \"m<|>od {}\", \"pub(crate) mod {}\");\n+        check_assist(change_visibility, \"unsafe f<|>n foo() {}\", \"pub(crate) unsafe fn foo() {}\");\n     }\n \n     #[test]\n     fn change_visibility_works_with_struct_fields() {\n         check_assist(\n             change_visibility,\n             r\"struct S { <|>field: u32 }\",\n-            r\"struct S { <|>pub(crate) field: u32 }\",\n+            r\"struct S { pub(crate) field: u32 }\",\n         );\n-        check_assist(change_visibility, r\"struct S ( <|>u32 )\", r\"struct S ( <|>pub(crate) u32 )\");\n+        check_assist(change_visibility, r\"struct S ( <|>u32 )\", r\"struct S ( pub(crate) u32 )\");\n     }\n \n     #[test]\n     fn change_visibility_field_false_positive() {\n-        covers!(change_visibility_field_false_positive);\n+        mark::check!(change_visibility_field_false_positive);\n         check_assist_not_applicable(\n             change_visibility,\n             r\"struct S { field: [(); { let <|>x = ();}] }\",\n@@ -297,17 +148,17 @@ mod tests {\n \n     #[test]\n     fn change_visibility_pub_to_pub_crate() {\n-        check_assist(change_visibility, \"<|>pub fn foo() {}\", \"<|>pub(crate) fn foo() {}\")\n+        check_assist(change_visibility, \"<|>pub fn foo() {}\", \"pub(crate) fn foo() {}\")\n     }\n \n     #[test]\n     fn change_visibility_pub_crate_to_pub() {\n-        check_assist(change_visibility, \"<|>pub(crate) fn foo() {}\", \"<|>pub fn foo() {}\")\n+        check_assist(change_visibility, \"<|>pub(crate) fn foo() {}\", \"pub fn foo() {}\")\n     }\n \n     #[test]\n     fn change_visibility_const() {\n-        check_assist(change_visibility, \"<|>const FOO = 3u8;\", \"<|>pub(crate) const FOO = 3u8;\");\n+        check_assist(change_visibility, \"<|>const FOO = 3u8;\", \"pub(crate) const FOO = 3u8;\");\n     }\n \n     #[test]\n@@ -328,198 +179,11 @@ mod tests {\n             // comments\n \n             #[derive(Debug)]\n-            <|>pub(crate) struct Foo;\n+            pub(crate) struct Foo;\n             \",\n         )\n     }\n \n-    #[test]\n-    fn change_visibility_of_fn_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { fn foo() {} }\n-              fn main() { foo::foo<|>() } \",\n-            r\"mod foo { <|>pub(crate) fn foo() {} }\n-              fn main() { foo::foo() } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub fn foo() {} }\n-              fn main() { foo::foo<|>() } \",\n-        )\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_adt_in_submodule_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { struct Foo; }\n-              fn main() { foo::Foo<|> } \",\n-            r\"mod foo { <|>pub(crate) struct Foo; }\n-              fn main() { foo::Foo } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub struct Foo; }\n-              fn main() { foo::Foo<|> } \",\n-        );\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { enum Foo; }\n-              fn main() { foo::Foo<|> } \",\n-            r\"mod foo { <|>pub(crate) enum Foo; }\n-              fn main() { foo::Foo } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub enum Foo; }\n-              fn main() { foo::Foo<|> } \",\n-        );\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { union Foo; }\n-              fn main() { foo::Foo<|> } \",\n-            r\"mod foo { <|>pub(crate) union Foo; }\n-              fn main() { foo::Foo } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub union Foo; }\n-              fn main() { foo::Foo<|> } \",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_adt_in_other_file_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"\n-              //- /main.rs\n-              mod foo;\n-              fn main() { foo::Foo<|> }\n-\n-              //- /foo.rs\n-              struct Foo;\n-              \",\n-            r\"<|>pub(crate) struct Foo;\n-\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_struct_field_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { pub struct Foo { bar: (), } }\n-              fn main() { foo::Foo { <|>bar: () }; } \",\n-            r\"mod foo { pub struct Foo { <|>pub(crate) bar: (), } }\n-              fn main() { foo::Foo { bar: () }; } \",\n-        );\n-        check_assist(\n-            change_visibility,\n-            r\"//- /lib.rs\n-              mod foo;\n-              fn main() { foo::Foo { <|>bar: () }; }\n-              //- /foo.rs\n-              pub struct Foo { bar: () }\n-              \",\n-            r\"pub struct Foo { <|>pub(crate) bar: () }\n-\n-\",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub struct Foo { pub bar: (), } }\n-              fn main() { foo::Foo { <|>bar: () }; } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"//- /lib.rs\n-              mod foo;\n-              fn main() { foo::Foo { <|>bar: () }; }\n-              //- /foo.rs\n-              pub struct Foo { pub bar: () }\n-              \",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_enum_variant_field_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { pub enum Foo { Bar { bar: () } } }\n-              fn main() { foo::Foo::Bar { <|>bar: () }; } \",\n-            r\"mod foo { pub enum Foo { Bar { <|>pub(crate) bar: () } } }\n-              fn main() { foo::Foo::Bar { bar: () }; } \",\n-        );\n-        check_assist(\n-            change_visibility,\n-            r\"//- /lib.rs\n-              mod foo;\n-              fn main() { foo::Foo::Bar { <|>bar: () }; }\n-              //- /foo.rs\n-              pub enum Foo { Bar { bar: () } }\n-              \",\n-            r\"pub enum Foo { Bar { <|>pub(crate) bar: () } }\n-\n-\",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub struct Foo { pub bar: (), } }\n-              fn main() { foo::Foo { <|>bar: () }; } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"//- /lib.rs\n-              mod foo;\n-              fn main() { foo::Foo { <|>bar: () }; }\n-              //- /foo.rs\n-              pub struct Foo { pub bar: () }\n-              \",\n-        );\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    // FIXME reenable this test when `Semantics::resolve_record_field` works with union fields\n-    fn change_visibility_of_union_field_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { pub union Foo { bar: (), } }\n-              fn main() { foo::Foo { <|>bar: () }; } \",\n-            r\"mod foo { pub union Foo { <|>pub(crate) bar: (), } }\n-              fn main() { foo::Foo { bar: () }; } \",\n-        );\n-        check_assist(\n-            change_visibility,\n-            r\"//- /lib.rs\n-              mod foo;\n-              fn main() { foo::Foo { <|>bar: () }; }\n-              //- /foo.rs\n-              pub union Foo { bar: () }\n-              \",\n-            r\"pub union Foo { <|>pub(crate) bar: () }\n-\n-\",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub union Foo { pub bar: (), } }\n-              fn main() { foo::Foo { <|>bar: () }; } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"//- /lib.rs\n-              mod foo;\n-              fn main() { foo::Foo { <|>bar: () }; }\n-              //- /foo.rs\n-              pub union Foo { pub bar: () }\n-              \",\n-        );\n-    }\n-\n     #[test]\n     fn not_applicable_for_enum_variants() {\n         check_assist_not_applicable(\n@@ -529,182 +193,6 @@ mod tests {\n         );\n     }\n \n-    #[test]\n-    fn change_visibility_of_const_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { const FOO: () = (); }\n-              fn main() { foo::FOO<|> } \",\n-            r\"mod foo { <|>pub(crate) const FOO: () = (); }\n-              fn main() { foo::FOO } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub const FOO: () = (); }\n-              fn main() { foo::FOO<|> } \",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_static_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { static FOO: () = (); }\n-              fn main() { foo::FOO<|> } \",\n-            r\"mod foo { <|>pub(crate) static FOO: () = (); }\n-              fn main() { foo::FOO } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub static FOO: () = (); }\n-              fn main() { foo::FOO<|> } \",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_trait_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { trait Foo { fn foo(&self) {} } }\n-              fn main() { let x: &dyn foo::<|>Foo; } \",\n-            r\"mod foo { <|>pub(crate) trait Foo { fn foo(&self) {} } }\n-              fn main() { let x: &dyn foo::Foo; } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub trait Foo { fn foo(&self) {} } }\n-              fn main() { let x: &dyn foo::Foo<|>; } \",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_type_alias_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { type Foo = (); }\n-              fn main() { let x: foo::Foo<|>; } \",\n-            r\"mod foo { <|>pub(crate) type Foo = (); }\n-              fn main() { let x: foo::Foo; } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub type Foo = (); }\n-              fn main() { let x: foo::Foo<|>; } \",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_module_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { mod bar { fn bar() {} } }\n-              fn main() { foo::bar<|>::bar(); } \",\n-            r\"mod foo { <|>pub(crate) mod bar { fn bar() {} } }\n-              fn main() { foo::bar::bar(); } \",\n-        );\n-\n-        check_assist(\n-            change_visibility,\n-            r\"\n-            //- /main.rs\n-            mod foo;\n-            fn main() { foo::bar<|>::baz(); }\n-\n-            //- /foo.rs\n-            mod bar {\n-                pub fn baz() {}\n-            }\n-            \",\n-            r\"<|>pub(crate) mod bar {\n-    pub fn baz() {}\n-}\n-\n-\",\n-        );\n-\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub mod bar { pub fn bar() {} } }\n-              fn main() { foo::bar<|>::bar(); } \",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_inline_module_in_other_file_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"\n-            //- /main.rs\n-            mod foo;\n-            fn main() { foo::bar<|>::baz(); }\n-\n-            //- /foo.rs\n-            mod bar;\n-\n-            //- /foo/bar.rs\n-            pub fn baz() {}\n-            }\n-            \",\n-            r\"<|>pub(crate) mod bar;\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_module_declaration_in_other_file_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"//- /main.rs\n-              mod foo;\n-              fn main() { foo::bar<|>>::baz(); }\n-\n-              //- /foo.rs\n-              mod bar {\n-                  pub fn baz() {}\n-              }\",\n-            r\"<|>pub(crate) mod bar {\n-    pub fn baz() {}\n-}\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    // FIXME handle reexports properly\n-    fn change_visibility_of_reexport() {\n-        check_assist(\n-            change_visibility,\n-            r\"\n-            mod foo {\n-                use bar::Baz;\n-                mod bar { pub(super) struct Baz; }\n-            }\n-            foo::Baz<|>\n-            \",\n-            r\"\n-            mod foo {\n-                <|>pub(crate) use bar::Baz;\n-                mod bar { pub(super) struct Baz; }\n-            }\n-            foo::Baz\n-            \",\n-        )\n-    }\n-\n-    #[test]\n-    fn adds_pub_when_target_is_in_another_crate() {\n-        check_assist(\n-            change_visibility,\n-            r\"//- /main.rs crate:a deps:foo\n-              foo::Bar<|>\n-              //- /lib.rs crate:foo\n-              struct Bar;\",\n-            r\"<|>pub struct Bar;\n-\",\n-        )\n-    }\n-\n     #[test]\n     fn change_visibility_target() {\n         check_assist_target(change_visibility, \"<|>fn foo() {}\", \"fn\");"}, {"sha": "4cc75a7ce2dcda9733ff936908485520aa0b0808", "filename": "crates/ra_assists/src/handlers/early_return.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -97,7 +97,6 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n     }\n \n     then_block.syntax().last_child_or_token().filter(|t| t.kind() == R_CURLY)?;\n-    let cursor_position = ctx.offset();\n \n     let target = if_expr.syntax().text_range();\n     acc.add(AssistId(\"convert_to_guarded_return\"), \"Convert to guarded return\", target, |edit| {\n@@ -148,7 +147,6 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n             }\n         };\n         edit.replace_ast(parent_block, ast::BlockExpr::cast(new_block).unwrap());\n-        edit.set_cursor(cursor_position);\n \n         fn replace(\n             new_expr: &SyntaxNode,\n@@ -207,7 +205,7 @@ mod tests {\n             r#\"\n             fn main() {\n                 bar();\n-                if<|> !true {\n+                if !true {\n                     return;\n                 }\n                 foo();\n@@ -237,7 +235,7 @@ mod tests {\n             r#\"\n             fn main(n: Option<String>) {\n                 bar();\n-                le<|>t n = match n {\n+                let n = match n {\n                     Some(it) => it,\n                     _ => return,\n                 };\n@@ -263,7 +261,7 @@ mod tests {\n             \"#,\n             r#\"\n             fn main() {\n-                le<|>t x = match Err(92) {\n+                let x = match Err(92) {\n                     Ok(it) => it,\n                     _ => return,\n                 };\n@@ -291,7 +289,7 @@ mod tests {\n             r#\"\n             fn main(n: Option<String>) {\n                 bar();\n-                le<|>t n = match n {\n+                let n = match n {\n                     Ok(it) => it,\n                     _ => return,\n                 };\n@@ -321,7 +319,7 @@ mod tests {\n             r#\"\n             fn main() {\n                 while true {\n-                    if<|> !true {\n+                    if !true {\n                         continue;\n                     }\n                     foo();\n@@ -349,7 +347,7 @@ mod tests {\n             r#\"\n             fn main() {\n                 while true {\n-                    le<|>t n = match n {\n+                    let n = match n {\n                         Some(it) => it,\n                         _ => continue,\n                     };\n@@ -378,7 +376,7 @@ mod tests {\n             r#\"\n             fn main() {\n                 loop {\n-                    if<|> !true {\n+                    if !true {\n                         continue;\n                     }\n                     foo();\n@@ -406,7 +404,7 @@ mod tests {\n             r#\"\n             fn main() {\n                 loop {\n-                    le<|>t n = match n {\n+                    let n = match n {\n                         Some(it) => it,\n                         _ => continue,\n                     };"}, {"sha": "cc303285b35d77d2d235676bc9e287f1265e8115", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 115, "deletions": 117, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -4,8 +4,12 @@ use hir::{Adt, HasSource, ModuleDef, Semantics};\n use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n use ra_syntax::ast::{self, make, AstNode, MatchArm, NameOwner, Pat};\n+use test_utils::mark;\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{\n+    utils::{render_snippet, Cursor, FamousDefs},\n+    AssistContext, AssistId, Assists,\n+};\n \n // Assist: fill_match_arms\n //\n@@ -26,7 +30,7 @@ use crate::{AssistContext, AssistId, Assists};\n //\n // fn handle(action: Action) {\n //     match action {\n-//         Action::Move { distance } => {}\n+//         $0Action::Move { distance } => {}\n //         Action::Stop => {}\n //     }\n // }\n@@ -49,12 +53,18 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n     let missing_arms: Vec<MatchArm> = if let Some(enum_def) = resolve_enum_def(&ctx.sema, &expr) {\n         let variants = enum_def.variants(ctx.db);\n \n-        variants\n+        let mut variants = variants\n             .into_iter()\n             .filter_map(|variant| build_pat(ctx.db, module, variant))\n             .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n             .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n-            .collect()\n+            .collect::<Vec<_>>();\n+        if Some(enum_def) == FamousDefs(&ctx.sema, module.krate()).core_option_Option() {\n+            // Match `Some` variant first.\n+            mark::hit!(option_order);\n+            variants.reverse()\n+        }\n+        variants\n     } else if let Some(enum_defs) = resolve_tuple_of_enum_def(&ctx.sema, &expr) {\n         // Partial fill not currently supported for tuple of enums.\n         if !arms.is_empty() {\n@@ -93,10 +103,23 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n     }\n \n     let target = match_expr.syntax().text_range();\n-    acc.add(AssistId(\"fill_match_arms\"), \"Fill match arms\", target, |edit| {\n-        let new_arm_list = match_arm_list.remove_placeholder().append_arms(missing_arms);\n-        edit.set_cursor(expr.syntax().text_range().start());\n-        edit.replace_ast(match_arm_list, new_arm_list);\n+    acc.add(AssistId(\"fill_match_arms\"), \"Fill match arms\", target, |builder| {\n+        let new_arm_list = match_arm_list.remove_placeholder();\n+        let n_old_arms = new_arm_list.arms().count();\n+        let new_arm_list = new_arm_list.append_arms(missing_arms);\n+        let first_new_arm = new_arm_list.arms().nth(n_old_arms);\n+        let old_range = match_arm_list.syntax().text_range();\n+        match (first_new_arm, ctx.config.snippet_cap) {\n+            (Some(first_new_arm), Some(cap)) => {\n+                let snippet = render_snippet(\n+                    cap,\n+                    new_arm_list.syntax(),\n+                    Cursor::Before(first_new_arm.syntax()),\n+                );\n+                builder.replace_snippet(cap, old_range, snippet);\n+            }\n+            _ => builder.replace(old_range, new_arm_list.to_string()),\n+        }\n     })\n }\n \n@@ -167,7 +190,12 @@ fn build_pat(db: &RootDatabase, module: hir::Module, var: hir::EnumVariant) -> O\n \n #[cfg(test)]\n mod tests {\n-    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use test_utils::mark;\n+\n+    use crate::{\n+        tests::{check_assist, check_assist_not_applicable, check_assist_target},\n+        utils::FamousDefs,\n+    };\n \n     use super::fill_match_arms;\n \n@@ -214,27 +242,27 @@ mod tests {\n             r#\"\n             enum A {\n                 As,\n-                Bs{x:i32, y:Option<i32>},\n+                Bs { x: i32, y: Option<i32> },\n                 Cs(i32, Option<i32>),\n             }\n             fn main() {\n                 match A::As<|> {\n-                    A::Bs{x,y:Some(_)} => {}\n+                    A::Bs { x, y: Some(_) } => {}\n                     A::Cs(_, Some(_)) => {}\n                 }\n             }\n             \"#,\n             r#\"\n             enum A {\n                 As,\n-                Bs{x:i32, y:Option<i32>},\n+                Bs { x: i32, y: Option<i32> },\n                 Cs(i32, Option<i32>),\n             }\n             fn main() {\n-                match <|>A::As {\n-                    A::Bs{x,y:Some(_)} => {}\n+                match A::As {\n+                    A::Bs { x, y: Some(_) } => {}\n                     A::Cs(_, Some(_)) => {}\n-                    A::As => {}\n+                    $0A::As => {}\n                 }\n             }\n             \"#,\n@@ -264,9 +292,9 @@ mod tests {\n                 Cs(Option<i32>),\n             }\n             fn main() {\n-                match <|>A::As {\n+                match A::As {\n                     A::Cs(_) | A::Bs => {}\n-                    A::As => {}\n+                    $0A::As => {}\n                 }\n             }\n             \"#,\n@@ -310,11 +338,11 @@ mod tests {\n                 Ys,\n             }\n             fn main() {\n-                match <|>A::As {\n+                match A::As {\n                     A::Bs if 0 < 1 => {}\n                     A::Ds(_value) => { let x = 1; }\n                     A::Es(B::Xs) => (),\n-                    A::As => {}\n+                    $0A::As => {}\n                     A::Cs => {}\n                 }\n             }\n@@ -332,7 +360,7 @@ mod tests {\n                 Bs,\n                 Cs(String),\n                 Ds(String, String),\n-                Es{ x: usize, y: usize }\n+                Es { x: usize, y: usize }\n             }\n \n             fn main() {\n@@ -346,13 +374,13 @@ mod tests {\n                 Bs,\n                 Cs(String),\n                 Ds(String, String),\n-                Es{ x: usize, y: usize }\n+                Es { x: usize, y: usize }\n             }\n \n             fn main() {\n                 let a = A::As;\n-                match <|>a {\n-                    A::As => {}\n+                match a {\n+                    $0A::As => {}\n                     A::Bs => {}\n                     A::Cs(_) => {}\n                     A::Ds(_, _) => {}\n@@ -368,14 +396,8 @@ mod tests {\n         check_assist(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n-            enum B {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n+            enum B { One, Two }\n \n             fn main() {\n                 let a = A::One;\n@@ -384,20 +406,14 @@ mod tests {\n             }\n             \"#,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n-            enum B {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n+            enum B { One, Two }\n \n             fn main() {\n                 let a = A::One;\n                 let b = B::One;\n-                match <|>(a, b) {\n-                    (A::One, B::One) => {}\n+                match (a, b) {\n+                    $0(A::One, B::One) => {}\n                     (A::One, B::Two) => {}\n                     (A::Two, B::One) => {}\n                     (A::Two, B::Two) => {}\n@@ -412,14 +428,8 @@ mod tests {\n         check_assist(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n-            enum B {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n+            enum B { One, Two }\n \n             fn main() {\n                 let a = A::One;\n@@ -428,20 +438,14 @@ mod tests {\n             }\n             \"#,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n-            enum B {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n+            enum B { One, Two }\n \n             fn main() {\n                 let a = A::One;\n                 let b = B::One;\n-                match <|>(&a, &b) {\n-                    (A::One, B::One) => {}\n+                match (&a, &b) {\n+                    $0(A::One, B::One) => {}\n                     (A::One, B::Two) => {}\n                     (A::Two, B::One) => {}\n                     (A::Two, B::Two) => {}\n@@ -456,14 +460,8 @@ mod tests {\n         check_assist_not_applicable(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n-            enum B {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n+            enum B { One, Two }\n \n             fn main() {\n                 let a = A::One;\n@@ -481,14 +479,8 @@ mod tests {\n         check_assist_not_applicable(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n-            enum B {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n+            enum B { One, Two }\n \n             fn main() {\n                 let a = A::One;\n@@ -512,10 +504,7 @@ mod tests {\n         check_assist_not_applicable(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n \n             fn main() {\n                 let a = A::One;\n@@ -531,23 +520,19 @@ mod tests {\n         check_assist(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                As,\n-            }\n+            enum A { As }\n \n             fn foo(a: &A) {\n                 match a<|> {\n                 }\n             }\n             \"#,\n             r#\"\n-            enum A {\n-                As,\n-            }\n+            enum A { As }\n \n             fn foo(a: &A) {\n-                match <|>a {\n-                    A::As => {}\n+                match a {\n+                    $0A::As => {}\n                 }\n             }\n             \"#,\n@@ -557,7 +542,7 @@ mod tests {\n             fill_match_arms,\n             r#\"\n             enum A {\n-                Es{ x: usize, y: usize }\n+                Es { x: usize, y: usize }\n             }\n \n             fn foo(a: &mut A) {\n@@ -567,12 +552,12 @@ mod tests {\n             \"#,\n             r#\"\n             enum A {\n-                Es{ x: usize, y: usize }\n+                Es { x: usize, y: usize }\n             }\n \n             fn foo(a: &mut A) {\n-                match <|>a {\n-                    A::Es { x, y } => {}\n+                match a {\n+                    $0A::Es { x, y } => {}\n                 }\n             }\n             \"#,\n@@ -611,8 +596,8 @@ mod tests {\n             enum E { X, Y }\n \n             fn main() {\n-                match <|>E::X {\n-                    E::X => {}\n+                match E::X {\n+                    $0E::X => {}\n                     E::Y => {}\n                 }\n             }\n@@ -639,8 +624,8 @@ mod tests {\n             use foo::E::X;\n \n             fn main() {\n-                match <|>X {\n-                    X => {}\n+                match X {\n+                    $0X => {}\n                     foo::E::Y => {}\n                 }\n             }\n@@ -653,10 +638,7 @@ mod tests {\n         check_assist(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n             fn foo(a: A) {\n                 match a {\n                     // foo bar baz<|>\n@@ -666,16 +648,13 @@ mod tests {\n             }\n             \"#,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n             fn foo(a: A) {\n-                match <|>a {\n+                match a {\n                     // foo bar baz\n                     A::One => {}\n                     // This is where the rest should be\n-                    A::Two => {}\n+                    $0A::Two => {}\n                 }\n             }\n             \"#,\n@@ -687,25 +666,19 @@ mod tests {\n         check_assist(\n             fill_match_arms,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n             fn foo(a: A) {\n                 match a {\n                     // foo bar baz<|>\n                 }\n             }\n             \"#,\n             r#\"\n-            enum A {\n-                One,\n-                Two,\n-            }\n+            enum A { One, Two }\n             fn foo(a: A) {\n-                match <|>a {\n+                match a {\n                     // foo bar baz\n-                    A::One => {}\n+                    $0A::One => {}\n                     A::Two => {}\n                 }\n             }\n@@ -728,12 +701,37 @@ mod tests {\n             r#\"\n             enum A { One, Two, }\n             fn foo(a: A) {\n-                match <|>a {\n-                    A::One => {}\n+                match a {\n+                    $0A::One => {}\n                     A::Two => {}\n                 }\n             }\n             \"#,\n         );\n     }\n+\n+    #[test]\n+    fn option_order() {\n+        mark::check!(option_order);\n+        let before = r#\"\n+fn foo(opt: Option<i32>) {\n+    match opt<|> {\n+    }\n+}\"#;\n+        let before =\n+            &format!(\"//- main.rs crate:main deps:core\\n{}{}\", before, FamousDefs::FIXTURE);\n+\n+        check_assist(\n+            fill_match_arms,\n+            before,\n+            r#\"\n+fn foo(opt: Option<i32>) {\n+    match opt {\n+        $0Some(_) => {}\n+        None => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "9ec42f568c5957ca17ba21992a03fab4f522f5f6", "filename": "crates/ra_assists/src/handlers/fix_visibility.rs", "status": "added", "additions": 559, "deletions": 0, "changes": 559, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -0,0 +1,559 @@\n+use hir::{db::HirDatabase, HasSource, HasVisibility, PathResolution};\n+use ra_db::FileId;\n+use ra_syntax::{\n+    ast, AstNode,\n+    SyntaxKind::{ATTR, COMMENT, WHITESPACE},\n+    SyntaxNode, TextRange, TextSize,\n+};\n+\n+use crate::{AssistContext, AssistId, Assists};\n+\n+// FIXME: this really should be a fix for diagnostic, rather than an assist.\n+\n+// Assist: fix_visibility\n+//\n+// Makes inaccessible item public.\n+//\n+// ```\n+// mod m {\n+//     fn frobnicate() {}\n+// }\n+// fn main() {\n+//     m::frobnicate<|>() {}\n+// }\n+// ```\n+// ->\n+// ```\n+// mod m {\n+//     $0pub(crate) fn frobnicate() {}\n+// }\n+// fn main() {\n+//     m::frobnicate() {}\n+// }\n+// ```\n+pub(crate) fn fix_visibility(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    add_vis_to_referenced_module_def(acc, ctx)\n+        .or_else(|| add_vis_to_referenced_record_field(acc, ctx))\n+}\n+\n+fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let path: ast::Path = ctx.find_node_at_offset()?;\n+    let path_res = ctx.sema.resolve_path(&path)?;\n+    let def = match path_res {\n+        PathResolution::Def(def) => def,\n+        _ => return None,\n+    };\n+\n+    let current_module = ctx.sema.scope(&path.syntax()).module()?;\n+    let target_module = def.module(ctx.db)?;\n+\n+    let vis = target_module.visibility_of(ctx.db, &def)?;\n+    if vis.is_visible_from(ctx.db, current_module.into()) {\n+        return None;\n+    };\n+\n+    let (offset, target, target_file, target_name) = target_data_for_def(ctx.db, def)?;\n+\n+    let missing_visibility =\n+        if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n+\n+    let assist_label = match target_name {\n+        None => format!(\"Change visibility to {}\", missing_visibility),\n+        Some(name) => format!(\"Change visibility of {} to {}\", name, missing_visibility),\n+    };\n+\n+    acc.add(AssistId(\"fix_visibility\"), assist_label, target, |builder| {\n+        builder.set_file(target_file);\n+        match ctx.config.snippet_cap {\n+            Some(cap) => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),\n+            None => builder.insert(offset, format!(\"{} \", missing_visibility)),\n+        }\n+    })\n+}\n+\n+fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let record_field: ast::RecordField = ctx.find_node_at_offset()?;\n+    let (record_field_def, _) = ctx.sema.resolve_record_field(&record_field)?;\n+\n+    let current_module = ctx.sema.scope(record_field.syntax()).module()?;\n+    let visibility = record_field_def.visibility(ctx.db);\n+    if visibility.is_visible_from(ctx.db, current_module.into()) {\n+        return None;\n+    }\n+\n+    let parent = record_field_def.parent_def(ctx.db);\n+    let parent_name = parent.name(ctx.db);\n+    let target_module = parent.module(ctx.db);\n+\n+    let in_file_source = record_field_def.source(ctx.db);\n+    let (offset, target) = match in_file_source.value {\n+        hir::FieldSource::Named(it) => {\n+            let s = it.syntax();\n+            (vis_offset(s), s.text_range())\n+        }\n+        hir::FieldSource::Pos(it) => {\n+            let s = it.syntax();\n+            (vis_offset(s), s.text_range())\n+        }\n+    };\n+\n+    let missing_visibility =\n+        if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n+    let target_file = in_file_source.file_id.original_file(ctx.db);\n+\n+    let target_name = record_field_def.name(ctx.db);\n+    let assist_label =\n+        format!(\"Change visibility of {}.{} to {}\", parent_name, target_name, missing_visibility);\n+\n+    acc.add(AssistId(\"fix_visibility\"), assist_label, target, |builder| {\n+        builder.set_file(target_file);\n+        match ctx.config.snippet_cap {\n+            Some(cap) => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),\n+            None => builder.insert(offset, format!(\"{} \", missing_visibility)),\n+        }\n+    })\n+}\n+\n+fn target_data_for_def(\n+    db: &dyn HirDatabase,\n+    def: hir::ModuleDef,\n+) -> Option<(TextSize, TextRange, FileId, Option<hir::Name>)> {\n+    fn offset_target_and_file_id<S, Ast>(\n+        db: &dyn HirDatabase,\n+        x: S,\n+    ) -> (TextSize, TextRange, FileId)\n+    where\n+        S: HasSource<Ast = Ast>,\n+        Ast: AstNode,\n+    {\n+        let source = x.source(db);\n+        let in_file_syntax = source.syntax();\n+        let file_id = in_file_syntax.file_id;\n+        let syntax = in_file_syntax.value;\n+        (vis_offset(syntax), syntax.text_range(), file_id.original_file(db.upcast()))\n+    }\n+\n+    let target_name;\n+    let (offset, target, target_file) = match def {\n+        hir::ModuleDef::Function(f) => {\n+            target_name = Some(f.name(db));\n+            offset_target_and_file_id(db, f)\n+        }\n+        hir::ModuleDef::Adt(adt) => {\n+            target_name = Some(adt.name(db));\n+            match adt {\n+                hir::Adt::Struct(s) => offset_target_and_file_id(db, s),\n+                hir::Adt::Union(u) => offset_target_and_file_id(db, u),\n+                hir::Adt::Enum(e) => offset_target_and_file_id(db, e),\n+            }\n+        }\n+        hir::ModuleDef::Const(c) => {\n+            target_name = c.name(db);\n+            offset_target_and_file_id(db, c)\n+        }\n+        hir::ModuleDef::Static(s) => {\n+            target_name = s.name(db);\n+            offset_target_and_file_id(db, s)\n+        }\n+        hir::ModuleDef::Trait(t) => {\n+            target_name = Some(t.name(db));\n+            offset_target_and_file_id(db, t)\n+        }\n+        hir::ModuleDef::TypeAlias(t) => {\n+            target_name = Some(t.name(db));\n+            offset_target_and_file_id(db, t)\n+        }\n+        hir::ModuleDef::Module(m) => {\n+            target_name = m.name(db);\n+            let in_file_source = m.declaration_source(db)?;\n+            let file_id = in_file_source.file_id.original_file(db.upcast());\n+            let syntax = in_file_source.value.syntax();\n+            (vis_offset(syntax), syntax.text_range(), file_id)\n+        }\n+        // Enum variants can't be private, we can't modify builtin types\n+        hir::ModuleDef::EnumVariant(_) | hir::ModuleDef::BuiltinType(_) => return None,\n+    };\n+\n+    Some((offset, target, target_file, target_name))\n+}\n+\n+fn vis_offset(node: &SyntaxNode) -> TextSize {\n+    node.children_with_tokens()\n+        .skip_while(|it| match it.kind() {\n+            WHITESPACE | COMMENT | ATTR => true,\n+            _ => false,\n+        })\n+        .next()\n+        .map(|it| it.text_range().start())\n+        .unwrap_or_else(|| node.text_range().start())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn fix_visibility_of_fn() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { fn foo() {} }\n+              fn main() { foo::foo<|>() } \",\n+            r\"mod foo { $0pub(crate) fn foo() {} }\n+              fn main() { foo::foo() } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub fn foo() {} }\n+              fn main() { foo::foo<|>() } \",\n+        )\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_adt_in_submodule() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { struct Foo; }\n+              fn main() { foo::Foo<|> } \",\n+            r\"mod foo { $0pub(crate) struct Foo; }\n+              fn main() { foo::Foo } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub struct Foo; }\n+              fn main() { foo::Foo<|> } \",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { enum Foo; }\n+              fn main() { foo::Foo<|> } \",\n+            r\"mod foo { $0pub(crate) enum Foo; }\n+              fn main() { foo::Foo } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub enum Foo; }\n+              fn main() { foo::Foo<|> } \",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { union Foo; }\n+              fn main() { foo::Foo<|> } \",\n+            r\"mod foo { $0pub(crate) union Foo; }\n+              fn main() { foo::Foo } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub union Foo; }\n+              fn main() { foo::Foo<|> } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_adt_in_other_file() {\n+        check_assist(\n+            fix_visibility,\n+            r\"\n+              //- /main.rs\n+              mod foo;\n+              fn main() { foo::Foo<|> }\n+\n+              //- /foo.rs\n+              struct Foo;\n+              \",\n+            r\"$0pub(crate) struct Foo;\n+\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_struct_field() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { pub struct Foo { bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+            r\"mod foo { pub struct Foo { $0pub(crate) bar: (), } }\n+              fn main() { foo::Foo { bar: () }; } \",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub struct Foo { bar: () }\n+              \",\n+            r\"pub struct Foo { $0pub(crate) bar: () }\n+\n+\",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub struct Foo { pub bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub struct Foo { pub bar: () }\n+              \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_enum_variant_field() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { pub enum Foo { Bar { bar: () } } }\n+              fn main() { foo::Foo::Bar { <|>bar: () }; } \",\n+            r\"mod foo { pub enum Foo { Bar { $0pub(crate) bar: () } } }\n+              fn main() { foo::Foo::Bar { bar: () }; } \",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo::Bar { <|>bar: () }; }\n+              //- /foo.rs\n+              pub enum Foo { Bar { bar: () } }\n+              \",\n+            r\"pub enum Foo { Bar { $0pub(crate) bar: () } }\n+\n+\",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub struct Foo { pub bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub struct Foo { pub bar: () }\n+              \",\n+        );\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME reenable this test when `Semantics::resolve_record_field` works with union fields\n+    fn fix_visibility_of_union_field() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { pub union Foo { bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+            r\"mod foo { pub union Foo { $0pub(crate) bar: (), } }\n+              fn main() { foo::Foo { bar: () }; } \",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub union Foo { bar: () }\n+              \",\n+            r\"pub union Foo { $0pub(crate) bar: () }\n+\n+\",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub union Foo { pub bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub union Foo { pub bar: () }\n+              \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_const() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { const FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+            r\"mod foo { $0pub(crate) const FOO: () = (); }\n+              fn main() { foo::FOO } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub const FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_static() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { static FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+            r\"mod foo { $0pub(crate) static FOO: () = (); }\n+              fn main() { foo::FOO } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub static FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_trait() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { trait Foo { fn foo(&self) {} } }\n+              fn main() { let x: &dyn foo::<|>Foo; } \",\n+            r\"mod foo { $0pub(crate) trait Foo { fn foo(&self) {} } }\n+              fn main() { let x: &dyn foo::Foo; } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub trait Foo { fn foo(&self) {} } }\n+              fn main() { let x: &dyn foo::Foo<|>; } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_type_alias() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { type Foo = (); }\n+              fn main() { let x: foo::Foo<|>; } \",\n+            r\"mod foo { $0pub(crate) type Foo = (); }\n+              fn main() { let x: foo::Foo; } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub type Foo = (); }\n+              fn main() { let x: foo::Foo<|>; } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_module() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { mod bar { fn bar() {} } }\n+              fn main() { foo::bar<|>::bar(); } \",\n+            r\"mod foo { $0pub(crate) mod bar { fn bar() {} } }\n+              fn main() { foo::bar::bar(); } \",\n+        );\n+\n+        check_assist(\n+            fix_visibility,\n+            r\"\n+            //- /main.rs\n+            mod foo;\n+            fn main() { foo::bar<|>::baz(); }\n+\n+            //- /foo.rs\n+            mod bar {\n+                pub fn baz() {}\n+            }\n+            \",\n+            r\"$0pub(crate) mod bar {\n+    pub fn baz() {}\n+}\n+\n+\",\n+        );\n+\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub mod bar { pub fn bar() {} } }\n+              fn main() { foo::bar<|>::bar(); } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_inline_module_in_other_file() {\n+        check_assist(\n+            fix_visibility,\n+            r\"\n+            //- /main.rs\n+            mod foo;\n+            fn main() { foo::bar<|>::baz(); }\n+\n+            //- /foo.rs\n+            mod bar;\n+\n+            //- /foo/bar.rs\n+            pub fn baz() {}\n+            }\n+            \",\n+            r\"$0pub(crate) mod bar;\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_module_declaration_in_other_file() {\n+        check_assist(\n+            fix_visibility,\n+            r\"//- /main.rs\n+              mod foo;\n+              fn main() { foo::bar<|>>::baz(); }\n+\n+              //- /foo.rs\n+              mod bar {\n+                  pub fn baz() {}\n+              }\",\n+            r\"$0pub(crate) mod bar {\n+    pub fn baz() {}\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn adds_pub_when_target_is_in_another_crate() {\n+        check_assist(\n+            fix_visibility,\n+            r\"//- /main.rs crate:a deps:foo\n+              foo::Bar<|>\n+              //- /lib.rs crate:foo\n+              struct Bar;\",\n+            r\"$0pub struct Bar;\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME handle reexports properly\n+    fn fix_visibility_of_reexport() {\n+        check_assist(\n+            fix_visibility,\n+            r\"\n+            mod foo {\n+                use bar::Baz;\n+                mod bar { pub(super) struct Baz; }\n+            }\n+            foo::Baz<|>\n+            \",\n+            r\"\n+            mod foo {\n+                $0pub(crate) use bar::Baz;\n+                mod bar { pub(super) struct Baz; }\n+            }\n+            foo::Baz\n+            \",\n+        )\n+    }\n+}"}, {"sha": "5731965766b048c1d42fc55aadef98cbb6226bfc", "filename": "crates/ra_assists/src/handlers/flip_binexpr.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -85,25 +85,21 @@ mod tests {\n         check_assist(\n             flip_binexpr,\n             \"fn f() { let res = 1 ==<|> 2; }\",\n-            \"fn f() { let res = 2 ==<|> 1; }\",\n+            \"fn f() { let res = 2 == 1; }\",\n         )\n     }\n \n     #[test]\n     fn flip_binexpr_works_for_gt() {\n-        check_assist(\n-            flip_binexpr,\n-            \"fn f() { let res = 1 ><|> 2; }\",\n-            \"fn f() { let res = 2 <<|> 1; }\",\n-        )\n+        check_assist(flip_binexpr, \"fn f() { let res = 1 ><|> 2; }\", \"fn f() { let res = 2 < 1; }\")\n     }\n \n     #[test]\n     fn flip_binexpr_works_for_lteq() {\n         check_assist(\n             flip_binexpr,\n             \"fn f() { let res = 1 <=<|> 2; }\",\n-            \"fn f() { let res = 2 >=<|> 1; }\",\n+            \"fn f() { let res = 2 >= 1; }\",\n         )\n     }\n \n@@ -112,7 +108,7 @@ mod tests {\n         check_assist(\n             flip_binexpr,\n             \"fn f() { let res = (1 + 1) ==<|> (2 + 2); }\",\n-            \"fn f() { let res = (2 + 2) ==<|> (1 + 1); }\",\n+            \"fn f() { let res = (2 + 2) == (1 + 1); }\",\n         )\n     }\n \n@@ -132,7 +128,7 @@ mod tests {\n             fn dyn_eq(&self, other: &dyn Diagnostic) -> bool {\n                 match other.downcast_ref::<Self>() {\n                     None => false,\n-                    Some(it) => self ==<|> it,\n+                    Some(it) => self == it,\n                 }\n             }\n             \"#,"}, {"sha": "a57a1c463c4416a63687766e03eb4111036688c9", "filename": "crates/ra_assists/src/handlers/flip_comma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -45,7 +45,7 @@ mod tests {\n         check_assist(\n             flip_comma,\n             \"fn foo(x: i32,<|> y: Result<(), ()>) {}\",\n-            \"fn foo(y: Result<(), ()>,<|> x: i32) {}\",\n+            \"fn foo(y: Result<(), ()>, x: i32) {}\",\n         )\n     }\n "}, {"sha": "0115adc8b53ab32d965ed204e62d276dc3629ccf", "filename": "crates/ra_assists/src/handlers/flip_trait_bound.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -60,7 +60,7 @@ mod tests {\n         check_assist(\n             flip_trait_bound,\n             \"struct S<T> where T: A <|>+ B { }\",\n-            \"struct S<T> where T: B <|>+ A { }\",\n+            \"struct S<T> where T: B + A { }\",\n         )\n     }\n \n@@ -69,21 +69,21 @@ mod tests {\n         check_assist(\n             flip_trait_bound,\n             \"impl X for S<T> where T: A +<|> B { }\",\n-            \"impl X for S<T> where T: B +<|> A { }\",\n+            \"impl X for S<T> where T: B + A { }\",\n         )\n     }\n \n     #[test]\n     fn flip_trait_bound_works_for_fn() {\n-        check_assist(flip_trait_bound, \"fn f<T: A <|>+ B>(t: T) { }\", \"fn f<T: B <|>+ A>(t: T) { }\")\n+        check_assist(flip_trait_bound, \"fn f<T: A <|>+ B>(t: T) { }\", \"fn f<T: B + A>(t: T) { }\")\n     }\n \n     #[test]\n     fn flip_trait_bound_works_for_fn_where_clause() {\n         check_assist(\n             flip_trait_bound,\n             \"fn f<T>(t: T) where T: A +<|> B { }\",\n-            \"fn f<T>(t: T) where T: B +<|> A { }\",\n+            \"fn f<T>(t: T) where T: B + A { }\",\n         )\n     }\n \n@@ -92,7 +92,7 @@ mod tests {\n         check_assist(\n             flip_trait_bound,\n             \"fn f<T>(t: T) where T: A <|>+ 'static { }\",\n-            \"fn f<T>(t: T) where T: 'static <|>+ A { }\",\n+            \"fn f<T>(t: T) where T: 'static + A { }\",\n         )\n     }\n \n@@ -101,7 +101,7 @@ mod tests {\n         check_assist(\n             flip_trait_bound,\n             \"struct S<T> where T: A<T> <|>+ b_mod::B<T> + C<T> { }\",\n-            \"struct S<T> where T: b_mod::B<T> <|>+ A<T> + C<T> { }\",\n+            \"struct S<T> where T: b_mod::B<T> + A<T> + C<T> { }\",\n         )\n     }\n \n@@ -110,7 +110,7 @@ mod tests {\n         check_assist(\n             flip_trait_bound,\n             \"struct S<T> where T: A + B + C + D + E + F +<|> G + H + I + J { }\",\n-            \"struct S<T> where T: A + B + C + D + E + G +<|> F + H + I + J { }\",\n+            \"struct S<T> where T: A + B + C + D + E + G + F + H + I + J { }\",\n         )\n     }\n }"}, {"sha": "d26e68847984a20b0e63fcfbb266986a9c8b9fa4", "filename": "crates/ra_assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{\n     ast::{self, AstNode, AstToken},\n     TextRange,\n };\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n@@ -33,11 +33,11 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n         _ => return None,\n     };\n     if bind_pat.mut_token().is_some() {\n-        tested_by!(test_not_inline_mut_variable);\n+        mark::hit!(test_not_inline_mut_variable);\n         return None;\n     }\n     if !bind_pat.syntax().text_range().contains_inclusive(ctx.offset()) {\n-        tested_by!(not_applicable_outside_of_bind_pat);\n+        mark::hit!(not_applicable_outside_of_bind_pat);\n         return None;\n     }\n     let initializer_expr = let_stmt.initializer()?;\n@@ -46,7 +46,7 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n     let def = Definition::Local(def);\n     let refs = def.find_usages(ctx.db, None);\n     if refs.is_empty() {\n-        tested_by!(test_not_applicable_if_variable_unused);\n+        mark::hit!(test_not_applicable_if_variable_unused);\n         return None;\n     };\n \n@@ -116,13 +116,12 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n             let replacement = if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n             builder.replace(desc.file_range.range, replacement)\n         }\n-        builder.set_cursor(delete_range.start())\n     })\n }\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n     use crate::tests::{check_assist, check_assist_not_applicable};\n \n@@ -149,7 +148,7 @@ fn foo() {\n             r\"\n fn bar(a: usize) {}\n fn foo() {\n-    <|>1 + 1;\n+    1 + 1;\n     if 1 > 10 {\n     }\n \n@@ -183,7 +182,7 @@ fn foo() {\n             r\"\n fn bar(a: usize) {}\n fn foo() {\n-    <|>(1 + 1) + 1;\n+    (1 + 1) + 1;\n     if (1 + 1) > 10 {\n     }\n \n@@ -217,7 +216,7 @@ fn foo() {\n             r\"\n fn bar(a: usize) {}\n fn foo() {\n-    <|>bar(1) + 1;\n+    bar(1) + 1;\n     if bar(1) > 10 {\n     }\n \n@@ -251,7 +250,7 @@ fn foo() {\n             r\"\n fn bar(a: usize): usize { a }\n fn foo() {\n-    <|>(bar(1) as u64) + 1;\n+    (bar(1) as u64) + 1;\n     if (bar(1) as u64) > 10 {\n     }\n \n@@ -283,7 +282,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>{ 10 + 1 } + 1;\n+    { 10 + 1 } + 1;\n     if { 10 + 1 } > 10 {\n     }\n \n@@ -315,7 +314,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>( 10 + 1 ) + 1;\n+    ( 10 + 1 ) + 1;\n     if ( 10 + 1 ) > 10 {\n     }\n \n@@ -330,7 +329,7 @@ fn foo() {\n \n     #[test]\n     fn test_not_inline_mut_variable() {\n-        covers!(test_not_inline_mut_variable);\n+        mark::check!(test_not_inline_mut_variable);\n         check_assist_not_applicable(\n             inline_local_variable,\n             r\"\n@@ -353,7 +352,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>let b = bar(10 + 1) * 10;\n+    let b = bar(10 + 1) * 10;\n     let c = bar(10 + 1) as usize;\n }\",\n         );\n@@ -373,7 +372,7 @@ fn foo() {\n             r\"\n fn foo() {\n     let x = vec![1, 2, 3];\n-    <|>let b = x[0] * 10;\n+    let b = x[0] * 10;\n     let c = x[0] as usize;\n }\",\n         );\n@@ -393,7 +392,7 @@ fn foo() {\n             r\"\n fn foo() {\n     let bar = vec![1];\n-    <|>let b = bar.len() * 10;\n+    let b = bar.len() * 10;\n     let c = bar.len() as usize;\n }\",\n         );\n@@ -421,7 +420,7 @@ struct Bar {\n \n fn foo() {\n     let bar = Bar { foo: 1 };\n-    <|>let b = bar.foo * 10;\n+    let b = bar.foo * 10;\n     let c = bar.foo as usize;\n }\",\n         );\n@@ -442,7 +441,7 @@ fn foo() -> Option<usize> {\n             r\"\n fn foo() -> Option<usize> {\n     let bar = Some(1);\n-    <|>let b = bar? * 10;\n+    let b = bar? * 10;\n     let c = bar? as usize;\n     None\n }\",\n@@ -462,7 +461,7 @@ fn foo() {\n             r\"\n fn foo() {\n     let bar = 10;\n-    <|>let b = &bar * 10;\n+    let b = &bar * 10;\n }\",\n         );\n     }\n@@ -478,7 +477,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>let b = (10, 20)[0];\n+    let b = (10, 20)[0];\n }\",\n         );\n     }\n@@ -494,7 +493,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>let b = [1, 2, 3].len();\n+    let b = [1, 2, 3].len();\n }\",\n         );\n     }\n@@ -511,7 +510,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>let b = (10 + 20) * 10;\n+    let b = (10 + 20) * 10;\n     let c = (10 + 20) as usize;\n }\",\n         );\n@@ -531,7 +530,7 @@ fn foo() {\n             r\"\n fn foo() {\n     let d = 10;\n-    <|>let b = d * 10;\n+    let b = d * 10;\n     let c = d as usize;\n }\",\n         );\n@@ -549,7 +548,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>let b = { 10 } * 10;\n+    let b = { 10 } * 10;\n     let c = { 10 } as usize;\n }\",\n         );\n@@ -569,7 +568,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>let b = (10 + 20) * 10;\n+    let b = (10 + 20) * 10;\n     let c = (10 + 20, 20);\n     let d = [10 + 20, 10];\n     let e = (10 + 20);\n@@ -588,7 +587,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>for i in vec![10, 20] {}\n+    for i in vec![10, 20] {}\n }\",\n         );\n     }\n@@ -604,7 +603,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>while 1 > 0 {}\n+    while 1 > 0 {}\n }\",\n         );\n     }\n@@ -622,7 +621,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>loop {\n+    loop {\n         break 1 + 1;\n     }\n }\",\n@@ -640,7 +639,7 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>return 1 > 0;\n+    return 1 > 0;\n }\",\n         );\n     }\n@@ -656,14 +655,14 @@ fn foo() {\n }\",\n             r\"\n fn foo() {\n-    <|>match 1 > 0 {}\n+    match 1 > 0 {}\n }\",\n         );\n     }\n \n     #[test]\n     fn test_not_applicable_if_variable_unused() {\n-        covers!(test_not_applicable_if_variable_unused);\n+        mark::check!(test_not_applicable_if_variable_unused);\n         check_assist_not_applicable(\n             inline_local_variable,\n             r\"\n@@ -676,7 +675,7 @@ fn foo() {\n \n     #[test]\n     fn not_applicable_outside_of_bind_pat() {\n-        covers!(not_applicable_outside_of_bind_pat);\n+        mark::check!(not_applicable_outside_of_bind_pat);\n         check_assist_not_applicable(\n             inline_local_variable,\n             r\""}, {"sha": "31d6539f7a77b46866102aefe0e553903aef6162", "filename": "crates/ra_assists/src/handlers/introduce_variable.rs", "status": "modified", "additions": 71, "deletions": 57, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -4,10 +4,10 @@ use ra_syntax::{\n         BLOCK_EXPR, BREAK_EXPR, COMMENT, LAMBDA_EXPR, LOOP_EXPR, MATCH_ARM, PATH_EXPR, RETURN_EXPR,\n         WHITESPACE,\n     },\n-    SyntaxNode, TextSize,\n+    SyntaxNode,\n };\n use stdx::format_to;\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{AssistContext, AssistId, Assists};\n \n@@ -23,7 +23,7 @@ use crate::{AssistContext, AssistId, Assists};\n // ->\n // ```\n // fn main() {\n-//     let var_name = (1 + 2);\n+//     let $0var_name = (1 + 2);\n //     var_name * 4;\n // }\n // ```\n@@ -33,7 +33,7 @@ pub(crate) fn introduce_variable(acc: &mut Assists, ctx: &AssistContext) -> Opti\n     }\n     let node = ctx.covering_element();\n     if node.kind() == COMMENT {\n-        tested_by!(introduce_var_in_comment_is_not_applicable);\n+        mark::hit!(introduce_var_in_comment_is_not_applicable);\n         return None;\n     }\n     let expr = node.ancestors().find_map(valid_target_expr)?;\n@@ -46,47 +46,61 @@ pub(crate) fn introduce_variable(acc: &mut Assists, ctx: &AssistContext) -> Opti\n     acc.add(AssistId(\"introduce_variable\"), \"Extract into variable\", target, move |edit| {\n         let mut buf = String::new();\n \n-        let cursor_offset = if wrap_in_block {\n+        if wrap_in_block {\n             buf.push_str(\"{ let var_name = \");\n-            TextSize::of(\"{ let \")\n         } else {\n             buf.push_str(\"let var_name = \");\n-            TextSize::of(\"let \")\n         };\n         format_to!(buf, \"{}\", expr.syntax());\n+\n         let full_stmt = ast::ExprStmt::cast(anchor_stmt.clone());\n         let is_full_stmt = if let Some(expr_stmt) = &full_stmt {\n             Some(expr.syntax().clone()) == expr_stmt.expr().map(|e| e.syntax().clone())\n         } else {\n             false\n         };\n         if is_full_stmt {\n-            tested_by!(test_introduce_var_expr_stmt);\n+            mark::hit!(test_introduce_var_expr_stmt);\n             if full_stmt.unwrap().semicolon_token().is_none() {\n                 buf.push_str(\";\");\n             }\n-            edit.replace(expr.syntax().text_range(), buf);\n-        } else {\n-            buf.push_str(\";\");\n-\n-            // We want to maintain the indent level,\n-            // but we do not want to duplicate possible\n-            // extra newlines in the indent block\n-            let text = indent.text();\n-            if text.starts_with('\\n') {\n-                buf.push_str(\"\\n\");\n-                buf.push_str(text.trim_start_matches('\\n'));\n-            } else {\n-                buf.push_str(text);\n+            let offset = expr.syntax().text_range();\n+            match ctx.config.snippet_cap {\n+                Some(cap) => {\n+                    let snip = buf.replace(\"let var_name\", \"let $0var_name\");\n+                    edit.replace_snippet(cap, offset, snip)\n+                }\n+                None => edit.replace(offset, buf),\n             }\n+            return;\n+        }\n \n-            edit.replace(expr.syntax().text_range(), \"var_name\".to_string());\n-            edit.insert(anchor_stmt.text_range().start(), buf);\n-            if wrap_in_block {\n-                edit.insert(anchor_stmt.text_range().end(), \" }\");\n+        buf.push_str(\";\");\n+\n+        // We want to maintain the indent level,\n+        // but we do not want to duplicate possible\n+        // extra newlines in the indent block\n+        let text = indent.text();\n+        if text.starts_with('\\n') {\n+            buf.push_str(\"\\n\");\n+            buf.push_str(text.trim_start_matches('\\n'));\n+        } else {\n+            buf.push_str(text);\n+        }\n+\n+        edit.replace(expr.syntax().text_range(), \"var_name\".to_string());\n+        let offset = anchor_stmt.text_range().start();\n+        match ctx.config.snippet_cap {\n+            Some(cap) => {\n+                let snip = buf.replace(\"let var_name\", \"let $0var_name\");\n+                edit.insert_snippet(cap, offset, snip)\n             }\n+            None => edit.insert(offset, buf),\n+        }\n+\n+        if wrap_in_block {\n+            edit.insert(anchor_stmt.text_range().end(), \" }\");\n         }\n-        edit.set_cursor(anchor_stmt.text_range().start() + cursor_offset);\n     })\n }\n \n@@ -113,7 +127,7 @@ fn anchor_stmt(expr: ast::Expr) -> Option<(SyntaxNode, bool)> {\n     expr.syntax().ancestors().find_map(|node| {\n         if let Some(expr) = node.parent().and_then(ast::BlockExpr::cast).and_then(|it| it.expr()) {\n             if expr.syntax() == &node {\n-                tested_by!(test_introduce_var_last_expr);\n+                mark::hit!(test_introduce_var_last_expr);\n                 return Some((node, false));\n             }\n         }\n@@ -134,7 +148,7 @@ fn anchor_stmt(expr: ast::Expr) -> Option<(SyntaxNode, bool)> {\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n@@ -144,37 +158,37 @@ mod tests {\n     fn test_introduce_var_simple() {\n         check_assist(\n             introduce_variable,\n-            \"\n+            r#\"\n fn foo() {\n     foo(<|>1 + 1<|>);\n-}\",\n-            \"\n+}\"#,\n+            r#\"\n fn foo() {\n-    let <|>var_name = 1 + 1;\n+    let $0var_name = 1 + 1;\n     foo(var_name);\n-}\",\n+}\"#,\n         );\n     }\n \n     #[test]\n     fn introduce_var_in_comment_is_not_applicable() {\n-        covers!(introduce_var_in_comment_is_not_applicable);\n+        mark::check!(introduce_var_in_comment_is_not_applicable);\n         check_assist_not_applicable(introduce_variable, \"fn main() { 1 + /* <|>comment<|> */ 1; }\");\n     }\n \n     #[test]\n     fn test_introduce_var_expr_stmt() {\n-        covers!(test_introduce_var_expr_stmt);\n+        mark::check!(test_introduce_var_expr_stmt);\n         check_assist(\n             introduce_variable,\n-            \"\n+            r#\"\n fn foo() {\n     <|>1 + 1<|>;\n-}\",\n-            \"\n+}\"#,\n+            r#\"\n fn foo() {\n-    let <|>var_name = 1 + 1;\n-}\",\n+    let $0var_name = 1 + 1;\n+}\"#,\n         );\n         check_assist(\n             introduce_variable,\n@@ -185,7 +199,7 @@ fn foo() {\n }\",\n             \"\n fn foo() {\n-    let <|>var_name = { let x = 0; x };\n+    let $0var_name = { let x = 0; x };\n     something_else();\n }\",\n         );\n@@ -201,15 +215,15 @@ fn foo() {\n }\",\n             \"\n fn foo() {\n-    let <|>var_name = 1;\n+    let $0var_name = 1;\n     var_name + 1;\n }\",\n         );\n     }\n \n     #[test]\n     fn test_introduce_var_last_expr() {\n-        covers!(test_introduce_var_last_expr);\n+        mark::check!(test_introduce_var_last_expr);\n         check_assist(\n             introduce_variable,\n             \"\n@@ -218,7 +232,7 @@ fn foo() {\n }\",\n             \"\n fn foo() {\n-    let <|>var_name = 1 + 1;\n+    let $0var_name = 1 + 1;\n     bar(var_name)\n }\",\n         );\n@@ -230,7 +244,7 @@ fn foo() {\n }\",\n             \"\n fn foo() {\n-    let <|>var_name = bar(1 + 1);\n+    let $0var_name = bar(1 + 1);\n     var_name\n }\",\n         )\n@@ -253,7 +267,7 @@ fn main() {\n fn main() {\n     let x = true;\n     let tuple = match x {\n-        true => { let <|>var_name = 2 + 2; (var_name, true) }\n+        true => { let $0var_name = 2 + 2; (var_name, true) }\n         _ => (0, false)\n     };\n }\n@@ -283,7 +297,7 @@ fn main() {\n     let tuple = match x {\n         true => {\n             let y = 1;\n-            let <|>var_name = 2 + y;\n+            let $0var_name = 2 + y;\n             (var_name, true)\n         }\n         _ => (0, false)\n@@ -304,7 +318,7 @@ fn main() {\n \",\n             \"\n fn main() {\n-    let lambda = |x: u32| { let <|>var_name = x * 2; var_name };\n+    let lambda = |x: u32| { let $0var_name = x * 2; var_name };\n }\n \",\n         );\n@@ -321,7 +335,7 @@ fn main() {\n \",\n             \"\n fn main() {\n-    let lambda = |x: u32| { let <|>var_name = x * 2; var_name };\n+    let lambda = |x: u32| { let $0var_name = x * 2; var_name };\n }\n \",\n         );\n@@ -338,7 +352,7 @@ fn main() {\n \",\n             \"\n fn main() {\n-    let <|>var_name = Some(true);\n+    let $0var_name = Some(true);\n     let o = var_name;\n }\n \",\n@@ -356,7 +370,7 @@ fn main() {\n \",\n             \"\n fn main() {\n-    let <|>var_name = bar.foo();\n+    let $0var_name = bar.foo();\n     let v = var_name;\n }\n \",\n@@ -374,7 +388,7 @@ fn foo() -> u32 {\n \",\n             \"\n fn foo() -> u32 {\n-    let <|>var_name = 2 + 2;\n+    let $0var_name = 2 + 2;\n     return var_name;\n }\n \",\n@@ -396,7 +410,7 @@ fn foo() -> u32 {\n fn foo() -> u32 {\n \n \n-    let <|>var_name = 2 + 2;\n+    let $0var_name = 2 + 2;\n     return var_name;\n }\n \",\n@@ -413,7 +427,7 @@ fn foo() -> u32 {\n             \"\n fn foo() -> u32 {\n \n-        let <|>var_name = 2 + 2;\n+        let $0var_name = 2 + 2;\n         return var_name;\n }\n \",\n@@ -438,7 +452,7 @@ fn foo() -> u32 {\n     // bar\n \n \n-    let <|>var_name = 2 + 2;\n+    let $0var_name = 2 + 2;\n     return var_name;\n }\n \",\n@@ -459,7 +473,7 @@ fn main() {\n             \"\n fn main() {\n     let result = loop {\n-        let <|>var_name = 2 + 2;\n+        let $0var_name = 2 + 2;\n         break var_name;\n     };\n }\n@@ -478,7 +492,7 @@ fn main() {\n \",\n             \"\n fn main() {\n-    let <|>var_name = 0f32 as u32;\n+    let $0var_name = 0f32 as u32;\n     let v = var_name;\n }\n \","}, {"sha": "59d278eb9bed8c03466ced60fce54599420093a2", "filename": "crates/ra_assists/src/handlers/invert_if.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -72,7 +72,7 @@ mod tests {\n         check_assist(\n             invert_if,\n             \"fn f() { i<|>f x != 3 { 1 } else { 3 + 2 } }\",\n-            \"fn f() { i<|>f x == 3 { 3 + 2 } else { 1 } }\",\n+            \"fn f() { if x == 3 { 3 + 2 } else { 1 } }\",\n         )\n     }\n \n@@ -81,7 +81,7 @@ mod tests {\n         check_assist(\n             invert_if,\n             \"fn f() { <|>if !cond { 3 * 2 } else { 1 } }\",\n-            \"fn f() { <|>if cond { 1 } else { 3 * 2 } }\",\n+            \"fn f() { if cond { 1 } else { 3 * 2 } }\",\n         )\n     }\n \n@@ -90,7 +90,7 @@ mod tests {\n         check_assist(\n             invert_if,\n             \"fn f() { i<|>f cond { 3 * 2 } else { 1 } }\",\n-            \"fn f() { i<|>f !cond { 1 } else { 3 * 2 } }\",\n+            \"fn f() { if !cond { 1 } else { 3 * 2 } }\",\n         )\n     }\n "}, {"sha": "972d162419468d830b8aa08ea6595b4db840b791", "filename": "crates/ra_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -58,8 +58,6 @@ pub(crate) fn merge_imports(acc: &mut Assists, ctx: &AssistContext) -> Option<()\n     let target = tree.syntax().text_range();\n     acc.add(AssistId(\"merge_imports\"), \"Merge imports\", target, |builder| {\n         builder.rewrite(rewriter);\n-        // FIXME: we only need because our diff is imprecise\n-        builder.set_cursor(offset);\n     })\n }\n \n@@ -142,7 +140,7 @@ use std::fmt<|>::Debug;\n use std::fmt::Display;\n \",\n             r\"\n-use std::fmt<|>::{Debug, Display};\n+use std::fmt::{Debug, Display};\n \",\n         )\n     }\n@@ -156,7 +154,7 @@ use std::fmt::Debug;\n use std::fmt<|>::Display;\n \",\n             r\"\n-use std::fmt:<|>:{Display, Debug};\n+use std::fmt::{Display, Debug};\n \",\n         );\n     }\n@@ -169,7 +167,7 @@ use std::fmt:<|>:{Display, Debug};\n use std::{fmt<|>::Debug, fmt::Display};\n \",\n             r\"\n-use std::{fmt<|>::{Debug, Display}};\n+use std::{fmt::{Debug, Display}};\n \",\n         );\n         check_assist(\n@@ -178,7 +176,7 @@ use std::{fmt<|>::{Debug, Display}};\n use std::{fmt::Debug, fmt<|>::Display};\n \",\n             r\"\n-use std::{fmt::<|>{Display, Debug}};\n+use std::{fmt::{Display, Debug}};\n \",\n         );\n     }\n@@ -192,7 +190,7 @@ use std<|>::cell::*;\n use std::str;\n \",\n             r\"\n-use std<|>::{cell::*, str};\n+use std::{cell::*, str};\n \",\n         )\n     }\n@@ -206,7 +204,7 @@ use std<|>::cell::*;\n use std::str::*;\n \",\n             r\"\n-use std<|>::{cell::*, str::*};\n+use std::{cell::*, str::*};\n \",\n         )\n     }\n@@ -222,7 +220,7 @@ use foo::baz;\n /// Doc comment\n \",\n             r\"\n-use foo<|>::{bar, baz};\n+use foo::{bar, baz};\n \n /// Doc comment\n \",\n@@ -241,7 +239,7 @@ use {\n \",\n             r\"\n use {\n-    foo<|>::{bar, baz},\n+    foo::{bar, baz},\n };\n \",\n         );\n@@ -255,7 +253,7 @@ use {\n \",\n             r\"\n use {\n-    foo::{bar<|>, baz},\n+    foo::{bar, baz},\n };\n \",\n         );\n@@ -272,7 +270,7 @@ use foo::<|>{\n };\n \",\n             r\"\n-use foo::{<|>\n+use foo::{\n     FooBar,\n bar::baz};\n \","}, {"sha": "ca04ec671a0f0761cd6568c0d71b3ef6a74fd81f", "filename": "crates/ra_assists/src/handlers/merge_match_arms.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -3,7 +3,7 @@ use std::iter::successors;\n use ra_syntax::{\n     algo::neighbor,\n     ast::{self, AstNode},\n-    Direction, TextSize,\n+    Direction,\n };\n \n use crate::{AssistContext, AssistId, Assists, TextRange};\n@@ -41,17 +41,6 @@ pub(crate) fn merge_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option\n     let current_expr = current_arm.expr()?;\n     let current_text_range = current_arm.syntax().text_range();\n \n-    enum CursorPos {\n-        InExpr(TextSize),\n-        InPat(TextSize),\n-    }\n-    let cursor_pos = ctx.offset();\n-    let cursor_pos = if current_expr.syntax().text_range().contains(cursor_pos) {\n-        CursorPos::InExpr(current_text_range.end() - cursor_pos)\n-    } else {\n-        CursorPos::InPat(cursor_pos)\n-    };\n-\n     // We check if the following match arms match this one. We could, but don't,\n     // compare to the previous match arm as well.\n     let arms_to_merge = successors(Some(current_arm), |it| neighbor(it, Direction::Next))\n@@ -87,10 +76,6 @@ pub(crate) fn merge_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option\n         let start = arms_to_merge.first().unwrap().syntax().text_range().start();\n         let end = arms_to_merge.last().unwrap().syntax().text_range().end();\n \n-        edit.set_cursor(match cursor_pos {\n-            CursorPos::InExpr(back_offset) => start + TextSize::of(&arm) - back_offset,\n-            CursorPos::InPat(offset) => offset,\n-        });\n         edit.replace(TextRange::new(start, end), arm);\n     })\n }\n@@ -132,7 +117,7 @@ mod tests {\n             fn main() {\n                 let x = X::A;\n                 let y = match x {\n-                    X::A | X::B => { 1i32<|> }\n+                    X::A | X::B => { 1i32 }\n                     X::C => { 2i32 }\n                 }\n             }\n@@ -164,7 +149,7 @@ mod tests {\n             fn main() {\n                 let x = X::A;\n                 let y = match x {\n-                    X::A | X::B | X::C | X::D => {<|> 1i32 },\n+                    X::A | X::B | X::C | X::D => { 1i32 },\n                     X::E => { 2i32 },\n                 }\n             }\n@@ -197,7 +182,7 @@ mod tests {\n                 let x = X::A;\n                 let y = match x {\n                     X::A => { 1i32 },\n-                    _ => { 2i<|>32 }\n+                    _ => { 2i32 }\n                 }\n             }\n             \"#,\n@@ -226,7 +211,7 @@ mod tests {\n \n             fn main() {\n                 match X::A {\n-                    X::A<|> | X::B | X::C => 92,\n+                    X::A | X::B | X::C => 92,\n                     X::D => 62,\n                     _ => panic!(),\n                 }"}, {"sha": "be2a7eddcfad3999dc071dcfb795047e6bed146f", "filename": "crates/ra_assists/src/handlers/move_bounds.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -99,7 +99,7 @@ mod tests {\n             fn foo<T: u32, <|>F: FnOnce(T) -> T>() {}\n             \"#,\n             r#\"\n-            fn foo<T, <|>F>() where T: u32, F: FnOnce(T) -> T {}\n+            fn foo<T, F>() where T: u32, F: FnOnce(T) -> T {}\n             \"#,\n         );\n     }\n@@ -112,7 +112,7 @@ mod tests {\n             impl<U: u32, <|>T> A<U, T> {}\n             \"#,\n             r#\"\n-            impl<U, <|>T> A<U, T> where U: u32 {}\n+            impl<U, T> A<U, T> where U: u32 {}\n             \"#,\n         );\n     }\n@@ -125,7 +125,7 @@ mod tests {\n             struct A<<|>T: Iterator<Item = u32>> {}\n             \"#,\n             r#\"\n-            struct A<<|>T> where T: Iterator<Item = u32> {}\n+            struct A<T> where T: Iterator<Item = u32> {}\n             \"#,\n         );\n     }\n@@ -138,7 +138,7 @@ mod tests {\n             struct Pair<<|>T: u32>(T, T);\n             \"#,\n             r#\"\n-            struct Pair<<|>T>(T, T) where T: u32;\n+            struct Pair<T>(T, T) where T: u32;\n             \"#,\n         );\n     }"}, {"sha": "7edcf07489584d1df0571c38c2f33b14db33faeb", "filename": "crates/ra_assists/src/handlers/move_guard.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,7 +1,6 @@\n use ra_syntax::{\n-    ast,\n-    ast::{AstNode, AstToken, IfExpr, MatchArm},\n-    TextSize,\n+    ast::{AstNode, IfExpr, MatchArm},\n+    SyntaxKind::WHITESPACE,\n };\n \n use crate::{AssistContext, AssistId, Assists};\n@@ -42,24 +41,15 @@ pub(crate) fn move_guard_to_arm_body(acc: &mut Assists, ctx: &AssistContext) ->\n \n     let target = guard.syntax().text_range();\n     acc.add(AssistId(\"move_guard_to_arm_body\"), \"Move guard to arm body\", target, |edit| {\n-        let offseting_amount = match space_before_guard.and_then(|it| it.into_token()) {\n-            Some(tok) => {\n-                if ast::Whitespace::cast(tok.clone()).is_some() {\n-                    let ele = tok.text_range();\n-                    edit.delete(ele);\n-                    ele.len()\n-                } else {\n-                    TextSize::from(0)\n-                }\n+        match space_before_guard {\n+            Some(element) if element.kind() == WHITESPACE => {\n+                edit.delete(element.text_range());\n             }\n-            _ => TextSize::from(0),\n+            _ => (),\n         };\n \n         edit.delete(guard.syntax().text_range());\n         edit.replace_node_and_indent(arm_expr.syntax(), buf);\n-        edit.set_cursor(\n-            arm_expr.syntax().text_range().start() + TextSize::from(3) - offseting_amount,\n-        );\n     })\n }\n \n@@ -124,7 +114,6 @@ pub(crate) fn move_arm_cond_to_match_guard(acc: &mut Assists, ctx: &AssistContex\n             }\n \n             edit.insert(match_pat.syntax().text_range().end(), buf);\n-            edit.set_cursor(match_pat.syntax().text_range().end() + TextSize::from(1));\n         },\n     )\n }\n@@ -172,7 +161,7 @@ mod tests {\n                 let t = 'a';\n                 let chars = \"abcd\";\n                 match t {\n-                    '\\r' => if chars.clone().next() == Some('\\n') { <|>false },\n+                    '\\r' => if chars.clone().next() == Some('\\n') { false },\n                     _ => true\n                 }\n             }\n@@ -195,7 +184,7 @@ mod tests {\n             r#\"\n             fn f() {\n                 match x {\n-                    y @ 4 | y @ 5 => if y > 5 { <|>true },\n+                    y @ 4 | y @ 5 => if y > 5 { true },\n                     _ => false\n                 }\n             }\n@@ -222,7 +211,7 @@ mod tests {\n                 let t = 'a';\n                 let chars = \"abcd\";\n                 match t {\n-                    '\\r' <|>if chars.clone().next() == Some('\\n') => false,\n+                    '\\r' if chars.clone().next() == Some('\\n') => false,\n                     _ => true\n                 }\n             }\n@@ -266,7 +255,7 @@ mod tests {\n                 let t = 'a';\n                 let chars = \"abcd\";\n                 match t {\n-                    '\\r' <|>if chars.clone().next().is_some() => {  },\n+                    '\\r' if chars.clone().next().is_some() => {  },\n                     _ => true\n                 }\n             }\n@@ -296,7 +285,7 @@ mod tests {\n                 let mut t = 'a';\n                 let chars = \"abcd\";\n                 match t {\n-                    '\\r' <|>if chars.clone().next().is_some() => {\n+                    '\\r' if chars.clone().next().is_some() => {\n                         t = 'e';\n                         false\n                     },"}, {"sha": "16002d2acec52b6d6e6e3b1cd119fe61f4b38d07", "filename": "crates/ra_assists/src/handlers/raw_string.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -164,7 +164,7 @@ mod test {\n             \"#,\n             r##\"\n             fn f() {\n-                let s = <|>r#\"random\n+                let s = r#\"random\n string\"#;\n             }\n             \"##,\n@@ -182,7 +182,7 @@ string\"#;\n             \"#,\n             r##\"\n             fn f() {\n-                format!(<|>r#\"x = {}\"#, 92)\n+                format!(r#\"x = {}\"#, 92)\n             }\n             \"##,\n         )\n@@ -199,7 +199,7 @@ string\"#;\n             \"###,\n             r####\"\n             fn f() {\n-                let s = <|>r#\"#random##\n+                let s = r#\"#random##\n string\"#;\n             }\n             \"####,\n@@ -217,7 +217,7 @@ string\"#;\n             \"###,\n             r####\"\n             fn f() {\n-                let s = <|>r###\"#random\"##\n+                let s = r###\"#random\"##\n string\"###;\n             }\n             \"####,\n@@ -235,7 +235,7 @@ string\"###;\n             \"#,\n             r##\"\n             fn f() {\n-                let s = <|>r#\"random string\"#;\n+                let s = r#\"random string\"#;\n             }\n             \"##,\n         )\n@@ -289,7 +289,7 @@ string\"###;\n             \"#,\n             r##\"\n             fn f() {\n-                let s = <|>r#\"random string\"#;\n+                let s = r#\"random string\"#;\n             }\n             \"##,\n         )\n@@ -306,7 +306,7 @@ string\"###;\n             \"##,\n             r###\"\n             fn f() {\n-                let s = <|>r##\"random\"string\"##;\n+                let s = r##\"random\"string\"##;\n             }\n             \"###,\n         )\n@@ -348,7 +348,7 @@ string\"###;\n             \"##,\n             r#\"\n             fn f() {\n-                let s = <|>r\"random string\";\n+                let s = r\"random string\";\n             }\n             \"#,\n         )\n@@ -365,7 +365,7 @@ string\"###;\n             \"##,\n             r#\"\n             fn f() {\n-                let s = <|>r\"random\\\"str\\\"ing\";\n+                let s = r\"random\\\"str\\\"ing\";\n             }\n             \"#,\n         )\n@@ -382,7 +382,7 @@ string\"###;\n             \"###,\n             r##\"\n             fn f() {\n-                let s = <|>r#\"random string\"#;\n+                let s = r#\"random string\"#;\n             }\n             \"##,\n         )\n@@ -436,7 +436,7 @@ string\"###;\n             \"##,\n             r#\"\n             fn f() {\n-                let s = <|>\"random string\";\n+                let s = \"random string\";\n             }\n             \"#,\n         )\n@@ -453,7 +453,7 @@ string\"###;\n             \"##,\n             r#\"\n             fn f() {\n-                let s = <|>\"random\\\"str\\\"ing\";\n+                let s = \"random\\\"str\\\"ing\";\n             }\n             \"#,\n         )\n@@ -470,7 +470,7 @@ string\"###;\n             \"###,\n             r##\"\n             fn f() {\n-                let s = <|>\"random string\";\n+                let s = \"random string\";\n             }\n             \"##,\n         )"}, {"sha": "961ee1731ad0f79106552985f59cd62e50ed60e3", "filename": "crates/ra_assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 9, "deletions": 30, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -29,26 +29,6 @@ pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n \n     let macro_range = macro_call.syntax().text_range();\n \n-    // If the cursor is inside the macro call, we'll try to maintain the cursor\n-    // position by subtracting the length of dbg!( from the start of the file\n-    // range, otherwise we'll default to using the start of the macro call\n-    let cursor_pos = {\n-        let file_range = ctx.frange.range;\n-\n-        let offset_start = file_range\n-            .start()\n-            .checked_sub(macro_range.start())\n-            .unwrap_or_else(|| TextSize::from(0));\n-\n-        let dbg_size = TextSize::of(\"dbg!(\");\n-\n-        if offset_start > dbg_size {\n-            file_range.start() - dbg_size\n-        } else {\n-            macro_range.start()\n-        }\n-    };\n-\n     let macro_content = {\n         let macro_args = macro_call.token_tree()?.syntax().clone();\n \n@@ -58,9 +38,8 @@ pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     };\n \n     let target = macro_call.syntax().text_range();\n-    acc.add(AssistId(\"remove_dbg\"), \"Remove dbg!()\", target, |edit| {\n-        edit.replace(macro_range, macro_content);\n-        edit.set_cursor(cursor_pos);\n+    acc.add(AssistId(\"remove_dbg\"), \"Remove dbg!()\", target, |builder| {\n+        builder.replace(macro_range, macro_content);\n     })\n }\n \n@@ -94,13 +73,13 @@ mod tests {\n \n     #[test]\n     fn test_remove_dbg() {\n-        check_assist(remove_dbg, \"<|>dbg!(1 + 1)\", \"<|>1 + 1\");\n+        check_assist(remove_dbg, \"<|>dbg!(1 + 1)\", \"1 + 1\");\n \n-        check_assist(remove_dbg, \"dbg!<|>((1 + 1))\", \"<|>(1 + 1)\");\n+        check_assist(remove_dbg, \"dbg!<|>((1 + 1))\", \"(1 + 1)\");\n \n-        check_assist(remove_dbg, \"dbg!(1 <|>+ 1)\", \"1 <|>+ 1\");\n+        check_assist(remove_dbg, \"dbg!(1 <|>+ 1)\", \"1 + 1\");\n \n-        check_assist(remove_dbg, \"let _ = <|>dbg!(1 + 1)\", \"let _ = <|>1 + 1\");\n+        check_assist(remove_dbg, \"let _ = <|>dbg!(1 + 1)\", \"let _ = 1 + 1\");\n \n         check_assist(\n             remove_dbg,\n@@ -113,7 +92,7 @@ fn foo(n: usize) {\n \",\n             \"\n fn foo(n: usize) {\n-    if let Some(_) = n.<|>checked_sub(4) {\n+    if let Some(_) = n.checked_sub(4) {\n         // ...\n     }\n }\n@@ -122,8 +101,8 @@ fn foo(n: usize) {\n     }\n     #[test]\n     fn test_remove_dbg_with_brackets_and_braces() {\n-        check_assist(remove_dbg, \"dbg![<|>1 + 1]\", \"<|>1 + 1\");\n-        check_assist(remove_dbg, \"dbg!{<|>1 + 1}\", \"<|>1 + 1\");\n+        check_assist(remove_dbg, \"dbg![<|>1 + 1]\", \"1 + 1\");\n+        check_assist(remove_dbg, \"dbg!{<|>1 + 1}\", \"1 + 1\");\n     }\n \n     #[test]"}, {"sha": "fe4eada0340876ef9bbc9d5fd2bae8bf1ec99538", "filename": "crates/ra_assists/src/handlers/remove_mut.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -26,8 +26,7 @@ pub(crate) fn remove_mut(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     };\n \n     let target = mut_token.text_range();\n-    acc.add(AssistId(\"remove_mut\"), \"Remove `mut` keyword\", target, |edit| {\n-        edit.set_cursor(delete_from);\n-        edit.delete(TextRange::new(delete_from, delete_to));\n+    acc.add(AssistId(\"remove_mut\"), \"Remove `mut` keyword\", target, |builder| {\n+        builder.delete(TextRange::new(delete_from, delete_to));\n     })\n }"}, {"sha": "30229edc2f24a7091436dc47afd7308e0294d720", "filename": "crates/ra_assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -140,7 +140,7 @@ mod tests {\n         \"#,\n             r#\"\n         struct Foo {foo: i32, bar: i32};\n-        const test: Foo = <|>Foo {foo: 1, bar: 0}\n+        const test: Foo = Foo {foo: 1, bar: 0}\n         \"#,\n         )\n     }\n@@ -164,7 +164,7 @@ mod tests {\n \n         fn f(f: Foo) -> {\n             match f {\n-                <|>Foo { ref mut bar, baz: 0, .. } => (),\n+                Foo { ref mut bar, baz: 0, .. } => (),\n                 _ => ()\n             }\n         }\n@@ -202,7 +202,7 @@ mod tests {\n             impl Foo {\n                 fn new() -> Foo {\n                     let foo = String::new();\n-                    <|>Foo {\n+                    Foo {\n                         foo,\n                         bar: foo.clone(),\n                         extra: \"Extra field\","}, {"sha": "e016f51c3eb490883dfe4a5563b525e17134f2cf", "filename": "crates/ra_assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -68,7 +68,6 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext)\n                 .indent(IndentLevel::from_node(if_expr.syntax()))\n         };\n \n-        edit.set_cursor(if_expr.syntax().text_range().start());\n         edit.replace_ast::<ast::Expr>(if_expr.into(), match_expr);\n     })\n }\n@@ -83,7 +82,7 @@ mod tests {\n     fn test_replace_if_let_with_match_unwraps_simple_expressions() {\n         check_assist(\n             replace_if_let_with_match,\n-            \"\n+            r#\"\n impl VariantData {\n     pub fn is_struct(&self) -> bool {\n         if <|>let VariantData::Struct(..) = *self {\n@@ -92,24 +91,24 @@ impl VariantData {\n             false\n         }\n     }\n-}           \",\n-            \"\n+}           \"#,\n+            r#\"\n impl VariantData {\n     pub fn is_struct(&self) -> bool {\n-        <|>match *self {\n+        match *self {\n             VariantData::Struct(..) => true,\n             _ => false,\n         }\n     }\n-}           \",\n+}           \"#,\n         )\n     }\n \n     #[test]\n     fn test_replace_if_let_with_match_doesnt_unwrap_multiline_expressions() {\n         check_assist(\n             replace_if_let_with_match,\n-            \"\n+            r#\"\n fn foo() {\n     if <|>let VariantData::Struct(..) = a {\n         bar(\n@@ -118,26 +117,26 @@ fn foo() {\n     } else {\n         false\n     }\n-}           \",\n-            \"\n+}           \"#,\n+            r#\"\n fn foo() {\n-    <|>match a {\n+    match a {\n         VariantData::Struct(..) => {\n             bar(\n                 123\n             )\n         }\n         _ => false,\n     }\n-}           \",\n+}           \"#,\n         )\n     }\n \n     #[test]\n     fn replace_if_let_with_match_target() {\n         check_assist_target(\n             replace_if_let_with_match,\n-            \"\n+            r#\"\n impl VariantData {\n     pub fn is_struct(&self) -> bool {\n         if <|>let VariantData::Struct(..) = *self {\n@@ -146,7 +145,7 @@ impl VariantData {\n             false\n         }\n     }\n-}           \",\n+}           \"#,\n             \"if let VariantData::Struct(..) = *self {\n             true\n         } else {\n@@ -176,7 +175,7 @@ enum Option<T> { Some(T), None }\n use Option::*;\n \n fn foo(x: Option<i32>) {\n-    <|>match x {\n+    match x {\n         Some(x) => println!(\"{}\", x),\n         None => println!(\"none\"),\n     }\n@@ -206,7 +205,7 @@ enum Result<T, E> { Ok(T), Err(E) }\n use Result::*;\n \n fn foo(x: Result<i32, ()>) {\n-    <|>match x {\n+    match x {\n         Ok(x) => println!(\"{}\", x),\n         Err(_) => println!(\"none\"),\n     }"}, {"sha": "761557ac05c8c5813b323c7b3bc193ae437c0571", "filename": "crates/ra_assists/src/handlers/replace_let_with_if_let.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -58,12 +58,9 @@ pub(crate) fn replace_let_with_if_let(acc: &mut Assists, ctx: &AssistContext) ->\n         let stmt = make::expr_stmt(if_);\n \n         let placeholder = stmt.syntax().descendants().find_map(ast::PlaceholderPat::cast).unwrap();\n-        let target_offset =\n-            let_stmt.syntax().text_range().start() + placeholder.syntax().text_range().start();\n         let stmt = stmt.replace_descendant(placeholder.into(), original_pat);\n \n         edit.replace_ast(ast::Stmt::from(let_stmt), ast::Stmt::from(stmt));\n-        edit.set_cursor(target_offset);\n     })\n }\n \n@@ -88,7 +85,7 @@ fn main() {\n enum E<T> { X(T), Y(T) }\n \n fn main() {\n-    if let <|>x = E::X(92) {\n+    if let x = E::X(92) {\n     }\n }\n             \","}, {"sha": "0197a8cf06788f01f321fd31fdacf9790e4fcf77", "filename": "crates/ra_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -39,7 +39,7 @@ pub(crate) fn replace_qualified_name_with_use(\n         target,\n         |builder| {\n             let path_to_import = hir_path.mod_path().clone();\n-            insert_use_statement(path.syntax(), &path_to_import, ctx, builder);\n+            insert_use_statement(path.syntax(), &path_to_import, ctx, builder.text_edit_builder());\n \n             if let Some(last) = path.segment() {\n                 // Here we are assuming the assist will provide a correct use statement\n@@ -89,7 +89,7 @@ std::fmt::Debug<|>\n             \"\n use std::fmt::Debug;\n \n-Debug<|>\n+Debug\n     \",\n         );\n     }\n@@ -106,7 +106,7 @@ fn main() {\n             \"\n use std::fmt::Debug;\n \n-Debug<|>\n+Debug\n \n fn main() {\n }\n@@ -130,7 +130,7 @@ use std::fmt::Debug;\n fn main() {\n }\n \n-Debug<|>\n+Debug\n     \",\n         );\n     }\n@@ -145,7 +145,7 @@ std::fmt<|>::Debug\n             \"\n use std::fmt;\n \n-fmt<|>::Debug\n+fmt::Debug\n     \",\n         );\n     }\n@@ -164,7 +164,7 @@ impl std::fmt::Debug<|> for Foo {\n use stdx;\n use std::fmt::Debug;\n \n-impl Debug<|> for Foo {\n+impl Debug for Foo {\n }\n     \",\n         );\n@@ -181,7 +181,7 @@ impl std::fmt::Debug<|> for Foo {\n             \"\n use std::fmt::Debug;\n \n-impl Debug<|> for Foo {\n+impl Debug for Foo {\n }\n     \",\n         );\n@@ -198,7 +198,7 @@ impl Debug<|> for Foo {\n             \"\n     use std::fmt::Debug;\n \n-    impl Debug<|> for Foo {\n+    impl Debug for Foo {\n     }\n     \",\n         );\n@@ -217,7 +217,7 @@ impl std::io<|> for Foo {\n             \"\n use std::{io, fmt};\n \n-impl io<|> for Foo {\n+impl io for Foo {\n }\n     \",\n         );\n@@ -236,7 +236,7 @@ impl std::fmt::Debug<|> for Foo {\n             \"\n use std::fmt::{self, Debug, };\n \n-impl Debug<|> for Foo {\n+impl Debug for Foo {\n }\n     \",\n         );\n@@ -255,7 +255,7 @@ impl std::fmt<|> for Foo {\n             \"\n use std::fmt::{self, Debug};\n \n-impl fmt<|> for Foo {\n+impl fmt for Foo {\n }\n     \",\n         );\n@@ -274,7 +274,7 @@ impl std::fmt::nested<|> for Foo {\n             \"\n use std::fmt::{Debug, nested::{Display, self}};\n \n-impl nested<|> for Foo {\n+impl nested for Foo {\n }\n \",\n         );\n@@ -293,7 +293,7 @@ impl std::fmt::nested<|> for Foo {\n             \"\n use std::fmt::{Debug, nested::{self, Display}};\n \n-impl nested<|> for Foo {\n+impl nested for Foo {\n }\n \",\n         );\n@@ -312,7 +312,7 @@ impl std::fmt::nested::Debug<|> for Foo {\n             \"\n use std::fmt::{Debug, nested::{Display, Debug}};\n \n-impl Debug<|> for Foo {\n+impl Debug for Foo {\n }\n \",\n         );\n@@ -331,7 +331,7 @@ impl std::fmt::nested::Display<|> for Foo {\n             \"\n use std::fmt::{nested::Display, Debug};\n \n-impl Display<|> for Foo {\n+impl Display for Foo {\n }\n \",\n         );\n@@ -350,7 +350,7 @@ impl std::fmt::Display<|> for Foo {\n             \"\n use std::fmt::{Display, nested::Debug};\n \n-impl Display<|> for Foo {\n+impl Display for Foo {\n }\n \",\n         );\n@@ -374,7 +374,7 @@ use crate::{\n     AssocItem,\n };\n \n-fn foo() { lower<|>::trait_env() }\n+fn foo() { lower::trait_env() }\n \",\n         );\n     }\n@@ -392,7 +392,7 @@ impl foo::Debug<|> for Foo {\n             \"\n use std::fmt as foo;\n \n-impl Debug<|> for Foo {\n+impl Debug for Foo {\n }\n \",\n         );\n@@ -435,7 +435,7 @@ mod foo {\n     mod bar {\n         use std::fmt::Debug;\n \n-        Debug<|>\n+        Debug\n     }\n }\n     \",\n@@ -458,7 +458,7 @@ fn main() {\n use std::fmt::Debug;\n \n fn main() {\n-    Debug<|>\n+    Debug\n }\n     \",\n         );"}, {"sha": "cff7dfb81215a29415cbc1e6b575a93b29c04b0f", "filename": "crates/ra_assists/src/handlers/replace_unwrap_with_match.rs", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -9,7 +9,10 @@ use ra_syntax::{\n     AstNode,\n };\n \n-use crate::{utils::TryEnum, AssistContext, AssistId, Assists};\n+use crate::{\n+    utils::{render_snippet, Cursor, TryEnum},\n+    AssistContext, AssistId, Assists,\n+};\n \n // Assist: replace_unwrap_with_match\n //\n@@ -29,7 +32,7 @@ use crate::{utils::TryEnum, AssistContext, AssistId, Assists};\n //     let x: Result<i32, i32> = Result::Ok(92);\n //     let y = match x {\n //         Ok(a) => a,\n-//         _ => unreachable!(),\n+//         $0_ => unreachable!(),\n //     };\n // }\n // ```\n@@ -43,31 +46,45 @@ pub(crate) fn replace_unwrap_with_match(acc: &mut Assists, ctx: &AssistContext)\n     let ty = ctx.sema.type_of_expr(&caller)?;\n     let happy_variant = TryEnum::from_ty(&ctx.sema, &ty)?.happy_case();\n     let target = method_call.syntax().text_range();\n-    acc.add(AssistId(\"replace_unwrap_with_match\"), \"Replace unwrap with match\", target, |edit| {\n+    acc.add(AssistId(\"replace_unwrap_with_match\"), \"Replace unwrap with match\", target, |builder| {\n         let ok_path = make::path_unqualified(make::path_segment(make::name_ref(happy_variant)));\n         let it = make::bind_pat(make::name(\"a\")).into();\n         let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n \n         let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n         let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n \n-        let unreachable_call = make::unreachable_macro_call().into();\n+        let unreachable_call = make::expr_unreachable();\n         let err_arm = make::match_arm(iter::once(make::placeholder_pat().into()), unreachable_call);\n \n         let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n         let match_expr = make::expr_match(caller.clone(), match_arm_list)\n             .indent(IndentLevel::from_node(method_call.syntax()));\n \n-        edit.set_cursor(caller.syntax().text_range().start());\n-        edit.replace_ast::<ast::Expr>(method_call.into(), match_expr);\n+        let range = method_call.syntax().text_range();\n+        match ctx.config.snippet_cap {\n+            Some(cap) => {\n+                let err_arm = match_expr\n+                    .syntax()\n+                    .descendants()\n+                    .filter_map(ast::MatchArm::cast)\n+                    .last()\n+                    .unwrap();\n+                let snippet =\n+                    render_snippet(cap, match_expr.syntax(), Cursor::Before(err_arm.syntax()));\n+                builder.replace_snippet(cap, range, snippet)\n+            }\n+            None => builder.replace(range, match_expr.to_string()),\n+        }\n     })\n }\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n     use crate::tests::{check_assist, check_assist_target};\n \n+    use super::*;\n+\n     #[test]\n     fn test_replace_result_unwrap_with_match() {\n         check_assist(\n@@ -85,9 +102,9 @@ enum Result<T, E> { Ok(T), Err(E) }\n fn i<T>(a: T) -> T { a }\n fn main() {\n     let x: Result<i32, i32> = Result::Ok(92);\n-    let y = <|>match i(x) {\n+    let y = match i(x) {\n         Ok(a) => a,\n-        _ => unreachable!(),\n+        $0_ => unreachable!(),\n     };\n }\n             \",\n@@ -111,9 +128,9 @@ enum Option<T> { Some(T), None }\n fn i<T>(a: T) -> T { a }\n fn main() {\n     let x = Option::Some(92);\n-    let y = <|>match i(x) {\n+    let y = match i(x) {\n         Some(a) => a,\n-        _ => unreachable!(),\n+        $0_ => unreachable!(),\n     };\n }\n             \",\n@@ -137,9 +154,9 @@ enum Result<T, E> { Ok(T), Err(E) }\n fn i<T>(a: T) -> T { a }\n fn main() {\n     let x: Result<i32, i32> = Result::Ok(92);\n-    let y = <|>match i(x) {\n+    let y = match i(x) {\n         Ok(a) => a,\n-        _ => unreachable!(),\n+        $0_ => unreachable!(),\n     }.count_zeroes();\n }\n             \","}, {"sha": "c7a8744802dccb6ac7ad1b055dc4c6626f2b15f3", "filename": "crates/ra_assists/src/handlers/split_import.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -26,12 +26,10 @@ pub(crate) fn split_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     if new_tree == use_tree {\n         return None;\n     }\n-    let cursor = ctx.offset();\n \n     let target = colon_colon.text_range();\n     acc.add(AssistId(\"split_import\"), \"Split import\", target, |edit| {\n         edit.replace_ast(use_tree, new_tree);\n-        edit.set_cursor(cursor);\n     })\n }\n \n@@ -46,7 +44,7 @@ mod tests {\n         check_assist(\n             split_import,\n             \"use crate::<|>db::RootDatabase;\",\n-            \"use crate::<|>{db::RootDatabase};\",\n+            \"use crate::{db::RootDatabase};\",\n         )\n     }\n \n@@ -55,7 +53,7 @@ mod tests {\n         check_assist(\n             split_import,\n             \"use crate:<|>:db::{RootDatabase, FileSymbol}\",\n-            \"use crate:<|>:{db::{RootDatabase, FileSymbol}}\",\n+            \"use crate::{db::{RootDatabase, FileSymbol}}\",\n         )\n     }\n "}, {"sha": "8440c7d0f43e37e98fa4b4fa1f1716740c17f992", "filename": "crates/ra_assists/src/handlers/unwrap_block.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,8 +1,10 @@\n-use crate::{AssistContext, AssistId, Assists};\n-\n-use ast::{ElseBranch, Expr, LoopBodyOwner};\n use ra_fmt::unwrap_trivial_block;\n-use ra_syntax::{ast, match_ast, AstNode, TextRange, T};\n+use ra_syntax::{\n+    ast::{self, ElseBranch, Expr, LoopBodyOwner},\n+    match_ast, AstNode, TextRange, T,\n+};\n+\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: unwrap_block\n //\n@@ -60,7 +62,6 @@ pub(crate) fn unwrap_block(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n                             let range_to_del_else_if = TextRange::new(ancestor_then_branch.syntax().text_range().end(), l_curly_token.text_range().start());\n                             let range_to_del_rest = TextRange::new(then_branch.syntax().text_range().end(), if_expr.syntax().text_range().end());\n \n-                            edit.set_cursor(ancestor_then_branch.syntax().text_range().end());\n                             edit.delete(range_to_del_rest);\n                             edit.delete(range_to_del_else_if);\n                             edit.replace(target, update_expr_string(then_branch.to_string(), &[' ', '{']));\n@@ -77,7 +78,6 @@ pub(crate) fn unwrap_block(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n                                 return acc.add(assist_id, assist_label, target, |edit| {\n                                     let range_to_del = TextRange::new(then_branch.syntax().text_range().end(), l_curly_token.text_range().start());\n \n-                                    edit.set_cursor(then_branch.syntax().text_range().end());\n                                     edit.delete(range_to_del);\n                                     edit.replace(target, update_expr_string(else_block.to_string(), &[' ', '{']));\n                                 });\n@@ -95,8 +95,6 @@ pub(crate) fn unwrap_block(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n     let target = expr_to_unwrap.syntax().text_range();\n     acc.add(assist_id, assist_label, target, |edit| {\n-        edit.set_cursor(expr.syntax().text_range().start());\n-\n         edit.replace(\n             expr.syntax().text_range(),\n             update_expr_string(expr_to_unwrap.to_string(), &[' ', '{', '\\n']),\n@@ -152,7 +150,7 @@ mod tests {\n             r#\"\n             fn main() {\n                 bar();\n-                <|>foo();\n+                foo();\n \n                 //comment\n                 bar();\n@@ -186,7 +184,7 @@ mod tests {\n \n                     //comment\n                     bar();\n-                }<|>\n+                }\n                 println!(\"bar\");\n             }\n             \"#,\n@@ -220,7 +218,7 @@ mod tests {\n \n                     //comment\n                     //bar();\n-                }<|>\n+                }\n                 println!(\"bar\");\n             }\n             \"#,\n@@ -256,7 +254,7 @@ mod tests {\n                     //bar();\n                 } else if false {\n                     println!(\"bar\");\n-                }<|>\n+                }\n                 println!(\"foo\");\n             }\n             \"#,\n@@ -296,7 +294,7 @@ mod tests {\n                     println!(\"bar\");\n                 } else if true {\n                     println!(\"foo\");\n-                }<|>\n+                }\n                 println!(\"else\");\n             }\n             \"#,\n@@ -334,7 +332,7 @@ mod tests {\n                     //bar();\n                 } else if false {\n                     println!(\"bar\");\n-                }<|>\n+                }\n                 println!(\"foo\");\n             }\n             \"#,\n@@ -381,7 +379,7 @@ mod tests {\n             \"#,\n             r#\"\n             fn main() {\n-                <|>if true {\n+                if true {\n                     foo();\n \n                     //comment\n@@ -415,7 +413,7 @@ mod tests {\n             r#\"\n             fn main() {\n                 for i in 0..5 {\n-                    <|>foo();\n+                    foo();\n \n                     //comment\n                     bar();\n@@ -445,7 +443,7 @@ mod tests {\n             \"#,\n             r#\"\n             fn main() {\n-                <|>if true {\n+                if true {\n                     foo();\n \n                     //comment\n@@ -478,7 +476,7 @@ mod tests {\n             \"#,\n             r#\"\n             fn main() {\n-                <|>if true {\n+                if true {\n                     foo();\n \n                     //comment"}, {"sha": "464bc03dde9e77e0ca2359786424da8014f39675", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -10,8 +10,8 @@ macro_rules! eprintln {\n     ($($tt:tt)*) => { stdx::eprintln!($($tt)*) };\n }\n \n+mod assist_config;\n mod assist_context;\n-mod marks;\n #[cfg(test)]\n mod tests;\n pub mod utils;\n@@ -24,6 +24,8 @@ use ra_syntax::TextRange;\n \n pub(crate) use crate::assist_context::{AssistContext, Assists};\n \n+pub use assist_config::AssistConfig;\n+\n /// Unique identifier of the assist, should not be shown to the user\n /// directly.\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n@@ -54,9 +56,9 @@ impl Assist {\n     ///\n     /// Assists are returned in the \"unresolved\" state, that is only labels are\n     /// returned, without actual edits.\n-    pub fn unresolved(db: &RootDatabase, range: FileRange) -> Vec<Assist> {\n+    pub fn unresolved(db: &RootDatabase, config: &AssistConfig, range: FileRange) -> Vec<Assist> {\n         let sema = Semantics::new(db);\n-        let ctx = AssistContext::new(sema, range);\n+        let ctx = AssistContext::new(sema, config, range);\n         let mut acc = Assists::new_unresolved(&ctx);\n         handlers::all().iter().for_each(|handler| {\n             handler(&mut acc, &ctx);\n@@ -68,9 +70,13 @@ impl Assist {\n     ///\n     /// Assists are returned in the \"resolved\" state, that is with edit fully\n     /// computed.\n-    pub fn resolved(db: &RootDatabase, range: FileRange) -> Vec<ResolvedAssist> {\n+    pub fn resolved(\n+        db: &RootDatabase,\n+        config: &AssistConfig,\n+        range: FileRange,\n+    ) -> Vec<ResolvedAssist> {\n         let sema = Semantics::new(db);\n-        let ctx = AssistContext::new(sema, range);\n+        let ctx = AssistContext::new(sema, config, range);\n         let mut acc = Assists::new_resolved(&ctx);\n         handlers::all().iter().for_each(|handler| {\n             handler(&mut acc, &ctx);\n@@ -103,12 +109,14 @@ mod handlers {\n     mod add_impl;\n     mod add_missing_impl_members;\n     mod add_new;\n+    mod add_turbo_fish;\n     mod apply_demorgan;\n     mod auto_import;\n     mod change_return_type_to_result;\n     mod change_visibility;\n     mod early_return;\n     mod fill_match_arms;\n+    mod fix_visibility;\n     mod flip_binexpr;\n     mod flip_comma;\n     mod flip_trait_bound;\n@@ -140,12 +148,14 @@ mod handlers {\n             add_function::add_function,\n             add_impl::add_impl,\n             add_new::add_new,\n+            add_turbo_fish::add_turbo_fish,\n             apply_demorgan::apply_demorgan,\n             auto_import::auto_import,\n             change_return_type_to_result::change_return_type_to_result,\n             change_visibility::change_visibility,\n             early_return::convert_to_guarded_return,\n             fill_match_arms::fill_match_arms,\n+            fix_visibility::fix_visibility,\n             flip_binexpr::flip_binexpr,\n             flip_comma::flip_comma,\n             flip_trait_bound::flip_trait_bound,"}, {"sha": "8d910205f0ab332d9fecc40cc94909e3c242abee", "filename": "crates/ra_assists/src/marks.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6143742bd4e625d391ac3ea860be7578ab9f53f/crates%2Fra_assists%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6143742bd4e625d391ac3ea860be7578ab9f53f/crates%2Fra_assists%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fmarks.rs?ref=c6143742bd4e625d391ac3ea860be7578ab9f53f", "patch": "@@ -1,12 +0,0 @@\n-//! See test_utils/src/marks.rs\n-\n-test_utils::marks![\n-    introduce_var_in_comment_is_not_applicable\n-    test_introduce_var_expr_stmt\n-    test_introduce_var_last_expr\n-    not_applicable_outside_of_bind_pat\n-    test_not_inline_mut_variable\n-    test_not_applicable_if_variable_unused\n-    change_visibility_field_false_positive\n-    test_add_from_impl_already_exists\n-];"}, {"sha": "373a7f7cc121fa052547396f9314b17cbedf083e", "filename": "crates/ra_assists/src/tests.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -11,7 +11,7 @@ use test_utils::{\n     RangeOrOffset,\n };\n \n-use crate::{handlers::Handler, Assist, AssistContext, Assists};\n+use crate::{handlers::Handler, Assist, AssistConfig, AssistContext, Assists};\n \n pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {\n     let (mut db, file_id) = RootDatabase::with_single_file(text);\n@@ -41,14 +41,14 @@ fn check_doc_test(assist_id: &str, before: &str, after: &str) {\n     let (db, file_id) = crate::tests::with_single_file(&before);\n     let frange = FileRange { file_id, range: selection.into() };\n \n-    let mut assist = Assist::resolved(&db, frange)\n+    let mut assist = Assist::resolved(&db, &AssistConfig::default(), frange)\n         .into_iter()\n         .find(|assist| assist.assist.id.0 == assist_id)\n         .unwrap_or_else(|| {\n             panic!(\n                 \"\\n\\nAssist is not applicable: {}\\nAvailable assists: {}\",\n                 assist_id,\n-                Assist::resolved(&db, frange)\n+                Assist::resolved(&db, &AssistConfig::default(), frange)\n                     .into_iter()\n                     .map(|assist| assist.assist.id.0)\n                     .collect::<Vec<_>>()\n@@ -90,7 +90,8 @@ fn check(handler: Handler, before: &str, expected: ExpectedResult) {\n     let frange = FileRange { file_id: file_with_caret_id, range: range_or_offset.into() };\n \n     let sema = Semantics::new(&db);\n-    let ctx = AssistContext::new(sema, frange);\n+    let config = AssistConfig::default();\n+    let ctx = AssistContext::new(sema, &config, frange);\n     let mut acc = Assists::new_resolved(&ctx);\n     handler(&mut acc, &ctx);\n     let mut res = acc.finish_resolved();\n@@ -103,19 +104,11 @@ fn check(handler: Handler, before: &str, expected: ExpectedResult) {\n             let mut actual = db.file_text(change.file_id).as_ref().to_owned();\n             change.edit.apply(&mut actual);\n \n-            match source_change.cursor_position {\n-                None => {\n-                    if let RangeOrOffset::Offset(before_cursor_pos) = range_or_offset {\n-                        let off = change\n-                            .edit\n-                            .apply_to_offset(before_cursor_pos)\n-                            .expect(\"cursor position is affected by the edit\");\n-                        actual = add_cursor(&actual, off)\n-                    }\n+            if !source_change.is_snippet {\n+                if let Some(off) = source_change.cursor_position {\n+                    actual = add_cursor(&actual, off.offset)\n                 }\n-                Some(off) => actual = add_cursor(&actual, off.offset),\n-            };\n-\n+            }\n             assert_eq_text!(after, &actual);\n         }\n         (Some(assist), ExpectedResult::Target(target)) => {\n@@ -136,7 +129,7 @@ fn assist_order_field_struct() {\n     let (before_cursor_pos, before) = extract_offset(before);\n     let (db, file_id) = with_single_file(&before);\n     let frange = FileRange { file_id, range: TextRange::empty(before_cursor_pos) };\n-    let assists = Assist::resolved(&db, frange);\n+    let assists = Assist::resolved(&db, &AssistConfig::default(), frange);\n     let mut assists = assists.iter();\n \n     assert_eq!(\n@@ -159,7 +152,7 @@ fn assist_order_if_expr() {\n     let (range, before) = extract_range(before);\n     let (db, file_id) = with_single_file(&before);\n     let frange = FileRange { file_id, range };\n-    let assists = Assist::resolved(&db, frange);\n+    let assists = Assist::resolved(&db, &AssistConfig::default(), frange);\n     let mut assists = assists.iter();\n \n     assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Extract into variable\");"}, {"sha": "250e56a6962468193c3abe38681e596f1dd6b3a3", "filename": "crates/ra_assists/src/tests/generated.rs", "status": "modified", "additions": 55, "deletions": 13, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -15,7 +15,7 @@ struct S;\n struct S;\n \n impl Debug for S {\n-\n+    $0\n }\n \"#####,\n     )\n@@ -32,7 +32,7 @@ struct Point {\n }\n \"#####,\n         r#####\"\n-#[derive()]\n+#[derive($0)]\n struct Point {\n     x: u32,\n     y: u32,\n@@ -78,7 +78,7 @@ fn foo() {\n }\n \n fn bar(arg: &str, baz: Baz) {\n-    todo!()\n+    ${0:todo!()}\n }\n \n \"#####,\n@@ -108,16 +108,16 @@ fn doctest_add_impl() {\n         \"add_impl\",\n         r#####\"\n struct Ctx<T: Clone> {\n-     data: T,<|>\n+    data: T,<|>\n }\n \"#####,\n         r#####\"\n struct Ctx<T: Clone> {\n-     data: T,\n+    data: T,\n }\n \n impl<T: Clone> Ctx<T> {\n-\n+    $0\n }\n \"#####,\n     )\n@@ -150,7 +150,7 @@ trait Trait {\n impl Trait for () {\n     Type X = ();\n     fn foo(&self) {}\n-    fn bar(&self) {}\n+    $0fn bar(&self) {}\n \n }\n \"#####,\n@@ -181,7 +181,7 @@ trait Trait<T> {\n \n impl Trait<u32> for () {\n     fn foo(&self) -> u32 {\n-        todo!()\n+        ${0:todo!()}\n     }\n \n }\n@@ -204,13 +204,32 @@ struct Ctx<T: Clone> {\n }\n \n impl<T: Clone> Ctx<T> {\n-    fn new(data: T) -> Self { Self { data } }\n+    fn $0new(data: T) -> Self { Self { data } }\n }\n \n \"#####,\n     )\n }\n \n+#[test]\n+fn doctest_add_turbo_fish() {\n+    check_doc_test(\n+        \"add_turbo_fish\",\n+        r#####\"\n+fn make<T>() -> T { todo!() }\n+fn main() {\n+    let x = make<|>();\n+}\n+\"#####,\n+        r#####\"\n+fn make<T>() -> T { todo!() }\n+fn main() {\n+    let x = make::<${0:_}>();\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_apply_demorgan() {\n     check_doc_test(\n@@ -257,7 +276,7 @@ fn doctest_change_return_type_to_result() {\n fn foo() -> i32<|> { 42i32 }\n \"#####,\n         r#####\"\n-fn foo() -> Result<i32, > { Ok(42i32) }\n+fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n \"#####,\n     )\n }\n@@ -317,14 +336,37 @@ enum Action { Move { distance: u32 }, Stop }\n \n fn handle(action: Action) {\n     match action {\n-        Action::Move { distance } => {}\n+        $0Action::Move { distance } => {}\n         Action::Stop => {}\n     }\n }\n \"#####,\n     )\n }\n \n+#[test]\n+fn doctest_fix_visibility() {\n+    check_doc_test(\n+        \"fix_visibility\",\n+        r#####\"\n+mod m {\n+    fn frobnicate() {}\n+}\n+fn main() {\n+    m::frobnicate<|>() {}\n+}\n+\"#####,\n+        r#####\"\n+mod m {\n+    $0pub(crate) fn frobnicate() {}\n+}\n+fn main() {\n+    m::frobnicate() {}\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_flip_binexpr() {\n     check_doc_test(\n@@ -401,7 +443,7 @@ fn main() {\n \"#####,\n         r#####\"\n fn main() {\n-    let var_name = (1 + 2);\n+    let $0var_name = (1 + 2);\n     var_name * 4;\n }\n \"#####,\n@@ -722,7 +764,7 @@ fn main() {\n     let x: Result<i32, i32> = Result::Ok(92);\n     let y = match x {\n         Ok(a) => a,\n-        _ => unreachable!(),\n+        $0_ => unreachable!(),\n     };\n }\n \"#####,"}, {"sha": "0038a9764b15da65f5a82c61404afd9f66c2b871", "filename": "crates/ra_assists/src/utils.rs", "status": "modified", "additions": 69, "deletions": 9, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,18 +1,57 @@\n //! Assorted functions shared by several assists.\n pub(crate) mod insert_use;\n \n-use std::iter;\n+use std::{iter, ops};\n \n-use hir::{Adt, Crate, Semantics, Trait, Type};\n+use hir::{Adt, Crate, Enum, ScopeDef, Semantics, Trait, Type};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     ast::{self, make, NameOwner},\n-    AstNode, T,\n+    AstNode, SyntaxNode, T,\n };\n use rustc_hash::FxHashSet;\n \n+use crate::assist_config::SnippetCap;\n+\n pub(crate) use insert_use::insert_use_statement;\n \n+#[derive(Clone, Copy, Debug)]\n+pub(crate) enum Cursor<'a> {\n+    Replace(&'a SyntaxNode),\n+    Before(&'a SyntaxNode),\n+}\n+\n+impl<'a> Cursor<'a> {\n+    fn node(self) -> &'a SyntaxNode {\n+        match self {\n+            Cursor::Replace(node) | Cursor::Before(node) => node,\n+        }\n+    }\n+}\n+\n+pub(crate) fn render_snippet(_cap: SnippetCap, node: &SyntaxNode, cursor: Cursor) -> String {\n+    assert!(cursor.node().ancestors().any(|it| it == *node));\n+    let range = cursor.node().text_range() - node.text_range().start();\n+    let range: ops::Range<usize> = range.into();\n+\n+    let mut placeholder = cursor.node().to_string();\n+    escape(&mut placeholder);\n+    let tab_stop = match cursor {\n+        Cursor::Replace(placeholder) => format!(\"${{0:{}}}\", placeholder),\n+        Cursor::Before(placeholder) => format!(\"$0{}\", placeholder),\n+    };\n+\n+    let mut buf = node.to_string();\n+    buf.replace_range(range, &tab_stop);\n+    return buf;\n+\n+    fn escape(buf: &mut String) {\n+        stdx::replace(buf, '{', r\"\\{\");\n+        stdx::replace(buf, '}', r\"\\}\");\n+        stdx::replace(buf, '$', r\"\\$\");\n+    }\n+}\n+\n pub fn get_missing_assoc_items(\n     sema: &Semantics<RootDatabase>,\n     impl_def: &ast::ImplDef,\n@@ -161,13 +200,19 @@ impl FamousDefs<'_, '_> {\n     #[cfg(test)]\n     pub(crate) const FIXTURE: &'static str = r#\"\n //- /libcore.rs crate:core\n-pub mod convert{\n+pub mod convert {\n     pub trait From<T> {\n         fn from(T) -> Self;\n     }\n }\n \n-pub mod prelude { pub use crate::convert::From }\n+pub mod option {\n+    pub enum Option<T> { None, Some(T)}\n+}\n+\n+pub mod prelude {\n+    pub use crate::{convert::From, option::Option::{self, *}};\n+}\n #[prelude_import]\n pub use prelude::*;\n \"#;\n@@ -176,7 +221,25 @@ pub use prelude::*;\n         self.find_trait(\"core:convert:From\")\n     }\n \n+    pub(crate) fn core_option_Option(&self) -> Option<Enum> {\n+        self.find_enum(\"core:option:Option\")\n+    }\n+\n     fn find_trait(&self, path: &str) -> Option<Trait> {\n+        match self.find_def(path)? {\n+            hir::ScopeDef::ModuleDef(hir::ModuleDef::Trait(it)) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    fn find_enum(&self, path: &str) -> Option<Enum> {\n+        match self.find_def(path)? {\n+            hir::ScopeDef::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(it))) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    fn find_def(&self, path: &str) -> Option<ScopeDef> {\n         let db = self.0.db;\n         let mut path = path.split(':');\n         let trait_ = path.next_back()?;\n@@ -201,9 +264,6 @@ pub use prelude::*;\n         }\n         let def =\n             module.scope(db, None).into_iter().find(|(name, _def)| &name.to_string() == trait_)?.1;\n-        match def {\n-            hir::ScopeDef::ModuleDef(hir::ModuleDef::Trait(it)) => Some(it),\n-            _ => None,\n-        }\n+        Some(def)\n     }\n }"}, {"sha": "0ee43482f79856a7a1f7fa963d6e89cdd3d6ac39", "filename": "crates/ra_assists/src/utils/insert_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n };\n use ra_text_edit::TextEditBuilder;\n \n-use crate::assist_context::{AssistBuilder, AssistContext};\n+use crate::assist_context::AssistContext;\n \n /// Creates and inserts a use statement for the given path to import.\n /// The use statement is inserted in the scope most appropriate to the\n@@ -21,7 +21,7 @@ pub(crate) fn insert_use_statement(\n     position: &SyntaxNode,\n     path_to_import: &ModPath,\n     ctx: &AssistContext,\n-    builder: &mut AssistBuilder,\n+    builder: &mut TextEditBuilder,\n ) {\n     let target = path_to_import.to_string().split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n     let container = ctx.sema.ancestors_with_macros(position.clone()).find_map(|n| {\n@@ -33,7 +33,7 @@ pub(crate) fn insert_use_statement(\n \n     if let Some(container) = container {\n         let action = best_action_for_target(container, position.clone(), &target);\n-        make_assist(&action, &target, builder.text_edit_builder());\n+        make_assist(&action, &target, builder);\n     }\n }\n "}, {"sha": "e08d62dd6869d66703312cb1b98adf478dd47b96", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -15,7 +15,7 @@ use ra_syntax::{\n     },\n     AstNode, AstPtr,\n };\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{\n     adt::StructKind,\n@@ -60,13 +60,10 @@ pub(super) fn lower(\n     params: Option<ast::ParamList>,\n     body: Option<ast::Expr>,\n ) -> (Body, BodySourceMap) {\n-    let ctx = LowerCtx::new(db, expander.current_file_id.clone());\n-\n     ExprCollector {\n         db,\n         def,\n         expander,\n-        ctx,\n         source_map: BodySourceMap::default(),\n         body: Body {\n             exprs: Arena::default(),\n@@ -83,7 +80,6 @@ struct ExprCollector<'a> {\n     db: &'a dyn DefDatabase,\n     def: DefWithBodyId,\n     expander: Expander,\n-    ctx: LowerCtx,\n     body: Body,\n     source_map: BodySourceMap,\n }\n@@ -122,6 +118,10 @@ impl ExprCollector<'_> {\n         (self.body, self.source_map)\n     }\n \n+    fn ctx(&self) -> LowerCtx {\n+        LowerCtx::new(self.db, self.expander.current_file_id)\n+    }\n+\n     fn alloc_expr(&mut self, expr: Expr, ptr: AstPtr<ast::Expr>) -> ExprId {\n         let src = self.expander.to_source(ptr);\n         let id = self.make_expr(expr, Ok(src.clone()));\n@@ -226,7 +226,7 @@ impl ExprCollector<'_> {\n                         None => self.collect_expr_opt(condition.expr()),\n                         // if let -- desugar to match\n                         Some(pat) => {\n-                            tested_by!(infer_resolve_while_let);\n+                            mark::hit!(infer_resolve_while_let);\n                             let pat = self.collect_pat(pat);\n                             let match_expr = self.collect_expr_opt(condition.expr());\n                             let placeholder_pat = self.missing_pat();\n@@ -268,7 +268,7 @@ impl ExprCollector<'_> {\n                 };\n                 let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n                 let generic_args =\n-                    e.type_arg_list().and_then(|it| GenericArgs::from_ast(&self.ctx, it));\n+                    e.type_arg_list().and_then(|it| GenericArgs::from_ast(&self.ctx(), it));\n                 self.alloc_expr(\n                     Expr::MethodCall { receiver, method_name, args, generic_args },\n                     syntax_ptr,\n@@ -373,7 +373,7 @@ impl ExprCollector<'_> {\n             }\n             ast::Expr::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                let type_ref = TypeRef::from_ast_opt(&self.ctx, e.type_ref());\n+                let type_ref = TypeRef::from_ast_opt(&self.ctx(), e.type_ref());\n                 self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n             }\n             ast::Expr::RefExpr(e) => {\n@@ -396,15 +396,15 @@ impl ExprCollector<'_> {\n                     for param in pl.params() {\n                         let pat = self.collect_pat_opt(param.pat());\n                         let type_ref =\n-                            param.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx, it));\n+                            param.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx(), it));\n                         args.push(pat);\n                         arg_types.push(type_ref);\n                     }\n                 }\n                 let ret_type = e\n                     .ret_type()\n                     .and_then(|r| r.type_ref())\n-                    .map(|it| TypeRef::from_ast(&self.ctx, it));\n+                    .map(|it| TypeRef::from_ast(&self.ctx(), it));\n                 let body = self.collect_expr_opt(e.body());\n                 self.alloc_expr(Expr::Lambda { args, arg_types, ret_type, body }, syntax_ptr)\n             }\n@@ -507,7 +507,8 @@ impl ExprCollector<'_> {\n             .map(|s| match s {\n                 ast::Stmt::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n-                    let type_ref = stmt.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx, it));\n+                    let type_ref =\n+                        stmt.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx(), it));\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n                     Statement::Let { pat, type_ref, initializer }\n                 }"}, {"sha": "09e92b74e1ab43bc59e050d7247a35cb2b0b96ce", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -174,7 +174,7 @@ mod tests {\n     use hir_expand::{name::AsName, InFile};\n     use ra_db::{fixture::WithFixture, FileId, SourceDatabase};\n     use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n-    use test_utils::{assert_eq_text, covers, extract_offset};\n+    use test_utils::{assert_eq_text, extract_offset, mark};\n \n     use crate::{db::DefDatabase, test_db::TestDB, FunctionId, ModuleDefId};\n \n@@ -388,7 +388,7 @@ mod tests {\n \n     #[test]\n     fn while_let_desugaring() {\n-        covers!(infer_resolve_while_let);\n+        mark::check!(infer_resolve_while_let);\n         do_check_local_name(\n             r#\"\n fn test() {"}, {"sha": "945a0025e504f7b71f240d9984ab6bc5344b3fbb", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,7 +1,7 @@\n //! Defines database & queries for name resolution.\n use std::sync::Arc;\n \n-use hir_expand::{db::AstDatabase, HirFileId};\n+use hir_expand::{db::AstDatabase, name::Name, HirFileId};\n use ra_db::{salsa, CrateId, SourceDatabase, Upcast};\n use ra_prof::profile;\n use ra_syntax::SmolStr;\n@@ -12,9 +12,13 @@ use crate::{\n     body::{scope::ExprScopes, Body, BodySourceMap},\n     data::{ConstData, FunctionData, ImplData, StaticData, TraitData, TypeAliasData},\n     docs::Documentation,\n+    find_path,\n     generics::GenericParams,\n+    item_scope::ItemInNs,\n     lang_item::{LangItemTarget, LangItems},\n     nameres::{raw::RawItems, CrateDefMap},\n+    path::ModPath,\n+    visibility::Visibility,\n     AttrDefId, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, FunctionId, FunctionLoc,\n     GenericDefId, ImplId, ImplLoc, ModuleId, StaticId, StaticLoc, StructId, StructLoc, TraitId,\n     TraitLoc, TypeAliasId, TypeAliasLoc, UnionId, UnionLoc,\n@@ -108,6 +112,16 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     // Remove this query completely, in favor of `Attrs::docs` method\n     #[salsa::invoke(Documentation::documentation_query)]\n     fn documentation(&self, def: AttrDefId) -> Option<Documentation>;\n+\n+    #[salsa::invoke(find_path::importable_locations_of_query)]\n+    fn importable_locations_of(\n+        &self,\n+        item: ItemInNs,\n+        krate: CrateId,\n+    ) -> Arc<[(ModuleId, Name, Visibility)]>;\n+\n+    #[salsa::invoke(find_path::find_path_inner_query)]\n+    fn find_path_inner(&self, item: ItemInNs, from: ModuleId, max_len: usize) -> Option<ModPath>;\n }\n \n fn crate_def_map_wait(db: &impl DefDatabase, krate: CrateId) -> Arc<CrateDefMap> {"}, {"sha": "4db7984730aa87eb281516565f57761b4083cd98", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "modified", "additions": 55, "deletions": 50, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,31 +1,40 @@\n //! An algorithm to find a path to refer to a certain item.\n \n+use std::sync::Arc;\n+\n+use hir_expand::name::{known, AsName, Name};\n+use ra_prof::profile;\n+use test_utils::mark;\n+\n use crate::{\n     db::DefDatabase,\n     item_scope::ItemInNs,\n     path::{ModPath, PathKind},\n     visibility::Visibility,\n     CrateId, ModuleDefId, ModuleId,\n };\n-use hir_expand::name::{known, AsName, Name};\n-use test_utils::tested_by;\n+\n+// FIXME: handle local items\n+\n+/// Find a path that can be used to refer to a certain item. This can depend on\n+/// *from where* you're referring to the item, hence the `from` parameter.\n+pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n+    let _p = profile(\"find_path\");\n+    db.find_path_inner(item, from, MAX_PATH_LEN)\n+}\n \n const MAX_PATH_LEN: usize = 15;\n \n impl ModPath {\n     fn starts_with_std(&self) -> bool {\n-        self.segments.first().filter(|&first_segment| first_segment == &known::std).is_some()\n+        self.segments.first() == Some(&known::std)\n     }\n \n     // When std library is present, paths starting with `std::`\n     // should be preferred over paths starting with `core::` and `alloc::`\n     fn can_start_with_std(&self) -> bool {\n-        self.segments\n-            .first()\n-            .filter(|&first_segment| {\n-                first_segment == &known::alloc || first_segment == &known::core\n-            })\n-            .is_some()\n+        let first_segment = self.segments.first();\n+        first_segment == Some(&known::alloc) || first_segment == Some(&known::core)\n     }\n \n     fn len(&self) -> usize {\n@@ -40,15 +49,7 @@ impl ModPath {\n     }\n }\n \n-// FIXME: handle local items\n-\n-/// Find a path that can be used to refer to a certain item. This can depend on\n-/// *from where* you're referring to the item, hence the `from` parameter.\n-pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n-    find_path_inner(db, item, from, MAX_PATH_LEN)\n-}\n-\n-fn find_path_inner(\n+pub(crate) fn find_path_inner_query(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n@@ -139,8 +140,7 @@ fn find_path_inner(\n     let mut best_path = None;\n     let mut best_path_len = max_len;\n     for (module_id, name) in importable_locations {\n-        let mut path = match find_path_inner(\n-            db,\n+        let mut path = match db.find_path_inner(\n             ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n             from,\n             best_path_len - 1,\n@@ -163,17 +163,19 @@ fn find_path_inner(\n \n fn select_best_path(old_path: ModPath, new_path: ModPath, prefer_no_std: bool) -> ModPath {\n     if old_path.starts_with_std() && new_path.can_start_with_std() {\n-        tested_by!(prefer_std_paths);\n         if prefer_no_std {\n+            mark::hit!(prefer_no_std_paths);\n             new_path\n         } else {\n+            mark::hit!(prefer_std_paths);\n             old_path\n         }\n     } else if new_path.starts_with_std() && old_path.can_start_with_std() {\n-        tested_by!(prefer_std_paths);\n         if prefer_no_std {\n+            mark::hit!(prefer_no_std_paths);\n             old_path\n         } else {\n+            mark::hit!(prefer_std_paths);\n             new_path\n         }\n     } else if new_path.len() < old_path.len() {\n@@ -198,7 +200,7 @@ fn find_importable_locations(\n         .chain(crate_graph[from.krate].dependencies.iter().map(|dep| dep.crate_id))\n     {\n         result.extend(\n-            importable_locations_in_crate(db, item, krate)\n+            db.importable_locations_of(item, krate)\n                 .iter()\n                 .filter(|(_, _, vis)| vis.is_visible_from(db, from))\n                 .map(|(m, n, _)| (*m, n.clone())),\n@@ -213,11 +215,12 @@ fn find_importable_locations(\n ///\n /// Note that the crate doesn't need to be the one in which the item is defined;\n /// it might be re-exported in other crates.\n-fn importable_locations_in_crate(\n+pub(crate) fn importable_locations_of_query(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     krate: CrateId,\n-) -> Vec<(ModuleId, Name, Visibility)> {\n+) -> Arc<[(ModuleId, Name, Visibility)]> {\n+    let _p = profile(\"importable_locations_of_query\");\n     let def_map = db.crate_def_map(krate);\n     let mut result = Vec::new();\n     for (local_id, data) in def_map.modules.iter() {\n@@ -243,17 +246,20 @@ fn importable_locations_in_crate(\n             result.push((ModuleId { krate, local_id }, name.clone(), vis));\n         }\n     }\n-    result\n+\n+    Arc::from(result)\n }\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use crate::test_db::TestDB;\n     use hir_expand::hygiene::Hygiene;\n     use ra_db::fixture::WithFixture;\n     use ra_syntax::ast::AstNode;\n-    use test_utils::covers;\n+    use test_utils::mark;\n+\n+    use crate::test_db::TestDB;\n+\n+    use super::*;\n \n     /// `code` needs to contain a cursor marker; checks that `find_path` for the\n     /// item the `path` refers to returns that same path when called from the\n@@ -508,7 +514,7 @@ mod tests {\n \n     #[test]\n     fn prefer_std_paths_over_alloc() {\n-        covers!(prefer_std_paths);\n+        mark::check!(prefer_std_paths);\n         let code = r#\"\n         //- /main.rs crate:main deps:alloc,std\n         <|>\n@@ -527,51 +533,50 @@ mod tests {\n     }\n \n     #[test]\n-    fn prefer_alloc_paths_over_std() {\n-        covers!(prefer_std_paths);\n+    fn prefer_core_paths_over_std() {\n+        mark::check!(prefer_no_std_paths);\n         let code = r#\"\n-        //- /main.rs crate:main deps:alloc,std\n+        //- /main.rs crate:main deps:core,std\n         #![no_std]\n \n         <|>\n \n-        //- /std.rs crate:std deps:alloc\n+        //- /std.rs crate:std deps:core\n \n-        pub mod sync {\n-            pub use alloc::sync::Arc;\n+        pub mod fmt {\n+            pub use core::fmt::Error;\n         }\n \n-        //- /zzz.rs crate:alloc\n+        //- /zzz.rs crate:core\n \n-        pub mod sync {\n-            pub struct Arc;\n+        pub mod fmt {\n+            pub struct Error;\n         }\n         \"#;\n-        check_found_path(code, \"alloc::sync::Arc\");\n+        check_found_path(code, \"core::fmt::Error\");\n     }\n \n     #[test]\n-    fn prefer_core_paths_over_std() {\n-        covers!(prefer_std_paths);\n+    fn prefer_alloc_paths_over_std() {\n         let code = r#\"\n-        //- /main.rs crate:main deps:core,std\n+        //- /main.rs crate:main deps:alloc,std\n         #![no_std]\n \n         <|>\n \n-        //- /std.rs crate:std deps:core\n+        //- /std.rs crate:std deps:alloc\n \n-        pub mod fmt {\n-            pub use core::fmt::Error;\n+        pub mod sync {\n+            pub use alloc::sync::Arc;\n         }\n \n-        //- /zzz.rs crate:core\n+        //- /zzz.rs crate:alloc\n \n-        pub mod fmt {\n-            pub struct Error;\n+        pub mod sync {\n+            pub struct Arc;\n         }\n         \"#;\n-        check_found_path(code, \"core::fmt::Error\");\n+        check_found_path(code, \"alloc::sync::Arc\");\n     }\n \n     #[test]"}, {"sha": "5325a27608eab95ddbda832651c3dab35909c26f", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -46,8 +46,6 @@ pub mod find_path;\n \n #[cfg(test)]\n mod test_db;\n-#[cfg(test)]\n-mod marks;\n \n use std::hash::Hash;\n "}, {"sha": "daa49d5f1040b6e792127d3299261fe685b76322", "filename": "crates/ra_hir_def/src/marks.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c6143742bd4e625d391ac3ea860be7578ab9f53f/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6143742bd4e625d391ac3ea860be7578ab9f53f/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs?ref=c6143742bd4e625d391ac3ea860be7578ab9f53f", "patch": "@@ -1,17 +0,0 @@\n-//! See test_utils/src/marks.rs\n-\n-test_utils::marks!(\n-    bogus_paths\n-    name_res_works_for_broken_modules\n-    can_import_enum_variant\n-    glob_enum\n-    glob_enum_group\n-    glob_across_crates\n-    std_prelude\n-    macro_rules_from_other_crates_are_visible_with_macro_use\n-    prelude_is_macro_use\n-    macro_dollar_crate_self\n-    macro_dollar_crate_other\n-    infer_resolve_while_let\n-    prefer_std_paths\n-);"}, {"sha": "353a31ad47a153cc6b717de468deb9e4b20594f9", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -14,7 +14,7 @@ use ra_cfg::CfgOptions;\n use ra_db::{CrateId, FileId, ProcMacroId};\n use ra_syntax::ast;\n use rustc_hash::FxHashMap;\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{\n     attr::Attrs,\n@@ -302,7 +302,7 @@ impl DefCollector<'_> {\n         );\n \n         if let Some(ModuleDefId::ModuleId(m)) = res.take_types() {\n-            tested_by!(macro_rules_from_other_crates_are_visible_with_macro_use);\n+            mark::hit!(macro_rules_from_other_crates_are_visible_with_macro_use);\n             self.import_all_macros_exported(current_module_id, m.krate);\n         }\n     }\n@@ -412,10 +412,10 @@ impl DefCollector<'_> {\n             match def.take_types() {\n                 Some(ModuleDefId::ModuleId(m)) => {\n                     if import.is_prelude {\n-                        tested_by!(std_prelude);\n+                        mark::hit!(std_prelude);\n                         self.def_map.prelude = Some(m);\n                     } else if m.krate != self.def_map.krate {\n-                        tested_by!(glob_across_crates);\n+                        mark::hit!(glob_across_crates);\n                         // glob import from other crate => we can just import everything once\n                         let item_map = self.db.crate_def_map(m.krate);\n                         let scope = &item_map[m.local_id].scope;\n@@ -461,7 +461,7 @@ impl DefCollector<'_> {\n                     }\n                 }\n                 Some(ModuleDefId::AdtId(AdtId::EnumId(e))) => {\n-                    tested_by!(glob_enum);\n+                    mark::hit!(glob_enum);\n                     // glob import from enum => just import all the variants\n \n                     // XXX: urgh, so this works by accident! Here, we look at\n@@ -510,7 +510,7 @@ impl DefCollector<'_> {\n \n                     self.update(module_id, &[(name, def)], vis);\n                 }\n-                None => tested_by!(bogus_paths),\n+                None => mark::hit!(bogus_paths),\n             }\n         }\n     }\n@@ -683,7 +683,7 @@ impl ModCollector<'_, '_> {\n         // Prelude module is always considered to be `#[macro_use]`.\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n             if prelude_module.krate != self.def_collector.def_map.krate {\n-                tested_by!(prelude_is_macro_use);\n+                mark::hit!(prelude_is_macro_use);\n                 self.def_collector.import_all_macros_exported(self.module_id, prelude_module.krate);\n             }\n         }"}, {"sha": "19692e70cf4564f97a17f817c60c9b8280c2baa5", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -14,7 +14,7 @@ use std::iter::successors;\n \n use hir_expand::name::Name;\n use ra_db::Edition;\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{\n     db::DefDatabase,\n@@ -108,15 +108,15 @@ impl CrateDefMap {\n         let mut curr_per_ns: PerNs = match path.kind {\n             PathKind::DollarCrate(krate) => {\n                 if krate == self.krate {\n-                    tested_by!(macro_dollar_crate_self);\n+                    mark::hit!(macro_dollar_crate_self);\n                     PerNs::types(\n                         ModuleId { krate: self.krate, local_id: self.root }.into(),\n                         Visibility::Public,\n                     )\n                 } else {\n                     let def_map = db.crate_def_map(krate);\n                     let module = ModuleId { krate, local_id: def_map.root };\n-                    tested_by!(macro_dollar_crate_other);\n+                    mark::hit!(macro_dollar_crate_other);\n                     PerNs::types(module.into(), Visibility::Public)\n                 }\n             }\n@@ -221,7 +221,7 @@ impl CrateDefMap {\n                 }\n                 ModuleDefId::AdtId(AdtId::EnumId(e)) => {\n                     // enum variant\n-                    tested_by!(can_import_enum_variant);\n+                    mark::hit!(can_import_enum_variant);\n                     let enum_data = db.enum_data(e);\n                     match enum_data.variant(&segment) {\n                         Some(local_id) => {"}, {"sha": "4e628b14d921424662c11fe2d50a4a3141a739ce", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -18,7 +18,7 @@ use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner, VisibilityOwner},\n     AstNode,\n };\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{\n     attr::Attrs,\n@@ -346,7 +346,7 @@ impl RawItemsCollector {\n             self.push_item(current_module, attrs, RawItemKind::Module(item));\n             return;\n         }\n-        tested_by!(name_res_works_for_broken_modules);\n+        mark::hit!(name_res_works_for_broken_modules);\n     }\n \n     fn add_use_item(&mut self, current_module: Option<Idx<ModuleData>>, use_item: ast::UseItem) {"}, {"sha": "05cd0297d1ed27faecc500b3b03c898f62284991", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -8,7 +8,7 @@ use std::sync::Arc;\n \n use insta::assert_snapshot;\n use ra_db::{fixture::WithFixture, SourceDatabase};\n-use test_utils::covers;\n+use test_utils::mark;\n \n use crate::{db::DefDatabase, nameres::*, test_db::TestDB};\n \n@@ -132,7 +132,7 @@ fn crate_def_map_fn_mod_same_name() {\n \n #[test]\n fn bogus_paths() {\n-    covers!(bogus_paths);\n+    mark::check!(bogus_paths);\n     let map = def_map(\n         \"\n         //- /lib.rs\n@@ -247,7 +247,7 @@ fn re_exports() {\n \n #[test]\n fn std_prelude() {\n-    covers!(std_prelude);\n+    mark::check!(std_prelude);\n     let map = def_map(\n         \"\n         //- /main.rs crate:main deps:test_crate\n@@ -271,7 +271,7 @@ fn std_prelude() {\n \n #[test]\n fn can_import_enum_variant() {\n-    covers!(can_import_enum_variant);\n+    mark::check!(can_import_enum_variant);\n     let map = def_map(\n         \"\n         //- /lib.rs"}, {"sha": "2b12c0daad5afcbb9ebe39af92c252e40056c265", "filename": "crates/ra_hir_def/src/nameres/tests/globs.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -152,7 +152,7 @@ fn glob_privacy_2() {\n \n #[test]\n fn glob_across_crates() {\n-    covers!(glob_across_crates);\n+    mark::check!(glob_across_crates);\n     let map = def_map(\n         r\"\n         //- /main.rs crate:main deps:test_crate\n@@ -171,7 +171,6 @@ fn glob_across_crates() {\n \n #[test]\n fn glob_privacy_across_crates() {\n-    covers!(glob_across_crates);\n     let map = def_map(\n         r\"\n         //- /main.rs crate:main deps:test_crate\n@@ -191,7 +190,7 @@ fn glob_privacy_across_crates() {\n \n #[test]\n fn glob_enum() {\n-    covers!(glob_enum);\n+    mark::check!(glob_enum);\n     let map = def_map(\n         \"\n         //- /lib.rs\n@@ -212,7 +211,7 @@ fn glob_enum() {\n \n #[test]\n fn glob_enum_group() {\n-    covers!(glob_enum_group);\n+    mark::check!(glob_enum_group);\n     let map = def_map(\n         r\"\n         //- /lib.rs"}, {"sha": "84480d9f6c4b2356769b5e7b529b28c38c735b00", "filename": "crates/ra_hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -212,7 +212,7 @@ fn unexpanded_macro_should_expand_by_fixedpoint_loop() {\n \n #[test]\n fn macro_rules_from_other_crates_are_visible_with_macro_use() {\n-    covers!(macro_rules_from_other_crates_are_visible_with_macro_use);\n+    mark::check!(macro_rules_from_other_crates_are_visible_with_macro_use);\n     let map = def_map(\n         \"\n         //- /main.rs crate:main deps:foo\n@@ -262,7 +262,7 @@ fn macro_rules_from_other_crates_are_visible_with_macro_use() {\n \n #[test]\n fn prelude_is_macro_use() {\n-    covers!(prelude_is_macro_use);\n+    mark::check!(prelude_is_macro_use);\n     let map = def_map(\n         \"\n         //- /main.rs crate:main deps:foo\n@@ -544,8 +544,7 @@ fn path_qualified_macros() {\n \n #[test]\n fn macro_dollar_crate_is_correct_in_item() {\n-    covers!(macro_dollar_crate_self);\n-    covers!(macro_dollar_crate_other);\n+    mark::check!(macro_dollar_crate_self);\n     let map = def_map(\n         \"\n         //- /main.rs crate:main deps:foo\n@@ -603,7 +602,7 @@ fn macro_dollar_crate_is_correct_in_item() {\n \n #[test]\n fn macro_dollar_crate_is_correct_in_indirect_deps() {\n-    covers!(macro_dollar_crate_other);\n+    mark::check!(macro_dollar_crate_other);\n     // From std\n     let map = def_map(\n         r#\""}, {"sha": "b43b294cab7c631ed736eac563e78a6f1bc6f542", "filename": "crates/ra_hir_def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n #[test]\n fn name_res_works_for_broken_modules() {\n-    covers!(name_res_works_for_broken_modules);\n+    mark::check!(name_res_works_for_broken_modules);\n     let map = def_map(\n         r\"\n         //- /lib.rs"}, {"sha": "7cc655487e78293b6341e9931c79cf26f2661fe7", "filename": "crates/ra_hir_def/src/path/lower/lower_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -6,7 +6,7 @@ use std::iter;\n use either::Either;\n use hir_expand::{hygiene::Hygiene, name::AsName};\n use ra_syntax::ast::{self, NameOwner};\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::path::{ImportAlias, ModPath, PathKind};\n \n@@ -54,7 +54,7 @@ pub(crate) fn lower_use_tree(\n         // FIXME: report errors somewhere\n         // We get here if we do\n         } else if is_glob {\n-            tested_by!(glob_enum_group);\n+            mark::hit!(glob_enum_group);\n             if let Some(prefix) = prefix {\n                 cb(prefix, &tree, is_glob, None)\n             }"}, {"sha": "3e6e1e3331b0140bd7c0ca174326b51fcaeef142", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1946,6 +1946,23 @@ mod tests {\n \n         check_no_diagnostic(content);\n     }\n+\n+    #[test]\n+    fn expr_diverges_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match loop {} {\n+                    Either::A => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n }\n \n #[cfg(test)]\n@@ -1997,26 +2014,6 @@ mod false_negatives {\n         check_no_diagnostic(content);\n     }\n \n-    #[test]\n-    fn expr_diverges_missing_arm() {\n-        let content = r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match loop {} {\n-                    Either::A => (),\n-                }\n-            }\n-        \";\n-\n-        // This is a false negative.\n-        // Even though the match expression diverges, rustc fails\n-        // to compile here since `Either::B` is missing.\n-        check_no_diagnostic(content);\n-    }\n-\n     #[test]\n     fn expr_loop_missing_arm() {\n         let content = r\"\n@@ -2035,7 +2032,7 @@ mod false_negatives {\n         // We currently infer the type of `loop { break Foo::A }` to `!`, which\n         // causes us to skip the diagnostic since `Either::A` doesn't type check\n         // with `!`.\n-        check_no_diagnostic(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]"}, {"sha": "957d6e0b5792d5f6d84a609e76ab5c2a57cd7382", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -218,6 +218,7 @@ struct InferenceContext<'a> {\n #[derive(Clone, Debug)]\n struct BreakableContext {\n     pub may_break: bool,\n+    pub break_ty: Ty,\n }\n \n impl<'a> InferenceContext<'a> {"}, {"sha": "2ee9adb16425c8063a1c44831193bcced58cc46d", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -5,7 +5,7 @@\n //! See: https://doc.rust-lang.org/nomicon/coercions.html\n \n use hir_def::{lang_item::LangItemTarget, type_ref::Mutability};\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{autoderef, traits::Solution, Obligation, Substs, TraitRef, Ty, TypeCtor};\n \n@@ -34,7 +34,7 @@ impl<'a> InferenceContext<'a> {\n             ty1.clone()\n         } else {\n             if let (ty_app!(TypeCtor::FnDef(_)), ty_app!(TypeCtor::FnDef(_))) = (ty1, ty2) {\n-                tested_by!(coerce_fn_reification);\n+                mark::hit!(coerce_fn_reification);\n                 // Special case: two function types. Try to coerce both to\n                 // pointers to have a chance at getting a match. See\n                 // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n@@ -44,7 +44,7 @@ impl<'a> InferenceContext<'a> {\n                 let ptr_ty2 = Ty::fn_ptr(sig2);\n                 self.coerce_merge_branch(&ptr_ty1, &ptr_ty2)\n             } else {\n-                tested_by!(coerce_merge_fail_fallback);\n+                mark::hit!(coerce_merge_fail_fallback);\n                 // For incompatible types, we use the latter one as result\n                 // to be better recovery for `if` without `else`.\n                 ty2.clone()"}, {"sha": "b28724f0e9461e03a6388b961feb77f58ae91ad4", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -93,22 +93,25 @@ impl<'a> InferenceContext<'a> {\n                 Ty::Unknown\n             }\n             Expr::Loop { body } => {\n-                self.breakables.push(BreakableContext { may_break: false });\n+                self.breakables.push(BreakableContext {\n+                    may_break: false,\n+                    break_ty: self.table.new_type_var(),\n+                });\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n \n                 let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                 if ctxt.may_break {\n                     self.diverges = Diverges::Maybe;\n                 }\n-                // FIXME handle break with value\n+\n                 if ctxt.may_break {\n-                    Ty::unit()\n+                    ctxt.break_ty\n                 } else {\n                     Ty::simple(TypeCtor::Never)\n                 }\n             }\n             Expr::While { condition, body } => {\n-                self.breakables.push(BreakableContext { may_break: false });\n+                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n                 // while let is desugared to a match loop, so this is always simple while\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n@@ -120,7 +123,7 @@ impl<'a> InferenceContext<'a> {\n             Expr::For { iterable, body, pat } => {\n                 let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n \n-                self.breakables.push(BreakableContext { may_break: false });\n+                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n                 let pat_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n@@ -229,17 +232,29 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Continue => Ty::simple(TypeCtor::Never),\n             Expr::Break { expr } => {\n-                if let Some(expr) = expr {\n-                    // FIXME handle break with value\n-                    self.infer_expr(*expr, &Expectation::none());\n-                }\n+                let val_ty = if let Some(expr) = expr {\n+                    self.infer_expr(*expr, &Expectation::none())\n+                } else {\n+                    Ty::unit()\n+                };\n+\n+                let last_ty = if let Some(ctxt) = self.breakables.last() {\n+                    ctxt.break_ty.clone()\n+                } else {\n+                    Ty::Unknown\n+                };\n+\n+                let merged_type = self.coerce_merge_branch(&last_ty, &val_ty);\n+\n                 if let Some(ctxt) = self.breakables.last_mut() {\n+                    ctxt.break_ty = merged_type;\n                     ctxt.may_break = true;\n                 } else {\n                     self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                         expr: tgt_expr,\n                     });\n                 }\n+\n                 Ty::simple(TypeCtor::Never)\n             }\n             Expr::Return { expr } => {"}, {"sha": "4006f595d18eeab0dd0f3414f06727d982f28390", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -10,7 +10,7 @@ use hir_def::{\n     FieldId,\n };\n use hir_expand::name::Name;\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use super::{BindingMode, Expectation, InferenceContext};\n use crate::{utils::variant_data, Substs, Ty, TypeCtor};\n@@ -111,7 +111,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n         } else if let Pat::Ref { .. } = &body[pat] {\n-            tested_by!(match_ergonomics_ref);\n+            mark::hit!(match_ergonomics_ref);\n             // When you encounter a `&pat` pattern, reset to Move.\n             // This is so that `w` is by value: `let (_, &w) = &(1, &2);`\n             default_bm = BindingMode::Move;"}, {"sha": "269495ca0bd25d29008f18a0d7f9855dd95986fe", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -4,7 +4,7 @@ use std::borrow::Cow;\n \n use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n \n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use super::{InferenceContext, Obligation};\n use crate::{\n@@ -313,7 +313,7 @@ impl InferenceTable {\n         // more than once\n         for i in 0..3 {\n             if i > 0 {\n-                tested_by!(type_var_resolves_to_int_var);\n+                mark::hit!(type_var_resolves_to_int_var);\n             }\n             match &*ty {\n                 Ty::Infer(tv) => {\n@@ -342,7 +342,7 @@ impl InferenceTable {\n             Ty::Infer(tv) => {\n                 let inner = tv.to_inner();\n                 if tv_stack.contains(&inner) {\n-                    tested_by!(type_var_cycles_resolve_as_possible);\n+                    mark::hit!(type_var_cycles_resolve_as_possible);\n                     // recursive type\n                     return tv.fallback_value();\n                 }\n@@ -369,7 +369,7 @@ impl InferenceTable {\n             Ty::Infer(tv) => {\n                 let inner = tv.to_inner();\n                 if tv_stack.contains(&inner) {\n-                    tested_by!(type_var_cycles_resolve_completely);\n+                    mark::hit!(type_var_cycles_resolve_completely);\n                     // recursive type\n                     return tv.fallback_value();\n                 }"}, {"sha": "c87ee06ce88cb5c6b078de11ba57b1e799a4aea8", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -42,7 +42,6 @@ pub mod expr;\n mod tests;\n #[cfg(test)]\n mod test_db;\n-mod marks;\n mod _match;\n \n use std::ops::Deref;\n@@ -808,15 +807,13 @@ impl Ty {\n         }\n     }\n \n-    /// If this is an `impl Trait` or `dyn Trait`, returns that trait.\n-    pub fn inherent_trait(&self) -> Option<TraitId> {\n+    /// If this is a `dyn Trait`, returns that trait.\n+    pub fn dyn_trait(&self) -> Option<TraitId> {\n         match self {\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                predicates.iter().find_map(|pred| match pred {\n-                    GenericPredicate::Implemented(tr) => Some(tr.trait_),\n-                    _ => None,\n-                })\n-            }\n+            Ty::Dyn(predicates) => predicates.iter().find_map(|pred| match pred {\n+                GenericPredicate::Implemented(tr) => Some(tr.trait_),\n+                _ => None,\n+            }),\n             _ => None,\n         }\n     }"}, {"sha": "35ac86a461eb0a6ff5cde7483f47642e4a40b821", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -812,7 +812,7 @@ impl TraitEnvironment {\n                 // add `Self: Trait<T1, T2, ...>` to the environment in trait\n                 // function default implementations (and hypothetical code\n                 // inside consts or type aliases)\n-                test_utils::tested_by!(trait_self_implements_self);\n+                test_utils::mark::hit!(trait_self_implements_self);\n                 let substs = Substs::type_params(db, trait_id);\n                 let trait_ref = TraitRef { trait_: trait_id, substs };\n                 let pred = GenericPredicate::Implemented(trait_ref);"}, {"sha": "a397401434bfc4e3c07ee404b64d08056112fb01", "filename": "crates/ra_hir_ty/src/marks.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6143742bd4e625d391ac3ea860be7578ab9f53f/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6143742bd4e625d391ac3ea860be7578ab9f53f/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs?ref=c6143742bd4e625d391ac3ea860be7578ab9f53f", "patch": "@@ -1,12 +0,0 @@\n-//! See test_utils/src/marks.rs\n-\n-test_utils::marks!(\n-    type_var_cycles_resolve_completely\n-    type_var_cycles_resolve_as_possible\n-    type_var_resolves_to_int_var\n-    impl_self_type_match_without_receiver\n-    match_ergonomics_ref\n-    coerce_merge_fail_fallback\n-    coerce_fn_reification\n-    trait_self_implements_self\n-);"}, {"sha": "e19628fdf728a772dbea5231dd2a9fe068a733c9", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -408,8 +408,9 @@ fn iterate_trait_method_candidates<T>(\n     receiver_ty: Option<&Canonical<Ty>>,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n-    // if ty is `impl Trait` or `dyn Trait`, the trait doesn't need to be in scope\n-    let inherent_trait = self_ty.value.inherent_trait().into_iter();\n+    // if ty is `dyn Trait`, the trait doesn't need to be in scope\n+    let inherent_trait =\n+        self_ty.value.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n     let env_traits = if let Ty::Placeholder(_) = self_ty.value {\n         // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n         env.trait_predicates_for_self_ty(&self_ty.value)\n@@ -468,7 +469,7 @@ fn iterate_inherent_methods<T>(\n                 // already happens in `is_valid_candidate` above; if not, we\n                 // check it here\n                 if receiver_ty.is_none() && inherent_impl_substs(db, impl_def, self_ty).is_none() {\n-                    test_utils::tested_by!(impl_self_type_match_without_receiver);\n+                    test_utils::mark::hit!(impl_self_type_match_without_receiver);\n                     continue;\n                 }\n                 if let Some(result) = callback(&self_ty.value, item) {\n@@ -601,11 +602,6 @@ pub fn implements_trait(\n     krate: CrateId,\n     trait_: TraitId,\n ) -> bool {\n-    if ty.value.inherent_trait() == Some(trait_) {\n-        // FIXME this is a bit of a hack, since Chalk should say the same thing\n-        // anyway, but currently Chalk doesn't implement `dyn/impl Trait` yet\n-        return true;\n-    }\n     let goal = generic_implements_goal(db, env, trait_, ty.clone());\n     let solution = db.trait_solve(krate, goal);\n "}, {"sha": "2cc4f4bf964c3168503c0b9af68501b4349b3815", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,6 +1,6 @@\n use super::infer_with_mismatches;\n use insta::assert_snapshot;\n-use test_utils::covers;\n+use test_utils::mark;\n \n // Infer with some common definitions and impls.\n fn infer(source: &str) -> String {\n@@ -339,7 +339,7 @@ fn test(i: i32) {\n \n #[test]\n fn coerce_merge_one_by_one1() {\n-    covers!(coerce_merge_fail_fallback);\n+    mark::check!(coerce_merge_fail_fallback);\n \n     assert_snapshot!(\n         infer(r#\"\n@@ -547,7 +547,7 @@ fn test() {\n \n #[test]\n fn coerce_fn_items_in_match_arms() {\n-    covers!(coerce_fn_reification);\n+    mark::check!(coerce_fn_reification);\n     assert_snapshot!(\n         infer_with_mismatches(r#\"\n fn foo1(x: u32) -> isize { 1 }"}, {"sha": "558a70022dce6ecb39ae37d6b77d498576c43818", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -984,7 +984,7 @@ fn test() { S2.into()<|>; }\n \n #[test]\n fn method_resolution_overloaded_method() {\n-    test_utils::covers!(impl_self_type_match_without_receiver);\n+    test_utils::mark::check!(impl_self_type_match_without_receiver);\n     let t = type_at(\n         r#\"\n //- main.rs\n@@ -1096,3 +1096,34 @@ fn test() { (S {}).method()<|>; }\n     );\n     assert_eq!(t, \"()\");\n }\n+\n+#[test]\n+fn dyn_trait_super_trait_not_in_scope() {\n+    assert_snapshot!(\n+        infer(r#\"\n+mod m {\n+    pub trait SuperTrait {\n+        fn foo(&self) -> u32 { 0 }\n+    }\n+}\n+trait Trait: m::SuperTrait {}\n+\n+struct S;\n+impl m::SuperTrait for S {}\n+impl Trait for S {}\n+\n+fn test(d: &dyn Trait) {\n+    d.foo();\n+}\n+\"#),\n+        @r###\"\n+    52..56 'self': &Self\n+    65..70 '{ 0 }': u32\n+    67..68 '0': u32\n+    177..178 'd': &dyn Trait\n+    192..208 '{     ...o(); }': ()\n+    198..199 'd': &dyn Trait\n+    198..205 'd.foo()': u32\n+    \"###\n+    );\n+}"}, {"sha": "0c5f972a2c6eaa7eeb750be86773887b95f9942b", "filename": "crates/ra_hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,5 +1,5 @@\n use insta::assert_snapshot;\n-use test_utils::covers;\n+use test_utils::mark;\n \n use super::{infer, infer_with_mismatches};\n \n@@ -197,7 +197,7 @@ fn test() {\n \n #[test]\n fn infer_pattern_match_ergonomics_ref() {\n-    covers!(match_ergonomics_ref);\n+    mark::check!(match_ergonomics_ref);\n     assert_snapshot!(\n         infer(r#\"\n fn test() {"}, {"sha": "1f004bd6301466fc60502b45f84bd43e707f39a5", "filename": "crates/ra_hir_ty/src/tests/regression.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,9 +1,10 @@\n use insta::assert_snapshot;\n-use test_utils::covers;\n+use ra_db::fixture::WithFixture;\n+use test_utils::mark;\n \n-use super::infer;\n use crate::test_db::TestDB;\n-use ra_db::fixture::WithFixture;\n+\n+use super::infer;\n \n #[test]\n fn bug_484() {\n@@ -89,8 +90,8 @@ fn quux() {\n \n #[test]\n fn recursive_vars() {\n-    covers!(type_var_cycles_resolve_completely);\n-    covers!(type_var_cycles_resolve_as_possible);\n+    mark::check!(type_var_cycles_resolve_completely);\n+    mark::check!(type_var_cycles_resolve_as_possible);\n     assert_snapshot!(\n         infer(r#\"\n fn test() {\n@@ -112,8 +113,6 @@ fn test() {\n \n #[test]\n fn recursive_vars_2() {\n-    covers!(type_var_cycles_resolve_completely);\n-    covers!(type_var_cycles_resolve_as_possible);\n     assert_snapshot!(\n         infer(r#\"\n fn test() {\n@@ -170,7 +169,7 @@ fn write() {\n \n #[test]\n fn infer_std_crash_2() {\n-    covers!(type_var_resolves_to_int_var);\n+    mark::check!(type_var_resolves_to_int_var);\n     // caused \"equating two type variables, ...\", taken from std\n     assert_snapshot!(\n         infer(r#\"\n@@ -563,6 +562,37 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn issue_4465_dollar_crate_at_type() {\n+    assert_snapshot!(\n+        infer(r#\"\n+pub struct Foo {}\n+pub fn anything<T>() -> T {\n+    loop {}\n+}\n+macro_rules! foo {\n+    () => {{\n+        let r: $crate::Foo = anything();\n+        r\n+    }};\n+}\n+fn main() {\n+    let _a = foo!();\n+}\n+\"#), @r###\"\n+    45..60 '{     loop {} }': T\n+    51..58 'loop {}': !\n+    56..58 '{}': ()\n+    !0..31 '{letr:...g();r}': Foo\n+    !4..5 'r': Foo\n+    !18..26 'anything': fn anything<Foo>() -> Foo\n+    !18..28 'anything()': Foo\n+    !29..30 'r': Foo\n+    164..188 '{     ...!(); }': ()\n+    174..176 '_a': Foo\n+\"###);\n+}\n+\n #[test]\n fn issue_4053_diesel_where_clauses() {\n     assert_snapshot!("}, {"sha": "fd2208af280e8fca4d2891fc00f9bcdb0c4e19fa", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1860,3 +1860,66 @@ fn test() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn infer_loop_break_with_val() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn test() {\n+    let x = loop {\n+        if false {\n+            break None;\n+        }\n+\n+        break Some(true);\n+    };\n+}\n+\"#),\n+        @r###\"\n+    60..169 '{     ...  }; }': ()\n+    70..71 'x': Option<bool>\n+    74..166 'loop {...     }': Option<bool>\n+    79..166 '{     ...     }': ()\n+    89..133 'if fal...     }': ()\n+    92..97 'false': bool\n+    98..133 '{     ...     }': ()\n+    112..122 'break None': !\n+    118..122 'None': Option<bool>\n+    143..159 'break ...(true)': !\n+    149..153 'Some': Some<bool>(bool) -> Option<bool>\n+    149..159 'Some(true)': Option<bool>\n+    154..158 'true': bool\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_loop_break_without_val() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn test() {\n+    let x = loop {\n+        if false {\n+            break;\n+        }\n+    };\n+}\n+\"#),\n+        @r###\"\n+    60..137 '{     ...  }; }': ()\n+    70..71 'x': ()\n+    74..134 'loop {...     }': ()\n+    79..134 '{     ...     }': ()\n+    89..128 'if fal...     }': ()\n+    92..97 'false': bool\n+    98..128 '{     ...     }': ()\n+    112..117 'break': !\n+    \"###\n+    );\n+}"}, {"sha": "34f4b9039cc3b44a53a15ce8651cbb37af773a86", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 136, "deletions": 4, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,10 +1,11 @@\n use insta::assert_snapshot;\n-\n use ra_db::fixture::WithFixture;\n+use test_utils::mark;\n \n-use super::{infer, infer_with_mismatches, type_at, type_at_pos};\n use crate::test_db::TestDB;\n \n+use super::{infer, infer_with_mismatches, type_at, type_at_pos};\n+\n #[test]\n fn infer_await() {\n     let (db, pos) = TestDB::with_position(\n@@ -301,7 +302,7 @@ fn test() {\n \n #[test]\n fn trait_default_method_self_bound_implements_trait() {\n-    test_utils::covers!(trait_self_implements_self);\n+    mark::check!(trait_self_implements_self);\n     assert_snapshot!(\n         infer(r#\"\n trait Trait {\n@@ -324,7 +325,6 @@ trait Trait {\n \n #[test]\n fn trait_default_method_self_bound_implements_super_trait() {\n-    test_utils::covers!(trait_self_implements_self);\n     assert_snapshot!(\n         infer(r#\"\n trait SuperTrait {\n@@ -1616,6 +1616,138 @@ fn test<F: FnOnce(u32, u64) -> u128>(f: F) {\n     );\n }\n \n+#[test]\n+fn fn_ptr_and_item() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang=\"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+\n+    fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+trait Foo<T> {\n+    fn foo(&self) -> T;\n+}\n+\n+struct Bar<T>(T);\n+\n+impl<A1, R, F: FnOnce(A1) -> R> Foo<(A1, R)> for Bar<F> {\n+    fn foo(&self) -> (A1, R) {}\n+}\n+\n+enum Opt<T> { None, Some(T) }\n+impl<T> Opt<T> {\n+    fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Opt<U> {}\n+}\n+\n+fn test() {\n+    let bar: Bar<fn(u8) -> u32>;\n+    bar.foo();\n+\n+    let opt: Opt<u8>;\n+    let f: fn(u8) -> u32;\n+    opt.map(f);\n+}\n+\"#),\n+        @r###\"\n+75..79 'self': Self\n+81..85 'args': Args\n+140..144 'self': &Self\n+244..248 'self': &Bar<F>\n+261..263 '{}': ()\n+347..351 'self': Opt<T>\n+353..354 'f': F\n+369..371 '{}': ()\n+385..501 '{     ...(f); }': ()\n+395..398 'bar': Bar<fn(u8) -> u32>\n+424..427 'bar': Bar<fn(u8) -> u32>\n+424..433 'bar.foo()': {unknown}\n+444..447 'opt': Opt<u8>\n+466..467 'f': fn(u8) -> u32\n+488..491 'opt': Opt<u8>\n+488..498 'opt.map(f)': Opt<FnOnce::Output<fn(u8) -> u32, (u8,)>>\n+496..497 'f': fn(u8) -> u32\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn fn_trait_deref_with_ty_default() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+#[lang=\"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+\n+    fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn foo(&self) -> usize {}\n+}\n+\n+struct Lazy<T, F = fn() -> T>(F);\n+\n+impl<T, F> Lazy<T, F> {\n+    pub fn new(f: F) -> Lazy<T, F> {}\n+}\n+\n+impl<T, F: FnOnce() -> T> Deref for Lazy<T, F> {\n+    type Target = T;\n+}\n+\n+fn test() {\n+    let lazy1: Lazy<Foo, _> = Lazy::new(|| Foo);\n+    let r1 = lazy1.foo();\n+\n+    fn make_foo_fn() -> Foo {}\n+    let make_foo_fn_ptr: fn() -> Foo = make_foo_fn;\n+    let lazy2: Lazy<Foo, _> = Lazy::new(make_foo_fn_ptr);\n+    let r2 = lazy2.foo();\n+}\n+\"#),\n+        @r###\"\n+65..69 'self': &Self\n+166..170 'self': Self\n+172..176 'args': Args\n+240..244 'self': &Foo\n+255..257 '{}': ()\n+335..336 'f': F\n+355..357 '{}': ()\n+444..690 '{     ...o(); }': ()\n+454..459 'lazy1': Lazy<Foo, fn() -> T>\n+476..485 'Lazy::new': fn new<Foo, fn() -> T>(fn() -> T) -> Lazy<Foo, fn() -> T>\n+476..493 'Lazy::...| Foo)': Lazy<Foo, fn() -> T>\n+486..492 '|| Foo': || -> T\n+489..492 'Foo': Foo\n+503..505 'r1': {unknown}\n+508..513 'lazy1': Lazy<Foo, fn() -> T>\n+508..519 'lazy1.foo()': {unknown}\n+561..576 'make_foo_fn_ptr': fn() -> Foo\n+592..603 'make_foo_fn': fn make_foo_fn() -> Foo\n+613..618 'lazy2': Lazy<Foo, fn() -> T>\n+635..644 'Lazy::new': fn new<Foo, fn() -> T>(fn() -> T) -> Lazy<Foo, fn() -> T>\n+635..661 'Lazy::...n_ptr)': Lazy<Foo, fn() -> T>\n+645..660 'make_foo_fn_ptr': fn() -> Foo\n+671..673 'r2': {unknown}\n+676..681 'lazy2': Lazy<Foo, fn() -> T>\n+676..687 'lazy2.foo()': {unknown}\n+550..552 '{}': ()\n+\"###\n+    );\n+}\n+\n #[test]\n fn closure_1() {\n     assert_snapshot!("}, {"sha": "aa039e6fcdb23ce06ac024df338da684440764c5", "filename": "crates/ra_ide/src/call_info.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     ast::{self, ArgListOwner},\n     match_ast, AstNode, SyntaxNode, SyntaxToken,\n };\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{CallInfo, FilePosition, FunctionSignature};\n \n@@ -84,7 +84,7 @@ fn call_info_for_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Op\n \n                 let arg_list_range = arg_list.syntax().text_range();\n                 if !arg_list_range.contains_inclusive(token.text_range().start()) {\n-                    tested_by!(call_info_bad_offset);\n+                    mark::hit!(call_info_bad_offset);\n                     return None;\n                 }\n \n@@ -213,7 +213,7 @@ impl CallInfo {\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n     use crate::mock_analysis::single_file_with_position;\n \n@@ -529,7 +529,7 @@ By default this method stops actor's `Context`.\"#\n \n     #[test]\n     fn call_info_bad_offset() {\n-        covers!(call_info_bad_offset);\n+        mark::check!(call_info_bad_offset);\n         let (analysis, position) = single_file_with_position(\n             r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n                fn bar() { foo <|> (3, ); }\"#,"}, {"sha": "191300704b5531ac1ea396ac110ab777c4907373", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -59,8 +59,8 @@ pub use crate::completion::{\n /// with ordering of completions (currently this is done by the client).\n pub(crate) fn completions(\n     db: &RootDatabase,\n-    position: FilePosition,\n     config: &CompletionConfig,\n+    position: FilePosition,\n ) -> Option<Completions> {\n     let ctx = CompletionContext::new(db, position, config)?;\n "}, {"sha": "02ac0166b6e12ee9c016045648151d66555f4d65", "filename": "crates/ra_ide/src/completion/complete_qualified_path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -3,7 +3,7 @@\n use hir::{Adt, HasVisibility, PathResolution, ScopeDef};\n use ra_syntax::AstNode;\n use rustc_hash::FxHashSet;\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::completion::{CompletionContext, Completions};\n \n@@ -40,7 +40,7 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                         if let Some(name_ref) = ctx.name_ref_syntax.as_ref() {\n                             if name_ref.syntax().text() == name.to_string().as_str() {\n                                 // for `use self::foo<|>`, don't suggest `foo` as a completion\n-                                tested_by!(dont_complete_current_use);\n+                                mark::hit!(dont_complete_current_use);\n                                 continue;\n                             }\n                         }\n@@ -147,7 +147,7 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n     use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n     use insta::assert_debug_snapshot;\n@@ -158,7 +158,7 @@ mod tests {\n \n     #[test]\n     fn dont_complete_current_use() {\n-        covers!(dont_complete_current_use);\n+        mark::check!(dont_complete_current_use);\n         let completions = do_completion(r\"use self::foo<|>;\", CompletionKind::Reference);\n         assert!(completions.is_empty());\n     }"}, {"sha": "db791660a18a756727200f7aca1b57896de82f11", "filename": "crates/ra_ide/src/completion/complete_unqualified_path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,7 +1,7 @@\n //! Completion of names from the current scope, e.g. locals and imported items.\n \n use hir::ScopeDef;\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::completion::{CompletionContext, Completions};\n use hir::{Adt, ModuleDef, Type};\n@@ -30,7 +30,7 @@ pub(super) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         if ctx.use_item_syntax.is_some() {\n             if let (ScopeDef::Unknown, Some(name_ref)) = (&res, &ctx.name_ref_syntax) {\n                 if name_ref.syntax().text() == name.to_string().as_str() {\n-                    tested_by!(self_fulfilling_completion);\n+                    mark::hit!(self_fulfilling_completion);\n                     return;\n                 }\n             }\n@@ -66,7 +66,7 @@ fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext, ty: &T\n #[cfg(test)]\n mod tests {\n     use insta::assert_debug_snapshot;\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n     use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n \n@@ -76,7 +76,7 @@ mod tests {\n \n     #[test]\n     fn self_fulfilling_completion() {\n-        covers!(self_fulfilling_completion);\n+        mark::check!(self_fulfilling_completion);\n         assert_debug_snapshot!(\n             do_reference_completion(\n                 r#\""}, {"sha": "440ffa31d4e0c9db6a10a0ee1b4c4d6c6e619294", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -3,7 +3,7 @@\n use hir::{Docs, HasAttrs, HasSource, HirDisplay, ModPath, ScopeDef, StructKind, Type};\n use ra_syntax::ast::NameOwner;\n use stdx::SepBy;\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{\n     completion::{\n@@ -121,7 +121,7 @@ impl Completions {\n                     _ => false,\n                 };\n                 if has_non_default_type_params {\n-                    tested_by!(inserts_angle_brackets_for_generics);\n+                    mark::hit!(inserts_angle_brackets_for_generics);\n                     completion_item = completion_item\n                         .lookup_by(local_name.clone())\n                         .label(format!(\"{}<\u2026>\", local_name))\n@@ -176,7 +176,7 @@ impl Completions {\n             }\n             None if needs_bang => builder.insert_text(format!(\"{}!\", name)),\n             _ => {\n-                tested_by!(dont_insert_macro_call_parens_unncessary);\n+                mark::hit!(dont_insert_macro_call_parens_unncessary);\n                 builder.insert_text(name)\n             }\n         };\n@@ -330,14 +330,14 @@ pub(crate) fn compute_score(\n     // FIXME: this should not fall back to string equality.\n     let ty = &ty.display(ctx.db).to_string();\n     let (active_name, active_type) = if let Some(record_field) = &ctx.record_field_syntax {\n-        tested_by!(test_struct_field_completion_in_record_lit);\n+        mark::hit!(test_struct_field_completion_in_record_lit);\n         let (struct_field, _local) = ctx.sema.resolve_record_field(record_field)?;\n         (\n             struct_field.name(ctx.db).to_string(),\n             struct_field.signature_ty(ctx.db).display(ctx.db).to_string(),\n         )\n     } else if let Some(active_parameter) = &ctx.active_parameter {\n-        tested_by!(test_struct_field_completion_in_func_call);\n+        mark::hit!(test_struct_field_completion_in_func_call);\n         (active_parameter.name.clone(), active_parameter.ty.clone())\n     } else {\n         return None;\n@@ -398,7 +398,7 @@ impl Builder {\n             None => return self,\n         };\n         // If not an import, add parenthesis automatically.\n-        tested_by!(inserts_parens_for_function_calls);\n+        mark::hit!(inserts_parens_for_function_calls);\n \n         let (snippet, label) = if params.is_empty() {\n             (format!(\"{}()$0\", name), format!(\"{}()\", name))\n@@ -457,7 +457,7 @@ fn guess_macro_braces(macro_name: &str, docs: &str) -> (&'static str, &'static s\n #[cfg(test)]\n mod tests {\n     use insta::assert_debug_snapshot;\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n     use crate::completion::{\n         test_utils::{do_completion, do_completion_with_options},\n@@ -607,7 +607,7 @@ mod tests {\n \n     #[test]\n     fn inserts_parens_for_function_calls() {\n-        covers!(inserts_parens_for_function_calls);\n+        mark::check!(inserts_parens_for_function_calls);\n         assert_debug_snapshot!(\n             do_reference_completion(\n                 r\"\n@@ -992,7 +992,7 @@ mod tests {\n \n     #[test]\n     fn inserts_angle_brackets_for_generics() {\n-        covers!(inserts_angle_brackets_for_generics);\n+        mark::check!(inserts_angle_brackets_for_generics);\n         assert_debug_snapshot!(\n             do_reference_completion(\n                 r\"\n@@ -1115,7 +1115,7 @@ mod tests {\n \n     #[test]\n     fn dont_insert_macro_call_parens_unncessary() {\n-        covers!(dont_insert_macro_call_parens_unncessary);\n+        mark::check!(dont_insert_macro_call_parens_unncessary);\n         assert_debug_snapshot!(\n             do_reference_completion(\n                 r\"\n@@ -1181,7 +1181,7 @@ mod tests {\n \n     #[test]\n     fn test_struct_field_completion_in_func_call() {\n-        covers!(test_struct_field_completion_in_func_call);\n+        mark::check!(test_struct_field_completion_in_func_call);\n         assert_debug_snapshot!(\n         do_reference_completion(\n                 r\"\n@@ -1271,7 +1271,7 @@ mod tests {\n \n     #[test]\n     fn test_struct_field_completion_in_record_lit() {\n-        covers!(test_struct_field_completion_in_record_lit);\n+        mark::check!(test_struct_field_completion_in_record_lit);\n         assert_debug_snapshot!(\n         do_reference_completion(\n                 r\""}, {"sha": "bf22452a281c76cf798aad520d97064151bf5fb3", "filename": "crates/ra_ide/src/completion/test_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -20,7 +20,7 @@ pub(crate) fn do_completion_with_options(\n     } else {\n         single_file_with_position(code)\n     };\n-    let completions = analysis.completions(position, options).unwrap().unwrap();\n+    let completions = analysis.completions(options, position).unwrap().unwrap();\n     let completion_items: Vec<CompletionItem> = completions.into();\n     let mut kind_completions: Vec<CompletionItem> =\n         completion_items.into_iter().filter(|c| c.completion_kind == kind).collect();"}, {"sha": "54c2bcc0942aab887b0cc8e13f98392e65ed0d9e", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -629,6 +629,7 @@ mod tests {\n                             },\n                         ],\n                         cursor_position: None,\n+                        is_snippet: false,\n                     },\n                 ),\n                 severity: Error,\n@@ -685,6 +686,7 @@ mod tests {\n                         ],\n                         file_system_edits: [],\n                         cursor_position: None,\n+                        is_snippet: false,\n                     },\n                 ),\n                 severity: Error,"}, {"sha": "90e85d4197126f12f0aba169c477a15b2e2a8978", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -93,7 +93,7 @@ pub(crate) fn reference_definition(\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::{assert_eq_text, covers};\n+    use test_utils::assert_eq_text;\n \n     use crate::mock_analysis::analysis_and_position;\n \n@@ -208,7 +208,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_macros() {\n-        covers!(ra_ide_db::goto_def_for_macros);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -225,7 +224,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_macros_from_other_crates() {\n-        covers!(ra_ide_db::goto_def_for_macros);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -245,7 +243,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_use_alias() {\n-        covers!(ra_ide_db::goto_def_for_use_alias);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -370,7 +367,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_methods() {\n-        covers!(ra_ide_db::goto_def_for_methods);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -390,7 +386,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_fields() {\n-        covers!(ra_ide_db::goto_def_for_fields);\n         check_goto(\n             r\"\n             //- /lib.rs\n@@ -409,7 +404,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_record_fields() {\n-        covers!(ra_ide_db::goto_def_for_record_fields);\n         check_goto(\n             r\"\n             //- /lib.rs\n@@ -430,7 +424,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_record_pat_fields() {\n-        covers!(ra_ide_db::goto_def_for_record_field_pats);\n         check_goto(\n             r\"\n             //- /lib.rs\n@@ -873,7 +866,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_field_init_shorthand() {\n-        covers!(ra_ide_db::goto_def_for_field_init_shorthand);\n         check_goto(\n             \"\n             //- /lib.rs"}, {"sha": "83cb498f79ede436cdb8fdf0ffeffdf8855c1632", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -42,8 +42,6 @@ mod inlay_hints;\n mod expand_macro;\n mod ssr;\n \n-#[cfg(test)]\n-mod marks;\n #[cfg(test)]\n mod test_utils;\n \n@@ -82,7 +80,7 @@ pub use crate::{\n };\n \n pub use hir::Documentation;\n-pub use ra_assists::AssistId;\n+pub use ra_assists::{AssistConfig, AssistId};\n pub use ra_db::{\n     Canceled, CrateGraph, CrateId, Edition, FileId, FilePosition, FileRange, SourceRootId,\n };\n@@ -458,17 +456,17 @@ impl Analysis {\n     /// Computes completions at the given position.\n     pub fn completions(\n         &self,\n-        position: FilePosition,\n         config: &CompletionConfig,\n+        position: FilePosition,\n     ) -> Cancelable<Option<Vec<CompletionItem>>> {\n-        self.with_db(|db| completion::completions(db, position, config).map(Into::into))\n+        self.with_db(|db| completion::completions(db, config, position).map(Into::into))\n     }\n \n     /// Computes assists (aka code actions aka intentions) for the given\n     /// position.\n-    pub fn assists(&self, frange: FileRange) -> Cancelable<Vec<Assist>> {\n+    pub fn assists(&self, config: &AssistConfig, frange: FileRange) -> Cancelable<Vec<Assist>> {\n         self.with_db(|db| {\n-            ra_assists::Assist::resolved(db, frange)\n+            ra_assists::Assist::resolved(db, config, frange)\n                 .into_iter()\n                 .map(|assist| Assist {\n                     id: assist.assist.id,"}, {"sha": "51ca4dde3f0017f19b5c338af1a11d7b78b6ee8f", "filename": "crates/ra_ide/src/marks.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6143742bd4e625d391ac3ea860be7578ab9f53f/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6143742bd4e625d391ac3ea860be7578ab9f53f/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmarks.rs?ref=c6143742bd4e625d391ac3ea860be7578ab9f53f", "patch": "@@ -1,16 +0,0 @@\n-//! See test_utils/src/marks.rs\n-\n-test_utils::marks!(\n-    inserts_angle_brackets_for_generics\n-    inserts_parens_for_function_calls\n-    call_info_bad_offset\n-    dont_complete_current_use\n-    test_resolve_parent_module_on_module_decl\n-    search_filters_by_range\n-    dont_insert_macro_call_parens_unncessary\n-    self_fulfilling_completion\n-    test_struct_field_completion_in_func_call\n-    test_struct_field_completion_in_record_lit\n-    test_rename_struct_field_for_shorthand\n-    test_rename_local_for_field_shorthand\n-);"}, {"sha": "a083fb1eb35890f0cd460357b3b13c6b7b3bdda7", "filename": "crates/ra_ide/src/parent_module.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fparent_module.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -7,7 +7,7 @@ use ra_syntax::{\n     algo::find_node_at_offset,\n     ast::{self, AstNode},\n };\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::NavigationTarget;\n \n@@ -25,7 +25,7 @@ pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<Na\n             .item_list()\n             .map_or(false, |it| it.syntax().text_range().contains_inclusive(position.offset))\n         {\n-            tested_by!(test_resolve_parent_module_on_module_decl);\n+            mark::hit!(test_resolve_parent_module_on_module_decl);\n             module = m.syntax().ancestors().skip(1).find_map(ast::Module::cast);\n         }\n     }\n@@ -57,7 +57,7 @@ pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n mod tests {\n     use ra_cfg::CfgOptions;\n     use ra_db::Env;\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n     use crate::{\n         mock_analysis::{analysis_and_position, MockAnalysis},\n@@ -81,7 +81,7 @@ mod tests {\n \n     #[test]\n     fn test_resolve_parent_module_on_module_decl() {\n-        covers!(test_resolve_parent_module_on_module_decl);\n+        mark::check!(test_resolve_parent_module_on_module_decl);\n         let (analysis, pos) = analysis_and_position(\n             \"\n             //- /lib.rs"}, {"sha": "96444bf6a52d2f8a72767d4deb322dc924d084ac", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -190,8 +190,6 @@ fn get_struct_def_name_for_struct_literal_search(\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::covers;\n-\n     use crate::{\n         mock_analysis::{analysis_and_position, single_file_with_position, MockAnalysis},\n         Declaration, Reference, ReferenceSearchResult, SearchScope,\n@@ -301,7 +299,6 @@ mod tests {\n \n     #[test]\n     fn search_filters_by_range() {\n-        covers!(ra_ide_db::search_filters_by_range);\n         let code = r#\"\n             fn foo() {\n                 let spam<|> = 92;"}, {"sha": "62ec8d85dd2a4af6dbb7d143dbdae6f66254c279", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::{\n };\n use ra_text_edit::TextEdit;\n use std::convert::TryInto;\n-use test_utils::tested_by;\n+use test_utils::mark;\n \n use crate::{\n     references::find_all_refs, FilePosition, FileSystemEdit, RangeInfo, Reference, ReferenceKind,\n@@ -57,13 +57,13 @@ fn source_edit_from_reference(reference: Reference, new_name: &str) -> SourceFil\n     let file_id = reference.file_range.file_id;\n     let range = match reference.kind {\n         ReferenceKind::FieldShorthandForField => {\n-            tested_by!(test_rename_struct_field_for_shorthand);\n+            mark::hit!(test_rename_struct_field_for_shorthand);\n             replacement_text.push_str(new_name);\n             replacement_text.push_str(\": \");\n             TextRange::new(reference.file_range.range.start(), reference.file_range.range.start())\n         }\n         ReferenceKind::FieldShorthandForLocal => {\n-            tested_by!(test_rename_local_for_field_shorthand);\n+            mark::hit!(test_rename_local_for_field_shorthand);\n             replacement_text.push_str(\": \");\n             replacement_text.push_str(new_name);\n             TextRange::new(reference.file_range.range.end(), reference.file_range.range.end())\n@@ -260,7 +260,7 @@ fn rename_reference(\n mod tests {\n     use insta::assert_debug_snapshot;\n     use ra_text_edit::TextEditBuilder;\n-    use test_utils::{assert_eq_text, covers};\n+    use test_utils::{assert_eq_text, mark};\n \n     use crate::{\n         mock_analysis::analysis_and_position, mock_analysis::single_file_with_position, FileId,\n@@ -492,7 +492,7 @@ mod tests {\n \n     #[test]\n     fn test_rename_struct_field_for_shorthand() {\n-        covers!(test_rename_struct_field_for_shorthand);\n+        mark::check!(test_rename_struct_field_for_shorthand);\n         test_rename(\n             r#\"\n     struct Foo {\n@@ -522,7 +522,7 @@ mod tests {\n \n     #[test]\n     fn test_rename_local_for_field_shorthand() {\n-        covers!(test_rename_local_for_field_shorthand);\n+        mark::check!(test_rename_local_for_field_shorthand);\n         test_rename(\n             r#\"\n     struct Foo {\n@@ -670,6 +670,7 @@ mod tests {\n                         },\n                     ],\n                     cursor_position: None,\n+                    is_snippet: false,\n                 },\n             },\n         )\n@@ -722,6 +723,7 @@ mod tests {\n                         },\n                     ],\n                     cursor_position: None,\n+                    is_snippet: false,\n                 },\n             },\n         )\n@@ -818,6 +820,7 @@ mod tests {\n                         },\n                     ],\n                     cursor_position: None,\n+                    is_snippet: false,\n                 },\n             },\n         )"}, {"sha": "3a3d0b0ac124d07db4d3806a8eeb2fdfe0695e9c", "filename": "crates/ra_ide/src/runnables.rs", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Frunnables.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{Attrs, HirFileId, InFile, Semantics};\n+use hir::{AsAssocItem, Attrs, HirFileId, InFile, Semantics};\n use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n@@ -70,14 +70,36 @@ fn runnable_fn(\n         RunnableKind::Bin\n     } else {\n         let test_id = if let Some(module) = sema.to_def(&fn_def).map(|def| def.module(sema.db)) {\n-            let path = module\n+            let def = sema.to_def(&fn_def)?;\n+            let impl_trait_name =\n+                def.as_assoc_item(sema.db).and_then(|assoc_item| {\n+                    match assoc_item.container(sema.db) {\n+                        hir::AssocItemContainer::Trait(trait_item) => {\n+                            Some(trait_item.name(sema.db).to_string())\n+                        }\n+                        hir::AssocItemContainer::ImplDef(impl_def) => impl_def\n+                            .target_ty(sema.db)\n+                            .as_adt()\n+                            .map(|adt| adt.name(sema.db).to_string()),\n+                    }\n+                });\n+\n+            let path_iter = module\n                 .path_to_root(sema.db)\n                 .into_iter()\n                 .rev()\n                 .filter_map(|it| it.name(sema.db))\n-                .map(|name| name.to_string())\n-                .chain(std::iter::once(name_string))\n-                .join(\"::\");\n+                .map(|name| name.to_string());\n+\n+            let path = if let Some(impl_trait_name) = impl_trait_name {\n+                path_iter\n+                    .chain(std::iter::once(impl_trait_name))\n+                    .chain(std::iter::once(name_string))\n+                    .join(\"::\")\n+            } else {\n+                path_iter.chain(std::iter::once(name_string)).join(\"::\")\n+            };\n+\n             TestId::Path(path)\n         } else {\n             TestId::Name(name_string)\n@@ -278,6 +300,46 @@ mod tests {\n                 );\n     }\n \n+    #[test]\n+    fn test_runnables_doc_test_in_impl() {\n+        let (analysis, pos) = analysis_and_position(\n+            r#\"\n+        //- /lib.rs\n+        <|> //empty\n+        fn main() {}\n+\n+        struct Data;\n+        impl Data {\n+            /// ```\n+            /// let x = 5;\n+            /// ```\n+            fn foo() {}\n+        }\n+        \"#,\n+        );\n+        let runnables = analysis.runnables(pos.file_id).unwrap();\n+        assert_debug_snapshot!(&runnables,\n+        @r###\"\n+        [\n+            Runnable {\n+                range: 1..21,\n+                kind: Bin,\n+                features_needed: None,\n+            },\n+            Runnable {\n+                range: 51..105,\n+                kind: DocTest {\n+                    test_id: Path(\n+                        \"Data::foo\",\n+                    ),\n+                },\n+                features_needed: None,\n+            },\n+        ]\n+        \"###\n+                );\n+    }\n+\n     #[test]\n     fn test_runnables_module() {\n         let (analysis, pos) = analysis_and_position("}, {"sha": "cd48cad93b969ec286a8e4fb32fef384ea92914d", "filename": "crates/ra_ide/src/typing.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -82,7 +82,6 @@ fn on_eq_typed(file: &SourceFile, offset: TextSize) -> Option<SingleFileChange>\n     Some(SingleFileChange {\n         label: \"add semicolon\".to_string(),\n         edit: TextEdit::insert(offset, \";\".to_string()),\n-        cursor_position: None,\n     })\n }\n \n@@ -111,7 +110,6 @@ fn on_dot_typed(file: &SourceFile, offset: TextSize) -> Option<SingleFileChange>\n     Some(SingleFileChange {\n         label: \"reindent dot\".to_string(),\n         edit: TextEdit::replace(TextRange::new(offset - current_indent_len, offset), target_indent),\n-        cursor_position: Some(offset + target_indent_len - current_indent_len + TextSize::of('.')),\n     })\n }\n \n@@ -130,7 +128,6 @@ fn on_arrow_typed(file: &SourceFile, offset: TextSize) -> Option<SingleFileChang\n     Some(SingleFileChange {\n         label: \"add space after return type\".to_string(),\n         edit: TextEdit::insert(after_arrow, \" \".to_string()),\n-        cursor_position: Some(after_arrow),\n     })\n }\n \n@@ -140,29 +137,23 @@ mod tests {\n \n     use super::*;\n \n-    fn do_type_char(char_typed: char, before: &str) -> Option<(String, SingleFileChange)> {\n+    fn do_type_char(char_typed: char, before: &str) -> Option<String> {\n         let (offset, before) = extract_offset(before);\n         let edit = TextEdit::insert(offset, char_typed.to_string());\n         let mut before = before.to_string();\n         edit.apply(&mut before);\n         let parse = SourceFile::parse(&before);\n         on_char_typed_inner(&parse.tree(), offset, char_typed).map(|it| {\n             it.edit.apply(&mut before);\n-            (before.to_string(), it)\n+            before.to_string()\n         })\n     }\n \n     fn type_char(char_typed: char, before: &str, after: &str) {\n-        let (actual, file_change) = do_type_char(char_typed, before)\n+        let actual = do_type_char(char_typed, before)\n             .unwrap_or_else(|| panic!(\"typing `{}` did nothing\", char_typed));\n \n-        if after.contains(\"<|>\") {\n-            let (offset, after) = extract_offset(after);\n-            assert_eq_text!(&after, &actual);\n-            assert_eq!(file_change.cursor_position, Some(offset))\n-        } else {\n-            assert_eq_text!(after, &actual);\n-        }\n+        assert_eq_text!(after, &actual);\n     }\n \n     fn type_char_noop(char_typed: char, before: &str) {\n@@ -350,6 +341,6 @@ fn foo() {\n \n     #[test]\n     fn adds_space_after_return_type() {\n-        type_char('>', \"fn foo() -<|>{ 92 }\", \"fn foo() -><|> { 92 }\")\n+        type_char('>', \"fn foo() -<|>{ 92 }\", \"fn foo() -> { 92 }\")\n     }\n }"}, {"sha": "8b06cbfc54b7ca8681708f783e216ff77cad68b4", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -14,7 +14,6 @@ use ra_syntax::{\n     ast::{self, AstNode},\n     match_ast,\n };\n-use test_utils::tested_by;\n \n use crate::RootDatabase;\n \n@@ -118,7 +117,6 @@ fn classify_name_inner(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Opti\n     match_ast! {\n         match parent {\n             ast::Alias(it) => {\n-                tested_by!(goto_def_for_use_alias; force);\n                 let use_tree = it.syntax().parent().and_then(ast::UseTree::cast)?;\n                 let path = use_tree.path()?;\n                 let path_segment = path.segment()?;\n@@ -203,6 +201,8 @@ impl NameRefClass {\n     }\n }\n \n+// Note: we don't have unit-tests for this rather important function.\n+// It is primarily exercised via goto definition tests in `ra_ide`.\n pub fn classify_name_ref(\n     sema: &Semantics<RootDatabase>,\n     name_ref: &ast::NameRef,\n@@ -212,22 +212,18 @@ pub fn classify_name_ref(\n     let parent = name_ref.syntax().parent()?;\n \n     if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n-        tested_by!(goto_def_for_methods; force);\n         if let Some(func) = sema.resolve_method_call(&method_call) {\n             return Some(NameRefClass::Definition(Definition::ModuleDef(func.into())));\n         }\n     }\n \n     if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n-        tested_by!(goto_def_for_fields; force);\n         if let Some(field) = sema.resolve_field(&field_expr) {\n             return Some(NameRefClass::Definition(Definition::Field(field)));\n         }\n     }\n \n     if let Some(record_field) = ast::RecordField::for_field_name(name_ref) {\n-        tested_by!(goto_def_for_record_fields; force);\n-        tested_by!(goto_def_for_field_init_shorthand; force);\n         if let Some((field, local)) = sema.resolve_record_field(&record_field) {\n             let field = Definition::Field(field);\n             let res = match local {\n@@ -239,15 +235,13 @@ pub fn classify_name_ref(\n     }\n \n     if let Some(record_field_pat) = ast::RecordFieldPat::cast(parent.clone()) {\n-        tested_by!(goto_def_for_record_field_pats; force);\n         if let Some(field) = sema.resolve_record_field_pat(&record_field_pat) {\n             let field = Definition::Field(field);\n             return Some(NameRefClass::Definition(field));\n         }\n     }\n \n     if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n-        tested_by!(goto_def_for_macros; force);\n         if let Some(macro_def) = sema.resolve_macro_call(&macro_call) {\n             return Some(NameRefClass::Definition(Definition::Macro(macro_def)));\n         }"}, {"sha": "4f37954bf7f09e4d354f2cc55d43412a9f9aac2c", "filename": "crates/ra_ide_db/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Flib.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -2,7 +2,6 @@\n //!\n //! It is mainly a `HirDatabase` for semantic analysis, plus a `SymbolsDatabase`, for fuzzy search.\n \n-pub mod marks;\n pub mod line_index;\n pub mod line_index_utils;\n pub mod symbol_index;"}, {"sha": "386fe605c74884c7ee29657b7443c0ddb48ff74a", "filename": "crates/ra_ide_db/src/marks.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6143742bd4e625d391ac3ea860be7578ab9f53f/crates%2Fra_ide_db%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6143742bd4e625d391ac3ea860be7578ab9f53f/crates%2Fra_ide_db%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fmarks.rs?ref=c6143742bd4e625d391ac3ea860be7578ab9f53f", "patch": "@@ -1,12 +0,0 @@\n-//! See test_utils/src/marks.rs\n-\n-test_utils::marks![\n-    goto_def_for_macros\n-    goto_def_for_use_alias\n-    goto_def_for_methods\n-    goto_def_for_fields\n-    goto_def_for_record_fields\n-    goto_def_for_field_init_shorthand\n-    goto_def_for_record_field_pats\n-    search_filters_by_range\n-];"}, {"sha": "589f4477192609a13f94807bf3ecf384ad77754a", "filename": "crates/ra_ide_db/src/search.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -12,7 +12,6 @@ use ra_db::{FileId, FileRange, SourceDatabaseExt};\n use ra_prof::profile;\n use ra_syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n use rustc_hash::FxHashMap;\n-use test_utils::tested_by;\n \n use crate::{\n     defs::{classify_name_ref, Definition, NameRefClass},\n@@ -209,7 +208,6 @@ impl Definition {\n             for (idx, _) in text.match_indices(pat) {\n                 let offset: TextSize = idx.try_into().unwrap();\n                 if !search_range.contains_inclusive(offset) {\n-                    tested_by!(search_filters_by_range; force);\n                     continue;\n                 }\n "}, {"sha": "94e118dd8cab14c7108313947d6bd119d304d8f9", "filename": "crates/ra_ide_db/src/source_change.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide_db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_ide_db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsource_change.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -4,7 +4,7 @@\n //! It can be viewed as a dual for `AnalysisChange`.\n \n use ra_db::{FileId, FilePosition, RelativePathBuf, SourceRootId};\n-use ra_text_edit::{TextEdit, TextSize};\n+use ra_text_edit::TextEdit;\n \n #[derive(Debug, Clone)]\n pub struct SourceChange {\n@@ -13,6 +13,7 @@ pub struct SourceChange {\n     pub source_file_edits: Vec<SourceFileEdit>,\n     pub file_system_edits: Vec<FileSystemEdit>,\n     pub cursor_position: Option<FilePosition>,\n+    pub is_snippet: bool,\n }\n \n impl SourceChange {\n@@ -28,6 +29,7 @@ impl SourceChange {\n             source_file_edits,\n             file_system_edits,\n             cursor_position: None,\n+            is_snippet: false,\n         }\n     }\n \n@@ -41,6 +43,7 @@ impl SourceChange {\n             source_file_edits: edits,\n             file_system_edits: vec![],\n             cursor_position: None,\n+            is_snippet: false,\n         }\n     }\n \n@@ -52,6 +55,7 @@ impl SourceChange {\n             source_file_edits: vec![],\n             file_system_edits: edits,\n             cursor_position: None,\n+            is_snippet: false,\n         }\n     }\n \n@@ -105,7 +109,6 @@ pub enum FileSystemEdit {\n pub struct SingleFileChange {\n     pub label: String,\n     pub edit: TextEdit,\n-    pub cursor_position: Option<TextSize>,\n }\n \n impl SingleFileChange {\n@@ -114,7 +117,8 @@ impl SingleFileChange {\n             label: self.label,\n             source_file_edits: vec![SourceFileEdit { file_id, edit: self.edit }],\n             file_system_edits: Vec::new(),\n-            cursor_position: self.cursor_position.map(|offset| FilePosition { file_id, offset }),\n+            cursor_position: None,\n+            is_snippet: false,\n         }\n     }\n }"}, {"sha": "7c9bb4d00e1a2f5f4d036eaa53393c8a5b77a7a9", "filename": "crates/ra_mbe/src/mbe_expander/transcriber.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,4 +1,4 @@\n-//! Transcraber takes a template, like `fn $ident() {}`, a set of bindings like\n+//! Transcriber takes a template, like `fn $ident() {}`, a set of bindings like\n //! `$ident => foo`, interpolates variables in the template, to get `fn foo() {}`\n \n use ra_syntax::SmolStr;\n@@ -53,7 +53,8 @@ impl Bindings {\n pub(super) fn transcribe(template: &tt::Subtree, bindings: &Bindings) -> ExpandResult<tt::Subtree> {\n     assert!(template.delimiter == None);\n     let mut ctx = ExpandCtx { bindings: &bindings, nesting: Vec::new() };\n-    expand_subtree(&mut ctx, template)\n+    let mut arena: Vec<tt::TokenTree> = Vec::new();\n+    expand_subtree(&mut ctx, template, &mut arena)\n }\n \n #[derive(Debug)]\n@@ -73,8 +74,13 @@ struct ExpandCtx<'a> {\n     nesting: Vec<NestingState>,\n }\n \n-fn expand_subtree(ctx: &mut ExpandCtx, template: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n-    let mut buf: Vec<tt::TokenTree> = Vec::new();\n+fn expand_subtree(\n+    ctx: &mut ExpandCtx,\n+    template: &tt::Subtree,\n+    arena: &mut Vec<tt::TokenTree>,\n+) -> ExpandResult<tt::Subtree> {\n+    // remember how many elements are in the arena now - when returning, we want to drain exactly how many elements we added. This way, the recursive uses of the arena get their own \"view\" of the arena, but will reuse the allocation\n+    let start_elements = arena.len();\n     let mut err = None;\n     for op in parse_template(template) {\n         let op = match op {\n@@ -85,25 +91,27 @@ fn expand_subtree(ctx: &mut ExpandCtx, template: &tt::Subtree) -> ExpandResult<t\n             }\n         };\n         match op {\n-            Op::TokenTree(tt @ tt::TokenTree::Leaf(..)) => buf.push(tt.clone()),\n+            Op::TokenTree(tt @ tt::TokenTree::Leaf(..)) => arena.push(tt.clone()),\n             Op::TokenTree(tt::TokenTree::Subtree(tt)) => {\n-                let ExpandResult(tt, e) = expand_subtree(ctx, tt);\n+                let ExpandResult(tt, e) = expand_subtree(ctx, tt, arena);\n                 err = err.or(e);\n-                buf.push(tt.into());\n+                arena.push(tt.into());\n             }\n             Op::Var { name, kind: _ } => {\n                 let ExpandResult(fragment, e) = expand_var(ctx, name);\n                 err = err.or(e);\n-                push_fragment(&mut buf, fragment);\n+                push_fragment(arena, fragment);\n             }\n             Op::Repeat { subtree, kind, separator } => {\n-                let ExpandResult(fragment, e) = expand_repeat(ctx, subtree, kind, separator);\n+                let ExpandResult(fragment, e) = expand_repeat(ctx, subtree, kind, separator, arena);\n                 err = err.or(e);\n-                push_fragment(&mut buf, fragment)\n+                push_fragment(arena, fragment)\n             }\n         }\n     }\n-    ExpandResult(tt::Subtree { delimiter: template.delimiter, token_trees: buf }, err)\n+    // drain the elements added in this instance of expand_subtree\n+    let tts = arena.drain(start_elements..arena.len()).collect();\n+    ExpandResult(tt::Subtree { delimiter: template.delimiter, token_trees: tts }, err)\n }\n \n fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> ExpandResult<Fragment> {\n@@ -155,6 +163,7 @@ fn expand_repeat(\n     template: &tt::Subtree,\n     kind: RepeatKind,\n     separator: Option<Separator>,\n+    arena: &mut Vec<tt::TokenTree>,\n ) -> ExpandResult<Fragment> {\n     let mut buf: Vec<tt::TokenTree> = Vec::new();\n     ctx.nesting.push(NestingState { idx: 0, at_end: false, hit: false });\n@@ -165,7 +174,7 @@ fn expand_repeat(\n     let mut counter = 0;\n \n     loop {\n-        let ExpandResult(mut t, e) = expand_subtree(ctx, template);\n+        let ExpandResult(mut t, e) = expand_subtree(ctx, template, arena);\n         let nesting_state = ctx.nesting.last_mut().unwrap();\n         if nesting_state.at_end || !nesting_state.hit {\n             break;"}, {"sha": "eeb8ad66bd16b3df4339141b111cbf12c094f47a", "filename": "crates/ra_parser/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_parser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_parser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Flib.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -25,7 +25,7 @@ pub(crate) use token_set::TokenSet;\n pub use syntax_kind::SyntaxKind;\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ParseError(pub String);\n+pub struct ParseError(pub Box<String>);\n \n /// `TokenSource` abstracts the source of the tokens parser operates on.\n ///"}, {"sha": "4f59b0a2356fe7a6ee33b7143e703176e1e93be2", "filename": "crates/ra_parser/src/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_parser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_parser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fparser.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -192,7 +192,7 @@ impl<'t> Parser<'t> {\n     /// structured errors with spans and notes, like rustc\n     /// does.\n     pub(crate) fn error<T: Into<String>>(&mut self, message: T) {\n-        let msg = ParseError(message.into());\n+        let msg = ParseError(Box::new(message.into()));\n         self.push_event(Event::Error { msg })\n     }\n "}, {"sha": "664894d1f839cfba0e1259bc625016fae30ad9d4", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -266,6 +266,15 @@ impl<'a> SyntaxRewriter<'a> {\n         let replacement = Replacement::Single(with.clone().into());\n         self.replacements.insert(what, replacement);\n     }\n+    pub fn replace_with_many<T: Clone + Into<SyntaxElement>>(\n+        &mut self,\n+        what: &T,\n+        with: Vec<SyntaxElement>,\n+    ) {\n+        let what = what.clone().into();\n+        let replacement = Replacement::Many(with);\n+        self.replacements.insert(what, replacement);\n+    }\n     pub fn replace_ast<T: AstNode>(&mut self, what: &T, with: &T) {\n         self.replace(what.syntax(), with.syntax())\n     }\n@@ -302,31 +311,41 @@ impl<'a> SyntaxRewriter<'a> {\n \n     fn rewrite_children(&self, node: &SyntaxNode) -> SyntaxNode {\n         //  FIXME: this could be made much faster.\n-        let new_children =\n-            node.children_with_tokens().flat_map(|it| self.rewrite_self(&it)).collect::<Vec<_>>();\n+        let mut new_children = Vec::new();\n+        for child in node.children_with_tokens() {\n+            self.rewrite_self(&mut new_children, &child);\n+        }\n         with_children(node, new_children)\n     }\n \n     fn rewrite_self(\n         &self,\n+        acc: &mut Vec<NodeOrToken<rowan::GreenNode, rowan::GreenToken>>,\n         element: &SyntaxElement,\n-    ) -> Option<NodeOrToken<rowan::GreenNode, rowan::GreenToken>> {\n+    ) {\n         if let Some(replacement) = self.replacement(&element) {\n-            return match replacement {\n+            match replacement {\n                 Replacement::Single(NodeOrToken::Node(it)) => {\n-                    Some(NodeOrToken::Node(it.green().clone()))\n+                    acc.push(NodeOrToken::Node(it.green().clone()))\n                 }\n                 Replacement::Single(NodeOrToken::Token(it)) => {\n-                    Some(NodeOrToken::Token(it.green().clone()))\n+                    acc.push(NodeOrToken::Token(it.green().clone()))\n                 }\n-                Replacement::Delete => None,\n+                Replacement::Many(replacements) => {\n+                    acc.extend(replacements.iter().map(|it| match it {\n+                        NodeOrToken::Node(it) => NodeOrToken::Node(it.green().clone()),\n+                        NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),\n+                    }))\n+                }\n+                Replacement::Delete => (),\n             };\n+            return;\n         }\n         let res = match element {\n             NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),\n             NodeOrToken::Node(it) => NodeOrToken::Node(self.rewrite_children(it).green().clone()),\n         };\n-        Some(res)\n+        acc.push(res)\n     }\n }\n \n@@ -341,6 +360,7 @@ impl ops::AddAssign for SyntaxRewriter<'_> {\n enum Replacement {\n     Delete,\n     Single(SyntaxElement),\n+    Many(Vec<SyntaxElement>),\n }\n \n fn with_children("}, {"sha": "29eb3fcb9ccca443055ef4c2bde26bf8f5735aac", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,7 +1,10 @@\n //! This module contains functions for editing syntax trees. As the trees are\n //! immutable, all function here return a fresh copy of the tree, instead of\n //! doing an in-place modification.\n-use std::{iter, ops::RangeInclusive};\n+use std::{\n+    fmt, iter,\n+    ops::{self, RangeInclusive},\n+};\n \n use arrayvec::ArrayVec;\n \n@@ -437,6 +440,28 @@ impl From<u8> for IndentLevel {\n     }\n }\n \n+impl fmt::Display for IndentLevel {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let spaces = \"                                        \";\n+        let buf;\n+        let len = self.0 as usize * 4;\n+        let indent = if len <= spaces.len() {\n+            &spaces[..len]\n+        } else {\n+            buf = iter::repeat(' ').take(len).collect::<String>();\n+            &buf\n+        };\n+        fmt::Display::fmt(indent, f)\n+    }\n+}\n+\n+impl ops::Add<u8> for IndentLevel {\n+    type Output = IndentLevel;\n+    fn add(self, rhs: u8) -> IndentLevel {\n+        IndentLevel(self.0 + rhs)\n+    }\n+}\n+\n impl IndentLevel {\n     pub fn from_node(node: &SyntaxNode) -> IndentLevel {\n         let first_token = match node.first_token() {\n@@ -453,6 +478,14 @@ impl IndentLevel {\n         IndentLevel(0)\n     }\n \n+    /// XXX: this intentionally doesn't change the indent of the very first token.\n+    /// Ie, in something like\n+    /// ```\n+    /// fn foo() {\n+    ///    92\n+    /// }\n+    /// ```\n+    /// if you indent the block, the `{` token would stay put.\n     fn increase_indent(self, node: SyntaxNode) -> SyntaxNode {\n         let mut rewriter = SyntaxRewriter::default();\n         node.descendants_with_tokens()\n@@ -463,12 +496,7 @@ impl IndentLevel {\n                 text.contains('\\n')\n             })\n             .for_each(|ws| {\n-                let new_ws = make::tokens::whitespace(&format!(\n-                    \"{}{:width$}\",\n-                    ws.syntax().text(),\n-                    \"\",\n-                    width = self.0 as usize * 4\n-                ));\n+                let new_ws = make::tokens::whitespace(&format!(\"{}{}\", ws.syntax(), self,));\n                 rewriter.replace(ws.syntax(), &new_ws)\n             });\n         rewriter.rewrite(&node)\n@@ -485,7 +513,7 @@ impl IndentLevel {\n             })\n             .for_each(|ws| {\n                 let new_ws = make::tokens::whitespace(\n-                    &ws.syntax().text().replace(&format!(\"\\n{:1$}\", \"\", self.0 as usize * 4), \"\\n\"),\n+                    &ws.syntax().text().replace(&format!(\"\\n{}\", self), \"\\n\"),\n                 );\n                 rewriter.replace(ws.syntax(), &new_ws)\n             });"}, {"sha": "da0eb09267ffe9eef47c0acaf689023618dabe1f", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,5 +1,9 @@\n //! This module contains free-standing functions for creating AST fragments out\n //! of smaller pieces.\n+//!\n+//! Note that all functions here intended to be stupid constructors, which just\n+//! assemble a finish node from immediate children. If you want to do something\n+//! smarter than that, it probably doesn't belong in this module.\n use itertools::Itertools;\n use stdx::format_to;\n \n@@ -95,6 +99,9 @@ pub fn expr_empty_block() -> ast::Expr {\n pub fn expr_unimplemented() -> ast::Expr {\n     expr_from_text(\"unimplemented!()\")\n }\n+pub fn expr_unreachable() -> ast::Expr {\n+    expr_from_text(\"unreachable!()\")\n+}\n pub fn expr_todo() -> ast::Expr {\n     expr_from_text(\"todo!()\")\n }\n@@ -264,10 +271,6 @@ pub fn token(kind: SyntaxKind) -> SyntaxToken {\n         .unwrap_or_else(|| panic!(\"unhandled token: {:?}\", kind))\n }\n \n-pub fn unreachable_macro_call() -> ast::MacroCall {\n-    ast_from_text(&format!(\"unreachable!()\"))\n-}\n-\n pub fn param(name: String, ty: String) -> ast::Param {\n     ast_from_text(&format!(\"fn f({}: {}) {{ }}\", name, ty))\n }\n@@ -277,29 +280,24 @@ pub fn param_list(pats: impl IntoIterator<Item = ast::Param>) -> ast::ParamList\n     ast_from_text(&format!(\"fn f({}) {{ }}\", args))\n }\n \n+pub fn visibility_pub_crate() -> ast::Visibility {\n+    ast_from_text(\"pub(crate) struct S\")\n+}\n+\n pub fn fn_def(\n+    visibility: Option<ast::Visibility>,\n     fn_name: ast::Name,\n     type_params: Option<ast::TypeParamList>,\n     params: ast::ParamList,\n     body: ast::BlockExpr,\n ) -> ast::FnDef {\n     let type_params =\n         if let Some(type_params) = type_params { format!(\"<{}>\", type_params) } else { \"\".into() };\n-    ast_from_text(&format!(\"fn {}{}{} {}\", fn_name, type_params, params, body))\n-}\n-\n-pub fn add_leading_newlines(amount_of_newlines: usize, t: impl AstNode) -> ast::SourceFile {\n-    let newlines = \"\\n\".repeat(amount_of_newlines);\n-    ast_from_text(&format!(\"{}{}\", newlines, t.syntax()))\n-}\n-\n-pub fn add_trailing_newlines(amount_of_newlines: usize, t: impl AstNode) -> ast::SourceFile {\n-    let newlines = \"\\n\".repeat(amount_of_newlines);\n-    ast_from_text(&format!(\"{}{}\", t.syntax(), newlines))\n-}\n-\n-pub fn add_pub_crate_modifier(fn_def: ast::FnDef) -> ast::FnDef {\n-    ast_from_text(&format!(\"pub(crate) {}\", fn_def))\n+    let visibility = match visibility {\n+        None => String::new(),\n+        Some(it) => format!(\"{} \", it),\n+    };\n+    ast_from_text(&format!(\"{}fn {}{}{} {}\", visibility, fn_name, type_params, params, body))\n }\n \n fn ast_from_text<N: AstNode>(text: &str) -> N {"}, {"sha": "e566af7e87acc2271a192c8d50b0ee0413817cad", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -70,6 +70,6 @@ impl SyntaxTreeBuilder {\n     }\n \n     pub fn error(&mut self, error: ra_parser::ParseError, text_pos: TextSize) {\n-        self.errors.push(SyntaxError::new_at_offset(error.0, text_pos))\n+        self.errors.push(SyntaxError::new_at_offset(*error.0, text_pos))\n     }\n }"}, {"sha": "5967f44cd08def64eb740335f25a67f9e049985b", "filename": "crates/ra_tt/src/buffer.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_tt%2Fsrc%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fra_tt%2Fsrc%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tt%2Fsrc%2Fbuffer.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -42,7 +42,9 @@ impl<'t> TokenBuffer<'t> {\n         buffers: &mut Vec<Box<[Entry<'t>]>>,\n         next: Option<EntryPtr>,\n     ) -> usize {\n-        let mut entries = vec![];\n+        // Must contain everything in tokens and then the Entry::End\n+        let start_capacity = tokens.len() + 1;\n+        let mut entries = Vec::with_capacity(start_capacity);\n         let mut children = vec![];\n \n         for (idx, tt) in tokens.iter().enumerate() {"}, {"sha": "b20efe98d8cb2156547443ae367666f32c02eb32", "filename": "crates/rust-analyzer/src/cli/analysis_bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -105,7 +105,7 @@ pub fn analysis_bench(\n             if is_completion {\n                 let options = CompletionConfig::default();\n                 let res = do_work(&mut host, file_id, |analysis| {\n-                    analysis.completions(file_position, &options)\n+                    analysis.completions(&options, file_position)\n                 });\n                 if verbosity.is_verbose() {\n                     println!(\"\\n{:#?}\", res);"}, {"sha": "d75c48597bce46abb4494d53304d87957c2c95cf", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -11,7 +11,7 @@ use std::{ffi::OsString, path::PathBuf};\n \n use lsp_types::ClientCapabilities;\n use ra_flycheck::FlycheckConfig;\n-use ra_ide::{CompletionConfig, InlayHintsConfig};\n+use ra_ide::{AssistConfig, CompletionConfig, InlayHintsConfig};\n use ra_project_model::CargoConfig;\n use serde::Deserialize;\n \n@@ -32,7 +32,38 @@ pub struct Config {\n \n     pub inlay_hints: InlayHintsConfig,\n     pub completion: CompletionConfig,\n+    pub assist: AssistConfig,\n     pub call_info_full: bool,\n+    pub lens: LensConfig,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct LensConfig {\n+    pub run: bool,\n+    pub debug: bool,\n+    pub impementations: bool,\n+}\n+\n+impl Default for LensConfig {\n+    fn default() -> Self {\n+        Self { run: true, debug: true, impementations: true }\n+    }\n+}\n+\n+impl LensConfig {\n+    pub const NO_LENS: LensConfig = Self { run: false, debug: false, impementations: false };\n+\n+    pub fn any(&self) -> bool {\n+        self.impementations || self.runnable()\n+    }\n+\n+    pub fn none(&self) -> bool {\n+        !self.any()\n+    }\n+\n+    pub fn runnable(&self) -> bool {\n+        self.run || self.debug\n+    }\n }\n \n #[derive(Debug, Clone)]\n@@ -106,7 +137,9 @@ impl Default for Config {\n                 add_call_argument_snippets: true,\n                 ..CompletionConfig::default()\n             },\n+            assist: AssistConfig::default(),\n             call_info_full: true,\n+            lens: LensConfig::default(),\n         }\n     }\n }\n@@ -196,6 +229,16 @@ impl Config {\n         set(value, \"/completion/addCallArgumentSnippets\", &mut self.completion.add_call_argument_snippets);\n         set(value, \"/callInfo/full\", &mut self.call_info_full);\n \n+        let mut lens_enabled = true;\n+        set(value, \"/lens/enable\", &mut lens_enabled);\n+        if lens_enabled {\n+            set(value, \"/lens/run\", &mut self.lens.run);\n+            set(value, \"/lens/debug\", &mut self.lens.debug);\n+            set(value, \"/lens/implementations\", &mut self.lens.impementations);\n+        } else {\n+            self.lens = LensConfig::NO_LENS;\n+        }\n+\n         log::info!(\"Config::update() = {:#?}\", self);\n \n         fn get<'a, T: Deserialize<'a>>(value: &'a serde_json::Value, pointer: &str) -> Option<T> {\n@@ -232,6 +275,7 @@ impl Config {\n             {\n                 self.client_caps.code_action_literals = value;\n             }\n+\n             self.completion.allow_snippets(false);\n             if let Some(completion) = &doc_caps.completion {\n                 if let Some(completion_item) = &completion.completion_item {\n@@ -247,5 +291,12 @@ impl Config {\n                 self.client_caps.work_done_progress = value;\n             }\n         }\n+\n+        self.assist.allow_snippets(false);\n+        if let Some(experimental) = &caps.experimental {\n+            let enable =\n+                experimental.get(\"snippetTextEdit\").and_then(|it| it.as_bool()) == Some(true);\n+            self.assist.allow_snippets(enable);\n+        }\n     }\n }"}, {"sha": "25856c5436b47d12a5ac141d62cf63b7eb61cb7c", "filename": "crates/rust-analyzer/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -3,9 +3,11 @@ pub(crate) mod to_proto;\n \n use std::{collections::HashMap, sync::Arc};\n \n-use lsp_types::{CodeActionOrCommand, Diagnostic, Range};\n+use lsp_types::{Diagnostic, Range};\n use ra_ide::FileId;\n \n+use crate::lsp_ext;\n+\n pub type CheckFixes = Arc<HashMap<FileId, Vec<Fix>>>;\n \n #[derive(Debug, Default, Clone)]\n@@ -18,13 +20,13 @@ pub struct DiagnosticCollection {\n #[derive(Debug, Clone)]\n pub struct Fix {\n     pub range: Range,\n-    pub action: CodeActionOrCommand,\n+    pub action: lsp_ext::CodeAction,\n }\n \n #[derive(Debug)]\n pub enum DiagnosticTask {\n     ClearCheck,\n-    AddCheck(FileId, Diagnostic, Vec<CodeActionOrCommand>),\n+    AddCheck(FileId, Diagnostic, Vec<lsp_ext::CodeAction>),\n     SetNative(FileId, Vec<Diagnostic>),\n }\n \n@@ -38,7 +40,7 @@ impl DiagnosticCollection {\n         &mut self,\n         file_id: FileId,\n         diagnostic: Diagnostic,\n-        fixes: Vec<CodeActionOrCommand>,\n+        fixes: Vec<lsp_ext::CodeAction>,\n     ) {\n         let diagnostics = self.check.entry(file_id).or_default();\n         for existing_diagnostic in diagnostics.iter() {"}, {"sha": "96466b5c90b3002efd484f20078bb512445c02cb", "filename": "crates/rust-analyzer/src/diagnostics/snapshots/rust_analyzer__diagnostics__to_proto__tests__snap_multi_line_fix.snap", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_multi_line_fix.snap", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_multi_line_fix.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_multi_line_fix.snap?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -68,9 +68,9 @@ expression: diag\n                 kind: Some(\n                     \"quickfix\",\n                 ),\n-                diagnostics: None,\n+                command: None,\n                 edit: Some(\n-                    WorkspaceEdit {\n+                    SnippetWorkspaceEdit {\n                         changes: Some(\n                             {\n                                 \"file:///test/src/main.rs\": [\n@@ -106,8 +106,6 @@ expression: diag\n                         document_changes: None,\n                     },\n                 ),\n-                command: None,\n-                is_preferred: None,\n             },\n         ],\n     },"}, {"sha": "8f962277f079c0e399b3aaa9bf6597b2beacbc3a", "filename": "crates/rust-analyzer/src/diagnostics/snapshots/rust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -53,9 +53,9 @@ expression: diag\n                 kind: Some(\n                     \"quickfix\",\n                 ),\n-                diagnostics: None,\n+                command: None,\n                 edit: Some(\n-                    WorkspaceEdit {\n+                    SnippetWorkspaceEdit {\n                         changes: Some(\n                             {\n                                 \"file:///test/driver/subcommand/repl.rs\": [\n@@ -78,8 +78,6 @@ expression: diag\n                         document_changes: None,\n                     },\n                 ),\n-                command: None,\n-                is_preferred: None,\n             },\n         ],\n     },"}, {"sha": "afea595254622ed66178a03dca41115c67c787b0", "filename": "crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -7,13 +7,13 @@ use std::{\n };\n \n use lsp_types::{\n-    CodeAction, Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag,\n-    Location, NumberOrString, Position, Range, TextEdit, Url, WorkspaceEdit,\n+    Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Location,\n+    NumberOrString, Position, Range, TextEdit, Url,\n };\n use ra_flycheck::{Applicability, DiagnosticLevel, DiagnosticSpan, DiagnosticSpanMacroExpansion};\n use stdx::format_to;\n \n-use crate::Result;\n+use crate::{lsp_ext, Result};\n \n /// Converts a Rust level string to a LSP severity\n fn map_level_to_severity(val: DiagnosticLevel) -> Option<DiagnosticSeverity> {\n@@ -110,7 +110,7 @@ fn is_deprecated(rd: &ra_flycheck::Diagnostic) -> bool {\n \n enum MappedRustChildDiagnostic {\n     Related(DiagnosticRelatedInformation),\n-    SuggestedFix(CodeAction),\n+    SuggestedFix(lsp_ext::CodeAction),\n     MessageLine(String),\n }\n \n@@ -143,13 +143,15 @@ fn map_rust_child_diagnostic(\n             message: rd.message.clone(),\n         })\n     } else {\n-        MappedRustChildDiagnostic::SuggestedFix(CodeAction {\n+        MappedRustChildDiagnostic::SuggestedFix(lsp_ext::CodeAction {\n             title: rd.message.clone(),\n             kind: Some(\"quickfix\".to_string()),\n-            diagnostics: None,\n-            edit: Some(WorkspaceEdit::new(edit_map)),\n+            edit: Some(lsp_ext::SnippetWorkspaceEdit {\n+                // FIXME: there's no good reason to use edit_map here....\n+                changes: Some(edit_map),\n+                document_changes: None,\n+            }),\n             command: None,\n-            is_preferred: None,\n         })\n     }\n }\n@@ -158,7 +160,7 @@ fn map_rust_child_diagnostic(\n pub(crate) struct MappedRustDiagnostic {\n     pub location: Location,\n     pub diagnostic: Diagnostic,\n-    pub fixes: Vec<CodeAction>,\n+    pub fixes: Vec<lsp_ext::CodeAction>,\n }\n \n /// Converts a Rust root diagnostic to LSP form"}, {"sha": "f75a26eb79672601e29ccdc8477946b544fd59ff", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -1,6 +1,6 @@\n //! rust-analyzer extensions to the LSP.\n \n-use std::path::PathBuf;\n+use std::{collections::HashMap, path::PathBuf};\n \n use lsp_types::request::Request;\n use lsp_types::{Location, Position, Range, TextDocumentIdentifier};\n@@ -137,7 +137,7 @@ pub struct Runnable {\n #[serde(rename_all = \"camelCase\")]\n pub struct SourceChange {\n     pub label: String,\n-    pub workspace_edit: lsp_types::WorkspaceEdit,\n+    pub workspace_edit: SnippetWorkspaceEdit,\n     pub cursor_position: Option<lsp_types::TextDocumentPositionParams>,\n }\n \n@@ -183,3 +183,54 @@ pub struct SsrParams {\n     pub query: String,\n     pub parse_only: bool,\n }\n+\n+pub enum CodeActionRequest {}\n+\n+impl Request for CodeActionRequest {\n+    type Params = lsp_types::CodeActionParams;\n+    type Result = Option<Vec<CodeAction>>;\n+    const METHOD: &'static str = \"textDocument/codeAction\";\n+}\n+\n+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]\n+pub struct CodeAction {\n+    pub title: String,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub kind: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub command: Option<lsp_types::Command>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub edit: Option<SnippetWorkspaceEdit>,\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct SnippetWorkspaceEdit {\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub changes: Option<HashMap<lsp_types::Url, Vec<lsp_types::TextEdit>>>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub document_changes: Option<Vec<SnippetDocumentChangeOperation>>,\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]\n+#[serde(untagged, rename_all = \"lowercase\")]\n+pub enum SnippetDocumentChangeOperation {\n+    Op(lsp_types::ResourceOp),\n+    Edit(SnippetTextDocumentEdit),\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct SnippetTextDocumentEdit {\n+    pub text_document: lsp_types::VersionedTextDocumentIdentifier,\n+    pub edits: Vec<SnippetTextEdit>,\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct SnippetTextEdit {\n+    pub range: Range,\n+    pub new_text: String,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub insert_text_format: Option<lsp_types::InsertTextFormat>,\n+}"}, {"sha": "87795fffbd6742189c164dcccd9165304f161ccd", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -518,14 +518,14 @@ fn on_request(\n         .on::<lsp_ext::ParentModule>(handlers::handle_parent_module)?\n         .on::<lsp_ext::Runnables>(handlers::handle_runnables)?\n         .on::<lsp_ext::InlayHints>(handlers::handle_inlay_hints)?\n+        .on::<lsp_ext::CodeActionRequest>(handlers::handle_code_action)?\n         .on::<lsp_types::request::OnTypeFormatting>(handlers::handle_on_type_formatting)?\n         .on::<lsp_types::request::DocumentSymbolRequest>(handlers::handle_document_symbol)?\n         .on::<lsp_types::request::WorkspaceSymbol>(handlers::handle_workspace_symbol)?\n         .on::<lsp_types::request::GotoDefinition>(handlers::handle_goto_definition)?\n         .on::<lsp_types::request::GotoImplementation>(handlers::handle_goto_implementation)?\n         .on::<lsp_types::request::GotoTypeDefinition>(handlers::handle_goto_type_definition)?\n         .on::<lsp_types::request::Completion>(handlers::handle_completion)?\n-        .on::<lsp_types::request::CodeActionRequest>(handlers::handle_code_action)?\n         .on::<lsp_types::request::CodeLensRequest>(handlers::handle_code_lens)?\n         .on::<lsp_types::request::CodeLensResolve>(handlers::handle_code_lens_resolve)?\n         .on::<lsp_types::request::FoldingRangeRequest>(handlers::handle_folding_range)?"}, {"sha": "cc9abd162bb1a5826255c74f01f762b526323f9f", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 124, "deletions": 130, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -11,12 +11,11 @@ use lsp_server::ErrorCode;\n use lsp_types::{\n     CallHierarchyIncomingCall, CallHierarchyIncomingCallsParams, CallHierarchyItem,\n     CallHierarchyOutgoingCall, CallHierarchyOutgoingCallsParams, CallHierarchyPrepareParams,\n-    CodeAction, CodeActionResponse, CodeLens, Command, CompletionItem, Diagnostic,\n-    DocumentFormattingParams, DocumentHighlight, DocumentSymbol, FoldingRange, FoldingRangeParams,\n-    Hover, HoverContents, Location, MarkupContent, MarkupKind, Position, PrepareRenameResponse,\n-    Range, RenameParams, SemanticTokensParams, SemanticTokensRangeParams,\n-    SemanticTokensRangeResult, SemanticTokensResult, SymbolInformation, TextDocumentIdentifier,\n-    TextEdit, Url, WorkspaceEdit,\n+    CodeLens, Command, CompletionItem, Diagnostic, DocumentFormattingParams, DocumentHighlight,\n+    DocumentSymbol, FoldingRange, FoldingRangeParams, Hover, HoverContents, Location,\n+    MarkupContent, MarkupKind, Position, PrepareRenameResponse, Range, RenameParams,\n+    SemanticTokensParams, SemanticTokensRangeParams, SemanticTokensRangeResult,\n+    SemanticTokensResult, SymbolInformation, TextDocumentIdentifier, TextEdit, Url, WorkspaceEdit,\n };\n use ra_ide::{\n     Assist, FileId, FilePosition, FileRange, Query, RangeInfo, Runnable, RunnableKind, SearchScope,\n@@ -476,7 +475,7 @@ pub fn handle_completion(\n         return Ok(None);\n     }\n \n-    let items = match world.analysis().completions(position, &world.config.completion)? {\n+    let items = match world.analysis().completions(&world.config.completion, position)? {\n         None => return Ok(None),\n         Some(items) => items,\n     };\n@@ -585,9 +584,8 @@ pub fn handle_rename(world: WorldSnapshot, params: RenameParams) -> Result<Optio\n         None => return Ok(None),\n         Some(it) => it.info,\n     };\n-\n-    let source_change = to_proto::source_change(&world, source_change)?;\n-    Ok(Some(source_change.workspace_edit))\n+    let workspace_edit = to_proto::workspace_edit(&world, source_change)?;\n+    Ok(Some(workspace_edit))\n }\n \n pub fn handle_references(\n@@ -696,14 +694,21 @@ pub fn handle_formatting(\n pub fn handle_code_action(\n     world: WorldSnapshot,\n     params: lsp_types::CodeActionParams,\n-) -> Result<Option<CodeActionResponse>> {\n+) -> Result<Option<Vec<lsp_ext::CodeAction>>> {\n     let _p = profile(\"handle_code_action\");\n+    // We intentionally don't support command-based actions, as those either\n+    // requires custom client-code anyway, or requires server-initiated edits.\n+    // Server initiated edits break causality, so we avoid those as well.\n+    if !world.config.client_caps.code_action_literals {\n+        return Ok(None);\n+    }\n+\n     let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n     let range = from_proto::text_range(&line_index, params.range);\n \n     let diagnostics = world.analysis().diagnostics(file_id)?;\n-    let mut res = CodeActionResponse::default();\n+    let mut res: Vec<lsp_ext::CodeAction> = Vec::new();\n \n     let fixes_from_diagnostics = diagnostics\n         .into_iter()\n@@ -713,22 +718,9 @@ pub fn handle_code_action(\n \n     for source_edit in fixes_from_diagnostics {\n         let title = source_edit.label.clone();\n-        let edit = to_proto::source_change(&world, source_edit)?;\n-\n-        let command = Command {\n-            title,\n-            command: \"rust-analyzer.applySourceChange\".to_string(),\n-            arguments: Some(vec![to_value(edit).unwrap()]),\n-        };\n-        let action = CodeAction {\n-            title: command.title.clone(),\n-            kind: None,\n-            diagnostics: None,\n-            edit: None,\n-            command: Some(command),\n-            is_preferred: None,\n-        };\n-        res.push(action.into());\n+        let edit = to_proto::snippet_workspace_edit(&world, source_edit)?;\n+        let action = lsp_ext::CodeAction { title, kind: None, edit: Some(edit), command: None };\n+        res.push(action);\n     }\n \n     for fix in world.check_fixes.get(&file_id).into_iter().flatten() {\n@@ -740,14 +732,21 @@ pub fn handle_code_action(\n     }\n \n     let mut grouped_assists: FxHashMap<String, (usize, Vec<Assist>)> = FxHashMap::default();\n-    for assist in world.analysis().assists(FileRange { file_id, range })?.into_iter() {\n+    for assist in\n+        world.analysis().assists(&world.config.assist, FileRange { file_id, range })?.into_iter()\n+    {\n         match &assist.group_label {\n             Some(label) => grouped_assists\n                 .entry(label.to_owned())\n                 .or_insert_with(|| {\n                     let idx = res.len();\n-                    let dummy = Command::new(String::new(), String::new(), None);\n-                    res.push(dummy.into());\n+                    let dummy = lsp_ext::CodeAction {\n+                        title: String::new(),\n+                        kind: None,\n+                        command: None,\n+                        edit: None,\n+                    };\n+                    res.push(dummy);\n                     (idx, Vec::new())\n                 })\n                 .1\n@@ -775,35 +774,10 @@ pub fn handle_code_action(\n                 command: \"rust-analyzer.selectAndApplySourceChange\".to_string(),\n                 arguments: Some(vec![serde_json::Value::Array(arguments)]),\n             });\n-            res[idx] = CodeAction {\n-                title,\n-                kind: None,\n-                diagnostics: None,\n-                edit: None,\n-                command,\n-                is_preferred: None,\n-            }\n-            .into();\n+            res[idx] = lsp_ext::CodeAction { title, kind: None, edit: None, command };\n         }\n     }\n \n-    // If the client only supports commands then filter the list\n-    // and remove and actions that depend on edits.\n-    if !world.config.client_caps.code_action_literals {\n-        // FIXME: use drain_filter once it hits stable.\n-        res = res\n-            .into_iter()\n-            .filter_map(|it| match it {\n-                cmd @ lsp_types::CodeActionOrCommand::Command(_) => Some(cmd),\n-                lsp_types::CodeActionOrCommand::CodeAction(action) => match action.command {\n-                    Some(cmd) if action.edit.is_none() => {\n-                        Some(lsp_types::CodeActionOrCommand::Command(cmd))\n-                    }\n-                    _ => None,\n-                },\n-            })\n-            .collect();\n-    }\n     Ok(Some(res))\n }\n \n@@ -812,88 +786,108 @@ pub fn handle_code_lens(\n     params: lsp_types::CodeLensParams,\n ) -> Result<Option<Vec<CodeLens>>> {\n     let _p = profile(\"handle_code_lens\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-\n     let mut lenses: Vec<CodeLens> = Default::default();\n \n+    if world.config.lens.none() {\n+        // early return before any db query!\n+        return Ok(Some(lenses));\n+    }\n+\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n+    let line_index = world.analysis().file_line_index(file_id)?;\n     let cargo_spec = CargoTargetSpec::for_file(&world, file_id)?;\n-    // Gather runnables\n-    for runnable in world.analysis().runnables(file_id)? {\n-        let title = match &runnable.kind {\n-            RunnableKind::Test { .. } | RunnableKind::TestMod { .. } => \"\u25b6\\u{fe0e} Run Test\",\n-            RunnableKind::DocTest { .. } => \"\u25b6\\u{fe0e} Run Doctest\",\n-            RunnableKind::Bench { .. } => \"Run Bench\",\n-            RunnableKind::Bin => {\n-                // Do not suggest binary run on other target than binary\n-                match &cargo_spec {\n-                    Some(spec) => match spec.target_kind {\n-                        TargetKind::Bin => \"Run\",\n-                        _ => continue,\n-                    },\n-                    None => continue,\n+\n+    if world.config.lens.runnable() {\n+        // Gather runnables\n+        for runnable in world.analysis().runnables(file_id)? {\n+            let (run_title, debugee) = match &runnable.kind {\n+                RunnableKind::Test { .. } | RunnableKind::TestMod { .. } => {\n+                    (\"\u25b6\\u{fe0e} Run Test\", true)\n+                }\n+                RunnableKind::DocTest { .. } => {\n+                    // cargo does not support -no-run for doctests\n+                    (\"\u25b6\\u{fe0e} Run Doctest\", false)\n                 }\n+                RunnableKind::Bench { .. } => {\n+                    // Nothing wrong with bench debugging\n+                    (\"Run Bench\", true)\n+                }\n+                RunnableKind::Bin => {\n+                    // Do not suggest binary run on other target than binary\n+                    match &cargo_spec {\n+                        Some(spec) => match spec.target_kind {\n+                            TargetKind::Bin => (\"Run\", true),\n+                            _ => continue,\n+                        },\n+                        None => continue,\n+                    }\n+                }\n+            };\n+\n+            let mut r = to_lsp_runnable(&world, file_id, runnable)?;\n+            if world.config.lens.run {\n+                let lens = CodeLens {\n+                    range: r.range,\n+                    command: Some(Command {\n+                        title: run_title.to_string(),\n+                        command: \"rust-analyzer.runSingle\".into(),\n+                        arguments: Some(vec![to_value(&r).unwrap()]),\n+                    }),\n+                    data: None,\n+                };\n+                lenses.push(lens);\n             }\n-        }\n-        .to_string();\n-        let mut r = to_lsp_runnable(&world, file_id, runnable)?;\n-        let lens = CodeLens {\n-            range: r.range,\n-            command: Some(Command {\n-                title,\n-                command: \"rust-analyzer.runSingle\".into(),\n-                arguments: Some(vec![to_value(&r).unwrap()]),\n-            }),\n-            data: None,\n-        };\n-        lenses.push(lens);\n \n-        if r.args[0] == \"run\" {\n-            r.args[0] = \"build\".into();\n-        } else {\n-            r.args.push(\"--no-run\".into());\n+            if debugee && world.config.lens.debug {\n+                if r.args[0] == \"run\" {\n+                    r.args[0] = \"build\".into();\n+                } else {\n+                    r.args.push(\"--no-run\".into());\n+                }\n+                let debug_lens = CodeLens {\n+                    range: r.range,\n+                    command: Some(Command {\n+                        title: \"Debug\".into(),\n+                        command: \"rust-analyzer.debugSingle\".into(),\n+                        arguments: Some(vec![to_value(r).unwrap()]),\n+                    }),\n+                    data: None,\n+                };\n+                lenses.push(debug_lens);\n+            }\n         }\n-        let debug_lens = CodeLens {\n-            range: r.range,\n-            command: Some(Command {\n-                title: \"Debug\".into(),\n-                command: \"rust-analyzer.debugSingle\".into(),\n-                arguments: Some(vec![to_value(r).unwrap()]),\n-            }),\n-            data: None,\n-        };\n-        lenses.push(debug_lens);\n     }\n \n-    // Handle impls\n-    lenses.extend(\n-        world\n-            .analysis()\n-            .file_structure(file_id)?\n-            .into_iter()\n-            .filter(|it| match it.kind {\n-                SyntaxKind::TRAIT_DEF | SyntaxKind::STRUCT_DEF | SyntaxKind::ENUM_DEF => true,\n-                _ => false,\n-            })\n-            .map(|it| {\n-                let range = to_proto::range(&line_index, it.node_range);\n-                let pos = range.start;\n-                let lens_params = lsp_types::request::GotoImplementationParams {\n-                    text_document_position_params: lsp_types::TextDocumentPositionParams::new(\n-                        params.text_document.clone(),\n-                        pos,\n-                    ),\n-                    work_done_progress_params: Default::default(),\n-                    partial_result_params: Default::default(),\n-                };\n-                CodeLens {\n-                    range,\n-                    command: None,\n-                    data: Some(to_value(CodeLensResolveData::Impls(lens_params)).unwrap()),\n-                }\n-            }),\n-    );\n-\n+    if world.config.lens.impementations {\n+        // Handle impls\n+        lenses.extend(\n+            world\n+                .analysis()\n+                .file_structure(file_id)?\n+                .into_iter()\n+                .filter(|it| match it.kind {\n+                    SyntaxKind::TRAIT_DEF | SyntaxKind::STRUCT_DEF | SyntaxKind::ENUM_DEF => true,\n+                    _ => false,\n+                })\n+                .map(|it| {\n+                    let range = to_proto::range(&line_index, it.node_range);\n+                    let pos = range.start;\n+                    let lens_params = lsp_types::request::GotoImplementationParams {\n+                        text_document_position_params: lsp_types::TextDocumentPositionParams::new(\n+                            params.text_document.clone(),\n+                            pos,\n+                        ),\n+                        work_done_progress_params: Default::default(),\n+                        partial_result_params: Default::default(),\n+                    };\n+                    CodeLens {\n+                        range,\n+                        command: None,\n+                        data: Some(to_value(CodeLensResolveData::Impls(lens_params)).unwrap()),\n+                    }\n+                }),\n+        );\n+    }\n     Ok(Some(lenses))\n }\n "}, {"sha": "af54f81b7da558e7ce99dac952ed6d6c5056be81", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 101, "deletions": 30, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -112,6 +112,22 @@ pub(crate) fn text_edit(\n     lsp_types::TextEdit { range, new_text }\n }\n \n+pub(crate) fn snippet_text_edit(\n+    line_index: &LineIndex,\n+    line_endings: LineEndings,\n+    is_snippet: bool,\n+    indel: Indel,\n+) -> lsp_ext::SnippetTextEdit {\n+    let text_edit = text_edit(line_index, line_endings, indel);\n+    let insert_text_format =\n+        if is_snippet { Some(lsp_types::InsertTextFormat::Snippet) } else { None };\n+    lsp_ext::SnippetTextEdit {\n+        range: text_edit.range,\n+        new_text: text_edit.new_text,\n+        insert_text_format,\n+    }\n+}\n+\n pub(crate) fn text_edit_vec(\n     line_index: &LineIndex,\n     line_endings: LineEndings,\n@@ -441,20 +457,21 @@ pub(crate) fn goto_definition_response(\n     }\n }\n \n-pub(crate) fn text_document_edit(\n+pub(crate) fn snippet_text_document_edit(\n     world: &WorldSnapshot,\n+    is_snippet: bool,\n     source_file_edit: SourceFileEdit,\n-) -> Result<lsp_types::TextDocumentEdit> {\n+) -> Result<lsp_ext::SnippetTextDocumentEdit> {\n     let text_document = versioned_text_document_identifier(world, source_file_edit.file_id, None)?;\n     let line_index = world.analysis().file_line_index(source_file_edit.file_id)?;\n     let line_endings = world.file_line_endings(source_file_edit.file_id);\n     let edits = source_file_edit\n         .edit\n         .as_indels()\n         .iter()\n-        .map(|it| text_edit(&line_index, line_endings, it.clone()))\n+        .map(|it| snippet_text_edit(&line_index, line_endings, is_snippet, it.clone()))\n         .collect();\n-    Ok(lsp_types::TextDocumentEdit { text_document, edits })\n+    Ok(lsp_ext::SnippetTextDocumentEdit { text_document, edits })\n }\n \n pub(crate) fn resource_op(\n@@ -500,20 +517,70 @@ pub(crate) fn source_change(\n             })\n         }\n     };\n-    let mut document_changes: Vec<lsp_types::DocumentChangeOperation> = Vec::new();\n+    let label = source_change.label.clone();\n+    let workspace_edit = self::snippet_workspace_edit(world, source_change)?;\n+    Ok(lsp_ext::SourceChange { label, workspace_edit, cursor_position })\n+}\n+\n+pub(crate) fn snippet_workspace_edit(\n+    world: &WorldSnapshot,\n+    source_change: SourceChange,\n+) -> Result<lsp_ext::SnippetWorkspaceEdit> {\n+    let mut document_changes: Vec<lsp_ext::SnippetDocumentChangeOperation> = Vec::new();\n     for op in source_change.file_system_edits {\n         let op = resource_op(&world, op)?;\n-        document_changes.push(lsp_types::DocumentChangeOperation::Op(op));\n+        document_changes.push(lsp_ext::SnippetDocumentChangeOperation::Op(op));\n     }\n     for edit in source_change.source_file_edits {\n-        let edit = text_document_edit(&world, edit)?;\n-        document_changes.push(lsp_types::DocumentChangeOperation::Edit(edit));\n+        let edit = snippet_text_document_edit(&world, source_change.is_snippet, edit)?;\n+        document_changes.push(lsp_ext::SnippetDocumentChangeOperation::Edit(edit));\n+    }\n+    let workspace_edit =\n+        lsp_ext::SnippetWorkspaceEdit { changes: None, document_changes: Some(document_changes) };\n+    Ok(workspace_edit)\n+}\n+\n+pub(crate) fn workspace_edit(\n+    world: &WorldSnapshot,\n+    source_change: SourceChange,\n+) -> Result<lsp_types::WorkspaceEdit> {\n+    assert!(!source_change.is_snippet);\n+    snippet_workspace_edit(world, source_change).map(|it| it.into())\n+}\n+\n+impl From<lsp_ext::SnippetWorkspaceEdit> for lsp_types::WorkspaceEdit {\n+    fn from(snippet_workspace_edit: lsp_ext::SnippetWorkspaceEdit) -> lsp_types::WorkspaceEdit {\n+        lsp_types::WorkspaceEdit {\n+            changes: None,\n+            document_changes: snippet_workspace_edit.document_changes.map(|changes| {\n+                lsp_types::DocumentChanges::Operations(\n+                    changes\n+                        .into_iter()\n+                        .map(|change| match change {\n+                            lsp_ext::SnippetDocumentChangeOperation::Op(op) => {\n+                                lsp_types::DocumentChangeOperation::Op(op)\n+                            }\n+                            lsp_ext::SnippetDocumentChangeOperation::Edit(edit) => {\n+                                lsp_types::DocumentChangeOperation::Edit(\n+                                    lsp_types::TextDocumentEdit {\n+                                        text_document: edit.text_document,\n+                                        edits: edit\n+                                            .edits\n+                                            .into_iter()\n+                                            .map(|edit| lsp_types::TextEdit {\n+                                                range: edit.range,\n+                                                new_text: edit.new_text,\n+                                            })\n+                                            .collect(),\n+                                    },\n+                                )\n+                            }\n+                        })\n+                        .collect(),\n+                )\n+            }),\n+        }\n     }\n-    let workspace_edit = lsp_types::WorkspaceEdit {\n-        changes: None,\n-        document_changes: Some(lsp_types::DocumentChanges::Operations(document_changes)),\n-    };\n-    Ok(lsp_ext::SourceChange { label: source_change.label, workspace_edit, cursor_position })\n }\n \n pub fn call_hierarchy_item(\n@@ -571,22 +638,26 @@ fn main() <fold>{\n     }\n }\n \n-pub(crate) fn code_action(world: &WorldSnapshot, assist: Assist) -> Result<lsp_types::CodeAction> {\n-    let source_change = source_change(&world, assist.source_change)?;\n-    let arg = serde_json::to_value(source_change)?;\n-    let title = assist.label;\n-    let command = lsp_types::Command {\n-        title: title.clone(),\n-        command: \"rust-analyzer.applySourceChange\".to_string(),\n-        arguments: Some(vec![arg]),\n-    };\n+pub(crate) fn code_action(world: &WorldSnapshot, assist: Assist) -> Result<lsp_ext::CodeAction> {\n+    let res = if assist.source_change.cursor_position.is_none() {\n+        lsp_ext::CodeAction {\n+            title: assist.label,\n+            kind: Some(String::new()),\n+            edit: Some(snippet_workspace_edit(world, assist.source_change)?),\n+            command: None,\n+        }\n+    } else {\n+        assert!(!assist.source_change.is_snippet);\n+        let source_change = source_change(&world, assist.source_change)?;\n+        let arg = serde_json::to_value(source_change)?;\n+        let title = assist.label;\n+        let command = lsp_types::Command {\n+            title: title.clone(),\n+            command: \"rust-analyzer.applySourceChange\".to_string(),\n+            arguments: Some(vec![arg]),\n+        };\n \n-    Ok(lsp_types::CodeAction {\n-        title,\n-        kind: Some(String::new()),\n-        diagnostics: None,\n-        edit: None,\n-        command: Some(command),\n-        is_preferred: None,\n-    })\n+        lsp_ext::CodeAction { title, kind: Some(String::new()), edit: None, command: Some(command) }\n+    };\n+    Ok(res)\n }"}, {"sha": "74676b3eede866320df3cbd901430907c8eaebad", "filename": "crates/rust-analyzer/tests/heavy_tests/main.rs", "status": "modified", "additions": 14, "deletions": 38, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -333,29 +333,17 @@ fn main() {}\n             partial_result_params: PartialResultParams::default(),\n             work_done_progress_params: WorkDoneProgressParams::default(),\n         },\n-        json!([\n-          {\n-            \"command\": {\n-              \"arguments\": [\n+        json!([{\n+            \"edit\": {\n+              \"documentChanges\": [\n                 {\n-                  \"cursorPosition\": null,\n-                  \"label\": \"Create module\",\n-                  \"workspaceEdit\": {\n-                    \"documentChanges\": [\n-                      {\n-                        \"kind\": \"create\",\n-                        \"uri\": \"file:///[..]/src/bar.rs\"\n-                      }\n-                    ]\n-                  }\n+                  \"kind\": \"create\",\n+                  \"uri\": \"file:///[..]/src/bar.rs\"\n                 }\n-              ],\n-              \"command\": \"rust-analyzer.applySourceChange\",\n-              \"title\": \"Create module\"\n+              ]\n             },\n             \"title\": \"Create module\"\n-          }\n-        ]),\n+        }]),\n     );\n \n     server.request::<CodeActionRequest>(\n@@ -416,29 +404,17 @@ fn main() {{}}\n             partial_result_params: PartialResultParams::default(),\n             work_done_progress_params: WorkDoneProgressParams::default(),\n         },\n-        json!([\n-          {\n-            \"command\": {\n-              \"arguments\": [\n+        json!([{\n+            \"edit\": {\n+              \"documentChanges\": [\n                 {\n-                  \"cursorPosition\": null,\n-                  \"label\": \"Create module\",\n-                  \"workspaceEdit\": {\n-                    \"documentChanges\": [\n-                      {\n-                        \"kind\": \"create\",\n-                        \"uri\": \"file:///[..]/src/bar.rs\"\n-                      }\n-                    ]\n-                  }\n+                  \"kind\": \"create\",\n+                  \"uri\": \"file://[..]/src/bar.rs\"\n                 }\n-              ],\n-              \"command\": \"rust-analyzer.applySourceChange\",\n-              \"title\": \"Create module\"\n+              ]\n             },\n             \"title\": \"Create module\"\n-          }\n-        ]),\n+        }]),\n     );\n \n     server.request::<CodeActionRequest>("}, {"sha": "71a57fba230f1ac05aa1c3b7fefc526986ab7577", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -116,3 +116,11 @@ pub fn to_lower_snake_case(s: &str) -> String {\n     }\n     buf\n }\n+\n+pub fn replace(buf: &mut String, from: char, to: &str) {\n+    if !buf.contains(from) {\n+        return;\n+    }\n+    // FIXME: do this in place.\n+    *buf = buf.replace(from, to)\n+}"}, {"sha": "be2cfbaa24d0db32bac6eeefcd2ccf8e6c243d6c", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -7,7 +7,7 @@\n //! * marks (see the eponymous module).\n \n #[macro_use]\n-pub mod marks;\n+pub mod mark;\n \n use std::{\n     fs,"}, {"sha": "7c309a89458994f03207e9a71ced529bcc2eedbf", "filename": "crates/test_utils/src/mark.rs", "status": "renamed", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Ftest_utils%2Fsrc%2Fmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/crates%2Ftest_utils%2Fsrc%2Fmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fmark.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -7,18 +7,18 @@\n //! ```\n //! #[test]\n //! fn test_foo() {\n-//!     covers!(test_foo);\n+//!     mark::check!(test_foo);\n //! }\n //! ```\n //!\n //! and in the code under test you write\n //!\n //! ```\n-//! # use test_utils::tested_by;\n+//! # use test_utils::mark;\n //! # fn some_condition() -> bool { true }\n //! fn foo() {\n //!     if some_condition() {\n-//!         tested_by!(test_foo);\n+//!         mark::hit!(test_foo);\n //!     }\n //! }\n //! ```\n@@ -29,43 +29,31 @@\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n #[macro_export]\n-macro_rules! tested_by {\n-    ($ident:ident; force) => {{\n-        {\n-            // sic! use call-site crate\n-            crate::marks::$ident.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n-        }\n-    }};\n+macro_rules! _hit {\n     ($ident:ident) => {{\n         #[cfg(test)]\n         {\n-            // sic! use call-site crate\n-            crate::marks::$ident.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n+            extern \"C\" {\n+                #[no_mangle]\n+                static $ident: std::sync::atomic::AtomicUsize;\n+            }\n+            unsafe {\n+                $ident.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n+            }\n         }\n     }};\n }\n+pub use _hit as hit;\n \n #[macro_export]\n-macro_rules! covers {\n-    // sic! use call-site crate\n+macro_rules! _check {\n     ($ident:ident) => {\n-        $crate::covers!(crate::$ident)\n-    };\n-    ($krate:ident :: $ident:ident) => {\n-        let _checker = $crate::marks::MarkChecker::new(&$krate::marks::$ident);\n-    };\n-}\n-\n-#[macro_export]\n-macro_rules! marks {\n-    ($($ident:ident)*) => {\n-        $(\n-        #[allow(bad_style)]\n-        pub static $ident: std::sync::atomic::AtomicUsize =\n-            std::sync::atomic::AtomicUsize::new(0);\n-        )*\n+        #[no_mangle]\n+        static $ident: std::sync::atomic::AtomicUsize = std::sync::atomic::AtomicUsize::new(0);\n+        let _checker = $crate::mark::MarkChecker::new(&$ident);\n     };\n }\n+pub use _check as check;\n \n pub struct MarkChecker {\n     mark: &'static AtomicUsize,", "previous_filename": "crates/test_utils/src/marks.rs"}, {"sha": "65cc9fc12c0cde5d6a728490faf583e2b1254cd4", "filename": "docs/dev/README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -74,7 +74,7 @@ relevant test and execute it (VS Code includes an action for running a single\n test).\n \n However, launching a VS Code instance with locally build language server is\n-possible. There's **\"Run Extension (Dev Server)\"** launch configuration for this.\n+possible. There's **\"Run Extension (Debug Build)\"** launch configuration for this.\n \n In general, I use one of the following workflows for fixing bugs and\n implementing features.\n@@ -86,7 +86,7 @@ then just do printf-driven development/debugging. As a sanity check after I'm\n done, I use `cargo xtask install --server` and **Reload Window** action in VS\n Code to sanity check that the thing works as I expect.\n \n-If the problem concerns only the VS Code extension, I use **Run Extension**\n+If the problem concerns only the VS Code extension, I use **Run Installed Extension**\n launch configuration from `launch.json`. Notably, this uses the usual\n `rust-analyzer` binary from `PATH`. For this it is important to have the following\n in `setting.json` file:"}, {"sha": "59a83f7d76fda6c3586647f771dc650c290a5b87", "filename": "docs/dev/debugging.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/docs%2Fdev%2Fdebugging.md", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/docs%2Fdev%2Fdebugging.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fdebugging.md?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -22,8 +22,8 @@ where **only** the `rust-analyzer` extension being debugged is enabled.\n \n ## Debug TypeScript VSCode extension\n \n-- `Run Extension` - runs the extension with the globally installed `rust-analyzer` binary.\n-- `Run Extension (Dev Server)` - runs extension with the locally built LSP server (`target/debug/rust-analyzer`).\n+- `Run Installed Extension` - runs the extension with the globally installed `rust-analyzer` binary.\n+- `Run Extension (Debug Build)` - runs extension with the locally built LSP server (`target/debug/rust-analyzer`).\n \n TypeScript debugging is configured to watch your source edits and recompile.\n To apply changes to an already running debug process, press <kbd>Ctrl+Shift+P</kbd> and run the following command in your `[Extension Development Host]`\n@@ -47,7 +47,7 @@ To apply changes to an already running debug process, press <kbd>Ctrl+Shift+P</k\n     debug = 2\n   ```\n \n-- Select `Run Extension (Dev Server)` to run your locally built `target/debug/rust-analyzer`.\n+- Select `Run Extension (Debug Build)` to run your locally built `target/debug/rust-analyzer`.\n \n - In the original VSCode window once again select the `Attach To Server` debug configuration.\n "}, {"sha": "d2ec6c0215b39457e2471e4715c1a5f05c1cb880", "filename": "docs/dev/lsp-extensions.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -0,0 +1,34 @@\n+# LSP Extensions\n+\n+This document describes LSP extensions used by rust-analyzer.\n+It's a best effort document, when in doubt, consult the source (and send a PR with clarification ;-) ).\n+We aim to upstream all non Rust-specific extensions to the protocol, but this is not a top priority.\n+All capabilities are enabled via `experimental` field of `ClientCapabilities`.\n+\n+## `SnippetTextEdit`\n+\n+**Capability**\n+\n+```typescript\n+{\n+    \"snippetTextEdit\": boolean\n+}\n+```\n+\n+If this capability is set, `WorkspaceEdit`s returned from `codeAction` requests might contain `SnippetTextEdit`s instead of usual `TextEdit`s:\n+\n+```typescript\n+interface SnippetTextEdit extends TextEdit {\n+    insertTextFormat?: InsertTextFormat;\n+}\n+```\n+\n+```typescript\n+export interface TextDocumentEdit {\n+\ttextDocument: VersionedTextDocumentIdentifier;\n+\tedits: (TextEdit | SnippetTextEdit)[];\n+}\n+```\n+\n+When applying such code action, the editor should insert snippet, with tab stops and placeholder.\n+At the moment, rust-analyzer guarantees that only a single edit will have `InsertTextFormat.Snippet`."}, {"sha": "4ad7ea59d2e9b10e112428c2eb2f51a662349651", "filename": "docs/user/assists.md", "status": "modified", "additions": 53, "deletions": 13, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -17,7 +17,7 @@ struct S;\n struct S;\n \n impl Debug for S {\n-\n+    $0\n }\n ```\n \n@@ -33,7 +33,7 @@ struct Point {\n }\n \n // AFTER\n-#[derive()]\n+#[derive($0)]\n struct Point {\n     x: u32,\n     y: u32,\n@@ -77,7 +77,7 @@ fn foo() {\n }\n \n fn bar(arg: &str, baz: Baz) {\n-    todo!()\n+    ${0:todo!()}\n }\n \n ```\n@@ -105,16 +105,16 @@ Adds a new inherent impl for a type.\n ```rust\n // BEFORE\n struct Ctx<T: Clone> {\n-     data: T,\u2503\n+    data: T,\u2503\n }\n \n // AFTER\n struct Ctx<T: Clone> {\n-     data: T,\n+    data: T,\n }\n \n impl<T: Clone> Ctx<T> {\n-\n+    $0\n }\n ```\n \n@@ -146,7 +146,7 @@ trait Trait {\n impl Trait for () {\n     Type X = ();\n     fn foo(&self) {}\n-    fn bar(&self) {}\n+    $0fn bar(&self) {}\n \n }\n ```\n@@ -176,7 +176,7 @@ trait Trait<T> {\n \n impl Trait<u32> for () {\n     fn foo(&self) -> u32 {\n-        todo!()\n+        ${0:todo!()}\n     }\n \n }\n@@ -198,11 +198,29 @@ struct Ctx<T: Clone> {\n }\n \n impl<T: Clone> Ctx<T> {\n-    fn new(data: T) -> Self { Self { data } }\n+    fn $0new(data: T) -> Self { Self { data } }\n }\n \n ```\n \n+## `add_turbo_fish`\n+\n+Adds `::<_>` to a call of a generic method or function.\n+\n+```rust\n+// BEFORE\n+fn make<T>() -> T { todo!() }\n+fn main() {\n+    let x = make\u2503();\n+}\n+\n+// AFTER\n+fn make<T>() -> T { todo!() }\n+fn main() {\n+    let x = make::<${0:_}>();\n+}\n+```\n+\n ## `apply_demorgan`\n \n Apply [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws).\n@@ -250,7 +268,7 @@ Change the function's return type to Result.\n fn foo() -> i32\u2503 { 42i32 }\n \n // AFTER\n-fn foo() -> Result<i32, > { Ok(42i32) }\n+fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n ```\n \n ## `change_visibility`\n@@ -307,12 +325,34 @@ enum Action { Move { distance: u32 }, Stop }\n \n fn handle(action: Action) {\n     match action {\n-        Action::Move { distance } => {}\n+        $0Action::Move { distance } => {}\n         Action::Stop => {}\n     }\n }\n ```\n \n+## `fix_visibility`\n+\n+Makes inaccessible item public.\n+\n+```rust\n+// BEFORE\n+mod m {\n+    fn frobnicate() {}\n+}\n+fn main() {\n+    m::frobnicate\u2503() {}\n+}\n+\n+// AFTER\n+mod m {\n+    $0pub(crate) fn frobnicate() {}\n+}\n+fn main() {\n+    m::frobnicate() {}\n+}\n+```\n+\n ## `flip_binexpr`\n \n Flips operands of a binary expression.\n@@ -386,7 +426,7 @@ fn main() {\n \n // AFTER\n fn main() {\n-    let var_name = (1 + 2);\n+    let $0var_name = (1 + 2);\n     var_name * 4;\n }\n ```\n@@ -693,7 +733,7 @@ fn main() {\n     let x: Result<i32, i32> = Result::Ok(92);\n     let y = match x {\n         Ok(a) => a,\n-        _ => unreachable!(),\n+        $0_ => unreachable!(),\n     };\n }\n ```"}, {"sha": "40ed54809146707b46ad8b29a1f83a4cb08376a4", "filename": "docs/user/readme.adoc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/docs%2Fuser%2Freadme.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/docs%2Fuser%2Freadme.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Freadme.adoc?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -63,7 +63,7 @@ The server binary is stored in:\n * macOS: `~/Library/Application Support/Code/User/globalStorage/matklad.rust-analyzer`\n * Windows: `%APPDATA%\\Code\\User\\globalStorage\\matklad.rust-analyzer`\n \n-Note that we only support the latest version of VS Code.\n+Note that we only support two most recent versions of VS Code.\n \n ==== Updates\n \n@@ -249,7 +249,7 @@ If it worked, you should see \"rust-analyzer, Line X, Column Y\" on the left side\n \n If you get an error saying `No such file or directory: 'rust-analyzer'`, see the <<rust-analyzer-language-server-binary,`rust-analyzer` binary>> section on installing the language server binary.\n \n-=== Gnome Builder\n+=== GNOME Builder\n \n Prerequisites: You have installed the <<rust-analyzer-language-server-binary,`rust-analyzer` binary>>.\n "}, {"sha": "d899f60e333c64c66adc67aaeb69973c60ffa291", "filename": "editors/code/package.json", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -21,7 +21,7 @@\n         \"Programming Languages\"\n     ],\n     \"engines\": {\n-        \"vscode\": \"^1.45.0\"\n+        \"vscode\": \"^1.44.0\"\n     },\n     \"enableProposedApi\": true,\n     \"scripts\": {\n@@ -41,7 +41,7 @@\n         \"@rollup/plugin-node-resolve\": \"^7.1.3\",\n         \"@types/node\": \"^12.12.39\",\n         \"@types/node-fetch\": \"^2.5.7\",\n-        \"@types/vscode\": \"^1.45.0\",\n+        \"@types/vscode\": \"^1.44.0\",\n         \"@typescript-eslint/eslint-plugin\": \"^2.33.0\",\n         \"@typescript-eslint/parser\": \"^2.33.0\",\n         \"eslint\": \"^6.8.0\",\n@@ -443,6 +443,26 @@\n                     \"type\": \"object\",\n                     \"default\": {},\n                     \"description\": \"Optional settings passed to the debug engine. Example:\\n{ \\\"lldb\\\": { \\\"terminal\\\":\\\"external\\\"} }\"\n+                },\n+                \"rust-analyzer.lens.enable\": {\n+                    \"description\": \"Whether to show CodeLens in Rust files.\",\n+                    \"type\": \"boolean\",\n+                    \"default\": true\n+                },\n+                \"rust-analyzer.lens.run\": {\n+                    \"markdownDescription\": \"Whether to show Run lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n+                    \"type\": \"boolean\",\n+                    \"default\": true\n+                },\n+                \"rust-analyzer.lens.debug\": {\n+                    \"markdownDescription\": \"Whether to show Debug lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n+                    \"type\": \"boolean\",\n+                    \"default\": true\n+                },\n+                \"rust-analyzer.lens.implementations\": {\n+                    \"markdownDescription\": \"Whether to show Implementations lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n+                    \"type\": \"boolean\",\n+                    \"default\": true\n                 }\n             }\n         },\n@@ -604,6 +624,9 @@\n             {\n                 \"language\": \"rust\",\n                 \"scopes\": {\n+                    \"macro\": [\n+                        \"entity.name.function.macro.rust\"\n+                    ],\n                     \"attribute\": [\n                         \"meta.attribute.rust\"\n                     ],"}, {"sha": "6a41873d0067b5438472a7c9ae140582be946983", "filename": "editors/code/src/cargo.ts", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/editors%2Fcode%2Fsrc%2Fcargo.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/editors%2Fcode%2Fsrc%2Fcargo.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcargo.ts?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -51,10 +51,14 @@ export class Cargo {\n \n         // arguments for a runnable from the quick pick should be updated.\n         // see crates\\rust-analyzer\\src\\main_loop\\handlers.rs, handle_code_lens\n-        if (cargoArgs[0] === \"run\") {\n-            cargoArgs[0] = \"build\";\n-        } else if (cargoArgs.indexOf(\"--no-run\") === -1) {\n-            cargoArgs.push(\"--no-run\");\n+        switch (cargoArgs[0]) {\n+            case \"run\": cargoArgs[0] = \"build\"; break;\n+            case \"test\": {\n+                if (cargoArgs.indexOf(\"--no-run\") === -1) {\n+                    cargoArgs.push(\"--no-run\");\n+                }\n+                break;\n+            }\n         }\n \n         let artifacts = await this.artifactsFromArgs(cargoArgs);"}, {"sha": "fac1a0be3180231a52c9f43995b280dac6c3e477", "filename": "editors/code/src/client.ts", "status": "modified", "additions": 60, "deletions": 5, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/editors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/editors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fclient.ts?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -31,24 +31,79 @@ export function createClient(serverPath: string, cwd: string): lc.LanguageClient\n                 const res = await next(document, token);\n                 if (res === undefined) throw new Error('busy');\n                 return res;\n+            },\n+            async provideCodeActions(document: vscode.TextDocument, range: vscode.Range, context: vscode.CodeActionContext, token: vscode.CancellationToken, _next: lc.ProvideCodeActionsSignature) {\n+                const params: lc.CodeActionParams = {\n+                    textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),\n+                    range: client.code2ProtocolConverter.asRange(range),\n+                    context: client.code2ProtocolConverter.asCodeActionContext(context)\n+                };\n+                return client.sendRequest(lc.CodeActionRequest.type, params, token).then((values) => {\n+                    if (values === null) return undefined;\n+                    const result: (vscode.CodeAction | vscode.Command)[] = [];\n+                    for (const item of values) {\n+                        if (lc.CodeAction.is(item)) {\n+                            const action = client.protocol2CodeConverter.asCodeAction(item);\n+                            if (isSnippetEdit(item)) {\n+                                action.command = {\n+                                    command: \"rust-analyzer.applySnippetWorkspaceEdit\",\n+                                    title: \"\",\n+                                    arguments: [action.edit],\n+                                };\n+                                action.edit = undefined;\n+                            }\n+                            result.push(action);\n+                        } else {\n+                            const command = client.protocol2CodeConverter.asCommand(item);\n+                            result.push(command);\n+                        }\n+                    }\n+                    return result;\n+                },\n+                    (_error) => undefined\n+                );\n             }\n+\n         } as any\n     };\n \n-    const res = new lc.LanguageClient(\n+    const client = new lc.LanguageClient(\n         'rust-analyzer',\n         'Rust Analyzer Language Server',\n         serverOptions,\n         clientOptions,\n     );\n \n-    // To turn on all proposed features use: res.registerProposedFeatures();\n+    // To turn on all proposed features use: client.registerProposedFeatures();\n     // Here we want to enable CallHierarchyFeature and SemanticTokensFeature\n     // since they are available on stable.\n     // Note that while these features are stable in vscode their LSP protocol\n     // implementations are still in the \"proposed\" category for 3.16.\n-    res.registerFeature(new CallHierarchyFeature(res));\n-    res.registerFeature(new SemanticTokensFeature(res));\n+    client.registerFeature(new CallHierarchyFeature(client));\n+    client.registerFeature(new SemanticTokensFeature(client));\n+    client.registerFeature(new SnippetTextEditFeature());\n+\n+    return client;\n+}\n \n-    return res;\n+class SnippetTextEditFeature implements lc.StaticFeature {\n+    fillClientCapabilities(capabilities: lc.ClientCapabilities): void {\n+        const caps: any = capabilities.experimental ?? {};\n+        caps.snippetTextEdit = true;\n+        capabilities.experimental = caps;\n+    }\n+    initialize(_capabilities: lc.ServerCapabilities<any>, _documentSelector: lc.DocumentSelector | undefined): void {\n+    }\n+}\n+\n+function isSnippetEdit(action: lc.CodeAction): boolean {\n+    const documentChanges = action.edit?.documentChanges ?? [];\n+    for (const edit of documentChanges) {\n+        if (lc.TextDocumentEdit.is(edit)) {\n+            if (edit.edits.some((indel) => (indel as any).insertTextFormat === lc.InsertTextFormat.Snippet)) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n }"}, {"sha": "0937b495c26c711ddf8b344deef4d4ecb641b91d", "filename": "editors/code/src/commands/index.ts", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/editors%2Fcode%2Fsrc%2Fcommands%2Findex.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/editors%2Fcode%2Fsrc%2Fcommands%2Findex.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Findex.ts?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -4,6 +4,7 @@ import * as ra from '../rust-analyzer-api';\n \n import { Ctx, Cmd } from '../ctx';\n import * as sourceChange from '../source_change';\n+import { assert } from '../util';\n \n export * from './analyzer_status';\n export * from './matching_brace';\n@@ -51,3 +52,37 @@ export function selectAndApplySourceChange(ctx: Ctx): Cmd {\n         }\n     };\n }\n+\n+export function applySnippetWorkspaceEdit(_ctx: Ctx): Cmd {\n+    return async (edit: vscode.WorkspaceEdit) => {\n+        assert(edit.entries().length === 1, `bad ws edit: ${JSON.stringify(edit)}`);\n+        const [uri, edits] = edit.entries()[0];\n+\n+        const editor = vscode.window.visibleTextEditors.find((it) => it.document.uri.toString() === uri.toString());\n+        if (!editor) return;\n+\n+        let editWithSnippet: vscode.TextEdit | undefined = undefined;\n+        let lineDelta = 0;\n+        await editor.edit((builder) => {\n+            for (const indel of edits) {\n+                const isSnippet = indel.newText.indexOf('$0') !== -1 || indel.newText.indexOf('${') !== -1;\n+                if (isSnippet) {\n+                    editWithSnippet = indel;\n+                } else {\n+                    if (!editWithSnippet) {\n+                        lineDelta = (indel.newText.match(/\\n/g) || []).length - (indel.range.end.line - indel.range.start.line);\n+                    }\n+                    builder.replace(indel.range, indel.newText);\n+                }\n+            }\n+        });\n+        if (editWithSnippet) {\n+            const snip = editWithSnippet as vscode.TextEdit;\n+            const range = snip.range.with(\n+                snip.range.start.with(snip.range.start.line + lineDelta),\n+                snip.range.end.with(snip.range.end.line + lineDelta),\n+            );\n+            await editor.insertSnippet(new vscode.SnippetString(snip.newText), range);\n+        }\n+    };\n+}"}, {"sha": "0bd30fb077d7743f097d8632f224884780b01a35", "filename": "editors/code/src/commands/runnables.ts", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -7,7 +7,7 @@ import { startDebugSession, getDebugConfiguration } from '../debug';\n \n const quickPickButtons = [{ iconPath: new vscode.ThemeIcon(\"save\"), tooltip: \"Save as a launch.json configurtation.\" }];\n \n-async function selectRunnable(ctx: Ctx, prevRunnable?: RunnableQuickPick, showButtons: boolean = true): Promise<RunnableQuickPick | undefined> {\n+async function selectRunnable(ctx: Ctx, prevRunnable?: RunnableQuickPick, debuggeeOnly = false, showButtons: boolean = true): Promise<RunnableQuickPick | undefined> {\n     const editor = ctx.activeRustEditor;\n     const client = ctx.client;\n     if (!editor || !client) return;\n@@ -33,9 +33,20 @@ async function selectRunnable(ctx: Ctx, prevRunnable?: RunnableQuickPick, showBu\n         ) {\n             continue;\n         }\n+\n+        if (debuggeeOnly && (r.label.startsWith('doctest') || r.label.startsWith('cargo'))) {\n+            continue;\n+        }\n         items.push(new RunnableQuickPick(r));\n     }\n \n+    if (items.length === 0) {\n+        // it is the debug case, run always has at least 'cargo check ...'\n+        // see crates\\rust-analyzer\\src\\main_loop\\handlers.rs, handle_runnables\n+        vscode.window.showErrorMessage(\"There's no debug target!\");\n+        return;\n+    }\n+\n     return await new Promise((resolve) => {\n         const disposables: vscode.Disposable[] = [];\n         const close = (result?: RunnableQuickPick) => {\n@@ -107,7 +118,7 @@ export function debug(ctx: Ctx): Cmd {\n     let prevDebuggee: RunnableQuickPick | undefined;\n \n     return async () => {\n-        const item = await selectRunnable(ctx, prevDebuggee);\n+        const item = await selectRunnable(ctx, prevDebuggee, true);\n         if (!item) return;\n \n         item.detail = 'restart';\n@@ -147,7 +158,7 @@ async function makeDebugConfig(ctx: Ctx, item: RunnableQuickPick): Promise<void>\n \n export function newDebugConfig(ctx: Ctx): Cmd {\n     return async () => {\n-        const item = await selectRunnable(ctx, undefined, false);\n+        const item = await selectRunnable(ctx, undefined, true, false);\n         if (!item) return;\n \n         await makeDebugConfig(ctx, item);"}, {"sha": "ee294fbe312c4c9b5e121cbb769fd5f97b42dccb", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -16,6 +16,10 @@ export class Config {\n         \"files\",\n         \"highlighting\",\n         \"updates.channel\",\n+        \"lens.enable\",\n+        \"lens.run\",\n+        \"lens.debug\",\n+        \"lens.implementations\",\n     ]\n         .map(opt => `${this.rootSection}.${opt}`);\n \n@@ -119,4 +123,13 @@ export class Config {\n             sourceFileMap: sourceFileMap\n         };\n     }\n+\n+    get lens() {\n+        return {\n+            enable: this.get<boolean>(\"lens.enable\"),\n+            run: this.get<boolean>(\"lens.run\"),\n+            debug: this.get<boolean>(\"lens.debug\"),\n+            implementations: this.get<boolean>(\"lens.implementations\"),\n+        };\n+    }\n }"}, {"sha": "ac3bb365e2f0b5cb94b5a970ace34fcac66a73b4", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -91,6 +91,7 @@ export async function activate(context: vscode.ExtensionContext) {\n     ctx.registerCommand('debugSingle', commands.debugSingle);\n     ctx.registerCommand('showReferences', commands.showReferences);\n     ctx.registerCommand('applySourceChange', commands.applySourceChange);\n+    ctx.registerCommand('applySnippetWorkspaceEdit', commands.applySnippetWorkspaceEdit);\n     ctx.registerCommand('selectAndApplySourceChange', commands.selectAndApplySourceChange);\n \n     ctx.pushCleanup(activateTaskProvider(workspaceFolder));"}, {"sha": "2e9fcf07c5f25d88bd31223095a76af628a276a7", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=a7c8aa7c60c05db66ba4e89ae9e05c82e62507a5", "patch": "@@ -57,6 +57,7 @@ fn check_todo(path: &Path, text: &str) {\n         \"tests/generated.rs\",\n         \"handlers/add_missing_impl_members.rs\",\n         \"handlers/add_function.rs\",\n+        \"handlers/add_turbo_fish.rs\",\n         // To support generating `todo!()` in assists, we have `expr_todo()` in ast::make.\n         \"ast/make.rs\",\n     ];"}]}