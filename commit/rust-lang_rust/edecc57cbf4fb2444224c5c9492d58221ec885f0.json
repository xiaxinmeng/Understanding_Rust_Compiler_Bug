{"sha": "edecc57cbf4fb2444224c5c9492d58221ec885f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZWNjNTdjYmY0ZmIyNDQ0MjI0YzVjOTQ5MmQ1ODIyMWVjODg1ZjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-27T03:52:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-27T03:52:24Z"}, "message": "Auto merge of #35053 - steveklabnik:rollup, r=steveklabnik\n\nRollup of 15 pull requests\n\n- Successful merges: #34461, #34609, #34732, #34850, #34935, #34974, #34990, #34995, #35001, #35009, #35010, #35019, #35028, #35029, #35043\n- Failed merges:", "tree": {"sha": "fdb8421077b032891009c119232516cbfb1c150b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdb8421077b032891009c119232516cbfb1c150b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edecc57cbf4fb2444224c5c9492d58221ec885f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edecc57cbf4fb2444224c5c9492d58221ec885f0", "html_url": "https://github.com/rust-lang/rust/commit/edecc57cbf4fb2444224c5c9492d58221ec885f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edecc57cbf4fb2444224c5c9492d58221ec885f0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b541f5f0cc342dc6d31d7980f75c3d3d42f7587f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b541f5f0cc342dc6d31d7980f75c3d3d42f7587f", "html_url": "https://github.com/rust-lang/rust/commit/b541f5f0cc342dc6d31d7980f75c3d3d42f7587f"}, {"sha": "d64de045c96ccd8fd3e956f6b04e999563198ce2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d64de045c96ccd8fd3e956f6b04e999563198ce2", "html_url": "https://github.com/rust-lang/rust/commit/d64de045c96ccd8fd3e956f6b04e999563198ce2"}], "stats": {"total": 1039, "additions": 624, "deletions": 415}, "files": [{"sha": "0259db221b6bc0dbaa0a47c94e7386eec91d22a3", "filename": "src/doc/book/syntax-index.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Fdoc%2Fbook%2Fsyntax-index.md", "raw_url": "https://github.com/rust-lang/rust/raw/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Fdoc%2Fbook%2Fsyntax-index.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsyntax-index.md?ref=edecc57cbf4fb2444224c5c9492d58221ec885f0", "patch": "@@ -94,7 +94,7 @@\n * `|` (`|\u2026| expr`): closures.  See [Closures].\n * `|=` (`var |= expr`): bitwise or & assignment. Overloadable (`BitOrAssign`).\n * `||` (`expr || expr`): logical or.\n-* `_`: \"ignored\" pattern binding.  See [Patterns (Ignoring bindings)].\n+* `_`: \"ignored\" pattern binding (see [Patterns (Ignoring bindings)]). Also used to make integer-literals readable (see [Reference (Integer literals)]).\n \n ## Other Syntax\n \n@@ -231,6 +231,7 @@\n [Primitive Types (Tuples)]: primitive-types.html#tuples\n [Raw Pointers]: raw-pointers.html\n [Reference (Byte String Literals)]: ../reference.html#byte-string-literals\n+[Reference (Integer literals)]: ../reference.html#integer-literals\n [Reference (Raw Byte String Literals)]: ../reference.html#raw-byte-string-literals\n [Reference (Raw String Literals)]: ../reference.html#raw-string-literals\n [References and Borrowing]: references-and-borrowing.html"}, {"sha": "b1aee579aabc26ae560c72e7187532fc0fd95c00", "filename": "src/doc/book/trait-objects.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Fdoc%2Fbook%2Ftrait-objects.md", "raw_url": "https://github.com/rust-lang/rust/raw/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Fdoc%2Fbook%2Ftrait-objects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftrait-objects.md?ref=edecc57cbf4fb2444224c5c9492d58221ec885f0", "patch": "@@ -123,7 +123,6 @@ dispatch with trait objects by casting:\n # trait Foo { fn method(&self) -> String; }\n # impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n # impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n-\n fn do_something(x: &Foo) {\n     x.method();\n }\n@@ -140,7 +139,6 @@ or by coercing:\n # trait Foo { fn method(&self) -> String; }\n # impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n # impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n-\n fn do_something(x: &Foo) {\n     x.method();\n }"}, {"sha": "189695716deb1bb776f46aee347699529bcd42c4", "filename": "src/doc/nomicon/phantom-data.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Fdoc%2Fnomicon%2Fphantom-data.md", "raw_url": "https://github.com/rust-lang/rust/raw/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Fdoc%2Fnomicon%2Fphantom-data.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fphantom-data.md?ref=edecc57cbf4fb2444224c5c9492d58221ec885f0", "patch": "@@ -50,7 +50,7 @@ struct Vec<T> {\n }\n ```\n \n-Unlike the previous example it *appears* that everything is exactly as we\n+Unlike the previous example, it *appears* that everything is exactly as we\n want. Every generic argument to Vec shows up in at least one field.\n Good to go!\n \n@@ -84,4 +84,3 @@ standard library made a utility for itself called `Unique<T>` which:\n * includes a `PhantomData<T>`\n * auto-derives Send/Sync as if T was contained\n * marks the pointer as NonZero for the null-pointer optimization\n-"}, {"sha": "a461023642afd6130df80eaf0b95de7c0cd32021", "filename": "src/doc/reference.md", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=edecc57cbf4fb2444224c5c9492d58221ec885f0", "patch": "@@ -1653,14 +1653,43 @@ the Rust ABI and the foreign ABI.\n A number of [attributes](#ffi-attributes) control the behavior of external blocks.\n \n By default external blocks assume that the library they are calling uses the\n-standard C \"cdecl\" ABI. Other ABIs may be specified using an `abi` string, as\n-shown here:\n+standard C ABI on the specific platform. Other ABIs may be specified using an\n+`abi` string, as shown here:\n \n ```ignore\n // Interface to the Windows API\n extern \"stdcall\" { }\n ```\n \n+There are three ABI strings which are cross-platform, and which all compilers\n+are guaranteed to support:\n+\n+* `extern \"Rust\"` -- The default ABI when you write a normal `fn foo()` in any\n+  Rust code.\n+* `extern \"C\"` -- This is the same as `extern fn foo()`; whatever the default\n+  your C compiler supports.\n+* `extern \"system\"` -- Usually the same as `extern \"C\"`, except on Win32, in\n+  which case it's `\"stdcall\"`, or what you should use to link to the Windows API\n+  itself\n+\n+There are also some platform-specific ABI strings:\n+\n+* `extern \"cdecl\"` -- The default for x86\\_32 C code.\n+* `extern \"stdcall\"` -- The default for the Win32 API on x86\\_32.\n+* `extern \"win64\"` -- The default for C code on x86\\_64 Windows.\n+* `extern \"aapcs\"` -- The default for ARM.\n+* `extern \"fastcall\"` -- The `fastcall` ABI -- corresponds to MSVC's\n+  `__fastcall` and GCC and clang's `__attribute__((fastcall))`\n+* `extern \"vectorcall\"` -- The `vectorcall` ABI -- corresponds to MSVC's\n+  `__vectorcall` and clang's `__attribute__((vectorcall))`\n+\n+Finally, there are some rustc-specific ABI strings:\n+\n+* `extern \"rust-intrinsic\"` -- The ABI of rustc intrinsics.\n+* `extern \"rust-call\"` -- The ABI of the Fn::call trait functions.\n+* `extern \"platform-intrinsic\"` -- Specific platform intrinsics -- like, for\n+  example, `sqrt` -- have this ABI. You should never have to deal with it.\n+\n The `link` attribute allows the name of the library to be specified. When\n specified the compiler will attempt to link against the native library of the\n specified name."}, {"sha": "ccef6c02f9d22f4d15aa3aded94270d16d847a9e", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=edecc57cbf4fb2444224c5c9492d58221ec885f0", "patch": "@@ -691,15 +691,40 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n-    /// Print the slice split by numbers divisible by 3 (i.e. `[10, 40]`,\n-    /// `[20]`, `[50]`):\n+    /// ```\n+    /// let slice = [10, 40, 33, 20];\n+    /// let mut iter = slice.split(|num| num % 3 == 0);\n     ///\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n+    /// assert_eq!(iter.next().unwrap(), &[20]);\n+    /// assert!(iter.next().is_none());\n     /// ```\n-    /// let v = [10, 40, 30, 20, 60, 50];\n     ///\n-    /// for group in v.split(|num| *num % 3 == 0) {\n-    ///     println!(\"{:?}\", group);\n-    /// }\n+    /// If the first element is matched, an empty slice will be the first item\n+    /// returned by the iterator. Similarly, if the last element in the slice\n+    /// is matched, an empty slice will be the last item returned by the\n+    /// iterator:\n+    ///\n+    /// ```\n+    /// let slice = [10, 40, 33];\n+    /// let mut iter = slice.split(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n+    /// assert_eq!(iter.next().unwrap(), &[]);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// If two matched elements are directly adjacent, an empty slice will be\n+    /// present between them:\n+    ///\n+    /// ```\n+    /// let slice = [10, 6, 33, 20];\n+    /// let mut iter = slice.split(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10]);\n+    /// assert_eq!(iter.next().unwrap(), &[]);\n+    /// assert_eq!(iter.next().unwrap(), &[20]);\n+    /// assert!(iter.next().is_none());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "9c3792afa2f1c91b5e87e234f1258028d2dc5f30", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=edecc57cbf4fb2444224c5c9492d58221ec885f0", "patch": "@@ -402,6 +402,8 @@ impl<T> VecDeque<T> {\n \n     /// Retrieves an element in the `VecDeque` by index.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -425,6 +427,8 @@ impl<T> VecDeque<T> {\n \n     /// Retrieves an element in the `VecDeque` mutably by index.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -456,6 +460,8 @@ impl<T> VecDeque<T> {\n     ///\n     /// Fails if there is no element with either index.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1180,6 +1186,8 @@ impl<T> VecDeque<T> {\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1214,6 +1222,8 @@ impl<T> VecDeque<T> {\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1245,6 +1255,8 @@ impl<T> VecDeque<T> {\n     /// end is closer to the insertion point will be moved to make room,\n     /// and all the affected elements will be moved to new positions.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Panics\n     ///\n     /// Panics if `index` is greater than `VecDeque`'s length\n@@ -1472,6 +1484,8 @@ impl<T> VecDeque<T> {\n     /// room, and all the affected elements will be moved to new positions.\n     /// Returns `None` if `index` is out of bounds.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1651,6 +1665,8 @@ impl<T> VecDeque<T> {\n     ///\n     /// Note that the capacity of `self` does not change.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Panics\n     ///\n     /// Panics if `at > len`"}, {"sha": "c645608dda7902ed3189dbe7ad6af7b948fdf1b4", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 188, "deletions": 5, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=edecc57cbf4fb2444224c5c9492d58221ec885f0", "patch": "@@ -277,17 +277,200 @@ extern \"rust-intrinsic\" {\n     /// Moves a value out of scope without running drop glue.\n     pub fn forget<T>(_: T) -> ();\n \n-    /// Unsafely transforms a value of one type into a value of another type.\n+    /// Reinterprets the bits of a value of one type as another type; both types\n+    /// must have the same size. Neither the original, nor the result, may be an\n+    /// [invalid value] (../../nomicon/meet-safe-and-unsafe.html).\n     ///\n-    /// Both types must have the same size.\n+    /// `transmute` is semantically equivalent to a bitwise move of one type\n+    /// into another. It copies the bits from the destination type into the\n+    /// source type, then forgets the original. It's equivalent to C's `memcpy`\n+    /// under the hood, just like `transmute_copy`.\n+    ///\n+    /// `transmute` is incredibly unsafe. There are a vast number of ways to\n+    /// cause undefined behavior with this function. `transmute` should be\n+    /// the absolute last resort.\n+    ///\n+    /// The [nomicon](../../nomicon/transmutes.html) has additional\n+    /// documentation.\n     ///\n     /// # Examples\n     ///\n+    /// There are a few things that `transmute` is really useful for.\n+    ///\n+    /// Getting the bitpattern of a floating point type (or, more generally,\n+    /// type punning, when `T` and `U` aren't pointers):\n+    ///\n     /// ```\n-    /// use std::mem;\n+    /// let bitpattern = unsafe {\n+    ///     std::mem::transmute::<f32, u32>(1.0)\n+    /// };\n+    /// assert_eq!(bitpattern, 0x3F800000);\n+    /// ```\n+    ///\n+    /// Turning a pointer into a function pointer:\n+    ///\n+    /// ```\n+    /// fn foo() -> i32 {\n+    ///     0\n+    /// }\n+    /// let pointer = foo as *const ();\n+    /// let function = unsafe {\n+    ///     std::mem::transmute::<*const (), fn() -> i32>(pointer)\n+    /// };\n+    /// assert_eq!(function(), 0);\n+    /// ```\n+    ///\n+    /// Extending a lifetime, or shortening an invariant lifetime; this is\n+    /// advanced, very unsafe rust:\n+    ///\n+    /// ```\n+    /// struct R<'a>(&'a i32);\n+    /// unsafe fn extend_lifetime<'b>(r: R<'b>) -> R<'static> {\n+    ///     std::mem::transmute::<R<'b>, R<'static>>(r)\n+    /// }\n+    ///\n+    /// unsafe fn shorten_invariant_lifetime<'b, 'c>(r: &'b mut R<'static>)\n+    ///                                              -> &'b mut R<'c> {\n+    ///     std::mem::transmute::<&'b mut R<'static>, &'b mut R<'c>>(r)\n+    /// }\n+    /// ```\n+    ///\n+    /// # Alternatives\n+    ///\n+    /// However, many uses of `transmute` can be achieved through other means.\n+    /// `transmute` can transform any type into any other, with just the caveat\n+    /// that they're the same size, and often interesting results occur. Below\n+    /// are common applications of `transmute` which can be replaced with safe\n+    /// applications of `as`:\n     ///\n-    /// let array: &[u8] = unsafe { mem::transmute(\"Rust\") };\n-    /// assert_eq!(array, [82, 117, 115, 116]);\n+    /// Turning a pointer into a `usize`:\n+    ///\n+    /// ```\n+    /// let ptr = &0;\n+    /// let ptr_num_transmute = unsafe {\n+    ///     std::mem::transmute::<&i32, usize>(ptr)\n+    /// };\n+    /// // Use an `as` cast instead\n+    /// let ptr_num_cast = ptr as *const i32 as usize;\n+    /// ```\n+    ///\n+    /// Turning a `*mut T` into an `&mut T`:\n+    ///\n+    /// ```\n+    /// let ptr: *mut i32 = &mut 0;\n+    /// let ref_transmuted = unsafe {\n+    ///     std::mem::transmute::<*mut i32, &mut i32>(ptr)\n+    /// };\n+    /// // Use a reborrow instead\n+    /// let ref_casted = unsafe { &mut *ptr };\n+    /// ```\n+    ///\n+    /// Turning an `&mut T` into an `&mut U`:\n+    ///\n+    /// ```\n+    /// let ptr = &mut 0;\n+    /// let val_transmuted = unsafe {\n+    ///     std::mem::transmute::<&mut i32, &mut u32>(ptr)\n+    /// };\n+    /// // Now, put together `as` and reborrowing - note the chaining of `as`\n+    /// // `as` is not transitive\n+    /// let val_casts = unsafe { &mut *(ptr as *mut i32 as *mut u32) };\n+    /// ```\n+    ///\n+    /// Turning an `&str` into an `&[u8]`:\n+    ///\n+    /// ```\n+    /// // this is not a good way to do this.\n+    /// let slice = unsafe { std::mem::transmute::<&str, &[u8]>(\"Rust\") };\n+    /// assert_eq!(slice, &[82, 117, 115, 116]);\n+    /// // You could use `str::as_bytes`\n+    /// let slice = \"Rust\".as_bytes();\n+    /// assert_eq!(slice, &[82, 117, 115, 116]);\n+    /// // Or, just use a byte string, if you have control over the string\n+    /// // literal\n+    /// assert_eq!(b\"Rust\", &[82, 117, 115, 116]);\n+    /// ```\n+    ///\n+    /// Turning a `Vec<&T>` into a `Vec<Option<&T>>`:\n+    ///\n+    /// ```\n+    /// let store = [0, 1, 2, 3];\n+    /// let mut v_orig = store.iter().collect::<Vec<&i32>>();\n+    /// // Using transmute: this is Undefined Behavior, and a bad idea.\n+    /// // However, it is no-copy.\n+    /// let v_transmuted = unsafe {\n+    ///     std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(\n+    ///         v_orig.clone())\n+    /// };\n+    /// // This is the suggested, safe way.\n+    /// // It does copy the entire Vector, though, into a new array.\n+    /// let v_collected = v_orig.clone()\n+    ///                         .into_iter()\n+    ///                         .map(|r| Some(r))\n+    ///                         .collect::<Vec<Option<&i32>>>();\n+    /// // The no-copy, unsafe way, still using transmute, but not UB.\n+    /// // This is equivalent to the original, but safer, and reuses the\n+    /// // same Vec internals. Therefore the new inner type must have the\n+    /// // exact same size, and the same or lesser alignment, as the old\n+    /// // type. The same caveats exist for this method as transmute, for\n+    /// // the original inner type (`&i32`) to the converted inner type\n+    /// // (`Option<&i32>`), so read the nomicon pages linked above.\n+    /// let v_from_raw = unsafe {\n+    ///     Vec::from_raw_parts(v_orig.as_mut_ptr(),\n+    ///                         v_orig.len(),\n+    ///                         v_orig.capacity())\n+    /// };\n+    /// std::mem::forget(v_orig);\n+    /// ```\n+    ///\n+    /// Implementing `split_at_mut`:\n+    ///\n+    /// ```\n+    /// use std::{slice, mem};\n+    /// // There are multiple ways to do this; and there are multiple problems\n+    /// // with the following, transmute, way.\n+    /// fn split_at_mut_transmute<T>(slice: &mut [T], mid: usize)\n+    ///                              -> (&mut [T], &mut [T]) {\n+    ///     let len = slice.len();\n+    ///     assert!(mid <= len);\n+    ///     unsafe {\n+    ///         let slice2 = mem::transmute::<&mut [T], &mut [T]>(slice);\n+    ///         // first: transmute is not typesafe; all it checks is that T and\n+    ///         // U are of the same size. Second, right here, you have two\n+    ///         // mutable references pointing to the same memory.\n+    ///         (&mut slice[0..mid], &mut slice2[mid..len])\n+    ///     }\n+    /// }\n+    /// // This gets rid of the typesafety problems; `&mut *` will *only* give\n+    /// // you an `&mut T` from an `&mut T` or `*mut T`.\n+    /// fn split_at_mut_casts<T>(slice: &mut [T], mid: usize)\n+    ///                          -> (&mut [T], &mut [T]) {\n+    ///     let len = slice.len();\n+    ///     assert!(mid <= len);\n+    ///     unsafe {\n+    ///         let slice2 = &mut *(slice as *mut [T]);\n+    ///         // however, you still have two mutable references pointing to\n+    ///         // the same memory.\n+    ///         (&mut slice[0..mid], &mut slice2[mid..len])\n+    ///     }\n+    /// }\n+    /// // This is how the standard library does it. This is the best method, if\n+    /// // you need to do something like this\n+    /// fn split_at_stdlib<T>(slice: &mut [T], mid: usize)\n+    ///                       -> (&mut [T], &mut [T]) {\n+    ///     let len = slice.len();\n+    ///     assert!(mid <= len);\n+    ///     unsafe {\n+    ///         let ptr = slice.as_mut_ptr();\n+    ///         // This now has three mutable references pointing at the same\n+    ///         // memory. `slice`, the rvalue ret.0, and the rvalue ret.1.\n+    ///         // `slice` is never used after `let ptr = ...`, and so one can\n+    ///         // treat it as \"dead\", and therefore, you only have two real\n+    ///         // mutable slices.\n+    ///         (slice::from_raw_parts_mut(ptr, mid),\n+    ///          slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n+    ///     }\n+    /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn transmute<T, U>(e: T) -> U;"}, {"sha": "292d72dd362ad5c203497361cd9cda2febfaebc7", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=edecc57cbf4fb2444224c5c9492d58221ec885f0", "patch": "@@ -386,10 +386,11 @@ pub trait Extend<A> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DoubleEndedIterator: Iterator {\n-    /// An iterator able to yield elements from both ends.\n+    /// Removes and returns an element from the end of the iterator.\n     ///\n-    /// As this is the only method for this trait, the [trait-level] docs\n-    /// contain more details.\n+    /// Returns `None` when there are no more elements.\n+    ///\n+    /// The [trait-level] docs contain more details.\n     ///\n     /// [trait-level]: trait.DoubleEndedIterator.html\n     ///"}, {"sha": "0fd95500422ff193af8a29aa1f8ea615657eb775", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=edecc57cbf4fb2444224c5c9492d58221ec885f0", "patch": "@@ -427,7 +427,7 @@ fn make_values_str(pairs: &[(&'static str, &str)]) -> String {\n }\n \n fn span_extent_str(span: SpanData) -> String {\n-    format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},byte_start,{}\\\n+    format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},byte_start,{},\\\n              file_line_end,{},file_col_end,{},byte_end,{}\",\n              span.file_name, span.line_start, span.column_start, span.byte_start,\n              span.line_end, span.column_end, span.byte_end)"}, {"sha": "fd7b0a2e6bbf6d9b0d8834c911e7dca320c7c298", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 199, "deletions": 6, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=edecc57cbf4fb2444224c5c9492d58221ec885f0", "patch": "@@ -877,7 +877,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// }\n     ///\n     /// for val in map.values() {\n-    ///     print!(\"{}\", val);\n+    ///     println!(\"{}\", val);\n     /// }\n     /// ```\n     #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n@@ -1336,6 +1336,10 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n }\n \n /// A view into a single location in a map, which may be vacant or occupied.\n+/// This enum is constructed from the [`entry`] method on [`HashMap`].\n+///\n+/// [`HashMap`]: struct.HashMap.html\n+/// [`entry`]: struct.HashMap.html#method.entry\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// An occupied Entry.\n@@ -1366,6 +1370,9 @@ impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for Entry<'a, K, V> {\n }\n \n /// A view into a single occupied location in a HashMap.\n+/// It is part of the [`Entry`] enum.\n+///\n+/// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     key: Option<K>,\n@@ -1383,6 +1390,9 @@ impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for OccupiedEntry<'a, K, V> {\n }\n \n /// A view into a single empty location in a HashMap.\n+/// It is part of the [`Entry`] enum.\n+///\n+/// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n@@ -1551,6 +1561,20 @@ impl<'a, K, V> Entry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    ///\n+    /// *map.entry(\"poneyland\").or_insert(12) += 10;\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n     pub fn or_insert(self, default: V) -> &'a mut V {\n         match self {\n             Occupied(entry) => entry.into_mut(),\n@@ -1561,6 +1585,19 @@ impl<'a, K, V> Entry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the result of the default function if empty,\n     /// and returns a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, String> = HashMap::new();\n+    /// let s = \"hoho\".to_owned();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with(|| s);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_owned());\n+    /// ```\n     pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n         match self {\n             Occupied(entry) => entry.into_mut(),\n@@ -1569,6 +1606,15 @@ impl<'a, K, V> Entry<'a, K, V> {\n     }\n \n     /// Returns a reference to this entry's key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         match *self {\n@@ -1580,45 +1626,154 @@ impl<'a, K, V> Entry<'a, K, V> {\n \n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the key in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         self.elem.read().0\n     }\n \n     /// Take the ownership of the key and value from the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_entry_recover_keys)]\n+    ///\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     // We delete the entry from the map.\n+    ///     o.remove_pair();\n+    /// }\n+    ///\n+    /// assert_eq!(map.contains_key(\"poneyland\"), false);\n+    /// ```\n     #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n     pub fn remove_pair(self) -> (K, V) {\n         pop_internal(self.elem)\n     }\n \n     /// Gets a reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.get(), &12);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {\n         self.elem.read().1\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///      *o.get_mut() += 10;\n+    /// }\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.elem.read_mut().1\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n-    /// with a lifetime bound to the map itself\n+    /// with a lifetime bound to the map itself.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     *o.into_mut() += 10;\n+    /// }\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_mut(self) -> &'a mut V {\n         self.elem.into_mut_refs().1\n     }\n \n-    /// Sets the value of the entry, and returns the entry's old value\n+    /// Sets the value of the entry, and returns the entry's old value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.insert(15), 12);\n+    /// }\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 15);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, mut value: V) -> V {\n         let old_value = self.get_mut();\n         mem::swap(&mut value, old_value);\n         value\n     }\n \n-    /// Takes the value out of the entry, and returns it\n+    /// Takes the value out of the entry, and returns it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.remove(), 12);\n+    /// }\n+    ///\n+    /// assert_eq!(map.contains_key(\"poneyland\"), false);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(self) -> V {\n         pop_internal(self.elem).1\n@@ -1634,20 +1789,58 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n \n impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// Gets a reference to the key that would be used when inserting a value\n-    /// through the VacantEntry.\n+    /// through the `VacantEntry`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         &self.key\n     }\n \n     /// Take ownership of the key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_entry_recover_keys)]\n+    ///\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    ///\n+    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n+    ///     v.into_key();\n+    /// }\n+    /// ```\n     #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n     pub fn into_key(self) -> K {\n         self.key\n     }\n \n     /// Sets the value of the entry with the VacantEntry's key,\n-    /// and returns a mutable reference to it\n+    /// and returns a mutable reference to it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    ///\n+    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n+    ///     o.insert(37);\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 37);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         match self.elem {"}, {"sha": "48753ccf1c353cfe8ba172dbb347cf47c54f4f5e", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 125, "deletions": 18, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=edecc57cbf4fb2444224c5c9492d58221ec885f0", "patch": "@@ -58,28 +58,37 @@ pub struct File {\n \n /// Metadata information about a file.\n ///\n-/// This structure is returned from the `metadata` function or method and\n+/// This structure is returned from the [`metadata`] function or method and\n /// represents known metadata about a file such as its permissions, size,\n /// modification times, etc.\n+///\n+/// [`metadata`]: fn.metadata.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Metadata(fs_imp::FileAttr);\n \n /// Iterator over the entries in a directory.\n ///\n-/// This iterator is returned from the `read_dir` function of this module and\n-/// will yield instances of `io::Result<DirEntry>`. Through a `DirEntry`\n+/// This iterator is returned from the [`read_dir`] function of this module and\n+/// will yield instances of `io::Result<DirEntry>`. Through a [`DirEntry`]\n /// information like the entry's path and possibly other metadata can be\n /// learned.\n ///\n+/// [`read_dir`]: fn.read_dir.html\n+/// [`DirEntry`]: struct.DirEntry.html\n+///\n /// # Errors\n ///\n-/// This `io::Result` will be an `Err` if there's some sort of intermittent\n+/// This [`io::Result`] will be an `Err` if there's some sort of intermittent\n /// IO error during iteration.\n+///\n+/// [`io::Result`]: ../io/type.Result.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ReadDir(fs_imp::ReadDir);\n \n-/// Entries returned by the `ReadDir` iterator.\n+/// Entries returned by the [`ReadDir`] iterator.\n+///\n+/// [`ReadDir`]: struct.ReadDir.html\n ///\n /// An instance of `DirEntry` represents an entry inside of a directory on the\n /// filesystem. Each entry can be inspected via methods to learn about the full\n@@ -89,17 +98,23 @@ pub struct DirEntry(fs_imp::DirEntry);\n \n /// Options and flags which can be used to configure how a file is opened.\n ///\n-/// This builder exposes the ability to configure how a `File` is opened and\n-/// what operations are permitted on the open file. The `File::open` and\n-/// `File::create` methods are aliases for commonly used options using this\n+/// This builder exposes the ability to configure how a [`File`] is opened and\n+/// what operations are permitted on the open file. The [`File::open`] and\n+/// [`File::create`] methods are aliases for commonly used options using this\n /// builder.\n ///\n-/// Generally speaking, when using `OpenOptions`, you'll first call `new()`,\n-/// then chain calls to methods to set each option, then call `open()`, passing\n-/// the path of the file you're trying to open. This will give you a\n+/// [`File`]: struct.File.html\n+/// [`File::open`]: struct.File.html#method.open\n+/// [`File::create`]: struct.File.html#method.create\n+///\n+/// Generally speaking, when using `OpenOptions`, you'll first call [`new()`],\n+/// then chain calls to methods to set each option, then call [`open()`],\n+/// passing the path of the file you're trying to open. This will give you a\n /// [`io::Result`][result] with a [`File`][file] inside that you can further\n /// operate on.\n ///\n+/// [`new()`]: struct.OpenOptions.html#method.new\n+/// [`open()`]: struct.OpenOptions.html#method.open\n /// [result]: ../io/type.Result.html\n /// [file]: struct.File.html\n ///\n@@ -131,10 +146,12 @@ pub struct OpenOptions(fs_imp::OpenOptions);\n \n /// Representation of the various permissions on a file.\n ///\n-/// This module only currently provides one bit of information, `readonly`,\n+/// This module only currently provides one bit of information, [`readonly`],\n /// which is exposed on all currently supported platforms. Unix-specific\n /// functionality, such as mode bits, is available through the\n /// `os::unix::PermissionsExt` trait.\n+///\n+/// [`readonly`]: struct.Permissions.html#method.readonly\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Permissions(fs_imp::FilePermissions);\n@@ -156,12 +173,14 @@ pub struct DirBuilder {\n impl File {\n     /// Attempts to open a file in read-only mode.\n     ///\n-    /// See the `OpenOptions::open` method for more details.\n+    /// See the [`OpenOptions::open`] method for more details.\n     ///\n     /// # Errors\n     ///\n     /// This function will return an error if `path` does not already exist.\n-    /// Other errors may also be returned according to `OpenOptions::open`.\n+    /// Other errors may also be returned according to [`OpenOptions::open`].\n+    ///\n+    /// [`OpenOptions::open`]: struct.OpenOptions.html#method.open\n     ///\n     /// # Examples\n     ///\n@@ -183,7 +202,9 @@ impl File {\n     /// This function will create a file if it does not exist,\n     /// and will truncate it if it does.\n     ///\n-    /// See the `OpenOptions::open` function for more details.\n+    /// See the [`OpenOptions::open`] function for more details.\n+    ///\n+    /// [`OpenOptions::open`]: struct.OpenOptions.html#method.open\n     ///\n     /// # Examples\n     ///\n@@ -224,15 +245,17 @@ impl File {\n         self.inner.fsync()\n     }\n \n-    /// This function is similar to `sync_all`, except that it may not\n+    /// This function is similar to [`sync_all`], except that it may not\n     /// synchronize file metadata to the filesystem.\n     ///\n     /// This is intended for use cases that must synchronize content, but don't\n     /// need the metadata on disk. The goal of this method is to reduce disk\n     /// operations.\n     ///\n     /// Note that some platforms may simply implement this in terms of\n-    /// `sync_all`.\n+    /// [`sync_all`].\n+    ///\n+    /// [`sync_all`]: struct.File.html#method.sync_all\n     ///\n     /// # Examples\n     ///\n@@ -304,6 +327,18 @@ impl File {\n     /// The returned `File` is a reference to the same state that this object\n     /// references. Both handles will read and write with the same cursor\n     /// position.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let file_copy = try!(f.try_clone());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"file_try_clone\", since = \"1.9.0\")]\n     pub fn try_clone(&self) -> io::Result<File> {\n         Ok(File {\n@@ -829,6 +864,26 @@ impl DirEntry {\n     /// On Windows this function is cheap to call (no extra system calls\n     /// needed), but on Unix platforms this function is the equivalent of\n     /// calling `symlink_metadata` on the path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs;\n+    ///\n+    /// if let Ok(entries) = fs::read_dir(\".\") {\n+    ///     for entry in entries {\n+    ///         if let Ok(entry) = entry {\n+    ///             // Here, `entry` is a `DirEntry`.\n+    ///             if let Ok(metadata) = entry.metadata() {\n+    ///                 // Now let's show our entry's permissions!\n+    ///                 println!(\"{:?}: {:?}\", entry.path(), metadata.permissions());\n+    ///             } else {\n+    ///                 println!(\"Couldn't get metadata for {:?}\", entry.path());\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n     pub fn metadata(&self) -> io::Result<Metadata> {\n         self.0.metadata().map(Metadata)\n@@ -844,13 +899,48 @@ impl DirEntry {\n     /// On Windows and most Unix platforms this function is free (no extra\n     /// system calls needed), but some Unix platforms may require the equivalent\n     /// call to `symlink_metadata` to learn about the target file type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs;\n+    ///\n+    /// if let Ok(entries) = fs::read_dir(\".\") {\n+    ///     for entry in entries {\n+    ///         if let Ok(entry) = entry {\n+    ///             // Here, `entry` is a `DirEntry`.\n+    ///             if let Ok(file_type) = entry.file_type() {\n+    ///                 // Now let's show our entry's file type!\n+    ///                 println!(\"{:?}: {:?}\", entry.path(), file_type);\n+    ///             } else {\n+    ///                 println!(\"Couldn't get file type for {:?}\", entry.path());\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         self.0.file_type().map(FileType)\n     }\n \n     /// Returns the bare file name of this directory entry without any other\n     /// leading path component.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs;\n+    ///\n+    /// if let Ok(entries) = fs::read_dir(\".\") {\n+    ///     for entry in entries {\n+    ///         if let Ok(entry) = entry {\n+    ///             // Here, `entry` is a `DirEntry`.\n+    ///             println!(\"{:?}\", entry.file_name());\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n     pub fn file_name(&self) -> OsString {\n         self.0.file_name()\n@@ -1397,6 +1487,14 @@ pub fn set_permissions<P: AsRef<Path>>(path: P, perm: Permissions)\n impl DirBuilder {\n     /// Creates a new set of options with default mode/security settings for all\n     /// platforms and also non-recursive.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs::DirBuilder;\n+    ///\n+    /// let builder = DirBuilder::new();\n+    /// ```\n     #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n     pub fn new() -> DirBuilder {\n         DirBuilder {\n@@ -1409,7 +1507,16 @@ impl DirBuilder {\n     /// all parent directories if they do not exist with the same security and\n     /// permissions settings.\n     ///\n-    /// This option defaults to `false`\n+    /// This option defaults to `false`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs::DirBuilder;\n+    ///\n+    /// let mut builder = DirBuilder::new();\n+    /// builder.recursive(true);\n+    /// ```\n     #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n     pub fn recursive(&mut self, recursive: bool) -> &mut Self {\n         self.recursive = recursive;"}, {"sha": "54340773a42b52e5bb672e41edde061cc487f769", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edecc57cbf4fb2444224c5c9492d58221ec885f0/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=edecc57cbf4fb2444224c5c9492d58221ec885f0", "patch": "@@ -196,6 +196,22 @@ impl FileTypeExt for fs::FileType {\n pub trait DirEntryExt {\n     /// Returns the underlying `d_ino` field in the contained `dirent`\n     /// structure.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs;\n+    /// use std::os::unix::fs::DirEntryExt;\n+    ///\n+    /// if let Ok(entries) = fs::read_dir(\".\") {\n+    ///     for entry in entries {\n+    ///         if let Ok(entry) = entry {\n+    ///             // Here, `entry` is a `DirEntry`.\n+    ///             println!(\"{:?}: {}\", entry.file_name(), entry.ino());\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n     fn ino(&self) -> u64;\n }\n@@ -239,6 +255,16 @@ pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n pub trait DirBuilderExt {\n     /// Sets the mode to create new directories with. This option defaults to\n     /// 0o777.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore\n+    /// use std::fs::DirBuilder;\n+    /// use std::os::unix::fs::DirBuilderExt;\n+    ///\n+    /// let mut builder = DirBuilder::new();\n+    /// builder.mode(0o755);\n+    /// ```\n     #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n     fn mode(&mut self, mode: u32) -> &mut Self;\n }"}, {"sha": "b5b6ca7572703cc65fab869385623d0d4b924be5", "filename": "src/test/debuginfo/function-prologue-stepping-no-stack-check.rs", "status": "removed", "additions": 0, "deletions": 369, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/b541f5f0cc342dc6d31d7980f75c3d3d42f7587f/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b541f5f0cc342dc6d31d7980f75c3d3d42f7587f/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs?ref=b541f5f0cc342dc6d31d7980f75c3d3d42f7587f", "patch": "@@ -1,369 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-android: FIXME(#10381)\n-// min-lldb-version: 310\n-\n-// This test case checks if function arguments already have the correct value\n-// when breaking at the beginning of a function. Functions with the\n-// #[no_stack_check] attribute have the same prologue as regular C functions\n-// compiled with GCC or Clang and therefore are better handled by GDB. As a\n-// consequence, and as opposed to regular Rust functions, we can set the\n-// breakpoints via the function name (and don't have to fall back on using line\n-// numbers). For LLDB this shouldn't make a difference because it can handle\n-// both cases.\n-\n-// compile-flags:-g\n-\n-// === GDB TESTS ===================================================================================\n-\n-// gdb-command:rbreak immediate_args\n-// gdb-command:rbreak binding\n-// gdb-command:rbreak assignment\n-// gdb-command:rbreak function_call\n-// gdb-command:rbreak identifier\n-// gdb-command:rbreak return_expr\n-// gdb-command:rbreak arithmetic_expr\n-// gdb-command:rbreak if_expr\n-// gdb-command:rbreak while_expr\n-// gdb-command:rbreak loop_expr\n-// gdb-command:run\n-\n-// IMMEDIATE ARGS\n-// gdb-command:print a\n-// gdb-check:$1 = 1\n-// gdb-command:print b\n-// gdb-check:$2 = true\n-// gdb-command:print c\n-// gdb-check:$3 = 2.5\n-// gdb-command:continue\n-\n-// NON IMMEDIATE ARGS\n-// gdb-command:print a\n-// gdb-check:$4 = {a = 3, b = 4, c = 5, d = 6, e = 7, f = 8, g = 9, h = 10}\n-// gdb-command:print b\n-// gdb-check:$5 = {a = 11, b = 12, c = 13, d = 14, e = 15, f = 16, g = 17, h = 18}\n-// gdb-command:continue\n-\n-// BINDING\n-// gdb-command:print a\n-// gdb-check:$6 = 19\n-// gdb-command:print b\n-// gdb-check:$7 = 20\n-// gdb-command:print c\n-// gdb-check:$8 = 21.5\n-// gdb-command:continue\n-\n-// ASSIGNMENT\n-// gdb-command:print a\n-// gdb-check:$9 = 22\n-// gdb-command:print b\n-// gdb-check:$10 = 23\n-// gdb-command:print c\n-// gdb-check:$11 = 24.5\n-// gdb-command:continue\n-\n-// FUNCTION CALL\n-// gdb-command:print x\n-// gdb-check:$12 = 25\n-// gdb-command:print y\n-// gdb-check:$13 = 26\n-// gdb-command:print z\n-// gdb-check:$14 = 27.5\n-// gdb-command:continue\n-\n-// EXPR\n-// gdb-command:print x\n-// gdb-check:$15 = 28\n-// gdb-command:print y\n-// gdb-check:$16 = 29\n-// gdb-command:print z\n-// gdb-check:$17 = 30.5\n-// gdb-command:continue\n-\n-// RETURN EXPR\n-// gdb-command:print x\n-// gdb-check:$18 = 31\n-// gdb-command:print y\n-// gdb-check:$19 = 32\n-// gdb-command:print z\n-// gdb-check:$20 = 33.5\n-// gdb-command:continue\n-\n-// ARITHMETIC EXPR\n-// gdb-command:print x\n-// gdb-check:$21 = 34\n-// gdb-command:print y\n-// gdb-check:$22 = 35\n-// gdb-command:print z\n-// gdb-check:$23 = 36.5\n-// gdb-command:continue\n-\n-// IF EXPR\n-// gdb-command:print x\n-// gdb-check:$24 = 37\n-// gdb-command:print y\n-// gdb-check:$25 = 38\n-// gdb-command:print z\n-// gdb-check:$26 = 39.5\n-// gdb-command:continue\n-\n-// WHILE EXPR\n-// gdb-command:print x\n-// gdb-check:$27 = 40\n-// gdb-command:print y\n-// gdb-check:$28 = 41\n-// gdb-command:print z\n-// gdb-check:$29 = 42\n-// gdb-command:continue\n-\n-// LOOP EXPR\n-// gdb-command:print x\n-// gdb-check:$30 = 43\n-// gdb-command:print y\n-// gdb-check:$31 = 44\n-// gdb-command:print z\n-// gdb-check:$32 = 45\n-// gdb-command:continue\n-\n-\n-// === LLDB TESTS ==================================================================================\n-\n-// lldb-command:breakpoint set --name immediate_args\n-// lldb-command:breakpoint set --name non_immediate_args\n-// lldb-command:breakpoint set --name binding\n-// lldb-command:breakpoint set --name assignment\n-// lldb-command:breakpoint set --name function_call\n-// lldb-command:breakpoint set --name identifier\n-// lldb-command:breakpoint set --name return_expr\n-// lldb-command:breakpoint set --name arithmetic_expr\n-// lldb-command:breakpoint set --name if_expr\n-// lldb-command:breakpoint set --name while_expr\n-// lldb-command:breakpoint set --name loop_expr\n-// lldb-command:run\n-\n-// IMMEDIATE ARGS\n-// lldb-command:print a\n-// lldb-check:[...]$0 = 1\n-// lldb-command:print b\n-// lldb-check:[...]$1 = true\n-// lldb-command:print c\n-// lldb-check:[...]$2 = 2.5\n-// lldb-command:continue\n-\n-// NON IMMEDIATE ARGS\n-// lldb-command:print a\n-// lldb-check:[...]$3 = BigStruct { a: 3, b: 4, c: 5, d: 6, e: 7, f: 8, g: 9, h: 10 }\n-// lldb-command:print b\n-// lldb-check:[...]$4 = BigStruct { a: 11, b: 12, c: 13, d: 14, e: 15, f: 16, g: 17, h: 18 }\n-// lldb-command:continue\n-\n-// BINDING\n-// lldb-command:print a\n-// lldb-check:[...]$5 = 19\n-// lldb-command:print b\n-// lldb-check:[...]$6 = 20\n-// lldb-command:print c\n-// lldb-check:[...]$7 = 21.5\n-// lldb-command:continue\n-\n-// ASSIGNMENT\n-// lldb-command:print a\n-// lldb-check:[...]$8 = 22\n-// lldb-command:print b\n-// lldb-check:[...]$9 = 23\n-// lldb-command:print c\n-// lldb-check:[...]$10 = 24.5\n-// lldb-command:continue\n-\n-// FUNCTION CALL\n-// lldb-command:print x\n-// lldb-check:[...]$11 = 25\n-// lldb-command:print y\n-// lldb-check:[...]$12 = 26\n-// lldb-command:print z\n-// lldb-check:[...]$13 = 27.5\n-// lldb-command:continue\n-\n-// EXPR\n-// lldb-command:print x\n-// lldb-check:[...]$14 = 28\n-// lldb-command:print y\n-// lldb-check:[...]$15 = 29\n-// lldb-command:print z\n-// lldb-check:[...]$16 = 30.5\n-// lldb-command:continue\n-\n-// RETURN EXPR\n-// lldb-command:print x\n-// lldb-check:[...]$17 = 31\n-// lldb-command:print y\n-// lldb-check:[...]$18 = 32\n-// lldb-command:print z\n-// lldb-check:[...]$19 = 33.5\n-// lldb-command:continue\n-\n-// ARITHMETIC EXPR\n-// lldb-command:print x\n-// lldb-check:[...]$20 = 34\n-// lldb-command:print y\n-// lldb-check:[...]$21 = 35\n-// lldb-command:print z\n-// lldb-check:[...]$22 = 36.5\n-// lldb-command:continue\n-\n-// IF EXPR\n-// lldb-command:print x\n-// lldb-check:[...]$23 = 37\n-// lldb-command:print y\n-// lldb-check:[...]$24 = 38\n-// lldb-command:print z\n-// lldb-check:[...]$25 = 39.5\n-// lldb-command:continue\n-\n-// WHILE EXPR\n-// lldb-command:print x\n-// lldb-check:[...]$26 = 40\n-// lldb-command:print y\n-// lldb-check:[...]$27 = 41\n-// lldb-command:print z\n-// lldb-check:[...]$28 = 42\n-// lldb-command:continue\n-\n-// LOOP EXPR\n-// lldb-command:print x\n-// lldb-check:[...]$29 = 43\n-// lldb-command:print y\n-// lldb-check:[...]$30 = 44\n-// lldb-command:print z\n-// lldb-check:[...]$31 = 45\n-// lldb-command:continue\n-\n-#![allow(dead_code, unused_assignments, unused_variables)]\n-#![feature(omit_gdb_pretty_printer_section)]\n-#![omit_gdb_pretty_printer_section]\n-\n-#[no_stack_check]\n-fn immediate_args(a: isize, b: bool, c: f64) {\n-    println!(\"\");\n-}\n-\n-struct BigStruct {\n-    a: u64,\n-    b: u64,\n-    c: u64,\n-    d: u64,\n-    e: u64,\n-    f: u64,\n-    g: u64,\n-    h: u64\n-}\n-\n-#[no_stack_check]\n-fn non_immediate_args(a: BigStruct, b: BigStruct) {\n-    println!(\"\");\n-}\n-\n-#[no_stack_check]\n-fn binding(a: i64, b: u64, c: f64) {\n-    let x = 0;\n-    println!(\"\");\n-}\n-\n-#[no_stack_check]\n-fn assignment(mut a: u64, b: u64, c: f64) {\n-    a = b;\n-    println!(\"\");\n-}\n-\n-#[no_stack_check]\n-fn function_call(x: u64, y: u64, z: f64) {\n-    println!(\"Hi!\")\n-}\n-\n-#[no_stack_check]\n-fn identifier(x: u64, y: u64, z: f64) -> u64 {\n-    x\n-}\n-\n-#[no_stack_check]\n-fn return_expr(x: u64, y: u64, z: f64) -> u64 {\n-    return x;\n-}\n-\n-#[no_stack_check]\n-fn arithmetic_expr(x: u64, y: u64, z: f64) -> u64 {\n-    x + y\n-}\n-\n-#[no_stack_check]\n-fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n-    if x + y < 1000 {\n-        x\n-    } else {\n-        y\n-    }\n-}\n-\n-#[no_stack_check]\n-fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n-    while x + y < 1000 {\n-        x += z\n-    }\n-    return x;\n-}\n-\n-#[no_stack_check]\n-fn loop_expr(mut x: u64, y: u64, z: u64) -> u64 {\n-    loop {\n-        x += z;\n-\n-        if x + y > 1000 {\n-            return x;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    immediate_args(1, true, 2.5);\n-\n-    non_immediate_args(\n-        BigStruct {\n-            a: 3,\n-            b: 4,\n-            c: 5,\n-            d: 6,\n-            e: 7,\n-            f: 8,\n-            g: 9,\n-            h: 10\n-        },\n-        BigStruct {\n-            a: 11,\n-            b: 12,\n-            c: 13,\n-            d: 14,\n-            e: 15,\n-            f: 16,\n-            g: 17,\n-            h: 18\n-        }\n-    );\n-\n-    binding(19, 20, 21.5);\n-    assignment(22, 23, 24.5);\n-    function_call(25, 26, 27.5);\n-    identifier(28, 29, 30.5);\n-    return_expr(31, 32, 33.5);\n-    arithmetic_expr(34, 35, 36.5);\n-    if_expr(37, 38, 39.5);\n-    while_expr(40, 41, 42);\n-    loop_expr(43, 44, 45);\n-}"}]}