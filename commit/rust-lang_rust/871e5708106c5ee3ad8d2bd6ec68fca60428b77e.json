{"sha": "871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MWU1NzA4MTA2YzVlZTNhZDhkMmJkNmVjNjhmY2E2MDQyOGI3N2U=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-16T18:56:24Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-17T07:53:08Z"}, "message": "De-@ codemap and diagnostic.", "tree": {"sha": "7dc2002f3ffb245f6dfdd3b05fc4788ddb316f04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dc2002f3ffb245f6dfdd3b05fc4788ddb316f04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "html_url": "https://github.com/rust-lang/rust/commit/871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bb6de3076e17a8a25728f616b833e1060f06088", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb6de3076e17a8a25728f616b833e1060f06088", "html_url": "https://github.com/rust-lang/rust/commit/0bb6de3076e17a8a25728f616b833e1060f06088"}], "stats": {"total": 667, "additions": 311, "deletions": 356}, "files": [{"sha": "edb9d11b11a0d337821b167fd2425248896c175b", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -1352,9 +1352,8 @@ fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n     }\n \n     // Converts a library file-stem into a cc -l argument\n-    fn unlib(config: @session::Config, stem: &str) -> ~str {\n-        if stem.starts_with(\"lib\") &&\n-            config.os != abi::OsWin32 {\n+    fn unlib(config: &session::Config, stem: &str) -> ~str {\n+        if stem.starts_with(\"lib\") && config.os != abi::OsWin32 {\n             stem.slice(3, stem.len()).to_owned()\n         } else {\n             stem.to_owned()\n@@ -1434,7 +1433,7 @@ fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n             // what its name is\n             let dir = cratepath.dirname_str().unwrap();\n             if !dir.is_empty() { args.push(\"-L\" + dir); }\n-            let libarg = unlib(sess.targ_cfg, cratepath.filestem_str().unwrap());\n+            let libarg = unlib(&sess.targ_cfg, cratepath.filestem_str().unwrap());\n             args.push(\"-l\" + libarg);\n         }\n     }"}, {"sha": "a14fda080bb3aa716708e89fd83e7d407de8fb2a", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -27,7 +27,7 @@ use middle::{trans, freevars, kind, ty, typeck, lint, astencode, reachable};\n use middle;\n use util::common::time;\n use util::ppaux;\n-use util::nodemap::NodeSet;\n+use util::nodemap::{NodeMap, NodeSet};\n \n use serialize::{json, Encodable};\n \n@@ -39,7 +39,6 @@ use std::mem::drop;\n use std::os;\n use std::vec_ng::Vec;\n use std::vec_ng;\n-use collections::HashMap;\n use getopts::{optopt, optmulti, optflag, optflagopt};\n use getopts;\n use syntax::ast;\n@@ -75,9 +74,9 @@ pub fn anon_src() -> ~str {\n \n pub fn source_name(input: &Input) -> ~str {\n     match *input {\n-      // FIXME (#9639): This needs to handle non-utf8 paths\n-      FileInput(ref ifile) => ifile.as_str().unwrap().to_str(),\n-      StrInput(_) => anon_src()\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        FileInput(ref ifile) => ifile.as_str().unwrap().to_str(),\n+        StrInput(_) => anon_src()\n     }\n }\n \n@@ -213,7 +212,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                                     -> (ast::Crate, syntax::ast_map::Map) {\n     let time_passes = sess.time_passes();\n \n-    sess.building_library.set(session::building_library(sess.opts, &krate));\n+    sess.building_library.set(session::building_library(&sess.opts, &krate));\n     sess.crate_types.set(session::collect_crate_types(sess,\n                                                       krate.attrs\n                                                            .as_slice()));\n@@ -315,7 +314,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     sess.macro_registrar_fn.with_mut(|r| *r =\n         time(time_passes, \"looking for macro registrar\", (), |_|\n             syntax::ext::registrar::find_macro_registrar(\n-                sess.span_diagnostic, krate)));\n+                sess.diagnostic(), krate)));\n \n     let freevars = time(time_passes, \"freevar finding\", (), |_|\n                         freevars::annotate_freevars(def_map, krate));\n@@ -541,19 +540,14 @@ fn write_out_deps(sess: &Session,\n \n     // Build a list of files used to compile the output and\n     // write Makefile-compatible dependency rules\n-    let files: Vec<~str> = {\n-        let files = sess.codemap.files.borrow();\n-        files.get()\n-             .iter()\n-             .filter_map(|fmap| {\n-                 if fmap.is_real_file() {\n-                     Some(fmap.name.clone())\n-                 } else {\n-                     None\n-                 }\n-             })\n-             .collect()\n-    };\n+    let files: Vec<~str> = sess.codemap().files.borrow().get()\n+                               .iter().filter_map(|fmap| {\n+                                    if fmap.deref().is_real_file() {\n+                                        Some(fmap.deref().name.clone())\n+                                    } else {\n+                                        None\n+                                    }\n+                                }).collect();\n     let mut file = try!(io::File::create(&deps_filename));\n     for path in out_filenames.iter() {\n         try!(write!(&mut file as &mut Writer,\n@@ -741,8 +735,7 @@ static architecture_abis : &'static [(&'static str, abi::Architecture)] = &'stat\n \n     (\"mips\",   abi::Mips)];\n \n-pub fn build_target_config(sopts: @session::Options)\n-                           -> @session::Config {\n+pub fn build_target_config(sopts: &session::Options) -> session::Config {\n     let os = match get_os(sopts.target_triple) {\n       Some(os) => os,\n       None => early_error(\"unknown operating system\")\n@@ -764,14 +757,13 @@ pub fn build_target_config(sopts: @session::Options)\n       abi::Arm => arm::get_target_strs(target_triple, os),\n       abi::Mips => mips::get_target_strs(target_triple, os)\n     };\n-    let target_cfg = @session::Config {\n+    session::Config {\n         os: os,\n         arch: arch,\n         target_strs: target_strs,\n         int_type: int_type,\n         uint_type: uint_type,\n-    };\n-    return target_cfg;\n+    }\n }\n \n pub fn host_triple() -> ~str {\n@@ -938,7 +930,7 @@ pub fn build_session_options(matches: &getopts::Matches)\n                        matches.opt_present(\"crate-file-name\"));\n     let cg = build_codegen_options(matches);\n \n-    @session::Options {\n+    session::Options {\n         crate_types: crate_types,\n         gc: gc,\n         optimize: opt_level,\n@@ -991,25 +983,24 @@ pub fn build_codegen_options(matches: &getopts::Matches)\n     return cg;\n }\n \n-pub fn build_session(sopts: @session::Options,\n+pub fn build_session(sopts: session::Options,\n                      local_crate_source_file: Option<Path>)\n                      -> Session {\n-    let codemap = @codemap::CodeMap::new();\n+    let codemap = codemap::CodeMap::new();\n     let diagnostic_handler =\n         diagnostic::default_handler();\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n-    build_session_(sopts, local_crate_source_file, codemap, span_diagnostic_handler)\n+    build_session_(sopts, local_crate_source_file, span_diagnostic_handler)\n }\n \n-pub fn build_session_(sopts: @session::Options,\n+pub fn build_session_(sopts: session::Options,\n                       local_crate_source_file: Option<Path>,\n-                      codemap: @codemap::CodeMap,\n-                      span_diagnostic_handler: @diagnostic::SpanHandler)\n+                      span_diagnostic: diagnostic::SpanHandler)\n                       -> Session {\n-    let target_cfg = build_target_config(sopts);\n-    let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler, codemap);\n+    let target_cfg = build_target_config(&sopts);\n+    let p_s = parse::new_parse_sess_special_handler(span_diagnostic);\n     let default_sysroot = match sopts.maybe_sysroot {\n         Some(_) => None,\n         None => Some(filesearch::get_or_default_sysroot())\n@@ -1029,19 +1020,17 @@ pub fn build_session_(sopts: @session::Options,\n         opts: sopts,\n         cstore: CStore::new(token::get_ident_interner()),\n         parse_sess: p_s,\n-        codemap: codemap,\n         // For a library crate, this is always none\n         entry_fn: RefCell::new(None),\n         entry_type: Cell::new(None),\n         macro_registrar_fn: RefCell::new(None),\n-        span_diagnostic: span_diagnostic_handler,\n         default_sysroot: default_sysroot,\n         building_library: Cell::new(false),\n         local_crate_source_file: local_crate_source_file,\n         working_dir: os::getcwd(),\n-        lints: RefCell::new(HashMap::new()),\n+        lints: RefCell::new(NodeMap::new()),\n         node_id: Cell::new(1),\n-        crate_types: @RefCell::new(Vec::new()),\n+        crate_types: RefCell::new(Vec::new()),\n         features: front::feature_gate::Features::new(),\n         recursion_limit: Cell::new(64),\n     }"}, {"sha": "8d3048a80b29f6cfc3365ee5611c464b5df605d2", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -16,6 +16,7 @@ use front;\n use metadata::filesearch;\n use metadata;\n use middle::lint;\n+use util::nodemap::NodeMap;\n \n use syntax::attr::AttrMetaMethods;\n use syntax::ast::NodeId;\n@@ -28,7 +29,7 @@ use syntax;\n \n use std::cell::{Cell, RefCell};\n use std::vec_ng::Vec;\n-use collections::{HashMap,HashSet};\n+use collections::HashSet;\n \n pub struct Config {\n     os: abi::Os,\n@@ -174,26 +175,23 @@ pub enum CrateType {\n }\n \n pub struct Session {\n-    targ_cfg: @Config,\n-    opts: @Options,\n+    targ_cfg: Config,\n+    opts: Options,\n     cstore: metadata::cstore::CStore,\n     parse_sess: ParseSess,\n-    codemap: @codemap::CodeMap,\n     // For a library crate, this is always none\n     entry_fn: RefCell<Option<(NodeId, codemap::Span)>>,\n     entry_type: Cell<Option<EntryFnType>>,\n-    span_diagnostic: @diagnostic::SpanHandler,\n     macro_registrar_fn: RefCell<Option<ast::DefId>>,\n     default_sysroot: Option<Path>,\n     building_library: Cell<bool>,\n     // The name of the root source file of the crate, in the local file system. The path is always\n     // expected to be absolute. `None` means that there is no source file.\n     local_crate_source_file: Option<Path>,\n     working_dir: Path,\n-    lints: RefCell<HashMap<ast::NodeId,\n-                           Vec<(lint::Lint, codemap::Span, ~str)> >>,\n+    lints: RefCell<NodeMap<Vec<(lint::Lint, codemap::Span, ~str)>>>,\n     node_id: Cell<ast::NodeId>,\n-    crate_types: @RefCell<Vec<CrateType> >,\n+    crate_types: RefCell<Vec<CrateType>>,\n     features: front::feature_gate::Features,\n \n     /// The maximum recursion limit for potentially infinitely recursive\n@@ -203,52 +201,52 @@ pub struct Session {\n \n impl Session {\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n-        self.span_diagnostic.span_fatal(sp, msg)\n+        self.diagnostic().span_fatal(sp, msg)\n     }\n     pub fn fatal(&self, msg: &str) -> ! {\n-        self.span_diagnostic.handler().fatal(msg)\n+        self.diagnostic().handler().fatal(msg)\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n-        self.span_diagnostic.span_err(sp, msg)\n+        self.diagnostic().span_err(sp, msg)\n     }\n     pub fn err(&self, msg: &str) {\n-        self.span_diagnostic.handler().err(msg)\n+        self.diagnostic().handler().err(msg)\n     }\n     pub fn err_count(&self) -> uint {\n-        self.span_diagnostic.handler().err_count()\n+        self.diagnostic().handler().err_count()\n     }\n     pub fn has_errors(&self) -> bool {\n-        self.span_diagnostic.handler().has_errors()\n+        self.diagnostic().handler().has_errors()\n     }\n     pub fn abort_if_errors(&self) {\n-        self.span_diagnostic.handler().abort_if_errors()\n+        self.diagnostic().handler().abort_if_errors()\n     }\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n-        self.span_diagnostic.span_warn(sp, msg)\n+        self.diagnostic().span_warn(sp, msg)\n     }\n     pub fn warn(&self, msg: &str) {\n-        self.span_diagnostic.handler().warn(msg)\n+        self.diagnostic().handler().warn(msg)\n     }\n     pub fn span_note(&self, sp: Span, msg: &str) {\n-        self.span_diagnostic.span_note(sp, msg)\n+        self.diagnostic().span_note(sp, msg)\n     }\n     pub fn span_end_note(&self, sp: Span, msg: &str) {\n-        self.span_diagnostic.span_end_note(sp, msg)\n+        self.diagnostic().span_end_note(sp, msg)\n     }\n     pub fn note(&self, msg: &str) {\n-        self.span_diagnostic.handler().note(msg)\n+        self.diagnostic().handler().note(msg)\n     }\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n-        self.span_diagnostic.span_bug(sp, msg)\n+        self.diagnostic().span_bug(sp, msg)\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.span_diagnostic.handler().bug(msg)\n+        self.diagnostic().handler().bug(msg)\n     }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n-        self.span_diagnostic.span_unimpl(sp, msg)\n+        self.diagnostic().span_unimpl(sp, msg)\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n-        self.span_diagnostic.handler().unimpl(msg)\n+        self.diagnostic().handler().unimpl(msg)\n     }\n     pub fn add_lint(&self,\n                     lint: lint::Lint,\n@@ -275,12 +273,15 @@ impl Session {\n \n         v\n     }\n-    pub fn diagnostic(&self) -> @diagnostic::SpanHandler {\n-        self.span_diagnostic\n+    pub fn diagnostic<'a>(&'a self) -> &'a diagnostic::SpanHandler {\n+        &self.parse_sess.span_diagnostic\n     }\n     pub fn debugging_opt(&self, opt: u64) -> bool {\n         (self.opts.debugging_opts & opt) != 0\n     }\n+    pub fn codemap<'a>(&'a self) -> &'a codemap::CodeMap {\n+        &self.parse_sess.span_diagnostic.cm\n+    }\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n@@ -328,8 +329,8 @@ impl Session {\n }\n \n /// Some reasonable defaults\n-pub fn basic_options() -> @Options {\n-    @Options {\n+pub fn basic_options() -> Options {\n+    Options {\n         crate_types: Vec::new(),\n         gc: false,\n         optimize: No,"}, {"sha": "9409d8c457fb4ee96f1c8e65eae978359c3f4015", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -295,26 +295,26 @@ pub fn run_compiler(args: &[~str]) {\n         d::parse_pretty(&sess, a)\n     });\n     match pretty {\n-      Some::<d::PpMode>(ppm) => {\n-        d::pretty_print_input(sess, cfg, &input, ppm);\n-        return;\n-      }\n-      None::<d::PpMode> => {/* continue */ }\n+        Some::<d::PpMode>(ppm) => {\n+            d::pretty_print_input(sess, cfg, &input, ppm);\n+            return;\n+        }\n+        None::<d::PpMode> => {/* continue */ }\n     }\n     let ls = matches.opt_present(\"ls\");\n     if ls {\n         match input {\n-          d::FileInput(ref ifile) => {\n-            let mut stdout = io::stdout();\n-            d::list_metadata(&sess, &(*ifile), &mut stdout).unwrap();\n-          }\n-          d::StrInput(_) => {\n-            d::early_error(\"can not list metadata for stdin\");\n-          }\n+            d::FileInput(ref ifile) => {\n+                let mut stdout = io::stdout();\n+                d::list_metadata(&sess, &(*ifile), &mut stdout).unwrap();\n+            }\n+            d::StrInput(_) => {\n+                d::early_error(\"can not list metadata for stdin\");\n+            }\n         }\n         return;\n     }\n-    let (crate_id, crate_name, crate_file_name) = sopts.print_metas;\n+    let (crate_id, crate_name, crate_file_name) = sess.opts.print_metas;\n     // these nasty nested conditions are to avoid doing extra work\n     if crate_id || crate_name || crate_file_name {\n         let attrs = parse_crate_attrs(&sess, &input);"}, {"sha": "74e180072faa49bb28ee13c8390c02c522752c59", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -88,7 +88,7 @@ fn dump_crates(crate_cache: &[cache_entry]) {\n }\n \n fn warn_if_multiple_versions(e: &mut Env,\n-                             diag: @SpanHandler,\n+                             diag: &SpanHandler,\n                              crate_cache: &[cache_entry]) {\n     if crate_cache.len() != 0u {\n         let name = crate_cache[crate_cache.len() - 1].crate_id.name.clone();"}, {"sha": "d41d01f3c85cba4feef522fb6e6ac60818b9cb56", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -214,11 +214,11 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(class_id.krate);\n     let all_items = reader::get_doc(reader::Doc(cdata.data()), tag_items);\n-    let class_doc = expect(tcx.diag,\n+    let class_doc = expect(tcx.sess.diagnostic(),\n                            decoder::maybe_find_item(class_id.node, all_items),\n                            || format!(\"get_field_type: class ID {:?} not found\",\n                                    class_id) );\n-    let the_field = expect(tcx.diag,\n+    let the_field = expect(tcx.sess.diagnostic(),\n         decoder::maybe_find_item(def.node, class_doc),\n         || format!(\"get_field_type: in class {:?}, field ID {:?} not found\",\n                  class_id, def) );"}, {"sha": "b869e0a7d91ce13b644633c11aeff562667d5ab0", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -68,7 +68,7 @@ pub type EncodeInlinedItem<'a> = 'a |ecx: &EncodeContext,\n                                      ii: InlinedItemRef|;\n \n pub struct EncodeParams<'a> {\n-    diag: @SpanHandler,\n+    diag: &'a SpanHandler,\n     tcx: &'a ty::ctxt,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'a RefCell<NodeMap<~str>>,\n@@ -95,7 +95,7 @@ pub struct Stats {\n }\n \n pub struct EncodeContext<'a> {\n-    diag: @SpanHandler,\n+    diag: &'a SpanHandler,\n     tcx: &'a ty::ctxt,\n     stats: @Stats,\n     reexports2: middle::resolve::ExportMap2,\n@@ -904,7 +904,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     }\n \n     debug!(\"encoding info for item at {}\",\n-           ecx.tcx.sess.codemap.span_to_str(item.span));\n+           ecx.tcx.sess.codemap().span_to_str(item.span));\n \n     let def_id = local_def(item.id);\n     match item.node {\n@@ -1630,7 +1630,7 @@ impl<'a, 'b> Visitor<()> for MacroDefVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n         match item.node {\n             ItemMac(..) => {\n-                let def = self.ecx.tcx.sess.codemap.span_to_snippet(item.span)\n+                let def = self.ecx.tcx.sess.codemap().span_to_snippet(item.span)\n                     .expect(\"Unable to find source for macro\");\n                 self.ebml_w.start_tag(tag_macro_def);\n                 self.ebml_w.wr_str(def);\n@@ -1901,7 +1901,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n // Get the encoded string for a type\n pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> ~str {\n     let cx = &tyencode::ctxt {\n-        diag: tcx.diag,\n+        diag: tcx.sess.diagnostic(),\n         ds: def_to_str,\n         tcx: tcx,\n         abbrevs: tyencode::ac_no_abbrevs};"}, {"sha": "28556105c7b9c902b1467d372f015a046881815a", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -352,7 +352,7 @@ impl<'a> Context<'a> {\n     }\n }\n \n-pub fn note_crateid_attr(diag: @SpanHandler, crateid: &CrateId) {\n+pub fn note_crateid_attr(diag: &SpanHandler, crateid: &CrateId) {\n     diag.handler().note(format!(\"crate_id: {}\", crateid.to_str()));\n }\n "}, {"sha": "e78fe8e72a8d12f418ae0b8701373a462b3a4dc8", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -29,16 +29,15 @@ use syntax::ast;\n use syntax::ast::*;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token;\n-use syntax::print::pprust::*;\n \n macro_rules! mywrite( ($wr:expr, $($arg:tt)*) => (\n     format_args!(|a| { mywrite($wr, a) }, $($arg)*)\n ) )\n \n pub struct ctxt<'a> {\n-    diag: @SpanHandler,\n+    diag: &'a SpanHandler,\n     // Def -> str Callback:\n-    ds: extern \"Rust\" fn(DefId) -> ~str,\n+    ds: fn(DefId) -> ~str,\n     // The type context.\n     tcx: &'a ty::ctxt,\n     abbrevs: abbrev_ctxt"}, {"sha": "2d4cbee243e89aff59a37ba2a7caf6dcff9f4e6c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -153,7 +153,7 @@ enum LiveNodeKind {\n }\n \n fn live_node_kind_to_str(lnk: LiveNodeKind, cx: &ty::ctxt) -> ~str {\n-    let cm = cx.sess.codemap;\n+    let cm = cx.sess.codemap();\n     match lnk {\n         FreeVarNode(s) => format!(\"Free var node [{}]\", cm.span_to_str(s)),\n         ExprNode(s)    => format!(\"Expr node [{}]\", cm.span_to_str(s)),"}, {"sha": "a13dce65f513e3e82b4dca0b23e2ab1587fa1597", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -847,7 +847,7 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n                                body.id={}, \\\n                                cx.parent={})\",\n            id,\n-           visitor.sess.codemap.span_to_str(sp),\n+           visitor.sess.codemap().span_to_str(sp),\n            body.id,\n            cx.parent);\n "}, {"sha": "2784be5a01bcd6c6f4cbc21b3b8a02015f9584cb", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -3275,7 +3275,7 @@ impl<'a> Resolver<'a> {\n         let import_count = imports.get().len();\n         if index != import_count {\n             let sn = self.session\n-                         .codemap\n+                         .codemap()\n                          .span_to_snippet(imports.get().get(index).span)\n                          .unwrap();\n             if sn.contains(\"::\") {\n@@ -5449,7 +5449,7 @@ impl<'a> Resolver<'a> {\n     // public or private item, we will check the correct thing, dependent on how the import\n     // is used.\n     fn finalize_import(&mut self, id: NodeId, span: Span) {\n-        debug!(\"finalizing import uses for {}\", self.session.codemap.span_to_snippet(span));\n+        debug!(\"finalizing import uses for {}\", self.session.codemap().span_to_snippet(span));\n \n         if !self.used_imports.contains(&(id, TypeNS)) &&\n            !self.used_imports.contains(&(id, ValueNS)) {"}, {"sha": "c403d323bf4ce66077a49e620945d19c20e42e98", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -749,7 +749,7 @@ impl<'a> Builder<'a> {\n \n     pub fn add_span_comment(&self, sp: Span, text: &str) {\n         if self.ccx.sess().asm_comments() {\n-            let s = format!(\"{} ({})\", text, self.ccx.sess().codemap.span_to_str(sp));\n+            let s = format!(\"{} ({})\", text, self.ccx.sess().codemap().span_to_str(sp));\n             debug!(\"{}\", s);\n             self.add_comment(s);\n         }"}, {"sha": "e812f36e85d68a5d0084ac59fdd8e6cb04915bca", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -941,9 +941,9 @@ pub fn dummy_substs(tps: Vec<ty::t> ) -> ty::substs {\n \n pub fn filename_and_line_num_from_span(bcx: &Block, span: Span)\n                                        -> (ValueRef, ValueRef) {\n-    let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n+    let loc = bcx.sess().codemap().lookup_char_pos(span.lo);\n     let filename_cstr = C_cstr(bcx.ccx(),\n-                               token::intern_and_get_ident(loc.file.name));\n+                               token::intern_and_get_ident(loc.file.deref().name));\n     let filename = build::PointerCast(bcx, filename_cstr, Type::i8p(bcx.ccx()));\n     let line = C_int(bcx.ccx(), loc.line as int);\n     (filename, line)"}, {"sha": "4ed4f0fb3102c44944872682845875d7101d859a", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -132,13 +132,11 @@ impl CrateContext {\n             let metadata_llmod = format!(\"{}_metadata\", name).with_c_str(|buf| {\n                 llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n             });\n-            let data_layout: &str = tcx.sess.targ_cfg.target_strs.data_layout;\n-            let targ_triple: &str = tcx.sess.targ_cfg.target_strs.target_triple;\n-            data_layout.with_c_str(|buf| {\n+            tcx.sess.targ_cfg.target_strs.data_layout.with_c_str(|buf| {\n                 llvm::LLVMSetDataLayout(llmod, buf);\n                 llvm::LLVMSetDataLayout(metadata_llmod, buf);\n             });\n-            targ_triple.with_c_str(|buf| {\n+            tcx.sess.targ_cfg.target_strs.target_triple.with_c_str(|buf| {\n                 llvm::LLVMRustSetNormalizedTarget(llmod, buf);\n                 llvm::LLVMRustSetNormalizedTarget(metadata_llmod, buf);\n             });"}, {"sha": "2796eaeb129d80df2f67fa9f969ffb01a2d47a41", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -331,13 +331,11 @@ pub fn trans_fail<'a>(\n                   sp: Span,\n                   fail_str: InternedString)\n                   -> &'a Block<'a> {\n-    let v_fail_str = C_cstr(bcx.ccx(), fail_str);\n-    let _icx = push_ctxt(\"trans_fail_value\");\n     let ccx = bcx.ccx();\n-    let sess = bcx.sess();\n-    let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-    let v_filename = C_cstr(bcx.ccx(),\n-                            token::intern_and_get_ident(loc.file.name));\n+    let v_fail_str = C_cstr(ccx, fail_str);\n+    let _icx = push_ctxt(\"trans_fail_value\");\n+    let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n+    let v_filename = C_cstr(ccx, token::intern_and_get_ident(loc.file.deref().name));\n     let v_line = loc.line as int;\n     let v_str = PointerCast(bcx, v_fail_str, Type::i8p(ccx));\n     let v_filename = PointerCast(bcx, v_filename, Type::i8p(ccx));"}, {"sha": "b044ee15b3b133b3de0db8b021b00b89a5444436", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -485,7 +485,7 @@ pub fn set_source_location(fcx: &FunctionContext,\n \n     let cx = fcx.ccx;\n \n-    debug!(\"set_source_location: {}\", cx.sess().codemap.span_to_str(span));\n+    debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_str(span));\n \n     if fcx.debug_context.get_ref(cx, span).source_locations_enabled.get() {\n         let loc = span_start(cx, span);\n@@ -616,7 +616,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     }\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.deref().name);\n \n     let function_type_metadata = unsafe {\n         let fn_signature = get_function_signature(cx, fn_ast_id, fn_decl, param_substs, span);\n@@ -939,7 +939,7 @@ fn declare_local(bcx: &Block,\n                  span: Span) {\n     let cx: &CrateContext = bcx.ccx();\n \n-    let filename = span_start(cx, span).file.name.clone();\n+    let filename = span_start(cx, span).file.deref().name.clone();\n     let file_metadata = file_metadata(cx, filename);\n \n     let name = token::get_ident(variable_ident);\n@@ -1195,7 +1195,7 @@ fn prepare_struct_metadata(cx: &CrateContext,\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id);\n \n-    let file_name = span_start(cx, definition_span).file.name.clone();\n+    let file_name = span_start(cx, definition_span).file.deref().name.clone();\n     let file_metadata = file_metadata(cx, file_name);\n \n     let struct_metadata_stub = create_struct_stub(cx,\n@@ -1292,7 +1292,7 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n     let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.deref().name);\n \n     UnfinishedMetadata {\n         cache_id: cache_id_for_type(tuple_type),\n@@ -1452,7 +1452,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n     let loc = span_start(cx, definition_span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.deref().name);\n \n     // For empty enums there is an early exit. Just describe it as an empty struct with the\n     // appropriate type name\n@@ -1791,7 +1791,7 @@ fn boxed_type_metadata(cx: &CrateContext,\n     ];\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.deref().name);\n \n     return composite_type_metadata(\n         cx,\n@@ -1892,16 +1892,16 @@ fn vec_metadata(cx: &CrateContext,\n     assert!(member_descriptions.len() == member_llvm_types.len());\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.deref().name);\n \n-    return composite_type_metadata(\n+    composite_type_metadata(\n         cx,\n         vec_llvm_type,\n         vec_type_name,\n         member_descriptions,\n         file_metadata,\n         file_metadata,\n-        span);\n+        span)\n }\n \n fn vec_slice_metadata(cx: &CrateContext,\n@@ -1943,7 +1943,7 @@ fn vec_slice_metadata(cx: &CrateContext,\n     assert!(member_descriptions.len() == member_llvm_types.len());\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.deref().name);\n \n     return composite_type_metadata(\n         cx,\n@@ -1969,7 +1969,7 @@ fn subroutine_type_metadata(cx: &CrateContext,\n                             span: Span)\n                          -> DICompositeType {\n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.deref().name);\n \n     let mut signature_metadata: Vec<DIType> =\n         Vec::with_capacity(signature.inputs.len() + 1);\n@@ -2015,7 +2015,7 @@ fn trait_metadata(cx: &CrateContext,\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id);\n \n-    let file_name = span_start(cx, definition_span).file.name.clone();\n+    let file_name = span_start(cx, definition_span).file.deref().name.clone();\n     let file_metadata = file_metadata(cx, file_name);\n \n     let trait_llvm_type = type_of::type_of(cx, trait_type);\n@@ -2218,7 +2218,7 @@ fn generate_unique_type_id(prefix: &'static str) -> ~str {\n \n /// Return codemap::Loc corresponding to the beginning of the span\n fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n-    cx.sess().codemap.lookup_char_pos(span.lo)\n+    cx.sess().codemap().lookup_char_pos(span.lo)\n }\n \n fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (u64, u64) {\n@@ -2315,8 +2315,8 @@ fn populate_scope_map(cx: &CrateContext,\n                                    &mut Vec<ScopeStackEntry> ,\n                                    &mut HashMap<ast::NodeId, DIScope>|) {\n         // Create a new lexical scope and push it onto the stack\n-        let loc = cx.sess().codemap.lookup_char_pos(scope_span.lo);\n-        let file_metadata = file_metadata(cx, loc.file.name);\n+        let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n+        let file_metadata = file_metadata(cx, loc.file.deref().name);\n         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n         let scope_metadata = unsafe {\n@@ -2432,8 +2432,8 @@ fn populate_scope_map(cx: &CrateContext,\n \n                     if need_new_scope {\n                         // Create a new lexical scope and push it onto the stack\n-                        let loc = cx.sess().codemap.lookup_char_pos(pat.span.lo);\n-                        let file_metadata = file_metadata(cx, loc.file.name);\n+                        let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n+                        let file_metadata = file_metadata(cx, loc.file.deref().name);\n                         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                         let scope_metadata = unsafe {"}, {"sha": "ae940ebeef2eb14f9c0b1511769bc552d83a37ff", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -253,7 +253,6 @@ pub enum AutoRef {\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n pub struct ctxt {\n-    diag: @syntax::diagnostic::SpanHandler,\n     // Specifically use a speedy hash algorithm for this hash map, it's used\n     // quite often.\n     interner: RefCell<FnvHashMap<intern_key, ~t_box_>>,\n@@ -1088,7 +1087,6 @@ pub fn mk_ctxt(s: Session,\n     ctxt {\n         named_region_map: named_region_map,\n         item_variance_map: RefCell::new(DefIdMap::new()),\n-        diag: s.diagnostic(),\n         interner: RefCell::new(FnvHashMap::new()),\n         next_id: Cell::new(primitives::LAST_PRIMITIVE_ID),\n         sess: s,"}, {"sha": "b3d3e59ea6b3f16afc8530ec9a202c50affad7bc", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -139,9 +139,8 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n     };\n \n     fn explain_span(cx: &ctxt, heading: &str, span: Span)\n-        -> (~str, Option<Span>)\n-    {\n-        let lo = cx.sess.codemap.lookup_char_pos_adj(span.lo);\n+        -> (~str, Option<Span>) {\n+        let lo = cx.sess.codemap().lookup_char_pos_adj(span.lo);\n         (format!(\"the {} at {}:{}\", heading,\n               lo.line, lo.col.to_uint()), Some(span))\n     }\n@@ -172,28 +171,28 @@ pub fn ReScope_id_to_str(cx: &ctxt, node_id: ast::NodeId) -> ~str {\n     match cx.map.find(node_id) {\n       Some(ast_map::NodeBlock(ref blk)) => {\n         format!(\"<block at {}>\",\n-             cx.sess.codemap.span_to_str(blk.span))\n+             cx.sess.codemap().span_to_str(blk.span))\n       }\n       Some(ast_map::NodeExpr(expr)) => {\n         match expr.node {\n           ast::ExprCall(..) => {\n             format!(\"<call at {}>\",\n-                 cx.sess.codemap.span_to_str(expr.span))\n+                 cx.sess.codemap().span_to_str(expr.span))\n           }\n           ast::ExprMatch(..) => {\n             format!(\"<match at {}>\",\n-                 cx.sess.codemap.span_to_str(expr.span))\n+                 cx.sess.codemap().span_to_str(expr.span))\n           }\n           ast::ExprAssignOp(..) |\n           ast::ExprUnary(..) |\n           ast::ExprBinary(..) |\n           ast::ExprIndex(..) => {\n             format!(\"<method at {}>\",\n-                 cx.sess.codemap.span_to_str(expr.span))\n+                 cx.sess.codemap().span_to_str(expr.span))\n           }\n           _ => {\n             format!(\"<expression at {}>\",\n-                 cx.sess.codemap.span_to_str(expr.span))\n+                 cx.sess.codemap().span_to_str(expr.span))\n           }\n         }\n       }\n@@ -972,7 +971,7 @@ impl Repr for ty::BuiltinBounds {\n \n impl Repr for Span {\n     fn repr(&self, tcx: &ctxt) -> ~str {\n-        tcx.sess.codemap.span_to_str(*self)\n+        tcx.sess.codemap().span_to_str(*self)\n     }\n }\n "}, {"sha": "65a0f473db2295b1fa81974157c0f9fc7dadc910", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -375,7 +375,7 @@ pub fn find_stability<AM: AttrMetaMethods, It: Iterator<AM>>(mut metas: It)\n     None\n }\n \n-pub fn require_unique_names(diagnostic: @SpanHandler, metas: &[@MetaItem]) {\n+pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[@MetaItem]) {\n     let mut set = HashSet::new();\n     for meta in metas.iter() {\n         let name = meta.name();\n@@ -400,7 +400,7 @@ pub fn require_unique_names(diagnostic: @SpanHandler, metas: &[@MetaItem]) {\n  * present (before fields, if any) with that type; reprensentation\n  * optimizations which would remove it will not be done.\n  */\n-pub fn find_repr_attr(diagnostic: @SpanHandler, attr: @ast::MetaItem, acc: ReprAttr)\n+pub fn find_repr_attr(diagnostic: &SpanHandler, attr: @ast::MetaItem, acc: ReprAttr)\n     -> ReprAttr {\n     let mut acc = acc;\n     match attr.node {\n@@ -438,7 +438,7 @@ pub fn find_repr_attr(diagnostic: @SpanHandler, attr: @ast::MetaItem, acc: ReprA\n         // Not a \"repr\" hint: ignore.\n         _ => { }\n     }\n-    return acc;\n+    acc\n }\n \n fn int_type_of_word(s: &str) -> Option<IntType> {"}, {"sha": "4bfd5391a8f10d1e1642b788cd592c85d3c4df69", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 54, "deletions": 67, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -23,6 +23,7 @@ source code snippets, etc.\n \n use std::cell::RefCell;\n use std::cmp;\n+use std::rc::Rc;\n use std::vec_ng::Vec;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -140,7 +141,7 @@ pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n /// A source code location used for error reporting\n pub struct Loc {\n     /// Information about the original source\n-    file: @FileMap,\n+    file: Rc<FileMap>,\n     /// The (1-based) line number\n     line: uint,\n     /// The (0-based) column offset\n@@ -154,12 +155,12 @@ pub struct LocWithOpt {\n     filename: FileName,\n     line: uint,\n     col: CharPos,\n-    file: Option<@FileMap>,\n+    file: Option<Rc<FileMap>>,\n }\n \n // used to be structural records. Better names, anyone?\n-pub struct FileMapAndLine {fm: @FileMap, line: uint}\n-pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n+pub struct FileMapAndLine {fm: Rc<FileMap>, line: uint}\n+pub struct FileMapAndBytePos {fm: Rc<FileMap>, pos: BytePos}\n \n #[deriving(Clone, Hash, Show)]\n pub enum MacroFormat {\n@@ -186,10 +187,10 @@ pub struct ExpnInfo {\n \n pub type FileName = ~str;\n \n-pub struct FileLines\n-{\n-    file: @FileMap,\n-    lines: Vec<uint> }\n+pub struct FileLines {\n+    file: Rc<FileMap>,\n+    lines: Vec<uint>\n+}\n \n /// Identifies an offset of a multi-byte character in a FileMap\n pub struct MultiByteChar {\n@@ -251,8 +252,7 @@ impl FileMap {\n             pos: pos,\n             bytes: bytes,\n         };\n-        let mut multibyte_chars = self.multibyte_chars.borrow_mut();\n-        multibyte_chars.get().push(mbc);\n+        self.multibyte_chars.borrow_mut().get().push(mbc);\n     }\n \n     pub fn is_real_file(&self) -> bool {\n@@ -261,7 +261,7 @@ impl FileMap {\n }\n \n pub struct CodeMap {\n-    files: RefCell<Vec<@FileMap> >\n+    files: RefCell<Vec<Rc<FileMap>>>\n }\n \n impl CodeMap {\n@@ -271,11 +271,11 @@ impl CodeMap {\n         }\n     }\n \n-    pub fn new_filemap(&self, filename: FileName, mut src: ~str) -> @FileMap {\n+    pub fn new_filemap(&self, filename: FileName, mut src: ~str) -> Rc<FileMap> {\n         let mut files = self.files.borrow_mut();\n         let start_pos = match files.get().last() {\n             None => 0,\n-            Some(last) => last.start_pos.to_uint() + last.src.len(),\n+            Some(last) => last.deref().start_pos.to_uint() + last.deref().src.len(),\n         };\n \n         // Append '\\n' in case it's not already there.\n@@ -286,46 +286,42 @@ impl CodeMap {\n             src.push_char('\\n');\n         }\n \n-        let filemap = @FileMap {\n+        let filemap = Rc::new(FileMap {\n             name: filename,\n             src: src,\n             start_pos: Pos::from_uint(start_pos),\n             lines: RefCell::new(Vec::new()),\n             multibyte_chars: RefCell::new(Vec::new()),\n-        };\n+        });\n \n-        files.get().push(filemap);\n+        files.get().push(filemap.clone());\n \n-        return filemap;\n+        filemap\n     }\n \n     pub fn mk_substr_filename(&self, sp: Span) -> ~str {\n         let pos = self.lookup_char_pos(sp.lo);\n-        return format!(\"<{}:{}:{}>\", pos.file.name,\n-                       pos.line, pos.col.to_uint() + 1)\n+        format!(\"<{}:{}:{}>\", pos.file.deref().name, pos.line, pos.col.to_uint() + 1)\n     }\n \n     /// Lookup source information about a BytePos\n     pub fn lookup_char_pos(&self, pos: BytePos) -> Loc {\n-        return self.lookup_pos(pos);\n+        self.lookup_pos(pos)\n     }\n \n     pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt {\n         let loc = self.lookup_char_pos(pos);\n         LocWithOpt {\n-            filename: loc.file.name.to_str(),\n+            filename: loc.file.deref().name.to_str(),\n             line: loc.line,\n             col: loc.col,\n             file: Some(loc.file)\n         }\n     }\n \n     pub fn span_to_str(&self, sp: Span) -> ~str {\n-        {\n-            let files = self.files.borrow();\n-            if files.get().len() == 0 && sp == DUMMY_SP {\n-                return ~\"no-location\";\n-            }\n+        if self.files.borrow().get().len() == 0 && sp == DUMMY_SP {\n+            return ~\"no-location\";\n         }\n \n         let lo = self.lookup_char_pos_adj(sp.lo);\n@@ -335,18 +331,17 @@ impl CodeMap {\n     }\n \n     pub fn span_to_filename(&self, sp: Span) -> FileName {\n-        let lo = self.lookup_char_pos(sp.lo);\n-        lo.file.name.to_str()\n+        self.lookup_char_pos(sp.lo).file.deref().name.to_str()\n     }\n \n-    pub fn span_to_lines(&self, sp: Span) -> @FileLines {\n+    pub fn span_to_lines(&self, sp: Span) -> FileLines {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n         let mut lines = Vec::new();\n         for i in range(lo.line - 1u, hi.line as uint) {\n             lines.push(i);\n         };\n-        return @FileLines {file: lo.file, lines: lines};\n+        FileLines {file: lo.file, lines: lines}\n     }\n \n     pub fn span_to_snippet(&self, sp: Span) -> Option<~str> {\n@@ -357,27 +352,22 @@ impl CodeMap {\n         // it's testing isn't true for all spans in the AST, so to allow the\n         // caller to not have to fail (and it can't catch it since the CodeMap\n         // isn't sendable), return None\n-        if begin.fm.start_pos != end.fm.start_pos {\n+        if begin.fm.deref().start_pos != end.fm.deref().start_pos {\n             None\n         } else {\n-            Some(begin.fm.src.slice( begin.pos.to_uint(), end.pos.to_uint()).to_owned())\n+            Some(begin.fm.deref().src.slice( begin.pos.to_uint(), end.pos.to_uint()).to_owned())\n         }\n     }\n \n-    pub fn get_filemap(&self, filename: &str) -> @FileMap {\n-        let files = self.files.borrow();\n-        for fm in files.get().iter() {\n-            if filename == fm.name {\n-                return *fm\n+    pub fn get_filemap(&self, filename: &str) -> Rc<FileMap> {\n+        for fm in self.files.borrow().get().iter() {\n+            if filename == fm.deref().name {\n+                return fm.clone();\n             }\n         }\n-        //XXjdm the following triggers a mismatched type bug\n-        //      (or expected function, found _|_)\n-        fail!(); // (\"asking for \" + filename + \" which we don't know about\");\n+        fail!(\"asking for {} which we don't know about\", filename);\n     }\n-}\n \n-impl CodeMap {\n     fn lookup_filemap_idx(&self, pos: BytePos) -> uint {\n         let files = self.files.borrow();\n         let files = files.get();\n@@ -386,7 +376,7 @@ impl CodeMap {\n         let mut b = len;\n         while b - a > 1u {\n             let m = (a + b) / 2u;\n-            if files.get(m).start_pos > pos {\n+            if files.get(m).deref().start_pos > pos {\n                 b = m;\n             } else {\n                 a = m;\n@@ -396,7 +386,7 @@ impl CodeMap {\n         // filemap, but are not the filemaps we want (because they are length 0, they cannot\n         // contain what we are looking for). So, rewind until we find a useful filemap.\n         loop {\n-            let lines = files.get(a).lines.borrow();\n+            let lines = files.get(a).deref().lines.borrow();\n             let lines = lines.get();\n             if lines.len() > 0 {\n                 break;\n@@ -413,49 +403,47 @@ impl CodeMap {\n         return a;\n     }\n \n-    fn lookup_line(&self, pos: BytePos) -> FileMapAndLine\n-    {\n+    fn lookup_line(&self, pos: BytePos) -> FileMapAndLine {\n         let idx = self.lookup_filemap_idx(pos);\n \n         let files = self.files.borrow();\n-        let f = *files.get().get(idx);\n+        let f = files.get().get(idx).clone();\n         let mut a = 0u;\n-        let mut lines = f.lines.borrow_mut();\n-        let mut b = lines.get().len();\n-        while b - a > 1u {\n-            let m = (a + b) / 2u;\n-            if *lines.get().get(m) > pos { b = m; } else { a = m; }\n+        {\n+            let mut lines = f.deref().lines.borrow_mut();\n+            let mut b = lines.get().len();\n+            while b - a > 1u {\n+                let m = (a + b) / 2u;\n+                if *lines.get().get(m) > pos { b = m; } else { a = m; }\n+            }\n         }\n-        return FileMapAndLine {fm: f, line: a};\n+        FileMapAndLine {fm: f, line: a}\n     }\n \n     fn lookup_pos(&self, pos: BytePos) -> Loc {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n         let line = a + 1u; // Line numbers start at 1\n         let chpos = self.bytepos_to_file_charpos(pos);\n-        let lines = f.lines.borrow();\n-        let linebpos = *lines.get().get(a);\n+        let linebpos = *f.deref().lines.borrow().get().get(a);\n         let linechpos = self.bytepos_to_file_charpos(linebpos);\n         debug!(\"codemap: byte pos {:?} is on the line at byte pos {:?}\",\n                pos, linebpos);\n         debug!(\"codemap: char pos {:?} is on the line at char pos {:?}\",\n                chpos, linechpos);\n         debug!(\"codemap: byte is on line: {:?}\", line);\n         assert!(chpos >= linechpos);\n-        return Loc {\n+        Loc {\n             file: f,\n             line: line,\n             col: chpos - linechpos\n-        };\n+        }\n     }\n \n-    fn lookup_byte_offset(&self, bpos: BytePos)\n-        -> FileMapAndBytePos {\n+    fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n-        let files = self.files.borrow();\n-        let fm = *files.get().get(idx);\n-        let offset = bpos - fm.start_pos;\n-        return FileMapAndBytePos {fm: fm, pos: offset};\n+        let fm = self.files.borrow().get().get(idx).clone();\n+        let offset = bpos - fm.deref().start_pos;\n+        FileMapAndBytePos {fm: fm, pos: offset}\n     }\n \n     // Converts an absolute BytePos to a CharPos relative to the filemap.\n@@ -468,8 +456,7 @@ impl CodeMap {\n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n \n-        let multibyte_chars = map.multibyte_chars.borrow();\n-        for mbc in multibyte_chars.get().iter() {\n+        for mbc in map.deref().multibyte_chars.borrow().get().iter() {\n             debug!(\"codemap: {:?}-byte char at {:?}\", mbc.bytes, mbc.pos);\n             if mbc.pos < bpos {\n                 // every character is at least one byte, so we only\n@@ -483,8 +470,8 @@ impl CodeMap {\n             }\n         }\n \n-        assert!(map.start_pos.to_uint() + total_extra_bytes <= bpos.to_uint());\n-        CharPos(bpos.to_uint() - map.start_pos.to_uint() - total_extra_bytes)\n+        assert!(map.deref().start_pos.to_uint() + total_extra_bytes <= bpos.to_uint());\n+        CharPos(bpos.to_uint() - map.deref().start_pos.to_uint() - total_extra_bytes)\n     }\n }\n "}, {"sha": "c88c5a3c4e6f6bb908846052ae0aab97f25233f8", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -40,37 +40,37 @@ pub struct ExplicitBug;\n // accepts span information for source-location\n // reporting.\n pub struct SpanHandler {\n-    handler: @Handler,\n-    cm: @codemap::CodeMap,\n+    handler: Handler,\n+    cm: codemap::CodeMap,\n }\n \n impl SpanHandler {\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n-        self.handler.emit(Some((&*self.cm, sp)), msg, Fatal);\n+        self.handler.emit(Some((&self.cm, sp)), msg, Fatal);\n         fail!(FatalError);\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&*self.cm, sp)), msg, Error);\n+        self.handler.emit(Some((&self.cm, sp)), msg, Error);\n         self.handler.bump_err_count();\n     }\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&*self.cm, sp)), msg, Warning);\n+        self.handler.emit(Some((&self.cm, sp)), msg, Warning);\n     }\n     pub fn span_note(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&*self.cm, sp)), msg, Note);\n+        self.handler.emit(Some((&self.cm, sp)), msg, Note);\n     }\n     pub fn span_end_note(&self, sp: Span, msg: &str) {\n-        self.handler.custom_emit(&*self.cm, sp, msg, Note);\n+        self.handler.custom_emit(&self.cm, sp, msg, Note);\n     }\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n-        self.handler.emit(Some((&*self.cm, sp)), msg, Bug);\n+        self.handler.emit(Some((&self.cm, sp)), msg, Bug);\n         fail!(ExplicitBug);\n     }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp, ~\"unimplemented \" + msg);\n     }\n-    pub fn handler(&self) -> @Handler {\n-        self.handler\n+    pub fn handler<'a>(&'a self) -> &'a Handler {\n+        &self.handler\n     }\n }\n \n@@ -137,20 +137,19 @@ impl Handler {\n     }\n }\n \n-pub fn mk_span_handler(handler: @Handler, cm: @codemap::CodeMap)\n-                       -> @SpanHandler {\n-    @SpanHandler {\n+pub fn mk_span_handler(handler: Handler, cm: codemap::CodeMap) -> SpanHandler {\n+    SpanHandler {\n         handler: handler,\n         cm: cm,\n     }\n }\n \n-pub fn default_handler() -> @Handler {\n+pub fn default_handler() -> Handler {\n     mk_handler(~EmitterWriter::stderr())\n }\n \n-pub fn mk_handler(e: ~Emitter) -> @Handler {\n-    @Handler {\n+pub fn mk_handler(e: ~Emitter) -> Handler {\n+    Handler {\n         err_count: Cell::new(0),\n         emit: RefCell::new(e),\n     }\n@@ -301,8 +300,8 @@ fn highlight_lines(err: &mut EmitterWriter,\n                    cm: &codemap::CodeMap,\n                    sp: Span,\n                    lvl: Level,\n-                   lines: &codemap::FileLines) -> io::IoResult<()> {\n-    let fm = lines.file;\n+                   lines: codemap::FileLines) -> io::IoResult<()> {\n+    let fm = lines.file.deref();\n \n     let mut elided = false;\n     let mut display_lines = lines.lines.as_slice();\n@@ -374,8 +373,8 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n                           cm: &codemap::CodeMap,\n                           sp: Span,\n                           lvl: Level,\n-                          lines: &codemap::FileLines) -> io::IoResult<()> {\n-    let fm = lines.file;\n+                          lines: codemap::FileLines) -> io::IoResult<()> {\n+    let fm = lines.file.deref();\n \n     let lines = lines.lines.as_slice();\n     if lines.len() > MAX_LINES {\n@@ -420,8 +419,7 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n     Ok(())\n }\n \n-pub fn expect<T:Clone>(diag: @SpanHandler, opt: Option<T>, msg: || -> ~str)\n-              -> T {\n+pub fn expect<T:Clone>(diag: &SpanHandler, opt: Option<T>, msg: || -> ~str) -> T {\n     match opt {\n        Some(ref t) => (*t).clone(),\n        None => diag.handler().bug(msg()),"}, {"sha": "df2c265e6ebf3cd6a42a3efd879bf403e6a1446a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -326,7 +326,7 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn codemap(&self) -> @CodeMap { self.parse_sess.cm }\n+    pub fn codemap(&self) -> &'a CodeMap { &self.parse_sess.span_diagnostic.cm }\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n     pub fn call_site(&self) -> Span {"}, {"sha": "7c42476bc01bf3111748596d04642deca3e51c3d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -633,7 +633,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             vec!(\n                 self.expr_str(span, msg),\n                 self.expr_str(span,\n-                              token::intern_and_get_ident(loc.file.name)),\n+                              token::intern_and_get_ident(loc.file.deref().name)),\n                 self.expr_uint(span, loc.line)))\n     }\n "}, {"sha": "d8bf726da79819b25ed9856de96c09850aa3f89b", "filename": "src/libsyntax/ext/registrar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fext%2Fregistrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fext%2Fregistrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fregistrar.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -37,7 +37,7 @@ impl Visitor<()> for MacroRegistrarContext {\n     }\n }\n \n-pub fn find_macro_registrar(diagnostic: @diagnostic::SpanHandler,\n+pub fn find_macro_registrar(diagnostic: &diagnostic::SpanHandler,\n                             krate: &ast::Crate) -> Option<ast::DefId> {\n     let mut ctx = MacroRegistrarContext { registrars: Vec::new() };\n     visit::walk_crate(&mut ctx, krate, ());"}, {"sha": "137cd89bf30b7e450b8b016e2ecece8c06dbde08", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -57,7 +57,7 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let topmost = topmost_expn_info(cx.backtrace().unwrap());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    let filename = token::intern_and_get_ident(loc.file.name);\n+    let filename = token::intern_and_get_ident(loc.file.deref().name);\n     base::MRExpr(cx.expr_str(topmost.call_site, filename))\n }\n \n@@ -117,7 +117,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             // dependency information\n             let filename = file.display().to_str();\n             let interned = token::intern_and_get_ident(src);\n-            cx.parse_sess.cm.new_filemap(filename, src);\n+            cx.codemap().new_filemap(filename, src);\n \n             base::MRExpr(cx.expr_str(sp, interned))\n         }"}, {"sha": "fa49f06e516714c613bab55632d1b7f0e68bc037", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -22,7 +22,7 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt,\n                         -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n-    let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n+    let tt_rdr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n                                None,\n                                tt.iter().map(|x| (*x).clone()).collect());\n     let mut rust_parser = Parser(sess, cfg.clone(), tt_rdr.dup());"}, {"sha": "3f4ed0b1e8e02fcafe8fc6de468428343c9d8468", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -131,13 +131,11 @@ fn generic_extension(cx: &ExtCtxt,\n     let mut best_fail_spot = DUMMY_SP;\n     let mut best_fail_msg = ~\"internal error: ran no matchers\";\n \n-    let s_d = cx.parse_sess().span_diagnostic;\n-\n     for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n         match **lhs {\n           MatchedNonterminal(NtMatchers(ref mtcs)) => {\n             // `None` is because we're not interpolating\n-            let arg_rdr = new_tt_reader(s_d,\n+            let arg_rdr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n                                         None,\n                                         arg.iter()\n                                            .map(|x| (*x).clone())\n@@ -162,7 +160,8 @@ fn generic_extension(cx: &ExtCtxt,\n                     _ => cx.span_bug(sp, \"bad thing in rhs\")\n                 };\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let trncbr = new_tt_reader(s_d, Some(named_matches),\n+                let trncbr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n+                                           Some(named_matches),\n                                            rhs);\n                 let p = Parser(cx.parse_sess(), cx.cfg(), ~trncbr);\n                 // Let the context choose how to interpret the result.\n@@ -218,7 +217,7 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n \n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n-    let arg_reader = new_tt_reader(cx.parse_sess().span_diagnostic,\n+    let arg_reader = new_tt_reader(&cx.parse_sess().span_diagnostic,\n                                    None,\n                                    arg.clone());\n     let argument_map = parse_or_else(cx.parse_sess(),"}, {"sha": "e120f07742e7544367080b87ecbe2ada86c99727", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -30,8 +30,8 @@ struct TtFrame {\n     up: Option<@TtFrame>,\n }\n \n-pub struct TtReader {\n-    sp_diag: @SpanHandler,\n+pub struct TtReader<'a> {\n+    sp_diag: &'a SpanHandler,\n     // the unzipped tree:\n     priv stack: RefCell<@TtFrame>,\n     /* for MBE-style macro transcription */\n@@ -46,10 +46,10 @@ pub struct TtReader {\n /** This can do Macro-By-Example transcription. On the other hand, if\n  *  `src` contains no `TTSeq`s and `TTNonterminal`s, `interp` can (and\n  *  should) be none. */\n-pub fn new_tt_reader(sp_diag: @SpanHandler,\n-                     interp: Option<HashMap<Ident, @NamedMatch>>,\n-                     src: Vec<ast::TokenTree> )\n-                     -> TtReader {\n+pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n+                         interp: Option<HashMap<Ident, @NamedMatch>>,\n+                         src: Vec<ast::TokenTree> )\n+                         -> TtReader<'a> {\n     let r = TtReader {\n         sp_diag: sp_diag,\n         stack: RefCell::new(@TtFrame {\n@@ -70,7 +70,7 @@ pub fn new_tt_reader(sp_diag: @SpanHandler,\n         cur_span: RefCell::new(DUMMY_SP),\n     };\n     tt_next_token(&r); /* get cur_tok and cur_span set up */\n-    return r;\n+    r\n }\n \n fn dup_tt_frame(f: @TtFrame) -> @TtFrame {\n@@ -86,7 +86,7 @@ fn dup_tt_frame(f: @TtFrame) -> @TtFrame {\n     }\n }\n \n-pub fn dup_tt_reader(r: &TtReader) -> TtReader {\n+pub fn dup_tt_reader<'a>(r: &TtReader<'a>) -> TtReader<'a> {\n     TtReader {\n         sp_diag: r.sp_diag,\n         stack: RefCell::new(dup_tt_frame(r.stack.get())),"}, {"sha": "ed74fd416d14e75cdb0b86f41328f44c2ed7f433", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -346,10 +346,10 @@ pub struct Literal {\n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n pub fn gather_comments_and_literals(span_diagnostic:\n-                                        @diagnostic::SpanHandler,\n+                                        &diagnostic::SpanHandler,\n                                     path: ~str,\n                                     srdr: &mut io::Reader)\n-                                 -> (Vec<Comment> , Vec<Literal> ) {\n+                                 -> (Vec<Comment>, Vec<Literal>) {\n     let src = srdr.read_to_end().unwrap();\n     let src = str::from_utf8_owned(src).unwrap();\n     let cm = CodeMap::new();"}, {"sha": "43e1f8756fae98a385df6612e47060b286b50acd", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -18,6 +18,7 @@ use parse::token::{str_to_ident};\n \n use std::cell::{Cell, RefCell};\n use std::char;\n+use std::rc::Rc;\n use std::mem::replace;\n use std::num::from_str_radix;\n \n@@ -27,7 +28,7 @@ pub trait Reader {\n     fn is_eof(&self) -> bool;\n     fn next_token(&self) -> TokenAndSpan;\n     fn fatal(&self, ~str) -> !;\n-    fn span_diag(&self) -> @SpanHandler;\n+    fn span_diag<'a>(&'a self) -> &'a SpanHandler;\n     fn peek(&self) -> TokenAndSpan;\n     fn dup(&self) -> ~Reader:;\n }\n@@ -38,8 +39,8 @@ pub struct TokenAndSpan {\n     sp: Span,\n }\n \n-pub struct StringReader {\n-    span_diagnostic: @SpanHandler,\n+pub struct StringReader<'a> {\n+    span_diagnostic: &'a SpanHandler,\n     // The absolute offset within the codemap of the next character to read\n     pos: Cell<BytePos>,\n     // The absolute offset within the codemap of the last character read(curr)\n@@ -48,36 +49,36 @@ pub struct StringReader {\n     col: Cell<CharPos>,\n     // The last character to be read\n     curr: Cell<Option<char>>,\n-    filemap: @codemap::FileMap,\n+    filemap: Rc<codemap::FileMap>,\n     /* cached: */\n     peek_tok: RefCell<token::Token>,\n     peek_span: RefCell<Span>,\n }\n \n-impl StringReader {\n+impl<'a> StringReader<'a> {\n     pub fn curr_is(&self, c: char) -> bool {\n         self.curr.get() == Some(c)\n     }\n }\n \n-pub fn new_string_reader(span_diagnostic: @SpanHandler,\n-                         filemap: @codemap::FileMap)\n-                      -> StringReader {\n+pub fn new_string_reader<'a>(span_diagnostic: &'a SpanHandler,\n+                             filemap: Rc<codemap::FileMap>)\n+                             -> StringReader<'a> {\n     let r = new_low_level_string_reader(span_diagnostic, filemap);\n     string_advance_token(&r); /* fill in peek_* */\n     r\n }\n \n /* For comments.rs, which hackily pokes into 'pos' and 'curr' */\n-pub fn new_low_level_string_reader(span_diagnostic: @SpanHandler,\n-                                   filemap: @codemap::FileMap)\n-                                -> StringReader {\n+pub fn new_low_level_string_reader<'a>(span_diagnostic: &'a SpanHandler,\n+                                       filemap: Rc<codemap::FileMap>)\n+                                       -> StringReader<'a> {\n     // Force the initial reader bump to start on a fresh line\n     let initial_char = '\\n';\n     let r = StringReader {\n         span_diagnostic: span_diagnostic,\n-        pos: Cell::new(filemap.start_pos),\n-        last_pos: Cell::new(filemap.start_pos),\n+        pos: Cell::new(filemap.deref().start_pos),\n+        last_pos: Cell::new(filemap.deref().start_pos),\n         col: Cell::new(CharPos(0)),\n         curr: Cell::new(Some(initial_char)),\n         filemap: filemap,\n@@ -92,20 +93,20 @@ pub fn new_low_level_string_reader(span_diagnostic: @SpanHandler,\n // duplicating the string reader is probably a bad idea, in\n // that using them will cause interleaved pushes of line\n // offsets to the underlying filemap...\n-fn dup_string_reader(r: &StringReader) -> StringReader {\n+fn dup_string_reader<'a>(r: &StringReader<'a>) -> StringReader<'a> {\n     StringReader {\n         span_diagnostic: r.span_diagnostic,\n         pos: Cell::new(r.pos.get()),\n         last_pos: Cell::new(r.last_pos.get()),\n         col: Cell::new(r.col.get()),\n         curr: Cell::new(r.curr.get()),\n-        filemap: r.filemap,\n+        filemap: r.filemap.clone(),\n         peek_tok: r.peek_tok.clone(),\n         peek_span: r.peek_span.clone(),\n     }\n }\n \n-impl Reader for StringReader {\n+impl<'a> Reader for StringReader<'a> {\n     fn is_eof(&self) -> bool { is_eof(self) }\n     // return the next token. EFFECT: advances the string_reader.\n     fn next_token(&self) -> TokenAndSpan {\n@@ -122,7 +123,7 @@ impl Reader for StringReader {\n     fn fatal(&self, m: ~str) -> ! {\n         self.span_diagnostic.span_fatal(self.peek_span.get(), m)\n     }\n-    fn span_diag(&self) -> @SpanHandler { self.span_diagnostic }\n+    fn span_diag<'a>(&'a self) -> &'a SpanHandler { self.span_diagnostic }\n     fn peek(&self) -> TokenAndSpan {\n         // FIXME(pcwalton): Bad copy!\n         TokenAndSpan {\n@@ -133,7 +134,7 @@ impl Reader for StringReader {\n     fn dup(&self) -> ~Reader: { ~dup_string_reader(self) as ~Reader: }\n }\n \n-impl Reader for TtReader {\n+impl<'a> Reader for TtReader<'a> {\n     fn is_eof(&self) -> bool {\n         let cur_tok = self.cur_tok.borrow();\n         *cur_tok.get() == token::EOF\n@@ -146,7 +147,7 @@ impl Reader for TtReader {\n     fn fatal(&self, m: ~str) -> ! {\n         self.sp_diag.span_fatal(self.cur_span.get(), m);\n     }\n-    fn span_diag(&self) -> @SpanHandler { self.sp_diag }\n+    fn span_diag<'a>(&'a self) -> &'a SpanHandler { self.sp_diag }\n     fn peek(&self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: self.cur_tok.get(),\n@@ -189,7 +190,7 @@ fn fatal_span_verbose(rdr: &StringReader,\n                    -> ! {\n     let mut m = m;\n     m.push_str(\": \");\n-    let s = rdr.filemap.src.slice(\n+    let s = rdr.filemap.deref().src.slice(\n                   byte_offset(rdr, from_pos).to_uint(),\n                   byte_offset(rdr, to_pos).to_uint());\n     m.push_str(s);\n@@ -218,7 +219,7 @@ fn string_advance_token(r: &StringReader) {\n }\n \n fn byte_offset(rdr: &StringReader, pos: BytePos) -> BytePos {\n-    (pos - rdr.filemap.start_pos)\n+    (pos - rdr.filemap.deref().start_pos)\n }\n \n /// Calls `f` with a string slice of the source text spanning from `start`\n@@ -240,7 +241,7 @@ fn with_str_from_to<T>(\n                     end: BytePos,\n                     f: |s: &str| -> T)\n                     -> T {\n-    f(rdr.filemap.src.slice(\n+    f(rdr.filemap.deref().src.slice(\n             byte_offset(rdr, start).to_uint(),\n             byte_offset(rdr, end).to_uint()))\n }\n@@ -250,21 +251,21 @@ fn with_str_from_to<T>(\n pub fn bump(rdr: &StringReader) {\n     rdr.last_pos.set(rdr.pos.get());\n     let current_byte_offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n-    if current_byte_offset < (rdr.filemap.src).len() {\n+    if current_byte_offset < rdr.filemap.deref().src.len() {\n         assert!(rdr.curr.get().is_some());\n         let last_char = rdr.curr.get().unwrap();\n-        let next = rdr.filemap.src.char_range_at(current_byte_offset);\n+        let next = rdr.filemap.deref().src.char_range_at(current_byte_offset);\n         let byte_offset_diff = next.next - current_byte_offset;\n         rdr.pos.set(rdr.pos.get() + Pos::from_uint(byte_offset_diff));\n         rdr.curr.set(Some(next.ch));\n         rdr.col.set(rdr.col.get() + CharPos(1u));\n         if last_char == '\\n' {\n-            rdr.filemap.next_line(rdr.last_pos.get());\n+            rdr.filemap.deref().next_line(rdr.last_pos.get());\n             rdr.col.set(CharPos(0u));\n         }\n \n         if byte_offset_diff > 1 {\n-            rdr.filemap.record_multibyte_char(rdr.last_pos.get(), byte_offset_diff);\n+            rdr.filemap.deref().record_multibyte_char(rdr.last_pos.get(), byte_offset_diff);\n         }\n     } else {\n         rdr.curr.set(None);\n@@ -275,8 +276,8 @@ pub fn is_eof(rdr: &StringReader) -> bool {\n }\n pub fn nextch(rdr: &StringReader) -> Option<char> {\n     let offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n-    if offset < (rdr.filemap.src).len() {\n-        Some(rdr.filemap.src.char_at(offset))\n+    if offset < rdr.filemap.deref().src.len() {\n+        Some(rdr.filemap.deref().src.char_at(offset))\n     } else {\n         None\n     }\n@@ -334,56 +335,55 @@ fn consume_any_line_comment(rdr: &StringReader)\n                          -> Option<TokenAndSpan> {\n     if rdr.curr_is('/') {\n         match nextch(rdr) {\n-          Some('/') => {\n-            bump(rdr);\n-            bump(rdr);\n-            // line comments starting with \"///\" or \"//!\" are doc-comments\n-            if rdr.curr_is('/') || rdr.curr_is('!') {\n-                let start_bpos = rdr.pos.get() - BytePos(3);\n-                while !rdr.curr_is('\\n') && !is_eof(rdr) {\n-                    bump(rdr);\n-                }\n-                let ret = with_str_from(rdr, start_bpos, |string| {\n-                    // but comments with only more \"/\"s are not\n-                    if !is_line_non_doc_comment(string) {\n-                        Some(TokenAndSpan{\n-                            tok: token::DOC_COMMENT(str_to_ident(string)),\n-                            sp: codemap::mk_sp(start_bpos, rdr.pos.get())\n-                        })\n-                    } else {\n-                        None\n+            Some('/') => {\n+                bump(rdr);\n+                bump(rdr);\n+                // line comments starting with \"///\" or \"//!\" are doc-comments\n+                if rdr.curr_is('/') || rdr.curr_is('!') {\n+                    let start_bpos = rdr.pos.get() - BytePos(3);\n+                    while !rdr.curr_is('\\n') && !is_eof(rdr) {\n+                        bump(rdr);\n                     }\n-                });\n+                    let ret = with_str_from(rdr, start_bpos, |string| {\n+                        // but comments with only more \"/\"s are not\n+                        if !is_line_non_doc_comment(string) {\n+                            Some(TokenAndSpan{\n+                                tok: token::DOC_COMMENT(str_to_ident(string)),\n+                                sp: codemap::mk_sp(start_bpos, rdr.pos.get())\n+                            })\n+                        } else {\n+                            None\n+                        }\n+                    });\n \n-                if ret.is_some() {\n-                    return ret;\n+                    if ret.is_some() {\n+                        return ret;\n+                    }\n+                } else {\n+                    while !rdr.curr_is('\\n') && !is_eof(rdr) { bump(rdr); }\n                 }\n-            } else {\n-                while !rdr.curr_is('\\n') && !is_eof(rdr) { bump(rdr); }\n+                // Restart whitespace munch.\n+                consume_whitespace_and_comments(rdr)\n             }\n-            // Restart whitespace munch.\n-            return consume_whitespace_and_comments(rdr);\n-          }\n-          Some('*') => { bump(rdr); bump(rdr); return consume_block_comment(rdr); }\n-          _ => ()\n+            Some('*') => { bump(rdr); bump(rdr); consume_block_comment(rdr) }\n+            _ => None\n         }\n     } else if rdr.curr_is('#') {\n         if nextch_is(rdr, '!') {\n             // I guess this is the only way to figure out if\n             // we're at the beginning of the file...\n-            let cmap = @CodeMap::new();\n-            {\n-                let mut files = cmap.files.borrow_mut();\n-                files.get().push(rdr.filemap);\n-            }\n+            let cmap = CodeMap::new();\n+            cmap.files.borrow_mut().get().push(rdr.filemap.clone());\n             let loc = cmap.lookup_char_pos_adj(rdr.last_pos.get());\n             if loc.line == 1u && loc.col == CharPos(0u) {\n                 while !rdr.curr_is('\\n') && !is_eof(rdr) { bump(rdr); }\n                 return consume_whitespace_and_comments(rdr);\n             }\n         }\n+        None\n+    } else {\n+        None\n     }\n-    return None;\n }\n \n pub fn is_block_non_doc_comment(s: &str) -> bool {\n@@ -1019,7 +1019,7 @@ mod test {\n         let writer = ~util::NullWriter;\n         let emitter = diagnostic::EmitterWriter::new(writer);\n         let handler = diagnostic::mk_handler(~emitter);\n-        let span_handler = diagnostic::mk_span_handler(handler, @cm);\n+        let span_handler = diagnostic::mk_span_handler(handler, cm);\n         Env {\n             string_reader: new_string_reader(span_handler,fm)\n         }"}, {"sha": "79fedf827986ca1f4e558ee7461cf56c5baa4206", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 28, "deletions": 38, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -13,13 +13,13 @@\n \n use ast;\n use codemap::{Span, CodeMap, FileMap};\n-use codemap;\n use diagnostic::{SpanHandler, mk_span_handler, default_handler};\n use parse::attr::ParserAttr;\n use parse::parser::Parser;\n \n use std::cell::RefCell;\n use std::io::File;\n+use std::rc::Rc;\n use std::str;\n use std::vec_ng::Vec;\n \n@@ -40,26 +40,20 @@ pub mod obsolete;\n \n // info about a parsing session.\n pub struct ParseSess {\n-    cm: @codemap::CodeMap, // better be the same as the one in the reader!\n-    span_diagnostic: @SpanHandler, // better be the same as the one in the reader!\n+    span_diagnostic: SpanHandler, // better be the same as the one in the reader!\n     /// Used to determine and report recursive mod inclusions\n-    included_mod_stack: RefCell<Vec<Path> >,\n+    included_mod_stack: RefCell<Vec<Path>>,\n }\n \n pub fn new_parse_sess() -> ParseSess {\n-    let cm = @CodeMap::new();\n     ParseSess {\n-        cm: cm,\n-        span_diagnostic: mk_span_handler(default_handler(), cm),\n+        span_diagnostic: mk_span_handler(default_handler(), CodeMap::new()),\n         included_mod_stack: RefCell::new(Vec::new()),\n     }\n }\n \n-pub fn new_parse_sess_special_handler(sh: @SpanHandler,\n-                                      cm: @codemap::CodeMap)\n-                                      -> ParseSess {\n+pub fn new_parse_sess_special_handler(sh: SpanHandler) -> ParseSess {\n     ParseSess {\n-        cm: cm,\n         span_diagnostic: sh,\n         included_mod_stack: RefCell::new(Vec::new()),\n     }\n@@ -175,48 +169,44 @@ pub fn parse_tts_from_source_str(name: ~str,\n \n // Create a new parser from a source string\n pub fn new_parser_from_source_str<'a>(sess: &'a ParseSess,\n-                                     cfg: ast::CrateConfig,\n-                                     name: ~str,\n-                                     source: ~str)\n-                                     -> Parser<'a> {\n-    filemap_to_parser(sess,string_to_filemap(sess,source,name),cfg)\n+                                      cfg: ast::CrateConfig,\n+                                      name: ~str,\n+                                      source: ~str)\n+                                      -> Parser<'a> {\n+    filemap_to_parser(sess, string_to_filemap(sess, source, name), cfg)\n }\n \n /// Create a new parser, handling errors as appropriate\n /// if the file doesn't exist\n-pub fn new_parser_from_file<'a>(\n-    sess: &'a ParseSess,\n-    cfg: ast::CrateConfig,\n-    path: &Path\n-) -> Parser<'a> {\n-    filemap_to_parser(sess,file_to_filemap(sess,path,None),cfg)\n+pub fn new_parser_from_file<'a>(sess: &'a ParseSess,\n+                                cfg: ast::CrateConfig,\n+                                path: &Path) -> Parser<'a> {\n+    filemap_to_parser(sess, file_to_filemap(sess, path, None), cfg)\n }\n \n /// Given a session, a crate config, a path, and a span, add\n /// the file at the given path to the codemap, and return a parser.\n /// On an error, use the given span as the source of the problem.\n-pub fn new_sub_parser_from_file<'a>(\n-    sess: &'a ParseSess,\n-    cfg: ast::CrateConfig,\n-    path: &Path,\n-    sp: Span\n-) -> Parser<'a> {\n-    filemap_to_parser(sess,file_to_filemap(sess,path,Some(sp)),cfg)\n+pub fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n+                                    cfg: ast::CrateConfig,\n+                                    path: &Path,\n+                                    sp: Span) -> Parser<'a> {\n+    filemap_to_parser(sess, file_to_filemap(sess, path, Some(sp)), cfg)\n }\n \n /// Given a filemap and config, return a parser\n pub fn filemap_to_parser<'a>(sess: &'a ParseSess,\n-                             filemap: @FileMap,\n+                             filemap: Rc<FileMap>,\n                              cfg: ast::CrateConfig) -> Parser<'a> {\n-    tts_to_parser(sess,filemap_to_tts(sess,filemap),cfg)\n+    tts_to_parser(sess, filemap_to_tts(sess, filemap), cfg)\n }\n \n // must preserve old name for now, because quote! from the *existing*\n // compiler expands into it\n pub fn new_parser_from_tts<'a>(sess: &'a ParseSess,\n                                cfg: ast::CrateConfig,\n                                tts: Vec<ast::TokenTree>) -> Parser<'a> {\n-    tts_to_parser(sess,tts,cfg)\n+    tts_to_parser(sess, tts, cfg)\n }\n \n \n@@ -225,7 +215,7 @@ pub fn new_parser_from_tts<'a>(sess: &'a ParseSess,\n /// Given a session and a path and an optional span (for error reporting),\n /// add the path to the session's codemap and return the new filemap.\n pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n-    -> @FileMap {\n+    -> Rc<FileMap> {\n     let err = |msg: &str| {\n         match spanopt {\n             Some(sp) => sess.span_diagnostic.span_fatal(sp, msg),\n@@ -251,17 +241,17 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n // given a session and a string, add the string to\n // the session's codemap and return the new filemap\n pub fn string_to_filemap(sess: &ParseSess, source: ~str, path: ~str)\n-                         -> @FileMap {\n-    sess.cm.new_filemap(path, source)\n+                         -> Rc<FileMap> {\n+    sess.span_diagnostic.cm.new_filemap(path, source)\n }\n \n // given a filemap, produce a sequence of token-trees\n-pub fn filemap_to_tts(sess: &ParseSess, filemap: @FileMap)\n+pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n     -> Vec<ast::TokenTree> {\n     // it appears to me that the cfg doesn't matter here... indeed,\n     // parsing tt's probably shouldn't require a parser at all.\n     let cfg = Vec::new();\n-    let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap);\n+    let srdr = lexer::new_string_reader(&sess.span_diagnostic, filemap);\n     let mut p1 = Parser(sess, cfg, ~srdr);\n     p1.parse_all_token_trees()\n }\n@@ -270,7 +260,7 @@ pub fn filemap_to_tts(sess: &ParseSess, filemap: @FileMap)\n pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n                          tts: Vec<ast::TokenTree>,\n                          cfg: ast::CrateConfig) -> Parser<'a> {\n-    let trdr = lexer::new_tt_reader(sess.span_diagnostic, None, tts);\n+    let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, tts);\n     Parser(sess, cfg, ~trdr)\n }\n "}, {"sha": "27c86956499ce860498adaaba35d8529a65fc6db", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871e5708106c5ee3ad8d2bd6ec68fca60428b77e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=871e5708106c5ee3ad8d2bd6ec68fca60428b77e", "patch": "@@ -4150,7 +4150,7 @@ impl<'a> Parser<'a> {\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n                     -> (ast::Item_, Vec<ast::Attribute> ) {\n-        let mut prefix = Path::new(self.sess.cm.span_to_filename(self.span));\n+        let mut prefix = Path::new(self.sess.span_diagnostic.cm.span_to_filename(self.span));\n         prefix.pop();\n         let mod_path = Path::new(\".\").join_many(self.mod_path_stack.as_slice());\n         let dir_path = prefix.join(&mod_path);"}]}