{"sha": "3c60328df8d5ac952d41b5ad1d898d339c82c265", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNjAzMjhkZjhkNWFjOTUyZDQxYjVhZDFkODk4ZDMzOWM4MmMyNjU=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-11-03T08:39:21Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-11-03T08:39:21Z"}, "message": "Merge pull request #558 from johannhof/master\n\nStdin support", "tree": {"sha": "c0582529fa12926570e6f59e155faa0bc14f987e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0582529fa12926570e6f59e155faa0bc14f987e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c60328df8d5ac952d41b5ad1d898d339c82c265", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c60328df8d5ac952d41b5ad1d898d339c82c265", "html_url": "https://github.com/rust-lang/rust/commit/3c60328df8d5ac952d41b5ad1d898d339c82c265", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c60328df8d5ac952d41b5ad1d898d339c82c265/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd0fdbb364ba69c69b867f96bc1ea9b59177fb76", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd0fdbb364ba69c69b867f96bc1ea9b59177fb76", "html_url": "https://github.com/rust-lang/rust/commit/bd0fdbb364ba69c69b867f96bc1ea9b59177fb76"}, {"sha": "154e20a04f7b3261c2d94e18f9abd39a056f6bef", "url": "https://api.github.com/repos/rust-lang/rust/commits/154e20a04f7b3261c2d94e18f9abd39a056f6bef", "html_url": "https://github.com/rust-lang/rust/commit/154e20a04f7b3261c2d94e18f9abd39a056f6bef"}], "stats": {"total": 96, "additions": 83, "deletions": 13}, "files": [{"sha": "b8eacc2bcd01899434c3a21dfebf80e82b9fc545", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3c60328df8d5ac952d41b5ad1d898d339c82c265/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60328df8d5ac952d41b5ad1d898d339c82c265/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=3c60328df8d5ac952d41b5ad1d898d339c82c265", "patch": "@@ -17,7 +17,7 @@ extern crate toml;\n extern crate env_logger;\n extern crate getopts;\n \n-use rustfmt::{WriteMode, run};\n+use rustfmt::{WriteMode, run, run_from_stdin};\n use rustfmt::config::Config;\n \n use std::env;\n@@ -35,6 +35,8 @@ enum Operation {\n     Help,\n     /// Invalid program input, including reason.\n     InvalidInput(String),\n+    /// No file specified, read from stdin\n+    Stdin(String, WriteMode),\n }\n \n /// Try to find a project file in the input file directory and its parents.\n@@ -75,7 +77,7 @@ fn execute() -> i32 {\n     opts.optflag(\"h\", \"help\", \"show this message\");\n     opts.optopt(\"\",\n                 \"write-mode\",\n-                \"mode to write in\",\n+                \"mode to write in (not usable when piping from stdin)\",\n                 \"[replace|overwrite|display|diff|coverage]\");\n \n     let operation = determine_operation(&opts, env::args().skip(1));\n@@ -89,6 +91,18 @@ fn execute() -> i32 {\n             print_usage(&opts, \"\");\n             0\n         }\n+        Operation::Stdin(input, write_mode) => {\n+            // try to read config from local directory\n+            let config = match lookup_and_read_project_file(&Path::new(\".\")) {\n+                Ok((path, toml)) => {\n+                    Config::from_toml(&toml)\n+                }\n+                Err(_) => Default::default(),\n+            };\n+\n+            run_from_stdin(input, write_mode, &config);\n+            0\n+        }\n         Operation::Format(file, write_mode) => {\n             let config = match lookup_and_read_project_file(&file) {\n                 Ok((path, toml)) => {\n@@ -138,6 +152,19 @@ fn determine_operation<I>(opts: &Options, args: I) -> Operation\n         return Operation::Help;\n     }\n \n+    // if no file argument is supplied, read from stdin\n+    if matches.free.len() == 0 {\n+\n+        let mut buffer = String::new();\n+        match io::stdin().read_to_string(&mut buffer) {\n+            Ok(..) => (),\n+            Err(e) => return Operation::InvalidInput(e.to_string()),\n+        }\n+\n+        // WriteMode is always plain for Stdin\n+        return Operation::Stdin(buffer, WriteMode::Plain);\n+    }\n+\n     let write_mode = match matches.opt_str(\"write-mode\") {\n         Some(mode) => {\n             match mode.parse() {\n@@ -148,9 +175,5 @@ fn determine_operation<I>(opts: &Options, args: I) -> Operation\n         None => WriteMode::Replace,\n     };\n \n-    if matches.free.len() != 1 {\n-        return Operation::InvalidInput(\"Please provide one file to format\".into());\n-    }\n-\n     Operation::Format(PathBuf::from(&matches.free[0]), write_mode)\n }"}, {"sha": "3f1a867f38594700cfd722de548237595a2c4c4e", "filename": "src/filemap.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3c60328df8d5ac952d41b5ad1d898d339c82c265/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60328df8d5ac952d41b5ad1d898d339c82c265/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=3c60328df8d5ac952d41b5ad1d898d339c82c265", "patch": "@@ -46,11 +46,11 @@ pub fn write_all_files(file_map: &FileMap,\n     Ok(result)\n }\n \n-fn write_file(text: &StringBuffer,\n-              filename: &str,\n-              mode: WriteMode,\n-              config: &Config)\n-              -> Result<Option<String>, io::Error> {\n+pub fn write_file(text: &StringBuffer,\n+                  filename: &str,\n+                  mode: WriteMode,\n+                  config: &Config)\n+                  -> Result<Option<String>, io::Error> {\n \n     // prints all newlines either as `\\n` or as `\\r\\n`\n     fn write_system_newlines<T>(mut writer: T,\n@@ -100,11 +100,16 @@ fn write_file(text: &StringBuffer,\n             let file = try!(File::create(&filename));\n             try!(write_system_newlines(file, text, config));\n         }\n+        WriteMode::Plain => {\n+            let stdout = stdout();\n+            let stdout = stdout.lock();\n+            try!(write_system_newlines(stdout, text, config));\n+        }\n         WriteMode::Display | WriteMode::Coverage => {\n             println!(\"{}:\\n\", filename);\n             let stdout = stdout();\n-            let stdout_lock = stdout.lock();\n-            try!(write_system_newlines(stdout_lock, text, config));\n+            let stdout = stdout.lock();\n+            try!(write_system_newlines(stdout, text, config));\n         }\n         WriteMode::Diff => {\n             println!(\"Diff of {}:\\n\", filename);"}, {"sha": "4c7b3cbd24984a49462dd59caab59bc425407ed2", "filename": "src/lib.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3c60328df8d5ac952d41b5ad1d898d339c82c265/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60328df8d5ac952d41b5ad1d898d339c82c265/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=3c60328df8d5ac952d41b5ad1d898d339c82c265", "patch": "@@ -193,6 +193,8 @@ pub enum WriteMode {\n     Return,\n     // Display how much of the input file was processed\n     Coverage,\n+    // Unfancy stdout\n+    Plain,\n }\n \n impl FromStr for WriteMode {\n@@ -205,6 +207,7 @@ impl FromStr for WriteMode {\n             \"overwrite\" => Ok(WriteMode::Overwrite),\n             \"diff\" => Ok(WriteMode::Diff),\n             \"coverage\" => Ok(WriteMode::Coverage),\n+            \"plain\" => Ok(WriteMode::Plain),\n             _ => Err(()),\n         }\n     }\n@@ -386,6 +389,33 @@ pub fn fmt_lines(file_map: &mut FileMap, config: &Config) -> FormatReport {\n     report\n }\n \n+pub fn format_string(input: String, config: &Config, mode: WriteMode) -> FileMap {\n+    let path = \"stdin\";\n+    let mut parse_session = ParseSess::new();\n+    let krate = parse::parse_crate_from_source_str(path.to_owned(),\n+                                                   input,\n+                                                   Vec::new(),\n+                                                   &parse_session);\n+\n+    // Suppress error output after parsing.\n+    let emitter = Box::new(EmitterWriter::new(Box::new(Vec::new()), None));\n+    parse_session.span_diagnostic.handler = Handler::with_emitter(false, emitter);\n+\n+    // FIXME: we still use a FileMap even though we only have\n+    // one file, because fmt_lines requires a FileMap\n+    let mut file_map = FileMap::new();\n+\n+    // do the actual formatting\n+    let mut visitor = FmtVisitor::from_codemap(&parse_session, config, Some(mode));\n+    visitor.format_separate_mod(&krate.module, path);\n+\n+    // append final newline\n+    visitor.buffer.push_str(\"\\n\");\n+    file_map.insert(path.to_owned(), visitor.buffer);\n+\n+    return file_map;\n+}\n+\n pub fn format(file: &Path, config: &Config, mode: WriteMode) -> FileMap {\n     let mut parse_session = ParseSess::new();\n     let krate = parse::parse_crate_from_file(file, Vec::new(), &parse_session);\n@@ -418,3 +448,15 @@ pub fn run(file: &Path, write_mode: WriteMode, config: &Config) {\n         println!(\"Error writing files: {}\", msg);\n     }\n }\n+\n+// Similar to run, but takes an input String instead of a file to format\n+pub fn run_from_stdin(input: String, mode: WriteMode, config: &Config) {\n+    let mut result = format_string(input, config, mode);\n+    fmt_lines(&mut result, config);\n+\n+    let write_result = filemap::write_file(&result[\"stdin\"], \"stdin\", mode, config);\n+\n+    if let Err(msg) = write_result {\n+        panic!(\"Error writing to stdout: {}\", msg);\n+    }\n+}"}]}