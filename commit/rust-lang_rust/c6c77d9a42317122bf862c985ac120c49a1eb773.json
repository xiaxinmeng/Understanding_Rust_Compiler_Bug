{"sha": "c6c77d9a42317122bf862c985ac120c49a1eb773", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2Yzc3ZDlhNDIzMTcxMjJiZjg2MmM5ODVhYzEyMGM0OWExZWI3NzM=", "commit": {"author": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-03-18T22:13:06Z"}, "committer": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-04-20T10:30:00Z"}, "message": "use Visitor api to find Mutex::lock calls", "tree": {"sha": "f07a3ce5a4433ca48886385bd0ece72ae24bb9b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f07a3ce5a4433ca48886385bd0ece72ae24bb9b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6c77d9a42317122bf862c985ac120c49a1eb773", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6c77d9a42317122bf862c985ac120c49a1eb773", "html_url": "https://github.com/rust-lang/rust/commit/c6c77d9a42317122bf862c985ac120c49a1eb773", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6c77d9a42317122bf862c985ac120c49a1eb773/comments", "author": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fca3537fa3e88d80936222177b96ae0b918c022e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fca3537fa3e88d80936222177b96ae0b918c022e", "html_url": "https://github.com/rust-lang/rust/commit/fca3537fa3e88d80936222177b96ae0b918c022e"}], "stats": {"total": 176, "additions": 96, "deletions": 80}, "files": [{"sha": "5f83d952fe3a5d42682c64056a255e3327e55acf", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 94, "deletions": 78, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/c6c77d9a42317122bf862c985ac120c49a1eb773/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c77d9a42317122bf862c985ac120c49a1eb773/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=c6c77d9a42317122bf862c985ac120c49a1eb773", "patch": "@@ -1,6 +1,7 @@\n use crate::utils::{match_type, paths, span_lint_and_help};\n-use if_chain::if_chain;\n-use rustc_hir::{Arm, Expr, ExprKind, MatchSource, Stmt, StmtKind};\n+use rustc::hir::map::Map;\n+use rustc_hir::intravisit::{self as visit, NestedVisitorMap, Visitor};\n+use rustc_hir::{Arm, Expr, ExprKind, MatchSource, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -40,100 +41,115 @@ declare_lint_pass!(IfLetMutex => [IF_LET_MUTEX]);\n \n impl LateLintPass<'_, '_> for IfLetMutex {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, ex: &'_ Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Match(ref op, ref arms, MatchSource::IfLetDesugar {\n+        let mut arm_visit = ArmVisitor {\n+            arm_mutex: false,\n+            arm_lock: false,\n+            cx,\n+        };\n+        let mut op_visit = IfLetMutexVisitor {\n+            op_mutex: false,\n+            op_lock: false,\n+            cx,\n+        };\n+        if let ExprKind::Match(\n+            ref op,\n+            ref arms,\n+            MatchSource::IfLetDesugar {\n                 contains_else_clause: true,\n-            }) = ex.kind; // if let ... {} else {}\n-            if let ExprKind::MethodCall(_, _, ref args) = op.kind;\n-            let ty = cx.tables.expr_ty(&args[0]);\n-            if match_type(cx, ty, &paths::MUTEX); // make sure receiver is Mutex\n-            if method_chain_names(op, 10).iter().any(|s| s == \"lock\"); // and lock is called\n+            },\n+        ) = ex.kind\n+        {\n+            op_visit.visit_expr(op);\n+            if op_visit.op_mutex && op_visit.op_lock {\n+                for arm in *arms {\n+                    arm_visit.visit_arm(arm);\n+                }\n \n-            if arms.iter().any(|arm| matching_arm(arm, op, ex, cx));\n-            then {\n-                span_lint_and_help(\n-                    cx,\n-                    IF_LET_MUTEX,\n-                    ex.span,\n-                    \"calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\",\n-                    \"move the lock call outside of the `if let ...` expression\",\n-                );\n+                if arm_visit.arm_mutex && arm_visit.arm_lock {\n+                    span_lint_and_help(\n+                        cx,\n+                        IF_LET_MUTEX,\n+                        ex.span,\n+                        \"calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\",\n+                        \"move the lock call outside of the `if let ...` expression\",\n+                    );\n+                }\n             }\n         }\n     }\n }\n \n-fn matching_arm(arm: &Arm<'_>, op: &Expr<'_>, ex: &Expr<'_>, cx: &LateContext<'_, '_>) -> bool {\n-    if let ExprKind::Block(ref block, _l) = arm.body.kind {\n-        block.stmts.iter().any(|stmt| matching_stmt(stmt, op, ex, cx))\n-    } else {\n-        false\n-    }\n+/// Checks if `Mutex::lock` is called in the `if let _ = expr.\n+pub struct IfLetMutexVisitor<'tcx, 'l> {\n+    pub op_mutex: bool,\n+    pub op_lock: bool,\n+    pub cx: &'tcx LateContext<'tcx, 'l>,\n }\n \n-fn matching_stmt(stmt: &Stmt<'_>, op: &Expr<'_>, ex: &Expr<'_>, cx: &LateContext<'_, '_>) -> bool {\n-    match stmt.kind {\n-        StmtKind::Local(l) => if_chain! {\n-            if let Some(ex) = l.init;\n-            if let ExprKind::MethodCall(_, _, _) = op.kind;\n-            if method_chain_names(ex, 10).iter().any(|s| s == \"lock\"); // and lock is called\n-            then {\n-                match_type_method_chain(cx, ex, 5)\n-            } else {\n-                false\n-            }\n-        },\n-        StmtKind::Expr(e) => if_chain! {\n-            if let ExprKind::MethodCall(_, _, _) = e.kind;\n-            if method_chain_names(e, 10).iter().any(|s| s == \"lock\"); // and lock is called\n-            then {\n-                match_type_method_chain(cx, ex, 5)\n-            } else {\n-                false\n+impl<'tcx, 'l> Visitor<'tcx> for IfLetMutexVisitor<'tcx, 'l> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::MethodCall(path, _span, args) = &expr.kind {\n+            if path.ident.to_string() == \"lock\" {\n+                self.op_lock = true;\n             }\n-        },\n-        StmtKind::Semi(e) => if_chain! {\n-            if let ExprKind::MethodCall(_, _, _) = e.kind;\n-            if method_chain_names(e, 10).iter().any(|s| s == \"lock\"); // and lock is called\n-            then {\n-                match_type_method_chain(cx, ex, 5)\n-            } else {\n-                false\n+            let ty = self.cx.tables.expr_ty(&args[0]);\n+            if match_type(self.cx, ty, &paths::MUTEX) {\n+                self.op_mutex = true;\n             }\n-        },\n-        _ => false,\n+        }\n+        visit::walk_expr(self, expr);\n     }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Checks if `Mutex::lock` is called in any of the branches.\n+pub struct ArmVisitor<'tcx, 'l> {\n+    pub arm_mutex: bool,\n+    pub arm_lock: bool,\n+    pub cx: &'tcx LateContext<'tcx, 'l>,\n }\n \n-/// Return the names of `max_depth` number of methods called in the chain.\n-fn method_chain_names<'tcx>(expr: &'tcx Expr<'tcx>, max_depth: usize) -> Vec<String> {\n-    let mut method_names = Vec::with_capacity(max_depth);\n-    let mut current = expr;\n-    for _ in 0..max_depth {\n-        if let ExprKind::MethodCall(path, _, args) = &current.kind {\n-            if args.iter().any(|e| e.span.from_expansion()) {\n-                break;\n+impl<'tcx, 'l> Visitor<'tcx> for ArmVisitor<'tcx, 'l> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::MethodCall(path, _span, args) = &expr.kind {\n+            if path.ident.to_string() == \"lock\" {\n+                self.arm_lock = true;\n+            }\n+            let ty = self.cx.tables.expr_ty(&args[0]);\n+            if match_type(self.cx, ty, &paths::MUTEX) {\n+                self.arm_mutex = true;\n             }\n-            method_names.push(path.ident.to_string());\n-            current = &args[0];\n-        } else {\n-            break;\n         }\n+        visit::walk_expr(self, expr);\n     }\n-    method_names\n-}\n \n-/// Check that lock is called on a `Mutex`.\n-fn match_type_method_chain<'tcx>(cx: &LateContext<'_, '_>, expr: &'tcx Expr<'tcx>, max_depth: usize) -> bool {\n-    let mut current = expr;\n-    for _ in 0..max_depth {\n-        if let ExprKind::MethodCall(_, _, args) = &current.kind {\n-            let ty = cx.tables.expr_ty(&args[0]);\n-            if match_type(cx, ty, &paths::MUTEX) {\n-                return true;\n+    fn visit_arm(&mut self, arm: &'tcx Arm<'_>) {\n+        if let ExprKind::Block(ref block, _l) = arm.body.kind {\n+            for stmt in block.stmts {\n+                match stmt.kind {\n+                    StmtKind::Local(loc) => {\n+                        if let Some(expr) = loc.init {\n+                            self.visit_expr(expr)\n+                        }\n+                    },\n+                    StmtKind::Expr(expr) => self.visit_expr(expr),\n+                    StmtKind::Semi(expr) => self.visit_expr(expr),\n+                    // we don't care about `Item`\n+                    _ => {},\n+                }\n             }\n-            current = &args[0];\n-        }\n+        };\n+        visit::walk_arm(self, arm);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n     }\n-    false\n }"}, {"sha": "1d7cc756dc5b8f0d028ece1d087ed94add957528", "filename": "tests/ui/if_let_mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c77d9a42317122bf862c985ac120c49a1eb773/tests%2Fui%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c77d9a42317122bf862c985ac120c49a1eb773/tests%2Fui%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_mutex.rs?ref=c6c77d9a42317122bf862c985ac120c49a1eb773", "patch": "@@ -3,9 +3,9 @@\n use std::sync::Mutex;\n \n fn do_stuff<T>(_: T) {}\n-fn foo() {\n-    let m = Mutex::new(1u8);\n \n+fn if_let() {\n+    let m = Mutex::new(1u8);\n     if let Err(locked) = m.lock() {\n         do_stuff(locked);\n     } else {"}]}