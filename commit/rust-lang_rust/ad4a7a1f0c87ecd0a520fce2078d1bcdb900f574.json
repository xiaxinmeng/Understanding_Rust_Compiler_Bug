{"sha": "ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNGE3YTFmMGM4N2VjZDBhNTIwZmNlMjA3OGQxYmNkYjkwMGY1NzQ=", "commit": {"author": {"name": "CohenArthur", "email": "arthur.cohen@epita.fr", "date": "2020-08-22T13:21:38Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@epita.fr", "date": "2020-08-22T13:21:38Z"}, "message": "FunctionCx: WIP: Fix syntax error on sed codegen_cx -> .codegen_cx", "tree": {"sha": "60494aa61d12b7925b768bfae61a5c0d36a48084", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60494aa61d12b7925b768bfae61a5c0d36a48084"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "html_url": "https://github.com/rust-lang/rust/commit/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d199b83b5571f18391fc82d253ccd51d4a5cbaa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d199b83b5571f18391fc82d253ccd51d4a5cbaa3", "html_url": "https://github.com/rust-lang/rust/commit/d199b83b5571f18391fc82d253ccd51d4a5cbaa3"}], "stats": {"total": 556, "additions": 278, "deletions": 278}, "files": [{"sha": "ca6680f1e14d213fb65a78dace20a937f4c7b25a", "filename": "src/abi/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -226,9 +226,9 @@ pub(crate) fn import_function<'tcx>(\n impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n     /// Instance must be monomorphized\n     pub(crate) fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n-        let func_id = import_function(selfcodegen_cx.tcx, selfcodegen_cx.module, inst);\n+        let func_id = import_function(self.codegen_cx.tcx, self.codegen_cx.module, inst);\n         let func_ref = self\n-            codegen_cx.module\n+            .codegen_cx.module\n             .declare_func_in_func(func_id, &mut self.bcx.func);\n \n         #[cfg(debug_assertions)]\n@@ -250,11 +250,11 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n             call_conv: CallConv::triple_default(self.triple()),\n         };\n         let func_id = self\n-            codegen_cx.module\n+            .codegen_cx.module\n             .declare_function(&name, Linkage::Import, &sig)\n             .unwrap();\n         let func_ref = self\n-            codegen_cx.module\n+            .codegen_cx.module\n             .declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         #[cfg(debug_assertions)]\n@@ -374,9 +374,9 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n         .collect::<Vec<(Local, ArgKind<'tcx>, Ty<'tcx>)>>();\n \n     assert!(fx.caller_location.is_none());\n-    if fx.instance.def.requires_caller_location(fxcodegen_cx.tcx) {\n+    if fx.instance.def.requires_caller_location(fx.codegen_cx.tcx) {\n         // Store caller location for `#[track_caller]`.\n-        fx.caller_location = Some(cvalue_for_param(fx, start_block, None, None, fxcodegen_cx.tcx.caller_location_ty()).unwrap());\n+        fx.caller_location = Some(cvalue_for_param(fx, start_block, None, None, fx.codegen_cx.tcx.caller_location_ty()).unwrap());\n     }\n \n     fx.bcx.switch_to_block(start_block);\n@@ -398,7 +398,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n                     let local_decl = &fx.mir.local_decls[local];\n                     //                       v this ! is important\n                     let internally_mutable = !val.layout().ty.is_freeze(\n-                        fxcodegen_cx.tcx.at(local_decl.source_info.span),\n+                        fx.codegen_cx.tcx.at(local_decl.source_info.span),\n                         ParamEnv::reveal_all(),\n                     );\n                     if local_decl.mutability == mir::Mutability::Not && !internally_mutable {\n@@ -465,24 +465,24 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     args: &[Operand<'tcx>],\n     destination: Option<(Place<'tcx>, BasicBlock)>,\n ) {\n-    let fn_ty = fx.monomorphize(&func.ty(fx.mir, fxcodegen_cx.tcx));\n+    let fn_ty = fx.monomorphize(&func.ty(fx.mir, fx.codegen_cx.tcx));\n     let fn_sig = fx\n-        codegen_cx.tcx\n-        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &fn_ty.fn_sig(fxcodegen_cx.tcx));\n+        .codegen_cx.tcx\n+        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &fn_ty.fn_sig(fx.codegen_cx.tcx));\n \n     let destination = destination.map(|(place, bb)| (trans_place(fx, place), bb));\n \n     // Handle special calls like instrinsics and empty drop glue.\n     let instance = if let ty::FnDef(def_id, substs) = fn_ty.kind {\n-        let instance = ty::Instance::resolve(fxcodegen_cx.tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n+        let instance = ty::Instance::resolve(fx.codegen_cx.tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n             .unwrap()\n             .unwrap()\n-            .polymorphize(fxcodegen_cx.tcx);\n+            .polymorphize(fx.codegen_cx.tcx);\n \n-        if fxcodegen_cx.tcx.symbol_name(instance).name.starts_with(\"llvm.\") {\n+        if fx.codegen_cx.tcx.symbol_name(instance).name.starts_with(\"llvm.\") {\n             crate::intrinsics::codegen_llvm_intrinsic_call(\n                 fx,\n-                &fxcodegen_cx.tcx.symbol_name(instance).name,\n+                &fx.codegen_cx.tcx.symbol_name(instance).name,\n                 substs,\n                 args,\n                 destination,\n@@ -510,7 +510,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n     let is_cold =\n         instance.map(|inst|\n-            fxcodegen_cx.tcx.codegen_fn_attrs(inst.def_id())\n+            fx.codegen_cx.tcx.codegen_fn_attrs(inst.def_id())\n                 .flags.contains(CodegenFnAttrFlags::COLD))\n                 .unwrap_or(false);\n     if is_cold {\n@@ -558,7 +558,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                     nop_inst,\n                     format!(\n                         \"virtual call; self arg pass mode: {:?}\",\n-                        get_pass_mode(fxcodegen_cx.tcx, args[0].layout())\n+                        get_pass_mode(fx.codegen_cx.tcx, args[0].layout())\n                     ),\n                 );\n             }\n@@ -608,15 +608,15 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 )\n                 .collect::<Vec<_>>();\n \n-            if instance.map(|inst| inst.def.requires_caller_location(fxcodegen_cx.tcx)).unwrap_or(false) {\n+            if instance.map(|inst| inst.def.requires_caller_location(fx.codegen_cx.tcx)).unwrap_or(false) {\n                 // Pass the caller location for `#[track_caller]`.\n                 let caller_location = fx.get_caller_location(span);\n                 call_args.extend(adjust_arg_for_abi(fx, caller_location).into_iter());\n             }\n \n             let call_inst = if let Some(func_ref) = func_ref {\n                 let sig = clif_sig_from_fn_sig(\n-                    fxcodegen_cx.tcx,\n+                    fx.codegen_cx.tcx,\n                     fx.triple(),\n                     fn_sig,\n                     span,\n@@ -637,7 +637,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n         if fn_sig.abi != Abi::C {\n-            fxcodegen_cx.tcx.sess.span_fatal(span, &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi));\n+            fx.codegen_cx.tcx.sess.span_fatal(span, &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi));\n         }\n         let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n         let abi_params = call_args\n@@ -646,7 +646,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 let ty = fx.bcx.func.dfg.value_type(arg);\n                 if !ty.is_int() {\n                     // FIXME set %al to upperbound on float args once floats are supported\n-                    fxcodegen_cx.tcx.sess.span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n+                    fx.codegen_cx.tcx.sess.span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n                 }\n                 AbiParam::new(ty)\n             })\n@@ -668,17 +668,17 @@ pub(crate) fn codegen_drop<'tcx>(\n     drop_place: CPlace<'tcx>,\n ) {\n     let ty = drop_place.layout().ty;\n-    let drop_fn = Instance::resolve_drop_in_place(fxcodegen_cx.tcx, ty).polymorphize(fxcodegen_cx.tcx);\n+    let drop_fn = Instance::resolve_drop_in_place(fx.codegen_cx.tcx, ty).polymorphize(fx.codegen_cx.tcx);\n \n     if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n         // we don't actually need to drop anything\n     } else {\n-        let drop_fn_ty = drop_fn.ty(fxcodegen_cx.tcx, ParamEnv::reveal_all());\n-        let fn_sig = fxcodegen_cx.tcx.normalize_erasing_late_bound_regions(\n+        let drop_fn_ty = drop_fn.ty(fx.codegen_cx.tcx, ParamEnv::reveal_all());\n+        let fn_sig = fx.codegen_cx.tcx.normalize_erasing_late_bound_regions(\n             ParamEnv::reveal_all(),\n-            &drop_fn_ty.fn_sig(fxcodegen_cx.tcx),\n+            &drop_fn_ty.fn_sig(fx.codegen_cx.tcx),\n         );\n-        assert_eq!(fn_sig.output(), fxcodegen_cx.tcx.mk_unit());\n+        assert_eq!(fn_sig.output(), fx.codegen_cx.tcx.mk_unit());\n \n         match ty.kind {\n             ty::Dynamic(..) => {\n@@ -687,7 +687,7 @@ pub(crate) fn codegen_drop<'tcx>(\n                 let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable.unwrap());\n \n                 let sig = clif_sig_from_fn_sig(\n-                    fxcodegen_cx.tcx,\n+                    fx.codegen_cx.tcx,\n                     fx.triple(),\n                     fn_sig,\n                     span,\n@@ -702,7 +702,7 @@ pub(crate) fn codegen_drop<'tcx>(\n \n                 let arg_place = CPlace::new_stack_slot(\n                     fx,\n-                    fx.layout_of(fxcodegen_cx.tcx.mk_ref(\n+                    fx.layout_of(fx.codegen_cx.tcx.mk_ref(\n                         &ty::RegionKind::ReErased,\n                         TypeAndMut {\n                             ty,\n@@ -716,7 +716,7 @@ pub(crate) fn codegen_drop<'tcx>(\n \n                 let mut call_args: Vec<Value> = arg_value.into_iter().collect::<Vec<_>>();\n \n-                if drop_fn.def.requires_caller_location(fxcodegen_cx.tcx) {\n+                if drop_fn.def.requires_caller_location(fx.codegen_cx.tcx) {\n                     // Pass the caller location for `#[track_caller]`.\n                     let caller_location = fx.get_caller_location(span);\n                     call_args.extend(adjust_arg_for_abi(fx, caller_location).into_iter());"}, {"sha": "7172a56ad2979df53e0b2ee696e8d113eac940a8", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -118,7 +118,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n     arg: CValue<'tcx>,\n ) -> EmptySinglePair<Value> {\n-    match get_pass_mode(fxcodegen_cx.tcx, arg.layout()) {\n+    match get_pass_mode(fx.codegen_cx.tcx, arg.layout()) {\n         PassMode::NoPass => Empty,\n         PassMode::ByVal(_) => Single(arg.load_scalar(fx)),\n         PassMode::ByValPair(_, _) => {\n@@ -144,13 +144,13 @@ pub(super) fn cvalue_for_param<'tcx>(\n     arg_ty: Ty<'tcx>,\n ) -> Option<CValue<'tcx>> {\n     let layout = fx.layout_of(arg_ty);\n-    let pass_mode = get_pass_mode(fxcodegen_cx.tcx, layout);\n+    let pass_mode = get_pass_mode(fx.codegen_cx.tcx, layout);\n \n     if let PassMode::NoPass = pass_mode {\n         return None;\n     }\n \n-    let clif_types = pass_mode.get_param_ty(fxcodegen_cx.tcx);\n+    let clif_types = pass_mode.get_param_ty(fx.codegen_cx.tcx);\n     let block_params = clif_types.map(|t| fx.bcx.append_block_param(start_block, t));\n \n     #[cfg(debug_assertions)]"}, {"sha": "51c0c144defe38a68730a7d9cd17b7f27ad98f3f", "filename": "src/abi/returning.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -19,7 +19,7 @@ pub(super) fn codegen_return_param(\n     start_block: Block,\n ) {\n     let ret_layout = return_layout(fx);\n-    let ret_pass_mode = get_pass_mode(fxcodegen_cx.tcx, ret_layout);\n+    let ret_pass_mode = get_pass_mode(fx.codegen_cx.tcx, ret_layout);\n     let ret_param = match ret_pass_mode {\n         PassMode::NoPass => {\n             fx.local_map\n@@ -66,7 +66,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx, B: Backend, T>(\n ) -> (Inst, T) {\n     let ret_layout = fx.layout_of(fn_sig.output());\n \n-    let output_pass_mode = get_pass_mode(fxcodegen_cx.tcx, ret_layout);\n+    let output_pass_mode = get_pass_mode(fx.codegen_cx.tcx, ret_layout);\n     let return_ptr = match output_pass_mode {\n         PassMode::NoPass => None,\n         PassMode::ByRef { size: Some(_)} => match ret_place {\n@@ -102,7 +102,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx, B: Backend, T>(\n }\n \n pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n-    match get_pass_mode(fxcodegen_cx.tcx, return_layout(fx)) {\n+    match get_pass_mode(fx.codegen_cx.tcx, return_layout(fx)) {\n         PassMode::NoPass | PassMode::ByRef { size: Some(_) } => {\n             fx.bcx.ins().return_(&[]);\n         }"}, {"sha": "466e0a312c075f9e743dd08ca80b59e4145f0041", "filename": "src/analyze.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -35,8 +35,8 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Backend>) -> IndexVec<Local,\n         match &bb.terminator().kind {\n             TerminatorKind::Call { destination, .. } => {\n                 if let Some((dest_place, _dest_bb)) = destination {\n-                    let dest_layout = fx.layout_of(fx.monomorphize(&dest_place.ty(&fx.mir.local_decls, fxcodegen_cx.tcx).ty));\n-                    if !crate::abi::can_return_to_ssa_var(fxcodegen_cx.tcx, dest_layout) {\n+                    let dest_layout = fx.layout_of(fx.monomorphize(&dest_place.ty(&fx.mir.local_decls, fx.codegen_cx.tcx).ty));\n+                    if !crate::abi::can_return_to_ssa_var(fx.codegen_cx.tcx, dest_layout) {\n                         not_ssa(&mut flag_map, dest_place.local)\n                     }\n                 }"}, {"sha": "00dca2c34a6b1e5cb0d48714bb8eb3329fd5b1bc", "filename": "src/atomic_shim.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fatomic_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fatomic_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fatomic_shim.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -81,51 +81,51 @@ pub(crate) fn init_global_lock_constructor(\n }\n \n pub(crate) fn lock_global_lock(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n-    let atomic_mutex = fxcodegen_cx.module.declare_data(\n+    let atomic_mutex = fx.codegen_cx.module.declare_data(\n         \"__cg_clif_global_atomic_mutex\",\n         Linkage::Import,\n         true,\n         false,\n         None,\n     ).unwrap();\n \n-    let pthread_mutex_lock = fxcodegen_cx.module.declare_function(\"pthread_mutex_lock\", Linkage::Import, &cranelift_codegen::ir::Signature {\n-        call_conv: fxcodegen_cx.module.target_config().default_call_conv,\n+    let pthread_mutex_lock = fx.codegen_cx.module.declare_function(\"pthread_mutex_lock\", Linkage::Import, &cranelift_codegen::ir::Signature {\n+        call_conv: fx.codegen_cx.module.target_config().default_call_conv,\n         params: vec![\n-            AbiParam::new(fxcodegen_cx.module.target_config().pointer_type() /* *mut pthread_mutex_t */),\n+            AbiParam::new(fx.codegen_cx.module.target_config().pointer_type() /* *mut pthread_mutex_t */),\n         ],\n         returns: vec![AbiParam::new(types::I32 /* c_int */)],\n     }).unwrap();\n \n-    let pthread_mutex_lock = fxcodegen_cx.module.declare_func_in_func(pthread_mutex_lock, fx.bcx.func);\n+    let pthread_mutex_lock = fx.codegen_cx.module.declare_func_in_func(pthread_mutex_lock, fx.bcx.func);\n \n-    let atomic_mutex = fxcodegen_cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx.bcx.ins().global_value(fxcodegen_cx.module.target_config().pointer_type(), atomic_mutex);\n+    let atomic_mutex = fx.codegen_cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n+    let atomic_mutex = fx.bcx.ins().global_value(fx.codegen_cx.module.target_config().pointer_type(), atomic_mutex);\n \n     fx.bcx.ins().call(pthread_mutex_lock, &[atomic_mutex]);\n }\n \n pub(crate) fn unlock_global_lock(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n-    let atomic_mutex = fxcodegen_cx.module.declare_data(\n+    let atomic_mutex = fx.codegen_cx.module.declare_data(\n         \"__cg_clif_global_atomic_mutex\",\n         Linkage::Import,\n         true,\n         false,\n         None,\n     ).unwrap();\n \n-    let pthread_mutex_unlock = fxcodegen_cx.module.declare_function(\"pthread_mutex_unlock\", Linkage::Import, &cranelift_codegen::ir::Signature {\n-        call_conv: fxcodegen_cx.module.target_config().default_call_conv,\n+    let pthread_mutex_unlock = fx.codegen_cx.module.declare_function(\"pthread_mutex_unlock\", Linkage::Import, &cranelift_codegen::ir::Signature {\n+        call_conv: fx.codegen_cx.module.target_config().default_call_conv,\n         params: vec![\n-            AbiParam::new(fxcodegen_cx.module.target_config().pointer_type() /* *mut pthread_mutex_t */),\n+            AbiParam::new(fx.codegen_cx.module.target_config().pointer_type() /* *mut pthread_mutex_t */),\n         ],\n         returns: vec![AbiParam::new(types::I32 /* c_int */)],\n     }).unwrap();\n \n-    let pthread_mutex_unlock = fxcodegen_cx.module.declare_func_in_func(pthread_mutex_unlock, fx.bcx.func);\n+    let pthread_mutex_unlock = fx.codegen_cx.module.declare_func_in_func(pthread_mutex_unlock, fx.bcx.func);\n \n-    let atomic_mutex = fxcodegen_cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx.bcx.ins().global_value(fxcodegen_cx.module.target_config().pointer_type(), atomic_mutex);\n+    let atomic_mutex = fx.codegen_cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n+    let atomic_mutex = fx.bcx.ins().global_value(fx.codegen_cx.module.target_config().pointer_type(), atomic_mutex);\n \n     fx.bcx.ins().call(pthread_mutex_unlock, &[atomic_mutex]);\n }"}, {"sha": "cbb845af77c1bb1f67989d91d3abb36fc79baf34", "filename": "src/base.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -8,13 +8,13 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n     instance: Instance<'tcx>,\n     linkage: Linkage,\n ) {\n-    let tcx = cxcodegen_cx.tcx;\n+    let tcx = cx.codegen_cx.tcx;\n \n     let mir = tcx.instance_mir(instance.def);\n \n     // Declare function\n-    let (name, sig) = get_function_name_and_sig(tcx, cxcodegen_cx.module.isa().triple(), instance, false);\n-    let func_id = cxcodegen_cx.module.declare_function(&name, linkage, &sig).unwrap();\n+    let (name, sig) = get_function_name_and_sig(tcx, cx.codegen_cx.module.isa().triple(), instance, false);\n+    let func_id = cx.codegen_cx.module.declare_function(&name, linkage, &sig).unwrap();\n \n     // Make FunctionBuilder\n     let context = &mut cx.cached_context;\n@@ -30,12 +30,12 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n     let block_map: IndexVec<BasicBlock, Block> = (0..mir.basic_blocks().len()).map(|_| bcx.create_block()).collect();\n \n     // Make FunctionCx\n-    let pointer_type = cxcodegen_cx.module.target_config().pointer_type();\n+    let pointer_type = cx.codegen_cx.module.target_config().pointer_type();\n     let clif_comments = crate::pretty_clif::CommentWriter::new(tcx, instance);\n \n     let mut fx = FunctionCx {\n         tcx,\n-        module: &mut cxcodegen_cx.module,\n+        module: &mut cx.codegen_cx.module,\n         global_asm: &mut cx.global_asm,\n         pointer_type,\n \n@@ -49,7 +49,7 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n         cold_blocks: EntitySet::new(),\n \n         clif_comments,\n-        constants_cx: &mut cxcodegen_cx.constants_cx,\n+        constants_cx: &mut cx.codegen_cx.constants_cx,\n         vtables: &mut cx.vtables,\n         source_info_set: indexmap::IndexSet::new(),\n         next_ssa_var: 0,\n@@ -78,7 +78,7 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n     let cold_blocks = fx.cold_blocks;\n \n     crate::pretty_clif::write_clif_file(\n-        cxcodegen_cx.tcx,\n+        cx.codegen_cx.tcx,\n         \"unopt\",\n         None,\n         instance,\n@@ -98,10 +98,10 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n     // instruction, which doesn't have an encoding.\n     context.compute_cfg();\n     context.compute_domtree();\n-    context.eliminate_unreachable_code(cxcodegen_cx.module.isa()).unwrap();\n+    context.eliminate_unreachable_code(cx.codegen_cx.module.isa()).unwrap();\n \n     // Define function\n-    let module = &mut cxcodegen_cx.module;\n+    let module = &mut cx.codegen_cx.module;\n     tcx.sess.time(\n         \"define function\",\n         || module.define_function(\n@@ -113,16 +113,16 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n \n     // Write optimized function to file for debugging\n     crate::pretty_clif::write_clif_file(\n-        cxcodegen_cx.tcx,\n+        cx.codegen_cx.tcx,\n         \"opt\",\n-        Some(cxcodegen_cx.module.isa()),\n+        Some(cx.codegen_cx.module.isa()),\n         instance,\n         &context,\n         &clif_comments,\n     );\n \n     // Define debuginfo for function\n-    let isa = cxcodegen_cx.module.isa();\n+    let isa = cx.codegen_cx.module.isa();\n     let debug_context = &mut cx.debug_context;\n     let unwind_context = &mut cx.unwind_context;\n     tcx.sess.time(\"generate debug info\", || {\n@@ -224,7 +224,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n                 target,\n                 cleanup: _,\n             } => {\n-                if !fxcodegen_cx.tcx.sess.overflow_checks() {\n+                if !fx.codegen_cx.tcx.sess.overflow_checks() {\n                     if let mir::AssertKind::OverflowNeg(_) = *msg {\n                         let target = fx.get_block(*target);\n                         fx.bcx.ins().jump(target, &[]);\n@@ -265,12 +265,12 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n                     }\n                 };\n \n-                let def_id = fxcodegen_cx.tcx.lang_items().require(lang_item).unwrap_or_else(|s| {\n-                    fxcodegen_cx.tcx.sess.span_fatal(bb_data.terminator().source_info.span, &s)\n+                let def_id = fx.codegen_cx.tcx.lang_items().require(lang_item).unwrap_or_else(|s| {\n+                    fx.codegen_cx.tcx.sess.span_fatal(bb_data.terminator().source_info.span, &s)\n                 });\n \n-                let instance = Instance::mono(fxcodegen_cx.tcx, def_id).polymorphize(fxcodegen_cx.tcx);\n-                let symbol_name = fxcodegen_cx.tcx.symbol_name(instance).name;\n+                let instance = Instance::mono(fx.codegen_cx.tcx, def_id).polymorphize(fx.codegen_cx.tcx);\n+                let symbol_name = fx.codegen_cx.tcx.symbol_name(instance).name;\n \n                 fx.lib_call(&*symbol_name, vec![fx.pointer_type, fx.pointer_type, fx.pointer_type], vec![], &args);\n \n@@ -300,7 +300,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n                 cleanup: _,\n                 from_hir_call: _,\n             } => {\n-                fxcodegen_cx.tcx.sess.time(\"codegen call\", || crate::abi::codegen_terminator_call(\n+                fx.codegen_cx.tcx.sess.time(\"codegen call\", || crate::abi::codegen_terminator_call(\n                     fx,\n                     *fn_span,\n                     block,\n@@ -419,7 +419,7 @@ fn trans_stmt<'tcx>(\n                     let lhs = trans_operand(fx, lhs);\n                     let rhs = trans_operand(fx, rhs);\n \n-                    let res = if !fxcodegen_cx.tcx.sess.overflow_checks() {\n+                    let res = if !fx.codegen_cx.tcx.sess.overflow_checks() {\n                         let val =\n                             crate::num::trans_int_binop(fx, *bin_op, lhs, rhs).load_scalar(fx);\n                         let is_overflow = fx.bcx.ins().iconst(types::I8, 0);\n@@ -465,14 +465,14 @@ fn trans_stmt<'tcx>(\n                     lval.write_cvalue(fx, res);\n                 }\n                 Rvalue::Cast(CastKind::Pointer(PointerCast::ReifyFnPointer), operand, to_ty) => {\n-                    let from_ty = fx.monomorphize(&operand.ty(&fx.mir.local_decls, fxcodegen_cx.tcx));\n+                    let from_ty = fx.monomorphize(&operand.ty(&fx.mir.local_decls, fx.codegen_cx.tcx));\n                     let to_layout = fx.layout_of(fx.monomorphize(to_ty));\n                     match from_ty.kind {\n                         ty::FnDef(def_id, substs) => {\n                             let func_ref = fx.get_function_ref(\n-                                Instance::resolve_for_fn_ptr(fxcodegen_cx.tcx, ParamEnv::reveal_all(), def_id, substs)\n+                                Instance::resolve_for_fn_ptr(fx.codegen_cx.tcx, ParamEnv::reveal_all(), def_id, substs)\n                                     .unwrap()\n-                                    .polymorphize(fxcodegen_cx.tcx),\n+                                    .polymorphize(fx.codegen_cx.tcx),\n                             );\n                             let func_addr = fx.bcx.ins().func_addr(fx.pointer_type, func_ref);\n                             lval.write_cvalue(fx, CValue::by_val(func_addr, to_layout));\n@@ -501,7 +501,7 @@ fn trans_stmt<'tcx>(\n                                 |ty::TypeAndMut {\n                                      ty: pointee_ty,\n                                      mutbl: _,\n-                                 }| has_ptr_meta(fxcodegen_cx.tcx, pointee_ty),\n+                                 }| has_ptr_meta(fx.codegen_cx.tcx, pointee_ty),\n                             )\n                             .unwrap_or(false)\n                     }\n@@ -527,7 +527,7 @@ fn trans_stmt<'tcx>(\n \n                         match &operand.layout().variants {\n                             Variants::Single { index } => {\n-                                let discr = operand.layout().ty.discriminant_for_variant(fxcodegen_cx.tcx, *index).unwrap();\n+                                let discr = operand.layout().ty.discriminant_for_variant(fx.codegen_cx.tcx, *index).unwrap();\n                                 let discr = if discr.ty.is_signed() {\n                                     rustc_middle::mir::interpret::sign_extend(discr.val, fx.layout_of(discr.ty).size)\n                                 } else {\n@@ -579,11 +579,11 @@ fn trans_stmt<'tcx>(\n                     match operand.layout().ty.kind {\n                         ty::Closure(def_id, substs) => {\n                             let instance = Instance::resolve_closure(\n-                                fxcodegen_cx.tcx,\n+                                fx.codegen_cx.tcx,\n                                 def_id,\n                                 substs,\n                                 ty::ClosureKind::FnOnce,\n-                            ).polymorphize(fxcodegen_cx.tcx);\n+                            ).polymorphize(fx.codegen_cx.tcx);\n                             let func_ref = fx.get_function_ref(instance);\n                             let func_addr = fx.bcx.ins().func_addr(fx.pointer_type, func_ref);\n                             lval.write_cvalue(fx, CValue::by_val(func_addr, lval.layout()));\n@@ -606,9 +606,9 @@ fn trans_stmt<'tcx>(\n                     let operand = trans_operand(fx, operand);\n                     let times = fx\n                         .monomorphize(times)\n-                        .eval(fxcodegen_cx.tcx, ParamEnv::reveal_all())\n+                        .eval(fx.codegen_cx.tcx, ParamEnv::reveal_all())\n                         .val\n-                        .try_to_bits(fxcodegen_cx.tcx.data_layout.pointer_size)\n+                        .try_to_bits(fx.codegen_cx.tcx.data_layout.pointer_size)\n                         .unwrap();\n                     for i in 0..times {\n                         let index = fx.bcx.ins().iconst(fx.pointer_type, i as i64);\n@@ -618,33 +618,33 @@ fn trans_stmt<'tcx>(\n                 }\n                 Rvalue::Len(place) => {\n                     let place = trans_place(fx, *place);\n-                    let usize_layout = fx.layout_of(fxcodegen_cx.tcx.types.usize);\n+                    let usize_layout = fx.layout_of(fx.codegen_cx.tcx.types.usize);\n                     let len = codegen_array_len(fx, place);\n                     lval.write_cvalue(fx, CValue::by_val(len, usize_layout));\n                 }\n                 Rvalue::NullaryOp(NullOp::Box, content_ty) => {\n                     use rustc_hir::lang_items::ExchangeMallocFnLangItem;\n \n-                    let usize_type = fx.clif_type(fxcodegen_cx.tcx.types.usize).unwrap();\n+                    let usize_type = fx.clif_type(fx.codegen_cx.tcx.types.usize).unwrap();\n                     let content_ty = fx.monomorphize(content_ty);\n                     let layout = fx.layout_of(content_ty);\n                     let llsize = fx.bcx.ins().iconst(usize_type, layout.size.bytes() as i64);\n                     let llalign = fx\n                         .bcx\n                         .ins()\n                         .iconst(usize_type, layout.align.abi.bytes() as i64);\n-                    let box_layout = fx.layout_of(fxcodegen_cx.tcx.mk_box(content_ty));\n+                    let box_layout = fx.layout_of(fx.codegen_cx.tcx.mk_box(content_ty));\n \n                     // Allocate space:\n-                    let def_id = match fxcodegen_cx.tcx.lang_items().require(ExchangeMallocFnLangItem) {\n+                    let def_id = match fx.codegen_cx.tcx.lang_items().require(ExchangeMallocFnLangItem) {\n                         Ok(id) => id,\n                         Err(s) => {\n-                            fxcodegen_cx.tcx\n+                            fx.codegen_cx.tcx\n                                 .sess\n                                 .fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n                         }\n                     };\n-                    let instance = ty::Instance::mono(fxcodegen_cx.tcx, def_id).polymorphize(fxcodegen_cx.tcx);\n+                    let instance = ty::Instance::mono(fx.codegen_cx.tcx, def_id).polymorphize(fx.codegen_cx.tcx);\n                     let func_ref = fx.get_function_ref(instance);\n                     let call = fx.bcx.ins().call(func_ref, &[llsize, llalign]);\n                     let ptr = fx.bcx.inst_results(call)[0];\n@@ -654,9 +654,9 @@ fn trans_stmt<'tcx>(\n                     assert!(lval\n                         .layout()\n                         .ty\n-                        .is_sized(fxcodegen_cx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all()));\n+                        .is_sized(fx.codegen_cx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all()));\n                     let ty_size = fx.layout_of(fx.monomorphize(ty)).size.bytes();\n-                    let val = CValue::const_val(fx, fx.layout_of(fxcodegen_cx.tcx.types.usize), ty_size.into());\n+                    let val = CValue::const_val(fx, fx.layout_of(fx.codegen_cx.tcx.types.usize), ty_size.into());\n                     lval.write_cvalue(fx, val);\n                 }\n                 Rvalue::Aggregate(kind, operands) => match **kind {\n@@ -721,10 +721,10 @@ fn trans_stmt<'tcx>(\n                     let (eax, ebx, ecx, edx) = crate::intrinsics::codegen_cpuid_call(fx, leaf, subleaf);\n \n                     assert_eq!(outputs.len(), 4);\n-                    trans_place(fx, outputs[0]).write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fxcodegen_cx.tcx.types.u32)));\n-                    trans_place(fx, outputs[1]).write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fxcodegen_cx.tcx.types.u32)));\n-                    trans_place(fx, outputs[2]).write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fxcodegen_cx.tcx.types.u32)));\n-                    trans_place(fx, outputs[3]).write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fxcodegen_cx.tcx.types.u32)));\n+                    trans_place(fx, outputs[0]).write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.codegen_cx.tcx.types.u32)));\n+                    trans_place(fx, outputs[1]).write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.codegen_cx.tcx.types.u32)));\n+                    trans_place(fx, outputs[2]).write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.codegen_cx.tcx.types.u32)));\n+                    trans_place(fx, outputs[3]).write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.codegen_cx.tcx.types.u32)));\n                 }\n                 \"xgetbv\" => {\n                     assert_eq!(input_names, &[Symbol::intern(\"{ecx}\")]);\n@@ -744,17 +744,17 @@ fn trans_stmt<'tcx>(\n                     crate::trap::trap_unimplemented(fx, \"_xgetbv arch intrinsic is not supported\");\n                 }\n                 // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n-                _ if fxcodegen_cx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") => {\n+                _ if fx.codegen_cx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") => {\n                     crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n                 }\n-                _ if fxcodegen_cx.tcx.symbol_name(fx.instance).name == \"__alloca\" => {\n+                _ if fx.codegen_cx.tcx.symbol_name(fx.instance).name == \"__alloca\" => {\n                     crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n                 }\n                 // Used in sys::windows::abort_internal\n                 \"int $$0x29\" => {\n                     crate::trap::trap_unimplemented(fx, \"Windows abort\");\n                 }\n-                _ => fxcodegen_cx.tcx.sess.span_fatal(stmt.source_info.span, \"Inline assembly is not supported\"),\n+                _ => fx.codegen_cx.tcx.sess.span_fatal(stmt.source_info.span, \"Inline assembly is not supported\"),\n             }\n         }\n     }\n@@ -767,8 +767,8 @@ fn codegen_array_len<'tcx>(\n     match place.layout().ty.kind {\n         ty::Array(_elem_ty, len) => {\n             let len = fx.monomorphize(&len)\n-                .eval(fxcodegen_cx.tcx, ParamEnv::reveal_all())\n-                .eval_usize(fxcodegen_cx.tcx, ParamEnv::reveal_all()) as i64;\n+                .eval(fx.codegen_cx.tcx, ParamEnv::reveal_all())\n+                .eval_usize(fx.codegen_cx.tcx, ParamEnv::reveal_all()) as i64;\n             fx.bcx.ins().iconst(fx.pointer_type, len)\n         }\n         ty::Slice(_elem_ty) => place\n@@ -821,7 +821,7 @@ pub(crate) fn trans_place<'tcx>(\n                         let ptr = cplace.to_ptr();\n                         cplace = CPlace::for_ptr(\n                             ptr.offset_i64(fx, elem_layout.size.bytes() as i64 * i64::from(from)),\n-                            fx.layout_of(fxcodegen_cx.tcx.mk_array(elem_ty, u64::from(to) - u64::from(from))),\n+                            fx.layout_of(fx.codegen_cx.tcx.mk_array(elem_ty, u64::from(to) - u64::from(from))),\n                         );\n                     }\n                     ty::Slice(elem_ty) => {"}, {"sha": "db465a581275a871247b1f00058fe8c2a615d396", "filename": "src/cast.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -86,14 +86,14 @@ pub(crate) fn clif_int_or_float_cast(\n             );\n \n             let from_rust_ty = if from_signed {\n-                fxcodegen_cx.tcx.types.i128\n+                fx.codegen_cx.tcx.types.i128\n             } else {\n-                fxcodegen_cx.tcx.types.u128\n+                fx.codegen_cx.tcx.types.u128\n             };\n \n             let to_rust_ty = match to_ty {\n-                types::F32 => fxcodegen_cx.tcx.types.f32,\n-                types::F64 => fxcodegen_cx.tcx.types.f64,\n+                types::F32 => fx.codegen_cx.tcx.types.f32,\n+                types::F64 => fx.codegen_cx.tcx.types.f64,\n                 _ => unreachable!(),\n             };\n \n@@ -131,15 +131,15 @@ pub(crate) fn clif_int_or_float_cast(\n             );\n \n             let from_rust_ty = match from_ty {\n-                types::F32 => fxcodegen_cx.tcx.types.f32,\n-                types::F64 => fxcodegen_cx.tcx.types.f64,\n+                types::F32 => fx.codegen_cx.tcx.types.f32,\n+                types::F64 => fx.codegen_cx.tcx.types.f64,\n                 _ => unreachable!(),\n             };\n \n             let to_rust_ty = if to_signed {\n-                fxcodegen_cx.tcx.types.i128\n+                fx.codegen_cx.tcx.types.i128\n             } else {\n-                fxcodegen_cx.tcx.types.u128\n+                fx.codegen_cx.tcx.types.u128\n             };\n \n             return fx"}, {"sha": "bb927a4dd70bf8310a81eb44a8d11b54ec5417de", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -9,7 +9,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n     lhs: CValue<'tcx>,\n     rhs: CValue<'tcx>,\n ) -> Option<CValue<'tcx>> {\n-    if lhs.layout().ty != fxcodegen_cx.tcx.types.u128 && lhs.layout().ty != fxcodegen_cx.tcx.types.i128 {\n+    if lhs.layout().ty != fx.codegen_cx.tcx.types.u128 && lhs.layout().ty != fx.codegen_cx.tcx.types.i128 {\n         return None;\n     }\n \n@@ -25,15 +25,15 @@ pub(crate) fn maybe_codegen<'tcx>(\n         }\n         BinOp::Add | BinOp::Sub if !checked => return None,\n         BinOp::Add => {\n-            let out_ty = fxcodegen_cx.tcx.mk_tup([lhs.layout().ty, fxcodegen_cx.tcx.types.bool].iter());\n+            let out_ty = fx.codegen_cx.tcx.mk_tup([lhs.layout().ty, fx.codegen_cx.tcx.types.bool].iter());\n             return Some(if is_signed {\n                 fx.easy_call(\"__rust_i128_addo\", &[lhs, rhs], out_ty)\n             } else {\n                 fx.easy_call(\"__rust_u128_addo\", &[lhs, rhs], out_ty)\n             });\n         }\n         BinOp::Sub => {\n-            let out_ty = fxcodegen_cx.tcx.mk_tup([lhs.layout().ty, fxcodegen_cx.tcx.types.bool].iter());\n+            let out_ty = fx.codegen_cx.tcx.mk_tup([lhs.layout().ty, fx.codegen_cx.tcx.types.bool].iter());\n             return Some(if is_signed {\n                 fx.easy_call(\"__rust_i128_subo\", &[lhs, rhs], out_ty)\n             } else {\n@@ -43,17 +43,17 @@ pub(crate) fn maybe_codegen<'tcx>(\n         BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n         BinOp::Mul => {\n             let res = if checked {\n-                let out_ty = fxcodegen_cx.tcx.mk_tup([lhs.layout().ty, fxcodegen_cx.tcx.types.bool].iter());\n+                let out_ty = fx.codegen_cx.tcx.mk_tup([lhs.layout().ty, fx.codegen_cx.tcx.types.bool].iter());\n                 if is_signed {\n                     fx.easy_call(\"__rust_i128_mulo\", &[lhs, rhs], out_ty)\n                 } else {\n                     fx.easy_call(\"__rust_u128_mulo\", &[lhs, rhs], out_ty)\n                 }\n             } else {\n                 let val_ty = if is_signed {\n-                    fxcodegen_cx.tcx.types.i128\n+                    fx.codegen_cx.tcx.types.i128\n                 } else {\n-                    fxcodegen_cx.tcx.types.u128\n+                    fx.codegen_cx.tcx.types.u128\n                 };\n                 fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty)\n             };\n@@ -62,17 +62,17 @@ pub(crate) fn maybe_codegen<'tcx>(\n         BinOp::Div => {\n             assert!(!checked);\n             if is_signed {\n-                Some(fx.easy_call(\"__divti3\", &[lhs, rhs], fxcodegen_cx.tcx.types.i128))\n+                Some(fx.easy_call(\"__divti3\", &[lhs, rhs], fx.codegen_cx.tcx.types.i128))\n             } else {\n-                Some(fx.easy_call(\"__udivti3\", &[lhs, rhs], fxcodegen_cx.tcx.types.u128))\n+                Some(fx.easy_call(\"__udivti3\", &[lhs, rhs], fx.codegen_cx.tcx.types.u128))\n             }\n         }\n         BinOp::Rem => {\n             assert!(!checked);\n             if is_signed {\n-                Some(fx.easy_call(\"__modti3\", &[lhs, rhs], fxcodegen_cx.tcx.types.i128))\n+                Some(fx.easy_call(\"__modti3\", &[lhs, rhs], fx.codegen_cx.tcx.types.i128))\n             } else {\n-                Some(fx.easy_call(\"__umodti3\", &[lhs, rhs], fxcodegen_cx.tcx.types.u128))\n+                Some(fx.easy_call(\"__umodti3\", &[lhs, rhs], fx.codegen_cx.tcx.types.u128))\n             }\n         }\n         BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {\n@@ -104,21 +104,21 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 let val = match (bin_op, is_signed) {\n                     (BinOp::Shr, false) => {\n                         let val = fx.bcx.ins().iconcat(lhs_msb, all_zeros);\n-                        Some(CValue::by_val(val, fx.layout_of(fxcodegen_cx.tcx.types.u128)))\n+                        Some(CValue::by_val(val, fx.layout_of(fx.codegen_cx.tcx.types.u128)))\n                     }\n                     (BinOp::Shr, true) => {\n                         let sign = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, lhs_msb, 0);\n                         let all_ones = fx.bcx.ins().iconst(types::I64, u64::MAX as i64);\n                         let all_sign_bits = fx.bcx.ins().select(sign, all_zeros, all_ones);\n \n                         let val = fx.bcx.ins().iconcat(lhs_msb, all_sign_bits);\n-                        Some(CValue::by_val(val, fx.layout_of(fxcodegen_cx.tcx.types.i128)))\n+                        Some(CValue::by_val(val, fx.layout_of(fx.codegen_cx.tcx.types.i128)))\n                     }\n                     (BinOp::Shl, _) => {\n                         let val_ty = if is_signed {\n-                            fxcodegen_cx.tcx.types.i128\n+                            fx.codegen_cx.tcx.types.i128\n                         } else {\n-                            fxcodegen_cx.tcx.types.u128\n+                            fx.codegen_cx.tcx.types.u128\n                         };\n                         let val = fx.bcx.ins().iconcat(all_zeros, lhs_lsb);\n                         Some(CValue::by_val(val, fx.layout_of(val_ty)))\n@@ -127,7 +127,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 };\n                 if let Some(val) = val {\n                     if let Some(is_overflow) = is_overflow {\n-                        let out_ty = fxcodegen_cx.tcx.mk_tup([lhs.layout().ty, fxcodegen_cx.tcx.types.bool].iter());\n+                        let out_ty = fx.codegen_cx.tcx.mk_tup([lhs.layout().ty, fx.codegen_cx.tcx.types.bool].iter());\n                         let val = val.load_scalar(fx);\n                         return Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)));\n                     } else {\n@@ -137,24 +137,24 @@ pub(crate) fn maybe_codegen<'tcx>(\n             }\n \n             let truncated_rhs = clif_intcast(fx, rhs_val, types::I32, false);\n-            let truncated_rhs = CValue::by_val(truncated_rhs, fx.layout_of(fxcodegen_cx.tcx.types.u32));\n+            let truncated_rhs = CValue::by_val(truncated_rhs, fx.layout_of(fx.codegen_cx.tcx.types.u32));\n             let val = match (bin_op, is_signed) {\n                 (BinOp::Shl, false) => {\n-                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fxcodegen_cx.tcx.types.u128)\n+                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fx.codegen_cx.tcx.types.u128)\n                 }\n                 (BinOp::Shl, true) => {\n-                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fxcodegen_cx.tcx.types.i128)\n+                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fx.codegen_cx.tcx.types.i128)\n                 }\n                 (BinOp::Shr, false) => {\n-                    fx.easy_call(\"__lshrti3\", &[lhs, truncated_rhs], fxcodegen_cx.tcx.types.u128)\n+                    fx.easy_call(\"__lshrti3\", &[lhs, truncated_rhs], fx.codegen_cx.tcx.types.u128)\n                 }\n                 (BinOp::Shr, true) => {\n-                    fx.easy_call(\"__ashrti3\", &[lhs, truncated_rhs], fxcodegen_cx.tcx.types.i128)\n+                    fx.easy_call(\"__ashrti3\", &[lhs, truncated_rhs], fx.codegen_cx.tcx.types.i128)\n                 }\n                 (_, _) => unreachable!(),\n             };\n             if let Some(is_overflow) = is_overflow {\n-                let out_ty = fxcodegen_cx.tcx.mk_tup([lhs.layout().ty, fxcodegen_cx.tcx.types.bool].iter());\n+                let out_ty = fx.codegen_cx.tcx.mk_tup([lhs.layout().ty, fx.codegen_cx.tcx.types.bool].iter());\n                 let val = val.load_scalar(fx);\n                 Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)))\n             } else {"}, {"sha": "d959ddc2f4d416f21527376c5fdf35ea3c769f4a", "filename": "src/common.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -265,7 +265,7 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n }\n \n pub(crate) struct FunctionCx<'clif, 'tcx, B: Backend + 'static> {\n-    pub(crate) codegen_cx: &'clif CodegenCx<'tcx, B>,\n+    pub(crate) .codegen_cx: &'clif CodegenCx<'tcx, B>,\n     pub(crate) global_asm: &'clif mut String,\n     pub(crate) pointer_type: Type, // Cached from module\n \n@@ -299,11 +299,11 @@ impl<'tcx, B: Backend> LayoutOf for FunctionCx<'_, 'tcx, B> {\n \n     fn layout_of(&self, ty: Ty<'tcx>) -> TyAndLayout<'tcx> {\n         assert!(!ty.still_further_specializable());\n-        selfcodegen_cx.tcx\n+        self.codegen_cx.tcx\n             .layout_of(ParamEnv::reveal_all().and(&ty))\n             .unwrap_or_else(|e| {\n                 if let layout::LayoutError::SizeOverflow(_) = e {\n-                    selfcodegen_cx.tcx.sess.fatal(&e.to_string())\n+                    self.codegen_cx.tcx.sess.fatal(&e.to_string())\n                 } else {\n                     bug!(\"failed to get layout for `{}`: {}\", ty, e)\n                 }\n@@ -313,13 +313,13 @@ impl<'tcx, B: Backend> LayoutOf for FunctionCx<'_, 'tcx, B> {\n \n impl<'tcx, B: Backend + 'static> layout::HasTyCtxt<'tcx> for FunctionCx<'_, 'tcx, B> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n-        selfcodegen_cx.tcx\n+        self.codegen_cx.tcx\n     }\n }\n \n impl<'tcx, B: Backend + 'static> rustc_target::abi::HasDataLayout for FunctionCx<'_, 'tcx, B> {\n     fn data_layout(&self) -> &rustc_target::abi::TargetDataLayout {\n-        &selfcodegen_cx.tcx.data_layout\n+        &self.codegen_cx.tcx.data_layout\n     }\n }\n \n@@ -331,7 +331,7 @@ impl<'tcx, B: Backend + 'static> layout::HasParamEnv<'tcx> for FunctionCx<'_, 't\n \n impl<'tcx, B: Backend + 'static> HasTargetSpec for FunctionCx<'_, 'tcx, B> {\n     fn target_spec(&self) -> &Target {\n-        &selfcodegen_cx.tcx.sess.target.target\n+        &self.codegen_cx.tcx.sess.target.target\n     }\n }\n \n@@ -341,22 +341,22 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n         T: TypeFoldable<'tcx> + Copy,\n     {\n         if let Some(substs) = self.instance.substs_for_mir_body() {\n-            selfcodegen_cx.tcx.subst_and_normalize_erasing_regions(\n+            self.codegen_cx.tcx.subst_and_normalize_erasing_regions(\n                 substs,\n                 ty::ParamEnv::reveal_all(),\n                 value,\n             )\n         } else {\n-            selfcodegen_cx.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), *value)\n+            self.codegen_cx.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), *value)\n         }\n     }\n \n     pub(crate) fn clif_type(&self, ty: Ty<'tcx>) -> Option<Type> {\n-        clif_type_from_ty(selfcodegen_cx.tcx, ty)\n+        clif_type_from_ty(self.codegen_cx.tcx, ty)\n     }\n \n     pub(crate) fn clif_pair_type(&self, ty: Ty<'tcx>) -> Option<(Type, Type)> {\n-        clif_pair_type_from_ty(selfcodegen_cx.tcx, ty)\n+        clif_pair_type_from_ty(self.codegen_cx.tcx, ty)\n     }\n \n     pub(crate) fn get_block(&self, bb: BasicBlock) -> Block {\n@@ -381,21 +381,21 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n         }\n \n         let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n-        let caller = selfcodegen_cx.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n-        let const_loc = selfcodegen_cx.tcx.const_caller_location((\n+        let caller = self.codegen_cx.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n+        let const_loc = self.codegen_cx.tcx.const_caller_location((\n             rustc_span::symbol::Symbol::intern(&caller.file.name.to_string()),\n             caller.line as u32,\n             caller.col_display as u32 + 1,\n         ));\n         crate::constant::trans_const_value(\n             self,\n             const_loc,\n-            selfcodegen_cx.tcx.caller_location_ty(),\n+            self.codegen_cx.tcx.caller_location_ty(),\n         )\n     }\n \n     pub(crate) fn triple(&self) -> &target_lexicon::Triple {\n-        selfcodegen_cx.module.isa().triple()\n+        self.codegen_cx.module.isa().triple()\n     }\n \n     pub(crate) fn anonymous_str(&mut self, prefix: &str, msg: &str) -> Value {\n@@ -408,7 +408,7 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n         let mut data_ctx = DataContext::new();\n         data_ctx.define(msg.as_bytes().to_vec().into_boxed_slice());\n         let msg_id = self\n-            codegen_cx.module\n+            .codegen_cx.module\n             .declare_data(\n                 &format!(\"__{}_{:08x}\", prefix, msg_hash),\n                 Linkage::Local,\n@@ -419,9 +419,9 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n             .unwrap();\n \n         // Ignore DuplicateDefinition error, as the data will be the same\n-        let _ = selfcodegen_cx.module.define_data(msg_id, &data_ctx);\n+        let _ = self.codegen_cx.module.define_data(msg_id, &data_ctx);\n \n-        let local_msg_id = selfcodegen_cx.module.declare_data_in_func(msg_id, self.bcx.func);\n+        let local_msg_id = self.codegen_cx.module.declare_data_in_func(msg_id, self.bcx.func);\n         #[cfg(debug_assertions)]\n         {\n             self.add_comment(local_msg_id, msg);"}, {"sha": "2e0dd9d7edc06feca7d86a273a903b262e17d209", "filename": "src/constant.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -41,10 +41,10 @@ pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n         match const_.val {\n             ConstKind::Value(_) => {}\n             ConstKind::Unevaluated(def, ref substs, promoted) => {\n-                if let Err(err) = fxcodegen_cx.tcx.const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None) {\n+                if let Err(err) = fx.codegen_cx.tcx.const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None) {\n                     match err {\n                         ErrorHandled::Reported(ErrorReported) | ErrorHandled::Linted => {\n-                            fxcodegen_cx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n+                            fx.codegen_cx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n                         }\n                         ErrorHandled::TooGeneric => {\n                             span_bug!(constant.span, \"codgen encountered polymorphic constant: {:?}\", err);\n@@ -67,8 +67,8 @@ pub(crate) fn codegen_tls_ref<'tcx>(\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CValue<'tcx> {\n-    let data_id = data_id_for_static(fxcodegen_cx.tcx, fxcodegen_cx.module, def_id, false);\n-    let local_data_id = fxcodegen_cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let data_id = data_id_for_static(fx.codegen_cx.tcx, fx.codegen_cx.module, def_id, false);\n+    let local_data_id = fx.codegen_cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n     let tls_ptr = fx.bcx.ins().tls_value(fx.pointer_type, local_data_id);\n@@ -80,8 +80,8 @@ fn codegen_static_ref<'tcx>(\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CPlace<'tcx> {\n-    let data_id = data_id_for_static(fxcodegen_cx.tcx, fxcodegen_cx.module, def_id, false);\n-    let local_data_id = fxcodegen_cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let data_id = data_id_for_static(fx.codegen_cx.tcx, fx.codegen_cx.module, def_id, false);\n+    let local_data_id = fx.codegen_cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n@@ -97,7 +97,7 @@ pub(crate) fn trans_constant<'tcx>(\n     let const_ = fx.monomorphize(&constant.literal);\n     let const_val = match const_.val {\n         ConstKind::Value(const_val) => const_val,\n-        ConstKind::Unevaluated(def, ref substs, promoted) if fxcodegen_cx.tcx.is_static(def.did) => {\n+        ConstKind::Unevaluated(def, ref substs, promoted) if fx.codegen_cx.tcx.is_static(def.did) => {\n             assert!(substs.is_empty());\n             assert!(promoted.is_none());\n \n@@ -108,11 +108,11 @@ pub(crate) fn trans_constant<'tcx>(\n             ).to_cvalue(fx);\n         }\n         ConstKind::Unevaluated(def, ref substs, promoted) => {\n-            match fxcodegen_cx.tcx.const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None) {\n+            match fx.codegen_cx.tcx.const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None) {\n                 Ok(const_val) => const_val,\n                 Err(_) => {\n                     if promoted.is_none() {\n-                        fxcodegen_cx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n+                        fx.codegen_cx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n                     }\n                     return crate::trap::trap_unreachable_ret_value(\n                         fx,\n@@ -154,7 +154,7 @@ pub(crate) fn trans_const_value<'tcx>(\n                 );\n                 let ptr = Pointer::new(AllocId(!0), Size::ZERO); // The alloc id is never used\n                 alloc.write_scalar(fx, ptr, x.into(), size).unwrap();\n-                let alloc = fxcodegen_cx.tcx.intern_const_alloc(alloc);\n+                let alloc = fx.codegen_cx.tcx.intern_const_alloc(alloc);\n                 return CValue::by_ref(pointer_for_allocation(fx, alloc), layout);\n             }\n \n@@ -164,25 +164,25 @@ pub(crate) fn trans_const_value<'tcx>(\n                     return CValue::const_val(fx, layout, data);\n                 }\n                 Scalar::Ptr(ptr) => {\n-                    let alloc_kind = fxcodegen_cx.tcx.get_global_alloc(ptr.alloc_id);\n+                    let alloc_kind = fx.codegen_cx.tcx.get_global_alloc(ptr.alloc_id);\n                     let base_addr = match alloc_kind {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n-                            fxcodegen_cx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n-                            let data_id = data_id_for_alloc_id(fxcodegen_cx.module, ptr.alloc_id, alloc.align, alloc.mutability);\n-                            let local_data_id = fxcodegen_cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                            fx.codegen_cx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n+                            let data_id = data_id_for_alloc_id(fx.codegen_cx.module, ptr.alloc_id, alloc.align, alloc.mutability);\n+                            let local_data_id = fx.codegen_cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             #[cfg(debug_assertions)]\n                             fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                         }\n                         Some(GlobalAlloc::Function(instance)) => {\n-                            let func_id = crate::abi::import_function(fxcodegen_cx.tcx, fxcodegen_cx.module, instance);\n-                            let local_func_id = fxcodegen_cx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n+                            let func_id = crate::abi::import_function(fx.codegen_cx.tcx, fx.codegen_cx.module, instance);\n+                            let local_func_id = fx.codegen_cx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n                             fx.bcx.ins().func_addr(fx.pointer_type, local_func_id)\n                         }\n                         Some(GlobalAlloc::Static(def_id)) => {\n-                            assert!(fxcodegen_cx.tcx.is_static(def_id));\n-                            let data_id = data_id_for_static(fxcodegen_cx.tcx, fxcodegen_cx.module, def_id, false);\n-                            let local_data_id = fxcodegen_cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                            assert!(fx.codegen_cx.tcx.is_static(def_id));\n+                            let data_id = data_id_for_static(fx.codegen_cx.tcx, fx.codegen_cx.module, def_id, false);\n+                            let local_data_id = fx.codegen_cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             #[cfg(debug_assertions)]\n                             fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n@@ -215,11 +215,11 @@ fn pointer_for_allocation<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n     alloc: &'tcx Allocation,\n ) -> crate::pointer::Pointer {\n-    let alloc_id = fxcodegen_cx.tcx.create_memory_alloc(alloc);\n-    fxcodegen_cx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n-    let data_id = data_id_for_alloc_id(fxcodegen_cx.module, alloc_id, alloc.align, alloc.mutability);\n+    let alloc_id = fx.codegen_cx.tcx.create_memory_alloc(alloc);\n+    fx.codegen_cx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n+    let data_id = data_id_for_alloc_id(fx.codegen_cx.module, alloc_id, alloc.align, alloc.mutability);\n \n-    let local_data_id = fxcodegen_cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let local_data_id = fx.codegen_cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n@@ -419,7 +419,7 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n     match operand {\n         Operand::Copy(_) | Operand::Move(_) => None,\n         Operand::Constant(const_) => {\n-            Some(fx.monomorphize(&const_.literal).eval(fxcodegen_cx.tcx, ParamEnv::reveal_all()))\n+            Some(fx.monomorphize(&const_.literal).eval(fx.codegen_cx.tcx, ParamEnv::reveal_all()))\n         }\n     }\n }"}, {"sha": "6167fb8a56d102f46de4c02384571db41621821c", "filename": "src/debuginfo/line_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fline_info.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -95,7 +95,7 @@ fn line_program_add_file(\n \n impl<'tcx> DebugContext<'tcx> {\n     pub(super) fn emit_location(&mut self, entry_id: UnitEntryId, span: Span) {\n-        let loc = selfcodegen_cx.tcx.sess.source_map().lookup_char_pos(span.lo());\n+        let loc = self.codegen_cx.tcx.sess.source_map().lookup_char_pos(span.lo());\n \n         let file_id = line_program_add_file(\n             &mut self.dwarf.unit.line_program,\n@@ -129,7 +129,7 @@ impl<'tcx> DebugContext<'tcx> {\n         function_span: Span,\n         source_info_set: &indexmap::IndexSet<SourceInfo>,\n     ) -> CodeOffset {\n-        let tcx = selfcodegen_cx.tcx;\n+        let tcx = self.codegen_cx.tcx;\n         let line_program = &mut self.dwarf.unit.line_program;\n         let func = &context.func;\n "}, {"sha": "54d51e4d41af0301362c6d2207ca9dd9900ba2bc", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -165,7 +165,7 @@ impl<'tcx> DebugContext<'tcx> {\n         };\n \n         let name = format!(\"{}\", ty);\n-        let layout = selfcodegen_cx.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n+        let layout = self.codegen_cx.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n \n         let type_id = match ty.kind {\n             ty::Bool => primitive(&mut self.dwarf, gimli::DW_ATE_boolean),\n@@ -203,7 +203,7 @@ impl<'tcx> DebugContext<'tcx> {\n                 for (field_idx, field_def) in variant.fields.iter().enumerate() {\n                     let field_offset = layout.fields.offset(field_idx);\n                     let field_layout = layout.field(&layout::LayoutCx {\n-                        tcx: selfcodegen_cx.tcx,\n+                        tcx: self.codegen_cx.tcx,\n                         param_env: ParamEnv::reveal_all(),\n                     }, field_idx).unwrap();\n \n@@ -261,7 +261,7 @@ impl<'tcx> DebugContext<'tcx> {\n         local_map: FxHashMap<mir::Local, CPlace<'tcx>>,\n     ) {\n         let symbol = func_id.as_u32() as usize;\n-        let mir = selfcodegen_cx.tcx.instance_mir(instance.def);\n+        let mir = self.codegen_cx.tcx.instance_mir(instance.def);\n \n         // FIXME: add to appropriate scope instead of root\n         let scope = self.dwarf.unit.root();\n@@ -336,7 +336,7 @@ impl<'tcx> DebugContext<'tcx> {\n             let value_labels_ranges = context.build_value_labels_ranges(isa).unwrap();\n \n             for (local, _local_decl) in mir.local_decls.iter_enumerated() {\n-                let ty = selfcodegen_cx.tcx.subst_and_normalize_erasing_regions(\n+                let ty = self.codegen_cx.tcx.subst_and_normalize_erasing_regions(\n                     instance.substs,\n                     ty::ParamEnv::reveal_all(),\n                     &mir.local_decls[local].ty,"}, {"sha": "0c3686f4bb06650fbeee956840ed5ddd87788b94", "filename": "src/debuginfo/unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Funwind.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> UnwindContext<'tcx> {\n     }\n \n     pub(crate) fn emit<P: WriteDebugInfo>(self, product: &mut P) {\n-        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(selfcodegen_cx.tcx)));\n+        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.codegen_cx.tcx)));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if !eh_frame.0.writer.slice().is_empty() {\n@@ -74,7 +74,7 @@ impl<'tcx> UnwindContext<'tcx> {\n         self,\n         jit_module: &mut Module<cranelift_simplejit::SimpleJITBackend>,\n     ) -> Option<UnwindRegistry> {\n-        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(selfcodegen_cx.tcx)));\n+        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.codegen_cx.tcx)));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if eh_frame.0.writer.slice().is_empty() {"}, {"sha": "efe95322aae3b6294f188e2b374c0c22978e175c", "filename": "src/discriminant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiscriminant.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -26,7 +26,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n             let ptr = place.place_field(fx, mir::Field::new(tag_field));\n             let to = layout\n                 .ty\n-                .discriminant_for_variant(fxcodegen_cx.tcx, variant_index)\n+                .discriminant_for_variant(fx.codegen_cx.tcx, variant_index)\n                 .unwrap()\n                 .val;\n             let discr = CValue::const_val(fx, ptr.layout(), to);\n@@ -73,7 +73,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n         Variants::Single { index } => {\n             let discr_val = layout\n                 .ty\n-                .discriminant_for_variant(fxcodegen_cx.tcx, *index)\n+                .discriminant_for_variant(fx.codegen_cx.tcx, *index)\n                 .map_or(u128::from(index.as_u32()), |discr| discr.val);\n             return CValue::const_val(fx, dest_layout, discr_val);\n         }"}, {"sha": "81f0e874b3a02abfa7738d843526a041f962cab7", "filename": "src/driver/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fmod.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -33,14 +33,14 @@ fn codegen_mono_items<'tcx>(\n     cx: &mut crate::CodegenCx<'tcx, impl Backend + 'static>,\n     mono_items: Vec<(MonoItem<'tcx>, (RLinkage, Visibility))>,\n ) {\n-    cxcodegen_cx.tcx.sess.time(\"predefine functions\", || {\n+    cx.codegen_cx.tcx.sess.time(\"predefine functions\", || {\n         for &(mono_item, (linkage, visibility)) in &mono_items {\n             match mono_item {\n                 MonoItem::Fn(instance) => {\n                     let (name, sig) =\n-                        get_function_name_and_sig(cxcodegen_cx.tcx, cxcodegen_cx.module.isa().triple(), instance, false);\n+                        get_function_name_and_sig(cx.codegen_cx.tcx, cx.codegen_cx.module.isa().triple(), instance, false);\n                     let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n-                    cxcodegen_cx.module.declare_function(&name, linkage, &sig).unwrap();\n+                    cx.codegen_cx.module.declare_function(&name, linkage, &sig).unwrap();\n                 }\n                 MonoItem::Static(_) | MonoItem::GlobalAsm(_) => {}\n             }\n@@ -58,7 +58,7 @@ fn trans_mono_item<'tcx, B: Backend + 'static>(\n     mono_item: MonoItem<'tcx>,\n     linkage: Linkage,\n ) {\n-    let tcx = cxcodegen_cx.tcx;\n+    let tcx = cx.codegen_cx.tcx;\n     match mono_item {\n         MonoItem::Fn(inst) => {\n             let _inst_guard =\n@@ -85,10 +85,10 @@ fn trans_mono_item<'tcx, B: Backend + 'static>(\n                 }\n             });\n \n-            cxcodegen_cx.tcx.sess.time(\"codegen fn\", || crate::base::trans_fn(cx, inst, linkage));\n+            cx.codegen_cx.tcx.sess.time(\"codegen fn\", || crate::base::trans_fn(cx, inst, linkage));\n         }\n         MonoItem::Static(def_id) => {\n-            crate::constant::codegen_static(&mut cxcodegen_cx.constants_cx, def_id);\n+            crate::constant::codegen_static(&mut cx.codegen_cx.constants_cx, def_id);\n         }\n         MonoItem::GlobalAsm(hir_id) => {\n             let item = tcx.hir().expect_item(hir_id);"}, {"sha": "45ade1f7a0bfd558b125aa9e76c2308c875c6690", "filename": "src/inline_asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -70,7 +70,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n \n     let inline_asm_index = fx.inline_asm_index;\n     fx.inline_asm_index += 1;\n-    let asm_name = format!(\"{}__inline_asm_{}\", fxcodegen_cx.tcx.symbol_name(fx.instance).name, inline_asm_index);\n+    let asm_name = format!(\"{}__inline_asm_{}\", fx.codegen_cx.tcx.symbol_name(fx.instance).name, inline_asm_index);\n \n     let generated_asm = generate_asm_wrapper(&asm_name, InlineAsmArch::X86_64, options, template, clobbered_regs, &inputs, &outputs);\n     fx.global_asm.push_str(&generated_asm);\n@@ -169,12 +169,12 @@ fn call_inline_asm<'tcx>(\n     #[cfg(debug_assertions)]\n     fx.add_comment(stack_slot, \"inline asm scratch slot\");\n \n-    let inline_asm_func = fxcodegen_cx.module.declare_function(asm_name, Linkage::Import, &Signature {\n+    let inline_asm_func = fx.codegen_cx.module.declare_function(asm_name, Linkage::Import, &Signature {\n         call_conv: CallConv::SystemV,\n         params: vec![AbiParam::new(fx.pointer_type)],\n         returns: vec![],\n     }).unwrap();\n-    let inline_asm_func = fxcodegen_cx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n+    let inline_asm_func = fx.codegen_cx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(inline_asm_func, asm_name);\n "}, {"sha": "171eb51ccdff018d857795ec5d57a63cf7128418", "filename": "src/intrinsics/llvm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fllvm.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -30,13 +30,13 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n     intrinsic_match! {\n         fx, intrinsic, substs, args,\n         _ => {\n-            fxcodegen_cx.tcx.sess.warn(&format!(\"unsupported llvm intrinsic {}; replacing with trap\", intrinsic));\n+            fx.codegen_cx.tcx.sess.warn(&format!(\"unsupported llvm intrinsic {}; replacing with trap\", intrinsic));\n             crate::trap::trap_unimplemented(fx, intrinsic);\n         };\n \n         // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n         llvm.x86.sse2.pmovmskb.128 | llvm.x86.avx2.pmovmskb | llvm.x86.sse2.movmsk.pd, (c a) {\n-            let (lane_layout, lane_count) = lane_type_and_count(fxcodegen_cx.tcx, a.layout());\n+            let (lane_layout, lane_count) = lane_type_and_count(fx.codegen_cx.tcx, a.layout());\n             let lane_ty = fx.clif_type(lane_layout.ty).unwrap();\n             assert!(lane_count <= 32);\n \n@@ -61,7 +61,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n                 res = fx.bcx.ins().bor(res, a_lane_sign);\n             }\n \n-            let res = CValue::by_val(res, fx.layout_of(fxcodegen_cx.tcx.types.i32));\n+            let res = CValue::by_val(res, fx.layout_of(fx.codegen_cx.tcx.types.i32));\n             ret.write_cvalue(fx, res);\n         };\n         llvm.x86.sse2.cmp.ps | llvm.x86.sse2.cmp.pd, (c x, c y, o kind) {"}, {"sha": "f73e9f765c02d320da5dec297c950d93528178a4", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -88,7 +88,7 @@ macro call_intrinsic_match {\n                         let ($($arg,)*) = (\n                             $(trans_operand($fx, $arg),)*\n                         );\n-                        let res = $fx.easy_call(stringify!($func), &[$($arg),*], $fxcodegen_cx.tcx.types.$ty);\n+                        let res = $fx.easy_call(stringify!($func), &[$($arg),*], $fx.codegen_cx.tcx.types.$ty);\n                         $ret.write_cvalue($fx, res);\n \n                         if let Some((_, dest)) = $destination {\n@@ -144,7 +144,7 @@ macro validate_atomic_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n     match $ty.kind {\n         ty::Uint(_) | ty::Int(_) => {}\n         _ => {\n-            $fxcodegen_cx.tcx.sess.span_err($span, &format!(\"`{}` intrinsic: expected basic integer type, found `{:?}`\", $intrinsic, $ty));\n+            $fx.codegen_cx.tcx.sess.span_err($span, &format!(\"`{}` intrinsic: expected basic integer type, found `{:?}`\", $intrinsic, $ty));\n             // Prevent verifier error\n             crate::trap::trap_unreachable($fx, \"compilation should not have succeeded\");\n             return;\n@@ -154,7 +154,7 @@ macro validate_atomic_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n \n macro validate_simd_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n     if !$ty.is_simd() {\n-        $fxcodegen_cx.tcx.sess.span_err($span, &format!(\"invalid monomorphization of `{}` intrinsic: expected SIMD input type, found non-SIMD `{}`\", $intrinsic, $ty));\n+        $fx.codegen_cx.tcx.sess.span_err($span, &format!(\"invalid monomorphization of `{}` intrinsic: expected SIMD input type, found non-SIMD `{}`\", $intrinsic, $ty));\n         // Prevent verifier error\n         crate::trap::trap_unreachable($fx, \"compilation should not have succeeded\");\n         return;\n@@ -203,8 +203,8 @@ fn simd_for_each_lane<'tcx, B: Backend>(\n ) {\n     let layout = val.layout();\n \n-    let (lane_layout, lane_count) = lane_type_and_count(fxcodegen_cx.tcx, layout);\n-    let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fxcodegen_cx.tcx, ret.layout());\n+    let (lane_layout, lane_count) = lane_type_and_count(fx.codegen_cx.tcx, layout);\n+    let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.codegen_cx.tcx, ret.layout());\n     assert_eq!(lane_count, ret_lane_count);\n \n     for lane_idx in 0..lane_count {\n@@ -233,8 +233,8 @@ fn simd_pair_for_each_lane<'tcx, B: Backend>(\n     assert_eq!(x.layout(), y.layout());\n     let layout = x.layout();\n \n-    let (lane_layout, lane_count) = lane_type_and_count(fxcodegen_cx.tcx, layout);\n-    let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fxcodegen_cx.tcx, ret.layout());\n+    let (lane_layout, lane_count) = lane_type_and_count(fx.codegen_cx.tcx, layout);\n+    let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.codegen_cx.tcx, ret.layout());\n     assert_eq!(lane_count, ret_lane_count);\n \n     for lane in 0..lane_count {\n@@ -273,7 +273,7 @@ fn bool_to_zero_or_max_uint<'tcx>(\n \n macro simd_cmp {\n     ($fx:expr, $cc:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        let vector_ty = clif_vector_type($fxcodegen_cx.tcx, $x.layout());\n+        let vector_ty = clif_vector_type($fx.codegen_cx.tcx, $x.layout());\n \n         if let Some(vector_ty) = vector_ty {\n             let x = $x.load_scalar($fx);\n@@ -390,7 +390,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n-    let intrinsic = fxcodegen_cx.tcx.item_name(def_id).as_str();\n+    let intrinsic = fx.codegen_cx.tcx.item_name(def_id).as_str();\n     let intrinsic = &intrinsic[..];\n \n     let ret = match destination {\n@@ -423,7 +423,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         return;\n     }\n \n-    let usize_layout = fx.layout_of(fxcodegen_cx.tcx.types.usize);\n+    let usize_layout = fx.layout_of(fx.codegen_cx.tcx.types.usize);\n \n     call_intrinsic_match! {\n         fx, intrinsic, substs, ret, destination, args,\n@@ -473,7 +473,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n     intrinsic_match! {\n         fx, intrinsic, substs, args,\n         _ => {\n-            fxcodegen_cx.tcx.sess.span_fatal(span, &format!(\"unsupported intrinsic {}\", intrinsic));\n+            fx.codegen_cx.tcx.sess.span_fatal(span, &format!(\"unsupported intrinsic {}\", intrinsic));\n         };\n \n         assume, (c _a) {};\n@@ -494,10 +494,10 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n             if intrinsic.contains(\"nonoverlapping\") {\n                 // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fxcodegen_cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memcpy(fx.codegen_cx.module.target_config(), dst, src, byte_amount);\n             } else {\n                 // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fxcodegen_cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memmove(fx.codegen_cx.module.target_config(), dst, src, byte_amount);\n             }\n         };\n         // NOTE: the volatile variants have src and dst swapped\n@@ -513,10 +513,10 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             // FIXME make the copy actually volatile when using emit_small_mem{cpy,move}\n             if intrinsic.contains(\"nonoverlapping\") {\n                 // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fxcodegen_cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memcpy(fx.codegen_cx.module.target_config(), dst, src, byte_amount);\n             } else {\n                 // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fxcodegen_cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memmove(fx.codegen_cx.module.target_config(), dst, src, byte_amount);\n             }\n         };\n         discriminant_value, (c ptr) {\n@@ -680,11 +680,11 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let dst_ptr = dst.load_scalar(fx);\n             // FIXME make the memset actually volatile when switching to emit_small_memset\n             // FIXME use emit_small_memset\n-            fx.bcx.call_memset(fxcodegen_cx.module.target_config(), dst_ptr, val, count);\n+            fx.bcx.call_memset(fx.codegen_cx.module.target_config(), dst_ptr, val, count);\n         };\n         ctlz | ctlz_nonzero, <T> (v arg) {\n             // FIXME trap on `ctlz_nonzero` with zero arg.\n-            let res = if T == fxcodegen_cx.tcx.types.u128 || T == fxcodegen_cx.tcx.types.i128 {\n+            let res = if T == fx.codegen_cx.tcx.types.u128 || T == fx.codegen_cx.tcx.types.i128 {\n                 // FIXME verify this algorithm is correct\n                 let (lsb, msb) = fx.bcx.ins().isplit(arg);\n                 let lsb_lz = fx.bcx.ins().clz(lsb);\n@@ -701,7 +701,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         cttz | cttz_nonzero, <T> (v arg) {\n             // FIXME trap on `cttz_nonzero` with zero arg.\n-            let res = if T == fxcodegen_cx.tcx.types.u128 || T == fxcodegen_cx.tcx.types.i128 {\n+            let res = if T == fx.codegen_cx.tcx.types.u128 || T == fx.codegen_cx.tcx.types.i128 {\n                 // FIXME verify this algorithm is correct\n                 let (lsb, msb) = fx.bcx.ins().isplit(arg);\n                 let lsb_tz = fx.bcx.ins().ctz(lsb);\n@@ -842,7 +842,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n         size_of | pref_align_of | min_align_of | needs_drop | type_id | type_name | variant_count, () {\n             let const_val =\n-                fxcodegen_cx.tcx.const_eval_instance(ParamEnv::reveal_all(), instance, None).unwrap();\n+                fx.codegen_cx.tcx.const_eval_instance(ParamEnv::reveal_all(), instance, None).unwrap();\n             let val = crate::constant::trans_const_value(\n                 fx,\n                 const_val,\n@@ -852,7 +852,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n \n         ptr_offset_from, <T> (v ptr, v base) {\n-            let isize_layout = fx.layout_of(fxcodegen_cx.tcx.types.isize);\n+            let isize_layout = fx.layout_of(fx.codegen_cx.tcx.types.isize);\n \n             let pointee_size: u64 = fx.layout_of(T).size.bytes();\n             let diff = fx.bcx.ins().isub(ptr, base);\n@@ -1011,22 +1011,22 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n         minnumf32, (v a, v b) {\n             let val = fx.bcx.ins().fmin(a, b);\n-            let val = CValue::by_val(val, fx.layout_of(fxcodegen_cx.tcx.types.f32));\n+            let val = CValue::by_val(val, fx.layout_of(fx.codegen_cx.tcx.types.f32));\n             ret.write_cvalue(fx, val);\n         };\n         minnumf64, (v a, v b) {\n             let val = fx.bcx.ins().fmin(a, b);\n-            let val = CValue::by_val(val, fx.layout_of(fxcodegen_cx.tcx.types.f64));\n+            let val = CValue::by_val(val, fx.layout_of(fx.codegen_cx.tcx.types.f64));\n             ret.write_cvalue(fx, val);\n         };\n         maxnumf32, (v a, v b) {\n             let val = fx.bcx.ins().fmax(a, b);\n-            let val = CValue::by_val(val, fx.layout_of(fxcodegen_cx.tcx.types.f32));\n+            let val = CValue::by_val(val, fx.layout_of(fx.codegen_cx.tcx.types.f32));\n             ret.write_cvalue(fx, val);\n         };\n         maxnumf64, (v a, v b) {\n             let val = fx.bcx.ins().fmax(a, b);\n-            let val = CValue::by_val(val, fx.layout_of(fxcodegen_cx.tcx.types.f64));\n+            let val = CValue::by_val(val, fx.layout_of(fx.codegen_cx.tcx.types.f64));\n             ret.write_cvalue(fx, val);\n         };\n "}, {"sha": "bdda4bd9840343bfb09d3091fc771337ebf230b4", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -11,13 +11,13 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n-    let intrinsic = fxcodegen_cx.tcx.item_name(def_id).as_str();\n+    let intrinsic = fx.codegen_cx.tcx.item_name(def_id).as_str();\n     let intrinsic = &intrinsic[..];\n \n     intrinsic_match! {\n         fx, intrinsic, substs, args,\n         _ => {\n-            fxcodegen_cx.tcx.sess.span_fatal(span, &format!(\"Unknown SIMD intrinsic {}\", intrinsic));\n+            fx.codegen_cx.tcx.sess.span_fatal(span, &format!(\"Unknown SIMD intrinsic {}\", intrinsic));\n         };\n \n         simd_cast, (c a) {\n@@ -68,8 +68,8 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             assert_eq!(x.layout(), y.layout());\n             let layout = x.layout();\n \n-            let (lane_type, lane_count) = lane_type_and_count(fxcodegen_cx.tcx, layout);\n-            let (ret_lane_type, ret_lane_count) = lane_type_and_count(fxcodegen_cx.tcx, ret.layout());\n+            let (lane_type, lane_count) = lane_type_and_count(fx.codegen_cx.tcx, layout);\n+            let (ret_lane_type, ret_lane_count) = lane_type_and_count(fx.codegen_cx.tcx, ret.layout());\n \n             assert_eq!(lane_type, ret_lane_type);\n             assert_eq!(n, ret_lane_count);\n@@ -92,7 +92,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 (0..ret_lane_count).map(|i| {\n                     let i = usize::try_from(i).unwrap();\n                     let idx = rustc_middle::mir::interpret::read_target_uint(\n-                        fxcodegen_cx.tcx.data_layout.endian,\n+                        fx.codegen_cx.tcx.data_layout.endian,\n                         &idx_bytes[4*i.. 4*i + 4],\n                     ).expect(\"read_target_uint\");\n                     u16::try_from(idx).expect(\"try_from u32\")\n@@ -119,7 +119,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             let idx_const = if let Some(idx_const) = crate::constant::mir_operand_get_const_val(fx, idx) {\n                 idx_const\n             } else {\n-                fxcodegen_cx.tcx.sess.span_warn(\n+                fx.codegen_cx.tcx.sess.span_warn(\n                     fx.mir.span,\n                     \"`#[rustc_arg_required_const(..)]` is not yet supported. Calling this function will panic.\",\n                 );\n@@ -128,9 +128,9 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             };\n \n             let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).expect(&format!(\"kind not scalar: {:?}\", idx_const));\n-            let (_lane_type, lane_count) = lane_type_and_count(fxcodegen_cx.tcx, base.layout());\n+            let (_lane_type, lane_count) = lane_type_and_count(fx.codegen_cx.tcx, base.layout());\n             if idx >= lane_count.into() {\n-                fxcodegen_cx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_insert] idx {} >= lane_count {}\", idx, lane_count));\n+                fx.codegen_cx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_insert] idx {} >= lane_count {}\", idx, lane_count));\n             }\n \n             ret.write_cvalue(fx, base);\n@@ -143,7 +143,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             let idx_const = if let Some(idx_const) = crate::constant::mir_operand_get_const_val(fx, idx) {\n                 idx_const\n             } else {\n-                fxcodegen_cx.tcx.sess.span_warn(\n+                fx.codegen_cx.tcx.sess.span_warn(\n                     fx.mir.span,\n                     \"`#[rustc_arg_required_const(..)]` is not yet supported. Calling this function will panic.\",\n                 );\n@@ -153,9 +153,9 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             };\n \n             let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).expect(&format!(\"kind not scalar: {:?}\", idx_const));\n-            let (_lane_type, lane_count) = lane_type_and_count(fxcodegen_cx.tcx, v.layout());\n+            let (_lane_type, lane_count) = lane_type_and_count(fx.codegen_cx.tcx, v.layout());\n             if idx >= lane_count.into() {\n-                fxcodegen_cx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count));\n+                fx.codegen_cx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count));\n             }\n \n             let ret_lane = v.value_field(fx, mir::Field::new(idx.try_into().unwrap()));\n@@ -205,8 +205,8 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             assert_eq!(a.layout(), c.layout());\n             let layout = a.layout();\n \n-            let (_lane_layout, lane_count) = lane_type_and_count(fxcodegen_cx.tcx, layout);\n-            let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fxcodegen_cx.tcx, ret.layout());\n+            let (_lane_layout, lane_count) = lane_type_and_count(fx.codegen_cx.tcx, layout);\n+            let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.codegen_cx.tcx, ret.layout());\n             assert_eq!(lane_count, ret_lane_count);\n \n             for lane in 0..lane_count {"}, {"sha": "87e8936a53e17cfc2d3a880bb2e656ddda42213e", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -160,8 +160,8 @@ impl<'tcx, B: Backend + 'static> CodegenCx<'tcx, B> {\n     }\n \n     fn finalize(mut self) -> (Module<B>, String, Option<DebugContext<'tcx>>, UnwindContext<'tcx>) {\n-        selfcodegen_cx.constants_cx.finalize(selfcodegen_cx.tcx, &mut selfcodegen_cx.module);\n-        (selfcodegen_cx.module, self.global_asm, self.debug_context, self.unwind_context)\n+        self.codegen_cx.constants_cx.finalize(self.codegen_cx.tcx, &mut self.codegen_cx.module);\n+        (self.codegen_cx.module, self.global_asm, self.debug_context, self.unwind_context)\n     }\n }\n "}, {"sha": "06721e1af127c92e214da90904f860e351b11e7e", "filename": "src/num.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -48,7 +48,7 @@ fn codegen_compare_bin_op<'tcx>(\n     let intcc = crate::num::bin_op_to_intcc(bin_op, signed).unwrap();\n     let val = fx.bcx.ins().icmp(intcc, lhs, rhs);\n     let val = fx.bcx.ins().bint(types::I8, val);\n-    CValue::by_val(val, fx.layout_of(fxcodegen_cx.tcx.types.bool))\n+    CValue::by_val(val, fx.layout_of(fx.codegen_cx.tcx.types.bool))\n }\n \n pub(crate) fn codegen_binop<'tcx>(\n@@ -66,8 +66,8 @@ pub(crate) fn codegen_binop<'tcx>(\n                     let rhs = in_rhs.load_scalar(fx);\n \n                     let (lhs, rhs) = if (bin_op == BinOp::Eq || bin_op == BinOp::Ne)\n-                        && (in_lhs.layout().ty.kind == fxcodegen_cx.tcx.types.i8.kind\n-                            || in_lhs.layout().ty.kind == fxcodegen_cx.tcx.types.i16.kind)\n+                        && (in_lhs.layout().ty.kind == fx.codegen_cx.tcx.types.i8.kind\n+                            || in_lhs.layout().ty.kind == fx.codegen_cx.tcx.types.i16.kind)\n                     {\n                         // FIXME(CraneStation/cranelift#896) icmp_imm.i8/i16 with eq/ne for signed ints is implemented wrong.\n                         (\n@@ -118,7 +118,7 @@ pub(crate) fn trans_bool_binop<'tcx>(\n         _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs, in_rhs),\n     };\n \n-    CValue::by_val(res, fx.layout_of(fxcodegen_cx.tcx.types.bool))\n+    CValue::by_val(res, fx.layout_of(fx.codegen_cx.tcx.types.bool))\n }\n \n pub(crate) fn trans_int_binop<'tcx>(\n@@ -323,7 +323,7 @@ pub(crate) fn trans_checked_int_binop<'tcx>(\n     // FIXME directly write to result place instead\n     let out_place = CPlace::new_stack_slot(\n         fx,\n-        fx.layout_of(fxcodegen_cx.tcx.mk_tup([in_lhs.layout().ty, fxcodegen_cx.tcx.types.bool].iter())),\n+        fx.layout_of(fx.codegen_cx.tcx.mk_tup([in_lhs.layout().ty, fx.codegen_cx.tcx.types.bool].iter())),\n     );\n     let out_layout = out_place.layout();\n     out_place.write_cvalue(fx, CValue::by_val_pair(res, has_overflow, out_layout));\n@@ -368,7 +368,7 @@ pub(crate) fn trans_float_binop<'tcx>(\n             };\n             let val = fx.bcx.ins().fcmp(fltcc, lhs, rhs);\n             let val = fx.bcx.ins().bint(types::I8, val);\n-            return CValue::by_val(val, fx.layout_of(fxcodegen_cx.tcx.types.bool));\n+            return CValue::by_val(val, fx.layout_of(fx.codegen_cx.tcx.types.bool));\n         }\n         _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs, in_rhs),\n     };\n@@ -383,7 +383,7 @@ pub(crate) fn trans_ptr_binop<'tcx>(\n     in_rhs: CValue<'tcx>,\n ) -> CValue<'tcx> {\n     let is_thin_ptr = in_lhs.layout().ty.builtin_deref(true).map(|TypeAndMut { ty, mutbl: _}| {\n-        !has_ptr_meta(fxcodegen_cx.tcx, ty)\n+        !has_ptr_meta(fx.codegen_cx.tcx, ty)\n     }).unwrap_or(true);\n \n     if is_thin_ptr {\n@@ -440,7 +440,7 @@ pub(crate) fn trans_ptr_binop<'tcx>(\n \n         CValue::by_val(\n             fx.bcx.ins().bint(types::I8, res),\n-            fx.layout_of(fxcodegen_cx.tcx.types.bool),\n+            fx.layout_of(fx.codegen_cx.tcx.types.bool),\n         )\n     }\n }"}, {"sha": "d48bf6a4298c906514c90bf3e4795c923bdd35b6", "filename": "src/trap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftrap.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -2,24 +2,24 @@ use crate::prelude::*;\n \n fn codegen_print(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, msg: &str) {\n     let puts = fx\n-        codegen_cx.module\n+        .codegen_cx.module\n         .declare_function(\n             \"puts\",\n             Linkage::Import,\n             &Signature {\n                 call_conv: CallConv::triple_default(fx.triple()),\n-                params: vec![AbiParam::new(pointer_ty(fxcodegen_cx.tcx))],\n+                params: vec![AbiParam::new(pointer_ty(fx.codegen_cx.tcx))],\n                 returns: vec![AbiParam::new(types::I32)],\n             },\n         )\n         .unwrap();\n-    let puts = fxcodegen_cx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n+    let puts = fx.codegen_cx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     {\n         fx.add_comment(puts, \"puts\");\n     }\n \n-    let symbol_name = fxcodegen_cx.tcx.symbol_name(fx.instance);\n+    let symbol_name = fx.codegen_cx.tcx.symbol_name(fx.instance);\n     let real_msg = format!(\"trap at {:?} ({}): {}\\0\", fx.instance, symbol_name, msg);\n     let msg_ptr = fx.anonymous_str(\"trap\", &real_msg);\n     fx.bcx.ins().call(puts, &[msg_ptr]);"}, {"sha": "fec1bfd799f6a01f01a35e8f88cef81b3f3732fb", "filename": "src/unsize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsize.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -15,12 +15,12 @@ pub(crate) fn unsized_info<'tcx>(\n     old_info: Option<Value>,\n ) -> Value {\n     let (source, target) =\n-        fxcodegen_cx.tcx\n+        fx.codegen_cx.tcx\n             .struct_lockstep_tails_erasing_lifetimes(source, target, ParamEnv::reveal_all());\n     match (&source.kind, &target.kind) {\n         (&ty::Array(_, len), &ty::Slice(_)) => fx.bcx.ins().iconst(\n             fx.pointer_type,\n-            len.eval_usize(fxcodegen_cx.tcx, ParamEnv::reveal_all()) as i64,\n+            len.eval_usize(fx.codegen_cx.tcx, ParamEnv::reveal_all()) as i64,\n         ),\n         (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n             // For now, upcasts are limited to changes in marker"}, {"sha": "4483691013daf744b54a45f924273817a94d06b9", "filename": "src/value_and_place.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -35,10 +35,10 @@ fn codegen_field<'tcx>(\n                 let unaligned_offset = field_offset.bytes();\n                 let (_, unsized_align) = crate::unsize::size_and_align_of_dst(fx, field_layout, extra);\n \n-                let one = fx.bcx.ins().iconst(pointer_ty(fxcodegen_cx.tcx), 1);\n+                let one = fx.bcx.ins().iconst(pointer_ty(fx.codegen_cx.tcx), 1);\n                 let align_sub_1 = fx.bcx.ins().isub(unsized_align, one);\n                 let and_lhs = fx.bcx.ins().iadd_imm(align_sub_1, unaligned_offset as i64);\n-                let zero = fx.bcx.ins().iconst(pointer_ty(fxcodegen_cx.tcx), 0);\n+                let zero = fx.bcx.ins().iconst(pointer_ty(fx.codegen_cx.tcx), 0);\n                 let and_rhs = fx.bcx.ins().isub(zero, unsized_align);\n                 let offset = fx.bcx.ins().band(and_lhs, and_rhs);\n \n@@ -119,9 +119,9 @@ impl<'tcx> CValue<'tcx> {\n         match self.0 {\n             CValueInner::ByRef(ptr, None) => {\n                 let clif_ty = match layout.abi {\n-                    Abi::Scalar(ref scalar) => scalar_to_clif_type(fxcodegen_cx.tcx, scalar.clone()),\n+                    Abi::Scalar(ref scalar) => scalar_to_clif_type(fx.codegen_cx.tcx, scalar.clone()),\n                     Abi::Vector { ref element, count } => {\n-                        scalar_to_clif_type(fxcodegen_cx.tcx, element.clone())\n+                        scalar_to_clif_type(fx.codegen_cx.tcx, element.clone())\n                             .by(u16::try_from(count).unwrap()).unwrap()\n                     }\n                     _ => unreachable!(\"{:?}\", layout.ty),\n@@ -146,9 +146,9 @@ impl<'tcx> CValue<'tcx> {\n                     Abi::ScalarPair(a, b) => (a, b),\n                     _ => unreachable!(\"load_scalar_pair({:?})\", self),\n                 };\n-                let b_offset = scalar_pair_calculate_b_offset(fxcodegen_cx.tcx, a_scalar, b_scalar);\n-                let clif_ty1 = scalar_to_clif_type(fxcodegen_cx.tcx, a_scalar.clone());\n-                let clif_ty2 = scalar_to_clif_type(fxcodegen_cx.tcx, b_scalar.clone());\n+                let b_offset = scalar_pair_calculate_b_offset(fx.codegen_cx.tcx, a_scalar, b_scalar);\n+                let clif_ty1 = scalar_to_clif_type(fx.codegen_cx.tcx, a_scalar.clone());\n+                let clif_ty2 = scalar_to_clif_type(fx.codegen_cx.tcx, b_scalar.clone());\n                 let val1 = ptr.load(fx, clif_ty1, MemFlags::new());\n                 let val2 = ptr.offset(fx, b_offset).load(fx, clif_ty2, MemFlags::new());\n                 (val1, val2)\n@@ -419,13 +419,13 @@ impl<'tcx> CPlace<'tcx> {\n                     assert_assignable(fx, a, b);\n                 }\n                 (ty::FnPtr(_), ty::FnPtr(_)) => {\n-                    let from_sig = fxcodegen_cx.tcx.normalize_erasing_late_bound_regions(\n+                    let from_sig = fx.codegen_cx.tcx.normalize_erasing_late_bound_regions(\n                         ParamEnv::reveal_all(),\n-                        &from_ty.fn_sig(fxcodegen_cx.tcx),\n+                        &from_ty.fn_sig(fx.codegen_cx.tcx),\n                     );\n-                    let to_sig = fxcodegen_cx.tcx.normalize_erasing_late_bound_regions(\n+                    let to_sig = fx.codegen_cx.tcx.normalize_erasing_late_bound_regions(\n                         ParamEnv::reveal_all(),\n-                        &to_ty.fn_sig(fxcodegen_cx.tcx),\n+                        &to_ty.fn_sig(fx.codegen_cx.tcx),\n                     );\n                     assert_eq!(\n                         from_sig, to_sig,\n@@ -436,10 +436,10 @@ impl<'tcx> CPlace<'tcx> {\n                 }\n                 (ty::Dynamic(from_traits, _), ty::Dynamic(to_traits, _)) => {\n                     let from_traits = fx\n-                        codegen_cx.tcx\n+                        .codegen_cx.tcx\n                         .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from_traits);\n                     let to_traits = fx\n-                        codegen_cx.tcx\n+                        .codegen_cx.tcx\n                         .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to_traits);\n                     assert_eq!(\n                         from_traits, to_traits,\n@@ -569,7 +569,7 @@ impl<'tcx> CPlace<'tcx> {\n             }\n             Abi::ScalarPair(ref a_scalar, ref b_scalar) => {\n                 let (value, extra) = from.load_scalar_pair(fx);\n-                let b_offset = scalar_pair_calculate_b_offset(fxcodegen_cx.tcx, a_scalar, b_scalar);\n+                let b_offset = scalar_pair_calculate_b_offset(fx.codegen_cx.tcx, a_scalar, b_scalar);\n                 to_ptr.store(fx, value, MemFlags::new());\n                 to_ptr.offset(fx, b_offset).store(fx, extra, MemFlags::new());\n                 return;\n@@ -595,7 +595,7 @@ impl<'tcx> CPlace<'tcx> {\n                 let src_align = src_layout.align.abi.bytes() as u8;\n                 let dst_align = dst_layout.align.abi.bytes() as u8;\n                 fx.bcx.emit_small_memory_copy(\n-                    fxcodegen_cx.module.target_config(),\n+                    fx.codegen_cx.module.target_config(),\n                     to_addr,\n                     from_addr,\n                     size,\n@@ -673,7 +673,7 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn place_deref(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> CPlace<'tcx> {\n         let inner_layout = fx.layout_of(self.layout().ty.builtin_deref(true).unwrap().ty);\n-        if has_ptr_meta(fxcodegen_cx.tcx, inner_layout.ty) {\n+        if has_ptr_meta(fx.codegen_cx.tcx, inner_layout.ty) {\n             let (addr, extra) = self.to_cvalue(fx).load_scalar_pair(fx);\n             CPlace::for_ptr_with_extra(Pointer::new(addr), extra, inner_layout)\n         } else {\n@@ -682,7 +682,7 @@ impl<'tcx> CPlace<'tcx> {\n     }\n \n     pub(crate) fn write_place_ref(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>, dest: CPlace<'tcx>) {\n-        if has_ptr_meta(fxcodegen_cx.tcx, self.layout().ty) {\n+        if has_ptr_meta(fx.codegen_cx.tcx, self.layout().ty) {\n             let (ptr, extra) = self.to_ptr_maybe_unsized();\n             let ptr = CValue::by_val_pair(\n                 ptr.get_addr(fx),"}, {"sha": "6a179b3dfeb41ea53dfbbf56e3dca124e28cc28c", "filename": "src/vtable.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=ad4a7a1f0c87ecd0a520fce2078d1bcdb900f574", "patch": "@@ -13,29 +13,29 @@ fn vtable_memflags() -> MemFlags {\n }\n \n pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, impl Backend>, vtable: Value) -> Value {\n-    let usize_size = fx.layout_of(fxcodegen_cx.tcx.types.usize).size.bytes() as usize;\n+    let usize_size = fx.layout_of(fx.codegen_cx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n-        pointer_ty(fxcodegen_cx.tcx),\n+        pointer_ty(fx.codegen_cx.tcx),\n         vtable_memflags(),\n         vtable,\n         (DROP_FN_INDEX * usize_size) as i32,\n     )\n }\n \n pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, impl Backend>, vtable: Value) -> Value {\n-    let usize_size = fx.layout_of(fxcodegen_cx.tcx.types.usize).size.bytes() as usize;\n+    let usize_size = fx.layout_of(fx.codegen_cx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n-        pointer_ty(fxcodegen_cx.tcx),\n+        pointer_ty(fx.codegen_cx.tcx),\n         vtable_memflags(),\n         vtable,\n         (SIZE_INDEX * usize_size) as i32,\n     )\n }\n \n pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, impl Backend>, vtable: Value) -> Value {\n-    let usize_size = fx.layout_of(fxcodegen_cx.tcx.types.usize).size.bytes() as usize;\n+    let usize_size = fx.layout_of(fx.codegen_cx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n-        pointer_ty(fxcodegen_cx.tcx),\n+        pointer_ty(fx.codegen_cx.tcx),\n         vtable_memflags(),\n         vtable,\n         (ALIGN_INDEX * usize_size) as i32,\n@@ -57,9 +57,9 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n         )\n     };\n \n-    let usize_size = fx.layout_of(fxcodegen_cx.tcx.types.usize).size.bytes();\n+    let usize_size = fx.layout_of(fx.codegen_cx.tcx.types.usize).size.bytes();\n     let func_ref = fx.bcx.ins().load(\n-        pointer_ty(fxcodegen_cx.tcx),\n+        pointer_ty(fx.codegen_cx.tcx),\n         vtable_memflags(),\n         vtable,\n         ((idx + 3) * usize_size as usize) as i32,\n@@ -80,7 +80,7 @@ pub(crate) fn get_vtable<'tcx>(\n         data_id\n     };\n \n-    let local_data_id = fxcodegen_cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let local_data_id = fx.codegen_cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n }\n \n@@ -89,11 +89,11 @@ fn build_vtable<'tcx>(\n     layout: TyAndLayout<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> DataId {\n-    let tcx = fxcodegen_cx.tcx;\n-    let usize_size = fx.layout_of(fxcodegen_cx.tcx.types.usize).size.bytes() as usize;\n+    let tcx = fx.codegen_cx.tcx;\n+    let usize_size = fx.layout_of(fx.codegen_cx.tcx.types.usize).size.bytes() as usize;\n \n     let drop_in_place_fn =\n-        import_function(tcx, fxcodegen_cx.module, Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fxcodegen_cx.tcx));\n+        import_function(tcx, fx.codegen_cx.module, Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.codegen_cx.tcx));\n \n     let mut components: Vec<_> = vec![Some(drop_in_place_fn), None, None];\n \n@@ -108,8 +108,8 @@ fn build_vtable<'tcx>(\n         opt_mth.map_or(None, |(def_id, substs)| {\n             Some(import_function(\n                 tcx,\n-                fxcodegen_cx.module,\n-                Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs).unwrap().polymorphize(fxcodegen_cx.tcx),\n+                fx.codegen_cx.module,\n+                Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs).unwrap().polymorphize(fx.codegen_cx.tcx),\n             ))\n         })\n     });\n@@ -121,19 +121,19 @@ fn build_vtable<'tcx>(\n         .collect::<Vec<u8>>()\n         .into_boxed_slice();\n \n-    write_usize(fxcodegen_cx.tcx, &mut data, SIZE_INDEX, layout.size.bytes());\n-    write_usize(fxcodegen_cx.tcx, &mut data, ALIGN_INDEX, layout.align.abi.bytes());\n+    write_usize(fx.codegen_cx.tcx, &mut data, SIZE_INDEX, layout.size.bytes());\n+    write_usize(fx.codegen_cx.tcx, &mut data, ALIGN_INDEX, layout.align.abi.bytes());\n     data_ctx.define(data);\n \n     for (i, component) in components.into_iter().enumerate() {\n         if let Some(func_id) = component {\n-            let func_ref = fxcodegen_cx.module.declare_func_in_data(func_id, &mut data_ctx);\n+            let func_ref = fx.codegen_cx.module.declare_func_in_data(func_id, &mut data_ctx);\n             data_ctx.write_function_addr((i * usize_size) as u32, func_ref);\n         }\n     }\n \n     let data_id = fx\n-        codegen_cx.module\n+        .codegen_cx.module\n         .declare_data(\n             &format!(\n                 \"__vtable.{}.for.{:?}.{}\",\n@@ -148,7 +148,7 @@ fn build_vtable<'tcx>(\n             false,\n             false,\n             Some(\n-                fxcodegen_cx.tcx\n+                fx.codegen_cx.tcx\n                     .data_layout\n                     .pointer_align\n                     .pref\n@@ -159,7 +159,7 @@ fn build_vtable<'tcx>(\n         )\n         .unwrap();\n \n-    fxcodegen_cx.module.define_data(data_id, &data_ctx).unwrap();\n+    fx.codegen_cx.module.define_data(data_id, &data_ctx).unwrap();\n \n     data_id\n }"}]}