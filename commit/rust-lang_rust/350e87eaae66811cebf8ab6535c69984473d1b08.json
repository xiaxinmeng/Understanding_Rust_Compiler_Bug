{"sha": "350e87eaae66811cebf8ab6535c69984473d1b08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1MGU4N2VhYWU2NjgxMWNlYmY4YWI2NTM1YzY5OTg0NDczZDFiMDg=", "commit": {"author": {"name": "Roland Tanglao", "email": "roland@rolandtanglao.com", "date": "2012-01-11T06:44:31Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-12T06:37:25Z"}, "message": "Change doc comments to rustdoc in bool.rs", "tree": {"sha": "3d3dfac7482a130825623d07d9db56365267085b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d3dfac7482a130825623d07d9db56365267085b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/350e87eaae66811cebf8ab6535c69984473d1b08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/350e87eaae66811cebf8ab6535c69984473d1b08", "html_url": "https://github.com/rust-lang/rust/commit/350e87eaae66811cebf8ab6535c69984473d1b08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/350e87eaae66811cebf8ab6535c69984473d1b08/comments", "author": {"login": "rtanglao", "id": 45195, "node_id": "MDQ6VXNlcjQ1MTk1", "avatar_url": "https://avatars.githubusercontent.com/u/45195?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rtanglao", "html_url": "https://github.com/rtanglao", "followers_url": "https://api.github.com/users/rtanglao/followers", "following_url": "https://api.github.com/users/rtanglao/following{/other_user}", "gists_url": "https://api.github.com/users/rtanglao/gists{/gist_id}", "starred_url": "https://api.github.com/users/rtanglao/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rtanglao/subscriptions", "organizations_url": "https://api.github.com/users/rtanglao/orgs", "repos_url": "https://api.github.com/users/rtanglao/repos", "events_url": "https://api.github.com/users/rtanglao/events{/privacy}", "received_events_url": "https://api.github.com/users/rtanglao/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c70b2fb7ee33c663cc96c420daaa74b951b3af9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c70b2fb7ee33c663cc96c420daaa74b951b3af9", "html_url": "https://github.com/rust-lang/rust/commit/2c70b2fb7ee33c663cc96c420daaa74b951b3af9"}], "stats": {"total": 156, "additions": 73, "deletions": 83}, "files": [{"sha": "5810cdc93a969ba5f76ec6a7b3b5dc33d27296d4", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 73, "deletions": 83, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/350e87eaae66811cebf8ab6535c69984473d1b08/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350e87eaae66811cebf8ab6535c69984473d1b08/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=350e87eaae66811cebf8ab6535c69984473d1b08", "patch": "@@ -1,128 +1,118 @@\n // -*- rust -*-\n \n-/*\n-Module: bool\n-\n-Classic Boolean logic reified as ADT\n-*/\n+#[doc = \"Classic Boolean logic reified as ADT\"];\n \n export t;\n export not, and, or, xor, implies;\n export eq, ne, is_true, is_false;\n export from_str, to_str, all_values, to_bit;\n \n-/*\n-Type: t\n-\n-The type of boolean logic values\n-*/\n+#[doc = \"The type of boolean logic values\"]\n type t = bool;\n \n-/* Function: not\n-\n-Negation/Inverse\n-*/\n+#[doc(\n+  brief = \"Negation/Inverse\",\n+  args(v = \"Value to Negate/Invert\"),\n+  return = \"Negated/Inverted Value\"\n+)]\n pure fn not(v: t) -> t { !v }\n \n-/* Function: and\n-\n-Conjunction\n-*/\n+#[doc(\n+  brief = \"Conjunction\",\n+  args(a = \"value `a`\",\n+       b = \"value `b`\"),\n+  return = \"`a` AND `b`\"\n+)]\n pure fn and(a: t, b: t) -> t { a && b }\n \n-/* Function: or\n-\n-Disjunction\n-*/\n+#[doc(\n+  brief = \"Disjunction\",\n+  args(a = \"value `a`\",\n+       b = \"value `b`\"),\n+  return = \"`a` OR `b`\"\n+)]\n pure fn or(a: t, b: t) -> t { a || b }\n \n-/*\n-Function: xor\n-\n-Exclusive or, i.e. `or(and(a, not(b)), and(not(a), b))`\n-*/\n+#[doc(\n+  brief = \"Exclusive or, i.e. `or(and(a, not(b)), and(not(a), b))`\",\n+  args(a = \"value `a`\",\n+       b = \"value `b`\"),\n+  return = \"`a` XOR `b`\"\n+)]\n pure fn xor(a: t, b: t) -> t { (a && !b) || (!a && b) }\n \n-/*\n-Function: implies\n-\n-Implication in the logic, i.e. from `a` follows `b`\n-*/\n+#[doc(\n+  brief = \"Implication in the logic, i.e. from `a` follows `b`\",\n+  args(a = \"value `a`\",\n+       b = \"value `b`\"),\n+  return = \"`a` IMPLIES `b`\"\n+)]\n pure fn implies(a: t, b: t) -> t { !a || b }\n \n-/*\n-Predicate: eq\n-\n-Returns:\n-\n-true if truth values `a` and `b` are indistinguishable in the logic\n-*/\n+#[doc(\n+  brief = \"true if truth values `a` and `b` are indistinguishable in the logic\",\n+  args(a = \"value `a`\",\n+       b = \"value `b`\"),\n+  return = \"`a` == `b`\"\n+)]\n pure fn eq(a: t, b: t) -> bool { a == b }\n \n-/*\n-Predicate: ne\n-\n-Returns:\n-\n-true if truth values `a` and `b` are distinguishable in the logic\n-*/\n+#[doc(\n+  brief = \"true if truth values `a` and `b` are distinguishable in the logic\",\n+  args(a = \"value `a`\",\n+       b = \"value `b`\"),\n+  return = \"`a` != `b`\"\n+)]\n pure fn ne(a: t, b: t) -> bool { a != b }\n \n-/*\n-Predicate: is_true\n-\n-Returns:\n-\n-true if `v` represents truth in the logic\n-*/\n+#[doc(\n+  brief = \"true if `v` represents truth in the logic\",\n+  args(v = \"value `v`\"),\n+  return = \"bool(`v`)\"\n+)]\n pure fn is_true(v: t) -> bool { v }\n \n-/*\n-Predicate: is_false\n-\n-Returns:\n-\n-true if `v` represents falsehood in the logic\n-*/\n+#[doc(\n+  brief = \"true if `v` represents falsehood in the logic\",\n+  args(v = \"value `v`\"),\n+  return = \"bool(!`v`)\"\n+)]\n pure fn is_false(v: t) -> bool { !v }\n \n-/*\n-Function: from_str\n-\n-Parse logic value from `s`\n-*/\n+#[doc(\n+  brief = \"Parse logic value from `s`\",\n+  args(v = \"string value `s`\"),\n+  return = \"true if `s` equals \\\"true\\\", else false\"\n+)]\n pure fn from_str(s: str) -> t {\n     alt s {\n       \"true\" { true }\n       \"false\" { false }\n     }\n }\n \n-/*\n-Function: to_str\n-\n-Convert `v` into a string\n-*/\n+#[doc(\n+  brief = \"Convert `v` into a string\",\n+  args(v = \"truth value `v`\"),\n+  return = \"\\\"true\\\" if value `v` is true, else \\\"false\\\"\"\n+)]\n pure fn to_str(v: t) -> str { if v { \"true\" } else { \"false\" } }\n \n-/*\n-Function: all_values\n-\n-Iterates over all truth values by passing them to `blk`\n-in an unspecified order\n-*/\n+#[doc(\n+  brief = \"Iterates over all truth values by passing them to `blk` in an unspecified order\",\n+  args(v = \"block value `v`\"),\n+  return = \"Undefined return value\"\n+)]\n fn all_values(blk: block(v: t)) {\n     blk(true);\n     blk(false);\n }\n \n-/*\n-Function: to_bit\n-\n-Returns:\n-\n-An u8 whose first bit is set if `if_true(v)` holds\n-*/\n+#[doc(\n+  brief = \"converts truth value to an 8 bit byte\",\n+  args(v = \"value `v`\"),\n+  return = \"returns byte with value 1 if `v` has truth value of true, else 0\"\n+)]\n pure fn to_bit(v: t) -> u8 { if v { 1u8 } else { 0u8 } }\n \n // Local Variables:"}]}