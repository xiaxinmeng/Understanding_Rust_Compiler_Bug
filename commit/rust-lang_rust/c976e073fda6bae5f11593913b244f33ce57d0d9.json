{"sha": "c976e073fda6bae5f11593913b244f33ce57d0d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NzZlMDczZmRhNmJhZTVmMTE1OTM5MTNiMjQ0ZjMzY2U1N2QwZDk=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-07-01T16:32:53Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-12T03:43:34Z"}, "message": "rustc: don't reveal specializable polymorphic projections.", "tree": {"sha": "bbe778e375d42cb6f3b7508c4ba5a46ae44f81e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbe778e375d42cb6f3b7508c4ba5a46ae44f81e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c976e073fda6bae5f11593913b244f33ce57d0d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c976e073fda6bae5f11593913b244f33ce57d0d9", "html_url": "https://github.com/rust-lang/rust/commit/c976e073fda6bae5f11593913b244f33ce57d0d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c976e073fda6bae5f11593913b244f33ce57d0d9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab26dbb96f12af96877832e34973641747bd6db1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab26dbb96f12af96877832e34973641747bd6db1", "html_url": "https://github.com/rust-lang/rust/commit/ab26dbb96f12af96877832e34973641747bd6db1"}], "stats": {"total": 83, "additions": 48, "deletions": 35}, "files": [{"sha": "b93693cd756ce7f2337c3649d089e4181107a566", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c976e073fda6bae5f11593913b244f33ce57d0d9/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c976e073fda6bae5f11593913b244f33ce57d0d9/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=c976e073fda6bae5f11593913b244f33ce57d0d9", "patch": "@@ -93,7 +93,7 @@ pub enum Reveal {\n     /// }\n     NotSpecializable,\n \n-    /// At trans time, all projections will succeed.\n+    /// At trans time, all monomorphic projections will succeed.\n     All,\n }\n \n@@ -878,7 +878,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n \n                 candidate_set.vec.push(ProjectionTyCandidate::Select);\n             }\n-            super::VtableImpl(ref impl_data) if selcx.projection_mode() != Reveal::All => {\n+            super::VtableImpl(ref impl_data) => {\n                 // We have to be careful when projecting out of an\n                 // impl because of specialization. If we are not in\n                 // trans (i.e., projection mode is not \"any\"), and the\n@@ -902,37 +902,43 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                                                  impl_data.impl_def_id,\n                                                  obligation.predicate.item_name);\n                 let new_candidate = if let Some(node_item) = opt_node_item {\n-                    if node_item.node.is_from_trait() {\n-                        if node_item.item.ty.is_some() {\n-                            // The impl inherited a `type Foo =\n-                            // Bar` given in the trait, which is\n-                            // implicitly default. No candidate.\n-                            None\n-                        } else {\n-                            // The impl did not specify `type` and neither\n-                            // did the trait:\n-                            //\n-                            // ```rust\n-                            // trait Foo { type T; }\n-                            // impl Foo for Bar { }\n-                            // ```\n-                            //\n-                            // This is an error, but it will be\n-                            // reported in `check_impl_items_against_trait`.\n-                            // We accept it here but will flag it as\n-                            // an error when we confirm the candidate\n-                            // (which will ultimately lead to `normalize_to_error`\n-                            // being invoked).\n+                    let is_default = if node_item.node.is_from_trait() {\n+                        // If true, the impl inherited a `type Foo = Bar`\n+                        // given in the trait, which is implicitly default.\n+                        // Otherwise, the impl did not specify `type` and\n+                        // neither did the trait:\n+                        //\n+                        // ```rust\n+                        // trait Foo { type T; }\n+                        // impl Foo for Bar { }\n+                        // ```\n+                        //\n+                        // This is an error, but it will be\n+                        // reported in `check_impl_items_against_trait`.\n+                        // We accept it here but will flag it as\n+                        // an error when we confirm the candidate\n+                        // (which will ultimately lead to `normalize_to_error`\n+                        // being invoked).\n+                        node_item.item.ty.is_some()\n+                    } else {\n+                        node_item.item.defaultness.is_default()\n+                    };\n+\n+                    // Only reveal a specializable default if we're past type-checking\n+                    // and the obligations is monomorphic, otherwise passes such as\n+                    // transmute checking and polymorphic MIR optimizations could\n+                    // get a result which isn't correct for all monomorphizations.\n+                    if !is_default {\n+                        Some(ProjectionTyCandidate::Select)\n+                    } else if selcx.projection_mode() == Reveal::All {\n+                        assert!(!poly_trait_ref.needs_infer());\n+                        if !poly_trait_ref.needs_subst() {\n                             Some(ProjectionTyCandidate::Select)\n+                        } else {\n+                            None\n                         }\n-                    } else if node_item.item.defaultness.is_default() {\n-                        // The impl specified `default type Foo =\n-                        // Bar`. No candidate.\n-                        None\n                     } else {\n-                        // The impl specified `type Foo = Bar`\n-                        // with no default. Add a candidate.\n-                        Some(ProjectionTyCandidate::Select)\n+                        None\n                     }\n                 } else {\n                     // This is saying that neither the trait nor\n@@ -982,11 +988,6 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                 };\n                 candidate_set.vec.extend(new_candidate);\n             }\n-            super::VtableImpl(_) => {\n-                // In trans mode, we can just project out of impls, no prob.\n-                assert!(selcx.projection_mode() == Reveal::All);\n-                candidate_set.vec.push(ProjectionTyCandidate::Select);\n-            }\n             super::VtableParam(..) => {\n                 // This case tell us nothing about the value of an\n                 // associated type. Consider:"}, {"sha": "5fab271efce64cb72905e943b8b029531b75dff3", "filename": "src/test/compile-fail/transmute-different-sizes.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c976e073fda6bae5f11593913b244f33ce57d0d9/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c976e073fda6bae5f11593913b244f33ce57d0d9/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs?ref=c976e073fda6bae5f11593913b244f33ce57d0d9", "patch": "@@ -11,6 +11,7 @@\n // Tests that `transmute` cannot be called on types of different size.\n \n #![allow(warnings)]\n+#![feature(specialization)]\n \n use std::mem::transmute;\n \n@@ -24,4 +25,15 @@ unsafe fn g<T>(x: &T) {\n     //~^ ERROR transmute called with differently sized types\n }\n \n+trait Specializable { type Output; }\n+\n+impl<T> Specializable for T {\n+    default type Output = u16;\n+}\n+\n+unsafe fn specializable<T>(x: u16) -> <T as Specializable>::Output {\n+    transmute(x)\n+    //~^ ERROR transmute called with differently sized types\n+}\n+\n fn main() {}"}]}