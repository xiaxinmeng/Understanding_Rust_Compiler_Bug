{"sha": "92c97059ff6fe728d47d7fd2c06a658fd12957d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYzk3MDU5ZmY2ZmU3MjhkNDdkN2ZkMmMwNmE2NThmZDEyOTU3ZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-25T23:01:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-25T23:01:16Z"}, "message": "auto merge of #15787 : treeman/rust/hashmap-doc, r=alexcrichton\n\nAdd an example showing how to use the map with a custom type. Fill in\r\nexamples for methods  without ones.\r\n\r\nAlso move `pop_equiv` next to related public methods, to not create a\r\nduplicate trait in the docs.", "tree": {"sha": "df458acd21ab034e044266356fb7c4f8dd8e3562", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df458acd21ab034e044266356fb7c4f8dd8e3562"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92c97059ff6fe728d47d7fd2c06a658fd12957d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92c97059ff6fe728d47d7fd2c06a658fd12957d0", "html_url": "https://github.com/rust-lang/rust/commit/92c97059ff6fe728d47d7fd2c06a658fd12957d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92c97059ff6fe728d47d7fd2c06a658fd12957d0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66a0b528a6601d060095655f31c7d38e2a841511", "url": "https://api.github.com/repos/rust-lang/rust/commits/66a0b528a6601d060095655f31c7d38e2a841511", "html_url": "https://github.com/rust-lang/rust/commit/66a0b528a6601d060095655f31c7d38e2a841511"}, {"sha": "c4ce4c8f9b9855dc48ac90eb9df4803ba1c72f80", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4ce4c8f9b9855dc48ac90eb9df4803ba1c72f80", "html_url": "https://github.com/rust-lang/rust/commit/c4ce4c8f9b9855dc48ac90eb9df4803ba1c72f80"}], "stats": {"total": 385, "additions": 337, "deletions": 48}, "files": [{"sha": "e825dc3a8b5fd2a95d66e8e4cc955d885059aa4e", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 337, "deletions": 48, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/92c97059ff6fe728d47d7fd2c06a658fd12957d0/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92c97059ff6fe728d47d7fd2c06a658fd12957d0/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=92c97059ff6fe728d47d7fd2c06a658fd12957d0", "patch": "@@ -693,7 +693,7 @@ impl DefaultResizePolicy {\n ///\n /// # Example\n ///\n-/// ```rust\n+/// ```\n /// use std::collections::HashMap;\n ///\n /// // type inference lets us omit an explicit type signature (which\n@@ -729,6 +729,30 @@ impl DefaultResizePolicy {\n ///     println!(\"{}: \\\"{}\\\"\", *book, *review);\n /// }\n /// ```\n+///\n+/// The easiest way to use `HashMap` with a custom type is to derive `Eq` and `Hash`.\n+/// We must also derive `PartialEq`.\n+///\n+/// ```\n+/// use std::collections::HashMap;\n+///\n+/// #[deriving(Hash, Eq, PartialEq, Show)]\n+/// struct Viking<'a> {\n+///     name: &'a str,\n+///     power: uint,\n+/// }\n+///\n+/// let mut vikings = HashMap::new();\n+///\n+/// vikings.insert(\"Norway\", Viking { name: \"Einar\", power: 9u });\n+/// vikings.insert(\"Denmark\", Viking { name: \"Olaf\", power: 4u });\n+/// vikings.insert(\"Iceland\", Viking { name: \"Harald\", power: 8u });\n+///\n+/// // Use derived implementation to print the vikings.\n+/// for (land, viking) in vikings.iter() {\n+///     println!(\"{} at {}\", viking, land);\n+/// }\n+/// ```\n #[deriving(Clone)]\n pub struct HashMap<K, V, H = RandomSipHasher> {\n     // All hashes are keyed on these values, to prevent hash collision attacks.\n@@ -906,28 +930,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         // earlier.\n         return Some(retval);\n     }\n-\n-    /// Like `pop`, but can operate on any type that is equivalent to a key.\n-    #[experimental]\n-    pub fn pop_equiv<Q:Hash<S> + Equiv<K>>(&mut self, k: &Q) -> Option<V> {\n-        if self.table.size() == 0 {\n-            return None\n-        }\n-\n-        let potential_new_size = self.table.size() - 1;\n-        self.make_some_room(potential_new_size);\n-\n-        let starting_index = match self.search_equiv(k) {\n-            Some(idx) => idx,\n-            None      => return None,\n-        };\n-\n-        self.pop_internal(starting_index)\n-    }\n }\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Collection for HashMap<K, V, H> {\n-    /// Return the number of elements in the map\n+    /// Return the number of elements in the map.\n     fn len(&self) -> uint { self.table.size() }\n }\n \n@@ -1032,12 +1038,26 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H>\n \n impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     /// Create an empty HashMap.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// let mut map: HashMap<&str, int> = HashMap::new();\n+    /// ```\n     #[inline]\n     pub fn new() -> HashMap<K, V, RandomSipHasher> {\n         HashMap::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Creates an empty hash map with the given initial capacity.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n+    /// ```\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomSipHasher> {\n         let hasher = RandomSipHasher::new();\n@@ -1049,6 +1069,17 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Creates an empty hashmap which will use the given hasher to hash keys.\n     ///\n     /// The creates map has the default initial capacity.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::hash::sip::SipHasher;\n+    ///\n+    /// let h = SipHasher::new();\n+    /// let mut map = HashMap::with_hasher(h);\n+    /// map.insert(1i, 2u);\n+    /// ```\n     #[inline]\n     pub fn with_hasher(hasher: H) -> HashMap<K, V, H> {\n         HashMap::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n@@ -1061,6 +1092,17 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// is designed to allow HashMaps to be resistant to attacks that\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::hash::sip::SipHasher;\n+    ///\n+    /// let h = SipHasher::new();\n+    /// let mut map = HashMap::with_capacity_and_hasher(10, h);\n+    /// map.insert(1i, 2u);\n+    /// ```\n     #[inline]\n     pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashMap<K, V, H> {\n         let cap = num::next_power_of_two(max(INITIAL_CAPACITY, capacity));\n@@ -1077,6 +1119,12 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// This function has no effect on the operational semantics of the\n     /// hashtable, only on performance.\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// let mut map: HashMap<&str, int> = HashMap::new();\n+    /// map.reserve(10);\n+    /// ```\n     pub fn reserve(&mut self, new_minimum_capacity: uint) {\n         let cap = num::next_power_of_two(\n             max(INITIAL_CAPACITY, new_minimum_capacity));\n@@ -1241,12 +1289,38 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// // Insert 1i with key \"a\"\n+    /// assert_eq!(*map.find_or_insert(\"a\", 1i), 1);\n+    ///\n+    /// // Find the existing key\n+    /// assert_eq!(*map.find_or_insert(\"a\", -2), 1);\n+    /// ```\n     pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V {\n         self.find_with_or_insert_with(k, v, |_k, _v, _a| (), |_k, a| a)\n     }\n \n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// // Insert 10 with key 2\n+    /// assert_eq!(*map.find_or_insert_with(2i, |&key| 5 * key as uint), 10u);\n+    ///\n+    /// // Find the existing key\n+    /// assert_eq!(*map.find_or_insert_with(2, |&key| key as uint), 10);\n+    /// ```\n     pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)\n                                -> &'a mut V {\n         self.find_with_or_insert_with(k, (), |_k, _v, _a| (), |k, _a| f(k))\n@@ -1255,6 +1329,20 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Insert a key-value pair into the map if the key is not already present.\n     /// Otherwise, modify the existing value for the key.\n     /// Returns the new or modified value for the key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// // Insert 2 with key \"a\"\n+    /// assert_eq!(*map.insert_or_update_with(\"a\", 2u, |_key, val| *val = 3), 2);\n+    ///\n+    /// // Update and return the existing value\n+    /// assert_eq!(*map.insert_or_update_with(\"a\", 9, |_key, val| *val = 7), 7);\n+    /// assert_eq!(map.get(&\"a\"), &7);\n+    /// ```\n     pub fn insert_or_update_with<'a>(\n                                  &'a mut self,\n                                  k: K,\n@@ -1268,13 +1356,15 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// insert and return a new value if it doesn't exist.\n     ///\n     /// This method allows for all insertion behaviours of a hashmap;\n-    /// see methods like `insert`, `find_or_insert` and\n-    /// `insert_or_update_with` for less general and more friendly\n-    /// variations of this.\n+    /// see methods like\n+    /// [`insert`](../trait.MutableMap.html#tymethod.insert),\n+    /// [`find_or_insert`](#method.find_or_insert) and\n+    /// [`insert_or_update_with`](#method.insert_or_update_with)\n+    /// for less general and more friendly variations of this.\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::HashMap;\n     ///\n     /// // map some strings to vectors of strings\n@@ -1326,15 +1416,54 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Retrieves a value for the given key, failing if the key is not present.\n+    /// Retrieves a value for the given key.\n+    /// See [`find`](../trait.Map.html#tymethod.find) for a non-failing alternative.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the key is not present.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// assert_eq!(map.get(&\"a\"), &1);\n+    /// ```\n     pub fn get<'a>(&'a self, k: &K) -> &'a V {\n         match self.find(k) {\n             Some(v) => v,\n             None => fail!(\"no entry found for key\")\n         }\n     }\n \n-    /// Retrieves a (mutable) value for the given key, failing if the key is not present.\n+    /// Retrieves a mutable value for the given key.\n+    /// See [`find_mut`](../trait.MutableMap.html#tymethod.find_mut) for a non-failing alternative.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the key is not present.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// {\n+    ///     // val will freeze map to prevent usage during its lifetime\n+    ///     let val = map.get_mut(&\"a\");\n+    ///     *val = 40;\n+    /// }\n+    /// assert_eq!(map.get(&\"a\"), &40);\n+    ///\n+    /// // A more direct way could be:\n+    /// *map.get_mut(&\"a\") = -2;\n+    /// assert_eq!(map.get(&\"a\"), &-2);\n+    /// ```\n     pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V {\n         match self.find_mut(k) {\n             Some(v) => v,\n@@ -1344,12 +1473,16 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     /// Return true if the map contains a value for the specified key,\n     /// using equivalence.\n+    ///\n+    /// See [pop_equiv](#method.pop_equiv) for an extended example.\n     pub fn contains_key_equiv<Q: Hash<S> + Equiv<K>>(&self, key: &Q) -> bool {\n         self.search_equiv(key).is_some()\n     }\n \n     /// Return the value corresponding to the key in the map, using\n     /// equivalence.\n+    ///\n+    /// See [pop_equiv](#method.pop_equiv) for an extended example.\n     pub fn find_equiv<'a, Q: Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n         match self.search_equiv(k) {\n             None      => None,\n@@ -1360,46 +1493,211 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n+    /// Remove an equivalent key from the map, returning the value at the\n+    /// key if the key was previously in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// This is a slightly silly example where we define the number's parity as\n+    /// the equivalence class. It is important that the values hash the same,\n+    /// which is why we override `Hash`.\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::hash::Hash;\n+    /// use std::hash::sip::SipState;\n+    ///\n+    /// #[deriving(Eq, PartialEq)]\n+    /// struct EvenOrOdd {\n+    ///     num: uint\n+    /// };\n+    ///\n+    /// impl Hash for EvenOrOdd {\n+    ///     fn hash(&self, state: &mut SipState) {\n+    ///         let parity = self.num % 2;\n+    ///         parity.hash(state);\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Equiv<EvenOrOdd> for EvenOrOdd {\n+    ///     fn equiv(&self, other: &EvenOrOdd) -> bool {\n+    ///         self.num % 2 == other.num % 2\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(EvenOrOdd { num: 3 }, \"foo\");\n+    ///\n+    /// assert!(map.contains_key_equiv(&EvenOrOdd { num: 1 }));\n+    /// assert!(!map.contains_key_equiv(&EvenOrOdd { num: 4 }));\n+    ///\n+    /// assert_eq!(map.find_equiv(&EvenOrOdd { num: 5 }), Some(&\"foo\"));\n+    /// assert_eq!(map.find_equiv(&EvenOrOdd { num: 2 }), None);\n+    ///\n+    /// assert_eq!(map.pop_equiv(&EvenOrOdd { num: 1 }), Some(\"foo\"));\n+    /// assert_eq!(map.pop_equiv(&EvenOrOdd { num: 2 }), None);\n+    ///\n+    /// ```\n+    #[experimental]\n+    pub fn pop_equiv<Q:Hash<S> + Equiv<K>>(&mut self, k: &Q) -> Option<V> {\n+        if self.table.size() == 0 {\n+            return None\n+        }\n+\n+        let potential_new_size = self.table.size() - 1;\n+        self.make_some_room(potential_new_size);\n+\n+        let starting_index = match self.search_equiv(k) {\n+            Some(idx) => idx,\n+            None      => return None,\n+        };\n+\n+        self.pop_internal(starting_index)\n+    }\n+\n     /// An iterator visiting all keys in arbitrary order.\n-    /// Iterator element type is &'a K.\n+    /// Iterator element type is `&'a K`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// for key in map.keys() {\n+    ///     println!(\"{}\", key);\n+    /// }\n+    /// ```\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         self.iter().map(|(k, _v)| k)\n     }\n \n     /// An iterator visiting all values in arbitrary order.\n-    /// Iterator element type is &'a V.\n+    /// Iterator element type is `&'a V`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// for key in map.values() {\n+    ///     println!(\"{}\", key);\n+    /// }\n+    /// ```\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         self.iter().map(|(_k, v)| v)\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order.\n-    /// Iterator element type is (&'a K, &'a V).\n+    /// Iterator element type is `(&'a K, &'a V)`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// for (key, val) in map.iter() {\n+    ///     println!(\"key: {} val: {}\", key, val);\n+    /// }\n+    /// ```\n     pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n         self.table.iter()\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order,\n     /// with mutable references to the values.\n-    /// Iterator element type is (&'a K, &'a mut V).\n+    /// Iterator element type is `(&'a K, &'a mut V)`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// // Update all values\n+    /// for (_, val) in map.mut_iter() {\n+    ///     *val *= 2;\n+    /// }\n+    ///\n+    /// for (key, val) in map.iter() {\n+    ///     println!(\"key: {} val: {}\", key, val);\n+    /// }\n+    /// ```\n     pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n         self.table.mut_iter()\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each key-value\n     /// pair out of the map in arbitrary order. The map cannot be used after\n     /// calling this.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// // Not possible with .iter()\n+    /// let vec: Vec<(&str, int)> = map.move_iter().collect();\n+    /// ```\n     pub fn move_iter(self) -> MoveEntries<K, V> {\n         self.table.move_iter().map(|(_, k, v)| (k, v))\n     }\n }\n \n impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n-    /// Like `find`, but returns a copy of the value.\n+    /// Return a copy of the value corresponding to the key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<uint, String> = HashMap::new();\n+    /// map.insert(1u, \"foo\".to_string());\n+    /// let s: String = map.find_copy(&1).unwrap();\n+    /// ```\n     pub fn find_copy(&self, k: &K) -> Option<V> {\n         self.find(k).map(|v| (*v).clone())\n     }\n \n-    /// Like `get`, but returns a copy of the value.\n+    /// Return a copy of the value corresponding to the key.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the key is not present.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<uint, String> = HashMap::new();\n+    /// map.insert(1u, \"foo\".to_string());\n+    /// let s: String = map.get_copy(&1);\n+    /// ```\n     pub fn get_copy(&self, k: &K) -> V {\n         (*self.get(k)).clone()\n     }\n@@ -1489,7 +1787,7 @@ pub type SetMoveItems<K> =\n ///\n /// # Example\n ///\n-/// ```rust\n+/// ```\n /// use std::collections::HashSet;\n ///\n /// // Type inference lets us omit an explicit type signature (which\n@@ -1552,7 +1850,6 @@ impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n     /// use std::collections::HashSet;\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// ```\n@@ -1566,7 +1863,6 @@ impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n     /// use std::collections::HashSet;\n     /// let mut set: HashSet<int> = HashSet::with_capacity(10);\n     /// ```\n@@ -1624,7 +1920,6 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n     /// use std::collections::HashSet;\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// set.reserve(10);\n@@ -1683,9 +1978,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::HashSet;\n-    ///\n     /// let mut set = HashSet::new();\n     /// set.insert(\"a\");\n     /// set.insert(\"b\");\n@@ -1705,9 +1999,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::HashSet;\n-    ///\n     /// let mut set = HashSet::new();\n     /// set.insert(\"a\".to_string());\n     /// set.insert(\"b\".to_string());\n@@ -1728,9 +2021,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::HashSet;\n-    ///\n     /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n     /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n@@ -1758,9 +2050,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::HashSet;\n-    ///\n     /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n     /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n@@ -1784,9 +2075,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::HashSet;\n-    ///\n     /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n     /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n@@ -1810,9 +2100,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::HashSet;\n-    ///\n     /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n     /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n     ///"}]}