{"sha": "cd7584743710aa2355eb7e09146fea7c338a27e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNzU4NDc0MzcxMGFhMjM1NWViN2UwOTE0NmZlYTdjMzM4YTI3ZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-21T21:06:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-21T21:06:51Z"}, "message": "auto merge of #18822 : scialex/rust/better-rustdoc, r=alexcrichton\n\nChanged `rustdoc` so that if we do not have the `strip-private` pass\r\nenabled private modules will be included in the generated documentation\r\n\r\nI added this because it is useful to be able to read the documentation in the very nice `rustdoc` web interface when doing internal work on a project. In this case we want the `rustdoc` to include modules that are hidden from consumers. Since this is not currently possible I added it here.", "tree": {"sha": "2b6748677edf38672a44b7b3f0f9969a218e1f12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b6748677edf38672a44b7b3f0f9969a218e1f12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd7584743710aa2355eb7e09146fea7c338a27e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd7584743710aa2355eb7e09146fea7c338a27e5", "html_url": "https://github.com/rust-lang/rust/commit/cd7584743710aa2355eb7e09146fea7c338a27e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd7584743710aa2355eb7e09146fea7c338a27e5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97c043b2e9ecfc121c754f05ef3c70c3ddde1197", "url": "https://api.github.com/repos/rust-lang/rust/commits/97c043b2e9ecfc121c754f05ef3c70c3ddde1197", "html_url": "https://github.com/rust-lang/rust/commit/97c043b2e9ecfc121c754f05ef3c70c3ddde1197"}, {"sha": "26107f6181a5301d3af9c9614fee4c69d76c7213", "url": "https://api.github.com/repos/rust-lang/rust/commits/26107f6181a5301d3af9c9614fee4c69d76c7213", "html_url": "https://github.com/rust-lang/rust/commit/26107f6181a5301d3af9c9614fee4c69d76c7213"}], "stats": {"total": 109, "additions": 62, "deletions": 47}, "files": [{"sha": "97a18e9708fe2508d5ac9f547e1848ab43e5d6ab", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 47, "deletions": 39, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/cd7584743710aa2355eb7e09146fea7c338a27e5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd7584743710aa2355eb7e09146fea7c338a27e5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=cd7584743710aa2355eb7e09146fea7c338a27e5", "patch": "@@ -101,6 +101,8 @@ pub struct Context {\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n     pub render_redirect_pages: bool,\n+    /// All the passes that were run on this crate.\n+    pub passes: HashSet<String>,\n }\n \n /// Indicates where an external crate can be found.\n@@ -190,6 +192,7 @@ pub struct Cache {\n     parent_stack: Vec<ast::DefId>,\n     search_index: Vec<IndexItem>,\n     privmod: bool,\n+    remove_priv: bool,\n     public_items: NodeSet,\n \n     // In rare case where a structure is defined in one module but implemented\n@@ -236,9 +239,13 @@ local_data_key!(pub cache_key: Arc<Cache>)\n local_data_key!(pub current_location_key: Vec<String> )\n \n /// Generates the documentation for `crate` into the directory `dst`\n-pub fn run(mut krate: clean::Crate, external_html: &ExternalHtml, dst: Path) -> io::IoResult<()> {\n+pub fn run(mut krate: clean::Crate,\n+           external_html: &ExternalHtml,\n+           dst: Path,\n+           passes: HashSet<String>) -> io::IoResult<()> {\n     let mut cx = Context {\n         dst: dst,\n+        passes: passes,\n         current: Vec::new(),\n         root_path: String::new(),\n         sidebar: HashMap::new(),\n@@ -320,6 +327,7 @@ pub fn run(mut krate: clean::Crate, external_html: &ExternalHtml, dst: Path) ->\n         search_index: Vec::new(),\n         extern_locations: HashMap::new(),\n         primitive_locations: HashMap::new(),\n+        remove_priv: cx.passes.contains(\"strip-private\"),\n         privmod: false,\n         public_items: public_items,\n         orphan_methods: Vec::new(),\n@@ -767,7 +775,7 @@ impl DocFolder for Cache {\n         let orig_privmod = match item.inner {\n             clean::ModuleItem(..) => {\n                 let prev = self.privmod;\n-                self.privmod = prev || item.visibility != Some(ast::Public);\n+                self.privmod = prev || (self.remove_priv && item.visibility != Some(ast::Public));\n                 prev\n             }\n             _ => self.privmod,\n@@ -1192,7 +1200,7 @@ impl Context {\n         // these modules are recursed into, but not rendered normally (a\n         // flag on the context).\n         if !self.render_redirect_pages {\n-            self.render_redirect_pages = ignore_private_item(&item);\n+            self.render_redirect_pages = self.ignore_private_item(&item);\n         }\n \n         match item.inner {\n@@ -1211,7 +1219,7 @@ impl Context {\n                         clean::ModuleItem(m) => m,\n                         _ => unreachable!()\n                     };\n-                    this.sidebar = build_sidebar(&m);\n+                    this.sidebar = this.build_sidebar(&m);\n                     for item in m.items.into_iter() {\n                         f(this,item);\n                     }\n@@ -1230,6 +1238,40 @@ impl Context {\n             _ => Ok(())\n         }\n     }\n+\n+    fn build_sidebar(&self, m: &clean::Module) -> HashMap<String, Vec<String>> {\n+        let mut map = HashMap::new();\n+        for item in m.items.iter() {\n+            if self.ignore_private_item(item) { continue }\n+\n+            let short = shortty(item).to_static_str();\n+            let myname = match item.name {\n+                None => continue,\n+                Some(ref s) => s.to_string(),\n+            };\n+            let v = match map.entry(short.to_string()) {\n+                Vacant(entry) => entry.set(Vec::with_capacity(1)),\n+                Occupied(entry) => entry.into_mut(),\n+            };\n+            v.push(myname);\n+        }\n+\n+        for (_, items) in map.iter_mut() {\n+            items.as_mut_slice().sort();\n+        }\n+        return map;\n+    }\n+\n+    fn ignore_private_item(&self, it: &clean::Item) -> bool {\n+        match it.inner {\n+            clean::ModuleItem(ref m) => {\n+                (m.items.len() == 0 && it.doc_value().is_none()) ||\n+                (self.passes.contains(\"strip-private\") && it.visibility != Some(ast::Public))\n+            }\n+            clean::PrimitiveItem(..) => it.visibility != Some(ast::Public),\n+            _ => false,\n+        }\n+    }\n }\n \n impl<'a> Item<'a> {\n@@ -1443,7 +1485,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     try!(document(w, item));\n \n     let mut indices = range(0, items.len()).filter(|i| {\n-        !ignore_private_item(&items[*i])\n+        !cx.ignore_private_item(&items[*i])\n     }).collect::<Vec<uint>>();\n \n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n@@ -2157,29 +2199,6 @@ impl<'a> fmt::Show for Sidebar<'a> {\n     }\n }\n \n-fn build_sidebar(m: &clean::Module) -> HashMap<String, Vec<String>> {\n-    let mut map = HashMap::new();\n-    for item in m.items.iter() {\n-        if ignore_private_item(item) { continue }\n-\n-        let short = shortty(item).to_static_str();\n-        let myname = match item.name {\n-            None => continue,\n-            Some(ref s) => s.to_string(),\n-        };\n-        let v = match map.entry(short.to_string()) {\n-            Vacant(entry) => entry.set(Vec::with_capacity(1)),\n-            Occupied(entry) => entry.into_mut(),\n-        };\n-        v.push(myname);\n-    }\n-\n-    for (_, items) in map.iter_mut() {\n-        items.as_mut_slice().sort();\n-    }\n-    return map;\n-}\n-\n impl<'a> fmt::Show for Source<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Source(s) = *self;\n@@ -2214,17 +2233,6 @@ fn item_primitive(w: &mut fmt::Formatter,\n     render_methods(w, it)\n }\n \n-fn ignore_private_item(it: &clean::Item) -> bool {\n-    match it.inner {\n-        clean::ModuleItem(ref m) => {\n-            (m.items.len() == 0 && it.doc_value().is_none()) ||\n-               it.visibility != Some(ast::Public)\n-        }\n-        clean::PrimitiveItem(..) => it.visibility != Some(ast::Public),\n-        _ => false,\n-    }\n-}\n-\n fn get_basic_keywords() -> &'static str {\n     \"rust, rustlang, rust-lang\"\n }"}, {"sha": "54e9196d8a9f6189d9506cddc7fdb1d76521dc80", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cd7584743710aa2355eb7e09146fea7c338a27e5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd7584743710aa2355eb7e09146fea7c338a27e5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=cd7584743710aa2355eb7e09146fea7c338a27e5", "patch": "@@ -86,7 +86,11 @@ static DEFAULT_PASSES: &'static [&'static str] = &[\n \n local_data_key!(pub analysiskey: core::CrateAnalysis)\n \n-type Output = (clean::Crate, Vec<plugins::PluginJson> );\n+struct Output {\n+    krate: clean::Crate,\n+    json_plugins: Vec<plugins::PluginJson>,\n+    passes: Vec<String>,\n+}\n \n pub fn main() {\n     std::os::set_exit_status(main_args(std::os::args().as_slice()));\n@@ -229,24 +233,26 @@ pub fn main_args(args: &[String]) -> int {\n         (false, false) => {}\n     }\n \n-    let (krate, res) = match acquire_input(input, externs, &matches) {\n-        Ok(pair) => pair,\n+    let out = match acquire_input(input, externs, &matches) {\n+        Ok(out) => out,\n         Err(s) => {\n             println!(\"input error: {}\", s);\n             return 1;\n         }\n     };\n-\n+    let Output { krate, json_plugins, passes, } = out;\n     info!(\"going to format\");\n     match matches.opt_str(\"w\").as_ref().map(|s| s.as_slice()) {\n         Some(\"html\") | None => {\n-            match html::render::run(krate, &external_html, output.unwrap_or(Path::new(\"doc\"))) {\n+            match html::render::run(krate, &external_html, output.unwrap_or(Path::new(\"doc\")),\n+                                    passes.into_iter().collect()) {\n                 Ok(()) => {}\n                 Err(e) => panic!(\"failed to generate documentation: {}\", e),\n             }\n         }\n         Some(\"json\") => {\n-            match json_output(krate, res, output.unwrap_or(Path::new(\"doc.json\"))) {\n+            match json_output(krate, json_plugins,\n+                              output.unwrap_or(Path::new(\"doc.json\"))) {\n                 Ok(()) => {}\n                 Err(e) => panic!(\"failed to write json: {}\", e),\n             }\n@@ -397,7 +403,8 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n \n     // Run everything!\n     info!(\"Executing passes/plugins\");\n-    return pm.run_plugins(krate);\n+    let (krate, json) = pm.run_plugins(krate);\n+    return Output { krate: krate, json_plugins: json, passes: passes, };\n }\n \n /// This input format purely deserializes the json output file. No passes are\n@@ -435,7 +442,7 @@ fn json_input(input: &str) -> Result<Output, String> {\n             // FIXME: this should read from the \"plugins\" field, but currently\n             //      Json doesn't implement decodable...\n             let plugin_output = Vec::new();\n-            Ok((krate, plugin_output))\n+            Ok(Output { krate: krate, json_plugins: plugin_output, passes: Vec::new(), })\n         }\n         Ok(..) => {\n             Err(\"malformed json input: expected an object at the \\"}]}