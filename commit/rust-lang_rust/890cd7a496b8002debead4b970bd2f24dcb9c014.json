{"sha": "890cd7a496b8002debead4b970bd2f24dcb9c014", "node_id": "C_kwDOAAsO6NoAKDg5MGNkN2E0OTZiODAwMmRlYmVhZDRiOTcwYmQyZjI0ZGNiOWMwMTQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-24T18:04:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-24T18:04:26Z"}, "message": "Rollup merge of #99644 - RalfJung:interpret-int-ptr-transmute, r=oli-obk\n\nremove some provenance-related machine hooks that Miri no longer needs\n\nThen we can make `scalar_to_ptr` a method on `Scalar`. :)\n\nFixes https://github.com/rust-lang/miri/issues/2188\nr? `@oli-obk`", "tree": {"sha": "1bc9dbdce55f7c08204622e3c6f9bb9ed167426a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bc9dbdce55f7c08204622e3c6f9bb9ed167426a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/890cd7a496b8002debead4b970bd2f24dcb9c014", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi3YmqCRBK7hj4Ov3rIwAAUgQIADcm0qmXSD/9rhb8DDAIiev3\nrnTuHnszJv90r4fauuH8TfT1gwK+ABss1QdD18Sa5S6LFw6YkUXh3QJZnQfdjH3f\nCPIuOdMgrUdDVdbveQbmcY0RSlfxj/awUmS4am3ELZrkSxgWK6b9/KDtGflEik4u\n94n469Urx027xgToFSRFaxwh2hIoBrMBQR69rMhDBUIBO1aXnBvOy5PkjpKYFEYP\nf00sS0S/ZELbf/0BzmB/QYYlJKrZvlam5v1S63Dkwilp1Dipf7jbBvOwb1GPNKJs\nF6yhccru2JAodOvIkRAEo2DuJxsRqZHphqxMAIMJ7SouBLFXYS6e0pS0LOoQPqw=\n=Qazh\n-----END PGP SIGNATURE-----\n", "payload": "tree 1bc9dbdce55f7c08204622e3c6f9bb9ed167426a\nparent c32dcbba187d1ee0dbe92dc152cb9c2f3f42900c\nparent 4e89a7c29325964182e0fb9f92539cf2d9f18e82\nauthor Ralf Jung <post@ralfj.de> 1658685866 -0400\ncommitter GitHub <noreply@github.com> 1658685866 -0400\n\nRollup merge of #99644 - RalfJung:interpret-int-ptr-transmute, r=oli-obk\n\nremove some provenance-related machine hooks that Miri no longer needs\n\nThen we can make `scalar_to_ptr` a method on `Scalar`. :)\n\nFixes https://github.com/rust-lang/miri/issues/2188\nr? `@oli-obk`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/890cd7a496b8002debead4b970bd2f24dcb9c014", "html_url": "https://github.com/rust-lang/rust/commit/890cd7a496b8002debead4b970bd2f24dcb9c014", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/890cd7a496b8002debead4b970bd2f24dcb9c014/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c32dcbba187d1ee0dbe92dc152cb9c2f3f42900c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c32dcbba187d1ee0dbe92dc152cb9c2f3f42900c", "html_url": "https://github.com/rust-lang/rust/commit/c32dcbba187d1ee0dbe92dc152cb9c2f3f42900c"}, {"sha": "4e89a7c29325964182e0fb9f92539cf2d9f18e82", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e89a7c29325964182e0fb9f92539cf2d9f18e82", "html_url": "https://github.com/rust-lang/rust/commit/4e89a7c29325964182e0fb9f92539cf2d9f18e82"}], "stats": {"total": 147, "additions": 57, "deletions": 90}, "files": [{"sha": "ba8222dc15218d245af6ab41ceab5d2524ad7e3b", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=890cd7a496b8002debead4b970bd2f24dcb9c014", "patch": "@@ -173,18 +173,17 @@ pub(super) fn op_to_const<'tcx>(\n             Immediate::ScalarPair(a, b) => {\n                 debug!(\"ScalarPair(a: {:?}, b: {:?})\", a, b);\n                 // We know `offset` is relative to the allocation, so we can use `into_parts`.\n-                let (data, start) =\n-                    match ecx.scalar_to_ptr(a.check_init().unwrap()).unwrap().into_parts() {\n-                        (Some(alloc_id), offset) => {\n-                            (ecx.tcx.global_alloc(alloc_id).unwrap_memory(), offset.bytes())\n-                        }\n-                        (None, _offset) => (\n-                            ecx.tcx.intern_const_alloc(\n-                                Allocation::from_bytes_byte_aligned_immutable(b\"\" as &[u8]),\n-                            ),\n-                            0,\n-                        ),\n-                    };\n+                let (data, start) = match a.to_pointer(ecx).unwrap().into_parts() {\n+                    (Some(alloc_id), offset) => {\n+                        (ecx.tcx.global_alloc(alloc_id).unwrap_memory(), offset.bytes())\n+                    }\n+                    (None, _offset) => (\n+                        ecx.tcx.intern_const_alloc(Allocation::from_bytes_byte_aligned_immutable(\n+                            b\"\" as &[u8],\n+                        )),\n+                        0,\n+                    ),\n+                };\n                 let len = b.to_machine_usize(ecx).unwrap();\n                 let start = start.try_into().unwrap();\n                 let len: usize = len.try_into().unwrap();"}, {"sha": "c97c31eb9dadfb98508feee369e9697a24dbdce8", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=890cd7a496b8002debead4b970bd2f24dcb9c014", "patch": "@@ -180,7 +180,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         assert!(cast_ty.is_integral());\n \n         let scalar = src.to_scalar()?;\n-        let ptr = self.scalar_to_ptr(scalar)?;\n+        let ptr = scalar.to_pointer(self)?;\n         match ptr.into_pointer_or_addr() {\n             Ok(ptr) => M::expose_ptr(self, ptr)?,\n             Err(_) => {} // Do nothing, exposing an invalid pointer (`None` provenance) is a NOP.\n@@ -299,7 +299,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n                 let (old_data, old_vptr) = self.read_immediate(src)?.to_scalar_pair()?;\n-                let old_vptr = self.scalar_to_ptr(old_vptr)?;\n+                let old_vptr = old_vptr.to_pointer(self)?;\n                 let (ty, old_trait) = self.get_ptr_vtable(old_vptr)?;\n                 if old_trait != data_a.principal() {\n                     throw_ub_format!(\"upcast on a pointer whose vtable does not match its type\");"}, {"sha": "150d6589b0807e811f38df685f3e4a51993dd41f", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=890cd7a496b8002debead4b970bd2f24dcb9c014", "patch": "@@ -629,7 +629,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 Ok(Some((size, align)))\n             }\n             ty::Dynamic(..) => {\n-                let vtable = self.scalar_to_ptr(metadata.unwrap_meta())?;\n+                let vtable = metadata.unwrap_meta().to_pointer(self)?;\n                 // Read size and align from vtable (already checks size).\n                 Ok(Some(self.get_vtable_size_and_align(vtable)?))\n             }"}, {"sha": "376b8872c90ac1be2610e792cadbd844e3b6d60d", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=890cd7a496b8002debead4b970bd2f24dcb9c014", "patch": "@@ -245,7 +245,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n             if let ty::Dynamic(..) =\n                 tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind()\n             {\n-                let ptr = self.ecx.scalar_to_ptr(mplace.meta.unwrap_meta())?;\n+                let ptr = mplace.meta.unwrap_meta().to_pointer(&tcx)?;\n                 if let Some(alloc_id) = ptr.provenance {\n                     // Explicitly choose const mode here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable."}, {"sha": "71ccd1799fa95b19d26a49587ca129575d100dca", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=890cd7a496b8002debead4b970bd2f24dcb9c014", "patch": "@@ -135,9 +135,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Whether to enforce integers and floats being initialized.\n     fn enforce_number_init(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n-    /// Whether to enforce integers and floats not having provenance.\n-    fn enforce_number_no_provenance(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n-\n     /// Whether function calls should be [ABI](CallAbi)-checked.\n     fn enforce_abi(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         true\n@@ -300,13 +297,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         addr: u64,\n     ) -> InterpResult<'tcx, Pointer<Option<Self::Provenance>>>;\n \n-    /// Hook for returning a pointer from a transmute-like operation on an addr.\n-    /// This is only needed to support Miri's (unsound) \"allow-ptr-int-transmute\" flag.\n-    fn ptr_from_addr_transmute(\n-        ecx: &InterpCx<'mir, 'tcx, Self>,\n-        addr: u64,\n-    ) -> Pointer<Option<Self::Provenance>>;\n-\n     /// Marks a pointer as exposed, allowing it's provenance\n     /// to be recovered. \"Pointer-to-int cast\"\n     fn expose_ptr(\n@@ -469,11 +459,6 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n         true\n     }\n \n-    #[inline(always)]\n-    fn enforce_number_no_provenance(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n-        true\n-    }\n-\n     #[inline(always)]\n     fn checked_binop_checks_overflow(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n         true\n@@ -518,14 +503,6 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n         ptr\n     }\n \n-    #[inline(always)]\n-    fn ptr_from_addr_transmute(\n-        _ecx: &InterpCx<$mir, $tcx, Self>,\n-        addr: u64,\n-    ) -> Pointer<Option<AllocId>> {\n-        Pointer::from_addr(addr)\n-    }\n-\n     #[inline(always)]\n     fn ptr_from_addr_cast(\n         _ecx: &InterpCx<$mir, $tcx, Self>,"}, {"sha": "ed2c4edf9dd72920e0d634c2ae406cc8f65986e8", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=890cd7a496b8002debead4b970bd2f24dcb9c014", "patch": "@@ -9,7 +9,6 @@\n use std::assert_matches::assert_matches;\n use std::borrow::Cow;\n use std::collections::VecDeque;\n-use std::convert::TryFrom;\n use std::fmt;\n use std::ptr;\n \n@@ -1172,34 +1171,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n /// Machine pointer introspection.\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    pub fn scalar_to_ptr(\n-        &self,\n-        scalar: Scalar<M::Provenance>,\n-    ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n-        // We use `to_bits_or_ptr_internal` since we are just implementing the method people need to\n-        // call to force getting out a pointer.\n-        Ok(\n-            match scalar\n-                .to_bits_or_ptr_internal(self.pointer_size())\n-                .map_err(|s| err_ub!(ScalarSizeMismatch(s)))?\n-            {\n-                Err(ptr) => ptr.into(),\n-                Ok(bits) => {\n-                    let addr = u64::try_from(bits).unwrap();\n-                    M::ptr_from_addr_transmute(&self, addr)\n-                }\n-            },\n-        )\n-    }\n-\n     /// Test if this value might be null.\n     /// If the machine does not support ptr-to-int casts, this is conservative.\n     pub fn scalar_may_be_null(&self, scalar: Scalar<M::Provenance>) -> InterpResult<'tcx, bool> {\n         Ok(match scalar.try_to_int() {\n             Ok(int) => int.is_null(),\n             Err(_) => {\n                 // Can only happen during CTFE.\n-                let ptr = self.scalar_to_ptr(scalar)?;\n+                let ptr = scalar.to_pointer(self)?;\n                 match self.ptr_try_get_alloc_id(ptr) {\n                     Ok((alloc_id, offset, _)) => {\n                         let (size, _align, _kind) = self.get_alloc_info(alloc_id);"}, {"sha": "de284bd3bae3775a9000e3dbae1635d226403bdc", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=890cd7a496b8002debead4b970bd2f24dcb9c014", "patch": "@@ -14,7 +14,7 @@ use rustc_target::abi::{VariantIdx, Variants};\n use super::{\n     alloc_range, from_known_layout, mir_assign_valid_types, AllocId, ConstValue, Frame, GlobalId,\n     InterpCx, InterpResult, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Place, PlaceTy, Pointer,\n-    PointerArithmetic, Provenance, Scalar, ScalarMaybeUninit,\n+    Provenance, Scalar, ScalarMaybeUninit,\n };\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n@@ -363,17 +363,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Abi::Scalar(s) if force => Some(s.primitive()),\n             _ => None,\n         };\n-        let read_provenance = |s: abi::Primitive, size| {\n-            // Should be just `s.is_ptr()`, but we support a Miri flag that accepts more\n-            // questionable ptr-int transmutes.\n-            let number_may_have_provenance = !M::enforce_number_no_provenance(self);\n-            s.is_ptr() || (number_may_have_provenance && size == self.pointer_size())\n-        };\n         if let Some(s) = scalar_layout {\n             let size = s.size(self);\n             assert_eq!(size, mplace.layout.size, \"abi::Scalar size does not match layout size\");\n-            let scalar =\n-                alloc.read_scalar(alloc_range(Size::ZERO, size), read_provenance(s, size))?;\n+            let scalar = alloc\n+                .read_scalar(alloc_range(Size::ZERO, size), /*read_provenance*/ s.is_ptr())?;\n             return Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }));\n         }\n         let scalar_pair_layout = match mplace.layout.abi {\n@@ -391,10 +385,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             let (a_size, b_size) = (a.size(self), b.size(self));\n             let b_offset = a_size.align_to(b.align(self).abi);\n             assert!(b_offset.bytes() > 0); // in `operand_field` we use the offset to tell apart the fields\n-            let a_val =\n-                alloc.read_scalar(alloc_range(Size::ZERO, a_size), read_provenance(a, a_size))?;\n-            let b_val =\n-                alloc.read_scalar(alloc_range(b_offset, b_size), read_provenance(b, b_size))?;\n+            let a_val = alloc.read_scalar(\n+                alloc_range(Size::ZERO, a_size),\n+                /*read_provenance*/ a.is_ptr(),\n+            )?;\n+            let b_val = alloc\n+                .read_scalar(alloc_range(b_offset, b_size), /*read_provenance*/ b.is_ptr())?;\n             return Ok(Some(ImmTy {\n                 imm: Immediate::ScalarPair(a_val, b_val),\n                 layout: mplace.layout,\n@@ -459,7 +455,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: &OpTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n-        self.scalar_to_ptr(self.read_scalar(op)?.check_init()?)\n+        self.read_scalar(op)?.to_pointer(self)\n     }\n \n     /// Turn the wide MPlace into a string (must already be dereferenced!)"}, {"sha": "473da71a0ab9cb570ee88d11d9eb89db16b347bf", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=890cd7a496b8002debead4b970bd2f24dcb9c014", "patch": "@@ -331,7 +331,7 @@ where\n             Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n         };\n \n-        let mplace = MemPlace { ptr: self.scalar_to_ptr(ptr.check_init()?)?, meta };\n+        let mplace = MemPlace { ptr: ptr.to_pointer(self)?, meta };\n         // When deref'ing a pointer, the *static* alignment given by the type is what matters.\n         let align = layout.align.abi;\n         Ok(MPlaceTy { mplace, layout, align })\n@@ -889,7 +889,7 @@ where\n         &self,\n         mplace: &MPlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n-        let vtable = self.scalar_to_ptr(mplace.vtable())?; // also sanity checks the type\n+        let vtable = mplace.vtable().to_pointer(self)?; // also sanity checks the type\n         let (ty, _) = self.get_ptr_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;\n "}, {"sha": "42de0dbdca92868b45a2eb18bb3a15077a675290", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=890cd7a496b8002debead4b970bd2f24dcb9c014", "patch": "@@ -561,7 +561,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n \n                 // Get the required information from the vtable.\n-                let vptr = self.scalar_to_ptr(receiver_place.meta.unwrap_meta())?;\n+                let vptr = receiver_place.meta.unwrap_meta().to_pointer(self)?;\n                 let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n                 if dyn_trait != data.principal() {\n                     throw_ub_format!("}, {"sha": "d20f16755c391243cc88facc4960a08f7769c6b5", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=890cd7a496b8002debead4b970bd2f24dcb9c014", "patch": "@@ -312,7 +312,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n         match tail.kind() {\n             ty::Dynamic(..) => {\n-                let vtable = self.ecx.scalar_to_ptr(meta.unwrap_meta())?;\n+                let vtable = meta.unwrap_meta().to_pointer(self.ecx)?;\n                 // Make sure it is a genuine vtable pointer.\n                 let (_ty, _trait) = try_validation!(\n                     self.ecx.get_ptr_vtable(vtable),\n@@ -517,15 +517,13 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                             { \"{:x}\", value } expected { \"initialized bytes\" }\n                     );\n                 }\n-                if M::enforce_number_no_provenance(self.ecx) {\n-                    // As a special exception we *do* match on a `Scalar` here, since we truly want\n-                    // to know its underlying representation (and *not* cast it to an integer).\n-                    let is_ptr = value.check_init().map_or(false, |v| matches!(v, Scalar::Ptr(..)));\n-                    if is_ptr {\n-                        throw_validation_failure!(self.path,\n-                            { \"{:x}\", value } expected { \"plain (non-pointer) bytes\" }\n-                        )\n-                    }\n+                // As a special exception we *do* match on a `Scalar` here, since we truly want\n+                // to know its underlying representation (and *not* cast it to an integer).\n+                let is_ptr = value.check_init().map_or(false, |v| matches!(v, Scalar::Ptr(..)));\n+                if is_ptr {\n+                    throw_validation_failure!(self.path,\n+                        { \"{:x}\", value } expected { \"plain (non-pointer) bytes\" }\n+                    )\n                 }\n                 Ok(true)\n             }\n@@ -568,7 +566,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n                 // If we check references recursively, also check that this points to a function.\n                 if let Some(_) = self.ref_tracking {\n-                    let ptr = self.ecx.scalar_to_ptr(value)?;\n+                    let ptr = value.to_pointer(self.ecx)?;\n                     let _fn = try_validation!(\n                         self.ecx.get_ptr_fn(ptr),\n                         self.path,\n@@ -906,7 +904,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 match alloc.check_bytes(\n                     alloc_range(Size::ZERO, size),\n                     /*allow_uninit*/ !M::enforce_number_init(self.ecx),\n-                    /*allow_ptr*/ !M::enforce_number_no_provenance(self.ecx),\n+                    /*allow_ptr*/ false,\n                 ) {\n                     // In the happy case, we needn't check anything else.\n                     Ok(()) => {}"}, {"sha": "834c114ee1c58d9067fc6ef4f161447200f5725a", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890cd7a496b8002debead4b970bd2f24dcb9c014/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=890cd7a496b8002debead4b970bd2f24dcb9c014", "patch": "@@ -331,6 +331,19 @@ impl<Prov> Scalar<Prov> {\n }\n \n impl<'tcx, Prov: Provenance> Scalar<Prov> {\n+    pub fn to_pointer(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, Pointer<Option<Prov>>> {\n+        match self\n+            .to_bits_or_ptr_internal(cx.pointer_size())\n+            .map_err(|s| err_ub!(ScalarSizeMismatch(s)))?\n+        {\n+            Err(ptr) => Ok(ptr.into()),\n+            Ok(bits) => {\n+                let addr = u64::try_from(bits).unwrap();\n+                Ok(Pointer::from_addr(addr))\n+            }\n+        }\n+    }\n+\n     /// Fundamental scalar-to-int (cast) operation. Many convenience wrappers exist below, that you\n     /// likely want to use instead.\n     ///\n@@ -546,6 +559,11 @@ impl<Prov> ScalarMaybeUninit<Prov> {\n }\n \n impl<'tcx, Prov: Provenance> ScalarMaybeUninit<Prov> {\n+    #[inline(always)]\n+    pub fn to_pointer(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, Pointer<Option<Prov>>> {\n+        self.check_init()?.to_pointer(cx)\n+    }\n+\n     #[inline(always)]\n     pub fn to_bool(self) -> InterpResult<'tcx, bool> {\n         self.check_init()?.to_bool()"}]}