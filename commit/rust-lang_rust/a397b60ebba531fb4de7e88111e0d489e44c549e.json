{"sha": "a397b60ebba531fb4de7e88111e0d489e44c549e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzOTdiNjBlYmJhNTMxZmI0ZGU3ZTg4MTExZTBkNDg5ZTQ0YzU0OWU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-06-11T15:47:47Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-07-08T09:42:57Z"}, "message": "Resolve partially resolved paths in struct patterns/expressions\n\nTreat Def::Err correctly in struct patterns\nMake instantiate_path and instantiate_type a bit closer to each other", "tree": {"sha": "79dc821f33f2ba03e767bbcc28ffb86d37f58bd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79dc821f33f2ba03e767bbcc28ffb86d37f58bd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a397b60ebba531fb4de7e88111e0d489e44c549e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a397b60ebba531fb4de7e88111e0d489e44c549e", "html_url": "https://github.com/rust-lang/rust/commit/a397b60ebba531fb4de7e88111e0d489e44c549e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a397b60ebba531fb4de7e88111e0d489e44c549e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49ea3d48a26c1325dd584c8420227f6e35721f66", "url": "https://api.github.com/repos/rust-lang/rust/commits/49ea3d48a26c1325dd584c8420227f6e35721f66", "html_url": "https://github.com/rust-lang/rust/commit/49ea3d48a26c1325dd584c8420227f6e35721f66"}], "stats": {"total": 362, "additions": 156, "deletions": 206}, "files": [{"sha": "a26480114bcc0c72399c8bd46d1b7622656c0faf", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=a397b60ebba531fb4de7e88111e0d489e44c549e", "patch": "@@ -67,21 +67,6 @@ pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::TupleStruct(..) |\n-        PatKind::Path(..) |\n-        PatKind::Struct(..) => {\n-            match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Variant(..)) | Some(Def::Struct(..)) |\n-                Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) => true,\n-                _ => false\n-            }\n-        }\n-        _ => false\n-    }\n-}\n-\n pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n         PatKind::Path(..) | PatKind::QPath(..) => {"}, {"sha": "4f7c8fbabdbd5b082ba37c80e7ee1fcfa12628fb", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=a397b60ebba531fb4de7e88111e0d489e44c549e", "patch": "@@ -489,39 +489,35 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn check_pat_struct(&self, pat: &'gcx hir::Pat,\n-                            path: &hir::Path, fields: &'gcx [Spanned<hir::FieldPat>],\n-                            etc: bool, expected: Ty<'tcx>) {\n-        let tcx = self.tcx;\n-\n-        let def = tcx.expect_def(pat.id);\n-        let variant = match self.def_struct_variant(def, path.span) {\n-            Some((_, variant)) => variant,\n-            None => {\n-                let name = pprust::path_to_string(path);\n-                span_err!(tcx.sess, pat.span, E0163,\n-                          \"`{}` does not name a struct or a struct variant\", name);\n-                self.write_error(pat.id);\n-\n-                for field in fields {\n-                    self.check_pat(&field.node.pat, tcx.types.err);\n-                }\n-                return;\n+    fn check_pat_struct(&self,\n+                        pat: &'gcx hir::Pat,\n+                        path: &hir::Path,\n+                        fields: &'gcx [Spanned<hir::FieldPat>],\n+                        etc: bool,\n+                        expected: Ty<'tcx>)\n+    {\n+        // Resolve the path and check the definition for errors.\n+        let def = self.finish_resolving_struct_path(path, pat.id, pat.span);\n+        let variant = if let Some(variant) = self.check_struct_path(def, path, pat.span) {\n+            variant\n+        } else {\n+            self.write_error(pat.id);\n+            for field in fields {\n+                self.check_pat(&field.node.pat, self.tcx.types.err);\n             }\n+            return;\n         };\n \n-        let pat_ty = self.instantiate_type(def.def_id(), path);\n-        let item_substs = match pat_ty.sty {\n+        // Type check the path.\n+        let pat_ty = self.instantiate_type_path(def.def_id(), path, pat.id);\n+        self.demand_eqtype(pat.span, expected, pat_ty);\n+\n+        // Type check subpatterns.\n+        let substs = match pat_ty.sty {\n             ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n             _ => span_bug!(pat.span, \"struct variant is not an ADT\")\n         };\n-        self.demand_eqtype(pat.span, expected, pat_ty);\n-        self.check_struct_pat_fields(pat.span, fields, variant, &item_substs, etc);\n-\n-        self.write_ty(pat.id, pat_ty);\n-        self.write_substs(pat.id, ty::ItemSubsts {\n-            substs: item_substs\n-        });\n+        self.check_struct_pat_fields(pat.span, fields, variant, substs, etc);\n     }\n \n     fn check_pat_path(&self,\n@@ -539,8 +535,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Resolve the path and check the definition for errors.\n-        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(tcx.expect_resolution(pat.id),\n-                                                            opt_self_ty, path, pat.span, pat.id);\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(opt_self_ty, path,\n+                                                                   pat.id, pat.span);\n         match def {\n             Def::Err => {\n                 self.set_tainted_by_errors();\n@@ -565,8 +561,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Type check the path.\n         let scheme = tcx.lookup_item_type(def.def_id());\n         let predicates = tcx.lookup_predicates(def.def_id());\n-        self.instantiate_path(segments, scheme, &predicates, opt_ty, def, pat.span, pat.id);\n-        let pat_ty = self.node_ty(pat.id);\n+        let pat_ty = self.instantiate_value_path(segments, scheme, &predicates,\n+                                                 opt_ty, def, pat.span, pat.id);\n         self.demand_suptype(pat.span, expected, pat_ty);\n     }\n \n@@ -597,9 +593,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Resolve the path and check the definition for errors.\n-        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(tcx.expect_resolution(pat.id),\n-                                                                   None, path, pat.span, pat.id);\n-        match def {\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(None, path, pat.id, pat.span);\n+        let variant = match def {\n             Def::Err => {\n                 self.set_tainted_by_errors();\n                 on_error();\n@@ -609,10 +604,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 report_unexpected_def(false);\n                 return;\n             }\n-            Def::Variant(..) | Def::Struct(..) => {} // OK\n+            Def::Variant(..) | Def::Struct(..) => {\n+                tcx.expect_variant_def(def)\n+            }\n             _ => bug!(\"unexpected pattern definition {:?}\", def)\n-        }\n-        let variant = tcx.expect_variant_def(def);\n+        };\n         if variant.kind == VariantKind::Unit && subpats.is_empty() && ddpos.is_some() {\n             // Matching unit structs with tuple variant patterns (`UnitVariant(..)`)\n             // is allowed for backward compatibility.\n@@ -633,20 +629,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             scheme\n         };\n         let predicates = tcx.lookup_predicates(def.def_id());\n-        self.instantiate_path(segments, scheme, &predicates, opt_ty, def, pat.span, pat.id);\n-        let pat_ty = self.node_ty(pat.id);\n+        let pat_ty = self.instantiate_value_path(segments, scheme, &predicates,\n+                                                 opt_ty, def, pat.span, pat.id);\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns.\n         if subpats.len() == variant.fields.len() ||\n                 subpats.len() < variant.fields.len() && ddpos.is_some() {\n-            let expected_substs = match pat_ty.sty {\n-                ty::TyEnum(_, expected_substs) => expected_substs,\n-                ty::TyStruct(_, expected_substs) => expected_substs,\n+            let substs = match pat_ty.sty {\n+                ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n                 ref ty => bug!(\"unexpected pattern type {:?}\", ty),\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n-                let field_ty = self.field_ty(subpat.span, &variant.fields[i], expected_substs);\n+                let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n                 self.check_pat(&subpat, field_ty);\n             }\n         } else {"}, {"sha": "929ab580fc3c1af13825be846b790b31388f6e79", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 108, "deletions": 88, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a397b60ebba531fb4de7e88111e0d489e44c549e", "patch": "@@ -1621,62 +1621,32 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// Note that this function is only intended to be used with type-paths,\n     /// not with value-paths.\n-    pub fn instantiate_type(&self,\n-                            did: DefId,\n-                            path: &hir::Path)\n-                            -> Ty<'tcx>\n-    {\n-        debug!(\"instantiate_type(did={:?}, path={:?})\", did, path);\n-        let type_scheme =\n-            self.tcx.lookup_item_type(did);\n-        let type_predicates =\n-            self.tcx.lookup_predicates(did);\n+    pub fn instantiate_type_path(&self,\n+                                 did: DefId,\n+                                 path: &hir::Path,\n+                                 node_id: ast::NodeId)\n+                                 -> Ty<'tcx> {\n+        debug!(\"instantiate_type_path(did={:?}, path={:?})\", did, path);\n+        let type_scheme = self.tcx.lookup_item_type(did);\n+        let type_predicates = self.tcx.lookup_predicates(did);\n         let substs = AstConv::ast_path_substs_for_ty(self, self,\n                                                      path.span,\n                                                      PathParamMode::Optional,\n                                                      &type_scheme.generics,\n                                                      path.segments.last().unwrap());\n-        debug!(\"instantiate_type: ty={:?} substs={:?}\", &type_scheme.ty, &substs);\n-        let bounds =\n-            self.instantiate_bounds(path.span, &substs, &type_predicates);\n-        self.add_obligations_for_parameters(\n-            traits::ObligationCause::new(\n-                path.span,\n-                self.body_id,\n-                traits::ItemObligation(did)),\n-            &bounds);\n-\n-        self.instantiate_type_scheme(path.span, &substs, &type_scheme.ty)\n-    }\n-\n-    /// Return the dict-like variant corresponding to a given `Def`.\n-    pub fn def_struct_variant(&self,\n-                              def: Def,\n-                              _span: Span)\n-                              -> Option<(ty::AdtDef<'tcx>, ty::VariantDef<'tcx>)>\n-    {\n-        let (adt, variant) = match def {\n-            Def::Variant(enum_id, variant_id) => {\n-                let adt = self.tcx.lookup_adt_def(enum_id);\n-                (adt, adt.variant_with_id(variant_id))\n-            }\n-            Def::Struct(did) | Def::TyAlias(did) => {\n-                let typ = self.tcx.lookup_item_type(did);\n-                if let ty::TyStruct(adt, _) = typ.ty.sty {\n-                    (adt, adt.struct_variant())\n-                } else {\n-                    return None;\n-                }\n-            }\n-            _ => return None\n-        };\n+        let substs = self.tcx.mk_substs(substs);\n+        debug!(\"instantiate_type_path: ty={:?} substs={:?}\", &type_scheme.ty, substs);\n+        let bounds = self.instantiate_bounds(path.span, substs, &type_predicates);\n+        let cause = traits::ObligationCause::new(path.span, self.body_id,\n+                                                 traits::ItemObligation(did));\n+        self.add_obligations_for_parameters(cause, &bounds);\n \n-        if variant.kind == ty::VariantKind::Struct ||\n-           variant.kind == ty::VariantKind::Unit {\n-            Some((adt, variant))\n-        } else {\n-            None\n-        }\n+        let ty_substituted = self.instantiate_type_scheme(path.span, substs, &type_scheme.ty);\n+        self.write_ty(node_id, ty_substituted);\n+        self.write_substs(node_id, ty::ItemSubsts {\n+            substs: substs\n+        });\n+        ty_substituted\n     }\n \n     pub fn write_nil(&self, node_id: ast::NodeId) {\n@@ -3151,34 +3121,54 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn check_struct_path(&self,\n+                         def: Def,\n+                         path: &hir::Path,\n+                         span: Span)\n+                         -> Option<ty::VariantDef<'tcx>> {\n+        let variant = match def {\n+            Def::Err => {\n+                self.set_tainted_by_errors();\n+                return None;\n+            }\n+            Def::Variant(..) | Def::Struct(..) => {\n+                Some(self.tcx.expect_variant_def(def))\n+            }\n+            Def::TyAlias(did) | Def::AssociatedTy(_, did) => {\n+                if let ty::TyStruct(adt, _) = self.tcx.lookup_item_type(did).ty.sty {\n+                    Some(adt.struct_variant())\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None\n+        };\n+        if variant.is_none() || variant.unwrap().kind == ty::VariantKind::Tuple {\n+            // Reject tuple structs for now, braced and unit structs are allowed.\n+            span_err!(self.tcx.sess, span, E0071,\n+                      \"`{}` does not name a struct or a struct variant\",\n+                      pprust::path_to_string(path));\n+            return None;\n+        }\n+        variant\n+    }\n+\n     fn check_expr_struct(&self,\n                          expr: &hir::Expr,\n                          path: &hir::Path,\n                          fields: &'gcx [hir::Field],\n                          base_expr: &'gcx Option<P<hir::Expr>>)\n     {\n-        let tcx = self.tcx;\n-\n         // Find the relevant variant\n-        let def = tcx.expect_def(expr.id);\n-        if def == Def::Err {\n-            self.set_tainted_by_errors();\n+        let def = self.finish_resolving_struct_path(path, expr.id, expr.span);\n+        let variant = if let Some(variant) = self.check_struct_path(def, path, expr.span) {\n+            variant\n+        } else {\n             self.check_struct_fields_on_error(expr.id, fields, base_expr);\n             return;\n-        }\n-        let variant = match self.def_struct_variant(def, path.span) {\n-            Some((_, variant)) => variant,\n-            None => {\n-                span_err!(self.tcx.sess, path.span, E0071,\n-                          \"`{}` does not name a structure\",\n-                          pprust::path_to_string(path));\n-                self.check_struct_fields_on_error(expr.id, fields, base_expr);\n-                return;\n-            }\n         };\n \n-        let expr_ty = self.instantiate_type(def.def_id(), path);\n-        self.write_ty(expr.id, expr_ty);\n+        let expr_ty = self.instantiate_type_path(def.def_id(), path, expr.id);\n \n         self.check_expr_struct_fields(expr_ty, path.span, variant, fields,\n                                       base_expr.is_none());\n@@ -3190,13 +3180,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         expr.id,\n                         adt.struct_variant().fields.iter().map(|f| {\n                             self.normalize_associated_types_in(\n-                                expr.span, &f.ty(tcx, substs)\n+                                expr.span, &f.ty(self.tcx, substs)\n                             )\n                         }).collect()\n                     );\n                 }\n                 _ => {\n-                    span_err!(tcx.sess, base_expr.span, E0436,\n+                    span_err!(self.tcx.sess, base_expr.span, E0436,\n                               \"functional record update syntax requires a struct\");\n                 }\n             }\n@@ -3349,12 +3339,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           }\n           hir::ExprPath(ref opt_qself, ref path) => {\n               let opt_self_ty = opt_qself.as_ref().map(|qself| self.to_ty(&qself.ty));\n-              let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(tcx.expect_resolution(id),\n-                                                            opt_self_ty, path, expr.span, expr.id);\n+              let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(opt_self_ty, path,\n+                                                                         expr.id, expr.span);\n               if def != Def::Err {\n                   let (scheme, predicates) = self.type_scheme_and_predicates_for_def(expr.span,\n                                                                                      def);\n-                  self.instantiate_path(segments, scheme, &predicates, opt_ty, def, expr.span, id);\n+                  self.instantiate_value_path(segments, scheme, &predicates,\n+                                              opt_ty, def, expr.span, id);\n               } else {\n                   self.set_tainted_by_errors();\n                   self.write_error(id);\n@@ -3695,18 +3686,45 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                expected);\n     }\n \n+    // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n+    // The newly resolved definition is written into `def_map`.\n+    pub fn finish_resolving_struct_path(&self,\n+                                        path: &hir::Path,\n+                                        node_id: ast::NodeId,\n+                                        span: Span)\n+                                        -> Def\n+    {\n+        let path_res = self.tcx().expect_resolution(node_id);\n+        if path_res.depth == 0 {\n+            // If fully resolved already, we don't have to do anything.\n+            path_res.base_def\n+        } else {\n+            let base_ty_end = path.segments.len() - path_res.depth;\n+            let (_ty, def) = AstConv::finish_resolving_def_to_ty(self, self, span,\n+                                                                 PathParamMode::Optional,\n+                                                                 path_res.base_def,\n+                                                                 None,\n+                                                                 node_id,\n+                                                                 &path.segments[..base_ty_end],\n+                                                                 &path.segments[base_ty_end..]);\n+            // Write back the new resolution.\n+            self.tcx().def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n+            def\n+        }\n+    }\n+\n     // Resolve associated value path into a base type and associated constant or method definition.\n     // The newly resolved definition is written into `def_map`.\n     pub fn resolve_ty_and_def_ufcs<'b>(&self,\n-                                       path_res: PathResolution,\n                                        opt_self_ty: Option<Ty<'tcx>>,\n                                        path: &'b hir::Path,\n-                                       span: Span,\n-                                       node_id: ast::NodeId)\n+                                       node_id: ast::NodeId,\n+                                       span: Span)\n                                        -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n-        // If fully resolved already, we don't have to do anything.\n+        let path_res = self.tcx().expect_resolution(node_id);\n         if path_res.depth == 0 {\n+            // If fully resolved already, we don't have to do anything.\n             (path_res.base_def, opt_self_ty, &path.segments)\n         } else {\n             // Try to resolve everything except for the last segment as a type.\n@@ -3975,15 +3993,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n-    pub fn instantiate_path(&self,\n-                            segments: &[hir::PathSegment],\n-                            type_scheme: TypeScheme<'tcx>,\n-                            type_predicates: &ty::GenericPredicates<'tcx>,\n-                            opt_self_ty: Option<Ty<'tcx>>,\n-                            def: Def,\n-                            span: Span,\n-                            node_id: ast::NodeId) {\n-        debug!(\"instantiate_path(path={:?}, def={:?}, node_id={}, type_scheme={:?})\",\n+    pub fn instantiate_value_path(&self,\n+                                  segments: &[hir::PathSegment],\n+                                  type_scheme: TypeScheme<'tcx>,\n+                                  type_predicates: &ty::GenericPredicates<'tcx>,\n+                                  opt_self_ty: Option<Ty<'tcx>>,\n+                                  def: Def,\n+                                  span: Span,\n+                                  node_id: ast::NodeId)\n+                                  -> Ty<'tcx> {\n+        debug!(\"instantiate_value_path(path={:?}, def={:?}, node_id={}, type_scheme={:?})\",\n                segments,\n                def,\n                node_id,\n@@ -4012,7 +4031,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //    actually pass through this function, but rather the\n         //    `ast_ty_to_ty` function in `astconv`. However, in the case\n         //    of struct patterns (and maybe literals) we do invoke\n-        //    `instantiate_path` to get the general type of an instance of\n+        //    `instantiate_value_path` to get the general type of an instance of\n         //    a struct. (In these cases, there are actually no type\n         //    parameters permitted at present, but perhaps we will allow\n         //    them in the future.)\n@@ -4235,20 +4254,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 Err(_) => {\n                     span_bug!(span,\n-                        \"instantiate_path: (UFCS) {:?} was a subtype of {:?} but now is not?\",\n+                        \"instantiate_value_path: (UFCS) {:?} was a subtype of {:?} but now is not?\",\n                         self_ty,\n                         impl_ty);\n                 }\n             }\n         }\n \n-        debug!(\"instantiate_path: type of {:?} is {:?}\",\n+        debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n         self.write_ty(node_id, ty_substituted);\n         self.write_substs(node_id, ty::ItemSubsts {\n             substs: substs\n         });\n+        ty_substituted\n     }\n \n     /// Finds the parameters that the user provided and adds them to `substs`. If too many"}, {"sha": "8769bc1a32b5080856297c7f7928c14e8b3eeb32", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=a397b60ebba531fb4de7e88111e0d489e44c549e", "patch": "@@ -1895,33 +1895,6 @@ fn my_start(argc: isize, argv: *const *const u8) -> isize {\n ```\n \"##,\n \n-E0163: r##\"\n-This error means that an attempt was made to match an enum variant as a\n-struct type when the variant isn't a struct type:\n-\n-```compile_fail\n-enum Foo { B(u32) }\n-\n-fn bar(foo: Foo) -> u32 {\n-    match foo {\n-        B{i} => i, // error E0163\n-    }\n-}\n-```\n-\n-Try using `()` instead:\n-\n-```\n-enum Foo { B(u32) }\n-\n-fn bar(foo: Foo) -> u32 {\n-    match foo {\n-        Foo::B(i) => i,\n-    }\n-}\n-```\n-\"##,\n-\n E0164: r##\"\n This error means that an attempt was made to match a struct type enum\n variant as a non-struct type:\n@@ -4070,6 +4043,7 @@ register_diagnostics! {\n //  E0129,\n //  E0141,\n //  E0159, // use of trait `{}` as struct constructor\n+//  E0163, // merged into E0071\n     E0167,\n //  E0168,\n //  E0173, // manual implementations of unboxed closure traits are experimental"}, {"sha": "5cb6f4d2803e199e3dd472ce7279c3bd52c51378", "filename": "src/test/compile-fail/E0163.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/49ea3d48a26c1325dd584c8420227f6e35721f66/src%2Ftest%2Fcompile-fail%2FE0163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ea3d48a26c1325dd584c8420227f6e35721f66/src%2Ftest%2Fcompile-fail%2FE0163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0163.rs?ref=49ea3d48a26c1325dd584c8420227f6e35721f66", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-enum Foo { B(u32) }\n-\n-fn bar(foo: Foo) -> u32 {\n-    match foo {\n-        Foo::B { i } => i, //~ ERROR E0163\n-    }\n-}\n-\n-fn main() {\n-}"}, {"sha": "671232e701f872b33721803aba16349e5ca33ed1", "filename": "src/test/compile-fail/issue-16058.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs?ref=a397b60ebba531fb4de7e88111e0d489e44c549e", "patch": "@@ -16,7 +16,7 @@ pub struct GslResult {\n \n impl GslResult {\n     pub fn new() -> GslResult {\n-        Result { //~ ERROR: `Result` does not name a structure\n+        Result { //~ ERROR: `Result` does not name a struct or a struct variant\n             val: 0f64,\n             err: 0f64\n         }"}, {"sha": "218f68714ff929821d1f9b5a975fa7ea0634afd8", "filename": "src/test/compile-fail/issue-17001.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-17001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-17001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17001.rs?ref=a397b60ebba531fb4de7e88111e0d489e44c549e", "patch": "@@ -11,5 +11,5 @@\n mod foo {}\n \n fn main() {\n-    let p = foo { x: () }; //~ ERROR `foo` does not name a structure\n+    let p = foo { x: () }; //~ ERROR `foo` does not name a struct or a struct variant\n }"}, {"sha": "2f2c252b947c90f38994c142985e6ae3fdd8cdb1", "filename": "src/test/compile-fail/issue-17405.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs?ref=a397b60ebba531fb4de7e88111e0d489e44c549e", "patch": "@@ -15,6 +15,5 @@ enum Foo {\n fn main() {\n     match Foo::Bar(1) {\n         Foo { i } => () //~ ERROR expected variant, struct or type alias, found enum `Foo`\n-        //~^ ERROR `Foo` does not name a struct or a struct variant\n     }\n }"}, {"sha": "090b8a0d16e64ca9a890fde406512ce8d22c82bb", "filename": "src/test/compile-fail/issue-21449.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-21449.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-21449.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21449.rs?ref=a397b60ebba531fb4de7e88111e0d489e44c549e", "patch": "@@ -11,5 +11,5 @@\n mod MyMod {}\n \n fn main() {\n-    let myVar = MyMod { T: 0 }; //~ ERROR `MyMod` does not name a structure\n+    let myVar = MyMod { T: 0 }; //~ ERROR `MyMod` does not name a struct or a struct variant\n }"}, {"sha": "24b39eeff0f791c0e3508e77c6e99e82d11ec383", "filename": "src/test/compile-fail/issue-26459.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs?ref=a397b60ebba531fb4de7e88111e0d489e44c549e", "patch": "@@ -12,6 +12,5 @@ fn main() {\n     match 'a' {\n         char{ch} => true\n         //~^ ERROR expected variant, struct or type alias, found builtin type `char`\n-        //~| ERROR `char` does not name a struct or a struct variant\n     };\n }"}, {"sha": "7a329bac61b22f64a0fa2eee6b1c512423005833", "filename": "src/test/compile-fail/issue-27815.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs?ref=a397b60ebba531fb4de7e88111e0d489e44c549e", "patch": "@@ -11,12 +11,10 @@\n mod A {}\n \n fn main() {\n-    let u = A { x: 1 }; //~ ERROR `A` does not name a structure\n-    let v = u32 { x: 1 }; //~ ERROR `u32` does not name a structure\n+    let u = A { x: 1 }; //~ ERROR `A` does not name a struct or a struct variant\n+    let v = u32 { x: 1 }; //~ ERROR `u32` does not name a struct or a struct variant\n     match () {\n         A { x: 1 } => {} //~ ERROR expected variant, struct or type alias, found module `A`\n-        //~^ ERROR `A` does not name a struct or a struct variant\n         u32 { x: 1 } => {} //~ ERROR expected variant, struct or type alias, found builtin type `u32\n-        //~^ ERROR `u32` does not name a struct or a struct variant\n     }\n }"}, {"sha": "e20e6ea23198cd3c885fa4bea2d8d90ec4a94567", "filename": "src/test/compile-fail/issue-27831.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs?ref=a397b60ebba531fb4de7e88111e0d489e44c549e", "patch": "@@ -18,7 +18,7 @@ enum Enum {\n \n fn main() {\n     let x = Foo(1);\n-    Foo { ..x }; //~ ERROR `Foo` does not name a structure\n+    Foo { ..x }; //~ ERROR `Foo` does not name a struct or a struct variant\n     let Foo { .. } = x; //~ ERROR `Foo` does not name a struct\n \n     let x = Bar;"}, {"sha": "55983c672aa08a8553ce28932d2db5202f277b63", "filename": "src/test/compile-fail/issue-4736.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs?ref=a397b60ebba531fb4de7e88111e0d489e44c549e", "patch": "@@ -11,5 +11,5 @@\n struct NonCopyable(());\n \n fn main() {\n-    let z = NonCopyable{ p: () }; //~ ERROR `NonCopyable` does not name a structure\n+    let z = NonCopyable{ p: () }; //~ ERROR `NonCopyable` does not name a struct or a struct variant\n }"}, {"sha": "505a91f223cc6ceb99afb37edf5540b923105301", "filename": "src/test/compile-fail/lexical-scopes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs?ref=a397b60ebba531fb4de7e88111e0d489e44c549e", "patch": "@@ -10,7 +10,7 @@\n \n struct T { i: i32 }\n fn f<T>() {\n-    let t = T { i: 0 }; //~ ERROR `T` does not name a structure\n+    let t = T { i: 0 }; //~ ERROR `T` does not name a struct or a struct variant\n }\n \n mod Foo {"}, {"sha": "13fdaa302f70a72ee0a800f21b42a93de4c9050d", "filename": "src/test/compile-fail/trait-as-struct-constructor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a397b60ebba531fb4de7e88111e0d489e44c549e/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs?ref=a397b60ebba531fb4de7e88111e0d489e44c549e", "patch": "@@ -12,5 +12,5 @@ trait TraitNotAStruct {}\n \n fn main() {\n     TraitNotAStruct{ value: 0 };\n-    //~^ ERROR: `TraitNotAStruct` does not name a structure [E0071]\n+    //~^ ERROR: `TraitNotAStruct` does not name a struct or a struct variant [E0071]\n }"}]}