{"sha": "d7a71687ef1a9fa5665944608d5bad58d98a9684", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3YTcxNjg3ZWYxYTlmYTU2NjU5NDQ2MDhkNWJhZDU4ZDk4YTk2ODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-24T21:22:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-24T21:22:26Z"}, "message": "Auto merge of #32346 - nikomatsakis:no-erased-regions, r=eddyb\n\nRemove `ErasedRegions` from substs\n\nThis commit removes the `ErasedRegions` enum from `Substs`. Instead, in trans, we just generate a vector of `ReStatic` of suitable length. The goal is both general cleanup and to help pave the way for a glorious future where erasure is used in type check.\n\nr? @eddyb\n\nOne concern: might be nice to do some profiling. Not sure the best way to do that. Perhaps I'll investigate running nrc's test suite locally.", "tree": {"sha": "423509120274dd419095d54c8367ccebd86b7c42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/423509120274dd419095d54c8367ccebd86b7c42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7a71687ef1a9fa5665944608d5bad58d98a9684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7a71687ef1a9fa5665944608d5bad58d98a9684", "html_url": "https://github.com/rust-lang/rust/commit/d7a71687ef1a9fa5665944608d5bad58d98a9684", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7a71687ef1a9fa5665944608d5bad58d98a9684/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcfb8d72e99425686376298fd793715f35b5d512", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcfb8d72e99425686376298fd793715f35b5d512", "html_url": "https://github.com/rust-lang/rust/commit/dcfb8d72e99425686376298fd793715f35b5d512"}, {"sha": "c5d74be4eddbfdd6f1f53839d71f5240c060e8b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5d74be4eddbfdd6f1f53839d71f5240c060e8b3", "html_url": "https://github.com/rust-lang/rust/commit/c5d74be4eddbfdd6f1f53839d71f5240c060e8b3"}], "stats": {"total": 541, "additions": 192, "deletions": 349}, "files": [{"sha": "b9bf550704e02e8f0e440f2557fb16078c9d3a9f", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 28, "deletions": 98, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -11,7 +11,6 @@\n // Type substitutions.\n \n pub use self::ParamSpace::*;\n-pub use self::RegionSubsts::*;\n \n use middle::cstore;\n use middle::def_id::DefId;\n@@ -34,24 +33,15 @@ use syntax::codemap::{Span, DUMMY_SP};\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Substs<'tcx> {\n     pub types: VecPerParamSpace<Ty<'tcx>>,\n-    pub regions: RegionSubsts,\n-}\n-\n-/// Represents the values to use when substituting lifetime parameters.\n-/// If the value is `ErasedRegions`, then this subst is occurring during\n-/// trans, and all region parameters will be replaced with `ty::ReStatic`.\n-#[derive(Clone, PartialEq, Eq, Hash)]\n-pub enum RegionSubsts {\n-    ErasedRegions,\n-    NonerasedRegions(VecPerParamSpace<ty::Region>)\n+    pub regions: VecPerParamSpace<ty::Region>,\n }\n \n impl<'tcx> Substs<'tcx> {\n     pub fn new(t: VecPerParamSpace<Ty<'tcx>>,\n                r: VecPerParamSpace<ty::Region>)\n                -> Substs<'tcx>\n     {\n-        Substs { types: t, regions: NonerasedRegions(r) }\n+        Substs { types: t, regions: r }\n     }\n \n     pub fn new_type(t: Vec<Ty<'tcx>>,\n@@ -71,32 +61,15 @@ impl<'tcx> Substs<'tcx> {\n                     VecPerParamSpace::new(r, Vec::new(), Vec::new()))\n     }\n \n-    pub fn erased(t: VecPerParamSpace<Ty<'tcx>>) -> Substs<'tcx>\n-    {\n-        Substs { types: t, regions: ErasedRegions }\n-    }\n-\n     pub fn empty() -> Substs<'tcx> {\n         Substs {\n             types: VecPerParamSpace::empty(),\n-            regions: NonerasedRegions(VecPerParamSpace::empty()),\n-        }\n-    }\n-\n-    pub fn trans_empty() -> Substs<'tcx> {\n-        Substs {\n-            types: VecPerParamSpace::empty(),\n-            regions: ErasedRegions\n+            regions: VecPerParamSpace::empty(),\n         }\n     }\n \n     pub fn is_noop(&self) -> bool {\n-        let regions_is_noop = match self.regions {\n-            ErasedRegions => false, // may be used to canonicalize\n-            NonerasedRegions(ref regions) => regions.is_empty(),\n-        };\n-\n-        regions_is_noop && self.types.is_empty()\n+        self.regions.is_empty() && self.types.is_empty()\n     }\n \n     pub fn type_for_def(&self, ty_param_def: &ty::TypeParameterDef) -> Ty<'tcx> {\n@@ -115,26 +88,9 @@ impl<'tcx> Substs<'tcx> {\n     }\n \n     pub fn erase_regions(self) -> Substs<'tcx> {\n-        let Substs { types, regions: _ } = self;\n-        Substs { types: types, regions: ErasedRegions }\n-    }\n-\n-    /// Since ErasedRegions are only to be used in trans, most of the compiler can use this method\n-    /// to easily access the set of region substitutions.\n-    pub fn regions<'a>(&'a self) -> &'a VecPerParamSpace<ty::Region> {\n-        match self.regions {\n-            ErasedRegions => panic!(\"Erased regions only expected in trans\"),\n-            NonerasedRegions(ref r) => r\n-        }\n-    }\n-\n-    /// Since ErasedRegions are only to be used in trans, most of the compiler can use this method\n-    /// to easily access the set of region substitutions.\n-    pub fn mut_regions<'a>(&'a mut self) -> &'a mut VecPerParamSpace<ty::Region> {\n-        match self.regions {\n-            ErasedRegions => panic!(\"Erased regions only expected in trans\"),\n-            NonerasedRegions(ref mut r) => r\n-        }\n+        let Substs { types, regions } = self;\n+        let regions = regions.map(|_| ty::ReStatic);\n+        Substs { types: types, regions: regions }\n     }\n \n     pub fn with_method(self,\n@@ -144,7 +100,7 @@ impl<'tcx> Substs<'tcx> {\n     {\n         let Substs { types, regions } = self;\n         let types = types.with_slice(FnSpace, &m_types);\n-        let regions = regions.map(|r| r.with_slice(FnSpace, &m_regions));\n+        let regions = regions.with_slice(FnSpace, &m_regions);\n         Substs { types: types, regions: regions }\n     }\n \n@@ -154,27 +110,23 @@ impl<'tcx> Substs<'tcx> {\n     {\n         let Substs { types, regions } = self.clone();\n         let types = types.with_slice(FnSpace, meth_substs.types.get_slice(FnSpace));\n-        let regions = regions.map(|r| {\n-            r.with_slice(FnSpace, meth_substs.regions().get_slice(FnSpace))\n-        });\n+        let regions = regions.with_slice(FnSpace, meth_substs.regions.get_slice(FnSpace));\n         Substs { types: types, regions: regions }\n     }\n \n     pub fn with_method_from_subst(self, other: &Substs<'tcx>) -> Substs<'tcx> {\n         let Substs { types, regions } = self;\n         let types = types.with_slice(FnSpace, other.types.get_slice(FnSpace));\n-        let regions = regions.map(|r| {\n-            r.with_slice(FnSpace, other.regions().get_slice(FnSpace))\n-        });\n+        let regions = regions.with_slice(FnSpace, other.regions.get_slice(FnSpace));\n         Substs { types: types, regions: regions }\n     }\n \n     /// Creates a trait-ref out of this substs, ignoring the FnSpace substs\n     pub fn to_trait_ref(&self, tcx: &TyCtxt<'tcx>, trait_id: DefId)\n                         -> ty::TraitRef<'tcx> {\n-        let Substs { mut types, regions } = self.clone();\n+        let Substs { mut types, mut regions } = self.clone();\n         types.truncate(FnSpace, 0);\n-        let regions = regions.map(|mut r| { r.truncate(FnSpace, 0); r });\n+        regions.truncate(FnSpace, 0);\n \n         ty::TraitRef {\n             def_id: trait_id,\n@@ -212,24 +164,6 @@ impl<'tcx> Decodable for &'tcx Substs<'tcx> {\n     }\n }\n \n-impl RegionSubsts {\n-    pub fn map<F>(self, op: F) -> RegionSubsts where\n-        F: FnOnce(VecPerParamSpace<ty::Region>) -> VecPerParamSpace<ty::Region>,\n-    {\n-        match self {\n-            ErasedRegions => ErasedRegions,\n-            NonerasedRegions(r) => NonerasedRegions(op(r))\n-        }\n-    }\n-\n-    pub fn is_erased(&self) -> bool {\n-        match *self {\n-            ErasedRegions => true,\n-            NonerasedRegions(_) => false,\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // ParamSpace\n \n@@ -664,26 +598,22 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         // the specialized routine `ty::replace_late_regions()`.\n         match r {\n             ty::ReEarlyBound(data) => {\n-                match self.substs.regions {\n-                    ErasedRegions => ty::ReStatic,\n-                    NonerasedRegions(ref regions) =>\n-                        match regions.opt_get(data.space, data.index as usize) {\n-                            Some(&r) => {\n-                                self.shift_region_through_binders(r)\n-                            }\n-                            None => {\n-                                let span = self.span.unwrap_or(DUMMY_SP);\n-                                self.tcx().sess.span_bug(\n-                                    span,\n-                                    &format!(\"Type parameter out of range \\\n-                                              when substituting in region {} (root type={:?}) \\\n-                                              (space={:?}, index={})\",\n-                                             data.name,\n-                                             self.root_ty,\n-                                             data.space,\n-                                             data.index));\n-                            }\n-                        }\n+                match self.substs.regions.opt_get(data.space, data.index as usize) {\n+                    Some(&r) => {\n+                        self.shift_region_through_binders(r)\n+                    }\n+                    None => {\n+                        let span = self.span.unwrap_or(DUMMY_SP);\n+                        self.tcx().sess.span_bug(\n+                            span,\n+                            &format!(\"Region parameter out of range \\\n+                                      when substituting in region {} (root type={:?}) \\\n+                                      (space={:?}, index={})\",\n+                                     data.name,\n+                                     self.root_ty,\n+                                     data.space,\n+                                     data.index));\n+                    }\n                 }\n             }\n             _ => r"}, {"sha": "92478f2874e1e9add0ae4b5909e7f014a80c3046", "filename": "src/librustc/middle/traits/specialize/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -102,14 +102,6 @@ pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         specialization_graph::Node::Trait(..) => source_trait_ref.substs.clone(),\n     };\n \n-    // retain erasure mode\n-    // NB: this must happen before inheriting method generics below\n-    let target_substs = if source_substs.regions.is_erased() {\n-        target_substs.erase_regions()\n-    } else {\n-        target_substs\n-    };\n-\n     // directly inherent the method generics, since those do not vary across impls\n     infcx.tcx.mk_substs(target_substs.with_method_from_subst(source_substs))\n }"}, {"sha": "c874e9b7ca52d67d32f65ff145ed0982dd366f92", "filename": "src/librustc/middle/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fflags.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -194,13 +194,8 @@ impl FlagComputation {\n \n     fn add_substs(&mut self, substs: &subst::Substs) {\n         self.add_tys(substs.types.as_slice());\n-        match substs.regions {\n-            subst::ErasedRegions => {}\n-            subst::NonerasedRegions(ref regions) => {\n-                for &r in regions {\n-                    self.add_region(r);\n-                }\n-            }\n+        for &r in &substs.regions {\n+            self.add_region(r);\n         }\n     }\n "}, {"sha": "f754e5c5a0a7d5008596c0f067594d624dc253a6", "filename": "src/librustc/middle/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -532,7 +532,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             fn fold_substs(&mut self,\n                            substs: &subst::Substs<'tcx>)\n                            -> subst::Substs<'tcx> {\n-                subst::Substs { regions: subst::ErasedRegions,\n+                subst::Substs { regions: substs.regions.fold_with(self),\n                                 types: substs.types.fold_with(self) }\n             }\n         }"}, {"sha": "050024d0e94ea4c20fd7601642390bc57eee883b", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -2605,7 +2605,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         Substs {\n             types: types,\n-            regions: subst::NonerasedRegions(regions)\n+            regions: regions,\n         }\n     }\n "}, {"sha": "563ff346a6440d169f21f5e9221470a46a185182", "filename": "src/librustc/middle/ty/relate.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -14,7 +14,7 @@\n //! type equality, etc.\n \n use middle::def_id::DefId;\n-use middle::subst::{ErasedRegions, NonerasedRegions, ParamSpace, Substs};\n+use middle::subst::{ParamSpace, Substs};\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use middle::ty::error::{ExpectedFound, TypeError};\n use std::rc::Rc;\n@@ -156,23 +156,15 @@ pub fn relate_substs<'a,'tcx:'a,R>(relation: &mut R,\n         substs.types.replace(space, tps);\n     }\n \n-    match (&a_subst.regions, &b_subst.regions) {\n-        (&ErasedRegions, _) | (_, &ErasedRegions) => {\n-            substs.regions = ErasedRegions;\n-        }\n-\n-        (&NonerasedRegions(ref a), &NonerasedRegions(ref b)) => {\n-            for &space in &ParamSpace::all() {\n-                let a_regions = a.get_slice(space);\n-                let b_regions = b.get_slice(space);\n-                let r_variances = variances.map(|v| v.regions.get_slice(space));\n-                let regions = relate_region_params(relation,\n-                                                   r_variances,\n-                                                   a_regions,\n-                                                   b_regions)?;\n-                substs.mut_regions().replace(space, regions);\n-            }\n-        }\n+    for &space in &ParamSpace::all() {\n+        let a_regions = a_subst.regions.get_slice(space);\n+        let b_regions = b_subst.regions.get_slice(space);\n+        let r_variances = variances.map(|v| v.regions.get_slice(space));\n+        let regions = relate_region_params(relation,\n+                                           r_variances,\n+                                           a_regions,\n+                                           b_regions)?;\n+        substs.regions.replace(space, regions);\n     }\n \n     Ok(substs)"}, {"sha": "0358fa2f1245593c860672c1f75b1ac29e7bad85", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -487,14 +487,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n \n impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let regions = match self.regions {\n-            subst::ErasedRegions => subst::ErasedRegions,\n-            subst::NonerasedRegions(ref regions) => {\n-                subst::NonerasedRegions(regions.fold_with(folder))\n-            }\n-        };\n-\n-        subst::Substs { regions: regions,\n+        subst::Substs { regions: self.regions.fold_with(folder),\n                         types: self.types.fold_with(folder) }\n     }\n \n@@ -503,10 +496,7 @@ impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.types.visit_with(visitor) || match self.regions {\n-            subst::ErasedRegions => false,\n-            subst::NonerasedRegions(ref regions) => regions.visit_with(visitor),\n-        }\n+        self.types.visit_with(visitor) || self.regions.visit_with(visitor)\n     }\n }\n "}, {"sha": "7a17b24df5e9d9feea1cd367bb512f48bc062539", "filename": "src/librustc/middle/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -1204,18 +1204,18 @@ impl<'tcx> TyS<'tcx> {\n             TyTrait(ref obj) => {\n                 let mut v = vec![obj.bounds.region_bound];\n                 v.extend_from_slice(obj.principal.skip_binder()\n-                                       .substs.regions().as_slice());\n+                                       .substs.regions.as_slice());\n                 v\n             }\n             TyEnum(_, substs) |\n             TyStruct(_, substs) => {\n-                substs.regions().as_slice().to_vec()\n+                substs.regions.as_slice().to_vec()\n             }\n             TyClosure(_, ref substs) => {\n-                substs.func_substs.regions().as_slice().to_vec()\n+                substs.func_substs.regions.as_slice().to_vec()\n             }\n             TyProjection(ref data) => {\n-                data.trait_ref.substs.regions().as_slice().to_vec()\n+                data.trait_ref.substs.regions.as_slice().to_vec()\n             }\n             TyFnDef(..) |\n             TyFnPtr(_) |"}, {"sha": "6e7f49516e8faffc7c107e140d810d66ee1ae2fa", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 15, "deletions": 37, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -104,17 +104,9 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n     };\n \n     if verbose {\n-        match substs.regions {\n-            subst::ErasedRegions => {\n-                start_or_continue(f, \"<\", \", \")?;\n-                write!(f, \"..\")?;\n-            }\n-            subst::NonerasedRegions(ref regions) => {\n-                for region in regions {\n-                    start_or_continue(f, \"<\", \", \")?;\n-                    write!(f, \"{:?}\", region)?;\n-                }\n-            }\n+        for region in &substs.regions {\n+            start_or_continue(f, \"<\", \", \")?;\n+            write!(f, \"{:?}\", region)?;\n         }\n         for &ty in &substs.types {\n             start_or_continue(f, \"<\", \", \")?;\n@@ -136,23 +128,18 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n         }\n     }\n \n-    match substs.regions {\n-        subst::ErasedRegions => { }\n-        subst::NonerasedRegions(ref regions) => {\n-            for &r in regions {\n-                start_or_continue(f, \"<\", \", \")?;\n-                let s = r.to_string();\n-                if s.is_empty() {\n-                    // This happens when the value of the region\n-                    // parameter is not easily serialized. This may be\n-                    // because the user omitted it in the first place,\n-                    // or because it refers to some block in the code,\n-                    // etc. I'm not sure how best to serialize this.\n-                    write!(f, \"'_\")?;\n-                } else {\n-                    write!(f, \"{}\", s)?;\n-                }\n-            }\n+    for &r in &substs.regions {\n+        start_or_continue(f, \"<\", \", \")?;\n+        let s = r.to_string();\n+        if s.is_empty() {\n+            // This happens when the value of the region\n+            // parameter is not easily serialized. This may be\n+            // because the user omitted it in the first place,\n+            // or because it refers to some block in the code,\n+            // etc. I'm not sure how best to serialize this.\n+            write!(f, \"'_\")?;\n+        } else {\n+            write!(f, \"{}\", s)?;\n         }\n     }\n \n@@ -393,15 +380,6 @@ impl<'tcx> fmt::Debug for ty::ItemSubsts<'tcx> {\n     }\n }\n \n-impl fmt::Debug for subst::RegionSubsts {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            subst::ErasedRegions => write!(f, \"erased\"),\n-            subst::NonerasedRegions(ref regions) => write!(f, \"{:?}\", regions)\n-        }\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // when printing out the debug representation, we don't need"}, {"sha": "1a84afab86bfce9946476280aeca1b3437e6b1d8", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 32, "deletions": 50, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -29,7 +29,6 @@ use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n \n use rustc_front::hir;\n-use rustc_front::intravisit::{self, Visitor};\n use rustc_front::util::is_shift_binop;\n \n register_long_diagnostics! {\n@@ -403,16 +402,6 @@ fn is_repr_nullable_ptr<'tcx>(tcx: &TyCtxt<'tcx>,\n     false\n }\n \n-fn ast_ty_to_normalized<'tcx>(tcx: &TyCtxt<'tcx>,\n-                              id: ast::NodeId)\n-                              -> Ty<'tcx> {\n-    let tty = match tcx.ast_ty_to_ty_cache.borrow().get(&id) {\n-        Some(&t) => t,\n-        None => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n-    };\n-    infer::normalize_associated_type(tcx, &tty)\n-}\n-\n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the given type is \"ffi-safe\" (has a stable, well-defined\n     /// representation which can be exported to C code).\n@@ -604,10 +593,12 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_def(&mut self, sp: Span, id: ast::NodeId) {\n-        let tty = ast_ty_to_normalized(self.cx.tcx, id);\n+    fn check_type_for_ffi_and_report_errors(&mut self, sp: Span, ty: Ty<'tcx>) {\n+        // it is only OK to use this function because extern fns cannot have\n+        // any generic types right now:\n+        let ty = infer::normalize_associated_type(self.cx.tcx, &ty);\n \n-        match ImproperCTypesVisitor::check_type_for_ffi(self, &mut FnvHashSet(), tty) {\n+        match self.check_type_for_ffi(&mut FnvHashSet(), ty) {\n             FfiResult::FfiSafe => {}\n             FfiResult::FfiUnsafe(s) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp, s);\n@@ -628,27 +619,30 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             }\n         }\n     }\n-}\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ImproperCTypesVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n-        match ty.node {\n-            hir::TyPath(..) |\n-            hir::TyBareFn(..) => self.check_def(ty.span, ty.id),\n-            hir::TyVec(..) => {\n-                self.cx.span_lint(IMPROPER_CTYPES, ty.span,\n-                    \"found Rust slice type in foreign module, consider \\\n-                     using a raw pointer instead\");\n-            }\n-            hir::TyFixedLengthVec(ref ty, _) => self.visit_ty(ty),\n-            hir::TyTup(..) => {\n-                self.cx.span_lint(IMPROPER_CTYPES, ty.span,\n-                    \"found Rust tuple type in foreign module; \\\n-                     consider using a struct instead`\")\n+    fn check_foreign_fn(&mut self, id: ast::NodeId, decl: &hir::FnDecl) {\n+        let def_id = self.cx.tcx.map.local_def_id(id);\n+        let scheme = self.cx.tcx.lookup_item_type(def_id);\n+        let sig = scheme.ty.fn_sig();\n+        let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n+\n+        for (&input_ty, input_hir) in sig.inputs.iter().zip(&decl.inputs) {\n+            self.check_type_for_ffi_and_report_errors(input_hir.ty.span, &input_ty);\n+        }\n+\n+        if let hir::Return(ref ret_hir) = decl.output {\n+            let ret_ty = sig.output.unwrap();\n+            if !ret_ty.is_nil() {\n+                self.check_type_for_ffi_and_report_errors(ret_hir.span, ret_ty);\n             }\n-            _ => intravisit::walk_ty(self, ty)\n         }\n     }\n+\n+    fn check_foreign_static(&mut self, id: ast::NodeId, span: Span) {\n+        let def_id = self.cx.tcx.map.local_def_id(id);\n+        let scheme = self.cx.tcx.lookup_item_type(def_id);\n+        self.check_type_for_ffi_and_report_errors(span, scheme.ty);\n+    }\n }\n \n #[derive(Copy, Clone)]\n@@ -662,29 +656,17 @@ impl LintPass for ImproperCTypes {\n \n impl LateLintPass for ImproperCTypes {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        fn check_ty(cx: &LateContext, ty: &hir::Ty) {\n-            let mut vis = ImproperCTypesVisitor { cx: cx };\n-            vis.visit_ty(ty);\n-        }\n-\n-        fn check_foreign_fn(cx: &LateContext, decl: &hir::FnDecl) {\n-            for input in &decl.inputs {\n-                check_ty(cx, &input.ty);\n-            }\n-            if let hir::Return(ref ret_ty) = decl.output {\n-                let tty = ast_ty_to_normalized(cx.tcx, ret_ty.id);\n-                if !tty.is_nil() {\n-                    check_ty(cx, &ret_ty);\n-                }\n-            }\n-        }\n-\n+        let mut vis = ImproperCTypesVisitor { cx: cx };\n         if let hir::ItemForeignMod(ref nmod) = it.node {\n             if nmod.abi != Abi::RustIntrinsic && nmod.abi != Abi::PlatformIntrinsic {\n                 for ni in &nmod.items {\n                     match ni.node {\n-                        hir::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &decl),\n-                        hir::ForeignItemStatic(ref t, _) => check_ty(cx, &t)\n+                        hir::ForeignItemFn(ref decl, _) => {\n+                            vis.check_foreign_fn(ni.id, decl);\n+                        }\n+                        hir::ForeignItemStatic(ref ty, _) => {\n+                            vis.check_foreign_static(ni.id, ty.span);\n+                        }\n                     }\n                 }\n             }"}, {"sha": "cd9c2e828bdefa6c1325bb79c4062fcdef2f8b27", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -144,22 +144,11 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     }\n \n     pub fn parse_substs(&mut self) -> subst::Substs<'tcx> {\n-        let regions = self.parse_region_substs();\n+        let regions = self.parse_vec_per_param_space(|this| this.parse_region());\n         let types = self.parse_vec_per_param_space(|this| this.parse_ty());\n         subst::Substs { types: types, regions: regions }\n     }\n \n-    fn parse_region_substs(&mut self) -> subst::RegionSubsts {\n-        match self.next() {\n-            'e' => subst::ErasedRegions,\n-            'n' => {\n-                subst::NonerasedRegions(\n-                    self.parse_vec_per_param_space(|this| this.parse_region()))\n-            }\n-            _ => panic!(\"parse_bound_region: bad input\")\n-        }\n-    }\n-\n     fn parse_bound_region(&mut self) -> ty::BoundRegion {\n         match self.next() {\n             'a' => {"}, {"sha": "4718732c8a037ca9f5448bb516d38e939885ba47", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -246,24 +246,12 @@ fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut Cursor<Vec<u8>>,\n \n pub fn enc_substs<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                             substs: &subst::Substs<'tcx>) {\n-    enc_region_substs(w, cx, &substs.regions);\n+    enc_vec_per_param_space(w, cx, &substs.regions,\n+                            |w, cx, &r| enc_region(w, cx, r));\n     enc_vec_per_param_space(w, cx, &substs.types,\n                             |w, cx, &ty| enc_ty(w, cx, ty));\n }\n \n-fn enc_region_substs(w: &mut Cursor<Vec<u8>>, cx: &ctxt, substs: &subst::RegionSubsts) {\n-    match *substs {\n-        subst::ErasedRegions => {\n-            write!(w, \"e\");\n-        }\n-        subst::NonerasedRegions(ref regions) => {\n-            write!(w, \"n\");\n-            enc_vec_per_param_space(w, cx, regions,\n-                                    |w, cx, &r| enc_region(w, cx, r));\n-        }\n-    }\n-}\n-\n pub fn enc_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, r: ty::Region) {\n     match r {\n         ty::ReLateBound(id, br) => {"}, {"sha": "1d8daf9d86b4ad2129dfe4c71be10a3a9c3f1da0", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -673,9 +673,11 @@ pub fn custom_coerce_unsize_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                                              source_ty: Ty<'tcx>,\n                                              target_ty: Ty<'tcx>)\n                                              -> CustomCoerceUnsized {\n-    let trait_substs = Substs::erased(subst::VecPerParamSpace::new(vec![target_ty],\n-                                                                   vec![source_ty],\n-                                                                   Vec::new()));\n+    let trait_substs = Substs::new(subst::VecPerParamSpace::new(vec![target_ty],\n+                                                                vec![source_ty],\n+                                                                Vec::new()),\n+                                   subst::VecPerParamSpace::empty());\n+\n     let trait_ref = ty::Binder(ty::TraitRef {\n         def_id: ccx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n         substs: ccx.tcx().mk_substs(trait_substs)\n@@ -1824,10 +1826,8 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n     if collector::collecting_debug_information(ccx) {\n-        ccx.record_translation_item_as_generated(TransItem::Fn(Instance {\n-            def: def_id,\n-            params: &param_substs.types\n-        }))\n+        ccx.record_translation_item_as_generated(\n+            TransItem::Fn(Instance::new(def_id, param_substs)));\n     }\n \n     let _icx = push_ctxt(\"trans_closure\");\n@@ -2259,8 +2259,8 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                 // compilation unit that references the item, so it will still get\n                 // translated everywhere it's needed.\n                 for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n-                    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n                     let def_id = tcx.map.local_def_id(item.id);\n+                    let empty_substs = ccx.empty_substs_for_def_id(def_id);\n                     let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n                     trans_fn(ccx, &decl, &body, llfn, empty_substs, item.id);\n                     set_global_section(ccx, llfn, item);\n@@ -2298,8 +2298,8 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                     if sig.generics.ty_params.is_empty() {\n                         let trans_everywhere = attr::requests_inline(&impl_item.attrs);\n                         for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n-                            let empty_substs = tcx.mk_substs(Substs::trans_empty());\n                             let def_id = tcx.map.local_def_id(impl_item.id);\n+                            let empty_substs = ccx.empty_substs_for_def_id(def_id);\n                             let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n                             trans_fn(ccx, &sig.decl, body, llfn, empty_substs, impl_item.id);\n                             update_linkage(ccx, llfn, Some(impl_item.id),\n@@ -2389,7 +2389,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n                     Ok(id) => id,\n                     Err(s) => ccx.sess().fatal(&s)\n                 };\n-                let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+                let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n                 let start_fn = Callee::def(ccx, start_def_id, empty_substs).reify(ccx).val;\n                 let args = {\n                     let opaque_rust_main ="}, {"sha": "1013c5d64b6097039119d3942c98d4ad6b413c38", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -383,7 +383,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n \n     //\n-    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n+    let empty_substs = tcx.mk_substs(Substs::empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n     fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &block_arena);"}, {"sha": "dbabc3f54c594d6be009db4db2f7ff676174be6f", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -144,10 +144,7 @@ fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // duplicate declarations\n     let tcx = ccx.tcx();\n     let substs = tcx.erase_regions(substs);\n-    let instance = Instance {\n-        def: closure_id,\n-        params: &substs.func_substs.types\n-    };\n+    let instance = Instance::new(closure_id, &substs.func_substs);\n \n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n         debug!(\"get_or_create_closure_declaration(): found closure {:?}: {:?}\","}, {"sha": "ab8f7d6bec3d5830ed835bdad8fbb793bb14d6d8", "filename": "src/librustc_trans/trans/collector.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -241,7 +241,7 @@ impl<'tcx> Hash for TransItem<'tcx> {\n             TransItem::Fn(instance) => {\n                 1u8.hash(s);\n                 instance.def.hash(s);\n-                (instance.params as *const _ as usize).hash(s);\n+                (instance.substs as *const _ as usize).hash(s);\n             }\n             TransItem::Static(node_id) => {\n                 2u8.hash(s);\n@@ -285,7 +285,6 @@ fn collect_roots<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             mode: mode,\n             output: &mut roots,\n             enclosing_item: None,\n-            trans_empty_substs: ccx.tcx().mk_substs(Substs::trans_empty()),\n         };\n \n         ccx.tcx().map.krate().visit_all_items(&mut visitor);\n@@ -331,10 +330,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n                 ccx: ccx,\n                 mir: &mir,\n                 output: &mut neighbors,\n-                param_substs: ccx.tcx().mk_substs(Substs {\n-                    types: instance.params.clone(),\n-                    regions: subst::ErasedRegions\n-                })\n+                param_substs: instance.substs\n             };\n \n             visitor.visit_mir(&mir);\n@@ -437,7 +433,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 let exchange_malloc_fn_trans_item =\n                     create_fn_trans_item(self.ccx,\n                                          exchange_malloc_fn_def_id,\n-                                         &Substs::trans_empty(),\n+                                         &Substs::empty(),\n                                          self.param_substs);\n \n                 self.output.push(exchange_malloc_fn_trans_item);\n@@ -569,8 +565,8 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let exchange_free_fn_trans_item =\n             create_fn_trans_item(ccx,\n                                  exchange_free_fn_def_id,\n-                                 &Substs::trans_empty(),\n-                                 &Substs::trans_empty());\n+                                 &Substs::empty(),\n+                                 &Substs::empty());\n \n         output.push(exchange_free_fn_trans_item);\n     }\n@@ -592,7 +588,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                    .unwrap();\n \n         let self_type_substs = ccx.tcx().mk_substs(\n-            Substs::trans_empty().with_self_ty(ty));\n+            Substs::empty().with_self_ty(ty));\n \n         let trait_ref = ty::TraitRef {\n             def_id: drop_trait_def_id,\n@@ -608,7 +604,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let trans_item = create_fn_trans_item(ccx,\n                                                   destructor_did,\n                                                   substs,\n-                                                  &Substs::trans_empty());\n+                                                  &Substs::empty());\n             output.push(trans_item);\n         }\n     }\n@@ -875,10 +871,9 @@ fn create_fn_trans_item<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                            fn_substs);\n     let concrete_substs = ccx.tcx().erase_regions(&concrete_substs);\n \n-    let trans_item = TransItem::Fn(Instance {\n-        def: def_id,\n-        params: &ccx.tcx().mk_substs(concrete_substs).types,\n-    });\n+    let trans_item =\n+        TransItem::Fn(Instance::new(def_id,\n+                                    &ccx.tcx().mk_substs(concrete_substs)));\n \n     return trans_item;\n }\n@@ -914,7 +909,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 Some(create_fn_trans_item(ccx,\n                                                           impl_method.method.def_id,\n                                                           &impl_method.substs,\n-                                                          &Substs::trans_empty()))\n+                                                          &Substs::empty()))\n                             } else {\n                                 None\n                             }\n@@ -938,7 +933,6 @@ struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n     mode: TransItemCollectionMode,\n     output: &'b mut Vec<TransItem<'tcx>>,\n     enclosing_item: Option<&'tcx hir::Item>,\n-    trans_empty_substs: &'tcx Substs<'tcx>\n }\n \n impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n@@ -962,7 +956,6 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                 if self.mode == TransItemCollectionMode::Eager {\n                     create_trans_items_for_default_impls(self.ccx,\n                                                          item,\n-                                                         self.trans_empty_substs,\n                                                          self.output);\n                 }\n             }\n@@ -1049,7 +1042,6 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n \n fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                   item: &'tcx hir::Item,\n-                                                  trans_empty_substs: &'tcx Substs<'tcx>,\n                                                   output: &mut Vec<TransItem<'tcx>>) {\n     match item.node {\n         hir::ItemImpl(_,\n@@ -1098,10 +1090,11 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     }\n \n                     if can_have_local_instance(ccx, default_impl.def_id) {\n+                        let empty_substs = ccx.tcx().mk_substs(ccx.tcx().erase_regions(mth.substs));\n                         let item = create_fn_trans_item(ccx,\n                                                         default_impl.def_id,\n                                                         callee_substs,\n-                                                        trans_empty_substs);\n+                                                        empty_substs);\n                         output.push(item);\n                     }\n                 }\n@@ -1328,7 +1321,7 @@ fn push_instance_as_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      instance: Instance<'tcx>,\n                                      output: &mut String) {\n     push_item_name(ccx, instance.def, output);\n-    push_type_params(ccx, instance.params, &[], output);\n+    push_type_params(ccx, &instance.substs.types, &[], output);\n }\n \n fn def_id_to_string(ccx: &CrateContext, def_id: DefId) -> String {\n@@ -1386,7 +1379,7 @@ impl<'tcx> TransItem<'tcx> {\n             TransItem::Fn(instance) => {\n                 format!(\"Fn({:?}, {})\",\n                          instance.def,\n-                         instance.params as *const _ as usize)\n+                         instance.substs as *const _ as usize)\n             }\n             TransItem::Static(id) => {\n                 format!(\"Static({:?})\", id)"}, {"sha": "7e6b24969100bef944bee105a2e692e8eb398399", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -272,7 +272,7 @@ fn get_const_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                            param_substs: &'tcx Substs<'tcx>)\n                            -> Result<ValueRef, ConstEvalFailure> {\n     let expr = get_const_expr(ccx, def_id, ref_expr, param_substs);\n-    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+    let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n     match get_const_expr_as_global(ccx, expr, ConstQualif::empty(), empty_substs, TrueConst::Yes) {\n         Err(Runtime(err)) => {\n             ccx.tcx().sess.span_err(expr.span, &err.description());\n@@ -1148,7 +1148,7 @@ pub fn trans_static(ccx: &CrateContext,\n         let def_id = ccx.tcx().map.local_def_id(id);\n         let datum = get_static(ccx, def_id);\n \n-        let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+        let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n         let (v, _) = const_expr(\n             ccx,\n             expr,"}, {"sha": "046e05dd0710af2eb152a7a6d32faef19efffd2f", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -28,7 +28,7 @@ use trans::mir::CachedMir;\n use trans::monomorphize::Instance;\n use trans::collector::{TransItem, TransItemState};\n use trans::type_::{Type, TypeNames};\n-use middle::subst::Substs;\n+use middle::subst::{Substs, VecPerParamSpace};\n use middle::ty::{self, Ty, TyCtxt};\n use session::config::NoDebugInfo;\n use session::Session;\n@@ -551,7 +551,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local\n     }\n \n-\n     /// Get a (possibly) different `CrateContext` from the same\n     /// `SharedCrateContext`.\n     pub fn rotate(&self) -> CrateContext<'b, 'tcx> {\n@@ -856,6 +855,21 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n             codegen_items.insert(cgi, TransItemState::NotPredictedButGenerated);\n         }\n     }\n+\n+    /// Given the def-id of some item that has no type parameters, make\n+    /// a suitable \"empty substs\" for it.\n+    pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n+        let scheme = self.tcx().lookup_item_type(item_def_id);\n+        self.empty_substs_for_scheme(&scheme)\n+    }\n+\n+    pub fn empty_substs_for_scheme(&self, scheme: &ty::TypeScheme<'tcx>)\n+                                   -> &'tcx Substs<'tcx> {\n+        assert!(scheme.generics.types.is_empty());\n+        self.tcx().mk_substs(\n+            Substs::new(VecPerParamSpace::empty(),\n+                        scheme.generics.regions.map(|_| ty::ReStatic)))\n+    }\n }\n \n pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'tcx>);"}, {"sha": "fe98fa290211ce69fa100dd6fd9a433ccff316bd", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -176,7 +176,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 hir::ExprPath(..) => {\n                     match bcx.def(expr.id) {\n                         Def::Const(did) | Def::AssociatedConst(did) => {\n-                            let empty_substs = bcx.tcx().mk_substs(Substs::trans_empty());\n+                            let empty_substs = bcx.tcx().mk_substs(Substs::empty());\n                             let const_expr = consts::get_const_expr(bcx.ccx(), did, expr,\n                                                                     empty_substs);\n                             // Temporarily get cleanup scopes out of the way,"}, {"sha": "de4b1ba858a6c21b8e67c37a29bf935a84570657", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -267,7 +267,7 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let _s = StatRecorder::new(ccx, format!(\"drop {:?}\", t));\n \n-    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n+    let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n     fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &arena);\n@@ -358,7 +358,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let trait_ref = ty::Binder(ty::TraitRef {\n         def_id: tcx.lang_items.drop_trait().unwrap(),\n-        substs: tcx.mk_substs(Substs::trans_empty().with_self_ty(t))\n+        substs: tcx.mk_substs(Substs::empty().with_self_ty(t))\n     });\n     let vtbl = match fulfill_obligation(bcx.ccx(), DUMMY_SP, trait_ref) {\n         traits::VtableImpl(data) => data,"}, {"sha": "530b99cba920c1a33c9f8bfdc72c7e7815b6c281", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -70,7 +70,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n                         // performance.\n                         AvailableExternallyLinkage\n                     };\n-                    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n+                    let empty_substs = tcx.mk_substs(Substs::empty());\n                     let def_id = tcx.map.local_def_id(item.id);\n                     let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n                     SetLinkage(llfn, linkage);\n@@ -144,8 +144,8 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n                 let impl_tpt = tcx.lookup_item_type(impl_did);\n                 if impl_tpt.generics.types.is_empty() &&\n                         sig.generics.ty_params.is_empty() {\n-                    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n                     let def_id = tcx.map.local_def_id(impl_item.id);\n+                    let empty_substs = ccx.empty_substs_for_def_id(def_id);\n                     let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n                     trans_fn(ccx,\n                              &sig.decl,"}, {"sha": "9bc07c6cd862679bbe07a19d3083331c3607bbcf", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -1298,7 +1298,7 @@ fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         sig: ty::Binder(sig)\n     });\n     let llfn = declare::define_internal_fn(ccx, name, rust_fn_ty);\n-    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+    let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n     let (fcx, block_arena);\n     block_arena = TypedArena::new();\n     fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &block_arena);"}, {"sha": "ae619ceb30b0113d43f4dd34b40a55d4f9ac8222", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -15,7 +15,7 @@ use back::link;\n use llvm::{ValueRef, get_params};\n use middle::def_id::DefId;\n use middle::infer;\n-use middle::subst::{Subst, Substs};\n+use middle::subst::{FnSpace, Subst, Substs};\n use middle::subst;\n use middle::traits::{self, ProjectionMode};\n use trans::abi::FnType;\n@@ -92,7 +92,7 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, method_ty, \"object_shim\");\n     let llfn = declare::define_internal_fn(ccx, &function_name, method_ty);\n \n-    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n+    let empty_substs = tcx.mk_substs(Substs::empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n     fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &block_arena);\n@@ -268,9 +268,17 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             debug!(\"get_vtable_methods: trait_method_type={:?}\",\n                    trait_method_type);\n \n+            // the method may have some early-bound lifetimes, add\n+            // regions for those\n+            let num_dummy_regions = trait_method_type.generics.regions.len(FnSpace);\n+            let dummy_regions = vec![ty::ReStatic; num_dummy_regions];\n+            let method_substs = substs.clone()\n+                                      .with_method(vec![], dummy_regions);\n+            let method_substs = tcx.mk_substs(method_substs);\n+\n             // The substitutions we have are on the impl, so we grab\n             // the method type from the impl to substitute into.\n-            let mth = get_impl_method(tcx, impl_id, substs, name);\n+            let mth = get_impl_method(tcx, impl_id, method_substs, name);\n \n             debug!(\"get_vtable_methods: mth={:?}\", mth);\n "}, {"sha": "63fb8c5fb5e1c4326dbbf5d550fc1f7bf2518963", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -45,10 +45,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let _icx = push_ctxt(\"monomorphic_fn\");\n \n-    let instance = Instance {\n-        def: fn_id,\n-        params: &psubsts.types\n-    };\n+    let instance = Instance::new(fn_id, psubsts);\n \n     let item_ty = ccx.tcx().lookup_item_type(fn_id).ty;\n \n@@ -179,26 +176,24 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Instance<'tcx> {\n     pub def: DefId,\n-    pub params: &'tcx subst::VecPerParamSpace<Ty<'tcx>>\n+    pub substs: &'tcx Substs<'tcx>,\n }\n \n impl<'tcx> fmt::Display for Instance<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let substs = Substs {\n-            types: self.params.clone(),\n-            regions: subst::ErasedRegions\n-        };\n-        ppaux::parameterized(f, &substs, self.def, ppaux::Ns::Value, &[],\n+        ppaux::parameterized(f, &self.substs, self.def, ppaux::Ns::Value, &[],\n                              |tcx| tcx.lookup_item_type(self.def).generics)\n     }\n }\n \n impl<'tcx> Instance<'tcx> {\n+    pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>)\n+               -> Instance<'tcx> {\n+        assert!(substs.regions.iter().all(|&r| r == ty::ReStatic));\n+        Instance { def: def_id, substs: substs }\n+    }\n     pub fn mono(tcx: &TyCtxt<'tcx>, def_id: DefId) -> Instance<'tcx> {\n-        Instance {\n-            def: def_id,\n-            params: &tcx.mk_substs(Substs::trans_empty()).types\n-        }\n+        Instance::new(def_id, &tcx.mk_substs(Substs::empty()))\n     }\n }\n "}, {"sha": "159ff90b509554d8bc64323b03449ccd7bb0c4b5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -411,7 +411,7 @@ fn create_substs_for_ast_path<'tcx>(\n            decl_generics, self_ty, types_provided,\n            region_substs);\n \n-    assert_eq!(region_substs.regions().len(TypeSpace), decl_generics.regions.len(TypeSpace));\n+    assert_eq!(region_substs.regions.len(TypeSpace), decl_generics.regions.len(TypeSpace));\n     assert!(region_substs.types.is_empty());\n \n     // Convert the type parameters supplied by the user."}, {"sha": "3e59f0ba73a81d205e2da05d9d656010ea1e470f", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -180,7 +180,7 @@ pub fn compare_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n         trait_to_impl_substs\n         .subst(tcx, impl_to_skol_substs)\n         .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n-                     impl_to_skol_substs.regions().get_slice(subst::FnSpace).to_vec());\n+                     impl_to_skol_substs.regions.get_slice(subst::FnSpace).to_vec());\n     debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n            trait_to_skol_substs);\n \n@@ -439,7 +439,7 @@ pub fn compare_const_impl<'tcx>(tcx: &TyCtxt<'tcx>,\n         trait_to_impl_substs\n         .subst(tcx, impl_to_skol_substs)\n         .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n-                     impl_to_skol_substs.regions().get_slice(subst::FnSpace).to_vec());\n+                     impl_to_skol_substs.regions.get_slice(subst::FnSpace).to_vec());\n     debug!(\"compare_const_impl: trait_to_skol_substs={:?}\",\n            trait_to_skol_substs);\n "}, {"sha": "aa4e1d0b52908e8bbf5f9c06e690dd9ce5b8d70e", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -334,7 +334,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     .generics.regions.get_slice(subst::FnSpace));\n \n         let subst::Substs { types, regions } = substs;\n-        let regions = regions.map(|r| r.with_slice(subst::FnSpace, &method_regions));\n+        let regions = regions.with_slice(subst::FnSpace, &method_regions);\n         let mut final_substs = subst::Substs { types: types, regions: regions };\n \n         if num_supplied_types == 0 {"}, {"sha": "5f7f9703b10596fe699cb361446b75c630cc5d1e", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -505,11 +505,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n                            trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n                 assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n-                           trait_ref.substs.regions().get_slice(subst::TypeSpace).len());\n+                           trait_ref.substs.regions.get_slice(subst::TypeSpace).len());\n                 assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n                            trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n                 assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n-                           trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n+                           trait_ref.substs.regions.get_slice(subst::SelfSpace).len());\n             }\n \n             // Because this trait derives from a where-clause, it\n@@ -1194,7 +1194,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // method yet. So create fresh variables here for those too,\n         // if there are any.\n         assert_eq!(substs.types.len(subst::FnSpace), 0);\n-        assert_eq!(substs.regions().len(subst::FnSpace), 0);\n+        assert_eq!(substs.regions.len(subst::FnSpace), 0);\n \n         if self.mode == Mode::Path {\n             return impl_ty;"}, {"sha": "6eb663e6047910c4a0dd4b31232bcacc1d698df4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -4431,7 +4431,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         assert_eq!(substs.types.len(space), type_defs.len(space));\n \n         adjust_region_parameters(fcx, span, space, region_defs, &mut substs);\n-        assert_eq!(substs.regions().len(space), region_defs.len(space));\n+        assert_eq!(substs.regions.len(space), region_defs.len(space));\n     }\n \n     // The things we are substituting into the type should not contain\n@@ -4459,7 +4459,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let impl_scheme = fcx.tcx().lookup_item_type(impl_def_id);\n         assert_eq!(substs.types.len(subst::TypeSpace),\n                    impl_scheme.generics.types.len(subst::TypeSpace));\n-        assert_eq!(substs.regions().len(subst::TypeSpace),\n+        assert_eq!(substs.regions.len(subst::TypeSpace),\n                    impl_scheme.generics.regions.len(subst::TypeSpace));\n \n         let impl_ty = fcx.instantiate_type_scheme(span, &substs, &impl_scheme.ty);\n@@ -4550,11 +4550,11 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         {\n             let region_count = region_defs.len(space);\n-            assert_eq!(substs.regions().len(space), 0);\n+            assert_eq!(substs.regions.len(space), 0);\n             for (i, lifetime) in data.lifetimes.iter().enumerate() {\n                 let r = ast_region_to_region(fcx.tcx(), lifetime);\n                 if i < region_count {\n-                    substs.mut_regions().push(space, r);\n+                    substs.regions.push(space, r);\n                 } else if i == region_count {\n                     span_err!(fcx.tcx().sess, lifetime.span, E0088,\n                         \"too many lifetime parameters provided: \\\n@@ -4563,7 +4563,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         if region_count == 1 {\"\"} else {\"s\"},\n                         data.lifetimes.len(),\n                         if data.lifetimes.len() == 1 {\"\"} else {\"s\"});\n-                    substs.mut_regions().truncate(space, 0);\n+                    substs.regions.truncate(space, 0);\n                     break;\n                 }\n             }\n@@ -4686,15 +4686,15 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         defs: &VecPerParamSpace<ty::RegionParameterDef>,\n         substs: &mut Substs)\n     {\n-        let provided_len = substs.mut_regions().len(space);\n+        let provided_len = substs.regions.len(space);\n         let desired = defs.get_slice(space);\n \n         // Enforced by `push_explicit_parameters_from_segment_to_substs()`.\n         assert!(provided_len <= desired.len());\n \n         // If nothing was provided, just use inference variables.\n         if provided_len == 0 {\n-            substs.mut_regions().replace(\n+            substs.regions.replace(\n                 space,\n                 fcx.infcx().region_vars_for_defs(span, desired));\n             return;\n@@ -4715,7 +4715,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             provided_len,\n             if provided_len == 1 {\"\"} else {\"s\"});\n \n-        substs.mut_regions().replace(\n+        substs.regions.replace(\n             space,\n             fcx.infcx().region_vars_for_defs(span, desired));\n     }"}, {"sha": "fb4870bce87653027c2ab7beb122b719eb8fbe2c", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -1496,7 +1496,7 @@ pub fn substs_wf_in_scope<'a,'tcx>(rcx: &mut Rcx<'a,'tcx>,\n \n     let origin = infer::ParameterInScope(origin, expr_span);\n \n-    for &region in substs.regions() {\n+    for &region in &substs.regions {\n         rcx.fcx.mk_subr(origin.clone(), expr_region, region);\n     }\n \n@@ -1624,7 +1624,7 @@ fn projection_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // edges, which winds up enforcing the same condition.\n     let needs_infer = {\n         projection_ty.trait_ref.substs.types.iter().any(|t| t.needs_infer()) ||\n-            projection_ty.trait_ref.substs.regions().iter().any(|r| r.needs_infer())\n+            projection_ty.trait_ref.substs.regions.iter().any(|r| r.needs_infer())\n     };\n     if env_bounds.is_empty() && needs_infer {\n         debug!(\"projection_must_outlive: no declared bounds\");\n@@ -1633,7 +1633,7 @@ fn projection_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n             type_must_outlive(rcx, origin.clone(), component_ty, region);\n         }\n \n-        for &r in projection_ty.trait_ref.substs.regions() {\n+        for &r in &projection_ty.trait_ref.substs.regions {\n             rcx.fcx.mk_subr(origin.clone(), region, r);\n         }\n \n@@ -1650,7 +1650,7 @@ fn projection_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     if !env_bounds.is_empty() && env_bounds[1..].iter().all(|b| *b == env_bounds[0]) {\n         let unique_bound = env_bounds[0];\n         debug!(\"projection_must_outlive: unique declared bound = {:?}\", unique_bound);\n-        if projection_ty.trait_ref.substs.regions()\n+        if projection_ty.trait_ref.substs.regions\n                                          .iter()\n                                          .any(|r| env_bounds.contains(r))\n         {"}, {"sha": "4446063e0c7bc537e0958875b849bf01cd367062", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -81,7 +81,7 @@ fn parameters_for_type_shallow<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n }\n \n fn parameters_for_regions_in_substs(substs: &subst::Substs) -> Vec<Parameter> {\n-    substs.regions()\n+    substs.regions\n           .iter()\n           .filter_map(|r| parameters_for_region(r))\n           .collect()"}, {"sha": "5c74e9096f3a7ec3be7546d35d39993ef83f3554", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -477,7 +477,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.declared_variance(p.def_id, def_id,\n                                        RegionParam, p.space, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_r = *substs.regions().get(p.space, p.index as usize);\n+            let substs_r = *substs.regions.get(p.space, p.index as usize);\n             self.add_constraints_from_region(generics, substs_r, variance_i);\n         }\n     }"}, {"sha": "15aeca9204a642e4ef08d68bb00375ac21aea206", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a71687ef1a9fa5665944608d5bad58d98a9684/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d7a71687ef1a9fa5665944608d5bad58d98a9684", "patch": "@@ -606,7 +606,7 @@ impl<'tcx> Clean<(Vec<TyParamBound>, Vec<TypeBinding>)> for ty::ExistentialBound\n \n fn external_path_params(cx: &DocContext, trait_did: Option<DefId>,\n                         bindings: Vec<TypeBinding>, substs: &subst::Substs) -> PathParameters {\n-    let lifetimes = substs.regions().get_slice(subst::TypeSpace)\n+    let lifetimes = substs.regions.get_slice(subst::TypeSpace)\n                     .iter()\n                     .filter_map(|v| v.clean(cx))\n                     .collect();\n@@ -739,7 +739,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n impl<'tcx> Clean<Option<Vec<TyParamBound>>> for subst::Substs<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Option<Vec<TyParamBound>> {\n         let mut v = Vec::new();\n-        v.extend(self.regions().iter().filter_map(|r| r.clean(cx)).map(RegionBound));\n+        v.extend(self.regions.iter().filter_map(|r| r.clean(cx)).map(RegionBound));\n         v.extend(self.types.iter().map(|t| TraitBound(PolyTrait {\n             trait_: t.clean(cx),\n             lifetimes: vec![]"}]}