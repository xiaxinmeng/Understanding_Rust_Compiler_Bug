{"sha": "37e998696f840ffea047efc50814819422750c20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3ZTk5ODY5NmY4NDBmZmVhMDQ3ZWZjNTA4MTQ4MTk0MjI3NTBjMjA=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-02-06T07:27:33Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-02-06T22:37:56Z"}, "message": "get rid of implicit vec copies in treemap iterator\n\nEach call to next() was doing a copy rather than a move. There's\ncurrently no way for this to be a method that uses &mut self, so it has\nto be a free function. Closes #4763.", "tree": {"sha": "e9a24d61f6e6025712006ca80cf224c5df366220", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9a24d61f6e6025712006ca80cf224c5df366220"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37e998696f840ffea047efc50814819422750c20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37e998696f840ffea047efc50814819422750c20", "html_url": "https://github.com/rust-lang/rust/commit/37e998696f840ffea047efc50814819422750c20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37e998696f840ffea047efc50814819422750c20/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b6c26b4e44e05717cc9a1d0041f44fb4df4d102", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b6c26b4e44e05717cc9a1d0041f44fb4df4d102", "html_url": "https://github.com/rust-lang/rust/commit/5b6c26b4e44e05717cc9a1d0041f44fb4df4d102"}], "stats": {"total": 136, "additions": 67, "deletions": 69}, "files": [{"sha": "610f2f5a59c2d19a51916b4a4b92833ab4a3a2f8", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 67, "deletions": 69, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/37e998696f840ffea047efc50814819422750c20/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37e998696f840ffea047efc50814819422750c20/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=37e998696f840ffea047efc50814819422750c20", "patch": "@@ -49,8 +49,8 @@ impl <K: Eq Ord, V: Eq> TreeMap<K, V>: Eq {\n             let mut y = other.iter();\n             for self.len().times {\n                 unsafe { // unsafe as a purity workaround\n-                    x = x.next();\n-                    y = y.next();\n+                    map_next(&mut x);\n+                    map_next(&mut y);\n                     // FIXME: #4492 (ICE), x.get() == y.get()\n                     let (x1, x2) = x.get().unwrap();\n                     let (y1, y2) = y.get().unwrap();\n@@ -74,8 +74,8 @@ pure fn lt<K: Ord, V>(a: &TreeMap<K, V>, b: &TreeMap<K, V>) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     for uint::min(a_len, b_len).times {\n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            map_next(&mut x);\n+            map_next(&mut y);\n             let (key_a,_) = x.get().unwrap();\n             let (key_b,_) = y.get().unwrap();\n             if *key_a < *key_b { return true; }\n@@ -210,32 +210,30 @@ impl <K: Ord, V> TreeMapIterator<K, V> {\n     // Returns the current node, or None if this iterator is at the end.\n     fn get(&const self) -> Option<(&self/K, &self/V)> {\n         match self.current {\n-            Some(res) => Some((&res.key, &res.value)),\n-            None => None\n+          Some(res) => Some((&res.key, &res.value)),\n+          None => None\n         }\n     }\n+}\n \n-    /// Advance the iterator to the next node (in order). If this iterator\n-    /// is finished, does nothing.\n-    fn next(self) -> TreeMapIterator/&self<K, V> {\n-        let mut this = self;\n-        while !this.stack.is_empty() || this.node.is_some() {\n-            match *this.node {\n-              Some(ref x) => {\n-                this.stack.push(x);\n-                this.node = &x.left;\n-              }\n-              None => {\n-                let res = this.stack.pop();\n-                this.node = &res.right;\n-                this.current = Some(res);\n-                return this;\n-              }\n-            }\n+/// Advance the iterator to the next node (in order). If this iterator\n+/// is finished, does nothing.\n+fn map_next<K: Ord, V>(iter: &mut TreeMapIterator/&a<K, V>) {\n+    while !iter.stack.is_empty() || iter.node.is_some() {\n+        match *iter.node {\n+          Some(ref x) => {\n+            iter.stack.push(x);\n+            iter.node = &x.left;\n+          }\n+          None => {\n+            let res = iter.stack.pop();\n+            iter.node = &res.right;\n+            iter.current = Some(res);\n+            return;\n+          }\n         }\n-        this.current = None;\n-        return this;\n     }\n+    iter.current = None;\n }\n \n pub struct TreeSet<T> {\n@@ -297,18 +295,18 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n                 if a1 < b1 {\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else if b1 < a1 {\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 } else {\n                     return false;\n@@ -328,8 +326,8 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n             while b.is_some() {\n@@ -345,10 +343,10 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n                 }\n \n                 if !(a1 < b1) {\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n-                x = x.next();\n+                set_next(&mut x);\n                 a = x.get();\n             }\n         }\n@@ -361,15 +359,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { x = x.next(); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x); x.get() } else { None }\n                     }\n                 }\n \n@@ -378,11 +376,11 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else {\n-                    if !(b1 < a1) { x = x.next(); a = x.get() }\n-                    y = y.next();\n+                    if !(b1 < a1) { set_next(&mut x); a = x.get() }\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n             }\n@@ -396,15 +394,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { x.next(); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x); x.get() } else { None }\n                     }\n                 }\n \n@@ -413,21 +411,21 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else {\n                     if b1 < a1 {\n                         if !f(b1) { return }\n                     } else {\n-                        x = x.next();\n+                        set_next(&mut x);\n                         a = x.get();\n                     }\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n             }\n             do b.while_some |b1| {\n-                if f(b1) { y = y.next(); y.get() } else { None }\n+                if f(b1) { set_next(&mut y); y.get() } else { None }\n             }\n         }\n     }\n@@ -438,22 +436,22 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n                 if a1 < b1 {\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else {\n                     if !(b1 < a1) {\n                         if !f(a1) { return }\n                     }\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n             }\n@@ -466,15 +464,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { x = x.next(); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x); x.get() } else { None }\n                     }\n                 }\n \n@@ -483,15 +481,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n \n                 if b1 < a1 {\n                     if !f(b1) { return }\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 } else {\n                     if !f(a1) { return }\n                     if !(a1 < b1) {\n-                        y = y.next();\n+                        set_next(&mut y);\n                         b = y.get()\n                     }\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 }\n             }\n@@ -524,16 +522,16 @@ impl <T: Ord> TreeSetIterator<T> {\n     /// Returns the current node, or None if this iterator is at the end.\n     fn get(&const self) -> Option<&self/T> {\n         match self.iter.get() {\n-            None => None,\n-            Some((k, _)) => Some(k)\n+          None => None,\n+          Some((k, _)) => Some(k)\n         }\n     }\n+}\n \n-    /// Advance the iterator to the next node (in order). If this iterator is\n-    /// finished, does nothing.\n-    fn next(self) -> TreeSetIterator/&self<T> {\n-        TreeSetIterator { iter: self.iter.next() }\n-    }\n+/// Advance the iterator to the next node (in order). If this iterator is\n+/// finished, does nothing.\n+fn set_next<T: Ord>(iter: &mut TreeSetIterator/&a<T>) {\n+    map_next(&mut iter.iter);\n }\n \n // Nodes keep track of their level in the tree, starting at 1 in the\n@@ -967,18 +965,18 @@ mod test_treemap {\n \n         // FIXME: #4492 (ICE): iter.next() == Some((&x1, &y1))\n \n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x1, &y1);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x2, &y2);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x3, &y3);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x4, &y4);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x5, &y5);\n \n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().is_none();\n     }\n }"}]}