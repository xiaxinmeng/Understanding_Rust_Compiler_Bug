{"sha": "06c94ee79b7baa8bebd039a019ce6adb5ea6a24f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2Yzk0ZWU3OWI3YmFhOGJlYmQwMzlhMDE5Y2U2YWRiNWVhNmEyNGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-15T20:06:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-15T20:06:49Z"}, "message": "Auto merge of #64491 - Centril:rollup-21wkl69, r=Centril\n\nRollup of 3 pull requests\n\nSuccessful merges:\n\n - #63872 (Document platform-specific behavior of the iterator returned by std::fs::read_dir)\n - #64250 (save-analysis: Nest typeck tables when processing functions/methods)\n - #64472 (Don't mark expression with attributes as not needing parentheses)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "f01be2bf8919ec224ce79a891326534a3048f0fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f01be2bf8919ec224ce79a891326534a3048f0fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f", "html_url": "https://github.com/rust-lang/rust/commit/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96d07e0ac9f0c56b95a2561c6cedac0b23a5d2a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/96d07e0ac9f0c56b95a2561c6cedac0b23a5d2a3", "html_url": "https://github.com/rust-lang/rust/commit/96d07e0ac9f0c56b95a2561c6cedac0b23a5d2a3"}, {"sha": "0592d137574189e500438aa300da64f0b1089a60", "url": "https://api.github.com/repos/rust-lang/rust/commits/0592d137574189e500438aa300da64f0b1089a60", "html_url": "https://github.com/rust-lang/rust/commit/0592d137574189e500438aa300da64f0b1089a60"}], "stats": {"total": 241, "additions": 140, "deletions": 101}, "files": [{"sha": "0155803e30580ace326f457a2559e75a2ef5836b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=06c94ee79b7baa8bebd039a019ce6adb5ea6a24f", "patch": "@@ -205,26 +205,24 @@ pub struct LocalTableInContext<'a, V> {\n fn validate_hir_id_for_typeck_tables(local_id_root: Option<DefId>,\n                                      hir_id: hir::HirId,\n                                      mut_access: bool) {\n-    if cfg!(debug_assertions) {\n-        if let Some(local_id_root) = local_id_root {\n-            if hir_id.owner != local_id_root.index {\n-                ty::tls::with(|tcx| {\n-                    bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n-                          TypeckTables with local_id_root {:?}\",\n-                         tcx.hir().node_to_string(hir_id),\n-                         DefId::local(hir_id.owner),\n-                         local_id_root)\n-                });\n-            }\n-        } else {\n-            // We use \"Null Object\" TypeckTables in some of the analysis passes.\n-            // These are just expected to be empty and their `local_id_root` is\n-            // `None`. Therefore we cannot verify whether a given `HirId` would\n-            // be a valid key for the given table. Instead we make sure that\n-            // nobody tries to write to such a Null Object table.\n-            if mut_access {\n-                bug!(\"access to invalid TypeckTables\")\n-            }\n+    if let Some(local_id_root) = local_id_root {\n+        if hir_id.owner != local_id_root.index {\n+            ty::tls::with(|tcx| {\n+                bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n+                        TypeckTables with local_id_root {:?}\",\n+                        tcx.hir().node_to_string(hir_id),\n+                        DefId::local(hir_id.owner),\n+                        local_id_root)\n+            });\n+        }\n+    } else {\n+        // We use \"Null Object\" TypeckTables in some of the analysis passes.\n+        // These are just expected to be empty and their `local_id_root` is\n+        // `None`. Therefore we cannot verify whether a given `HirId` would\n+        // be a valid key for the given table. Instead we make sure that\n+        // nobody tries to write to such a Null Object table.\n+        if mut_access {\n+            bug!(\"access to invalid TypeckTables\")\n         }\n     }\n }"}, {"sha": "c3975098351af9f83fed30a3f7d5587aa88905c5", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=06c94ee79b7baa8bebd039a019ce6adb5ea6a24f", "patch": "@@ -370,7 +370,8 @@ impl UnusedParens {\n                                      right_pos: Option<BytePos>) {\n         match value.node {\n             ast::ExprKind::Paren(ref inner) => {\n-                if !Self::is_expr_parens_necessary(inner, followed_by_block) {\n+                if !Self::is_expr_parens_necessary(inner, followed_by_block) &&\n+                    value.attrs.is_empty() {\n                     let expr_text = if let Ok(snippet) = cx.sess().source_map()\n                         .span_to_snippet(value.span) {\n                             snippet"}, {"sha": "55f6b91e7143106e336086ffb4ef0142f6969222", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 63, "deletions": 56, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=06c94ee79b7baa8bebd039a019ce6adb5ea6a24f", "patch": "@@ -130,6 +130,10 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         self.save_ctxt.span_from_span(span)\n     }\n \n+    fn lookup_def_id(&self, ref_id: NodeId) -> Option<DefId> {\n+        self.save_ctxt.lookup_def_id(ref_id)\n+    }\n+\n     pub fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n         let source_file = self.tcx.sess.local_crate_source_file.as_ref();\n         let crate_root = source_file.map(|source_file| {\n@@ -223,13 +227,6 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn lookup_def_id(&self, ref_id: NodeId) -> Option<DefId> {\n-        match self.save_ctxt.get_path_res(ref_id) {\n-            Res::PrimTy(..) | Res::SelfTy(..) | Res::Err => None,\n-            def => Some(def.def_id()),\n-        }\n-    }\n-\n     fn process_formals(&mut self, formals: &'l [ast::Param], qualname: &str) {\n         for arg in formals {\n             self.visit_pat(&arg.pat);\n@@ -283,36 +280,32 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     ) {\n         debug!(\"process_method: {}:{}\", id, ident);\n \n-        if let Some(mut method_data) = self.save_ctxt.get_method_data(id, ident, span) {\n-            let sig_str = crate::make_signature(&sig.decl, &generics);\n-            if body.is_some() {\n-                self.nest_tables(\n-                    id,\n-                    |v| v.process_formals(&sig.decl.inputs, &method_data.qualname),\n-                );\n-            }\n+        let hir_id = self.tcx.hir().node_to_hir_id(id);\n+        self.nest_tables(id, |v| {\n+            if let Some(mut method_data) = v.save_ctxt.get_method_data(id, ident, span) {\n+                v.process_formals(&sig.decl.inputs, &method_data.qualname);\n+                v.process_generic_params(&generics, &method_data.qualname, id);\n \n-            self.process_generic_params(&generics, &method_data.qualname, id);\n+                method_data.value = crate::make_signature(&sig.decl, &generics);\n+                method_data.sig = sig::method_signature(id, ident, generics, sig, &v.save_ctxt);\n \n-            method_data.value = sig_str;\n-            method_data.sig = sig::method_signature(id, ident, generics, sig, &self.save_ctxt);\n-            let hir_id = self.tcx.hir().node_to_hir_id(id);\n-            self.dumper.dump_def(&access_from_vis!(self.save_ctxt, vis, hir_id), method_data);\n-        }\n+                v.dumper.dump_def(&access_from_vis!(v.save_ctxt, vis, hir_id), method_data);\n+            }\n \n-        // walk arg and return types\n-        for arg in &sig.decl.inputs {\n-            self.visit_ty(&arg.ty);\n-        }\n+            // walk arg and return types\n+            for arg in &sig.decl.inputs {\n+                v.visit_ty(&arg.ty);\n+            }\n \n-        if let ast::FunctionRetTy::Ty(ref ret_ty) = sig.decl.output {\n-            self.visit_ty(ret_ty);\n-        }\n+            if let ast::FunctionRetTy::Ty(ref ret_ty) = sig.decl.output {\n+                v.visit_ty(ret_ty);\n+            }\n \n-        // walk the fn body\n-        if let Some(body) = body {\n-            self.nest_tables(id, |v| v.visit_block(body));\n-        }\n+            // walk the fn body\n+            if let Some(body) = body {\n+                v.visit_block(body);\n+            }\n+        });\n     }\n \n     fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n@@ -377,26 +370,31 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         ty_params: &'l ast::Generics,\n         body: &'l ast::Block,\n     ) {\n-        if let Some(fn_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(fn_data, DefData, item.span);\n-            self.nest_tables(\n-                item.id,\n-                |v| v.process_formals(&decl.inputs, &fn_data.qualname),\n-            );\n-            self.process_generic_params(ty_params, &fn_data.qualname, item.id);\n-            let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, item, hir_id), fn_data);\n-        }\n+        let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+        self.nest_tables(item.id, |v| {\n+            if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n+                down_cast_data!(fn_data, DefData, item.span);\n+                v.process_formals(&decl.inputs, &fn_data.qualname);\n+                v.process_generic_params(ty_params, &fn_data.qualname, item.id);\n \n-        for arg in &decl.inputs {\n-            self.visit_ty(&arg.ty);\n-        }\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item, hir_id), fn_data);\n+            }\n \n-        if let ast::FunctionRetTy::Ty(ref ret_ty) = decl.output {\n-            self.visit_ty(&ret_ty);\n-        }\n+            for arg in &decl.inputs {\n+                v.visit_ty(&arg.ty)\n+            }\n+\n+            if let ast::FunctionRetTy::Ty(ref ret_ty) = decl.output {\n+                if let ast::TyKind::ImplTrait(..) = ret_ty.node {\n+                    // FIXME: Opaque type desugaring prevents us from easily\n+                    // processing trait bounds. See `visit_ty` for more details.\n+                } else {\n+                    v.visit_ty(&ret_ty);\n+                }\n+            }\n \n-        self.nest_tables(item.id, |v| v.visit_block(&body));\n+            v.visit_block(&body);\n+        });\n     }\n \n     fn process_static_or_const_item(\n@@ -1113,11 +1111,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 // FIXME: uses of the assoc type should ideally point to this\n                 // 'def' and the name here should be a ref to the def in the\n                 // trait.\n-                for bound in bounds.iter() {\n-                    if let ast::GenericBound::Trait(trait_ref, _) = bound {\n-                        self.process_path(trait_ref.trait_ref.ref_id, &trait_ref.trait_ref.path)\n-                    }\n-                }\n+                self.process_bounds(&bounds);\n             }\n             ast::ImplItemKind::Macro(_) => {}\n         }\n@@ -1364,10 +1358,10 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 self.visit_ty(&ty);\n                 self.process_generic_params(ty_params, &qualname, item.id);\n             }\n-            OpaqueTy(ref _bounds, ref ty_params) => {\n+            OpaqueTy(ref bounds, ref ty_params) => {\n                 let qualname = format!(\"::{}\",\n                     self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n-                // FIXME do something with _bounds\n+\n                 let value = String::new();\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n@@ -1393,6 +1387,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                     );\n                 }\n \n+                self.process_bounds(bounds);\n                 self.process_generic_params(ty_params, &qualname, item.id);\n             }\n             Mac(_) => (),\n@@ -1449,6 +1444,18 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 self.visit_ty(element);\n                 self.nest_tables(length.id, |v| v.visit_expr(&length.value));\n             }\n+            ast::TyKind::ImplTrait(id, ref bounds) => {\n+                // FIXME: As of writing, the opaque type lowering introduces\n+                // another DefPath scope/segment (used to declare the resulting\n+                // opaque type item).\n+                // However, the synthetic scope does *not* have associated\n+                // typeck tables, which means we can't nest it and we fire an\n+                // assertion when resolving the qualified type paths in trait\n+                // bounds...\n+                // This will panic if called on return type `impl Trait`, which\n+                // we guard against in `process_fn`.\n+                self.nest_tables(id, |v| v.process_bounds(bounds));\n+            }\n             _ => visit::walk_ty(self, t),\n         }\n     }"}, {"sha": "055ccf6c2c4f83c3270fbb4d71dbf3f00f33f481", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=06c94ee79b7baa8bebd039a019ce6adb5ea6a24f", "patch": "@@ -312,7 +312,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     let impl_id = self.next_impl_id();\n                     let span = self.span_from_span(sub_span);\n \n-                    let type_data = self.lookup_ref_id(typ.id);\n+                    let type_data = self.lookup_def_id(typ.id);\n                     type_data.map(|type_data| {\n                         Data::RelationData(Relation {\n                             kind: RelationKind::Impl {\n@@ -322,7 +322,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                             from: id_from_def_id(type_data),\n                             to: trait_ref\n                                 .as_ref()\n-                                .and_then(|t| self.lookup_ref_id(t.ref_id))\n+                                .and_then(|t| self.lookup_def_id(t.ref_id))\n                                 .map(id_from_def_id)\n                                 .unwrap_or_else(|| null_id()),\n                         },\n@@ -495,7 +495,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_trait_ref_data(&self, trait_ref: &ast::TraitRef) -> Option<Ref> {\n-        self.lookup_ref_id(trait_ref.ref_id).and_then(|def_id| {\n+        self.lookup_def_id(trait_ref.ref_id).and_then(|def_id| {\n             let span = trait_ref.path.span;\n             if generated_code(span) {\n                 return None;\n@@ -870,7 +870,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         })\n     }\n \n-    fn lookup_ref_id(&self, ref_id: NodeId) -> Option<DefId> {\n+    fn lookup_def_id(&self, ref_id: NodeId) -> Option<DefId> {\n         match self.get_path_res(ref_id) {\n             Res::PrimTy(_) | Res::SelfTy(..) | Res::Err => None,\n             def => Some(def.def_id()),"}, {"sha": "b5265fe369e831a2a7a736f0ac2fabc5ef406cd2", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=06c94ee79b7baa8bebd039a019ce6adb5ea6a24f", "patch": "@@ -1956,7 +1956,8 @@ pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// # Platform-specific behavior\n ///\n /// This function currently corresponds to the `opendir` function on Unix\n-/// and the `FindFirstFile` function on Windows.\n+/// and the `FindFirstFile` function on Windows. Advancing the iterator\n+/// currently corresponds to `readdir` on Unix and `FindNextFile` on Windows.\n /// Note that, this [may change in the future][changes].\n ///\n /// [changes]: ../io/index.html#platform-specific-behavior"}, {"sha": "7dcbdd0863cbd9f2a5c07010632ef2530e30d45d", "filename": "src/test/ui/lint/issue-54538-unused-parens-lint.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.rs?ref=06c94ee79b7baa8bebd039a019ce6adb5ea6a24f", "patch": "@@ -1,4 +1,4 @@\n-#![feature(box_patterns)]\n+#![feature(box_patterns, stmt_expr_attributes)]\n \n #![feature(or_patterns)]\n //~^ WARN the feature `or_patterns` is incomplete\n@@ -17,6 +17,10 @@ fn lint_on_top_level() {\n     let _ = |(a): u8| 0; //~ ERROR unnecessary parentheses around pattern\n }\n \n+fn _no_lint_attr() {\n+    let _x = #[allow(dead_code)] (1 + 2);\n+}\n+\n // Don't lint in these cases (#64106).\n fn or_patterns_no_lint() {\n     match Box::new(0) {"}, {"sha": "675dd4f07def63a3b943ba6070a01f50c8892a09", "filename": "src/test/ui/lint/issue-54538-unused-parens-lint.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.stderr?ref=06c94ee79b7baa8bebd039a019ce6adb5ea6a24f", "patch": "@@ -49,109 +49,109 @@ LL |     let _ = |(a): u8| 0;\n    |              ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:41:12\n+  --> $DIR/issue-54538-unused-parens-lint.rs:45:12\n    |\n LL |     if let (0 | 1) = 0 {}\n    |            ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:42:13\n+  --> $DIR/issue-54538-unused-parens-lint.rs:46:13\n    |\n LL |     if let ((0 | 1),) = (0,) {}\n    |             ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:43:13\n+  --> $DIR/issue-54538-unused-parens-lint.rs:47:13\n    |\n LL |     if let [(0 | 1)] = [0] {}\n    |             ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:44:16\n+  --> $DIR/issue-54538-unused-parens-lint.rs:48:16\n    |\n LL |     if let 0 | (1 | 2) = 0 {}\n    |                ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:46:15\n+  --> $DIR/issue-54538-unused-parens-lint.rs:50:15\n    |\n LL |     if let TS((0 | 1)) = TS(0) {}\n    |               ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:48:20\n+  --> $DIR/issue-54538-unused-parens-lint.rs:52:20\n    |\n LL |     if let NS { f: (0 | 1) } = (NS { f: 0 }) {}\n    |                    ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:58:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:62:9\n    |\n LL |         (_) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:59:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:63:9\n    |\n LL |         (y) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:60:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:64:9\n    |\n LL |         (ref r) => {}\n    |         ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:61:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:65:9\n    |\n LL |         (e @ 1...2) => {}\n    |         ^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:67:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:71:9\n    |\n LL |         (e @ &(1...2)) => {}\n    |         ^^^^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:68:10\n+  --> $DIR/issue-54538-unused-parens-lint.rs:72:10\n    |\n LL |         &(_) => {}\n    |          ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:79:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:83:9\n    |\n LL |         (_) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:80:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:84:9\n    |\n LL |         (y) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:81:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:85:9\n    |\n LL |         (ref r) => {}\n    |         ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:82:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:86:9\n    |\n LL |         (e @ 1..=2) => {}\n    |         ^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:88:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:92:9\n    |\n LL |         (e @ &(1..=2)) => {}\n    |         ^^^^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:89:10\n+  --> $DIR/issue-54538-unused-parens-lint.rs:93:10\n    |\n LL |         &(_) => {}\n    |          ^^^ help: remove these parentheses"}, {"sha": "92e85884f664dbcc43f88023f439d802f08e6009", "filename": "src/test/ui/save-analysis/issue-63663.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-63663.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c94ee79b7baa8bebd039a019ce6adb5ea6a24f/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-63663.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-63663.rs?ref=06c94ee79b7baa8bebd039a019ce6adb5ea6a24f", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+// compile-flags: -Zsave-analysis\n+\n+pub trait Trait {\n+    type Assoc;\n+}\n+\n+pub struct A;\n+\n+trait Generic<T> {}\n+impl<T> Generic<T> for () {}\n+\n+// Don't ICE when resolving type paths in return type `impl Trait`\n+fn assoc_in_opaque_type_bounds<U: Trait>() -> impl Generic<U::Assoc> {}\n+\n+// Check that this doesn't ICE when processing associated const in formal\n+// argument and return type of functions defined inside function/method scope.\n+pub fn func() {\n+    fn _inner1<U: Trait>(_: U::Assoc) {}\n+    fn _inner2<U: Trait>() -> U::Assoc { unimplemented!() }\n+\n+    impl A {\n+        fn _inner1<U: Trait>(self, _: U::Assoc) {}\n+        fn _inner2<U: Trait>(self) -> U::Assoc { unimplemented!() }\n+    }\n+}\n+\n+fn main() {}"}]}