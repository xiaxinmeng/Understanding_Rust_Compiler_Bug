{"sha": "ac60db231c96738b874fb31a755ef49a0d71926c", "node_id": "C_kwDOAAsO6NoAKGFjNjBkYjIzMWM5NjczOGI4NzRmYjMxYTc1NWVmNDlhMGQ3MTkyNmM", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-03-09T12:56:12Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-02T10:20:59Z"}, "message": "do use ty::Const in patterns and abstract consts", "tree": {"sha": "cbd25c042a5066e64f6cf883613a94062dd2a7ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbd25c042a5066e64f6cf883613a94062dd2a7ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac60db231c96738b874fb31a755ef49a0d71926c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac60db231c96738b874fb31a755ef49a0d71926c", "html_url": "https://github.com/rust-lang/rust/commit/ac60db231c96738b874fb31a755ef49a0d71926c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac60db231c96738b874fb31a755ef49a0d71926c/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b38077ea0b9021cf69401289f23951f96d996129", "url": "https://api.github.com/repos/rust-lang/rust/commits/b38077ea0b9021cf69401289f23951f96d996129", "html_url": "https://github.com/rust-lang/rust/commit/b38077ea0b9021cf69401289f23951f96d996129"}], "stats": {"total": 232, "additions": 105, "deletions": 127}, "files": [{"sha": "b970ee0186c2e745e921b9f33c088e63f9227524", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=ac60db231c96738b874fb31a755ef49a0d71926c", "patch": "@@ -661,7 +661,7 @@ pub enum PatKind<'tcx> {\n     /// * Opaque constants, that must not be matched structurally. So anything that does not derive\n     ///   `PartialEq` and `Eq`.\n     Constant {\n-        value: mir::ConstantKind<'tcx>,\n+        value: ty::Const<'tcx>,\n     },\n \n     Range(PatRange<'tcx>),\n@@ -691,8 +691,8 @@ pub enum PatKind<'tcx> {\n \n #[derive(Copy, Clone, Debug, PartialEq, HashStable)]\n pub struct PatRange<'tcx> {\n-    pub lo: mir::ConstantKind<'tcx>,\n-    pub hi: mir::ConstantKind<'tcx>,\n+    pub lo: ty::Const<'tcx>,\n+    pub hi: ty::Const<'tcx>,\n     pub end: RangeEnd,\n }\n \n@@ -736,7 +736,11 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n                         Some(adt_def.variant(variant_index))\n                     }\n                     _ => self.ty.ty_adt_def().and_then(|adt| {\n-                        if !adt.is_enum() { Some(adt.non_enum_variant()) } else { None }\n+                        if !adt.is_enum() {\n+                            Some(adt.non_enum_variant())\n+                        } else {\n+                            None\n+                        }\n                     }),\n                 };\n "}, {"sha": "e02ed414574b43f41bc38d6314694e23e9faf57d", "filename": "compiler/rustc_middle/src/thir/abstract_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs?ref=ac60db231c96738b874fb31a755ef49a0d71926c", "patch": "@@ -22,7 +22,7 @@ pub enum CastKind {\n /// A node of an `AbstractConst`.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n pub enum Node<'tcx> {\n-    Leaf(mir::ConstantKind<'tcx>),\n+    Leaf(ty::Const<'tcx>),\n     Binop(mir::BinOp, NodeId, NodeId),\n     UnaryOp(mir::UnOp, NodeId),\n     FunctionCall(NodeId, &'tcx [NodeId]),"}, {"sha": "abf9696454e8effd2f446bca7cf78348b456d89c", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=ac60db231c96738b874fb31a755ef49a0d71926c", "patch": "@@ -94,13 +94,8 @@ pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Exp\n                 visitor.visit_expr(&visitor.thir()[value])\n             }\n         }\n-<<<<<<< HEAD\n         ConstBlock { did: _, substs: _ } => {}\n         Repeat { value, count: _ } => {\n-=======\n-        ConstBlock { value } => visitor.visit_constant(value),\n-        Repeat { value, count } => {\n->>>>>>> 6064f16d846 (change thir to use mir::ConstantKind instead of ty::Const)\n             visitor.visit_expr(&visitor.thir()[value]);\n         }\n         Array { ref fields } | Tuple { ref fields } => {"}, {"sha": "777ab7739f08b491e10971398e558db9632ada7c", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=ac60db231c96738b874fb31a755ef49a0d71926c", "patch": "@@ -76,7 +76,11 @@ static_assert_size!(ConstKind<'_>, 40);\n impl<'tcx> ConstKind<'tcx> {\n     #[inline]\n     pub fn try_to_value(self) -> Option<ConstValue<'tcx>> {\n-        if let ConstKind::Value(val) = self { Some(val) } else { None }\n+        if let ConstKind::Value(val) = self {\n+            Some(val)\n+        } else {\n+            None\n+        }\n     }\n \n     #[inline]\n@@ -126,6 +130,7 @@ impl<'tcx> ConstKind<'tcx> {\n     #[inline]\n     /// Tries to evaluate the constant if it is `Unevaluated`. If that isn't possible or necessary\n     /// return `None`.\n+    // FIXME(@lcnr): Completely rework the evaluation/normalization system for `ty::Const` once valtrees are merged.\n     pub fn try_eval(\n         self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "219d101aa7ccfa34b9b95eaca11eb9bad0e94b99", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=ac60db231c96738b874fb31a755ef49a0d71926c", "patch": "@@ -964,13 +964,13 @@ enum TestKind<'tcx> {\n         ///\n         /// For `bool` we always generate two edges, one for `true` and one for\n         /// `false`.\n-        options: FxIndexMap<ConstantKind<'tcx>, u128>,\n+        options: FxIndexMap<ty::Const<'tcx>, u128>,\n     },\n \n     /// Test for equality with value, possibly after an unsizing coercion to\n     /// `ty`,\n     Eq {\n-        value: ConstantKind<'tcx>,\n+        value: ty::Const<'tcx>,\n         // Integer types are handled by `SwitchInt`, and constants with ADT\n         // types are converted back into patterns, so this can only be `&str`,\n         // `&[T]`, `f32` or `f64`."}, {"sha": "7f53d9dd70502ad10b0f567efdd81d9e77a9f3fa", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=ac60db231c96738b874fb31a755ef49a0d71926c", "patch": "@@ -228,7 +228,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     _ => (None, 0),\n                 };\n                 if let Some((min, max, sz)) = range {\n-                    if let (Some(lo), Some(hi)) = (lo.try_to_bits(sz), hi.try_to_bits(sz)) {\n+                    if let (Some(lo), Some(hi)) =\n+                        (lo.val().try_to_bits(sz), hi.val().try_to_bits(sz))\n+                    {\n                         // We want to compare ranges numerically, but the order of the bitwise\n                         // representation of signed integers does not match their numeric order.\n                         // Thus, to correct the ordering, we need to shift the range of signed"}, {"sha": "806c260d110ea712e8a023b9dbd3d897069c755e", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=ac60db231c96738b874fb31a755ef49a0d71926c", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         test_place: &PlaceBuilder<'tcx>,\n         candidate: &Candidate<'pat, 'tcx>,\n         switch_ty: Ty<'tcx>,\n-        options: &mut FxIndexMap<ConstantKind<'tcx>, u128>,\n+        options: &mut FxIndexMap<ty::Const<'tcx>, u128>,\n     ) -> bool {\n         let Some(match_pair) = candidate.match_pairs.iter().find(|mp| mp.place == *test_place) else {\n             return false;\n@@ -264,7 +264,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     );\n                 } else if let [success, fail] = *make_target_blocks(self) {\n                     assert_eq!(value.ty(), ty);\n-                    let expect = self.literal_operand(test.span, value);\n+                    let expect = self.literal_operand(test.span, value.into());\n                     let val = Operand::Copy(place);\n                     self.compare(block, success, fail, source_info, BinOp::Eq, expect, val);\n                 } else {\n@@ -277,8 +277,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let target_blocks = make_target_blocks(self);\n \n                 // Test `val` by computing `lo <= val && val <= hi`, using primitive comparisons.\n-                let lo = self.literal_operand(test.span, lo);\n-                let hi = self.literal_operand(test.span, hi);\n+                let lo = self.literal_operand(test.span, lo.into());\n+                let hi = self.literal_operand(test.span, hi.into());\n                 let val = Operand::Copy(place);\n \n                 let [success, fail] = *target_blocks else {\n@@ -366,11 +366,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         block: BasicBlock,\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n         source_info: SourceInfo,\n-        value: ConstantKind<'tcx>,\n+        value: ty::Const<'tcx>,\n         place: Place<'tcx>,\n         mut ty: Ty<'tcx>,\n     ) {\n-        let mut expect = self.literal_operand(source_info.span, value);\n+        let mut expect = self.literal_operand(source_info.span, value.into());\n         let mut val = Operand::Copy(place);\n \n         // If we're using `b\"...\"` as a pattern, we need to insert an\n@@ -760,11 +760,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span_bug!(match_pair.pattern.span, \"simplifyable pattern found: {:?}\", match_pair.pattern)\n     }\n \n-    fn const_range_contains(\n-        &self,\n-        range: PatRange<'tcx>,\n-        value: ConstantKind<'tcx>,\n-    ) -> Option<bool> {\n+    fn const_range_contains(&self, range: PatRange<'tcx>, value: ty::Const<'tcx>) -> Option<bool> {\n         use std::cmp::Ordering::*;\n \n         let tcx = self.tcx;\n@@ -781,7 +777,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn values_not_contained_in_range(\n         &self,\n         range: PatRange<'tcx>,\n-        options: &FxIndexMap<ConstantKind<'tcx>, u128>,\n+        options: &FxIndexMap<ty::Const<'tcx>, u128>,\n     ) -> Option<bool> {\n         for &val in options.keys() {\n             if self.const_range_contains(range, val)? {"}, {"sha": "84762d602f8db5030f46e9c4046ed9f3000bf833", "filename": "compiler/rustc_mir_build/src/build/misc.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs?ref=ac60db231c96738b874fb31a755ef49a0d71926c", "patch": "@@ -3,6 +3,7 @@\n \n use crate::build::Builder;\n \n+use rustc_middle::mir;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::{Span, DUMMY_SP};\n@@ -25,7 +26,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Convenience function for creating a literal operand, one\n     /// without any user type annotation.\n-    crate fn literal_operand(&mut self, span: Span, literal: ConstantKind<'tcx>) -> Operand<'tcx> {\n+    crate fn literal_operand(\n+        &mut self,\n+        span: Span,\n+        literal: mir::ConstantKind<'tcx>,\n+    ) -> Operand<'tcx> {\n         let constant = Box::new(Constant { span, user_ty: None, literal });\n         Operand::Constant(constant)\n     }"}, {"sha": "2298cc7cddf47a26a220a27576e0094586e93bf3", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=ac60db231c96738b874fb31a755ef49a0d71926c", "patch": "@@ -1,7 +1,7 @@\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n-use rustc_middle::mir::{self, Field};\n+use rustc_middle::mir::Field;\n use rustc_middle::thir::{FieldPat, Pat, PatKind};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n@@ -22,7 +22,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn const_to_pat(\n         &self,\n-        cv: mir::ConstantKind<'tcx>,\n+        cv: ty::Const<'tcx>,\n         id: hir::HirId,\n         span: Span,\n         mir_structural_match_violation: bool,\n@@ -152,11 +152,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         ty.is_structural_eq_shallow(self.infcx.tcx)\n     }\n \n-    fn to_pat(\n-        &mut self,\n-        cv: mir::ConstantKind<'tcx>,\n-        mir_structural_match_violation: bool,\n-    ) -> Pat<'tcx> {\n+    fn to_pat(&mut self, cv: ty::Const<'tcx>, mir_structural_match_violation: bool) -> Pat<'tcx> {\n         trace!(self.treat_byte_string_as_slice);\n         // This method is just a wrapper handling a validity check; the heavy lifting is\n         // performed by the recursive `recur` method, which is not meant to be\n@@ -250,7 +246,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n \n     fn field_pats(\n         &self,\n-        vals: impl Iterator<Item = mir::ConstantKind<'tcx>>,\n+        vals: impl Iterator<Item = ty::Const<'tcx>>,\n     ) -> Result<Vec<FieldPat<'tcx>>, FallbackToConstRef> {\n         vals.enumerate()\n             .map(|(idx, val)| {\n@@ -263,7 +259,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     // Recursive helper for `to_pat`; invoke that (instead of calling this directly).\n     fn recur(\n         &self,\n-        cv: mir::ConstantKind<'tcx>,\n+        cv: ty::Const<'tcx>,\n         mir_structural_match_violation: bool,\n     ) -> Result<Pat<'tcx>, FallbackToConstRef> {\n         let id = self.id;\n@@ -369,7 +365,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n-                let destructured = tcx.destructure_mir_constant(param_env.and(cv));\n+                let destructured = tcx.destructure_const(param_env.and(cv));\n                 PatKind::Variant {\n                     adt_def: *adt_def,\n                     substs,\n@@ -380,12 +376,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 }\n             }\n             ty::Tuple(_) | ty::Adt(_, _) => {\n-                let destructured = tcx.destructure_mir_constant(param_env.and(cv));\n+                let destructured = tcx.destructure_const(param_env.and(cv));\n                 PatKind::Leaf { subpatterns: self.field_pats(destructured.fields.iter().copied())? }\n             }\n             ty::Array(..) => PatKind::Array {\n                 prefix: tcx\n-                    .destructure_mir_constant(param_env.and(cv))\n+                    .destructure_const(param_env.and(cv))\n                     .fields\n                     .iter()\n                     .map(|val| self.recur(*val, false))\n@@ -416,12 +412,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // arrays.\n                 ty::Array(..) if !self.treat_byte_string_as_slice => {\n                     let old = self.behind_reference.replace(true);\n-                    let array = tcx.deref_mir_constant(self.param_env.and(cv));\n+                    let array = tcx.deref_const(self.param_env.and(cv));\n                     let val = PatKind::Deref {\n                         subpattern: Pat {\n                             kind: Box::new(PatKind::Array {\n                                 prefix: tcx\n-                                    .destructure_mir_constant(param_env.and(array))\n+                                    .destructure_const(param_env.and(array))\n                                     .fields\n                                     .iter()\n                                     .map(|val| self.recur(*val, false))\n@@ -442,12 +438,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // pattern.\n                 ty::Slice(elem_ty) => {\n                     let old = self.behind_reference.replace(true);\n-                    let array = tcx.deref_mir_constant(self.param_env.and(cv));\n+                    let array = tcx.deref_const(self.param_env.and(cv));\n                     let val = PatKind::Deref {\n                         subpattern: Pat {\n                             kind: Box::new(PatKind::Slice {\n                                 prefix: tcx\n-                                    .destructure_mir_constant(param_env.and(array))\n+                                    .destructure_const(param_env.and(array))\n                                     .fields\n                                     .iter()\n                                     .map(|val| self.recur(*val, false))\n@@ -516,7 +512,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                         // we fall back to a const pattern. If we do not do this, we may end up with\n                         // a !structural-match constant that is not of reference type, which makes it\n                         // very hard to invoke `PartialEq::eq` on it as a fallback.\n-                        let val = match self.recur(tcx.deref_mir_constant(self.param_env.and(cv)), false) {\n+                        let val = match self.recur(tcx.deref_const(self.param_env.and(cv)), false) {\n                             Ok(subpattern) => PatKind::Deref { subpattern },\n                             Err(_) => PatKind::Constant { value: cv },\n                         };"}, {"sha": "20229d0a19fde9ccc854e15a8bc306a65ef99d6f", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=ac60db231c96738b874fb31a755ef49a0d71926c", "patch": "@@ -52,7 +52,7 @@ use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n \n use rustc_hir::{HirId, RangeEnd};\n-use rustc_middle::mir::{self, Field};\n+use rustc_middle::mir::Field;\n use rustc_middle::thir::{FieldPat, Pat, PatKind, PatRange};\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Ty, TyCtxt, VariantDef};\n@@ -136,30 +136,20 @@ impl IntRange {\n     fn from_const<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: mir::ConstantKind<'tcx>,\n+        value: ty::Const<'tcx>,\n     ) -> Option<IntRange> {\n         let ty = value.ty();\n         if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, ty) {\n             let val = (|| {\n-                match value {\n-                    mir::ConstantKind::Val(ConstValue::Scalar(scalar), _) => {\n-                        // For this specific pattern we can skip a lot of effort and go\n-                        // straight to the result, after doing a bit of checking. (We\n-                        // could remove this branch and just fall through, which\n-                        // is more general but much slower.)\n-                        if let Ok(bits) = scalar.to_bits_or_ptr_internal(target_size) {\n-                            return Some(bits);\n-                        }\n+                if let ty::ConstKind::Value(ConstValue::Scalar(scalar)) = value.val() {\n+                    // For this specific pattern we can skip a lot of effort and go\n+                    // straight to the result, after doing a bit of checking. (We\n+                    // could remove this branch and just fall through, which\n+                    // is more general but much slower.)\n+                    if let Ok(bits) = scalar.to_bits_or_ptr_internal(target_size) {\n+                        return Some(bits);\n                     }\n-                    mir::ConstantKind::Ty(c) => match c.val() {\n-                        ty::ConstKind::Value(_) => bug!(\n-                            \"encountered ConstValue in mir::ConstantKind::Ty, whereas this is expected to be in ConstantKind::Val\"\n-                        ),\n-                        _ => {}\n-                    },\n-                    _ => {}\n                 }\n-\n                 // This is a more general form of the previous case.\n                 value.try_eval_bits(tcx, param_env, ty)\n             })()?;\n@@ -244,8 +234,8 @@ impl IntRange {\n         let (lo, hi) = (lo ^ bias, hi ^ bias);\n \n         let env = ty::ParamEnv::empty().and(ty);\n-        let lo_const = mir::ConstantKind::from_bits(tcx, lo, env);\n-        let hi_const = mir::ConstantKind::from_bits(tcx, hi, env);\n+        let lo_const = ty::Const::from_bits(tcx, lo, env);\n+        let hi_const = ty::Const::from_bits(tcx, hi, env);\n \n         let kind = if lo == hi {\n             PatKind::Constant { value: lo_const }\n@@ -640,9 +630,9 @@ pub(super) enum Constructor<'tcx> {\n     /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n     IntRange(IntRange),\n     /// Ranges of floating-point literal values (`2.0..=5.2`).\n-    FloatRange(mir::ConstantKind<'tcx>, mir::ConstantKind<'tcx>, RangeEnd),\n+    FloatRange(ty::Const<'tcx>, ty::Const<'tcx>, RangeEnd),\n     /// String literals. Strings are not quite the same as `&[u8]` so we treat them separately.\n-    Str(mir::ConstantKind<'tcx>),\n+    Str(ty::Const<'tcx>),\n     /// Array and slice patterns.\n     Slice(Slice),\n     /// Constants that must not be matched structurally. They are treated as black\n@@ -839,7 +829,8 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n             }\n             (Str(self_val), Str(other_val)) => {\n-                // FIXME: there's probably a more direct way of comparing for equality\n+                // FIXME Once valtrees are available we can directly use the bytes\n+                // in the `Str` variant of the valtree for the comparison here.\n                 match compare_const_vals(\n                     pcx.cx.tcx,\n                     *self_val,"}, {"sha": "38c944b98d3604981e63fb9918ee4e1e98ee846d", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=ac60db231c96738b874fb31a755ef49a0d71926c", "patch": "@@ -17,7 +17,7 @@ use rustc_hir::RangeEnd;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{get_slice_bytes, ConstValue};\n use rustc_middle::mir::interpret::{ErrorHandled, LitToConstError, LitToConstInput};\n-use rustc_middle::mir::{self, UserTypeProjection};\n+use rustc_middle::mir::UserTypeProjection;\n use rustc_middle::mir::{BorrowKind, Field, Mutability};\n use rustc_middle::thir::{Ascription, BindingMode, FieldPat, Pat, PatKind, PatRange, PatTyProj};\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n@@ -121,8 +121,8 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     fn lower_pattern_range(\n         &mut self,\n         ty: Ty<'tcx>,\n-        lo: mir::ConstantKind<'tcx>,\n-        hi: mir::ConstantKind<'tcx>,\n+        lo: ty::Const<'tcx>,\n+        hi: ty::Const<'tcx>,\n         end: RangeEnd,\n         span: Span,\n     ) -> PatKind<'tcx> {\n@@ -177,24 +177,18 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         lo: Option<&PatKind<'tcx>>,\n         hi: Option<&PatKind<'tcx>>,\n-    ) -> Option<(mir::ConstantKind<'tcx>, mir::ConstantKind<'tcx>)> {\n+    ) -> Option<(ty::Const<'tcx>, ty::Const<'tcx>)> {\n         match (lo, hi) {\n             (Some(PatKind::Constant { value: lo }), Some(PatKind::Constant { value: hi })) => {\n                 Some((*lo, *hi))\n             }\n             (Some(PatKind::Constant { value: lo }), None) => {\n                 let hi = ty.numeric_max_val(self.tcx)?;\n-                Some((\n-                    *lo,\n-                    mir::ConstantKind::from_bits(self.tcx, hi, ty::ParamEnv::empty().and(ty)),\n-                ))\n+                Some((*lo, ty::Const::from_bits(self.tcx, hi, ty::ParamEnv::empty().and(ty))))\n             }\n             (None, Some(PatKind::Constant { value: hi })) => {\n                 let lo = ty.numeric_min_val(self.tcx)?;\n-                Some((\n-                    mir::ConstantKind::from_bits(self.tcx, lo, ty::ParamEnv::empty().and(ty)),\n-                    *hi,\n-                ))\n+                Some((ty::Const::from_bits(self.tcx, lo, ty::ParamEnv::empty().and(ty)), *hi))\n             }\n             _ => None,\n         }\n@@ -496,7 +490,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n         match self.tcx.const_eval_instance(param_env_reveal_all, instance, Some(span)) {\n             Ok(value) => {\n-                let const_ = mir::ConstantKind::Val(value, ty);\n+                let const_ = ty::Const::from_value(self.tcx, value, ty);\n                 let pattern = self.const_to_pat(const_, id, span, mir_structural_match_violation);\n \n                 if !is_associated_const {\n@@ -545,30 +539,25 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         span: Span,\n     ) -> PatKind<'tcx> {\n         let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n-        let value = mir::ConstantKind::from_inline_const(self.tcx, anon_const_def_id);\n+        let value = ty::Const::from_inline_const(self.tcx, anon_const_def_id);\n \n         // Evaluate early like we do in `lower_path`.\n         let value = value.eval(self.tcx, self.param_env);\n \n-        match value {\n-            mir::ConstantKind::Ty(c) => {\n-                match c.val() {\n-                    ConstKind::Param(_) => {\n-                        self.errors.push(PatternError::ConstParamInPattern(span));\n-                        return PatKind::Wild;\n-                    }\n-                    ConstKind::Unevaluated(_) => {\n-                        // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n-                        self.tcx\n-                            .sess\n-                            .span_err(span, \"constant pattern depends on a generic parameter\");\n-                        return PatKind::Wild;\n-                    }\n-                    _ => bug!(\"Expected either ConstKind::Param or ConstKind::Unevaluated\"),\n-                }\n+        match value.val() {\n+            ConstKind::Param(_) => {\n+                self.errors.push(PatternError::ConstParamInPattern(span));\n+                return PatKind::Wild;\n             }\n-            mir::ConstantKind::Val(_, _) => *self.const_to_pat(value, id, span, false).kind,\n+            ConstKind::Unevaluated(_) => {\n+                // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n+                self.tcx.sess.span_err(span, \"constant pattern depends on a generic parameter\");\n+                return PatKind::Wild;\n+            }\n+            _ => (),\n         }\n+\n+        *self.const_to_pat(value, id, span, false).kind\n     }\n \n     /// Converts literals, paths and negation of literals to patterns.\n@@ -595,7 +584,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n         let lit_input =\n             LitToConstInput { lit: &lit.node, ty: self.typeck_results.expr_ty(expr), neg };\n-        match self.tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n+        match self.tcx.at(expr.span).lit_to_const(lit_input) {\n             Ok(constant) => *self.const_to_pat(constant, expr.hir_id, lit.span, false).kind,\n             Err(LitToConstError::Reported) => PatKind::Wild,\n             Err(LitToConstError::TypeError) => bug!(\"lower_lit: had type error\"),\n@@ -750,11 +739,12 @@ impl<'tcx> PatternFoldable<'tcx> for PatKind<'tcx> {\n     }\n }\n \n+// FIXME: Get rid of this function once valtrees land\n #[instrument(skip(tcx), level = \"debug\")]\n crate fn compare_const_vals<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    a: mir::ConstantKind<'tcx>,\n-    b: mir::ConstantKind<'tcx>,\n+    a: ty::Const<'tcx>,\n+    b: ty::Const<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<Ordering> {"}, {"sha": "687b2e23c9fcb01cbf455addae52954f5a4955d2", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=ac60db231c96738b874fb31a755ef49a0d71926c", "patch": "@@ -765,10 +765,7 @@ fn lint_non_exhaustive_omitted_patterns<'p, 'tcx>(\n /// `is_under_guard` is used to inform if the pattern has a guard. If it\n /// has one it must not be inserted into the matrix. This shouldn't be\n /// relied on for soundness.\n-#[instrument(\n-    level = \"debug\",\n-    skip(cx, matrix, witness_preference, hir_id, is_under_guard, is_top_level)\n-)]\n+#[instrument(level = \"debug\", skip(cx, matrix, hir_id))]\n fn is_useful<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n@@ -800,6 +797,7 @@ fn is_useful<'p, 'tcx>(\n \n     let ty = v.head().ty();\n     let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);\n+    debug!(\"v.head: {:?}, v.span: {:?}\", v.head(), v.head().span());\n     let pcx = PatCtxt { cx, ty, span: v.head().span(), is_top_level, is_non_exhaustive };\n \n     // If the first pattern is an or-pattern, expand it.\n@@ -809,9 +807,11 @@ fn is_useful<'p, 'tcx>(\n         // We try each or-pattern branch in turn.\n         let mut matrix = matrix.clone();\n         for v in v.expand_or_pat() {\n+            debug!(?v);\n             let usefulness = ensure_sufficient_stack(|| {\n                 is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false)\n             });\n+            debug!(?usefulness);\n             ret.extend(usefulness);\n             // If pattern has a guard don't add it to the matrix.\n             if !is_under_guard {\n@@ -822,6 +822,7 @@ fn is_useful<'p, 'tcx>(\n         }\n     } else {\n         let v_ctor = v.head().ctor();\n+        debug!(?v_ctor);\n         if let Constructor::IntRange(ctor_range) = &v_ctor {\n             // Lint on likely incorrect range patterns (#63987)\n             ctor_range.lint_overlapping_range_endpoints(\n@@ -895,7 +896,7 @@ fn is_useful<'p, 'tcx>(\n }\n \n /// The arm of a match expression.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Debug)]\n crate struct MatchArm<'p, 'tcx> {\n     /// The pattern must have been lowered through `check_match::MatchVisitor::lower_pattern`.\n     crate pat: &'p DeconstructedPat<'p, 'tcx>,\n@@ -928,6 +929,7 @@ crate struct UsefulnessReport<'p, 'tcx> {\n ///\n /// Note: the input patterns must have been lowered through\n /// `check_match::MatchVisitor::lower_pattern`.\n+#[instrument(skip(cx, arms), level = \"debug\")]\n crate fn compute_match_usefulness<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     arms: &[MatchArm<'p, 'tcx>],\n@@ -939,6 +941,7 @@ crate fn compute_match_usefulness<'p, 'tcx>(\n         .iter()\n         .copied()\n         .map(|arm| {\n+            debug!(?arm);\n             let v = PatStack::from_pattern(arm.pat);\n             is_useful(cx, &matrix, &v, RealArm, arm.hir_id, arm.has_guard, true);\n             if !arm.has_guard {"}, {"sha": "0ce97de413496db7146557dd8e4681183a3acbb6", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=ac60db231c96738b874fb31a755ef49a0d71926c", "patch": "@@ -19,7 +19,6 @@ use rustc_hir::{AssocItemKind, HirIdSet, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n-use rustc_middle::mir::ConstantKind;\n use rustc_middle::span_bug;\n use rustc_middle::thir::abstract_const::Node as ACNode;\n use rustc_middle::ty::fold::TypeVisitor;\n@@ -157,10 +156,7 @@ where\n         ct: AbstractConst<'tcx>,\n     ) -> ControlFlow<V::BreakTy> {\n         const_evaluatable::walk_abstract_const(tcx, ct, |node| match node.root(tcx) {\n-            ACNode::Leaf(leaf) => match leaf {\n-                ConstantKind::Ty(c) => self.visit_const(c),\n-                ConstantKind::Val(_, ty) => self.visit_ty(ty),\n-            },\n+            ACNode::Leaf(leaf) => self.visit_const(leaf),\n             ACNode::Cast(_, _, ty) => self.visit_ty(ty),\n             ACNode::Binop(..) | ACNode::UnaryOp(..) | ACNode::FunctionCall(_, _) => {\n                 ControlFlow::CONTINUE\n@@ -288,7 +284,7 @@ where\n     fn visit_const(&mut self, c: Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         self.visit_ty(c.ty())?;\n         let tcx = self.def_id_visitor.tcx();\n-        if let Ok(Some(ct)) = AbstractConst::from_constant(tcx, ConstantKind::Ty(c)) {\n+        if let Ok(Some(ct)) = AbstractConst::from_const(tcx, c) {\n             self.visit_abstract_const_expr(tcx, ct)?;\n         }\n         ControlFlow::CONTINUE"}, {"sha": "709dd346efcc5203ce4f68996a29af983e3f3ecf", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=ac60db231c96738b874fb31a755ef49a0d71926c", "patch": "@@ -37,14 +37,9 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     span: Span,\n ) -> Result<(), NotConstEvaluatable> {\n-<<<<<<< HEAD\n     let tcx = infcx.tcx;\n \n     if tcx.features().generic_const_exprs {\n-=======\n-    if infcx.tcx.features().generic_const_exprs {\n-        let tcx = infcx.tcx;\n->>>>>>> 6064f16d846 (change thir to use mir::ConstantKind instead of ty::Const)\n         match AbstractConst::new(tcx, uv)? {\n             // We are looking at a generic abstract constant.\n             Some(ct) => {\n@@ -249,7 +244,7 @@ impl<'tcx> AbstractConst<'tcx> {\n         Ok(inner.map(|inner| AbstractConst { inner, substs: uv.substs }))\n     }\n \n-    pub fn from_constant(\n+    pub fn from_const(\n         tcx: TyCtxt<'tcx>,\n         ct: ty::Const<'tcx>,\n     ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n@@ -382,6 +377,10 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 }\n             }\n \n+            fn visit_const(&mut self, ct: ty::Const<'tcx>) {\n+                self.is_poly |= ct.has_param_types_or_consts();\n+            }\n+\n             fn visit_constant(&mut self, ct: mir::ConstantKind<'tcx>) {\n                 self.is_poly |= ct.has_param_types_or_consts();\n             }\n@@ -423,10 +422,10 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         self.recurse_build(self.body_id)?;\n \n         for n in self.nodes.iter() {\n-            if let Node::Leaf(mir::ConstantKind::Ty(ty::Const(Interned(\n+            if let Node::Leaf(ty::Const(Interned(\n                 ty::ConstS { val: ty::ConstKind::Unevaluated(ct), ty: _ },\n                 _,\n-            )))) = n\n+            ))) = n\n             {\n                 // `AbstractConst`s should not contain any promoteds as they require references which\n                 // are not allowed.\n@@ -863,4 +862,4 @@ impl<'tcx> ConstUnifyCtxt<'tcx> {\n                     false\n >>>>>>> 6064f16d846 (change thir to use mir::ConstantKind instead of ty::Const)\n \n- */\n\\ No newline at end of file\n+ */"}, {"sha": "6cceec8621304cf3e5db3a449be8dfde588f15f6", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60db231c96738b874fb31a755ef49a0d71926c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=ac60db231c96738b874fb31a755ef49a0d71926c", "patch": "@@ -17,7 +17,6 @@ use crate::traits::{self, Obligation, ObligationCause};\n use rustc_errors::FatalError;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::mir::ConstantKind;\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_middle::ty::{Predicate, ToPredicate};\n@@ -837,10 +836,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n             if let Ok(Some(ct)) = AbstractConst::new(self.tcx, uv.shrink()) {\n                 const_evaluatable::walk_abstract_const(self.tcx, ct, |node| {\n                     match node.root(self.tcx) {\n-                        Node::Leaf(leaf) => match leaf {\n-                            ConstantKind::Ty(c) => self.visit_const(c),\n-                            ConstantKind::Val(_, ty) => self.visit_ty(ty),\n-                        },\n+                        Node::Leaf(leaf) => self.visit_const(leaf),\n                         Node::Cast(_, _, ty) => self.visit_ty(ty),\n                         Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n                             ControlFlow::CONTINUE"}]}