{"sha": "66c03f980e235c3364e2f0dcc1fd654a33984c4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2YzAzZjk4MGUyMzVjMzM2NGUyZjBkY2MxZmQ2NTRhMzM5ODRjNGI=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-06-04T07:24:39Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-06-04T07:24:39Z"}, "message": "Merge pull request #962 from Manishearth/fix-doc\n\nFix DOC_MARKDOWN and multiline links and quotes", "tree": {"sha": "98d75799b56f8248e860135bfaa7a0b6e1ee2f1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98d75799b56f8248e860135bfaa7a0b6e1ee2f1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66c03f980e235c3364e2f0dcc1fd654a33984c4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66c03f980e235c3364e2f0dcc1fd654a33984c4b", "html_url": "https://github.com/rust-lang/rust/commit/66c03f980e235c3364e2f0dcc1fd654a33984c4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66c03f980e235c3364e2f0dcc1fd654a33984c4b/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7944fa811b4fce638baaeb43f9e305858bceec6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7944fa811b4fce638baaeb43f9e305858bceec6d", "html_url": "https://github.com/rust-lang/rust/commit/7944fa811b4fce638baaeb43f9e305858bceec6d"}, {"sha": "97c9930a3f8991da2e8b5edb8d1748ca7e2f20d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/97c9930a3f8991da2e8b5edb8d1748ca7e2f20d1", "html_url": "https://github.com/rust-lang/rust/commit/97c9930a3f8991da2e8b5edb8d1748ca7e2f20d1"}], "stats": {"total": 274, "additions": 183, "deletions": 91}, "files": [{"sha": "af1fbaa0f7da1c727380b38d86a04acff9ba7283", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 162, "deletions": 79, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/66c03f980e235c3364e2f0dcc1fd654a33984c4b/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c03f980e235c3364e2f0dcc1fd654a33984c4b/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=66c03f980e235c3364e2f0dcc1fd654a33984c4b", "patch": "@@ -51,6 +51,8 @@ impl EarlyLintPass for Doc {\n }\n \n pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [ast::Attribute]) {\n+    let mut docs = vec![];\n+\n     let mut in_multiline = false;\n     for attr in attrs {\n         if attr.node.is_sugared_doc {\n@@ -64,39 +66,21 @@ pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [a\n                     // check for multiline code blocks\n                     if real_doc.trim_left().starts_with(\"```\") {\n                         in_multiline = !in_multiline;\n-                    }\n-                    if !in_multiline {\n-                        check_doc(cx, valid_idents, real_doc, span);\n+                    } else if !in_multiline {\n+                        docs.push((real_doc, span));\n                     }\n                 }\n             }\n         }\n     }\n-}\n \n-macro_rules! jump_to {\n-    // Get the next character\u2019s first byte UTF-8 friendlyly.\n-    (@next_char, $chars: expr, $len: expr) => {{\n-        if let Some(&(pos, _)) = $chars.peek() {\n-            pos\n-        } else {\n-            $len\n-        }\n-    }};\n-\n-    // Jump to the next `$c`. If no such character is found, give up.\n-    ($chars: expr, $c: expr, $len: expr) => {{\n-        if $chars.find(|&(_, c)| c == $c).is_some() {\n-            jump_to!(@next_char, $chars, $len)\n-        }\n-        else {\n-            return;\n-        }\n-    }};\n+    if !docs.is_empty() {\n+        let _ = check_doc(cx, valid_idents, &docs);\n+    }\n }\n \n #[allow(while_let_loop)] // #362\n-pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Span) {\n+pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(&str, Span)]) -> Result<(), ()> {\n     // In markdown, `_` can be used to emphasize something, or, is a raw `_` depending on context.\n     // There really is no markdown specification that would disambiguate this properly. This is\n     // what GitHub and Rustdoc do:\n@@ -108,90 +92,189 @@ pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Sp\n     // (_baz_)             \u2192 (<em>baz</em>)\n     // foo _ bar _ baz     \u2192 foo _ bar _ baz\n \n-    /// Character that can appear in a word\n-    fn is_word_char(c: char) -> bool {\n+    /// Character that can appear in a path\n+    fn is_path_char(c: char) -> bool {\n         match c {\n             t if t.is_alphanumeric() => true,\n             ':' | '_' => true,\n             _ => false,\n         }\n     }\n \n-    #[allow(cast_possible_truncation)]\n-    fn word_span(mut span: Span, begin: usize, end: usize) -> Span {\n-        debug_assert_eq!(end as u32 as usize, end);\n-        debug_assert_eq!(begin as u32 as usize, begin);\n-        span.hi = span.lo + BytePos(end as u32);\n-        span.lo = span.lo + BytePos(begin as u32);\n-        span\n+    #[derive(Clone, Debug)]\n+    /// This type is used to iterate through the documentation characters, keeping the span at the\n+    /// same time.\n+    struct Parser<'a> {\n+        /// First byte of the current potential match\n+        current_word_begin: usize,\n+        /// List of lines and their associated span\n+        docs: &'a[(&'a str, Span)],\n+        /// Index of the current line we are parsing\n+        line: usize,\n+        /// Whether we are in a link\n+        link: bool,\n+        /// Whether we are at the beginning of a line\n+        new_line: bool,\n+        /// Whether we were to the end of a line last time `next` was called\n+        reset: bool,\n+        /// The position of the current character within the current line\n+        pos: usize,\n     }\n \n-    let mut new_line = true;\n-    let len = doc.len();\n-    let mut chars = doc.char_indices().peekable();\n-    let mut current_word_begin = 0;\n+    impl<'a> Parser<'a> {\n+        fn advance_begin(&mut self) {\n+            self.current_word_begin = self.pos;\n+        }\n+\n+        fn line(&self) -> (&'a str, Span) {\n+            self.docs[self.line]\n+        }\n+\n+        fn peek(&self) -> Option<char> {\n+            self.line().0[self.pos..].chars().next()\n+        }\n+\n+        #[allow(while_let_on_iterator)] // borrowck complains about for\n+        fn jump_to(&mut self, n: char) -> Result<(), ()> {\n+            while let Some((_, c)) = self.next() {\n+                if c == n {\n+                    self.advance_begin();\n+                    return Ok(());\n+                }\n+            }\n+\n+            Err(())\n+        }\n+\n+        fn next_line(&mut self) {\n+            self.pos = 0;\n+            self.current_word_begin = 0;\n+            self.line += 1;\n+            self.new_line = true;\n+        }\n+\n+        fn put_back(&mut self, c: char) {\n+            self.pos -= c.len_utf8();\n+        }\n+\n+        #[allow(cast_possible_truncation)]\n+        fn word(&self) -> (&'a str, Span) {\n+            let begin = self.current_word_begin;\n+            let end = self.pos;\n+\n+            debug_assert_eq!(end as u32 as usize, end);\n+            debug_assert_eq!(begin as u32 as usize, begin);\n+\n+            let (doc, mut span) = self.line();\n+            span.hi = span.lo + BytePos(end as u32);\n+            span.lo = span.lo + BytePos(begin as u32);\n+\n+            (&doc[begin..end], span)\n+        }\n+    }\n+\n+    impl<'a> Iterator for Parser<'a> {\n+        type Item = (bool, char);\n+\n+        fn next(&mut self) -> Option<(bool, char)> {\n+            while self.line < self.docs.len() {\n+                if self.reset {\n+                    self.line += 1;\n+                    self.reset = false;\n+                    self.pos = 0;\n+                    self.current_word_begin = 0;\n+                }\n+\n+                let mut chars = self.line().0[self.pos..].chars();\n+                let c = chars.next();\n+\n+                if let Some(c) = c {\n+                    self.pos += c.len_utf8();\n+                    let new_line = self.new_line;\n+                    self.new_line = c == '\\n' || (self.new_line && c.is_whitespace());\n+                    return Some((new_line, c));\n+                } else if self.line == self.docs.len() - 1 {\n+                    return None;\n+                } else {\n+                    self.new_line = true;\n+                    self.reset = true;\n+                    self.pos += 1;\n+                    return Some((true, '\\n'));\n+                }\n+            }\n+\n+            None\n+        }\n+    }\n+\n+    let mut parser = Parser {\n+        current_word_begin: 0,\n+        docs: docs,\n+        line: 0,\n+        link: false,\n+        new_line: true,\n+        reset: false,\n+        pos: 0,\n+    };\n+\n     loop {\n-        match chars.next() {\n-            Some((_, c)) => {\n+        match parser.next() {\n+            Some((new_line, c)) => {\n                 match c {\n                     '#' if new_line => { // don\u2019t warn on titles\n-                        current_word_begin = jump_to!(chars, '\\n', len);\n+                        parser.next_line();\n                     }\n                     '`' => {\n-                        current_word_begin = jump_to!(chars, '`', len);\n+                        try!(parser.jump_to('`'));\n                     }\n                     '[' => {\n-                        let end = jump_to!(chars, ']', len);\n-                        let link_text = &doc[current_word_begin + 1..end];\n-                        let word_span = word_span(span, current_word_begin + 1, end + 1);\n-\n-                        match chars.peek() {\n-                            Some(&(_, c)) => {\n-                                // Trying to parse a link. Let\u2019s ignore the link.\n-\n-                                // FIXME: how does markdown handles such link?\n-                                // https://en.wikipedia.org/w/index.php?title=)\n-                                match c {\n-                                    '(' => { // inline link\n-                                        current_word_begin = jump_to!(chars, ')', len);\n-                                        check_doc(cx, valid_idents, link_text, word_span);\n-                                    }\n-                                    '[' => { // reference link\n-                                        current_word_begin = jump_to!(chars, ']', len);\n-                                        check_doc(cx, valid_idents, link_text, word_span);\n-                                    }\n-                                    ':' => { // reference link\n-                                        current_word_begin = jump_to!(chars, '\\n', len);\n-                                    }\n-                                    _ => { // automatic reference link\n-                                        current_word_begin = jump_to!(@next_char, chars, len);\n-                                        check_doc(cx, valid_idents, link_text, word_span);\n-                                    }\n+                        // Check for a reference definition `[foo]:` at the beginning of a line\n+                        let mut link = true;\n+\n+                        if new_line {\n+                            let mut lookup_parser = parser.clone();\n+                            if let Some(_) = lookup_parser.find(|&(_, c)| c == ']') {\n+                                if let Some((_, ':')) = lookup_parser.next() {\n+                                    lookup_parser.next_line();\n+                                    parser = lookup_parser;\n+                                    link = false;\n                                 }\n                             }\n-                            None => return,\n+                        }\n+\n+                        parser.advance_begin();\n+                        parser.link = link;\n+                    }\n+                    ']' if parser.link => {\n+                        parser.link = false;\n+\n+                        match parser.peek() {\n+                            Some('(') => try!(parser.jump_to(')')),\n+                            Some('[') => try!(parser.jump_to(']')),\n+                            Some(_) => continue,\n+                            None => return Err(()),\n                         }\n                     }\n-                    // anything that\u2019s neither alphanumeric nor '_' is not part of an ident anyway\n-                    c if !c.is_alphanumeric() && c != '_' => {\n-                        current_word_begin = jump_to!(@next_char, chars, len);\n+                    c if !is_path_char(c) => {\n+                        parser.advance_begin();\n                     }\n                     _ => {\n-                        let end = match chars.find(|&(_, c)| !is_word_char(c)) {\n-                            Some((end, _)) => end,\n-                            None => len,\n-                        };\n-                        let word_span = word_span(span, current_word_begin, end);\n-                        check_word(cx, valid_idents, &doc[current_word_begin..end], word_span);\n-                        current_word_begin = jump_to!(@next_char, chars, len);\n+                        if let Some((_, c)) = parser.find(|&(_, c)| !is_path_char(c)) {\n+                            parser.put_back(c);\n+                        }\n+\n+                        let (word, span) = parser.word();\n+                        check_word(cx, valid_idents, word, span);\n+                        parser.advance_begin();\n                     }\n                 }\n \n-                new_line = c == '\\n' || (new_line && c.is_whitespace());\n             }\n             None => break,\n         }\n     }\n+\n+    Ok(())\n }\n \n fn check_word(cx: &EarlyContext, valid_idents: &[String], word: &str, span: Span) {"}, {"sha": "d3b1c037f4702c185c0f190ba2694400ac236a91", "filename": "tests/compile-fail/doc.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/66c03f980e235c3364e2f0dcc1fd654a33984c4b/tests%2Fcompile-fail%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c03f980e235c3364e2f0dcc1fd654a33984c4b/tests%2Fcompile-fail%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdoc.rs?ref=66c03f980e235c3364e2f0dcc1fd654a33984c4b", "patch": "@@ -12,6 +12,8 @@\n /// Markdown is _weird_. I mean _really weird_.  This \\_ is ok. So is `_`. But not Foo::some_fun\n //~^ ERROR: you should put `Foo::some_fun` between ticks\n /// which should be reported only once despite being __doubly bad__.\n+/// Here be ::is::a::global:path.\n+//~^ ERROR: you should put `is::a::global:path` between ticks\n /// be_sure_we_got_to_the_end_of_it\n //~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n fn foo_bar() {\n@@ -66,18 +68,18 @@ fn test_units() {\n //~^ ERROR: you should put `foo_\u211d` between ticks\n /// foo_\ud83d\udca3\n /// foo_\u2764\ufe0f\n-/// [\u00dfdummy text\u00df][foo_\u00df]\n-/// [\u211ddummy text\u211d][foo_\u211d]\n-/// [\ud83d\udca3dummy tex\ud83d\udca3t][foo_\ud83d\udca3]\n-/// [\u2764\ufe0fdummy text\u2764\ufe0f][foo_\u2764\ufe0f]\n-/// [\u00dfdummy text\u00df](foo_\u00df)\n-/// [\u211ddummy text\u211d](foo_\u211d)\n-/// [\ud83d\udca3dummy tex\ud83d\udca3t](foo_\ud83d\udca3)\n-/// [\u2764\ufe0fdummy text\u2764\ufe0f](foo_\u2764\ufe0f)\n-/// [foo_\u00df]: dummy text\n-/// [foo_\u211d]: dummy text\n-/// [foo_\ud83d\udca3]: dummy text\n-/// [foo_\u2764\ufe0f]: dummy text\n+/// [\u00dfdummy text\u00df][foo_1\u00df]\n+/// [\u211ddummy text\u211d][foo_2\u211d]\n+/// [\ud83d\udca3dummy tex\ud83d\udca3t][foo3_\ud83d\udca3]\n+/// [\u2764\ufe0fdummy text\u2764\ufe0f][foo_4\u2764\ufe0f]\n+/// [\u00dfdummy text\u00df](foo_5\u00df)\n+/// [\u211ddummy text\u211d](foo_6\u211d)\n+/// [\ud83d\udca3dummy tex\ud83d\udca3t](fo7o_\ud83d\udca3)\n+/// [\u2764\ufe0fdummy text\u2764\ufe0f](foo_8\u2764\ufe0f)\n+/// [foo1_\u00df]: dummy text\n+/// [foo2_\u211d]: dummy text\n+/// [foo3_\ud83d\udca3]: dummy text\n+/// [foo4_\u2764\ufe0f]: dummy text\n /// be_sure_we_got_to_the_end_of_it\n //~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n fn test_unicode() {\n@@ -141,3 +143,10 @@ fn issue900() {\n //~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n fn issue883() {\n }\n+\n+/// `foo_bar\n+/// baz_quz`\n+/// [foo\n+/// bar](https://doc.rust-lang.org/stable/std/iter/trait.IteratorFooBar.html)\n+fn multiline() {\n+}"}]}