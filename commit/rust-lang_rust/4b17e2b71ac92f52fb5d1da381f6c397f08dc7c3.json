{"sha": "4b17e2b71ac92f52fb5d1da381f6c397f08dc7c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMTdlMmI3MWFjOTJmNTJmYjVkMWRhMzgxZjZjMzk3ZjA4ZGM3YzM=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-14T00:19:55Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-15T16:06:49Z"}, "message": "Generate ADTs for tuple-like constructors instead\n\nPreviously we would generate regular calls for these, which is likely to result in worse LLVM code,\nespecially in presence of cleanups \u2013 we needn\u2019t unecessarilly generate landing pads to construct an\nADT!", "tree": {"sha": "3dfe7474270cacda07ad25ef226dabda48cd5e79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dfe7474270cacda07ad25ef226dabda48cd5e79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b17e2b71ac92f52fb5d1da381f6c397f08dc7c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b17e2b71ac92f52fb5d1da381f6c397f08dc7c3", "html_url": "https://github.com/rust-lang/rust/commit/4b17e2b71ac92f52fb5d1da381f6c397f08dc7c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b17e2b71ac92f52fb5d1da381f6c397f08dc7c3/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f4e317e45349eb2d3c853e96bfd24dd574b36d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f4e317e45349eb2d3c853e96bfd24dd574b36d1", "html_url": "https://github.com/rust-lang/rust/commit/1f4e317e45349eb2d3c853e96bfd24dd574b36d1"}], "stats": {"total": 50, "additions": 40, "deletions": 10}, "files": [{"sha": "8090fca66bb6247904341cb8f1de0cd3bb5e33a4", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4b17e2b71ac92f52fb5d1da381f6c397f08dc7c3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b17e2b71ac92f52fb5d1da381f6c397f08dc7c3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=4b17e2b71ac92f52fb5d1da381f6c397f08dc7c3", "patch": "@@ -53,7 +53,6 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     // Find the actual method implementation being called and\n                     // build the appropriate UFCS call expression with the\n                     // callee-object as self parameter.\n-\n                     let method = method_callee(cx, self, ty::MethodCall::expr(self.id));\n                     let mut argrefs = vec![fun.to_ref()];\n                     argrefs.extend(args.iter().map(|a| a.to_ref()));\n@@ -64,12 +63,40 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                         args: argrefs,\n                     }\n                 } else {\n-                    ExprKind::Call {\n-                        ty: &cx.tcx.node_id_to_type(fun.id),\n-                        fun: fun.to_ref(),\n-                        args: args.to_ref(),\n+                    let adt_data = if let hir::ExprPath(..) = fun.node {\n+                        // Tuple-like ADTs are represented as ExprCall. We convert them here.\n+                        expr_ty.ty_adt_def().and_then(|adt_def|{\n+                            match cx.tcx.def_map.borrow()[&fun.id].full_def() {\n+                                def::DefVariant(_, variant_id, false) => {\n+                                    Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n+                                },\n+                                def::DefStruct(_) => {\n+                                    Some((adt_def, 0))\n+                                },\n+                                _ => None\n+                            }\n+                        })\n+                    } else { None };\n+                    if let Some((adt_def, index)) = adt_data {\n+                        let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(fun.id).substs);\n+                        let field_refs = args.iter().enumerate().map(|(idx, e)| FieldExprRef {\n+                            name: Field::new(idx),\n+                            expr: e.to_ref()\n+                        }).collect();\n+                        ExprKind::Adt {\n+                            adt_def: adt_def,\n+                            substs: substs,\n+                            variant_index: index,\n+                            fields: field_refs,\n+                            base: None\n+                        }\n+                    } else {\n+                        ExprKind::Call {\n+                            ty: cx.tcx.node_id_to_type(fun.id),\n+                            fun: fun.to_ref(),\n+                            args: args.to_ref(),\n+                        }\n                     }\n-\n                 }\n             }\n \n@@ -549,10 +576,11 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n         def::DefFn(def_id, _) => (def_id, ItemKind::Function),\n         def::DefMethod(def_id) => (def_id, ItemKind::Method),\n         def::DefStruct(def_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n-            // A tuple-struct constructor.\n+            // A tuple-struct constructor. Should only be reached if not called in the same\n+            // expression.\n             ty::TyBareFn(..) => (def_id, ItemKind::Function),\n-            // This is a special case: a unit struct which is used as a value. We return a\n-            // completely different ExprKind here to account for this special case.\n+            // A unit struct which is used as a value. We return a completely different ExprKind\n+            // here to account for this special case.\n             ty::TyStruct(adt_def, substs) => return ExprKind::Adt {\n                 adt_def: adt_def,\n                 variant_index: 0,\n@@ -563,7 +591,8 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n             ref sty => panic!(\"unexpected sty: {:?}\", sty)\n         },\n         def::DefVariant(enum_id, variant_id, false) => match cx.tcx.node_id_to_type(expr.id).sty {\n-            // A variant constructor.\n+            // A variant constructor. Should only be reached if not called in the same\n+            // expression.\n             ty::TyBareFn(..) => (variant_id, ItemKind::Function),\n             // A unit variant, similar special case to the struct case above.\n             ty::TyEnum(adt_def, substs) => {\n@@ -900,6 +929,7 @@ fn loop_label<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> Cod\n     }\n }\n \n+/// Converts a list of named fields (i.e. for struct-like struct/enum ADTs) into FieldExprRef.\n fn field_refs<'tcx>(variant: VariantDef<'tcx>,\n                     fields: &'tcx [hir::Field])\n                     -> Vec<FieldExprRef<'tcx>>"}]}