{"sha": "caca2121ffe4cb47d8ea2d9469c493995f57e0b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhY2EyMTIxZmZlNGNiNDdkOGVhMmQ5NDY5YzQ5Mzk5NWY1N2UwYjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-05T20:12:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-05T20:12:13Z"}, "message": "Auto merge of #74024 - Folyd:master, r=m-ou-se\n\nImprove slice.binary_search_by()'s best-case performance to O(1)\n\nThis PR aimed to improve the [slice.binary_search_by()](https://doc.rust-lang.org/std/primitive.slice.html#method.binary_search_by)'s best-case performance to O(1).\n\n# Noticed\n\nI don't know why the docs of `binary_search_by` said `\"If there are multiple matches, then any one of the matches could be returned.\"`, but the implementation isn't the same thing. Actually, it returns the **last one** if multiple matches found.\n\nThen we got two options:\n\n## If returns the last one is the correct or desired result\n\nThen I can rectify the docs and revert my changes.\n\n## If the docs are correct or desired result\n\nThen my changes can be merged after fully reviewed.\n\nHowever, if my PR gets merged, another issue raised: this could be a **breaking change** since if multiple matches found, the returning order no longer the last one instead of it could be any one.\n\nFor example:\n```rust\nlet mut s = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\nlet num = 1;\nlet idx = s.binary_search(&num);\ns.insert(idx, 2);\n\n// Old implementations\nassert_eq!(s, [0, 1, 1, 1, 1, 2, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n\n// New implementations\nassert_eq!(s, [0, 1, 1, 1, 2, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n```\n\n# Benchmarking\n\n**Old implementations**\n```sh\n$ ./x.py bench --stage 1 library/libcore\ntest slice::binary_search_l1           ... bench:          59 ns/iter (+/- 4)\ntest slice::binary_search_l1_with_dups ... bench:          59 ns/iter (+/- 3)\ntest slice::binary_search_l2           ... bench:          76 ns/iter (+/- 5)\ntest slice::binary_search_l2_with_dups ... bench:          77 ns/iter (+/- 17)\ntest slice::binary_search_l3           ... bench:         183 ns/iter (+/- 23)\ntest slice::binary_search_l3_with_dups ... bench:         185 ns/iter (+/- 19)\n```\n\n**New implementations (1)**\n\nImplemented by this PR.\n```rust\nif cmp == Equal {\n    return Ok(mid);\n} else if cmp == Less {\n    base = mid\n}\n```\n```sh\n$ ./x.py bench --stage 1 library/libcore\ntest slice::binary_search_l1           ... bench:          58 ns/iter (+/- 2)\ntest slice::binary_search_l1_with_dups ... bench:          37 ns/iter (+/- 4)\ntest slice::binary_search_l2           ... bench:          76 ns/iter (+/- 3)\ntest slice::binary_search_l2_with_dups ... bench:          57 ns/iter (+/- 6)\ntest slice::binary_search_l3           ... bench:         200 ns/iter (+/- 30)\ntest slice::binary_search_l3_with_dups ... bench:         157 ns/iter (+/- 6)\n\n$ ./x.py bench --stage 1 library/libcore\ntest slice::binary_search_l1           ... bench:          59 ns/iter (+/- 8)\ntest slice::binary_search_l1_with_dups ... bench:          37 ns/iter (+/- 2)\ntest slice::binary_search_l2           ... bench:          77 ns/iter (+/- 2)\ntest slice::binary_search_l2_with_dups ... bench:          57 ns/iter (+/- 2)\ntest slice::binary_search_l3           ... bench:         198 ns/iter (+/- 21)\ntest slice::binary_search_l3_with_dups ... bench:         158 ns/iter (+/- 11)\n\n```\n\n**New implementations (2)**\n\nSuggested by `@nbdd0121` in [comment](https://github.com/rust-lang/rust/pull/74024#issuecomment-665430239).\n```rust\nbase = if cmp == Greater { base } else { mid };\nif cmp == Equal { break }\n```\n\n```sh\n$ ./x.py bench --stage 1 library/libcore\ntest slice::binary_search_l1           ... bench:          59 ns/iter (+/- 7)\ntest slice::binary_search_l1_with_dups ... bench:          37 ns/iter (+/- 5)\ntest slice::binary_search_l2           ... bench:          75 ns/iter (+/- 3)\ntest slice::binary_search_l2_with_dups ... bench:          56 ns/iter (+/- 3)\ntest slice::binary_search_l3           ... bench:         195 ns/iter (+/- 15)\ntest slice::binary_search_l3_with_dups ... bench:         151 ns/iter (+/- 7)\n\n$ ./x.py bench --stage 1 library/libcore\ntest slice::binary_search_l1           ... bench:          57 ns/iter (+/- 2)\ntest slice::binary_search_l1_with_dups ... bench:          38 ns/iter (+/- 2)\ntest slice::binary_search_l2           ... bench:          77 ns/iter (+/- 11)\ntest slice::binary_search_l2_with_dups ... bench:          57 ns/iter (+/- 4)\ntest slice::binary_search_l3           ... bench:         194 ns/iter (+/- 15)\ntest slice::binary_search_l3_with_dups ... bench:         151 ns/iter (+/- 18)\n\n```\n\nI run some benchmarking testings against on two implementations. The new implementation has a lot of improvement in duplicates cases, while in `binary_search_l3` case, it's a little bit slower than the old one.", "tree": {"sha": "d44eccfc52b379ba28baff51a5f8acd757a391c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d44eccfc52b379ba28baff51a5f8acd757a391c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caca2121ffe4cb47d8ea2d9469c493995f57e0b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caca2121ffe4cb47d8ea2d9469c493995f57e0b5", "html_url": "https://github.com/rust-lang/rust/commit/caca2121ffe4cb47d8ea2d9469c493995f57e0b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caca2121ffe4cb47d8ea2d9469c493995f57e0b5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fd946c63a6c3aae9788bd459d278cb2efa77099", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fd946c63a6c3aae9788bd459d278cb2efa77099", "html_url": "https://github.com/rust-lang/rust/commit/8fd946c63a6c3aae9788bd459d278cb2efa77099"}, {"sha": "3eb5bee242fae12c4cf547bfe0665653c20ca0c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eb5bee242fae12c4cf547bfe0665653c20ca0c2", "html_url": "https://github.com/rust-lang/rust/commit/3eb5bee242fae12c4cf547bfe0665653c20ca0c2"}], "stats": {"total": 109, "additions": 80, "deletions": 29}, "files": [{"sha": "dbab00856863b2efaa08cfa1095379a9edac7337", "filename": "library/core/benches/slice.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/caca2121ffe4cb47d8ea2d9469c493995f57e0b5/library%2Fcore%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caca2121ffe4cb47d8ea2d9469c493995f57e0b5/library%2Fcore%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fslice.rs?ref=caca2121ffe4cb47d8ea2d9469c493995f57e0b5", "patch": "@@ -7,15 +7,21 @@ enum Cache {\n     L3,\n }\n \n+impl Cache {\n+    fn size(&self) -> usize {\n+        match self {\n+            Cache::L1 => 1000,      // 8kb\n+            Cache::L2 => 10_000,    // 80kb\n+            Cache::L3 => 1_000_000, // 8Mb\n+        }\n+    }\n+}\n+\n fn binary_search<F>(b: &mut Bencher, cache: Cache, mapper: F)\n where\n     F: Fn(usize) -> usize,\n {\n-    let size = match cache {\n-        Cache::L1 => 1000,      // 8kb\n-        Cache::L2 => 10_000,    // 80kb\n-        Cache::L3 => 1_000_000, // 8Mb\n-    };\n+    let size = cache.size();\n     let v = (0..size).map(&mapper).collect::<Vec<_>>();\n     let mut r = 0usize;\n     b.iter(move || {\n@@ -24,7 +30,18 @@ where\n         // Lookup the whole range to get 50% hits and 50% misses.\n         let i = mapper(r % size);\n         black_box(v.binary_search(&i).is_ok());\n-    })\n+    });\n+}\n+\n+fn binary_search_worst_case(b: &mut Bencher, cache: Cache) {\n+    let size = cache.size();\n+\n+    let mut v = vec![0; size];\n+    let i = 1;\n+    v[size - 1] = i;\n+    b.iter(move || {\n+        black_box(v.binary_search(&i).is_ok());\n+    });\n }\n \n #[bench]\n@@ -57,6 +74,21 @@ fn binary_search_l3_with_dups(b: &mut Bencher) {\n     binary_search(b, Cache::L3, |i| i / 16 * 16);\n }\n \n+#[bench]\n+fn binary_search_l1_worst_case(b: &mut Bencher) {\n+    binary_search_worst_case(b, Cache::L1);\n+}\n+\n+#[bench]\n+fn binary_search_l2_worst_case(b: &mut Bencher) {\n+    binary_search_worst_case(b, Cache::L2);\n+}\n+\n+#[bench]\n+fn binary_search_l3_worst_case(b: &mut Bencher) {\n+    binary_search_worst_case(b, Cache::L3);\n+}\n+\n macro_rules! rotate {\n     ($fn:ident, $n:expr, $mapper:expr) => {\n         #[bench]"}, {"sha": "5510bb0257e3424af7f4e60f4ea536606da64733", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/caca2121ffe4cb47d8ea2d9469c493995f57e0b5/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caca2121ffe4cb47d8ea2d9469c493995f57e0b5/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=caca2121ffe4cb47d8ea2d9469c493995f57e0b5", "patch": "@@ -8,7 +8,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::cmp::Ordering::{self, Equal, Greater, Less};\n+use crate::cmp::Ordering::{self, Greater, Less};\n use crate::marker::Copy;\n use crate::mem;\n use crate::num::NonZeroUsize;\n@@ -2185,25 +2185,31 @@ impl<T> [T] {\n     where\n         F: FnMut(&'a T) -> Ordering,\n     {\n-        let s = self;\n-        let mut size = s.len();\n-        if size == 0 {\n-            return Err(0);\n-        }\n-        let mut base = 0usize;\n-        while size > 1 {\n-            let half = size / 2;\n-            let mid = base + half;\n-            // SAFETY: the call is made safe by the following inconstants:\n-            // - `mid >= 0`: by definition\n-            // - `mid < size`: `mid = size / 2 + size / 4 + size / 8 ...`\n-            let cmp = f(unsafe { s.get_unchecked(mid) });\n-            base = if cmp == Greater { base } else { mid };\n-            size -= half;\n+        let mut size = self.len();\n+        let mut left = 0;\n+        let mut right = size;\n+        while left < right {\n+            let mid = left + size / 2;\n+\n+            // SAFETY: the call is made safe by the following invariants:\n+            // - `mid >= 0`\n+            // - `mid < size`: `mid` is limited by `[left; right)` bound.\n+            let cmp = f(unsafe { self.get_unchecked(mid) });\n+\n+            // The reason why we use if/else control flow rather than match\n+            // is because match reorders comparison operations, which is perf sensitive.\n+            // This is x86 asm for u8: https://rust.godbolt.org/z/8Y8Pra.\n+            if cmp == Less {\n+                left = mid + 1;\n+            } else if cmp == Greater {\n+                right = mid;\n+            } else {\n+                return Ok(mid);\n+            }\n+\n+            size = right - left;\n         }\n-        // SAFETY: base is always in [0, size) because base <= mid.\n-        let cmp = f(unsafe { s.get_unchecked(base) });\n-        if cmp == Equal { Ok(base) } else { Err(base + (cmp == Less) as usize) }\n+        Err(left)\n     }\n \n     /// Binary searches this sorted slice with a key extraction function."}, {"sha": "7e198631cc7eb7ab48b2a6f46464b1804fb3744c", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/caca2121ffe4cb47d8ea2d9469c493995f57e0b5/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caca2121ffe4cb47d8ea2d9469c493995f57e0b5/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=caca2121ffe4cb47d8ea2d9469c493995f57e0b5", "patch": "@@ -1,4 +1,5 @@\n use core::cell::Cell;\n+use core::cmp::Ordering;\n use core::result::Result::{Err, Ok};\n \n #[test]\n@@ -64,6 +65,17 @@ fn test_binary_search() {\n     assert_eq!(b.binary_search(&6), Err(4));\n     assert_eq!(b.binary_search(&7), Ok(4));\n     assert_eq!(b.binary_search(&8), Err(5));\n+\n+    let b = [(); usize::MAX];\n+    assert_eq!(b.binary_search(&()), Ok(usize::MAX / 2));\n+}\n+\n+#[test]\n+fn test_binary_search_by_overflow() {\n+    let b = [(); usize::MAX];\n+    assert_eq!(b.binary_search_by(|_| Ordering::Equal), Ok(usize::MAX / 2));\n+    assert_eq!(b.binary_search_by(|_| Ordering::Greater), Err(0));\n+    assert_eq!(b.binary_search_by(|_| Ordering::Less), Err(usize::MAX));\n }\n \n #[test]\n@@ -73,13 +85,13 @@ fn test_binary_search_implementation_details() {\n     let b = [1, 1, 2, 2, 3, 3, 3];\n     assert_eq!(b.binary_search(&1), Ok(1));\n     assert_eq!(b.binary_search(&2), Ok(3));\n-    assert_eq!(b.binary_search(&3), Ok(6));\n+    assert_eq!(b.binary_search(&3), Ok(5));\n     let b = [1, 1, 1, 1, 1, 3, 3, 3, 3];\n     assert_eq!(b.binary_search(&1), Ok(4));\n-    assert_eq!(b.binary_search(&3), Ok(8));\n+    assert_eq!(b.binary_search(&3), Ok(7));\n     let b = [1, 1, 1, 1, 3, 3, 3, 3, 3];\n-    assert_eq!(b.binary_search(&1), Ok(3));\n-    assert_eq!(b.binary_search(&3), Ok(8));\n+    assert_eq!(b.binary_search(&1), Ok(2));\n+    assert_eq!(b.binary_search(&3), Ok(4));\n }\n \n #[test]\n@@ -1982,6 +1994,7 @@ fn test_copy_within_panics_dest_too_long() {\n     // The length is only 13, so a slice of length 4 starting at index 10 is out of bounds.\n     bytes.copy_within(0..4, 10);\n }\n+\n #[test]\n #[should_panic(expected = \"slice index starts at 2 but ends at 1\")]\n fn test_copy_within_panics_src_inverted() {"}]}