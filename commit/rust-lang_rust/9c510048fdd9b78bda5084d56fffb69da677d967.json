{"sha": "9c510048fdd9b78bda5084d56fffb69da677d967", "node_id": "C_kwDOAAsO6NoAKDljNTEwMDQ4ZmRkOWI3OGJkYTUwODRkNTZmZmZiNjlkYTY3N2Q5Njc", "commit": {"author": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2022-11-17T20:57:45Z"}, "committer": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2022-11-18T13:25:17Z"}, "message": "`InferCtxt::is_tainted_by_errors` returns `ErrorGuaranteed`", "tree": {"sha": "eb0184943eb841ad4ebc63e05d6405ed7cfd413f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb0184943eb841ad4ebc63e05d6405ed7cfd413f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c510048fdd9b78bda5084d56fffb69da677d967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c510048fdd9b78bda5084d56fffb69da677d967", "html_url": "https://github.com/rust-lang/rust/commit/9c510048fdd9b78bda5084d56fffb69da677d967", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c510048fdd9b78bda5084d56fffb69da677d967/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1ec8ff14d491642d8c8ae5a9f3c94db4eda9f26", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1ec8ff14d491642d8c8ae5a9f3c94db4eda9f26", "html_url": "https://github.com/rust-lang/rust/commit/c1ec8ff14d491642d8c8ae5a9f3c94db4eda9f26"}], "stats": {"total": 68, "additions": 33, "deletions": 35}, "files": [{"sha": "1591048d6570286612e6572b7e719e9325e73466", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=9c510048fdd9b78bda5084d56fffb69da677d967", "patch": "@@ -19,7 +19,7 @@ extern crate tracing;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::vec_map::VecMap;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::ChunkedBitSet;"}, {"sha": "b1060d9505c0b1492c618678afcc93ab4ce0559c", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=9c510048fdd9b78bda5084d56fffb69da677d967", "patch": "@@ -219,8 +219,8 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         instantiated_ty: OpaqueHiddenType<'tcx>,\n         origin: OpaqueTyOrigin,\n     ) -> Ty<'tcx> {\n-        if self.is_tainted_by_errors() {\n-            return self.tcx.ty_error();\n+        if let Some(e) = self.is_tainted_by_errors() {\n+            return self.tcx.ty_error_with_guaranteed(e);\n         }\n \n         let definition_ty = instantiated_ty"}, {"sha": "653c841290d020b93748d58c826e83dfcf6b6eef", "filename": "compiler/rustc_hir_typeck/src/fallback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs?ref=9c510048fdd9b78bda5084d56fffb69da677d967", "patch": "@@ -104,7 +104,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // type, `?T` is not considered unsolved, but `?I` is. The\n         // same is true for float variables.)\n         let fallback = match ty.kind() {\n-            _ if self.is_tainted_by_errors() => self.tcx.ty_error(),\n+            _ if let Some(e) = self.is_tainted_by_errors() => self.tcx.ty_error_with_guaranteed(e),\n             ty::Infer(ty::IntVar(_)) => self.tcx.types.i32,\n             ty::Infer(ty::FloatVar(_)) => self.tcx.types.f64,\n             _ => match diverging_fallback.get(&ty) {"}, {"sha": "86e7f818d5498ce24d18e8965aa4d0297112fe44", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=9c510048fdd9b78bda5084d56fffb69da677d967", "patch": "@@ -528,7 +528,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {\n         match self.typeck_results.borrow().node_types().get(id) {\n             Some(&t) => t,\n-            None if self.is_tainted_by_errors() => self.tcx.ty_error(),\n+            None if let Some(e) = self.is_tainted_by_errors() => self.tcx.ty_error_with_guaranteed(e),\n             None => {\n                 bug!(\n                     \"no type for node {}: {} in fcx {}\",\n@@ -543,7 +543,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn node_ty_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n         match self.typeck_results.borrow().node_types().get(id) {\n             Some(&t) => Some(t),\n-            None if self.is_tainted_by_errors() => Some(self.tcx.ty_error()),\n+            None if let Some(e) = self.is_tainted_by_errors() => Some(self.tcx.ty_error_with_guaranteed(e)),\n             None => None,\n         }\n     }\n@@ -1440,7 +1440,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if !ty.is_ty_var() {\n             ty\n         } else {\n-            if !self.is_tainted_by_errors() {\n+            if let None = self.is_tainted_by_errors() {\n                 self.err_ctxt()\n                     .emit_inference_failure_err((**self).body_id, sp, ty.into(), E0282, true)\n                     .emit();"}, {"sha": "56d8ce2a5c66d246e49f75ecc31bd767cbe3f711", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=9c510048fdd9b78bda5084d56fffb69da677d967", "patch": "@@ -344,7 +344,7 @@ fn typeck_with_fallback<'tcx>(\n \n         fcx.select_all_obligations_or_error();\n \n-        if !fcx.infcx.is_tainted_by_errors() {\n+        if let None = fcx.infcx.is_tainted_by_errors() {\n             fcx.check_transmutes();\n         }\n "}, {"sha": "495502da40670fe7d107df2330a81a7f14e1ec19", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=9c510048fdd9b78bda5084d56fffb69da677d967", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     }\n \n     fn is_tainted_by_errors(&self) -> bool {\n-        self.infcx.is_tainted_by_errors()\n+        self.infcx.is_tainted_by_errors().is_some()\n     }\n \n     fn resolve_type_vars_or_error("}, {"sha": "d3b704a672beed1d542b6fb51bb6b2956ede84dd", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=9c510048fdd9b78bda5084d56fffb69da677d967", "patch": "@@ -83,10 +83,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.typeck_results.treat_byte_string_as_slice =\n             mem::take(&mut self.typeck_results.borrow_mut().treat_byte_string_as_slice);\n \n-        if self.is_tainted_by_errors() {\n-            // FIXME(eddyb) keep track of `ErrorGuaranteed` from where the error was emitted.\n-            wbcx.typeck_results.tainted_by_errors =\n-                Some(ErrorGuaranteed::unchecked_claim_error_was_emitted());\n+        if let Some(e) = self.is_tainted_by_errors() {\n+            wbcx.typeck_results.tainted_by_errors = Some(e);\n         }\n \n         debug!(\"writeback: typeck results for {:?} are {:#?}\", item_def_id, wbcx.typeck_results);"}, {"sha": "f966c7bb776d72dd186d5249da88d380c06c44c2", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=9c510048fdd9b78bda5084d56fffb69da677d967", "patch": "@@ -1208,7 +1208,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// reporting errors that often occur as a result of earlier\n     /// errors, but where it's hard to be 100% sure (e.g., unresolved\n     /// inference variables, regionck errors).\n-    pub fn is_tainted_by_errors(&self) -> bool {\n+    pub fn is_tainted_by_errors(&self) -> Option<ErrorGuaranteed> {\n         debug!(\n             \"is_tainted_by_errors(err_count={}, err_count_on_creation={}, \\\n              tainted_by_errors={})\",\n@@ -1218,9 +1218,13 @@ impl<'tcx> InferCtxt<'tcx> {\n         );\n \n         if self.tcx.sess.err_count() > self.err_count_on_creation {\n-            return true; // errors reported since this infcx was made\n+            // errors reported since this infcx was made\n+            return Some(self.tcx.sess.delay_span_bug(\n+                DUMMY_SP,\n+                \"`tcx.sess.error_count()` incorrectly returned non zero value\",\n+            ));\n         }\n-        self.tainted_by_errors.get().is_some()\n+        self.tainted_by_errors.get()\n     }\n \n     /// Set the \"tainted by errors\" flag to true. We call this when we\n@@ -1270,7 +1274,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             let mut inner = self.inner.borrow_mut();\n             let inner = &mut *inner;\n             assert!(\n-                self.is_tainted_by_errors() || inner.region_obligations.is_empty(),\n+                self.is_tainted_by_errors().is_some() || inner.region_obligations.is_empty(),\n                 \"region_obligations not empty: {:#?}\",\n                 inner.region_obligations\n             );\n@@ -1707,7 +1711,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     ) {\n         let errors = self.resolve_regions(outlives_env);\n \n-        if !self.is_tainted_by_errors() {\n+        if let None = self.is_tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors\n             // altogether if other errors have been reported while\n             // this infcx was in use.  This is totally hokey but"}, {"sha": "c96c1f78146b8dc96037b83e7f8d7353304eee0f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=9c510048fdd9b78bda5084d56fffb69da677d967", "patch": "@@ -2060,7 +2060,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // check upstream for type errors and don't add the obligations to\n                 // begin with in those cases.\n                 if self.tcx.lang_items().sized_trait() == Some(trait_ref.def_id()) {\n-                    if !self.is_tainted_by_errors() {\n+                    if let None = self.is_tainted_by_errors() {\n                         self.emit_inference_failure_err(\n                             body_id,\n                             span,\n@@ -2115,16 +2115,14 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         if impls.len() > 1 && impls.len() < 5 && has_non_region_infer {\n                             self.annotate_source_of_ambiguity(&mut err, &impls, predicate);\n                         } else {\n-                            if self.is_tainted_by_errors() {\n-                                err.delay_as_bug();\n+                            if self.is_tainted_by_errors().is_some() {\n                                 return;\n                             }\n                             err.note(&format!(\"cannot satisfy `{}`\", predicate));\n                         }\n                     }\n                     _ => {\n-                        if self.is_tainted_by_errors() {\n-                            err.delay_as_bug();\n+                        if self.is_tainted_by_errors().is_some() {\n                             return;\n                         }\n                         err.note(&format!(\"cannot satisfy `{}`\", predicate));\n@@ -2226,7 +2224,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         ] = path.segments\n                         && data.trait_ref.def_id == *trait_id\n                         && self.tcx.trait_of_item(*item_id) == Some(*trait_id)\n-                        && !self.is_tainted_by_errors()\n+                        && let None = self.is_tainted_by_errors()\n                     {\n                         let (verb, noun) = match self.tcx.associated_item(item_id).kind {\n                             ty::AssocKind::Const => (\"refer to the\", \"constant\"),\n@@ -2295,7 +2293,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // with error messages.\n                 if arg.references_error()\n                     || self.tcx.sess.has_errors().is_some()\n-                    || self.is_tainted_by_errors()\n+                    || self.is_tainted_by_errors().is_some()\n                 {\n                     return;\n                 }\n@@ -2306,7 +2304,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             ty::PredicateKind::Subtype(data) => {\n                 if data.references_error()\n                     || self.tcx.sess.has_errors().is_some()\n-                    || self.is_tainted_by_errors()\n+                    || self.is_tainted_by_errors().is_some()\n                 {\n                     // no need to overload user in such cases\n                     return;\n@@ -2317,7 +2315,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 self.emit_inference_failure_err(body_id, span, a.into(), ErrorCode::E0282, true)\n             }\n             ty::PredicateKind::Projection(data) => {\n-                if predicate.references_error() || self.is_tainted_by_errors() {\n+                if predicate.references_error() || self.is_tainted_by_errors().is_some() {\n                     return;\n                 }\n                 let subst = data\n@@ -2351,7 +2349,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n \n             ty::PredicateKind::ConstEvaluatable(data) => {\n-                if predicate.references_error() || self.is_tainted_by_errors() {\n+                if predicate.references_error() || self.is_tainted_by_errors().is_some() {\n                     return;\n                 }\n                 let subst = data.walk().find(|g| g.is_non_region_infer());\n@@ -2378,7 +2376,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n             _ => {\n-                if self.tcx.sess.has_errors().is_some() || self.is_tainted_by_errors() {\n+                if self.tcx.sess.has_errors().is_some() || self.is_tainted_by_errors().is_some() {\n                     return;\n                 }\n                 let mut err = struct_span_err!(\n@@ -2422,7 +2420,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         post.sort();\n         post.dedup();\n \n-        if self.is_tainted_by_errors()\n+        if self.is_tainted_by_errors().is_some()\n             && (crate_names.len() == 1\n                 && spans.len() == 0\n                 && [\"`core`\", \"`alloc`\", \"`std`\"].contains(&crate_names[0].as_str())"}, {"sha": "8a2bfb5351fd9e00e79cc370c8696244d0f836e7", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c510048fdd9b78bda5084d56fffb69da677d967/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=9c510048fdd9b78bda5084d56fffb69da677d967", "patch": "@@ -33,7 +33,7 @@ use crate::traits::ProjectionCacheKey;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::{Diagnostic, ErrorGuaranteed};\n+use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n@@ -1089,10 +1089,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if !self.infcx.tcx.recursion_limit().value_within_limit(depth) {\n             match self.query_mode {\n                 TraitQueryMode::Standard => {\n-                    if self.infcx.is_tainted_by_errors() {\n-                        return Err(OverflowError::Error(\n-                            ErrorGuaranteed::unchecked_claim_error_was_emitted(),\n-                        ));\n+                    if let Some(e) = self.infcx.is_tainted_by_errors() {\n+                        return Err(OverflowError::Error(e));\n                     }\n                     self.infcx.err_ctxt().report_overflow_error(error_obligation, true);\n                 }"}]}