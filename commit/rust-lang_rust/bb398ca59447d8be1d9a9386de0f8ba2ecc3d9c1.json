{"sha": "bb398ca59447d8be1d9a9386de0f8ba2ecc3d9c1", "node_id": "C_kwDOAAsO6NoAKGJiMzk4Y2E1OTQ0N2Q4YmUxZDlhOTM4NmRlMGY4YmEyZWNjM2Q5YzE", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-04-29T05:23:25Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-04-29T05:23:25Z"}, "message": "Remove hacks in `make_token_stream`.\n\n`make_tokenstream` has three commented hacks, and a comment at the top\nreferring to #67062. These hacks have no observable effect, at least as judged\nby running the test suite. The hacks were added in #82608, with an explanation\n[here](https://github.com/rust-lang/rust/pull/82608#issuecomment-812877329). It\nappears that one of the following is true: (a) they never did anything useful,\n(b) they do something useful but we have no test coverage for them, or (c)\nsomething has changed in the meantime that means they are no longer necessary.\n\nThis commit removes the hacks and the comments, in the hope that (b) is not\ntrue.", "tree": {"sha": "51f5bf6a313d46590a84e9eaf25bbd1ceb3f8c10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51f5bf6a313d46590a84e9eaf25bbd1ceb3f8c10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb398ca59447d8be1d9a9386de0f8ba2ecc3d9c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb398ca59447d8be1d9a9386de0f8ba2ecc3d9c1", "html_url": "https://github.com/rust-lang/rust/commit/bb398ca59447d8be1d9a9386de0f8ba2ecc3d9c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb398ca59447d8be1d9a9386de0f8ba2ecc3d9c1/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baaa3b682986879c7784b5733ecea942e9ae7de3", "url": "https://api.github.com/repos/rust-lang/rust/commits/baaa3b682986879c7784b5733ecea942e9ae7de3", "html_url": "https://github.com/rust-lang/rust/commit/baaa3b682986879c7784b5733ecea942e9ae7de3"}], "stats": {"total": 38, "additions": 0, "deletions": 38}, "files": [{"sha": "66db5bf9d7cf2266bc08294892cb82c77b9100df", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bb398ca59447d8be1d9a9386de0f8ba2ecc3d9c1/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb398ca59447d8be1d9a9386de0f8ba2ecc3d9c1/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=bb398ca59447d8be1d9a9386de0f8ba2ecc3d9c1", "patch": "@@ -388,12 +388,6 @@ impl<'a> Parser<'a> {\n /// Converts a flattened iterator of tokens (including open and close delimiter tokens)\n /// into a `TokenStream`, creating a `TokenTree::Delimited` for each matching pair\n /// of open and close delims.\n-// FIXME(#67062): Currently, we don't parse `Invisible`-delimited groups correctly,\n-// which can cause us to end up with mismatched `Invisible` delimiters in our\n-// captured tokens. This function contains several hacks to work around this -\n-// essentially, we throw away mismatched `Invisible` delimiters when we encounter them.\n-// Once we properly parse `Invisible` delimiters, they can be captured just like any\n-// other tokens, and these hacks can be removed.\n fn make_token_stream(\n     mut iter: impl Iterator<Item = (FlatToken, Spacing)>,\n     break_last_token: bool,\n@@ -412,35 +406,10 @@ fn make_token_stream(\n                 stack.push(FrameData { open_delim_sp: Some((delim, span)), inner: vec![] });\n             }\n             FlatToken::Token(Token { kind: TokenKind::CloseDelim(delim), span }) => {\n-                // HACK: If we encounter a mismatched `Invisible` delimiter at the top\n-                // level, just ignore it.\n-                if matches!(delim, Delimiter::Invisible)\n-                    && (stack.len() == 1\n-                        || !matches!(\n-                            stack.last_mut().unwrap().open_delim_sp.unwrap().0,\n-                            Delimiter::Invisible\n-                        ))\n-                {\n-                    token_and_spacing = iter.next();\n-                    continue;\n-                }\n                 let frame_data = stack\n                     .pop()\n                     .unwrap_or_else(|| panic!(\"Token stack was empty for token: {:?}\", token));\n \n-                // HACK: If our current frame has a mismatched opening `Invisible` delimiter,\n-                // merge our current frame with the one above it. That is, transform\n-                // `[ { < first second } third ]` into `[ { first second } third ]`\n-                if !matches!(delim, Delimiter::Invisible)\n-                    && matches!(frame_data.open_delim_sp.unwrap().0, Delimiter::Invisible)\n-                {\n-                    stack.last_mut().unwrap().inner.extend(frame_data.inner);\n-                    // Process our closing delimiter again, this time at the previous\n-                    // frame in the stack\n-                    token_and_spacing = Some((token, spacing));\n-                    continue;\n-                }\n-\n                 let (open_delim, open_sp) = frame_data.open_delim_sp.unwrap();\n                 assert_eq!(\n                     open_delim, delim,\n@@ -472,13 +441,6 @@ fn make_token_stream(\n         }\n         token_and_spacing = iter.next();\n     }\n-    // HACK: If we don't have a closing `Invisible` delimiter for our last\n-    // frame, merge the frame with the top-level frame. That is,\n-    // turn `< first second` into `first second`\n-    if stack.len() == 2 && stack[1].open_delim_sp.unwrap().0 == Delimiter::Invisible {\n-        let temp_buf = stack.pop().unwrap();\n-        stack.last_mut().unwrap().inner.extend(temp_buf.inner);\n-    }\n     let mut final_buf = stack.pop().expect(\"Missing final buf!\");\n     if break_last_token {\n         let (last_token, spacing) = final_buf.inner.pop().unwrap();"}]}