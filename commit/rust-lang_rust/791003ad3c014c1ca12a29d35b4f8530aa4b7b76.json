{"sha": "791003ad3c014c1ca12a29d35b4f8530aa4b7b76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MTAwM2FkM2MwMTRjMWNhMTJhMjlkMzViNGY4NTMwYWE0YjdiNzY=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2015-11-10T11:16:28Z"}, "committer": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2015-11-10T11:16:28Z"}, "message": "Use deref coercions", "tree": {"sha": "b966a8c8926463991e4677e2164cf87b9ff6cc90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b966a8c8926463991e4677e2164cf87b9ff6cc90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/791003ad3c014c1ca12a29d35b4f8530aa4b7b76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/791003ad3c014c1ca12a29d35b4f8530aa4b7b76", "html_url": "https://github.com/rust-lang/rust/commit/791003ad3c014c1ca12a29d35b4f8530aa4b7b76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/791003ad3c014c1ca12a29d35b4f8530aa4b7b76/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b4986fa5753b9662c8baab1c31b9b79bc84ca19", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b4986fa5753b9662c8baab1c31b9b79bc84ca19", "html_url": "https://github.com/rust-lang/rust/commit/5b4986fa5753b9662c8baab1c31b9b79bc84ca19"}], "stats": {"total": 40, "additions": 20, "deletions": 20}, "files": [{"sha": "10731178c0610fb85f7d02c62f712b2d8b430430", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/791003ad3c014c1ca12a29d35b4f8530aa4b7b76/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791003ad3c014c1ca12a29d35b4f8530aa4b7b76/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=791003ad3c014c1ca12a29d35b4f8530aa4b7b76", "patch": "@@ -86,7 +86,7 @@ fn filter_foreign_item<F>(cx: &mut Context<F>,\n                           -> Option<P<ast::ForeignItem>> where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n-    if foreign_item_in_cfg(cx, &*item) {\n+    if foreign_item_in_cfg(cx, &item) {\n         Some(item)\n     } else {\n         None\n@@ -109,7 +109,7 @@ fn fold_foreign_mod<F>(cx: &mut Context<F>,\n fn fold_item<F>(cx: &mut Context<F>, item: P<ast::Item>) -> SmallVector<P<ast::Item>> where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n-    if item_in_cfg(cx, &*item) {\n+    if item_in_cfg(cx, &item) {\n         SmallVector::one(item.map(|i| cx.fold_item_simple(i)))\n     } else {\n         SmallVector::zero()\n@@ -189,7 +189,7 @@ fn retain_stmt<F>(cx: &mut Context<F>, stmt: &ast::Stmt) -> bool where\n         ast::StmtDecl(ref decl, _) => {\n             match decl.node {\n                 ast::DeclItem(ref item) => {\n-                    item_in_cfg(cx, &**item)\n+                    item_in_cfg(cx, item)\n                 }\n                 _ => true\n             }\n@@ -203,7 +203,7 @@ fn fold_block<F>(cx: &mut Context<F>, b: P<ast::Block>) -> P<ast::Block> where\n {\n     b.map(|ast::Block {id, stmts, expr, rules, span}| {\n         let resulting_stmts: Vec<P<ast::Stmt>> =\n-            stmts.into_iter().filter(|a| retain_stmt(cx, &**a)).collect();\n+            stmts.into_iter().filter(|a| retain_stmt(cx, a)).collect();\n         let resulting_stmts = resulting_stmts.into_iter()\n             .flat_map(|stmt| cx.fold_stmt(stmt).into_iter())\n             .collect();\n@@ -263,7 +263,7 @@ fn in_cfg(diagnostic: &SpanHandler, cfg: &[P<ast::MetaItem>], attrs: &[ast::Attr\n             return true;\n         }\n \n-        attr::cfg_matches(diagnostic, cfg, &*mis[0],\n+        attr::cfg_matches(diagnostic, cfg, &mis[0],\n                           feature_gated_cfgs)\n     })\n }"}, {"sha": "48199026204c8968789d3bf67feeb1c26bdd701d", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791003ad3c014c1ca12a29d35b4f8530aa4b7b76/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791003ad3c014c1ca12a29d35b4f8530aa4b7b76/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=791003ad3c014c1ca12a29d35b4f8530aa4b7b76", "patch": "@@ -33,7 +33,7 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n         return DummyResult::expr(sp);\n     }\n \n-    let matches_cfg = attr::cfg_matches(&cx.parse_sess.span_diagnostic, &cx.cfg, &*cfg,\n+    let matches_cfg = attr::cfg_matches(&cx.parse_sess.span_diagnostic, &cx.cfg, &cfg,\n                                         cx.feature_gated_cfgs);\n     MacEager::expr(cx.expr_bool(sp, matches_cfg))\n }"}, {"sha": "ba07c452e2a593ad303e81fc3d33ca7f4e94888b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/791003ad3c014c1ca12a29d35b4f8530aa4b7b76/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791003ad3c014c1ca12a29d35b4f8530aa4b7b76/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=791003ad3c014c1ca12a29d35b4f8530aa4b7b76", "patch": "@@ -547,7 +547,7 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n                     // names, as well... but that should be okay, as long as\n                     // the new names are gensyms for the old ones.\n                     // generate fresh names, push them to a new pending list\n-                    let idents = pattern_bindings(&*expanded_pat);\n+                    let idents = pattern_bindings(&expanded_pat);\n                     let mut new_pending_renames =\n                         idents.iter().map(|ident| (*ident, fresh_name(*ident))).collect();\n                     // rewrite the pattern using the new names (the old\n@@ -634,7 +634,7 @@ fn rename_in_scope<X, F>(pats: Vec<P<ast::Pat>>,\n {\n     // all of the pats must have the same set of bindings, so use the\n     // first one to extract them and generate new names:\n-    let idents = pattern_bindings(&*pats[0]);\n+    let idents = pattern_bindings(&pats[0]);\n     let new_renames = idents.into_iter().map(|id| (id, fresh_name(id))).collect();\n     // apply the renaming, but only to the PatIdents:\n     let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n@@ -659,7 +659,7 @@ impl<'v> Visitor<'v> for PatIdentFinder {\n                 self.ident_accumulator.push(path1.node);\n                 // visit optional subpattern of PatIdent:\n                 if let Some(ref subpat) = *inner {\n-                    self.visit_pat(&**subpat)\n+                    self.visit_pat(subpat)\n                 }\n             }\n             // use the default traversal for non-PatIdents\n@@ -679,7 +679,7 @@ fn pattern_bindings(pat: &ast::Pat) -> Vec<ast::Ident> {\n fn fn_decl_arg_bindings(fn_decl: &ast::FnDecl) -> Vec<ast::Ident> {\n     let mut pat_idents = PatIdentFinder{ident_accumulator:Vec::new()};\n     for arg in &fn_decl.inputs {\n-        pat_idents.visit_pat(&*arg.pat);\n+        pat_idents.visit_pat(&arg.pat);\n     }\n     pat_idents.ident_accumulator\n }\n@@ -1078,7 +1078,7 @@ fn expand_and_rename_fn_decl_and_block(fn_decl: P<ast::FnDecl>, block: P<ast::Bl\n                                        fld: &mut MacroExpander)\n                                        -> (P<ast::FnDecl>, P<ast::Block>) {\n     let expanded_decl = fld.fold_fn_decl(fn_decl);\n-    let idents = fn_decl_arg_bindings(&*expanded_decl);\n+    let idents = fn_decl_arg_bindings(&expanded_decl);\n     let renames =\n         idents.iter().map(|id| (*id,fresh_name(*id))).collect();\n     // first, a renamer for the PatIdents, for the fn_decl:\n@@ -1807,7 +1807,7 @@ foo_module!();\n     fn pat_idents(){\n         let pat = string_to_pat(\n             \"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\".to_string());\n-        let idents = pattern_bindings(&*pat);\n+        let idents = pattern_bindings(&pat);\n         assert_eq!(idents, strs_to_idents(vec!(\"a\",\"c\",\"b\",\"d\")));\n     }\n "}, {"sha": "35853256651db11f7d2461c0f1e360b1a0cecbf7", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791003ad3c014c1ca12a29d35b4f8530aa4b7b76/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791003ad3c014c1ca12a29d35b4f8530aa4b7b76/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=791003ad3c014c1ca12a29d35b4f8530aa4b7b76", "patch": "@@ -289,7 +289,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n     };\n \n     for lhs in &lhses {\n-        check_lhs_nt_follows(cx, &**lhs, def.span);\n+        check_lhs_nt_follows(cx, lhs, def.span);\n     }\n \n     let rhses = match **argument_map.get(&rhs_nm.name).unwrap() {"}, {"sha": "284bf46cc3fcd37e37d522fb692e82d254b1b6e2", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791003ad3c014c1ca12a29d35b4f8530aa4b7b76/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791003ad3c014c1ca12a29d35b4f8530aa4b7b76/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=791003ad3c014c1ca12a29d35b4f8530aa4b7b76", "patch": "@@ -673,7 +673,7 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n             token::NtIdent(Box::new(fld.fold_ident(*id)), is_mod_name),\n         token::NtMeta(meta_item) => token::NtMeta(fld.fold_meta_item(meta_item)),\n         token::NtPath(path) => token::NtPath(Box::new(fld.fold_path(*path))),\n-        token::NtTT(tt) => token::NtTT(P(fld.fold_tt(&*tt))),\n+        token::NtTT(tt) => token::NtTT(P(fld.fold_tt(&tt))),\n         token::NtArm(arm) => token::NtArm(fld.fold_arm(arm)),\n         token::NtImplItem(arm) =>\n             token::NtImplItem(fld.fold_impl_item(arm)"}, {"sha": "8b3faaaca146a9d7d512201b7f4cade3ce3fef65", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791003ad3c014c1ca12a29d35b4f8530aa4b7b76/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791003ad3c014c1ca12a29d35b4f8530aa4b7b76/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=791003ad3c014c1ca12a29d35b4f8530aa4b7b76", "patch": "@@ -53,7 +53,7 @@ pub fn stmt_ends_with_semi(stmt: &ast::Stmt_) -> bool {\n                 ast::DeclItem(_) => false\n             }\n         }\n-        ast::StmtExpr(ref e, _) => { expr_requires_semi_to_be_stmt(&**e) }\n+        ast::StmtExpr(ref e, _) => { expr_requires_semi_to_be_stmt(e) }\n         ast::StmtSemi(..) => { false }\n         ast::StmtMac(..) => { false }\n     }"}, {"sha": "bf65f82554b0376cbd8ace3d94aa48d88909bfad", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/791003ad3c014c1ca12a29d35b4f8530aa4b7b76/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791003ad3c014c1ca12a29d35b4f8530aa4b7b76/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=791003ad3c014c1ca12a29d35b4f8530aa4b7b76", "patch": "@@ -446,10 +446,10 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n         Some(suf) => {\n             if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n                 // if it looks like a width, lets try to be helpful.\n-                sd.span_err(sp, &*format!(\"invalid width `{}` for float literal\", &suf[1..]));\n+                sd.span_err(sp, &format!(\"invalid width `{}` for float literal\", &suf[1..]));\n                 sd.fileline_help(sp, \"valid widths are 32 and 64\");\n             } else {\n-                sd.span_err(sp, &*format!(\"invalid suffix `{}` for float literal\", suf));\n+                sd.span_err(sp, &format!(\"invalid suffix `{}` for float literal\", suf));\n                 sd.fileline_help(sp, \"valid suffixes are `f32` and `f64`\");\n             }\n \n@@ -619,11 +619,11 @@ pub fn integer_lit(s: &str,\n                 // i<digits> and u<digits> look like widths, so lets\n                 // give an error message along those lines\n                 if looks_like_width_suffix(&['i', 'u'], suf) {\n-                    sd.span_err(sp, &*format!(\"invalid width `{}` for integer literal\",\n-                                              &suf[1..]));\n+                    sd.span_err(sp, &format!(\"invalid width `{}` for integer literal\",\n+                                             &suf[1..]));\n                     sd.fileline_help(sp, \"valid widths are 8, 16, 32 and 64\");\n                 } else {\n-                    sd.span_err(sp, &*format!(\"invalid suffix `{}` for numeric literal\", suf));\n+                    sd.span_err(sp, &format!(\"invalid suffix `{}` for numeric literal\", suf));\n                     sd.fileline_help(sp, \"the suffix must be one of the integral types \\\n                                       (`u32`, `isize`, etc)\");\n                 }"}]}