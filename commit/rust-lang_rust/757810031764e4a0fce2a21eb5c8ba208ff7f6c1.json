{"sha": "757810031764e4a0fce2a21eb5c8ba208ff7f6c1", "node_id": "C_kwDOAAsO6NoAKDc1NzgxMDAzMTc2NGU0YTBmY2UyYTIxZWI1YzhiYTIwOGZmN2Y2YzE", "commit": {"author": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-11-28T02:48:04Z"}, "committer": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-11-30T03:26:04Z"}, "message": "Support most constant kinds in custom mir", "tree": {"sha": "68d4f71c67177588e70d145f87304884361c0c64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68d4f71c67177588e70d145f87304884361c0c64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/757810031764e4a0fce2a21eb5c8ba208ff7f6c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/757810031764e4a0fce2a21eb5c8ba208ff7f6c1", "html_url": "https://github.com/rust-lang/rust/commit/757810031764e4a0fce2a21eb5c8ba208ff7f6c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/757810031764e4a0fce2a21eb5c8ba208ff7f6c1/comments", "author": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a98254179b312f3d03c7ef57c53cdc590fc5c0b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a98254179b312f3d03c7ef57c53cdc590fc5c0b2", "html_url": "https://github.com/rust-lang/rust/commit/a98254179b312f3d03c7ef57c53cdc590fc5c0b2"}], "stats": {"total": 248, "additions": 170, "deletions": 78}, "files": [{"sha": "b2c5aead430daa770627bf8d05ba80bed8104cc8", "filename": "compiler/rustc_mir_build/src/build/custom/parse.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/757810031764e4a0fce2a21eb5c8ba208ff7f6c1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757810031764e4a0fce2a21eb5c8ba208ff7f6c1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs?ref=757810031764e4a0fce2a21eb5c8ba208ff7f6c1", "patch": "@@ -23,6 +23,7 @@ macro_rules! parse_by_kind {\n     (\n         $self:ident,\n         $expr_id:expr,\n+        $expr_name:pat,\n         $expected:literal,\n         $(\n             @call($name:literal, $args:ident) => $call_expr:expr,\n@@ -33,6 +34,8 @@ macro_rules! parse_by_kind {\n     ) => {{\n         let expr_id = $self.preparse($expr_id);\n         let expr = &$self.thir[expr_id];\n+        debug!(\"Trying to parse {:?} as {}\", expr.kind, $expected);\n+        let $expr_name = expr;\n         match &expr.kind {\n             $(\n                 ExprKind::Call { ty, fun: _, args: $args, .. } if {\n@@ -137,26 +140,26 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     /// This allows us to easily parse the basic blocks declarations, local declarations, and\n     /// basic block definitions in order.\n     pub fn parse_body(&mut self, expr_id: ExprId) -> PResult<()> {\n-        let body = parse_by_kind!(self, expr_id, \"whole body\",\n+        let body = parse_by_kind!(self, expr_id, _, \"whole body\",\n             ExprKind::Block { block } => self.thir[*block].expr.unwrap(),\n         );\n-        let (block_decls, rest) = parse_by_kind!(self, body, \"body with block decls\",\n+        let (block_decls, rest) = parse_by_kind!(self, body, _, \"body with block decls\",\n             ExprKind::Block { block } => {\n                 let block = &self.thir[*block];\n                 (&block.stmts, block.expr.unwrap())\n             },\n         );\n         self.parse_block_decls(block_decls.iter().copied())?;\n \n-        let (local_decls, rest) = parse_by_kind!(self, rest, \"body with local decls\",\n+        let (local_decls, rest) = parse_by_kind!(self, rest, _, \"body with local decls\",\n             ExprKind::Block { block } => {\n                 let block = &self.thir[*block];\n                 (&block.stmts, block.expr.unwrap())\n             },\n         );\n         self.parse_local_decls(local_decls.iter().copied())?;\n \n-        let block_defs = parse_by_kind!(self, rest, \"body with block defs\",\n+        let block_defs = parse_by_kind!(self, rest, _, \"body with block defs\",\n             ExprKind::Block { block } => &self.thir[*block].stmts,\n         );\n         for (i, block_def) in block_defs.iter().enumerate() {\n@@ -223,7 +226,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     fn parse_block_def(&self, expr_id: ExprId) -> PResult<BasicBlockData<'tcx>> {\n-        let block = parse_by_kind!(self, expr_id, \"basic block\",\n+        let block = parse_by_kind!(self, expr_id, _, \"basic block\",\n             ExprKind::Block { block } => &self.thir[*block],\n         );\n "}, {"sha": "cd809807a126761322e4286c992664d40243208f", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/757810031764e4a0fce2a21eb5c8ba208ff7f6c1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757810031764e4a0fce2a21eb5c8ba208ff7f6c1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=757810031764e4a0fce2a21eb5c8ba208ff7f6c1", "patch": "@@ -4,7 +4,7 @@ use super::{parse_by_kind, PResult, ParseCtxt};\n \n impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     pub fn parse_statement(&self, expr_id: ExprId) -> PResult<StatementKind<'tcx>> {\n-        parse_by_kind!(self, expr_id, \"statement\",\n+        parse_by_kind!(self, expr_id, _, \"statement\",\n             @call(\"mir_retag\", args) => {\n                 Ok(StatementKind::Retag(RetagKind::Default, Box::new(self.parse_place(args[0])?)))\n             },\n@@ -20,7 +20,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     pub fn parse_terminator(&self, expr_id: ExprId) -> PResult<TerminatorKind<'tcx>> {\n-        parse_by_kind!(self, expr_id, \"terminator\",\n+        parse_by_kind!(self, expr_id, _, \"terminator\",\n             @call(\"mir_return\", _args) => {\n                 Ok(TerminatorKind::Return)\n             },\n@@ -31,7 +31,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     fn parse_rvalue(&self, expr_id: ExprId) -> PResult<Rvalue<'tcx>> {\n-        parse_by_kind!(self, expr_id, \"rvalue\",\n+        parse_by_kind!(self, expr_id, _, \"rvalue\",\n             ExprKind::Borrow { borrow_kind, arg } => Ok(\n                 Rvalue::Ref(self.tcx.lifetimes.re_erased, *borrow_kind, self.parse_place(*arg)?)\n             ),\n@@ -43,14 +43,24 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     fn parse_operand(&self, expr_id: ExprId) -> PResult<Operand<'tcx>> {\n-        parse_by_kind!(self, expr_id, \"operand\",\n+        parse_by_kind!(self, expr_id, expr, \"operand\",\n             @call(\"mir_move\", args) => self.parse_place(args[0]).map(Operand::Move),\n+            ExprKind::Literal { .. }\n+            | ExprKind::NamedConst { .. }\n+            | ExprKind::NonHirLiteral { .. }\n+            | ExprKind::ZstLiteral { .. }\n+            | ExprKind::ConstParam { .. }\n+            | ExprKind::ConstBlock { .. } => {\n+                Ok(Operand::Constant(Box::new(\n+                    crate::build::expr::as_constant::as_constant_inner(expr, |_| None, self.tcx)\n+                )))\n+            },\n             _ => self.parse_place(expr_id).map(Operand::Copy),\n         )\n     }\n \n     fn parse_place(&self, expr_id: ExprId) -> PResult<Place<'tcx>> {\n-        parse_by_kind!(self, expr_id, \"place\",\n+        parse_by_kind!(self, expr_id, _, \"place\",\n             ExprKind::Deref { arg } => Ok(\n                 self.parse_place(*arg)?.project_deeper(&[PlaceElem::Deref], self.tcx)\n             ),\n@@ -59,13 +69,13 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     fn parse_local(&self, expr_id: ExprId) -> PResult<Local> {\n-        parse_by_kind!(self, expr_id, \"local\",\n+        parse_by_kind!(self, expr_id, _, \"local\",\n             ExprKind::VarRef { id } => Ok(self.local_map[id]),\n         )\n     }\n \n     fn parse_block(&self, expr_id: ExprId) -> PResult<BasicBlock> {\n-        parse_by_kind!(self, expr_id, \"basic block\",\n+        parse_by_kind!(self, expr_id, _, \"basic block\",\n             ExprKind::VarRef { id } => Ok(self.block_map[id]),\n         )\n     }"}, {"sha": "717c62315745b303ca7cef8e1e4d539c24930b4d", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 71, "deletions": 66, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/757810031764e4a0fce2a21eb5c8ba208ff7f6c1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757810031764e4a0fce2a21eb5c8ba208ff7f6c1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=757810031764e4a0fce2a21eb5c8ba208ff7f6c1", "patch": "@@ -8,7 +8,9 @@ use rustc_middle::mir::interpret::{\n };\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n-use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, TyCtxt};\n+use rustc_middle::ty::{\n+    self, CanonicalUserType, CanonicalUserTypeAnnotation, TyCtxt, UserTypeAnnotationIndex,\n+};\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::Size;\n \n@@ -19,84 +21,87 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let this = self;\n         let tcx = this.tcx;\n         let Expr { ty, temp_lifetime: _, span, ref kind } = *expr;\n-        match *kind {\n+        match kind {\n             ExprKind::Scope { region_scope: _, lint_level: _, value } => {\n-                this.as_constant(&this.thir[value])\n-            }\n-            ExprKind::Literal { lit, neg } => {\n-                let literal =\n-                    match lit_to_mir_constant(tcx, LitToConstInput { lit: &lit.node, ty, neg }) {\n-                        Ok(c) => c,\n-                        Err(LitToConstError::Reported(guar)) => {\n-                            ConstantKind::Ty(tcx.const_error_with_guaranteed(ty, guar))\n-                        }\n-                        Err(LitToConstError::TypeError) => {\n-                            bug!(\"encountered type error in `lit_to_mir_constant\")\n-                        }\n-                    };\n-\n-                Constant { span, user_ty: None, literal }\n+                this.as_constant(&this.thir[*value])\n             }\n-            ExprKind::NonHirLiteral { lit, ref user_ty } => {\n-                let user_ty = user_ty.as_ref().map(|user_ty| {\n-                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n+            _ => as_constant_inner(\n+                expr,\n+                |user_ty| {\n+                    Some(this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n                         span,\n                         user_ty: user_ty.clone(),\n                         inferred_ty: ty,\n-                    })\n-                });\n-                let literal = ConstantKind::Val(ConstValue::Scalar(Scalar::Int(lit)), ty);\n+                    }))\n+                },\n+                tcx,\n+            ),\n+        }\n+    }\n+}\n \n-                Constant { span, user_ty: user_ty, literal }\n-            }\n-            ExprKind::ZstLiteral { ref user_ty } => {\n-                let user_ty = user_ty.as_ref().map(|user_ty| {\n-                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n-                        span,\n-                        user_ty: user_ty.clone(),\n-                        inferred_ty: ty,\n-                    })\n-                });\n-                let literal = ConstantKind::Val(ConstValue::ZeroSized, ty);\n+pub fn as_constant_inner<'tcx>(\n+    expr: &Expr<'tcx>,\n+    push_cuta: impl FnMut(&Box<CanonicalUserType<'tcx>>) -> Option<UserTypeAnnotationIndex>,\n+    tcx: TyCtxt<'tcx>,\n+) -> Constant<'tcx> {\n+    let Expr { ty, temp_lifetime: _, span, ref kind } = *expr;\n+    match *kind {\n+        ExprKind::Literal { lit, neg } => {\n+            let literal =\n+                match lit_to_mir_constant(tcx, LitToConstInput { lit: &lit.node, ty, neg }) {\n+                    Ok(c) => c,\n+                    Err(LitToConstError::Reported(guar)) => {\n+                        ConstantKind::Ty(tcx.const_error_with_guaranteed(ty, guar))\n+                    }\n+                    Err(LitToConstError::TypeError) => {\n+                        bug!(\"encountered type error in `lit_to_mir_constant\")\n+                    }\n+                };\n \n-                Constant { span, user_ty: user_ty, literal }\n-            }\n-            ExprKind::NamedConst { def_id, substs, ref user_ty } => {\n-                let user_ty = user_ty.as_ref().map(|user_ty| {\n-                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n-                        span,\n-                        user_ty: user_ty.clone(),\n-                        inferred_ty: ty,\n-                    })\n-                });\n+            Constant { span, user_ty: None, literal }\n+        }\n+        ExprKind::NonHirLiteral { lit, ref user_ty } => {\n+            let user_ty = user_ty.as_ref().map(push_cuta).flatten();\n \n-                let uneval =\n-                    mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n-                let literal = ConstantKind::Unevaluated(uneval, ty);\n+            let literal = ConstantKind::Val(ConstValue::Scalar(Scalar::Int(lit)), ty);\n \n-                Constant { user_ty, span, literal }\n-            }\n-            ExprKind::ConstParam { param, def_id: _ } => {\n-                let const_param = tcx.mk_const(param, expr.ty);\n-                let literal = ConstantKind::Ty(const_param);\n+            Constant { span, user_ty: user_ty, literal }\n+        }\n+        ExprKind::ZstLiteral { ref user_ty } => {\n+            let user_ty = user_ty.as_ref().map(push_cuta).flatten();\n \n-                Constant { user_ty: None, span, literal }\n-            }\n-            ExprKind::ConstBlock { did: def_id, substs } => {\n-                let uneval =\n-                    mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n-                let literal = ConstantKind::Unevaluated(uneval, ty);\n+            let literal = ConstantKind::Val(ConstValue::ZeroSized, ty);\n \n-                Constant { user_ty: None, span, literal }\n-            }\n-            ExprKind::StaticRef { alloc_id, ty, .. } => {\n-                let const_val = ConstValue::Scalar(Scalar::from_pointer(alloc_id.into(), &tcx));\n-                let literal = ConstantKind::Val(const_val, ty);\n+            Constant { span, user_ty: user_ty, literal }\n+        }\n+        ExprKind::NamedConst { def_id, substs, ref user_ty } => {\n+            let user_ty = user_ty.as_ref().map(push_cuta).flatten();\n \n-                Constant { span, user_ty: None, literal }\n-            }\n-            _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n+            let uneval = mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n+            let literal = ConstantKind::Unevaluated(uneval, ty);\n+\n+            Constant { user_ty, span, literal }\n+        }\n+        ExprKind::ConstParam { param, def_id: _ } => {\n+            let const_param = tcx.mk_const(ty::ConstKind::Param(param), expr.ty);\n+            let literal = ConstantKind::Ty(const_param);\n+\n+            Constant { user_ty: None, span, literal }\n+        }\n+        ExprKind::ConstBlock { did: def_id, substs } => {\n+            let uneval = mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n+            let literal = ConstantKind::Unevaluated(uneval, ty);\n+\n+            Constant { user_ty: None, span, literal }\n+        }\n+        ExprKind::StaticRef { alloc_id, ty, .. } => {\n+            let const_val = ConstValue::Scalar(Scalar::from_pointer(alloc_id.into(), &tcx));\n+            let literal = ConstantKind::Val(const_val, ty);\n+\n+            Constant { span, user_ty: None, literal }\n         }\n+        _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n     }\n }\n "}, {"sha": "18011aa5e98a1cd856974ff682c12f29727aa526", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/757810031764e4a0fce2a21eb5c8ba208ff7f6c1/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757810031764e4a0fce2a21eb5c8ba208ff7f6c1/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=757810031764e4a0fce2a21eb5c8ba208ff7f6c1", "patch": "@@ -151,6 +151,13 @@ pub macro __internal_extract_let {\n         let $var $(: $ty)?;\n         ::core::intrinsics::mir::__internal_extract_let!($($rest)*);\n     },\n+    // Due to #86730, we have to handle const blocks separately\n+    (\n+        let $var:ident $(: $ty:ty)? = const $block:block; $($rest:tt)*\n+    ) => {\n+        let $var $(: $ty)?;\n+        ::core::intrinsics::mir::__internal_extract_let!($($rest)*);\n+    },\n     // Otherwise, output nothing\n     (\n         $stmt:stmt; $($rest:tt)*\n@@ -218,6 +225,28 @@ pub macro __internal_remove_let {\n             }\n         }\n     )},\n+    // Due to #86730 , we have to handle const blocks separately\n+    (\n+        {\n+            {\n+                $($already_parsed:tt)*\n+            }\n+            {\n+                let $var:ident $(: $ty:ty)? = const $block:block;\n+                $($rest:tt)*\n+            }\n+        }\n+    ) => { ::core::intrinsics::mir::__internal_remove_let!(\n+        {\n+            {\n+                $($already_parsed)*\n+                $var = const $block;\n+            }\n+            {\n+                $($rest)*\n+            }\n+        }\n+    )},\n     // Otherwise, keep going\n     (\n         {"}, {"sha": "e384cdeb465b97c2f7797b2e65be2ffc524b44c0", "filename": "src/test/mir-opt/building/custom/consts.consts.built.after.mir", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/757810031764e4a0fce2a21eb5c8ba208ff7f6c1/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.consts.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/757810031764e4a0fce2a21eb5c8ba208ff7f6c1/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.consts.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.consts.built.after.mir?ref=757810031764e4a0fce2a21eb5c8ba208ff7f6c1", "patch": "@@ -0,0 +1,22 @@\n+// MIR for `consts` after built\n+\n+fn consts() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/consts.rs:10:27: 10:27\n+    let mut _1: u8;                      // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _2: i8;                      // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _3: u32;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _4: i32;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _5: fn() {consts::<10>};     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _1 = const 5_u8;                 // scope 0 at $DIR/consts.rs:+0:1: +0:26\n+        _2 = const _;                    // scope 0 at $DIR/consts.rs:+0:1: +0:26\n+        _3 = const C;                    // scope 0 at $DIR/consts.rs:+0:1: +0:26\n+        _4 = const _;                    // scope 0 at $DIR/consts.rs:+0:1: +0:26\n+        _5 = consts::<10>;               // scope 0 at $DIR/consts.rs:+0:1: +0:26\n+                                         // mir::Constant\n+                                         // + span: $DIR/consts.rs:16:18: 16:30\n+                                         // + literal: Const { ty: fn() {consts::<10>}, val: Value(<ZST>) }\n+        return;                          // scope 0 at $DIR/consts.rs:+0:1: +0:26\n+    }\n+}"}, {"sha": "98b087f1e585a5fc552f164fdc3dd1e2aa92dd8b", "filename": "src/test/mir-opt/building/custom/consts.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/757810031764e4a0fce2a21eb5c8ba208ff7f6c1/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757810031764e4a0fce2a21eb5c8ba208ff7f6c1/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.rs?ref=757810031764e4a0fce2a21eb5c8ba208ff7f6c1", "patch": "@@ -0,0 +1,23 @@\n+#![feature(custom_mir, core_intrinsics, inline_const)]\n+\n+extern crate core;\n+use core::intrinsics::mir::*;\n+\n+const D: i32 = 5;\n+\n+// EMIT_MIR consts.consts.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn consts<const C: u32>() {\n+    mir!({\n+        let _a = 5_u8;\n+        let _b = const { 5_i8 };\n+        let _c = C;\n+        let _d = D;\n+        let _e = consts::<10>;\n+        Return()\n+    })\n+}\n+\n+fn main() {\n+    consts::<5>();\n+}"}]}