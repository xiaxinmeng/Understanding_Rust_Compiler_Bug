{"sha": "40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwZTRiNmVlM2RkNzBhMDUwMDc5MTViZDFjMTVjMTUwYTdiNzg5OWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-02T21:39:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-02T21:39:14Z"}, "message": "Auto merge of #52841 - petrochenkov:premacro, r=alexcrichton\n\nresolve: Implement prelude search for macro paths, implement tool attributes\n\nWhen identifier is macro path is resolved in scopes (i.e. the first path segment - `foo` in `foo::mac!()` or `foo!()`), scopes are searched in the same order as for non-macro paths - items in modules, extern prelude, tool prelude (see later), standard library prelude, language prelude, but with some extra shadowing restrictions (names from globs and macro expansions cannot shadow names from outer scopes). See the comment in `fn resolve_lexical_macro_path_segment` for more details.\n\n\"Tool prelude\" currently contains two \"tool modules\" `rustfmt` and `clippy`, and is searched immediately after extern prelude.\nThis makes the [possible long-term solution](https://github.com/rust-lang/rfcs/blob/master/text/2103-tool-attributes.md#long-term-solution) for tool attributes exactly equivalent to the existing extern prelude scheme, except that `--extern=my_crate` making crate names available in scope is replaced with something like `--tool=my_tool` making tool names available in scope.\n\nThe `tool_attributes` feature is still unstable and `#![feature(tool_attributes)]` now implicitly enables `#![feature(use_extern_macros)]`. `use_extern_macros` is a prerequisite for `tool_attributes`, so their stabilization will happen in the same order.\nIf `use_extern_macros` is not enabled, then tool attributes are treated as custom attributes (this is temporary, anyway).\n\nFixes https://github.com/rust-lang/rust/issues/52576\nFixes https://github.com/rust-lang/rust/issues/52512\nFixes https://github.com/rust-lang/rust/issues/51277\ncc https://github.com/rust-lang/rust/issues/52269", "tree": {"sha": "b9ca402630b5a091d7fb317c270af3b8d83683bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9ca402630b5a091d7fb317c270af3b8d83683bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "html_url": "https://github.com/rust-lang/rust/commit/40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "url": "https://api.github.com/repos/rust-lang/rust/commits/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "html_url": "https://github.com/rust-lang/rust/commit/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41"}, {"sha": "c3e54217e855a2492d9b707eb3fb7cdb6702d45a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3e54217e855a2492d9b707eb3fb7cdb6702d45a", "html_url": "https://github.com/rust-lang/rust/commit/c3e54217e855a2492d9b707eb3fb7cdb6702d45a"}], "stats": {"total": 810, "additions": 675, "deletions": 135}, "files": [{"sha": "cb5e1e600d3d2e8659b21d7bdcc8cc84231dd5a3", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -49,6 +49,7 @@ pub enum Def {\n     PrimTy(hir::PrimTy),\n     TyParam(DefId),\n     SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n+    ToolMod, // e.g. `rustfmt` in `#[rustfmt::skip]`\n \n     // Value namespace\n     Fn(DefId),\n@@ -67,6 +68,7 @@ pub enum Def {\n \n     // Macro namespace\n     Macro(DefId, MacroKind),\n+    NonMacroAttr, // e.g. `#[inline]` or `#[rustfmt::skip]`\n \n     GlobalAsm(DefId),\n \n@@ -259,6 +261,8 @@ impl Def {\n             Def::Label(..)  |\n             Def::PrimTy(..) |\n             Def::SelfTy(..) |\n+            Def::ToolMod |\n+            Def::NonMacroAttr |\n             Def::Err => {\n                 bug!(\"attempted .def_id() on invalid def: {:?}\", self)\n             }\n@@ -299,6 +303,8 @@ impl Def {\n             Def::SelfTy(..) => \"self type\",\n             Def::Macro(.., macro_kind) => macro_kind.descr(),\n             Def::GlobalAsm(..) => \"global asm\",\n+            Def::ToolMod => \"tool module\",\n+            Def::NonMacroAttr => \"non-macro attribute\",\n             Def::Err => \"unresolved item\",\n         }\n     }"}, {"sha": "cac0d182d3a48923c43ad897e4c7ab32dc0cf4a1", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -1016,6 +1016,8 @@ impl_stable_hash_for!(enum hir::def::Def {\n     Label(node_id),\n     Macro(def_id, macro_kind),\n     GlobalAsm(def_id),\n+    ToolMod,\n+    NonMacroAttr,\n     Err\n });\n "}, {"sha": "ab4d15d0b9040413aa2e3f459c6d82811a145f46", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -629,7 +629,8 @@ impl<'a> Resolver<'a> {\n     pub fn get_macro(&mut self, def: Def) -> Lrc<SyntaxExtension> {\n         let def_id = match def {\n             Def::Macro(def_id, ..) => def_id,\n-            _ => panic!(\"Expected Def::Macro(..)\"),\n+            Def::NonMacroAttr => return Lrc::new(SyntaxExtension::NonMacroAttr),\n+            _ => panic!(\"Expected Def::Macro(..) or Def::NonMacroAttr\"),\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {\n             return ext.clone();"}, {"sha": "4c12591c83207d8b5479a05cd55a85dc1a76b175", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -131,8 +131,7 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n                  directive.vis.get() == ty::Visibility::Public ||\n                  directive.span.is_dummy() => {\n                 if let ImportDirectiveSubclass::MacroUse = directive.subclass {\n-                    if resolver.session.features_untracked().use_extern_macros &&\n-                        !directive.span.is_dummy() {\n+                    if resolver.use_extern_macros && !directive.span.is_dummy() {\n                         resolver.session.buffer_lint(\n                             lint::builtin::MACRO_USE_EXTERN_CRATE,\n                             directive.id,"}, {"sha": "9c58d2c1f0b0ccaa46f2ad4b730e71d090a0794b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -86,6 +86,10 @@ mod check_unused;\n mod build_reduced_graph;\n mod resolve_imports;\n \n+fn is_known_tool(name: Name) -> bool {\n+    [\"clippy\", \"rustfmt\"].contains(&&*name.as_str())\n+}\n+\n /// A free importable items suggested in case of resolution failure.\n struct ImportSuggestion {\n     path: Path,\n@@ -200,15 +204,10 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                         err.span_label(typaram_span, \"type variable from outer function\");\n                     }\n                 },\n-                Def::Mod(..) | Def::Struct(..) | Def::Union(..) | Def::Enum(..) | Def::Variant(..) |\n-                Def::Trait(..) | Def::TyAlias(..) | Def::TyForeign(..) | Def::TraitAlias(..) |\n-                Def::AssociatedTy(..) | Def::PrimTy(..) | Def::Fn(..) | Def::Const(..) |\n-                Def::Static(..) | Def::StructCtor(..) | Def::VariantCtor(..) | Def::Method(..) |\n-                Def::AssociatedConst(..) | Def::Local(..) | Def::Upvar(..) | Def::Label(..) |\n-                Def::Existential(..) | Def::AssociatedExistential(..) |\n-                Def::Macro(..) | Def::GlobalAsm(..) | Def::Err =>\n+                _ => {\n                     bug!(\"TypeParametersFromOuterFunction should only be used with Def::SelfTy or \\\n                          Def::TyParam\")\n+                }\n             }\n \n             // Try to retrieve the span of the function signature and generate a new message with\n@@ -1711,9 +1710,7 @@ impl<'a> Resolver<'a> {\n                 vis: ty::Visibility::Public,\n             }),\n \n-            // The `proc_macro` and `decl_macro` features imply `use_extern_macros`\n-            use_extern_macros:\n-                features.use_extern_macros || features.decl_macro,\n+            use_extern_macros: features.use_extern_macros(),\n \n             crate_loader,\n             macro_names: FxHashSet(),\n@@ -1846,6 +1843,7 @@ impl<'a> Resolver<'a> {\n                                       path_span: Span)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         let record_used = record_used_id.is_some();\n+        assert!(ns == TypeNS  || ns == ValueNS);\n         if ns == TypeNS {\n             ident.span = if ident.name == keywords::SelfType.name() {\n                 // FIXME(jseyfried) improve `Self` hygiene\n@@ -1922,8 +1920,9 @@ impl<'a> Resolver<'a> {\n                     return Some(LexicalScopeBinding::Item(binding))\n                 }\n                 _ if poisoned.is_some() => break,\n-                Err(Undetermined) => return None,\n-                Err(Determined) => {}\n+                Err(Determined) => continue,\n+                Err(Undetermined) =>\n+                    span_bug!(ident.span, \"undetermined resolution during main resolution pass\"),\n             }\n         }\n \n@@ -1945,6 +1944,11 @@ impl<'a> Resolver<'a> {\n                                ident.span, Mark::root()).to_name_binding(self.arenas);\n                 return Some(LexicalScopeBinding::Item(binding));\n             }\n+            if ns == TypeNS && is_known_tool(ident.name) {\n+                let binding = (Def::ToolMod, ty::Visibility::Public,\n+                               ident.span, Mark::root()).to_name_binding(self.arenas);\n+                return Some(LexicalScopeBinding::Item(binding));\n+            }\n             if let Some(prelude) = self.prelude {\n                 if let Ok(binding) = self.resolve_ident_in_module_unadjusted(prelude, ident, ns,\n                                                                         false, false, path_span) {\n@@ -3505,6 +3509,8 @@ impl<'a> Resolver<'a> {\n                     let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(def);\n                     if let Some(next_module) = binding.module() {\n                         module = Some(next_module);\n+                    } else if def == Def::ToolMod && i + 1 != path.len() {\n+                        return PathResult::NonModule(PathResolution::new(Def::NonMacroAttr))\n                     } else if def == Def::Err {\n                         return PathResult::NonModule(err_path_resolution());\n                     } else if opt_ns.is_some() && (is_last || maybe_assoc) {"}, {"sha": "60a6bcf499db4aa735fbf5f06f3618ad65f02534", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 227, "deletions": 49, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {AmbiguityError, CrateLint, Resolver, ResolutionError, resolve_error};\n-use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult};\n-use Namespace::{self, MacroNS};\n+use {AmbiguityError, CrateLint, Resolver, ResolutionError, is_known_tool, resolve_error};\n+use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, ToNameBinding};\n+use Namespace::{self, TypeNS, MacroNS};\n use build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n use resolve_imports::ImportResolver;\n use rustc::hir::def_id::{DefId, BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, DefIndex,\n@@ -27,7 +27,7 @@ use syntax::ext::expand::{self, AstFragment, AstFragmentKind, Invocation, Invoca\n use syntax::ext::hygiene::{self, Mark};\n use syntax::ext::placeholders::placeholder;\n use syntax::ext::tt::macro_rules;\n-use syntax::feature_gate::{self, emit_feature_err, GateIssue};\n+use syntax::feature_gate::{self, feature_err, emit_feature_err, is_builtin_attr_name, GateIssue};\n use syntax::fold::{self, Folder};\n use syntax::parse::parser::PathStyle;\n use syntax::parse::token::{self, Token};\n@@ -326,6 +326,18 @@ impl<'a> base::Resolver for Resolver<'a> {\n         if let Def::Macro(_, MacroKind::ProcMacroStub) = def {\n             self.report_proc_macro_stub(invoc.span());\n             return Err(Determinacy::Determined);\n+        } else if let Def::NonMacroAttr = def {\n+            if let InvocationKind::Attr { .. } = invoc.kind {\n+                if !self.session.features_untracked().tool_attributes {\n+                    feature_err(&self.session.parse_sess, \"tool_attributes\",\n+                                invoc.span(), GateIssue::Language,\n+                                \"tool attributes are unstable\").emit();\n+                }\n+                return Ok(Some(Lrc::new(SyntaxExtension::NonMacroAttr)));\n+            } else {\n+                self.report_non_macro_attr(invoc.path_span());\n+                return Err(Determinacy::Determined);\n+            }\n         }\n         let def_id = def.def_id();\n \n@@ -348,6 +360,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n             if let Def::Macro(_, MacroKind::ProcMacroStub) = def {\n                 self.report_proc_macro_stub(path.span);\n                 return Err(Determinacy::Determined);\n+            } else if let Def::NonMacroAttr = def {\n+                self.report_non_macro_attr(path.span);\n+                return Err(Determinacy::Determined);\n             }\n             self.unused_macros.remove(&def.def_id());\n             Ok(self.get_macro(def))\n@@ -378,6 +393,11 @@ impl<'a> Resolver<'a> {\n                               \"can't use a procedural macro from the same crate that defines it\");\n     }\n \n+    fn report_non_macro_attr(&self, span: Span) {\n+        self.session.span_err(span,\n+                              \"expected a macro, found non-macro attribute\");\n+    }\n+\n     fn resolve_invoc_to_def(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n                             -> Result<Def, Determinacy> {\n         let (attr, traits, item) = match invoc.kind {\n@@ -450,7 +470,15 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_macro_to_def(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n                             -> Result<Def, Determinacy> {\n-        if kind != MacroKind::Bang && path.segments.len() > 1 {\n+        let def = self.resolve_macro_to_def_inner(scope, path, kind, force);\n+        if def != Err(Determinacy::Undetermined) {\n+            // Do not report duplicated errors on every undetermined resolution.\n+            path.segments.iter().find(|segment| segment.args.is_some()).map(|segment| {\n+                self.session.span_err(segment.args.as_ref().unwrap().span(),\n+                                      \"generic arguments in macro path\");\n+            });\n+        }\n+        if kind != MacroKind::Bang && path.segments.len() > 1 && def != Ok(Def::NonMacroAttr) {\n             if !self.session.features_untracked().proc_macro_path_invoc {\n                 emit_feature_err(\n                     &self.session.parse_sess,\n@@ -462,15 +490,6 @@ impl<'a> Resolver<'a> {\n                 );\n             }\n         }\n-\n-        let def = self.resolve_macro_to_def_inner(scope, path, kind, force);\n-        if def != Err(Determinacy::Undetermined) {\n-            // Do not report duplicated errors on every undetermined resolution.\n-            path.segments.iter().find(|segment| segment.args.is_some()).map(|segment| {\n-                self.session.span_err(segment.args.as_ref().unwrap().span(),\n-                                      \"generic arguments in macro path\");\n-            });\n-        }\n         def\n     }\n \n@@ -544,67 +563,226 @@ impl<'a> Resolver<'a> {\n         result\n     }\n \n-    // Resolve the initial segment of a non-global macro path (e.g. `foo` in `foo::bar!();`)\n+    // Resolve the initial segment of a non-global macro path\n+    // (e.g. `foo` in `foo::bar!(); or `foo!();`).\n+    // This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n+    // expansion and import resolution (perhaps they can be merged in the future).\n     pub fn resolve_lexical_macro_path_segment(&mut self,\n                                               mut ident: Ident,\n                                               ns: Namespace,\n                                               record_used: bool,\n                                               path_span: Span)\n                                               -> Result<MacroBinding<'a>, Determinacy> {\n+        // General principles:\n+        // 1. Not controlled (user-defined) names should have higher priority than controlled names\n+        //    built into the language or standard library. This way we can add new names into the\n+        //    language or standard library without breaking user code.\n+        // 2. \"Closed set\" below means new names can appear after the current resolution attempt.\n+        // Places to search (in order of decreasing priority):\n+        // (Type NS)\n+        // 1. FIXME: Ribs (type parameters), there's no necessary infrastructure yet\n+        //    (open set, not controlled).\n+        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled).\n+        // 3. Extern prelude (closed, not controlled).\n+        // 4. Tool modules (closed, controlled right now, but not in the future).\n+        // 5. Standard library prelude (de-facto closed, controlled).\n+        // 6. Language prelude (closed, controlled).\n+        // (Macro NS)\n+        // 1. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled).\n+        // 2. Macro prelude (language, standard library, user-defined legacy plugins lumped into\n+        //    one set) (open, the open part is from macro expansions, not controlled).\n+        // 2a. User-defined prelude from macro-use\n+        //    (open, the open part is from macro expansions, not controlled).\n+        // 2b. Standard library prelude, currently just a macro-use (closed, controlled)\n+        // 2c. Language prelude, perhaps including builtin attributes\n+        //    (closed, controlled, except for legacy plugins).\n+        // 3. Builtin attributes (closed, controlled).\n+\n+        assert!(ns == TypeNS  || ns == MacroNS);\n         ident = ident.modern();\n-        let mut module = Some(self.current_module);\n-        let mut potential_illegal_shadower = Err(Determinacy::Determined);\n-        let determinacy =\n-            if record_used { Determinacy::Determined } else { Determinacy::Undetermined };\n+\n+        // Names from inner scope that can't shadow names from outer scopes, e.g.\n+        // mod m { ... }\n+        // {\n+        //     use prefix::*; // if this imports another `m`, then it can't shadow the outer `m`\n+        //                    // and we have and ambiguity error\n+        //     m::mac!();\n+        // }\n+        // This includes names from globs and from macro expansions.\n+        let mut potentially_ambiguous_result: Option<MacroBinding> = None;\n+\n+        enum WhereToResolve<'a> {\n+            Module(Module<'a>),\n+            MacroPrelude,\n+            BuiltinAttrs,\n+            ExternPrelude,\n+            ToolPrelude,\n+            StdLibPrelude,\n+            PrimitiveTypes,\n+        }\n+\n+        // Go through all the scopes and try to resolve the name.\n+        let mut where_to_resolve = WhereToResolve::Module(self.current_module);\n+        let mut use_prelude = !self.current_module.no_implicit_prelude;\n         loop {\n-            let orig_current_module = self.current_module;\n-            let result = if let Some(module) = module {\n-                self.current_module = module; // Lexical resolutions can never be a privacy error.\n-                // Since expanded macros may not shadow the lexical scope and\n-                // globs may not shadow global macros (both enforced below),\n-                // we resolve with restricted shadowing (indicated by the penultimate argument).\n-                self.resolve_ident_in_module_unadjusted(\n-                    module, ident, ns, true, record_used, path_span,\n-                ).map(MacroBinding::Modern)\n-            } else {\n-                self.macro_prelude.get(&ident.name).cloned().ok_or(determinacy)\n-                    .map(MacroBinding::Global)\n+            let result = match where_to_resolve {\n+                WhereToResolve::Module(module) => {\n+                    let orig_current_module = mem::replace(&mut self.current_module, module);\n+                    let binding = self.resolve_ident_in_module_unadjusted(\n+                            module, ident, ns, true, record_used, path_span,\n+                    );\n+                    self.current_module = orig_current_module;\n+                    binding.map(MacroBinding::Modern)\n+                }\n+                WhereToResolve::MacroPrelude => {\n+                    match self.macro_prelude.get(&ident.name).cloned() {\n+                        Some(binding) => Ok(MacroBinding::Global(binding)),\n+                        None => Err(Determinacy::Determined),\n+                    }\n+                }\n+                WhereToResolve::BuiltinAttrs => {\n+                    if is_builtin_attr_name(ident.name) {\n+                        let binding = (Def::NonMacroAttr, ty::Visibility::Public,\n+                                       ident.span, Mark::root()).to_name_binding(self.arenas);\n+                        Ok(MacroBinding::Global(binding))\n+                    } else {\n+                        Err(Determinacy::Determined)\n+                    }\n+                }\n+                WhereToResolve::ExternPrelude => {\n+                    if use_prelude && self.extern_prelude.contains(&ident.name) {\n+                        if !self.session.features_untracked().extern_prelude &&\n+                           !self.ignore_extern_prelude_feature {\n+                            feature_err(&self.session.parse_sess, \"extern_prelude\",\n+                                        ident.span, GateIssue::Language,\n+                                        \"access to extern crates through prelude is experimental\")\n+                                        .emit();\n+                        }\n+\n+                        let crate_id =\n+                            self.crate_loader.process_path_extern(ident.name, ident.span);\n+                        let crate_root =\n+                            self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n+                        self.populate_module_if_necessary(crate_root);\n+\n+                        let binding = (crate_root, ty::Visibility::Public,\n+                                       ident.span, Mark::root()).to_name_binding(self.arenas);\n+                        Ok(MacroBinding::Global(binding))\n+                    } else {\n+                        Err(Determinacy::Determined)\n+                    }\n+                }\n+                WhereToResolve::ToolPrelude => {\n+                    if use_prelude && is_known_tool(ident.name) {\n+                        let binding = (Def::ToolMod, ty::Visibility::Public,\n+                                       ident.span, Mark::root()).to_name_binding(self.arenas);\n+                        Ok(MacroBinding::Global(binding))\n+                    } else {\n+                        Err(Determinacy::Determined)\n+                    }\n+                }\n+                WhereToResolve::StdLibPrelude => {\n+                    let mut result = Err(Determinacy::Determined);\n+                    if use_prelude {\n+                        if let Some(prelude) = self.prelude {\n+                            if let Ok(binding) =\n+                                    self.resolve_ident_in_module_unadjusted(prelude, ident, ns,\n+                                                                          false, false, path_span) {\n+                                result = Ok(MacroBinding::Global(binding));\n+                            }\n+                        }\n+                    }\n+                    result\n+                }\n+                WhereToResolve::PrimitiveTypes => {\n+                    if let Some(prim_ty) =\n+                            self.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n+                        let binding = (Def::PrimTy(prim_ty), ty::Visibility::Public,\n+                                       ident.span, Mark::root()).to_name_binding(self.arenas);\n+                        Ok(MacroBinding::Global(binding))\n+                    } else {\n+                        Err(Determinacy::Determined)\n+                    }\n+                }\n             };\n-            self.current_module = orig_current_module;\n \n-            match result.map(MacroBinding::binding) {\n-                Ok(binding) => {\n+            macro_rules! continue_search { () => {\n+                where_to_resolve = match where_to_resolve {\n+                    WhereToResolve::Module(module) => {\n+                        match self.hygienic_lexical_parent(module, &mut ident.span) {\n+                            Some(parent_module) => WhereToResolve::Module(parent_module),\n+                            None => {\n+                                use_prelude = !module.no_implicit_prelude;\n+                                if ns == MacroNS {\n+                                    WhereToResolve::MacroPrelude\n+                                } else {\n+                                    WhereToResolve::ExternPrelude\n+                                }\n+                            }\n+                        }\n+                    }\n+                    WhereToResolve::MacroPrelude => WhereToResolve::BuiltinAttrs,\n+                    WhereToResolve::BuiltinAttrs => break, // nowhere else to search\n+                    WhereToResolve::ExternPrelude => WhereToResolve::ToolPrelude,\n+                    WhereToResolve::ToolPrelude => WhereToResolve::StdLibPrelude,\n+                    WhereToResolve::StdLibPrelude => WhereToResolve::PrimitiveTypes,\n+                    WhereToResolve::PrimitiveTypes => break, // nowhere else to search\n+                };\n+\n+                continue;\n+            }}\n+\n+            match result {\n+                Ok(result) => {\n                     if !record_used {\n-                        return result;\n+                        return Ok(result);\n                     }\n-                    if let Ok(MacroBinding::Modern(shadower)) = potential_illegal_shadower {\n-                        if shadower.def() != binding.def() {\n-                            let name = ident.name;\n+\n+                    let binding = result.binding();\n+\n+                    // Found a solution that is ambiguous with a previously found solution.\n+                    // Push an ambiguity error for later reporting and\n+                    // return something for better recovery.\n+                    if let Some(previous_result) = potentially_ambiguous_result {\n+                        if binding.def() != previous_result.binding().def() {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 span: path_span,\n-                                name,\n-                                b1: shadower,\n+                                name: ident.name,\n+                                b1: previous_result.binding(),\n                                 b2: binding,\n                                 lexical: true,\n                             });\n-                            return potential_illegal_shadower;\n+                            return Ok(previous_result);\n                         }\n                     }\n+\n+                    // Found a solution that's not an ambiguity yet, but is \"suspicious\" and\n+                    // can participate in ambiguities later on.\n+                    // Remember it and go search for other solutions in outer scopes.\n                     if binding.is_glob_import() || binding.expansion != Mark::root() {\n-                        potential_illegal_shadower = result;\n-                    } else {\n-                        return result;\n+                        potentially_ambiguous_result = Some(result);\n+\n+                        continue_search!();\n                     }\n+\n+                    // Found a solution that can't be ambiguous, great success.\n+                    return Ok(result);\n                 },\n+                Err(Determinacy::Determined) => {\n+                    continue_search!();\n+                }\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n-                Err(Determinacy::Determined) => {}\n             }\n+        }\n \n-            module = match module {\n-                Some(module) => self.hygienic_lexical_parent(module, &mut ident.span),\n-                None => return potential_illegal_shadower,\n-            }\n+        // Previously found potentially ambiguous result turned out to not be ambiguous after all.\n+        if let Some(previous_result) = potentially_ambiguous_result {\n+            return Ok(previous_result);\n         }\n+\n+        if record_used { Err(Determinacy::Determined) } else { Err(Determinacy::Undetermined) }\n     }\n \n     pub fn resolve_legacy_scope(&mut self,"}, {"sha": "240b33c3c9478ca50ae950f9d1d11c361e0bd51f", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -811,6 +811,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             HirDef::Label(..) |\n             HirDef::Macro(..) |\n             HirDef::GlobalAsm(..) |\n+            HirDef::ToolMod |\n+            HirDef::NonMacroAttr |\n             HirDef::Err => None,\n         }\n     }"}, {"sha": "b3b173db70b8906649f300f7cbdc9060abfad849", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -65,17 +65,8 @@ pub fn is_known(attr: &Attribute) -> bool {\n     })\n }\n \n-const RUST_KNOWN_TOOL: &[&str] = &[\"clippy\", \"rustfmt\"];\n-const RUST_KNOWN_LINT_TOOL: &[&str] = &[\"clippy\"];\n-\n-pub fn is_known_tool(attr: &Attribute) -> bool {\n-    let tool_name =\n-        attr.path.segments.iter().next().expect(\"empty path in attribute\").ident.name;\n-    RUST_KNOWN_TOOL.contains(&tool_name.as_str().as_ref())\n-}\n-\n pub fn is_known_lint_tool(m_item: Ident) -> bool {\n-    RUST_KNOWN_LINT_TOOL.contains(&m_item.as_str().as_ref())\n+    [\"clippy\"].contains(&m_item.as_str().as_ref())\n }\n \n impl NestedMetaItem {\n@@ -221,10 +212,6 @@ impl Attribute {\n     pub fn is_value_str(&self) -> bool {\n         self.value_str().is_some()\n     }\n-\n-    pub fn is_scoped(&self) -> bool {\n-        self.path.segments.len() > 1\n-    }\n }\n \n impl MetaItem {"}, {"sha": "8450daa3f7c943fc93dc1de90f9f97730c8aaa2a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -588,6 +588,9 @@ impl MacroKind {\n \n /// An enum representing the different kinds of syntax extensions.\n pub enum SyntaxExtension {\n+    /// A trivial \"extension\" that does nothing, only keeps the attribute and marks it as known.\n+    NonMacroAttr,\n+\n     /// A syntax extension that is attached to an item and creates new items\n     /// based upon it.\n     ///\n@@ -667,6 +670,7 @@ impl SyntaxExtension {\n             SyntaxExtension::IdentTT(..) |\n             SyntaxExtension::ProcMacro { .. } =>\n                 MacroKind::Bang,\n+            SyntaxExtension::NonMacroAttr |\n             SyntaxExtension::MultiDecorator(..) |\n             SyntaxExtension::MultiModifier(..) |\n             SyntaxExtension::AttrProcMacro(..) =>\n@@ -696,6 +700,7 @@ impl SyntaxExtension {\n             SyntaxExtension::AttrProcMacro(.., edition) |\n             SyntaxExtension::ProcMacroDerive(.., edition) => edition,\n             // Unstable legacy stuff\n+            SyntaxExtension::NonMacroAttr |\n             SyntaxExtension::IdentTT(..) |\n             SyntaxExtension::MultiDecorator(..) |\n             SyntaxExtension::MultiModifier(..) |"}, {"sha": "8bd30e434767be5a3397e1cf8c78ffd9450e2a64", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -37,7 +37,7 @@ use visit::{self, Visitor};\n use std::collections::HashMap;\n use std::fs::File;\n use std::io::Read;\n-use std::mem;\n+use std::{iter, mem};\n use std::rc::Rc;\n use std::path::PathBuf;\n \n@@ -244,6 +244,15 @@ impl Invocation {\n         }\n     }\n \n+    pub fn path_span(&self) -> Span {\n+        match self.kind {\n+            InvocationKind::Bang { ref mac, .. } => mac.node.path.span,\n+            InvocationKind::Attr { attr: Some(ref attr), .. } => attr.path.span,\n+            InvocationKind::Attr { attr: None, .. } => DUMMY_SP,\n+            InvocationKind::Derive { ref path, .. } => path.span,\n+        }\n+    }\n+\n     pub fn attr_id(&self) -> Option<ast::AttrId> {\n         match self.kind {\n             InvocationKind::Attr { attr: Some(ref attr), .. } => Some(attr.id),\n@@ -568,6 +577,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         });\n \n         match *ext {\n+            NonMacroAttr => {\n+                attr::mark_known(&attr);\n+                let item = item.map_attrs(|mut attrs| { attrs.push(attr); attrs });\n+                Some(invoc.fragment_kind.expect_from_annotatables(iter::once(item)))\n+            }\n             MultiModifier(ref mac) => {\n                 let meta = attr.parse_meta(self.cx.parse_sess)\n                                .map_err(|mut e| { e.emit(); }).ok()?;\n@@ -812,7 +826,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n             }\n \n-            MultiDecorator(..) | MultiModifier(..) | AttrProcMacro(..) => {\n+            MultiDecorator(..) | MultiModifier(..) |\n+            AttrProcMacro(..) | SyntaxExtension::NonMacroAttr => {\n                 self.cx.span_err(path.span,\n                                  &format!(\"`{}` can only be used in attributes\", path));\n                 self.cx.trace_macros_diag();\n@@ -1669,13 +1684,16 @@ impl<'feat> ExpansionConfig<'feat> {\n         fn enable_allow_internal_unstable = allow_internal_unstable,\n         fn enable_custom_derive = custom_derive,\n         fn enable_format_args_nl = format_args_nl,\n-        fn use_extern_macros_enabled = use_extern_macros,\n         fn macros_in_extern_enabled = macros_in_extern,\n         fn proc_macro_mod = proc_macro_mod,\n         fn proc_macro_gen = proc_macro_gen,\n         fn proc_macro_expr = proc_macro_expr,\n         fn proc_macro_non_items = proc_macro_non_items,\n     }\n+\n+    pub fn use_extern_macros_enabled(&self) -> bool {\n+        self.features.map_or(false, |features| features.use_extern_macros())\n+    }\n }\n \n // A Marker adds the given mark to the syntax context."}, {"sha": "77e3faa5b1faca25b7d386c1e0f44eb394009626", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -80,6 +80,11 @@ macro_rules! declare_features {\n             {\n                 $(f(stringify!($feature), self.$feature);)+\n             }\n+\n+            pub fn use_extern_macros(&self) -> bool {\n+                // The `decl_macro` and `tool_attributes` features imply `use_extern_macros`.\n+                self.use_extern_macros || self.decl_macro || self.tool_attributes\n+            }\n         }\n     };\n \n@@ -689,6 +694,10 @@ pub fn deprecated_attributes() -> Vec<&'static (&'static str, AttributeType, Att\n     BUILTIN_ATTRIBUTES.iter().filter(|a| a.2.is_deprecated()).collect()\n }\n \n+pub fn is_builtin_attr_name(name: ast::Name) -> bool {\n+    BUILTIN_ATTRIBUTES.iter().any(|&(builtin_name, _, _)| name == builtin_name)\n+}\n+\n pub fn is_builtin_attr(attr: &ast::Attribute) -> bool {\n     BUILTIN_ATTRIBUTES.iter().any(|&(builtin_name, _, _)| attr.check_name(builtin_name)) ||\n     attr.name().as_str().starts_with(\"rustc_\")\n@@ -1198,28 +1207,9 @@ impl<'a> Context<'a> {\n             // before the plugin attributes are registered\n             // so we skip this then\n             if !is_macro {\n-                if attr.is_scoped() {\n-                    gate_feature!(self, tool_attributes, attr.span,\n-                                  &format!(\"scoped attribute `{}` is experimental\", attr.path));\n-                    if attr::is_known_tool(attr) {\n-                        attr::mark_used(attr);\n-                    } else {\n-                        span_err!(\n-                            self.parse_sess.span_diagnostic,\n-                            attr.span,\n-                            E0694,\n-                            \"an unknown tool name found in scoped attribute: `{}`.\",\n-                            attr.path\n-                        );\n-                    }\n-                } else {\n-                    gate_feature!(self, custom_attribute, attr.span,\n-                                  &format!(\"The attribute `{}` is currently \\\n-                                            unknown to the compiler and \\\n-                                            may have meaning \\\n-                                            added to it in the future\",\n-                                           attr.path));\n-                }\n+                let msg = format!(\"The attribute `{}` is currently unknown to the compiler and \\\n+                                   may have meaning added to it in the future\", attr.path);\n+                gate_feature!(self, custom_attribute, attr.span, &msg);\n             }\n         }\n     }\n@@ -1529,7 +1519,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n         }\n \n-        if self.context.features.use_extern_macros && attr::is_known(attr) {\n+        if self.context.features.use_extern_macros() && attr::is_known(attr) {\n             return\n         }\n \n@@ -2004,7 +1994,7 @@ impl FeatureChecker {\n     // the branching can be eliminated by modifying `set!()` to set these spans\n     // only for the features that need to be checked for mutual exclusion.\n     fn collect(&mut self, features: &Features, span: Span) {\n-        if features.use_extern_macros {\n+        if features.use_extern_macros() {\n             // If self.use_extern_macros is None, set to Some(span)\n             self.use_extern_macros = self.use_extern_macros.or(Some(span));\n         }"}, {"sha": "c4d22e6d392102ab9489797e4e844d04ecc31663", "filename": "src/test/compile-fail/unknown-tool-name.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fcompile-fail%2Funknown-tool-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fcompile-fail%2Funknown-tool-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funknown-tool-name.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(tool_attributes)]\n+#![feature(use_extern_macros, proc_macro_path_invoc)]\n \n-#![foo::bar] //~ ERROR an unknown tool name found in scoped attribute: `foo::bar`. [E0694]\n-\n-#[foo::bar] //~ ERROR an unknown tool name found in scoped attribute: `foo::bar`. [E0694]\n+#[foo::bar] //~ ERROR failed to resolve. Use of undeclared type or module `foo`\n fn main() {}"}, {"sha": "d4af99f97c5c82001c5394169a6530cbce193145", "filename": "src/test/run-pass-fulldeps/proc-macro/issue-42708.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-42708.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-42708.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-42708.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -11,7 +11,7 @@\n // aux-build:issue-42708.rs\n // ignore-stage1\n \n-#![feature(decl_macro, use_extern_macros, proc_macro_path_invoc)]\n+#![feature(decl_macro, proc_macro_path_invoc)]\n #![allow(unused)]\n \n extern crate issue_42708;"}, {"sha": "53783e7fedb2929ed865eed6dd49ae66a22e1fc7", "filename": "src/test/run-pass-fulldeps/proc-macro/issue-50061.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-50061.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-50061.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-50061.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -11,7 +11,7 @@\n // aux-build:issue-50061.rs\n // ignore-stage1\n \n-#![feature(use_extern_macros, proc_macro_path_invoc, decl_macro)]\n+#![feature(proc_macro_path_invoc, decl_macro)]\n \n extern crate issue_50061;\n "}, {"sha": "18f5b0f506cc2f7b9e78aa49ec730ff4b6fcac4c", "filename": "src/test/ui-fulldeps/proc-macro/parent-source-spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fparent-source-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fparent-source-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fparent-source-spans.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -11,7 +11,7 @@\n // aux-build:parent-source-spans.rs\n // ignore-stage1\n \n-#![feature(use_extern_macros, decl_macro, proc_macro_non_items)]\n+#![feature(decl_macro, proc_macro_non_items)]\n \n extern crate parent_source_spans;\n "}, {"sha": "c787cedc2d0ea10b5880ac5a76139858fb377427", "filename": "src/test/ui/auxiliary/macro-in-other-crate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fauxiliary%2Fmacro-in-other-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fauxiliary%2Fmacro-in-other-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauxiliary%2Fmacro-in-other-crate.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -12,3 +12,8 @@\n macro_rules! mac {\n     ($ident:ident) => { let $ident = 42; }\n }\n+\n+#[macro_export]\n+macro_rules! inline {\n+    () => ()\n+}"}, {"sha": "5d7e01fbbb752d895d42b4468c9abfffaa5cefb5", "filename": "src/test/ui/feature-gate-macros_in_extern.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ffeature-gate-macros_in_extern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ffeature-gate-macros_in_extern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-macros_in_extern.stderr?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -1,20 +1,20 @@\n-error[E0658]: macro invocations in `extern {}` blocks are experimental. (see issue #49476)\n+error[E0658]: macro and proc-macro invocations in `extern {}` blocks are experimental. (see issue #49476)\n   --> $DIR/feature-gate-macros_in_extern.rs:29:5\n    |\n LL |     returns_isize!(rust_get_test_int);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add #![feature(macros_in_extern)] to the crate attributes to enable\n \n-error[E0658]: macro invocations in `extern {}` blocks are experimental. (see issue #49476)\n+error[E0658]: macro and proc-macro invocations in `extern {}` blocks are experimental. (see issue #49476)\n   --> $DIR/feature-gate-macros_in_extern.rs:31:5\n    |\n LL |     takes_u32_returns_u32!(rust_dbg_extern_identity_u32);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add #![feature(macros_in_extern)] to the crate attributes to enable\n \n-error[E0658]: macro invocations in `extern {}` blocks are experimental. (see issue #49476)\n+error[E0658]: macro and proc-macro invocations in `extern {}` blocks are experimental. (see issue #49476)\n   --> $DIR/feature-gate-macros_in_extern.rs:33:5\n    |\n LL |     emits_nothing!();"}, {"sha": "47c623574ec90ef84e77f3357dbcb6ae588967d1", "filename": "src/test/ui/feature-gate-tool_attributes.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ffeature-gate-tool_attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ffeature-gate-tool_attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-tool_attributes.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(use_extern_macros)]\n+\n fn main() {\n-    #[rustfmt::skip] //~ ERROR scoped attribute `rustfmt::skip` is experimental\n+    #[rustfmt::skip] //~ ERROR tool attributes are unstable\n     let x = 3\n         ;\n }"}, {"sha": "ebc266e004ecceaf293e746e76cadd471d4e4f79", "filename": "src/test/ui/feature-gate-tool_attributes.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ffeature-gate-tool_attributes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ffeature-gate-tool_attributes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-tool_attributes.stderr?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -1,7 +1,7 @@\n-error[E0658]: scoped attribute `rustfmt::skip` is experimental (see issue #44690)\n-  --> $DIR/feature-gate-tool_attributes.rs:12:5\n+error[E0658]: tool attributes are unstable (see issue #44690)\n+  --> $DIR/feature-gate-tool_attributes.rs:14:5\n    |\n-LL |     #[rustfmt::skip] //~ ERROR scoped attribute `rustfmt::skip` is experimental\n+LL |     #[rustfmt::skip] //~ ERROR tool attributes are unstable\n    |     ^^^^^^^^^^^^^^^^\n    |\n    = help: add #![feature(tool_attributes)] to the crate attributes to enable"}, {"sha": "ff6009da72fd96920bf3a2dd59d0fe5327b37783", "filename": "src/test/ui/issue-11692-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fissue-11692-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fissue-11692-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11692-1.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    print!(test!());\n+    print!(testo!());\n     //~^ ERROR: format argument must be a string literal\n }"}, {"sha": "61ff455d16ca587ec008a390b7fe470bfc8e5ea5", "filename": "src/test/ui/issue-11692-1.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fissue-11692-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fissue-11692-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11692-1.stderr?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -1,11 +1,11 @@\n error: format argument must be a string literal\n   --> $DIR/issue-11692-1.rs:12:12\n    |\n-LL |     print!(test!());\n-   |            ^^^^^^^\n+LL |     print!(testo!());\n+   |            ^^^^^^^^\n help: you might be missing a string literal to format with\n    |\n-LL |     print!(\"{}\", test!());\n+LL |     print!(\"{}\", testo!());\n    |            ^^^^^\n \n error: aborting due to previous error"}, {"sha": "c595b0fb2c2d8ea9d59f17f785153c7edd09190a", "filename": "src/test/ui/issue-11692-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fissue-11692-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fissue-11692-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11692-2.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     concat!(test!());\n-    //~^ ERROR cannot find macro `test!` in this scope\n+    //~^ ERROR expected a macro, found non-macro attribute\n }"}, {"sha": "3d080bd46dcc967012c6a2a2a6b407519297f960", "filename": "src/test/ui/issue-11692-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fissue-11692-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fissue-11692-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11692-2.stderr?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -1,4 +1,4 @@\n-error: cannot find macro `test!` in this scope\n+error: expected a macro, found non-macro attribute\n   --> $DIR/issue-11692-2.rs:12:13\n    |\n LL |     concat!(test!());"}, {"sha": "ccb2742841cc5dd107a83a53bd598451d0a721ab", "filename": "src/test/ui/issue-50187.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fissue-50187.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fissue-50187.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-50187.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -10,7 +10,7 @@\n \n // compile-pass\n \n-#![feature(use_extern_macros, decl_macro)]\n+#![feature(decl_macro)]\n \n mod type_ns {\n     pub type A = u8;"}, {"sha": "b953805a7eb2f2ef2c85d074f4b25334bfbbbe81", "filename": "src/test/ui/macro-path-prelude-fail-1.rs", "status": "renamed", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-1.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Make sure that 'custom_attributes' feature does not allow scoped attributes.\n+#![feature(use_extern_macros, extern_prelude)]\n \n-#![feature(custom_attributes)]\n+mod m {\n+    fn check() {\n+        Vec::clone!(); //~ ERROR failed to resolve. Not a module `Vec`\n+        u8::clone!(); //~ ERROR failed to resolve. Not a module `u8`\n+    }\n+}\n \n-#[foo::bar]\n-//~^ ERROR scoped attribute `foo::bar` is experimental (see issue #44690) [E0658]\n-//~^^ ERROR an unknown tool name found in scoped attribute: `foo::bar`. [E0694]\n fn main() {}", "previous_filename": "src/test/compile-fail/unknown_tool_attributes-1.rs"}, {"sha": "fc74937d9120079223bd083e295662b9949da38b", "filename": "src/test/ui/macro-path-prelude-fail-1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-1.stderr?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,15 @@\n+error[E0433]: failed to resolve. Not a module `Vec`\n+  --> $DIR/macro-path-prelude-fail-1.rs:15:9\n+   |\n+LL |         Vec::clone!(); //~ ERROR failed to resolve. Not a module `Vec`\n+   |         ^^^ Not a module `Vec`\n+\n+error[E0433]: failed to resolve. Not a module `u8`\n+  --> $DIR/macro-path-prelude-fail-1.rs:16:9\n+   |\n+LL |         u8::clone!(); //~ ERROR failed to resolve. Not a module `u8`\n+   |         ^^ Not a module `u8`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "ec77e276bd4031c3a8ac007830da790eee1f3430", "filename": "src/test/ui/macro-path-prelude-fail-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-2.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(use_extern_macros)]\n+\n+mod m {\n+    fn check() {\n+        Result::Ok!(); //~ ERROR fail to resolve non-ident macro path\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d23aed847a30c733ca73b9475abb8599b29c4a65", "filename": "src/test/ui/macro-path-prelude-fail-2.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-2.stderr?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,8 @@\n+error: fail to resolve non-ident macro path\n+  --> $DIR/macro-path-prelude-fail-2.rs:15:9\n+   |\n+LL |         Result::Ok!(); //~ ERROR fail to resolve non-ident macro path\n+   |         ^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "4cf90019d40eba7c569c72dacd0bf0bd64e7c163", "filename": "src/test/ui/macro-path-prelude-fail-3.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-3.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(use_extern_macros)]\n+\n+#[derive(inline)] //~ ERROR expected a macro, found non-macro attribute\n+struct S;\n+\n+fn main() {\n+    inline!(); //~ ERROR expected a macro, found non-macro attribute\n+}"}, {"sha": "bd1015b7ee10efc5d15c0617fd5466c4eecc9168", "filename": "src/test/ui/macro-path-prelude-fail-3.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacro-path-prelude-fail-3.stderr?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,14 @@\n+error: expected a macro, found non-macro attribute\n+  --> $DIR/macro-path-prelude-fail-3.rs:13:10\n+   |\n+LL | #[derive(inline)] //~ ERROR expected a macro, found non-macro attribute\n+   |          ^^^^^^\n+\n+error: expected a macro, found non-macro attribute\n+  --> $DIR/macro-path-prelude-fail-3.rs:17:5\n+   |\n+LL |     inline!(); //~ ERROR expected a macro, found non-macro attribute\n+   |     ^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "bc58754513b6d400077bfe0750257e2c3f5b4a76", "filename": "src/test/ui/macro-path-prelude-pass.rs", "status": "renamed", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacro-path-prelude-pass.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -8,8 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main() {\n-    #[rustfmt::skip] //~ ERROR scoped attribute `rustfmt::skip` is experimental\n-    let x =\n-        3;\n+// compile-pass\n+\n+#![feature(use_extern_macros, extern_prelude)]\n+\n+mod m {\n+    fn check() {\n+        std::panic!(); // OK\n+    }\n }\n+\n+fn main() {}", "previous_filename": "src/test/compile-fail/feature-gate-tool_attributes.rs"}, {"sha": "1aff7777ef7b1d306e8ffc632a3093af75851267", "filename": "src/test/ui/macro-path-prelude-shadowing.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacro-path-prelude-shadowing.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro-in-other-crate.rs\n+\n+#![feature(decl_macro, extern_prelude)]\n+\n+macro_rules! add_macro_expanded_things_to_macro_prelude {() => {\n+    #[macro_use]\n+    extern crate macro_in_other_crate;\n+}}\n+\n+add_macro_expanded_things_to_macro_prelude!();\n+\n+mod m1 {\n+    fn check() {\n+        inline!(); //~ ERROR `inline` is ambiguous\n+    }\n+}\n+\n+mod m2 {\n+    pub mod std {\n+        pub macro panic() {}\n+    }\n+}\n+\n+mod m3 {\n+    use m2::*; // glob-import user-defined `std`\n+    fn check() {\n+        std::panic!(); //~ ERROR `std` is ambiguous\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0e1b9a985a3c378d8cfc86ab144bdb6eaa06d582", "filename": "src/test/ui/macro-path-prelude-shadowing.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Fmacro-path-prelude-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacro-path-prelude-shadowing.stderr?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,42 @@\n+error[E0659]: `inline` is ambiguous\n+  --> $DIR/macro-path-prelude-shadowing.rs:24:9\n+   |\n+LL |         inline!(); //~ ERROR `inline` is ambiguous\n+   |         ^^^^^^\n+   |\n+note: `inline` could refer to the name imported here\n+  --> $DIR/macro-path-prelude-shadowing.rs:16:5\n+   |\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^\n+...\n+LL | add_macro_expanded_things_to_macro_prelude!();\n+   | ---------------------------------------------- in this macro invocation\n+note: `inline` could also refer to the name defined here\n+  --> $DIR/macro-path-prelude-shadowing.rs:24:9\n+   |\n+LL |         inline!(); //~ ERROR `inline` is ambiguous\n+   |         ^^^^^^\n+   = note: macro-expanded macro imports do not shadow\n+\n+error[E0659]: `std` is ambiguous\n+  --> $DIR/macro-path-prelude-shadowing.rs:37:9\n+   |\n+LL |         std::panic!(); //~ ERROR `std` is ambiguous\n+   |         ^^^^^^^^^^\n+   |\n+note: `std` could refer to the name imported here\n+  --> $DIR/macro-path-prelude-shadowing.rs:35:9\n+   |\n+LL |     use m2::*; // glob-import user-defined `std`\n+   |         ^^^^^\n+note: `std` could also refer to the name defined here\n+  --> $DIR/macro-path-prelude-shadowing.rs:37:9\n+   |\n+LL |         std::panic!(); //~ ERROR `std` is ambiguous\n+   |         ^^^\n+   = note: consider adding an explicit import of `std` to disambiguate\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "87d47b75607c1735b7aaed7609fe0113afb52268", "filename": "src/test/ui/tool-attributes-disabled-1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-disabled-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-disabled-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes-disabled-1.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// If macro modularization (`use_extern_macros`) is not enabled,\n+// then tool attributes are treated as custom attributes.\n+\n+#[rustfmt::bar] //~ ERROR The attribute `rustfmt::bar` is currently unknown to the compiler\n+fn main() {}"}, {"sha": "6302c06057aa2bc7894a5dbe0dac6afbc7711c0c", "filename": "src/test/ui/tool-attributes-disabled-1.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-disabled-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-disabled-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes-disabled-1.stderr?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: The attribute `rustfmt::bar` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/tool-attributes-disabled-1.rs:14:1\n+   |\n+LL | #[rustfmt::bar] //~ ERROR The attribute `rustfmt::bar` is currently unknown to the compiler\n+   | ^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "160dda05b1ed69522c433e7e8ee825503cee5934", "filename": "src/test/ui/tool-attributes-disabled-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-disabled-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-disabled-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes-disabled-2.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// If macro modularization (`use_extern_macros`) is not enabled,\n+// then tool attributes are treated as custom attributes.\n+\n+// compile-pass\n+\n+#![feature(custom_attribute)]\n+\n+#[rustfmt::bar]\n+fn main() {}"}, {"sha": "b3355352423799aa1caabe5968d40f7e1a1157b4", "filename": "src/test/ui/tool-attributes-misplaced-1.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-misplaced-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-misplaced-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes-misplaced-1.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(tool_attributes)]\n+\n+type A = rustfmt; //~ ERROR expected type, found tool module `rustfmt`\n+type B = rustfmt::skip; //~ ERROR expected type, found non-macro attribute `rustfmt::skip`\n+\n+#[derive(rustfmt)] //~ ERROR cannot find derive macro `rustfmt` in this scope\n+struct S;\n+\n+#[rustfmt] //~ ERROR cannot find attribute macro `rustfmt` in this scope\n+fn check() {}\n+\n+#[rustfmt::skip] // OK\n+fn main() {\n+    rustfmt; //~ ERROR expected value, found tool module `rustfmt`\n+    rustfmt!(); //~ ERROR cannot find macro `rustfmt!` in this scope\n+\n+    rustfmt::skip; //~ ERROR expected value, found non-macro attribute `rustfmt::skip`\n+}"}, {"sha": "b9e61121406eddc2a83996f8939e27b0da24d3db", "filename": "src/test/ui/tool-attributes-misplaced-1.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-misplaced-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-misplaced-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes-misplaced-1.stderr?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,46 @@\n+error: cannot find derive macro `rustfmt` in this scope\n+  --> $DIR/tool-attributes-misplaced-1.rs:16:10\n+   |\n+LL | #[derive(rustfmt)] //~ ERROR cannot find derive macro `rustfmt` in this scope\n+   |          ^^^^^^^\n+\n+error: cannot find attribute macro `rustfmt` in this scope\n+  --> $DIR/tool-attributes-misplaced-1.rs:19:3\n+   |\n+LL | #[rustfmt] //~ ERROR cannot find attribute macro `rustfmt` in this scope\n+   |   ^^^^^^^\n+\n+error: cannot find macro `rustfmt!` in this scope\n+  --> $DIR/tool-attributes-misplaced-1.rs:25:5\n+   |\n+LL |     rustfmt!(); //~ ERROR cannot find macro `rustfmt!` in this scope\n+   |     ^^^^^^^\n+\n+error[E0573]: expected type, found tool module `rustfmt`\n+  --> $DIR/tool-attributes-misplaced-1.rs:13:10\n+   |\n+LL | type A = rustfmt; //~ ERROR expected type, found tool module `rustfmt`\n+   |          ^^^^^^^ not a type\n+\n+error[E0573]: expected type, found non-macro attribute `rustfmt::skip`\n+  --> $DIR/tool-attributes-misplaced-1.rs:14:10\n+   |\n+LL | type B = rustfmt::skip; //~ ERROR expected type, found non-macro attribute `rustfmt::skip`\n+   |          ^^^^^^^^^^^^^ not a type\n+\n+error[E0423]: expected value, found tool module `rustfmt`\n+  --> $DIR/tool-attributes-misplaced-1.rs:24:5\n+   |\n+LL |     rustfmt; //~ ERROR expected value, found tool module `rustfmt`\n+   |     ^^^^^^^ not a value\n+\n+error[E0423]: expected value, found non-macro attribute `rustfmt::skip`\n+  --> $DIR/tool-attributes-misplaced-1.rs:27:5\n+   |\n+LL |     rustfmt::skip; //~ ERROR expected value, found non-macro attribute `rustfmt::skip`\n+   |     ^^^^^^^^^^^^^ not a value\n+\n+error: aborting due to 7 previous errors\n+\n+Some errors occurred: E0423, E0573.\n+For more information about an error, try `rustc --explain E0423`."}, {"sha": "3bb0e3dc34382b2b4bb0decfebfbd00a123b810c", "filename": "src/test/ui/tool-attributes-misplaced-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-misplaced-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-misplaced-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes-misplaced-2.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(tool_attributes)]\n+\n+#[derive(rustfmt::skip)] //~ ERROR expected a macro, found non-macro attribute\n+struct S;\n+\n+fn main() {\n+    rustfmt::skip!(); //~ ERROR expected a macro, found non-macro attribute\n+}"}, {"sha": "66452267e947b8448d3dea8510a6eb3e0cf73968", "filename": "src/test/ui/tool-attributes-misplaced-2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-misplaced-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-misplaced-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes-misplaced-2.stderr?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,14 @@\n+error: expected a macro, found non-macro attribute\n+  --> $DIR/tool-attributes-misplaced-2.rs:13:10\n+   |\n+LL | #[derive(rustfmt::skip)] //~ ERROR expected a macro, found non-macro attribute\n+   |          ^^^^^^^^^^^^^\n+\n+error: expected a macro, found non-macro attribute\n+  --> $DIR/tool-attributes-misplaced-2.rs:17:5\n+   |\n+LL |     rustfmt::skip!(); //~ ERROR expected a macro, found non-macro attribute\n+   |     ^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "7913c9f40b5538b32f2ff99079ea45be82db4528", "filename": "src/test/ui/tool-attributes-shadowing.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes-shadowing.rs?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(tool_attributes, proc_macro_path_invoc)]\n+\n+mod rustfmt {}\n+\n+#[rustfmt::skip] //~ ERROR failed to resolve. Could not find `skip` in `rustfmt`\n+fn main() {}"}, {"sha": "f668d677f7a20deec27f9b8c525294eaa15d5cfa", "filename": "src/test/ui/tool-attributes-shadowing.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40e4b6ee3dd70a05007915bd1c15c150a7b7899f/src%2Ftest%2Fui%2Ftool-attributes-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes-shadowing.stderr?ref=40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "patch": "@@ -0,0 +1,9 @@\n+error[E0433]: failed to resolve. Could not find `skip` in `rustfmt`\n+  --> $DIR/tool-attributes-shadowing.rs:15:12\n+   |\n+LL | #[rustfmt::skip] //~ ERROR failed to resolve. Could not find `skip` in `rustfmt`\n+   |            ^^^^ Could not find `skip` in `rustfmt`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}]}