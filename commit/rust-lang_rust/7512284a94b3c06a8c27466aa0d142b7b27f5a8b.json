{"sha": "7512284a94b3c06a8c27466aa0d142b7b27f5a8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MTIyODRhOTRiM2MwNmE4YzI3NDY2YWEwZDE0MmI3YjI3ZjVhOGI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-16T02:36:04Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-16T13:06:42Z"}, "message": "further modularization of typeck, add comments", "tree": {"sha": "f1d2a68d42632f74329c7163d241a88e1ad0f987", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1d2a68d42632f74329c7163d241a88e1ad0f987"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7512284a94b3c06a8c27466aa0d142b7b27f5a8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7512284a94b3c06a8c27466aa0d142b7b27f5a8b", "html_url": "https://github.com/rust-lang/rust/commit/7512284a94b3c06a8c27466aa0d142b7b27f5a8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cc596ceb600ae4404dd942c6480618cba237943", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cc596ceb600ae4404dd942c6480618cba237943", "html_url": "https://github.com/rust-lang/rust/commit/8cc596ceb600ae4404dd942c6480618cba237943"}], "stats": {"total": 6884, "additions": 3486, "deletions": 3398}, "files": [{"sha": "7e796b4f2c5074327363610cddbde0c9ffc669ba", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 62, "deletions": 3111, "changes": 3173, "blob_url": "https://github.com/rust-lang/rust/blob/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=7512284a94b3c06a8c27466aa0d142b7b27f5a8b"}, {"sha": "c74d491ff21b77a51a0c1ece59a0760cf8dbaf57", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 48, "deletions": 256, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=7512284a94b3c06a8c27466aa0d142b7b27f5a8b", "patch": "@@ -1,17 +1,18 @@\n #[doc = \"\n \n-Conversion from AST representation of types to the ty.rs representation.\n-\n-The main routine here is `ast_ty_to_ty()`: each use is parameterized\n-by an instance of `ast_conv` and a `region_scope`.\n-\n-The `ast_conv` interface is the conversion context.  It has two\n-implementations, one for the crate context and one for the function\n-context.  The main purpose is to provide the `get_item_ty()` hook\n-which looks up the type of an item by its def-id.  This can be done in\n-two ways: in the initial phase, when a crate context is provided, this\n-will potentially trigger a call to `ty_of_item()`.  Later, when a\n-function context is used, this will simply be a lookup.\n+Conversion from AST representation of types to the ty.rs\n+representation.  The main routine here is `ast_ty_to_ty()`: each use\n+is parameterized by an instance of `ast_conv` and a `region_scope`.\n+\n+The parameterization of `ast_ty_to_ty()` is because it behaves\n+somewhat differently during the collect and check phases, particularly\n+with respect to looking up the types of top-level items.  In the\n+collect phase, the crate context is used as the `ast_conv` instance;\n+in this phase, the `get_item_ty()` function triggers a recursive call\n+to `ty_of_item()` (note that `ast_ty_to_ty()` will detect recursive\n+types and report an error).  In the check phase, when the @fn_ctxt is\n+used as the `ast_conv`, `get_item_ty()` just looks up the item type in\n+`tcx.tcache`.\n \n The `region_scope` interface controls how region references are\n handled.  It has two methods which are used to resolve anonymous\n@@ -21,8 +22,30 @@ commonly you want either `empty_rscope`, which permits only the static\n region, or `type_rscope`, which permits the self region if the type in\n question is parameterized by a region.\n \n+Unlike the `ast_conv` iface, the region scope can change as we descend\n+the type.  This is to accommodate the fact that (a) fn types are binding\n+scopes and (b) the default region may change.  To understand case (a),\n+consider something like:\n+\n+  type foo = { x: &a.int, y: fn(&a.int) }\n+\n+The type of `x` is an error because there is no region `a` in scope.\n+In the type of `y`, however, region `a` is considered a bound region\n+as it does not already appear in scope.\n+\n+Case (b) says that if you have a type:\n+  type foo/& = ...;\n+  type bar = fn(&foo, &a.foo)\n+The fully expanded version of type bar is:\n+  type bar = fn(&foo/&, &a.foo/&a)\n+Note that the self region for the `foo` defaulted to `&` in the first\n+case but `&a` in the second.  Basically, defaults that appear inside\n+an rptr (`&r.T`) use the region `r` that appears in the rptr.\n+\n \"];\n \n+import check::fn_ctxt;\n+\n iface ast_conv {\n     fn tcx() -> ty::ctxt;\n     fn ccx() -> @crate_ctxt;\n@@ -32,48 +55,6 @@ iface ast_conv {\n     fn ty_infer(span: span) -> ty::t;\n }\n \n-impl of ast_conv for @crate_ctxt {\n-    fn tcx() -> ty::ctxt { self.tcx }\n-    fn ccx() -> @crate_ctxt { self }\n-\n-    fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n-        if id.crate != ast::local_crate {\n-            csearch::get_type(self.tcx, id)\n-        } else {\n-            alt self.tcx.items.find(id.node) {\n-              some(ast_map::node_item(item, _)) {\n-                ty_of_item(self, item)\n-              }\n-              some(ast_map::node_native_item(native_item, _, _)) {\n-                ty_of_native_item(self, native_item)\n-              }\n-              x {\n-                self.tcx.sess.bug(#fmt[\"unexpected sort of item \\\n-                                        in get_item_ty(): %?\", x]);\n-              }\n-            }\n-        }\n-    }\n-\n-    fn ty_infer(span: span) -> ty::t {\n-        self.tcx.sess.span_bug(span,\n-                               \"found `ty_infer` in unexpected place\");\n-    }\n-}\n-\n-impl of ast_conv for @fn_ctxt {\n-    fn tcx() -> ty::ctxt { self.ccx.tcx }\n-    fn ccx() -> @crate_ctxt { self.ccx }\n-\n-    fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n-        ty::lookup_item_type(self.tcx(), id)\n-    }\n-\n-    fn ty_infer(_span: span) -> ty::t {\n-        self.next_ty_var()\n-    }\n-}\n-\n iface region_scope {\n     fn anon_region() -> result<ty::region, str>;\n     fn named_region(id: str) -> result<ty::region, str>;\n@@ -112,23 +93,6 @@ impl of region_scope for type_rscope {\n     }\n }\n \n-impl of region_scope for @fn_ctxt {\n-    fn anon_region() -> result<ty::region, str> {\n-        result::ok(self.next_region_var())\n-    }\n-    fn named_region(id: str) -> result<ty::region, str> {\n-        empty_rscope.named_region(id).chain_err { |_e|\n-            alt self.in_scope_regions.find(ty::br_named(id)) {\n-              some(r) { result::ok(r) }\n-              none if id == \"blk\" { self.block_region() }\n-              none {\n-                result::err(#fmt[\"named region `%s` not in scope here\", id])\n-              }\n-            }\n-        }\n-    }\n-}\n-\n enum anon_rscope = {anon: ty::region, base: region_scope};\n fn in_anon_rscope<RS: region_scope copy>(self: RS, r: ty::region)\n     -> @anon_rscope {\n@@ -159,6 +123,19 @@ impl of region_scope for @binding_rscope {\n     }\n }\n \n+fn get_region_reporting_err(tcx: ty::ctxt,\n+                            span: span,\n+                            res: result<ty::region, str>) -> ty::region {\n+\n+    alt res {\n+      result::ok(r) { r }\n+      result::err(e) {\n+        tcx.sess.span_err(span, e);\n+        ty::re_static\n+      }\n+    }\n+}\n+\n fn ast_region_to_region<AC: ast_conv, RS: region_scope>(\n     self: AC, rscope: RS, span: span, a_r: @ast::region) -> ty::region {\n \n@@ -233,36 +210,6 @@ fn ast_path_to_ty<AC: ast_conv, RS: region_scope copy>(\n     ret {substs: substs, ty: ty};\n }\n \n-/*\n-  Instantiates the path for the given iface reference, assuming that\n-  it's bound to a valid iface type. Returns the def_id for the defining\n-  iface. Fails if the type is a type other than an iface type.\n- */\n-fn instantiate_iface_ref(ccx: @crate_ctxt, t: @ast::iface_ref,\n-                         rp: ast::region_param)\n-    -> (ast::def_id, ty_param_substs_and_ty) {\n-\n-    let sp = t.path.span, err = \"can only implement interface types\",\n-        sess = ccx.tcx.sess;\n-\n-    let rscope = type_rscope(rp);\n-\n-    alt lookup_def_tcx(ccx.tcx, t.path.span, t.id) {\n-      ast::def_ty(t_id) {\n-        let tpt = ast_path_to_ty(ccx, rscope, t_id, t.path, t.id);\n-        alt ty::get(tpt.ty).struct {\n-           ty::ty_iface(*) {\n-              (t_id, tpt)\n-           }\n-           _ { sess.span_fatal(sp, err); }\n-        }\n-      }\n-      _ {\n-          sess.span_fatal(sp, err);\n-      }\n-    }\n-}\n-\n const NO_REGIONS: uint = 1u;\n const NO_TPS: uint = 2u;\n \n@@ -474,103 +421,6 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n     ret typ;\n }\n \n-fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n-    -> ty::ty_param_bounds_and_ty {\n-\n-    let def_id = local_def(it.id);\n-    let tcx = ccx.tcx;\n-    alt tcx.tcache.find(def_id) {\n-      some(tpt) { ret tpt; }\n-      _ {}\n-    }\n-    alt it.node {\n-      ast::item_const(t, _) {\n-        let typ = ccx.to_ty(empty_rscope, t);\n-        let tpt = no_params(typ);\n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        ret tpt;\n-      }\n-      ast::item_fn(decl, tps, _) {\n-        let bounds = ty_param_bounds(ccx, tps);\n-        let tofd = ty_of_fn_decl(ccx, empty_rscope, ast::proto_bare,\n-                                 decl, none);\n-        let tpt = {bounds: bounds,\n-                   rp: ast::rp_none, // functions do not have a self\n-                   ty: ty::mk_fn(ccx.tcx, tofd)};\n-        ccx.tcx.tcache.insert(local_def(it.id), tpt);\n-        ret tpt;\n-      }\n-      ast::item_ty(t, tps, rp) {\n-        alt tcx.tcache.find(local_def(it.id)) {\n-          some(tpt) { ret tpt; }\n-          none { }\n-        }\n-\n-        let tpt = {\n-            let ty = {\n-                let t0 = ccx.to_ty(type_rscope(rp), t);\n-                // Do not associate a def id with a named, parameterized type\n-                // like \"foo<X>\".  This is because otherwise ty_to_str will\n-                // print the name as merely \"foo\", as it has no way to\n-                // reconstruct the value of X.\n-                if !vec::is_empty(tps) { t0 } else {\n-                    ty::mk_with_id(tcx, t0, def_id)\n-                }\n-            };\n-            {bounds: ty_param_bounds(ccx, tps), rp: rp, ty: ty}\n-        };\n-\n-        check_bounds_are_used(ccx, t.span, tps, rp, tpt.ty);\n-\n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        ret tpt;\n-      }\n-      ast::item_res(decl, tps, _, _, _, rp) {\n-        let {bounds, substs} = mk_substs(ccx, tps, rp);\n-        let t_arg = ty_of_arg(ccx, type_rscope(rp),\n-                              decl.inputs[0], none);\n-        let t = ty::mk_res(tcx, local_def(it.id), t_arg.ty, substs);\n-        let t_res = {bounds: bounds, rp: rp, ty: t};\n-        tcx.tcache.insert(local_def(it.id), t_res);\n-        ret t_res;\n-      }\n-      ast::item_enum(_, tps, rp) {\n-        // Create a new generic polytype.\n-        let {bounds, substs} = mk_substs(ccx, tps, rp);\n-        let t = ty::mk_enum(tcx, local_def(it.id), substs);\n-        let tpt = {bounds: bounds, rp: rp, ty: t};\n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        ret tpt;\n-      }\n-      ast::item_iface(tps, rp, ms) {\n-        let {bounds, substs} = mk_substs(ccx, tps, rp);\n-        let t = ty::mk_iface(tcx, local_def(it.id), substs);\n-        let tpt = {bounds: bounds, rp: rp, ty: t};\n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        ret tpt;\n-      }\n-      ast::item_class(tps, _, _, _, _, rp) {\n-          let {bounds,substs} = mk_substs(ccx, tps, rp);\n-          let t = ty::mk_class(tcx, local_def(it.id), substs);\n-          let tpt = {bounds: bounds, rp: rp, ty: t};\n-          tcx.tcache.insert(local_def(it.id), tpt);\n-          ret tpt;\n-      }\n-      ast::item_impl(*) | ast::item_mod(_) |\n-      ast::item_native_mod(_) { fail; }\n-    }\n-}\n-\n-fn ty_of_native_item(ccx: @crate_ctxt, it: @ast::native_item)\n-    -> ty::ty_param_bounds_and_ty {\n-    alt it.node {\n-      ast::native_item_fn(fn_decl, params) {\n-        ret ty_of_native_fn_decl(ccx, fn_decl, params,\n-                                 local_def(it.id));\n-      }\n-    }\n-}\n-\n fn ty_of_arg<AC: ast_conv, RS: region_scope copy>(\n     self: AC, rscope: RS, a: ast::arg,\n     expected_ty: option<ty::arg>) -> ty::arg {\n@@ -651,61 +501,3 @@ fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy>(\n }\n \n \n-fn ty_param_bounds(ccx: @crate_ctxt,\n-                   params: [ast::ty_param]) -> @[ty::param_bounds] {\n-\n-    fn compute_bounds(ccx: @crate_ctxt,\n-                      param: ast::ty_param) -> ty::param_bounds {\n-        @vec::flat_map(*param.bounds) { |b|\n-            alt b {\n-              ast::bound_send { [ty::bound_send] }\n-              ast::bound_copy { [ty::bound_copy] }\n-              ast::bound_iface(t) {\n-                let ity = ast_ty_to_ty(ccx, empty_rscope, t);\n-                alt ty::get(ity).struct {\n-                  ty::ty_iface(*) {\n-                    [ty::bound_iface(ity)]\n-                  }\n-                  _ {\n-                    ccx.tcx.sess.span_err(\n-                        t.span, \"type parameter bounds must be \\\n-                                 interface types\");\n-                    []\n-                  }\n-                }\n-              }\n-            }\n-        }\n-    }\n-\n-    @params.map { |param|\n-        alt ccx.tcx.ty_param_bounds.find(param.id) {\n-          some(bs) { bs }\n-          none {\n-            let bounds = compute_bounds(ccx, param);\n-            ccx.tcx.ty_param_bounds.insert(param.id, bounds);\n-            bounds\n-          }\n-        }\n-    }\n-}\n-\n-fn ty_of_native_fn_decl(ccx: @crate_ctxt,\n-                        decl: ast::fn_decl,\n-                        ty_params: [ast::ty_param],\n-                        def_id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n-\n-    let bounds = ty_param_bounds(ccx, ty_params);\n-    let rb = in_binding_rscope(empty_rscope);\n-    let input_tys = decl.inputs.map { |a| ty_of_arg(ccx, rb, a, none) };\n-    let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n-\n-    let t_fn = ty::mk_fn(ccx.tcx, {proto: ast::proto_bare,\n-                                   inputs: input_tys,\n-                                   output: output_ty,\n-                                   ret_style: ast::return_val,\n-                                   constraints: []});\n-    let tpt = {bounds: bounds, rp: ast::rp_none, ty: t_fn};\n-    ccx.tcx.tcache.insert(def_id, tpt);\n-    ret tpt;\n-}"}, {"sha": "620a353617c8f0b91fc49069562b401c4dea9edb", "filename": "src/rustc/middle/typeck/check.rs", "status": "added", "additions": 2977, "deletions": 0, "changes": 2977, "blob_url": "https://github.com/rust-lang/rust/blob/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=7512284a94b3c06a8c27466aa0d142b7b27f5a8b"}, {"sha": "41cbf129fb00dd424e58d3944ce7cfcc696b4140", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 390, "deletions": 31, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=7512284a94b3c06a8c27466aa0d142b7b27f5a8b", "patch": "@@ -1,16 +1,71 @@\n-import astconv::{type_rscope, instantiate_iface_ref, ty_of_item,\n-                 empty_rscope, ty_of_native_item, ast_conv};\n-\n-// Item collection - a pair of bootstrap passes:\n-//\n-// (1) Collect the IDs of all type items (typedefs) and store them in a table.\n-//\n-// (2) Translate the AST fragments that describe types to determine a type for\n-//     each item. When we encounter a named type, we consult the table built\n-//     in pass 1 to find its item, and recursively translate it.\n-//\n-// We then annotate the AST with the resulting types and return the annotated\n-// AST, along with a table mapping item IDs to their types.\n+/*\n+\n+# Collect phase\n+\n+The collect phase of type check has the job of visiting all items,\n+determining their type, and writing that type into the `tcx.tcache`\n+table.  Despite its name, this table does not really operate as a\n+*cache*, at least not for the types of items defined within the\n+current crate: we assume that after the collect phase, the types of\n+all local items will be present in the table.\n+\n+Unlike most of the types that are present in Rust, the types computed\n+for each item are in fact polytypes.  In \"layman's terms\", this means\n+that they are generic types that may have type parameters (more\n+mathematically phrased, they are universally quantified over a set of\n+type parameters).  Polytypes are represented by an instance of\n+`ty::ty_param_bounds_and_ty`.  This combines the core type along with\n+a list of the bounds for each parameter.  Type parameters themselves\n+are represented as `ty_param()` instances.\n+\n+*/\n+\n+import astconv::{type_rscope, empty_rscope, in_binding_rscope, ast_conv,\n+                 ty_of_fn_decl, ty_of_arg, region_scope, ast_ty_to_ty};\n+\n+fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n+    visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n+        visit_item: bind convert(ccx, _),\n+        visit_native_item: bind convert_native(ccx, _)\n+        with *visit::default_simple_visitor()\n+    }));\n+}\n+\n+impl methods for @crate_ctxt {\n+    fn to_ty<RS: region_scope copy>(rs: RS, ast_ty: @ast::ty) -> ty::t {\n+        ast_ty_to_ty(self, rs, ast_ty)\n+    }\n+}\n+\n+impl of ast_conv for @crate_ctxt {\n+    fn tcx() -> ty::ctxt { self.tcx }\n+    fn ccx() -> @crate_ctxt { self }\n+\n+    fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+        if id.crate != ast::local_crate {\n+            csearch::get_type(self.tcx, id)\n+        } else {\n+            alt self.tcx.items.find(id.node) {\n+              some(ast_map::node_item(item, _)) {\n+                ty_of_item(self, item)\n+              }\n+              some(ast_map::node_native_item(native_item, _, _)) {\n+                ty_of_native_item(self, native_item)\n+              }\n+              x {\n+                self.tcx.sess.bug(#fmt[\"unexpected sort of item \\\n+                                        in get_item_ty(): %?\", x]);\n+              }\n+            }\n+        }\n+    }\n+\n+    fn ty_infer(span: span) -> ty::t {\n+        self.tcx.sess.span_bug(span,\n+                               \"found `ty_infer` in unexpected place\");\n+    }\n+}\n+\n fn get_enum_variant_types(ccx: @crate_ctxt,\n                           enum_ty: ty::t,\n                           variants: [ast::variant],\n@@ -36,7 +91,7 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n                             ret_style: ast::return_val,\n                             constraints: []})\n         };\n-        let tpt = {bounds: astconv::ty_param_bounds(ccx, ty_params),\n+        let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n                    rp: rp,\n                    ty: result_ty};\n         tcx.tcache.insert(local_def(variant.node.id), tpt);\n@@ -68,6 +123,51 @@ fn ensure_iface_methods(ccx: @crate_ctxt, id: ast::node_id) {\n     }\n }\n \n+fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n+                       impl_tps: uint, if_m: ty::method, substs: ty::substs,\n+                       self_ty: ty::t) -> ty::t {\n+\n+    if impl_m.tps != if_m.tps {\n+        tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n+                          \"` has an incompatible set of type parameters\");\n+        ty::mk_fn(tcx, impl_m.fty)\n+    } else if vec::len(impl_m.fty.inputs) != vec::len(if_m.fty.inputs) {\n+        tcx.sess.span_err(sp,#fmt[\"method `%s` has %u parameters \\\n+                                   but the iface has %u\",\n+                                  if_m.ident,\n+                                  vec::len(impl_m.fty.inputs),\n+                                  vec::len(if_m.fty.inputs)]);\n+        ty::mk_fn(tcx, impl_m.fty)\n+    } else {\n+        let auto_modes = vec::map2(impl_m.fty.inputs, if_m.fty.inputs, {|i, f|\n+            alt ty::get(f.ty).struct {\n+              ty::ty_param(*) | ty::ty_self\n+              if alt i.mode { ast::infer(_) { true } _ { false } } {\n+                {mode: ast::expl(ast::by_ref) with i}\n+              }\n+              _ { i }\n+            }\n+        });\n+        let impl_fty = ty::mk_fn(tcx, {inputs: auto_modes with impl_m.fty});\n+\n+        // Add dummy substs for the parameters of the impl method\n+        let substs = {\n+            self_r: substs.self_r,\n+            self_ty: some(self_ty),\n+            tps: substs.tps + vec::from_fn(vec::len(*if_m.tps), {|i|\n+                ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n+            })\n+        };\n+        let mut if_fty = ty::mk_fn(tcx, if_m.fty);\n+        if_fty = ty::subst(tcx, substs, if_fty);\n+        require_same_types(\n+            tcx, sp, impl_fty, if_fty,\n+            {|| \"method `\" + if_m.ident +\n+                 \"` has an incompatible type\"});\n+        ret impl_fty;\n+    }\n+}\n+\n fn check_methods_against_iface(ccx: @crate_ctxt,\n                                tps: [ast::ty_param],\n                                rp: ast::region_param,\n@@ -76,7 +176,7 @@ fn check_methods_against_iface(ccx: @crate_ctxt,\n                                ms: [@ast::method]) {\n \n     let tcx = ccx.tcx;\n-    let i_bounds = astconv::ty_param_bounds(ccx, tps);\n+    let i_bounds = ty_param_bounds(ccx, tps);\n     let my_methods = convert_methods(ccx, ms, rp, i_bounds, selfty);\n     let (did, tpt) = instantiate_iface_ref(ccx, a_ifacety, rp);\n     if did.crate == ast::local_crate {\n@@ -138,7 +238,7 @@ fn convert_methods(ccx: @crate_ctxt,\n     let tcx = ccx.tcx;\n     vec::map(ms) { |m|\n         write_ty_to_tcx(tcx, m.self_id, self_ty);\n-        let bounds = astconv::ty_param_bounds(ccx, m.tps);\n+        let bounds = ty_param_bounds(ccx, m.tps);\n         let mty = ty_of_method(ccx, m, rp);\n         let fty = ty::mk_fn(tcx, mty.fty);\n         tcx.tcache.insert(\n@@ -169,7 +269,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n                                ty_params, rp);\n       }\n       ast::item_impl(tps, rp, ifce, selfty, ms) {\n-        let i_bounds = astconv::ty_param_bounds(ccx, tps);\n+        let i_bounds = ty_param_bounds(ccx, tps);\n         let selfty = ccx.to_ty(type_rscope(rp), selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n         tcx.tcache.insert(local_def(it.id),\n@@ -194,7 +294,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n       ast::item_res(decl, tps, _, dtor_id, ctor_id, rp) {\n         let {bounds, substs} = mk_substs(ccx, tps, rp);\n         let def_id = local_def(it.id);\n-        let t_arg = astconv::ty_of_arg(ccx, type_rscope(rp),\n+        let t_arg = ty_of_arg(ccx, type_rscope(rp),\n                                        decl.inputs[0], none);\n         let t_res = ty::mk_res(tcx, def_id, t_arg.ty, substs);\n \n@@ -237,7 +337,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         let t_ctor =\n             ty::mk_fn(\n                 tcx,\n-                astconv::ty_of_fn_decl(ccx,\n+                ty_of_fn_decl(ccx,\n                                        empty_rscope,\n                                        ast::proto_any,\n                                        ctor.node.dec,\n@@ -253,7 +353,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n                 tcx,\n                 // not sure about empty_rscope\n                 // FIXME\n-                astconv::ty_of_fn_decl(ccx,\n+                ty_of_fn_decl(ccx,\n                                        empty_rscope,\n                                        ast::proto_any,\n                                        ast_util::dtor_dec(),\n@@ -317,20 +417,13 @@ fn convert_native(ccx: @crate_ctxt, i: @ast::native_item) {\n       }\n     }\n }\n-fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n-    visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n-        visit_item: bind convert(ccx, _),\n-        visit_native_item: bind convert_native(ccx, _)\n-        with *visit::default_simple_visitor()\n-    }));\n-}\n \n fn ty_of_method(ccx: @crate_ctxt,\n                 m: @ast::method,\n                 rp: ast::region_param) -> ty::method {\n     {ident: m.ident,\n-     tps: astconv::ty_param_bounds(ccx, m.tps),\n-     fty: astconv::ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare,\n+     tps: ty_param_bounds(ccx, m.tps),\n+     fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare,\n                                  m.decl, none),\n      purity: m.decl.purity,\n      vis: m.vis}\n@@ -340,9 +433,275 @@ fn ty_of_ty_method(self: @crate_ctxt,\n                    m: ast::ty_method,\n                    rp: ast::region_param) -> ty::method {\n     {ident: m.ident,\n-     tps: astconv::ty_param_bounds(self, m.tps),\n-     fty: astconv::ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare,\n+     tps: ty_param_bounds(self, m.tps),\n+     fty: ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare,\n                                  m.decl, none),\n      // assume public, because this is only invoked on iface methods\n      purity: m.decl.purity, vis: ast::public}\n }\n+\n+fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::native_item) {\n+    fn param(ccx: @crate_ctxt, n: uint) -> ty::t {\n+        ty::mk_param(ccx.tcx, n, local_def(0))\n+    }\n+    fn arg(m: ast::rmode, ty: ty::t) -> ty::arg {\n+        {mode: ast::expl(m), ty: ty}\n+    }\n+    let tcx = ccx.tcx;\n+    let (n_tps, inputs, output) = alt it.ident {\n+      \"size_of\" |\n+      \"pref_align_of\" | \"min_align_of\" { (1u, [], ty::mk_uint(ccx.tcx)) }\n+      \"get_tydesc\" { (1u, [], ty::mk_nil_ptr(tcx)) }\n+      \"init\" { (1u, [], param(ccx, 0u)) }\n+      \"forget\" { (1u, [arg(ast::by_move, param(ccx, 0u))],\n+                  ty::mk_nil(tcx)) }\n+      \"reinterpret_cast\" { (2u, [arg(ast::by_ref, param(ccx, 0u))],\n+                            param(ccx, 1u)) }\n+      \"addr_of\" { (1u, [arg(ast::by_ref, param(ccx, 0u))],\n+                   ty::mk_imm_ptr(tcx, param(ccx, 0u))) }\n+      \"needs_drop\" { (1u, [], ty::mk_bool(tcx)) }\n+\n+      \"visit_ty\" { (2u, [arg(ast::by_ref, param(ccx, 1u))],\n+                    ty::mk_nil(tcx)) }\n+\n+      \"visit_val\" { (2u, [arg(ast::by_ref, param(ccx, 0u)),\n+                          arg(ast::by_ref, param(ccx, 1u))],\n+                     ty::mk_nil(tcx)) }\n+\n+      \"visit_val_pair\" { (2u, [arg(ast::by_ref, param(ccx, 0u)),\n+                               arg(ast::by_ref, param(ccx, 0u)),\n+                               arg(ast::by_ref, param(ccx, 1u))],\n+                          ty::mk_nil(tcx)) }\n+\n+      other {\n+        tcx.sess.span_err(it.span, \"unrecognized intrinsic function: `\" +\n+                          other + \"`\");\n+        ret;\n+      }\n+    };\n+    let fty = ty::mk_fn(tcx, {proto: ast::proto_bare,\n+                              inputs: inputs, output: output,\n+                              ret_style: ast::return_val,\n+                              constraints: []});\n+    let i_ty = ty_of_native_item(ccx, it);\n+    let i_n_tps = (*i_ty.bounds).len();\n+    if i_n_tps != n_tps {\n+        tcx.sess.span_err(it.span, #fmt(\"intrinsic has wrong number \\\n+                                         of type parameters. found %u, \\\n+                                         expected %u\", i_n_tps, n_tps));\n+    } else {\n+        require_same_types(\n+            tcx, it.span, i_ty.ty, fty,\n+            {|| #fmt[\"intrinsic has wrong type. \\\n+                      expected %s\",\n+                     ty_to_str(ccx.tcx, fty)]});\n+    }\n+}\n+\n+\n+/*\n+  Instantiates the path for the given iface reference, assuming that\n+  it's bound to a valid iface type. Returns the def_id for the defining\n+  iface. Fails if the type is a type other than an iface type.\n+ */\n+fn instantiate_iface_ref(ccx: @crate_ctxt, t: @ast::iface_ref,\n+                         rp: ast::region_param)\n+    -> (ast::def_id, ty_param_substs_and_ty) {\n+\n+    let sp = t.path.span, err = \"can only implement interface types\",\n+        sess = ccx.tcx.sess;\n+\n+    let rscope = type_rscope(rp);\n+\n+    alt lookup_def_tcx(ccx.tcx, t.path.span, t.id) {\n+      ast::def_ty(t_id) {\n+        let tpt = astconv::ast_path_to_ty(ccx, rscope, t_id, t.path, t.id);\n+        alt ty::get(tpt.ty).struct {\n+           ty::ty_iface(*) {\n+              (t_id, tpt)\n+           }\n+           _ { sess.span_fatal(sp, err); }\n+        }\n+      }\n+      _ {\n+          sess.span_fatal(sp, err);\n+      }\n+    }\n+}\n+\n+fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n+    -> ty::ty_param_bounds_and_ty {\n+\n+    let def_id = local_def(it.id);\n+    let tcx = ccx.tcx;\n+    alt tcx.tcache.find(def_id) {\n+      some(tpt) { ret tpt; }\n+      _ {}\n+    }\n+    alt it.node {\n+      ast::item_const(t, _) {\n+        let typ = ccx.to_ty(empty_rscope, t);\n+        let tpt = no_params(typ);\n+        tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n+      }\n+      ast::item_fn(decl, tps, _) {\n+        let bounds = ty_param_bounds(ccx, tps);\n+        let tofd = ty_of_fn_decl(ccx, empty_rscope, ast::proto_bare,\n+                                          decl, none);\n+        let tpt = {bounds: bounds,\n+                   rp: ast::rp_none, // functions do not have a self\n+                   ty: ty::mk_fn(ccx.tcx, tofd)};\n+        ccx.tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n+      }\n+      ast::item_ty(t, tps, rp) {\n+        alt tcx.tcache.find(local_def(it.id)) {\n+          some(tpt) { ret tpt; }\n+          none { }\n+        }\n+\n+        let tpt = {\n+            let ty = {\n+                let t0 = ccx.to_ty(type_rscope(rp), t);\n+                // Do not associate a def id with a named, parameterized type\n+                // like \"foo<X>\".  This is because otherwise ty_to_str will\n+                // print the name as merely \"foo\", as it has no way to\n+                // reconstruct the value of X.\n+                if !vec::is_empty(tps) { t0 } else {\n+                    ty::mk_with_id(tcx, t0, def_id)\n+                }\n+            };\n+            {bounds: ty_param_bounds(ccx, tps), rp: rp, ty: ty}\n+        };\n+\n+        tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n+      }\n+      ast::item_res(decl, tps, _, _, _, rp) {\n+        let {bounds, substs} = mk_substs(ccx, tps, rp);\n+        let t_arg = ty_of_arg(ccx, type_rscope(rp),\n+                                       decl.inputs[0], none);\n+        let t = ty::mk_res(tcx, local_def(it.id), t_arg.ty, substs);\n+        let t_res = {bounds: bounds, rp: rp, ty: t};\n+        tcx.tcache.insert(local_def(it.id), t_res);\n+        ret t_res;\n+      }\n+      ast::item_enum(_, tps, rp) {\n+        // Create a new generic polytype.\n+        let {bounds, substs} = mk_substs(ccx, tps, rp);\n+        let t = ty::mk_enum(tcx, local_def(it.id), substs);\n+        let tpt = {bounds: bounds, rp: rp, ty: t};\n+        tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n+      }\n+      ast::item_iface(tps, rp, ms) {\n+        let {bounds, substs} = mk_substs(ccx, tps, rp);\n+        let t = ty::mk_iface(tcx, local_def(it.id), substs);\n+        let tpt = {bounds: bounds, rp: rp, ty: t};\n+        tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n+      }\n+      ast::item_class(tps, _, _, _, _, rp) {\n+          let {bounds,substs} = mk_substs(ccx, tps, rp);\n+          let t = ty::mk_class(tcx, local_def(it.id), substs);\n+          let tpt = {bounds: bounds, rp: rp, ty: t};\n+          tcx.tcache.insert(local_def(it.id), tpt);\n+          ret tpt;\n+      }\n+      ast::item_impl(*) | ast::item_mod(_) |\n+      ast::item_native_mod(_) { fail; }\n+    }\n+}\n+\n+fn ty_of_native_item(ccx: @crate_ctxt, it: @ast::native_item)\n+    -> ty::ty_param_bounds_and_ty {\n+    alt it.node {\n+      ast::native_item_fn(fn_decl, params) {\n+        ret ty_of_native_fn_decl(ccx, fn_decl, params,\n+                                 local_def(it.id));\n+      }\n+    }\n+}\n+fn ty_param_bounds(ccx: @crate_ctxt,\n+                   params: [ast::ty_param]) -> @[ty::param_bounds] {\n+\n+    fn compute_bounds(ccx: @crate_ctxt,\n+                      param: ast::ty_param) -> ty::param_bounds {\n+        @vec::flat_map(*param.bounds) { |b|\n+            alt b {\n+              ast::bound_send { [ty::bound_send] }\n+              ast::bound_copy { [ty::bound_copy] }\n+              ast::bound_iface(t) {\n+                let ity = ast_ty_to_ty(ccx, empty_rscope, t);\n+                alt ty::get(ity).struct {\n+                  ty::ty_iface(*) {\n+                    [ty::bound_iface(ity)]\n+                  }\n+                  _ {\n+                    ccx.tcx.sess.span_err(\n+                        t.span, \"type parameter bounds must be \\\n+                                 interface types\");\n+                    []\n+                  }\n+                }\n+              }\n+            }\n+        }\n+    }\n+\n+    @params.map { |param|\n+        alt ccx.tcx.ty_param_bounds.find(param.id) {\n+          some(bs) { bs }\n+          none {\n+            let bounds = compute_bounds(ccx, param);\n+            ccx.tcx.ty_param_bounds.insert(param.id, bounds);\n+            bounds\n+          }\n+        }\n+    }\n+}\n+\n+fn ty_of_native_fn_decl(ccx: @crate_ctxt,\n+                        decl: ast::fn_decl,\n+                        ty_params: [ast::ty_param],\n+                        def_id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+\n+    let bounds = ty_param_bounds(ccx, ty_params);\n+    let rb = in_binding_rscope(empty_rscope);\n+    let input_tys = decl.inputs.map { |a| ty_of_arg(ccx, rb, a, none) };\n+    let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n+\n+    let t_fn = ty::mk_fn(ccx.tcx, {proto: ast::proto_bare,\n+                                   inputs: input_tys,\n+                                   output: output_ty,\n+                                   ret_style: ast::return_val,\n+                                   constraints: []});\n+    let tpt = {bounds: bounds, rp: ast::rp_none, ty: t_fn};\n+    ccx.tcx.tcache.insert(def_id, tpt);\n+    ret tpt;\n+}\n+\n+fn mk_ty_params(ccx: @crate_ctxt, atps: [ast::ty_param])\n+    -> {bounds: @[ty::param_bounds], params: [ty::t]} {\n+\n+    let mut i = 0u;\n+    let bounds = ty_param_bounds(ccx, atps);\n+    {bounds: bounds,\n+     params: vec::map(atps, {|atp|\n+         let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));\n+         i += 1u;\n+         t\n+     })}\n+}\n+\n+fn mk_substs(ccx: @crate_ctxt, atps: [ast::ty_param], rp: ast::region_param)\n+    -> {bounds: @[ty::param_bounds], substs: ty::substs} {\n+\n+    let {bounds, params} = mk_ty_params(ccx, atps);\n+    let self_r = alt rp {\n+      ast::rp_self { some(ty::re_bound(ty::br_self)) }\n+      ast::rp_none { none }\n+    };\n+    {bounds: bounds, substs: {self_r: self_r, self_ty: none, tps: params}}\n+}"}, {"sha": "d61aa687511beece0fd976de311542aa903ac018", "filename": "src/rustc/middle/typeck/demand.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fdemand.rs?ref=7512284a94b3c06a8c27466aa0d142b7b27f5a8b", "patch": "@@ -1,3 +1,5 @@\n+import check::{fn_ctxt, methods};\n+\n // Requires that the two types unify, and prints an error message if they\n // don't.\n fn suptype(fcx: @fn_ctxt, sp: span,"}, {"sha": "05ff109a0db60d74a7637914a95c91dc7a378b4a", "filename": "src/rustc/middle/typeck/regionck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fregionck.rs?ref=7512284a94b3c06a8c27466aa0d142b7b27f5a8b", "patch": "@@ -15,6 +15,7 @@ the region scope `r`.\n \n import util::ppaux;\n import syntax::print::pprust;\n+import check::{fn_ctxt, methods};\n \n type rcx = @{fcx: @fn_ctxt, mut errors_reported: uint};\n type rvt = visit::vt<rcx>;"}, {"sha": "5201ce1b558ca96d77d9d01b1a2854778069944f", "filename": "src/rustc/middle/typeck/vtable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fvtable.rs?ref=7512284a94b3c06a8c27466aa0d142b7b27f5a8b", "patch": "@@ -1,3 +1,5 @@\n+import check::{fn_ctxt, impl_self_ty, methods};\n+\n fn has_iface_bounds(tps: [ty::param_bounds]) -> bool {\n     vec::any(tps, {|bs|\n         vec::any(*bs, {|b|"}, {"sha": "ba31e8a8c4025e30c08629a5235bfc09a75ea923", "filename": "src/rustc/middle/typeck/writeback.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Fmiddle%2Ftypeck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fwriteback.rs?ref=7512284a94b3c06a8c27466aa0d142b7b27f5a8b", "patch": "@@ -1,6 +1,9 @@\n // Type resolution: the phase that finds all the types in the AST with\n // unresolved type variables and replaces \"ty_var\" types with their\n // substitutions.\n+\n+import check::{fn_ctxt, lookup_local, methods};\n+\n export resolve_type_vars_in_fn;\n export resolve_type_vars_in_expr;\n "}, {"sha": "0fffb21c488d98802425b604a74127d8b8f05279", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/7512284a94b3c06a8c27466aa0d142b7b27f5a8b/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=7512284a94b3c06a8c27466aa0d142b7b27f5a8b", "patch": "@@ -52,6 +52,7 @@ mod middle {\n     mod ast_map;\n     mod resolve;\n     mod typeck {\n+        mod check;\n         mod regionck;\n         mod demand;\n         mod infer;"}]}