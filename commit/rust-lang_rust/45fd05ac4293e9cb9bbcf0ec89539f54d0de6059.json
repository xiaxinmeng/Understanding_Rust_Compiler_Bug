{"sha": "45fd05ac4293e9cb9bbcf0ec89539f54d0de6059", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZmQwNWFjNDI5M2U5Y2I5YmJjZjBlYzg5NTM5ZjU0ZDBkZTYwNTk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-20T23:54:38Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-20T23:54:38Z"}, "message": "Teach ty and typeck about linear for loops.", "tree": {"sha": "a74a737b9469f0996e1bfd3afdeacb41d6e4a73d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a74a737b9469f0996e1bfd3afdeacb41d6e4a73d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45fd05ac4293e9cb9bbcf0ec89539f54d0de6059", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45fd05ac4293e9cb9bbcf0ec89539f54d0de6059", "html_url": "https://github.com/rust-lang/rust/commit/45fd05ac4293e9cb9bbcf0ec89539f54d0de6059", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45fd05ac4293e9cb9bbcf0ec89539f54d0de6059/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61379af1a979aa7813aa9470e2558953eef166b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/61379af1a979aa7813aa9470e2558953eef166b6", "html_url": "https://github.com/rust-lang/rust/commit/61379af1a979aa7813aa9470e2558953eef166b6"}], "stats": {"total": 86, "additions": 56, "deletions": 30}, "files": [{"sha": "f27595a157c35bb92f8dbf890b060d38fbcfb175", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45fd05ac4293e9cb9bbcf0ec89539f54d0de6059/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fd05ac4293e9cb9bbcf0ec89539f54d0de6059/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=45fd05ac4293e9cb9bbcf0ec89539f54d0de6059", "patch": "@@ -646,6 +646,7 @@ fn expr_ty(@ast.expr expr) -> @t {\n         case (ast.expr_lit(_, ?ann))          { ret ann_to_type(ann); }\n         case (ast.expr_cast(_, _, ?ann))      { ret ann_to_type(ann); }\n         case (ast.expr_if(_, _, _, ?ann))     { ret ann_to_type(ann); }\n+        case (ast.expr_for(_, _, _, ?ann))    { ret ann_to_type(ann); }\n         case (ast.expr_while(_, _, ?ann))     { ret ann_to_type(ann); }\n         case (ast.expr_do_while(_, _, ?ann))  { ret ann_to_type(ann); }\n         case (ast.expr_alt(_, _, ?ann))       { ret ann_to_type(ann); }"}, {"sha": "02e6eaaac504961746c9c70f034c5f727b94fa29", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 55, "deletions": 30, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/45fd05ac4293e9cb9bbcf0ec89539f54d0de6059/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fd05ac4293e9cb9bbcf0ec89539f54d0de6059/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=45fd05ac4293e9cb9bbcf0ec89539f54d0de6059", "patch": "@@ -721,6 +721,10 @@ fn demand_expr(&@fn_ctxt fcx, @ty.t expected, @ast.expr e) -> @ast.expr {\n             }\n             e_1 = ast.expr_if(cond, then_1, else_1, ast.ann_type(t));\n         }\n+        case (ast.expr_for(?decl, ?seq, ?bloc, ?ann)) {\n+            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+            e_1 = ast.expr_for(decl, seq, bloc, ast.ann_type(t));\n+        }\n         case (ast.expr_while(?cond, ?bloc, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             e_1 = ast.expr_while(cond, bloc, ast.ann_type(t));\n@@ -1055,6 +1059,20 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                     ast.ann_type(elsopt_t)));\n         }\n \n+        case (ast.expr_for(?decl, ?seq, ?body, _)) {\n+            auto decl_1 = check_decl_local(fcx, decl);\n+            auto seq_1 = check_expr(fcx, seq);\n+            auto body_1 = check_block(fcx, body);\n+\n+            // FIXME: enforce that the type of the decl is the element type\n+            // of the seq.\n+\n+            auto ann = ast.ann_type(plain_ty(ty.ty_nil));\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_for(decl_1, seq_1,\n+                                                     body_1, ann));\n+        }\n+\n         case (ast.expr_while(?cond, ?body, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n             auto cond_1 = demand_expr(fcx, plain_ty(ty.ty_bool), cond_0);\n@@ -1413,40 +1431,47 @@ fn next_ty_var(@crate_ctxt ccx) -> @ty.t {\n     ret t;\n }\n \n+fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n+    alt (decl.node) {\n+        case (ast.decl_local(?local)) {\n+\n+            auto local_ty;\n+            alt (local.ty) {\n+                case (none[@ast.ty]) {\n+                    // Auto slot. Assign a ty_var.\n+                    local_ty = next_ty_var(fcx.ccx);\n+                }\n+\n+                case (some[@ast.ty](?ast_ty)) {\n+                    local_ty = ast_ty_to_ty_crate(fcx.ccx, ast_ty);\n+                }\n+            }\n+            fcx.locals.insert(local.id, local_ty);\n+\n+            auto rhs_ty = local_ty;\n+            auto init = local.init;\n+            alt (local.init) {\n+                case (some[@ast.expr](?expr)) {\n+                    auto expr_0 = check_expr(fcx, expr);\n+                    auto lty = plain_ty(ty.ty_local(local.id));\n+                    auto expr_1 = demand_expr(fcx, lty, expr_0);\n+                    init = some[@ast.expr](expr_1);\n+                }\n+                case (_) { /* fall through */  }\n+            }\n+            auto local_1 = @rec(init = init with *local);\n+            ret @rec(node=ast.decl_local(local_1)\n+                     with *decl);\n+        }\n+    }\n+}\n+\n fn check_stmt(&@fn_ctxt fcx, &@ast.stmt stmt) -> @ast.stmt {\n     alt (stmt.node) {\n         case (ast.stmt_decl(?decl)) {\n             alt (decl.node) {\n-                case (ast.decl_local(?local)) {\n-\n-                    auto local_ty;\n-                    alt (local.ty) {\n-                        case (none[@ast.ty]) {\n-                            // Auto slot. Assign a ty_var.\n-                            local_ty = next_ty_var(fcx.ccx);\n-                        }\n-\n-                        case (some[@ast.ty](?ast_ty)) {\n-                            local_ty = ast_ty_to_ty_crate(fcx.ccx, ast_ty);\n-                        }\n-                    }\n-                    fcx.locals.insert(local.id, local_ty);\n-\n-                    auto rhs_ty = local_ty;\n-                    auto init = local.init;\n-                    alt (local.init) {\n-                        case (some[@ast.expr](?expr)) {\n-                            auto expr_0 = check_expr(fcx, expr);\n-                            auto lty = plain_ty(ty.ty_local(local.id));\n-                            auto expr_1 = demand_expr(fcx, lty, expr_0);\n-                            init = some[@ast.expr](expr_1);\n-                        }\n-                        case (_) { /* fall through */  }\n-                    }\n-\n-                    auto local_1 = @rec(init = init with *local);\n-                    auto decl_1 = @rec(node=ast.decl_local(local_1)\n-                                       with *decl);\n+                case (ast.decl_local(_)) {\n+                    auto decl_1 = check_decl_local(fcx, decl);\n                     ret @fold.respan[ast.stmt_](stmt.span,\n                                                 ast.stmt_decl(decl_1));\n                 }"}]}