{"sha": "41563fd6128e94e1fe1ae4006e4e183dff1a645c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNTYzZmQ2MTI4ZTk0ZTFmZTFhZTQwMDZlNGUxODNkZmYxYTY0NWM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-04-07T09:31:50Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-04-07T09:31:50Z"}, "message": "Infer variants through type aliased enums", "tree": {"sha": "6de6740ca7f028b1e58ce107f414d7a4b67eb5ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6de6740ca7f028b1e58ce107f414d7a4b67eb5ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41563fd6128e94e1fe1ae4006e4e183dff1a645c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41563fd6128e94e1fe1ae4006e4e183dff1a645c", "html_url": "https://github.com/rust-lang/rust/commit/41563fd6128e94e1fe1ae4006e4e183dff1a645c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41563fd6128e94e1fe1ae4006e4e183dff1a645c/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6a1c9ca60c19bf3b02b302e21d9f9fd9bd8a466", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6a1c9ca60c19bf3b02b302e21d9f9fd9bd8a466", "html_url": "https://github.com/rust-lang/rust/commit/e6a1c9ca60c19bf3b02b302e21d9f9fd9bd8a466"}], "stats": {"total": 103, "additions": 70, "deletions": 33}, "files": [{"sha": "796f77ab0dea8da2dbc39fc55308be0fb0fe8266", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/41563fd6128e94e1fe1ae4006e4e183dff1a645c/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41563fd6128e94e1fe1ae4006e4e183dff1a645c/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=41563fd6128e94e1fe1ae4006e4e183dff1a645c", "patch": "@@ -484,36 +484,13 @@ impl<'a> InferenceContext<'a> {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n                 let substs = generics.type_params_subst(self.db);\n                 let ty = self.db.impl_self_ty(impl_id).substitute(&Interner, &substs);\n-                match unresolved {\n-                    None => {\n-                        let variant = ty_variant(&ty);\n-                        (ty, variant)\n-                    }\n-                    Some(1) => {\n-                        let segment = path.mod_path().segments().last().unwrap();\n-                        // this could be an enum variant or associated type\n-                        if let Some((AdtId::EnumId(enum_id), _)) = ty.as_adt() {\n-                            let enum_data = self.db.enum_data(enum_id);\n-                            if let Some(local_id) = enum_data.variant(segment) {\n-                                let variant = EnumVariantId { parent: enum_id, local_id };\n-                                return (ty, Some(variant.into()));\n-                            }\n-                        }\n-                        // FIXME potentially resolve assoc type\n-                        (self.err_ty(), None)\n-                    }\n-                    Some(_) => {\n-                        // FIXME diagnostic\n-                        (self.err_ty(), None)\n-                    }\n-                }\n+                self.resolve_variant_on_alias(ty, unresolved, path)\n             }\n             TypeNs::TypeAliasId(it) => {\n                 let ty = TyBuilder::def_ty(self.db, it.into())\n                     .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n                     .build();\n-                let variant = ty_variant(&ty);\n-                forbid_unresolved_segments((ty, variant), unresolved)\n+                self.resolve_variant_on_alias(ty, unresolved, path)\n             }\n             TypeNs::AdtSelfType(_) => {\n                 // FIXME this could happen in array size expressions, once we're checking them\n@@ -540,16 +517,43 @@ impl<'a> InferenceContext<'a> {\n                 (TyKind::Error.intern(&Interner), None)\n             }\n         }\n+    }\n \n-        fn ty_variant(ty: &Ty) -> Option<VariantId> {\n-            ty.as_adt().and_then(|(adt_id, _)| match adt_id {\n-                AdtId::StructId(s) => Some(VariantId::StructId(s)),\n-                AdtId::UnionId(u) => Some(VariantId::UnionId(u)),\n-                AdtId::EnumId(_) => {\n-                    // FIXME Error E0071, expected struct, variant or union type, found enum `Foo`\n-                    None\n+    fn resolve_variant_on_alias(\n+        &mut self,\n+        ty: Ty,\n+        unresolved: Option<usize>,\n+        path: &Path,\n+    ) -> (Ty, Option<VariantId>) {\n+        match unresolved {\n+            None => {\n+                let variant = ty.as_adt().and_then(|(adt_id, _)| match adt_id {\n+                    AdtId::StructId(s) => Some(VariantId::StructId(s)),\n+                    AdtId::UnionId(u) => Some(VariantId::UnionId(u)),\n+                    AdtId::EnumId(_) => {\n+                        // FIXME Error E0071, expected struct, variant or union type, found enum `Foo`\n+                        None\n+                    }\n+                });\n+                (ty, variant)\n+            }\n+            Some(1) => {\n+                let segment = path.mod_path().segments().last().unwrap();\n+                // this could be an enum variant or associated type\n+                if let Some((AdtId::EnumId(enum_id), _)) = ty.as_adt() {\n+                    let enum_data = self.db.enum_data(enum_id);\n+                    if let Some(local_id) = enum_data.variant(segment) {\n+                        let variant = EnumVariantId { parent: enum_id, local_id };\n+                        return (ty, Some(variant.into()));\n+                    }\n                 }\n-            })\n+                // FIXME potentially resolve assoc type\n+                (self.err_ty(), None)\n+            }\n+            Some(_) => {\n+                // FIXME diagnostic\n+                (self.err_ty(), None)\n+            }\n         }\n     }\n "}, {"sha": "84c5c05fd30158eeeda19970aab3d48398171e4d", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/41563fd6128e94e1fe1ae4006e4e183dff1a645c/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41563fd6128e94e1fe1ae4006e4e183dff1a645c/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=41563fd6128e94e1fe1ae4006e4e183dff1a645c", "patch": "@@ -2564,3 +2564,36 @@ fn f() {\n     \"#,\n     )\n }\n+\n+#[test]\n+fn infer_type_alias_variant() {\n+    check_infer(\n+        r#\"\n+type Qux = Foo;\n+enum Foo {\n+    Bar(i32),\n+    Baz { baz: f32 }\n+}\n+\n+fn f() {\n+    match Foo::Bar(3) {\n+        Qux::Bar(bar) => (),\n+        Qux::Baz { baz } => (),\n+    }\n+}\n+    \"#,\n+        expect![[r#\"\n+            72..166 '{     ...   } }': ()\n+            78..164 'match ...     }': ()\n+            84..92 'Foo::Bar': Bar(i32) -> Foo\n+            84..95 'Foo::Bar(3)': Foo\n+            93..94 '3': i32\n+            106..119 'Qux::Bar(bar)': Foo\n+            115..118 'bar': i32\n+            123..125 '()': ()\n+            135..151 'Qux::B... baz }': Foo\n+            146..149 'baz': f32\n+            155..157 '()': ()\n+        \"#]],\n+    )\n+}"}]}