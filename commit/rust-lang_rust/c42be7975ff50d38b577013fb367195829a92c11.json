{"sha": "c42be7975ff50d38b577013fb367195829a92c11", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0MmJlNzk3NWZmNTBkMzhiNTc3MDEzZmIzNjcxOTU4MjlhOTJjMTE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-07-23T16:23:13Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-07-23T16:28:33Z"}, "message": "Support repr(simd) on ADTs containing a single array field\n\nThis is the cg_clif half of rust PR 78863", "tree": {"sha": "06ae90dbab56db71faee689a6b6713bca8fe3418", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06ae90dbab56db71faee689a6b6713bca8fe3418"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c42be7975ff50d38b577013fb367195829a92c11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c42be7975ff50d38b577013fb367195829a92c11", "html_url": "https://github.com/rust-lang/rust/commit/c42be7975ff50d38b577013fb367195829a92c11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c42be7975ff50d38b577013fb367195829a92c11/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "356360836e128e1d1eb11caf6ff5186efb211960", "url": "https://api.github.com/repos/rust-lang/rust/commits/356360836e128e1d1eb11caf6ff5186efb211960", "html_url": "https://github.com/rust-lang/rust/commit/356360836e128e1d1eb11caf6ff5186efb211960"}], "stats": {"total": 105, "additions": 82, "deletions": 23}, "files": [{"sha": "a6983749a26abfec5f628871f3e1ec27c4ddfec3", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c42be7975ff50d38b577013fb367195829a92c11/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42be7975ff50d38b577013fb367195829a92c11/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=c42be7975ff50d38b577013fb367195829a92c11", "patch": "@@ -175,12 +175,11 @@ fn simd_for_each_lane<'tcx>(\n     assert_eq!(lane_count, ret_lane_count);\n \n     for lane_idx in 0..lane_count {\n-        let lane_idx = mir::Field::new(lane_idx.try_into().unwrap());\n-        let lane = val.value_field(fx, lane_idx).load_scalar(fx);\n+        let lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n \n         let res_lane = f(fx, lane_layout, ret_lane_layout, lane);\n \n-        ret.place_field(fx, lane_idx).write_cvalue(fx, res_lane);\n+        ret.place_lane(fx, lane_idx).write_cvalue(fx, res_lane);\n     }\n }\n \n@@ -206,14 +205,13 @@ fn simd_pair_for_each_lane<'tcx>(\n     let ret_lane_layout = fx.layout_of(ret_lane_ty);\n     assert_eq!(lane_count, ret_lane_count);\n \n-    for lane in 0..lane_count {\n-        let lane = mir::Field::new(lane.try_into().unwrap());\n-        let x_lane = x.value_field(fx, lane).load_scalar(fx);\n-        let y_lane = y.value_field(fx, lane).load_scalar(fx);\n+    for lane_idx in 0..lane_count {\n+        let x_lane = x.value_lane(fx, lane_idx).load_scalar(fx);\n+        let y_lane = y.value_lane(fx, lane_idx).load_scalar(fx);\n \n         let res_lane = f(fx, lane_layout, ret_lane_layout, x_lane, y_lane);\n \n-        ret.place_field(fx, lane).write_cvalue(fx, res_lane);\n+        ret.place_lane(fx, lane_idx).write_cvalue(fx, res_lane);\n     }\n }\n \n@@ -227,10 +225,9 @@ fn simd_reduce<'tcx>(\n     let lane_layout = fx.layout_of(lane_ty);\n     assert_eq!(lane_layout, ret.layout());\n \n-    let mut res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n+    let mut res_val = val.value_lane(fx, 0).load_scalar(fx);\n     for lane_idx in 1..lane_count {\n-        let lane =\n-            val.value_field(fx, mir::Field::new(lane_idx.try_into().unwrap())).load_scalar(fx);\n+        let lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n         res_val = f(fx, lane_layout, res_val, lane);\n     }\n     let res = CValue::by_val(res_val, lane_layout);\n@@ -246,11 +243,10 @@ fn simd_reduce_bool<'tcx>(\n     let (lane_count, _lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     assert!(ret.layout().ty.is_bool());\n \n-    let res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n+    let res_val = val.value_lane(fx, 0).load_scalar(fx);\n     let mut res_val = fx.bcx.ins().band_imm(res_val, 1); // mask to boolean\n     for lane_idx in 1..lane_count {\n-        let lane =\n-            val.value_field(fx, mir::Field::new(lane_idx.try_into().unwrap())).load_scalar(fx);\n+        let lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n         let lane = fx.bcx.ins().band_imm(lane, 1); // mask to boolean\n         res_val = f(fx, res_val, lane);\n     }"}, {"sha": "e952942de87776a8bc25d1e24e3f57dfc858698e", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c42be7975ff50d38b577013fb367195829a92c11/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42be7975ff50d38b577013fb367195829a92c11/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=c42be7975ff50d38b577013fb367195829a92c11", "patch": "@@ -108,11 +108,11 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n \n             for (out_idx, in_idx) in indexes.into_iter().enumerate() {\n                 let in_lane = if u64::from(in_idx) < lane_count {\n-                    x.value_field(fx, mir::Field::new(in_idx.into()))\n+                    x.value_lane(fx, in_idx.into())\n                 } else {\n-                    y.value_field(fx, mir::Field::new(usize::from(in_idx) - usize::try_from(lane_count).unwrap()))\n+                    y.value_lane(fx, u64::from(in_idx) - lane_count)\n                 };\n-                let out_lane = ret.place_field(fx, mir::Field::new(out_idx));\n+                let out_lane = ret.place_lane(fx, u64::try_from(out_idx).unwrap());\n                 out_lane.write_cvalue(fx, in_lane);\n             }\n         };\n@@ -163,7 +163,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count));\n             }\n \n-            let ret_lane = v.value_field(fx, mir::Field::new(idx.try_into().unwrap()));\n+            let ret_lane = v.value_lane(fx, idx.try_into().unwrap());\n             ret.write_cvalue(fx, ret_lane);\n         };\n \n@@ -216,15 +216,14 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             let ret_lane_layout = fx.layout_of(ret_lane_ty);\n \n             for lane in 0..lane_count {\n-                let lane = mir::Field::new(lane.try_into().unwrap());\n-                let a_lane = a.value_field(fx, lane).load_scalar(fx);\n-                let b_lane = b.value_field(fx, lane).load_scalar(fx);\n-                let c_lane = c.value_field(fx, lane).load_scalar(fx);\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+                let b_lane = b.value_lane(fx, lane).load_scalar(fx);\n+                let c_lane = c.value_lane(fx, lane).load_scalar(fx);\n \n                 let mul_lane = fx.bcx.ins().fmul(a_lane, b_lane);\n                 let res_lane = CValue::by_val(fx.bcx.ins().fadd(mul_lane, c_lane), ret_lane_layout);\n \n-                ret.place_field(fx, lane).write_cvalue(fx, res_lane);\n+                ret.place_lane(fx, lane).write_cvalue(fx, res_lane);\n             }\n         };\n "}, {"sha": "b1e00360d566ab5c5868bf23d8ec4267288d8591", "filename": "src/value_and_place.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c42be7975ff50d38b577013fb367195829a92c11/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42be7975ff50d38b577013fb367195829a92c11/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=c42be7975ff50d38b577013fb367195829a92c11", "patch": "@@ -206,6 +206,38 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n+    /// Like [`CValue::value_field`] except handling ADTs containing a single array field in a way\n+    /// such that you can access individual lanes.\n+    pub(crate) fn value_lane(\n+        self,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n+        lane_idx: u64,\n+    ) -> CValue<'tcx> {\n+        let layout = self.1;\n+        assert!(layout.ty.is_simd());\n+        let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+        let lane_layout = fx.layout_of(lane_ty);\n+        assert!(lane_idx < lane_count);\n+        match self.0 {\n+            CValueInner::ByVal(val) => match layout.abi {\n+                Abi::Vector { element: _, count: _ } => {\n+                    assert!(lane_count <= u8::MAX.into(), \"SIMD type with more than 255 lanes???\");\n+                    let lane_idx = u8::try_from(lane_idx).unwrap();\n+                    let lane = fx.bcx.ins().extractlane(val, lane_idx);\n+                    CValue::by_val(lane, lane_layout)\n+                }\n+                _ => unreachable!(\"value_lane for ByVal with abi {:?}\", layout.abi),\n+            },\n+            CValueInner::ByValPair(_, _) => unreachable!(),\n+            CValueInner::ByRef(ptr, None) => {\n+                let field_offset = lane_layout.size * lane_idx;\n+                let field_ptr = ptr.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap());\n+                CValue::by_ref(field_ptr, lane_layout)\n+            }\n+            CValueInner::ByRef(_, Some(_)) => unreachable!(),\n+        }\n+    }\n+\n     pub(crate) fn unsize_value(self, fx: &mut FunctionCx<'_, '_, 'tcx>, dest: CPlace<'tcx>) {\n         crate::unsize::coerce_unsized_into(fx, self, dest);\n     }\n@@ -610,6 +642,38 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n+    /// Like [`CPlace::place_field`] except handling ADTs containing a single array field in a way\n+    /// such that you can access individual lanes.\n+    pub(crate) fn place_lane(\n+        self,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n+        lane_idx: u64,\n+    ) -> CPlace<'tcx> {\n+        let layout = self.layout();\n+        assert!(layout.ty.is_simd());\n+        let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+        let lane_layout = fx.layout_of(lane_ty);\n+        assert!(lane_idx < lane_count);\n+\n+        match self.inner {\n+            CPlaceInner::Var(local, var) => {\n+                assert!(matches!(layout.abi, Abi::Vector { .. }));\n+                CPlace {\n+                    inner: CPlaceInner::VarLane(local, var, lane_idx.try_into().unwrap()),\n+                    layout: lane_layout,\n+                }\n+            }\n+            CPlaceInner::VarPair(_, _, _) => unreachable!(),\n+            CPlaceInner::VarLane(_, _, _) => unreachable!(),\n+            CPlaceInner::Addr(ptr, None) => {\n+                let field_offset = lane_layout.size * lane_idx;\n+                let field_ptr = ptr.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap());\n+                CPlace::for_ptr(field_ptr, lane_layout)\n+            }\n+            CPlaceInner::Addr(_, Some(_)) => unreachable!(),\n+        }\n+    }\n+\n     pub(crate) fn place_index(\n         self,\n         fx: &mut FunctionCx<'_, '_, 'tcx>,"}]}