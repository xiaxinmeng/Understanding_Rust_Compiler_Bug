{"sha": "ca1389ef9f535729d834d198c09805fc9a386d20", "node_id": "C_kwDOAAsO6NoAKGNhMTM4OWVmOWY1MzU3MjlkODM0ZDE5OGMwOTgwNWZjOWEzODZkMjA", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-12-04T19:12:11Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-12-04T19:37:17Z"}, "message": "Support `rustc_has_incoherent_inherent_impls`", "tree": {"sha": "60d2ccddc688de6ad718f09c50f2a06aa565cfb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60d2ccddc688de6ad718f09c50f2a06aa565cfb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca1389ef9f535729d834d198c09805fc9a386d20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca1389ef9f535729d834d198c09805fc9a386d20", "html_url": "https://github.com/rust-lang/rust/commit/ca1389ef9f535729d834d198c09805fc9a386d20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca1389ef9f535729d834d198c09805fc9a386d20/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "957b4bb2164e57a58d7e6cb5b4915b298dab9391", "url": "https://api.github.com/repos/rust-lang/rust/commits/957b4bb2164e57a58d7e6cb5b4915b298dab9391", "html_url": "https://github.com/rust-lang/rust/commit/957b4bb2164e57a58d7e6cb5b4915b298dab9391"}], "stats": {"total": 190, "additions": 153, "deletions": 37}, "files": [{"sha": "e5ab7bf3f6d2f643633aa72db33ab00b2750d047", "filename": "crates/hir-def/src/adt.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ca1389ef9f535729d834d198c09805fc9a386d20/crates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1389ef9f535729d834d198c09805fc9a386d20/crates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fadt.rs?ref=ca1389ef9f535729d834d198c09805fc9a386d20", "patch": "@@ -36,6 +36,7 @@ pub struct StructData {\n     pub variant_data: Arc<VariantData>,\n     pub repr: Option<ReprData>,\n     pub visibility: RawVisibility,\n+    pub rustc_has_incoherent_inherent_impls: bool,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -44,6 +45,7 @@ pub struct EnumData {\n     pub variants: Arena<EnumVariantData>,\n     pub repr: Option<ReprData>,\n     pub visibility: RawVisibility,\n+    pub rustc_has_incoherent_inherent_impls: bool,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -157,6 +159,10 @@ impl StructData {\n         let item_tree = loc.id.item_tree(db);\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n+        let rustc_has_incoherent_inherent_impls = item_tree\n+            .attrs(db, loc.container.krate, ModItem::from(loc.id.value).into())\n+            .by_key(\"rustc_has_incoherent_inherent_impls\")\n+            .exists();\n \n         let strukt = &item_tree[loc.id.value];\n         let (variant_data, diagnostics) = lower_fields(\n@@ -175,6 +181,7 @@ impl StructData {\n                 variant_data: Arc::new(variant_data),\n                 repr,\n                 visibility: item_tree[strukt.visibility].clone(),\n+                rustc_has_incoherent_inherent_impls,\n             }),\n             diagnostics.into(),\n         )\n@@ -194,6 +201,11 @@ impl StructData {\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n \n+        let rustc_has_incoherent_inherent_impls = item_tree\n+            .attrs(db, loc.container.krate, ModItem::from(loc.id.value).into())\n+            .by_key(\"rustc_has_incoherent_inherent_impls\")\n+            .exists();\n+\n         let union = &item_tree[loc.id.value];\n         let (variant_data, diagnostics) = lower_fields(\n             db,\n@@ -211,6 +223,7 @@ impl StructData {\n                 variant_data: Arc::new(variant_data),\n                 repr,\n                 visibility: item_tree[union.visibility].clone(),\n+                rustc_has_incoherent_inherent_impls,\n             }),\n             diagnostics.into(),\n         )\n@@ -231,6 +244,10 @@ impl EnumData {\n         let item_tree = loc.id.item_tree(db);\n         let cfg_options = db.crate_graph()[krate].cfg_options.clone();\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n+        let rustc_has_incoherent_inherent_impls = item_tree\n+            .attrs(db, loc.container.krate, ModItem::from(loc.id.value).into())\n+            .by_key(\"rustc_has_incoherent_inherent_impls\")\n+            .exists();\n \n         let enum_ = &item_tree[loc.id.value];\n         let mut variants = Arena::new();\n@@ -271,6 +288,7 @@ impl EnumData {\n                 variants,\n                 repr,\n                 visibility: item_tree[enum_.visibility].clone(),\n+                rustc_has_incoherent_inherent_impls,\n             }),\n             diagnostics.into(),\n         )"}, {"sha": "0e7acda4a757dcccb851e9b303635f483f82f9ce", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ca1389ef9f535729d834d198c09805fc9a386d20/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1389ef9f535729d834d198c09805fc9a386d20/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=ca1389ef9f535729d834d198c09805fc9a386d20", "patch": "@@ -168,6 +168,7 @@ pub struct TypeAliasData {\n     pub type_ref: Option<Interned<TypeRef>>,\n     pub visibility: RawVisibility,\n     pub is_extern: bool,\n+    pub rustc_has_incoherent_inherent_impls: bool,\n     /// Bounds restricting the type alias itself (eg. `type Ty: Bound;` in a trait or impl).\n     pub bounds: Vec<Interned<TypeBound>>,\n }\n@@ -186,11 +187,17 @@ impl TypeAliasData {\n             item_tree[typ.visibility].clone()\n         };\n \n+        let rustc_has_incoherent_inherent_impls = item_tree\n+            .attrs(db, loc.container.module(db).krate(), ModItem::from(loc.id.value).into())\n+            .by_key(\"rustc_has_incoherent_inherent_impls\")\n+            .exists();\n+\n         Arc::new(TypeAliasData {\n             name: typ.name.clone(),\n             type_ref: typ.type_ref.clone(),\n             visibility,\n             is_extern: matches!(loc.container, ItemContainerId::ExternBlockId(_)),\n+            rustc_has_incoherent_inherent_impls,\n             bounds: typ.bounds.to_vec(),\n         })\n     }\n@@ -202,6 +209,7 @@ pub struct TraitData {\n     pub items: Vec<(Name, AssocItemId)>,\n     pub is_auto: bool,\n     pub is_unsafe: bool,\n+    pub rustc_has_incoherent_inherent_impls: bool,\n     pub visibility: RawVisibility,\n     /// Whether the trait has `#[rust_skip_array_during_method_dispatch]`. `hir_ty` will ignore\n     /// method calls to this trait's methods when the receiver is an array and the crate edition is\n@@ -231,11 +239,11 @@ impl TraitData {\n         let is_auto = tr_def.is_auto;\n         let is_unsafe = tr_def.is_unsafe;\n         let visibility = item_tree[tr_def.visibility].clone();\n-        let skip_array_during_method_dispatch = item_tree\n-            .attrs(db, module_id.krate(), ModItem::from(tree_id.value).into())\n-            .by_key(\"rustc_skip_array_during_method_dispatch\")\n-            .exists();\n-\n+        let attrs = item_tree.attrs(db, module_id.krate(), ModItem::from(tree_id.value).into());\n+        let skip_array_during_method_dispatch =\n+            attrs.by_key(\"rustc_skip_array_during_method_dispatch\").exists();\n+        let rustc_has_incoherent_inherent_impls =\n+            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n         let (items, attribute_calls, diagnostics) = match &tr_def.items {\n             Some(items) => {\n                 let mut collector = AssocItemCollector::new(\n@@ -258,6 +266,7 @@ impl TraitData {\n                 is_unsafe,\n                 visibility,\n                 skip_array_during_method_dispatch,\n+                rustc_has_incoherent_inherent_impls,\n             }),\n             diagnostics.into(),\n         )"}, {"sha": "ae6bf786cf5ba3b138cf9a569ca23d0aebede240", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ca1389ef9f535729d834d198c09805fc9a386d20/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1389ef9f535729d834d198c09805fc9a386d20/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=ca1389ef9f535729d834d198c09805fc9a386d20", "patch": "@@ -3,13 +3,13 @@\n \n use std::sync::Arc;\n \n-use arrayvec::ArrayVec;\n use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n     db::DefDatabase, expr::ExprId, BlockId, ConstId, ConstParamId, DefWithBodyId, EnumVariantId,\n     FunctionId, GenericDefId, ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n };\n use la_arena::ArenaMap;\n+use smallvec::SmallVec;\n \n use crate::{\n     chalk_db,\n@@ -92,10 +92,15 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn inherent_impls_in_block(&self, block: BlockId) -> Option<Arc<InherentImpls>>;\n \n     /// Collects all crates in the dependency graph that have impls for the\n-    /// given fingerprint. This is only used for primitive types; for\n-    /// user-defined types we just look at the crate where the type is defined.\n-    #[salsa::invoke(crate::method_resolution::inherent_impl_crates_query)]\n-    fn inherent_impl_crates(&self, krate: CrateId, fp: TyFingerprint) -> ArrayVec<CrateId, 2>;\n+    /// given fingerprint. This is only used for primitive types and types\n+    /// annotated with `rustc_has_incoherent_inherent_impls`; for other types\n+    /// we just look at the crate where the type is defined.\n+    #[salsa::invoke(crate::method_resolution::incoherent_inherent_impl_crates)]\n+    fn incoherent_inherent_impl_crates(\n+        &self,\n+        krate: CrateId,\n+        fp: TyFingerprint,\n+    ) -> SmallVec<[CrateId; 2]>;\n \n     #[salsa::invoke(TraitImpls::trait_impls_in_crate_query)]\n     fn trait_impls_in_crate(&self, krate: CrateId) -> Arc<TraitImpls>;"}, {"sha": "0d980699ff543d37920d1f4bbf5532d90cd3d918", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ca1389ef9f535729d834d198c09805fc9a386d20/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1389ef9f535729d834d198c09805fc9a386d20/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=ca1389ef9f535729d834d198c09805fc9a386d20", "patch": "@@ -2,18 +2,17 @@\n //! For details about how this works in rustc, see the method lookup page in the\n //! [rustc guide](https://rust-lang.github.io/rustc-guide/method-lookup.html)\n //! and the corresponding code mostly in rustc_hir_analysis/check/method/probe.rs.\n-use std::{iter, ops::ControlFlow, sync::Arc};\n+use std::{ops::ControlFlow, sync::Arc};\n \n-use arrayvec::ArrayVec;\n use base_db::{CrateId, Edition};\n use chalk_ir::{cast::Cast, Mutability, UniverseIndex};\n use hir_def::{\n     data::ImplData, item_scope::ItemScope, nameres::DefMap, AssocItemId, BlockId, ConstId,\n-    FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId, ModuleId,\n-    TraitId,\n+    FunctionId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId, ModuleId, TraitId,\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n+use smallvec::{smallvec, SmallVec};\n use stdx::never;\n \n use crate::{\n@@ -336,21 +335,18 @@ impl InherentImpls {\n     }\n }\n \n-pub(crate) fn inherent_impl_crates_query(\n+pub(crate) fn incoherent_inherent_impl_crates(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n     fp: TyFingerprint,\n-) -> ArrayVec<CrateId, 2> {\n+) -> SmallVec<[CrateId; 2]> {\n     let _p = profile::span(\"inherent_impl_crates_query\");\n-    let mut res = ArrayVec::new();\n+    let mut res = SmallVec::new();\n     let crate_graph = db.crate_graph();\n \n+    // should pass crate for finger print and do reverse deps\n+\n     for krate in crate_graph.transitive_deps(krate) {\n-        if res.is_full() {\n-            // we don't currently look for or store more than two crates here,\n-            // so don't needlessly look at more crates than necessary.\n-            break;\n-        }\n         let impls = db.inherent_impls_in_crate(krate);\n         if impls.map.get(&fp).map_or(false, |v| !v.is_empty()) {\n             res.push(krate);\n@@ -392,30 +388,52 @@ pub fn def_crates(\n     db: &dyn HirDatabase,\n     ty: &Ty,\n     cur_crate: CrateId,\n-) -> Option<ArrayVec<CrateId, 2>> {\n-    let mod_to_crate_ids = |module: ModuleId| Some(iter::once(module.krate()).collect());\n-\n-    let fp = TyFingerprint::for_inherent_impl(ty);\n-\n+) -> Option<SmallVec<[CrateId; 2]>> {\n     match ty.kind(Interner) {\n-        TyKind::Adt(AdtId(def_id), _) => mod_to_crate_ids(def_id.module(db.upcast())),\n-        TyKind::Foreign(id) => {\n-            mod_to_crate_ids(from_foreign_def_id(*id).lookup(db.upcast()).module(db.upcast()))\n+        &TyKind::Adt(AdtId(def_id), _) => {\n+            let rustc_has_incoherent_inherent_impls = match def_id {\n+                hir_def::AdtId::StructId(id) => {\n+                    db.struct_data(id).rustc_has_incoherent_inherent_impls\n+                }\n+                hir_def::AdtId::UnionId(id) => {\n+                    db.union_data(id).rustc_has_incoherent_inherent_impls\n+                }\n+                hir_def::AdtId::EnumId(id) => db.enum_data(id).rustc_has_incoherent_inherent_impls,\n+            };\n+            Some(if rustc_has_incoherent_inherent_impls {\n+                db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::Adt(def_id))\n+            } else {\n+                smallvec![def_id.module(db.upcast()).krate()]\n+            })\n+        }\n+        &TyKind::Foreign(id) => {\n+            let alias = from_foreign_def_id(id);\n+            Some(if db.type_alias_data(alias).rustc_has_incoherent_inherent_impls {\n+                db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::ForeignType(id))\n+            } else {\n+                smallvec![alias.module(db.upcast()).krate()]\n+            })\n+        }\n+        TyKind::Dyn(_) => {\n+            let trait_id = ty.dyn_trait()?;\n+            Some(if db.trait_data(trait_id).rustc_has_incoherent_inherent_impls {\n+                db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::Dyn(trait_id))\n+            } else {\n+                smallvec![trait_id.module(db.upcast()).krate()]\n+            })\n         }\n-        TyKind::Dyn(_) => ty\n-            .dyn_trait()\n-            .and_then(|trait_| mod_to_crate_ids(GenericDefId::TraitId(trait_).module(db.upcast()))),\n         // for primitives, there may be impls in various places (core and alloc\n         // mostly). We just check the whole crate graph for crates with impls\n         // (cached behind a query).\n         TyKind::Scalar(_)\n         | TyKind::Str\n         | TyKind::Slice(_)\n         | TyKind::Array(..)\n-        | TyKind::Raw(..) => {\n-            Some(db.inherent_impl_crates(cur_crate, fp.expect(\"fingerprint for primitive\")))\n-        }\n-        _ => return None,\n+        | TyKind::Raw(..) => Some(db.incoherent_inherent_impl_crates(\n+            cur_crate,\n+            TyFingerprint::for_inherent_impl(ty).expect(\"fingerprint for primitive\"),\n+        )),\n+        _ => None,\n     }\n }\n "}, {"sha": "b6958c362c7aa0c934a55bd3ef5f553682b701ce", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ca1389ef9f535729d834d198c09805fc9a386d20/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1389ef9f535729d834d198c09805fc9a386d20/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=ca1389ef9f535729d834d198c09805fc9a386d20", "patch": "@@ -1867,3 +1867,32 @@ fn g<T: Trait>(a: T) {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn incoherent_impls() {\n+    check(\n+        r#\"\n+//- minicore: error, send\n+pub struct Box<T>(T);\n+use core::error::Error;\n+\n+#[rustc_allow_incoherent_impl]\n+impl dyn Error {\n+    pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error>> {\n+        loop {}\n+    }\n+}\n+#[rustc_allow_incoherent_impl]\n+impl dyn Error + Send {\n+    /// Attempts to downcast the box to a concrete type.\n+    pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error + Send>> {\n+        let err: Box<dyn Error> = self;\n+                               // ^^^^ expected Box<dyn Error>, got Box<dyn Error + Send>\n+                               // FIXME, type mismatch should not occur\n+        <dyn Error>::downcast(err).map_err(|_| loop {})\n+      //^^^^^^^^^^^^^^^^^^^^^ type: fn downcast<{unknown}>(Box<dyn Error>) -> Result<Box<{unknown}>, Box<dyn Error>>\n+    }\n+}\n+\"#,\n+    );\n+}"}, {"sha": "40a330a6bd1ece4a38b70f248cd3b8b6251b76fc", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ca1389ef9f535729d834d198c09805fc9a386d20/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1389ef9f535729d834d198c09805fc9a386d20/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=ca1389ef9f535729d834d198c09805fc9a386d20", "patch": "@@ -20,6 +20,7 @@\n //!     derive:\n //!     drop:\n //!     eq: sized\n+//!     error: fmt\n //!     fmt: result\n //!     fn:\n //!     from: sized\n@@ -34,8 +35,10 @@\n //!     pin:\n //!     range:\n //!     result:\n+//!     send: sized\n //!     sized:\n //!     slice:\n+//!     sync: sized\n //!     try:\n //!     unsize: sized\n \n@@ -47,6 +50,24 @@ pub mod marker {\n     pub trait Sized {}\n     // endregion:sized\n \n+    // region:send\n+    pub unsafe auto trait Send {}\n+\n+    impl<T: ?Sized> !Send for *const T {}\n+    impl<T: ?Sized> !Send for *mut T {}\n+    // region:sync\n+    unsafe impl<T: Sync + ?Sized> Send for &T {}\n+    unsafe impl<T: Send + ?Sized> Send for &mut T {}\n+    // endregion:sync\n+    // endregion:send\n+\n+    // region:sync\n+    pub unsafe auto trait Sync {}\n+\n+    impl<T: ?Sized> !Sync for *const T {}\n+    impl<T: ?Sized> !Sync for *mut T {}\n+    // endregion:sync\n+\n     // region:unsize\n     #[lang = \"unsize\"]\n     pub trait Unsize<T: ?Sized> {}\n@@ -438,6 +459,9 @@ pub mod fmt {\n     pub trait Debug {\n         fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n     }\n+    pub trait Display {\n+        fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n+    }\n }\n // endregion:fmt\n \n@@ -693,6 +717,17 @@ impl bool {\n }\n // endregion:bool_impl\n \n+// region:error\n+pub mod error {\n+    #[rustc_has_incoherent_inherent_impls]\n+    pub trait Error: crate::fmt::Debug + crate::fmt::Display {\n+        fn source(&self) -> Option<&(dyn Error + 'static)> {\n+            None\n+        }\n+    }\n+}\n+// endregion:error\n+\n pub mod prelude {\n     pub mod v1 {\n         pub use crate::{\n@@ -705,7 +740,9 @@ pub mod prelude {\n             iter::{IntoIterator, Iterator},     // :iterator\n             macros::builtin::derive,            // :derive\n             marker::Copy,                       // :copy\n+            marker::Send,                       // :send\n             marker::Sized,                      // :sized\n+            marker::Sync,                       // :sync\n             mem::drop,                          // :drop\n             ops::Drop,                          // :drop\n             ops::{Fn, FnMut, FnOnce},           // :fn"}]}