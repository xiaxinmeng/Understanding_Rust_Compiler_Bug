{"sha": "f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYjdjZDk5MjU0ZGQxMWZmNzM3MGZlNDIzY2NhNmZkODA0NmY3ZDI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-10-05T01:22:23Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:33Z"}, "message": "rustc_trans: restrict \"immediate pairs\" to pairs of scalars.", "tree": {"sha": "675199b5b8fe53c8038c33ae611f4dcf913e7b44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/675199b5b8fe53c8038c33ae611f4dcf913e7b44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "html_url": "https://github.com/rust-lang/rust/commit/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac60872077608c4382aab39495e15c9f226630dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac60872077608c4382aab39495e15c9f226630dd", "html_url": "https://github.com/rust-lang/rust/commit/ac60872077608c4382aab39495e15c9f226630dd"}], "stats": {"total": 190, "additions": 84, "deletions": 106}, "files": [{"sha": "03ae58fd941f170f706fc3689f80b4b620f5f93f", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "patch": "@@ -28,7 +28,7 @@ use type_of::LayoutLlvmExt;\n use value::Value;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{self, HasDataLayout, LayoutOf};\n+use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::hir;\n \n@@ -54,25 +54,6 @@ pub fn type_is_fat_ptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) ->\n     }\n }\n \n-/// Returns true if the type is represented as a pair of immediates.\n-pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n-                                  -> bool {\n-    let layout = ccx.layout_of(ty);\n-    match layout.fields {\n-        layout::FieldPlacement::Arbitrary { .. } => {\n-            // There must be only 2 fields.\n-            if layout.fields.count() != 2 {\n-                return false;\n-            }\n-\n-            // The two fields must be both immediates.\n-            layout.field(ccx, 0).is_llvm_immediate() &&\n-            layout.field(ccx, 1).is_llvm_immediate()\n-        }\n-        _ => false\n-    }\n-}\n-\n pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.needs_drop(tcx, ty::ParamEnv::empty(traits::Reveal::All))\n }"}, {"sha": "7d08090cd7e7c98a4dcb976a4f91bcbb84d35da9", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "patch": "@@ -675,10 +675,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let ptr = bcx.pointercast(llresult, ty.llvm_type(ccx).ptr_to());\n             bcx.store(llval, ptr, Some(ccx.align_of(ret_ty)));\n         } else {\n-            OperandRef {\n-                val: OperandValue::Immediate(llval),\n-                layout: result.layout\n-            }.unpack_if_pair(bcx).val.store(bcx, result);\n+            OperandRef::from_immediate_or_packed_pair(bcx, llval, result.layout)\n+                .val.store(bcx, result);\n         }\n     }\n }"}, {"sha": "bf822249a64a08a114def78c0041a2cc088fd938", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "patch": "@@ -19,7 +19,6 @@ use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir::traversal;\n use rustc::ty;\n use rustc::ty::layout::LayoutOf;\n-use common;\n use type_of::LayoutLlvmExt;\n use super::MirContext;\n \n@@ -32,10 +31,11 @@ pub fn lvalue_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n     for (index, ty) in mir.local_decls.iter().map(|l| l.ty).enumerate() {\n         let ty = mircx.monomorphize(&ty);\n         debug!(\"local {} has type {:?}\", index, ty);\n-        if mircx.ccx.layout_of(ty).is_llvm_immediate() {\n+        let layout = mircx.ccx.layout_of(ty);\n+        if layout.is_llvm_immediate() {\n             // These sorts of types are immediates that we can store\n             // in an ValueRef without an alloca.\n-        } else if common::type_is_imm_pair(mircx.ccx, ty) {\n+        } else if layout.is_llvm_scalar_pair(mircx.ccx) {\n             // We allow pairs and uses of any of their 2 fields.\n         } else {\n             // These sorts of types require an alloca. Note that\n@@ -145,7 +145,8 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                         let ty = proj.base.ty(self.cx.mir, self.cx.ccx.tcx());\n \n                         let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n-                        if common::type_is_imm_pair(self.cx.ccx, ty) {\n+                        let layout = self.cx.ccx.layout_of(ty);\n+                        if layout.is_llvm_scalar_pair(self.cx.ccx) {\n                             return;\n                         }\n                     }"}, {"sha": "e739037b07d7f45f979d22a39c48db6917fe7ecf", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "patch": "@@ -135,11 +135,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 if let Some((ret_dest, target)) = destination {\n                     let ret_bcx = this.get_builder(target);\n                     this.set_debug_loc(&ret_bcx, terminator.source_info);\n-                    let op = OperandRef {\n-                        val: Immediate(invokeret),\n-                        layout: fn_ty.ret.layout,\n-                    };\n-                    this.store_return(&ret_bcx, ret_dest, &fn_ty.ret, op);\n+                    this.store_return(&ret_bcx, ret_dest, &fn_ty.ret, invokeret);\n                 }\n             } else {\n                 let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle);\n@@ -153,11 +149,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n \n                 if let Some((ret_dest, target)) = destination {\n-                    let op = OperandRef {\n-                        val: Immediate(llret),\n-                        layout: fn_ty.ret.layout,\n-                    };\n-                    this.store_return(&bcx, ret_dest, &fn_ty.ret, op);\n+                    this.store_return(&bcx, ret_dest, &fn_ty.ret, llret);\n                     funclet_br(this, bcx, target);\n                 } else {\n                     bcx.unreachable();\n@@ -252,7 +244,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     if let Ref(llval, align) = op.val {\n                         bcx.load(llval, align.non_abi())\n                     } else {\n-                        op.pack_if_pair(&bcx).immediate()\n+                        op.immediate_or_packed_pair(&bcx)\n                     }\n                 };\n                 bcx.ret(llval);\n@@ -545,12 +537,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                          terminator.source_info.span);\n \n                     if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n-                        // Make a fake operand for store_return\n-                        let op = OperandRef {\n-                            val: Ref(dst.llval, Alignment::AbiAligned),\n-                            layout: fn_ty.ret.layout,\n-                        };\n-                        self.store_return(&bcx, ret_dest, &fn_ty.ret, op);\n+                        self.store_return(&bcx, ret_dest, &fn_ty.ret, dst.llval);\n                     }\n \n                     if let Some((_, target)) = *destination {\n@@ -649,7 +636,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     op.val.store(bcx, scratch);\n                     (scratch.llval, Alignment::AbiAligned, true)\n                 } else {\n-                    (op.pack_if_pair(bcx).immediate(), Alignment::AbiAligned, false)\n+                    (op.immediate_or_packed_pair(bcx), Alignment::AbiAligned, false)\n                 }\n             }\n             Ref(llval, align @ Alignment::Packed(_)) if arg.is_indirect() => {\n@@ -915,12 +902,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     bcx: &Builder<'a, 'tcx>,\n                     dest: ReturnDest<'tcx>,\n                     ret_ty: &ArgType<'tcx>,\n-                    op: OperandRef<'tcx>) {\n+                    llval: ValueRef) {\n         use self::ReturnDest::*;\n \n         match dest {\n             Nothing => (),\n-            Store(dst) => ret_ty.store(bcx, op.immediate(), dst),\n+            Store(dst) => ret_ty.store(bcx, llval, dst),\n             IndirectOperand(tmp, index) => {\n                 let op = tmp.load(bcx);\n                 tmp.storage_dead(bcx);\n@@ -929,14 +916,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n                 let op = if ret_ty.cast.is_some() {\n-                    let tmp = LvalueRef::alloca(bcx, op.layout, \"tmp_ret\");\n+                    let tmp = LvalueRef::alloca(bcx, ret_ty.layout, \"tmp_ret\");\n                     tmp.storage_live(bcx);\n-                    ret_ty.store(bcx, op.immediate(), tmp);\n+                    ret_ty.store(bcx, llval, tmp);\n                     let op = tmp.load(bcx);\n                     tmp.storage_dead(bcx);\n                     op\n                 } else {\n-                    op.unpack_if_pair(bcx)\n+                    OperandRef::from_immediate_or_packed_pair(bcx, llval, ret_ty.layout)\n                 };\n                 self.locals[index] = LocalRef::Operand(Some(op));\n             }"}, {"sha": "3196300a706de8a0449c5c1df8aff428e2b15d92", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "patch": "@@ -139,13 +139,14 @@ impl<'a, 'tcx> Const<'tcx> {\n     }\n \n     pub fn to_operand(&self, ccx: &CrateContext<'a, 'tcx>) -> OperandRef<'tcx> {\n-        let llty = ccx.layout_of(self.ty).immediate_llvm_type(ccx);\n+        let layout = ccx.layout_of(self.ty);\n+        let llty = layout.immediate_llvm_type(ccx);\n         let llvalty = val_ty(self.llval);\n \n-        let val = if llty == llvalty && common::type_is_imm_pair(ccx, self.ty) {\n+        let val = if llty == llvalty && layout.is_llvm_scalar_pair(ccx) {\n             let (a, b) = self.get_pair(ccx);\n             OperandValue::Pair(a, b)\n-        } else if llty == llvalty && ccx.layout_of(self.ty).is_llvm_immediate() {\n+        } else if llty == llvalty && layout.is_llvm_immediate() {\n             // If the types match, we can use the value directly.\n             OperandValue::Immediate(self.llval)\n         } else {"}, {"sha": "8340d865eb1e225841eb912af27384564a69e10b", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "patch": "@@ -16,7 +16,7 @@ use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n use base;\n use builder::Builder;\n-use common::{self, CrateContext, C_usize, C_u8, C_u32, C_uint, C_int, C_null, C_uint_big};\n+use common::{CrateContext, C_usize, C_u8, C_u32, C_uint, C_int, C_null, C_uint_big};\n use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n@@ -175,10 +175,10 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 load\n             };\n             OperandValue::Immediate(base::to_immediate(bcx, llval, self.layout))\n-        } else if common::type_is_imm_pair(bcx.ccx, self.layout.ty) {\n+        } else if self.layout.is_llvm_scalar_pair(bcx.ccx) {\n             OperandValue::Pair(\n-                self.project_field(bcx, 0).load(bcx).pack_if_pair(bcx).immediate(),\n-                self.project_field(bcx, 1).load(bcx).pack_if_pair(bcx).immediate())\n+                self.project_field(bcx, 0).load(bcx).immediate(),\n+                self.project_field(bcx, 1).load(bcx).immediate())\n         } else {\n             OperandValue::Ref(self.llval, self.alignment)\n         };"}, {"sha": "6f9d32b1a37d635653a1d496a1023a3813e9da86", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "patch": "@@ -475,11 +475,9 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n             bcx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n-            let operand = OperandRef {\n-                val: OperandValue::Immediate(llarg),\n-                layout: arg.layout\n-            };\n-            return LocalRef::Operand(Some(operand.unpack_if_pair(bcx)));\n+            return LocalRef::Operand(Some(\n+                OperandRef::from_immediate_or_packed_pair(bcx, llarg, arg.layout)\n+            ));\n         } else {\n             let tmp = LvalueRef::alloca(bcx, arg.layout, &name);\n             arg.store_fn_arg(bcx, &mut llarg_idx, tmp);"}, {"sha": "3e7aa9d0db5bf9b8ef808b85f1aeb65824694005", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 35, "deletions": 41, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "patch": "@@ -15,7 +15,7 @@ use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n-use common::{self, CrateContext, C_undef};\n+use common::{CrateContext, C_undef};\n use builder::Builder;\n use value::Value;\n use type_of::LayoutLlvmExt;\n@@ -24,7 +24,6 @@ use std::fmt;\n use std::ptr;\n \n use super::{MirContext, LocalRef};\n-use super::constant::Const;\n use super::lvalue::{Alignment, LvalueRef};\n \n /// The representation of a Rust value. The enum variant is in fact\n@@ -84,10 +83,10 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     pub fn new_zst(ccx: &CrateContext<'a, 'tcx>,\n                    layout: TyLayout<'tcx>) -> OperandRef<'tcx> {\n         assert!(layout.is_zst());\n-        let llty = layout.llvm_type(ccx);\n-        // FIXME(eddyb) ZSTs should always be immediate, not pairs.\n-        // This hack only exists to unpack a constant undef pair.\n-        Const::new(C_undef(llty), layout.ty).to_operand(ccx)\n+        OperandRef {\n+            val: OperandValue::Immediate(C_undef(layout.llvm_type(ccx))),\n+            layout\n+        }\n     }\n \n     /// Asserts that this operand refers to a scalar and returns\n@@ -115,42 +114,47 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         }\n     }\n \n-    /// If this operand is a Pair, we return an\n-    /// Immediate aggregate with the two values.\n-    pub fn pack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n+    /// If this operand is a `Pair`, we return an aggregate with the two values.\n+    /// For other cases, see `immediate`.\n+    pub fn immediate_or_packed_pair(self, bcx: &Builder<'a, 'tcx>) -> ValueRef {\n         if let OperandValue::Pair(a, b) = self.val {\n             let llty = self.layout.llvm_type(bcx.ccx);\n-            debug!(\"Operand::pack_if_pair: packing {:?} into {:?}\", self, llty);\n+            debug!(\"Operand::immediate_or_packed_pair: packing {:?} into {:?}\",\n+                   self, llty);\n             // Reconstruct the immediate aggregate.\n             let mut llpair = C_undef(llty);\n             let elems = [a, b];\n             for i in 0..2 {\n                 let elem = base::from_immediate(bcx, elems[i]);\n                 llpair = bcx.insert_value(llpair, elem, self.layout.llvm_field_index(i));\n             }\n-            self.val = OperandValue::Immediate(llpair);\n+            llpair\n+        } else {\n+            self.immediate()\n         }\n-        self\n     }\n \n-    /// If this operand is a pair in an Immediate,\n-    /// we return a Pair with the two halves.\n-    pub fn unpack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n-        if let OperandValue::Immediate(llval) = self.val {\n-            // Deconstruct the immediate aggregate.\n-            if common::type_is_imm_pair(bcx.ccx, self.layout.ty) {\n-                debug!(\"Operand::unpack_if_pair: unpacking {:?}\", self);\n+    /// If the type is a pair, we return a `Pair`, otherwise, an `Immediate`.\n+    pub fn from_immediate_or_packed_pair(bcx: &Builder<'a, 'tcx>,\n+                                         llval: ValueRef,\n+                                         layout: TyLayout<'tcx>)\n+                                         -> OperandRef<'tcx> {\n+        let val = if layout.is_llvm_scalar_pair(bcx.ccx) {\n+            debug!(\"Operand::from_immediate_or_packed_pair: unpacking {:?} @ {:?}\",\n+                    llval, layout);\n \n-                let a = bcx.extract_value(llval, self.layout.llvm_field_index(0));\n-                let a = base::to_immediate(bcx, a, self.layout.field(bcx.ccx, 0));\n+            // Deconstruct the immediate aggregate.\n+            let a = bcx.extract_value(llval, layout.llvm_field_index(0));\n+            let a = base::to_immediate(bcx, a, layout.field(bcx.ccx, 0));\n \n-                let b = bcx.extract_value(llval, self.layout.llvm_field_index(1));\n-                let b = base::to_immediate(bcx, b, self.layout.field(bcx.ccx, 1));\n+            let b = bcx.extract_value(llval, layout.llvm_field_index(1));\n+            let b = base::to_immediate(bcx, b, layout.field(bcx.ccx, 1));\n \n-                self.val = OperandValue::Pair(a, b);\n-            }\n-        }\n-        self\n+            OperandValue::Pair(a, b)\n+        } else {\n+            OperandValue::Immediate(llval)\n+        };\n+        OperandRef { val, layout }\n     }\n }\n \n@@ -170,16 +174,9 @@ impl<'a, 'tcx> OperandValue {\n                 bcx.store(base::from_immediate(bcx, s), dest.llval, dest.alignment.non_abi());\n             }\n             OperandValue::Pair(a, b) => {\n-                // See comment above about zero-sized values.\n-                let dest_a = dest.project_field(bcx, 0);\n-                if !dest_a.layout.is_zst() {\n-                    let a = base::from_immediate(bcx, a);\n-                    bcx.store(a, dest_a.llval, dest_a.alignment.non_abi());\n-                }\n-                let dest_b = dest.project_field(bcx, 1);\n-                if !dest_b.layout.is_zst() {\n-                    let b = base::from_immediate(bcx, b);\n-                    bcx.store(b, dest_b.llval, dest_b.alignment.non_abi());\n+                for (i, &x) in [a, b].iter().enumerate() {\n+                    OperandValue::Immediate(x)\n+                        .store(bcx, dest.project_field(bcx, i));\n                 }\n             }\n         }\n@@ -218,13 +215,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         (OperandValue::Pair(a, b),\n                          &mir::ProjectionElem::Field(ref f, ty)) => {\n                             let llval = [a, b][f.index()];\n-                            let op = OperandRef {\n+                            return OperandRef {\n                                 val: OperandValue::Immediate(llval),\n                                 layout: bcx.ccx.layout_of(self.monomorphize(&ty))\n                             };\n-\n-                            // Handle nested pairs.\n-                            return op.unpack_if_pair(bcx);\n                         }\n                         _ => {}\n                     }"}, {"sha": "33b1a7e3363fda2f1ced2a7746977de8ce4cbd96", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "patch": "@@ -70,9 +70,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // `CoerceUnsized` can be passed by a where-clause,\n                 // so the (generic) MIR may not be able to expand it.\n                 let operand = self.trans_operand(&bcx, source);\n-                let operand = operand.pack_if_pair(&bcx);\n                 match operand.val {\n-                    OperandValue::Pair(..) => bug!(),\n+                    OperandValue::Pair(..) |\n                     OperandValue::Immediate(_) => {\n                         // unsize from an immediate structure. We don't\n                         // really need a temporary alloca here, but"}, {"sha": "6da6f1ebaf060f2a23d7708d1f45160aad6512aa", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "patch": "@@ -174,6 +174,7 @@ pub struct PointeeInfo {\n \n pub trait LayoutLlvmExt<'tcx> {\n     fn is_llvm_immediate(&self) -> bool;\n+    fn is_llvm_scalar_pair<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> bool;\n     fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n     fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n     fn over_align(&self) -> Option<Align>;\n@@ -192,6 +193,24 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n+    fn is_llvm_scalar_pair<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> bool {\n+        match self.fields {\n+            layout::FieldPlacement::Arbitrary { .. } => {\n+                // There must be only 2 fields.\n+                if self.fields.count() != 2 {\n+                    return false;\n+                }\n+\n+                // The two fields must be both scalars.\n+                match (&self.field(ccx, 0).abi, &self.field(ccx, 1).abi) {\n+                    (&layout::Abi::Scalar(_), &layout::Abi::Scalar(_)) => true,\n+                    _ => false\n+                }\n+            }\n+            _ => false\n+        }\n+    }\n+\n     /// Get the LLVM type corresponding to a Rust type, i.e. `rustc::ty::Ty`.\n     /// The pointee type of the pointer in `LvalueRef` is always this type.\n     /// For sized types, it is also the right LLVM type for an `alloca`"}]}