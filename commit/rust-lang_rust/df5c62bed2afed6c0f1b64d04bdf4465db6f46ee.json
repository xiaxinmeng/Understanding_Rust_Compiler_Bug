{"sha": "df5c62bed2afed6c0f1b64d04bdf4465db6f46ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNWM2MmJlZDJhZmVkNmMwZjFiNjRkMDRiZGY0NDY1ZGI2ZjQ2ZWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-15T10:10:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-17T20:27:23Z"}, "message": "refactor: use `select` inside of a probe\n\nWe ought not to be affecting inference state when assembling candidates,\nso invoke select inside of a probe.", "tree": {"sha": "56132ab3348c3b6d5db2f48f03d4d29ebf575363", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56132ab3348c3b6d5db2f48f03d4d29ebf575363"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df5c62bed2afed6c0f1b64d04bdf4465db6f46ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df5c62bed2afed6c0f1b64d04bdf4465db6f46ee", "html_url": "https://github.com/rust-lang/rust/commit/df5c62bed2afed6c0f1b64d04bdf4465db6f46ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df5c62bed2afed6c0f1b64d04bdf4465db6f46ee/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fdf2c4f976ce52163841ba5b3117bb2bb06d97e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fdf2c4f976ce52163841ba5b3117bb2bb06d97e", "html_url": "https://github.com/rust-lang/rust/commit/4fdf2c4f976ce52163841ba5b3117bb2bb06d97e"}], "stats": {"total": 469, "additions": 281, "deletions": 188}, "files": [{"sha": "b6f7e19b04a560eb8745e4b47920978efc8e6f35", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 281, "deletions": 188, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/df5c62bed2afed6c0f1b64d04bdf4465db6f46ee/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df5c62bed2afed6c0f1b64d04bdf4465db6f46ee/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=df5c62bed2afed6c0f1b64d04bdf4465db6f46ee", "patch": "@@ -152,14 +152,8 @@ enum ProjectionTyCandidate<'tcx> {\n     // from the definition of `Trait` when you have something like <<A as Trait>::B as Trait2>::C\n     TraitDef(ty::PolyProjectionPredicate<'tcx>),\n \n-    // defined in an impl\n-    Impl(VtableImplData<'tcx, PredicateObligation<'tcx>>),\n-\n-    // closure return type\n-    Closure(VtableClosureData<'tcx, PredicateObligation<'tcx>>),\n-\n-    // fn pointer return type\n-    FnPointer(VtableFnPointerData<'tcx, PredicateObligation<'tcx>>),\n+    // from a \"impl\" (or a \"pseudo-impl\" returned by select)\n+    Select,\n }\n \n struct ProjectionTyCandidateSet<'tcx> {\n@@ -599,10 +593,8 @@ fn project_type<'cx, 'gcx, 'tcx>(\n         debug!(\"retaining param-env candidates only from {:?}\", candidates.vec);\n         candidates.vec.retain(|c| match *c {\n             ProjectionTyCandidate::ParamEnv(..) => true,\n-            ProjectionTyCandidate::Impl(..) |\n-            ProjectionTyCandidate::Closure(..) |\n             ProjectionTyCandidate::TraitDef(..) |\n-            ProjectionTyCandidate::FnPointer(..) => false,\n+            ProjectionTyCandidate::Select => false,\n         });\n         debug!(\"resulting candidate set: {:?}\", candidates.vec);\n         if candidates.vec.len() != 1 {\n@@ -612,78 +604,12 @@ fn project_type<'cx, 'gcx, 'tcx>(\n \n     assert!(candidates.vec.len() <= 1);\n \n-    let possible_candidate = candidates.vec.pop().and_then(|candidate| {\n-        // In Any (i.e. trans) mode, all projections succeed;\n-        // otherwise, we need to be sensitive to `default` and\n-        // specialization.\n-        if !selcx.projection_mode().is_any() {\n-            if let ProjectionTyCandidate::Impl(ref impl_data) = candidate {\n-                if let Some(node_item) = assoc_ty_def(selcx,\n-                                                      impl_data.impl_def_id,\n-                                                      obligation.predicate.item_name) {\n-                    if node_item.node.is_from_trait() {\n-                        if node_item.item.ty.is_some() {\n-                            // If the associated type has a default from the\n-                            // trait, that should be considered `default` and\n-                            // hence not projected.\n-                            //\n-                            // Note, however, that we allow a projection from\n-                            // the trait specifically in the case that the trait\n-                            // does *not* give a default. This is purely to\n-                            // avoid spurious errors: the situation can only\n-                            // arise when *no* impl in the specialization chain\n-                            // has provided a definition for the type. When we\n-                            // confirm the candidate, we'll turn the projection\n-                            // into a TyError, since the actual error will be\n-                            // reported in `check_impl_items_against_trait`.\n-                            return None;\n-                        }\n-                    } else if node_item.item.defaultness.is_default() {\n-                        return None;\n-                    }\n-                } else {\n-                    // Normally this situation could only arise througha\n-                    // compiler bug, but at coherence-checking time we only look\n-                    // at the topmost impl (we don't even consider the trait\n-                    // itself) for the definition -- so we can fail to find a\n-                    // definition of the type even if it exists.\n-\n-                    // For now, we just unconditionally ICE, because otherwise,\n-                    // examples like the following will succeed:\n-                    //\n-                    // ```\n-                    // trait Assoc {\n-                    //     type Output;\n-                    // }\n-                    //\n-                    // impl<T> Assoc for T {\n-                    //     default type Output = bool;\n-                    // }\n-                    //\n-                    // impl Assoc for u8 {}\n-                    // impl Assoc for u16 {}\n-                    //\n-                    // trait Foo {}\n-                    // impl Foo for <u8 as Assoc>::Output {}\n-                    // impl Foo for <u16 as Assoc>::Output {}\n-                    //     return None;\n-                    // }\n-                    // ```\n-                    //\n-                    // The essential problem here is that the projection fails,\n-                    // leaving two unnormalized types, which appear not to unify\n-                    // -- so the overlap check succeeds, when it should fail.\n-                    bug!(\"Tried to project an inherited associated type during \\\n-                          coherence checking, which is currently not supported.\");\n-                }\n-            }\n-        }\n-        Some(candidate)\n-    });\n-\n-    match possible_candidate {\n+    match candidates.vec.pop() {\n         Some(candidate) => {\n-            let (ty, obligations) = confirm_candidate(selcx, obligation, candidate);\n+            let (ty, obligations) = confirm_candidate(selcx,\n+                                                      obligation,\n+                                                      &obligation_trait_ref,\n+                                                      candidate);\n             Ok(ProjectedTy::Progress(ty, obligations))\n         }\n         None => {\n@@ -802,38 +728,6 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n     }\n }\n \n-fn assemble_candidates_from_object_type<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n-    obligation:  &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n-{\n-    let self_ty = obligation_trait_ref.self_ty();\n-    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n-    debug!(\"assemble_candidates_from_object_type(object_ty={:?})\",\n-           object_ty);\n-    let data = match object_ty.sty {\n-        ty::TyTrait(ref data) => data,\n-        _ => {\n-            span_bug!(\n-                obligation.cause.span,\n-                \"assemble_candidates_from_object_type called with non-object: {:?}\",\n-                object_ty);\n-        }\n-    };\n-    let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n-    let env_predicates = projection_bounds.iter()\n-                                          .map(|p| p.to_predicate())\n-                                          .collect();\n-    let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n-    assemble_candidates_from_predicates(selcx,\n-                                        obligation,\n-                                        obligation_trait_ref,\n-                                        candidate_set,\n-                                        ProjectionTyCandidate::ParamEnv,\n-                                        env_predicates)\n-}\n-\n fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n@@ -845,82 +739,183 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n     // start out by selecting the predicate `T as TraitRef<...>`:\n     let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n     let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n-    let vtable = match selcx.select(&trait_obligation) {\n-        Ok(Some(vtable)) => vtable,\n-        Ok(None) => {\n-            candidate_set.ambiguous = true;\n-            return Ok(());\n-        }\n-        Err(e) => {\n-            debug!(\"assemble_candidates_from_impls: selection error {:?}\",\n-                   e);\n-            return Err(e);\n-        }\n-    };\n+    selcx.infcx().probe(|_| {\n+        let vtable = match selcx.select(&trait_obligation) {\n+            Ok(Some(vtable)) => vtable,\n+            Ok(None) => {\n+                candidate_set.ambiguous = true;\n+                return Ok(());\n+            }\n+            Err(e) => {\n+                debug!(\"assemble_candidates_from_impls: selection error {:?}\",\n+                       e);\n+                return Err(e);\n+            }\n+        };\n \n-    match vtable {\n-        super::VtableImpl(data) => {\n-            debug!(\"assemble_candidates_from_impls: impl candidate {:?}\",\n-                   data);\n+        match vtable {\n+            super::VtableClosure(_) |\n+            super::VtableFnPointer(_) |\n+            super::VtableObject(_) => {\n+                debug!(\"assemble_candidates_from_impls: vtable={:?}\",\n+                       vtable);\n \n-            candidate_set.vec.push(\n-                ProjectionTyCandidate::Impl(data));\n-        }\n-        super::VtableObject(_) => {\n-            assemble_candidates_from_object_type(\n-                selcx, obligation, obligation_trait_ref, candidate_set);\n-        }\n-        super::VtableClosure(data) => {\n-            candidate_set.vec.push(\n-                ProjectionTyCandidate::Closure(data));\n-        }\n-        super::VtableFnPointer(data) => {\n-            candidate_set.vec.push(\n-                ProjectionTyCandidate::FnPointer(data));\n-        }\n-        super::VtableParam(..) => {\n-            // This case tell us nothing about the value of an\n-            // associated type. Consider:\n-            //\n-            // ```\n-            // trait SomeTrait { type Foo; }\n-            // fn foo<T:SomeTrait>(...) { }\n-            // ```\n-            //\n-            // If the user writes `<T as SomeTrait>::Foo`, then the `T\n-            // : SomeTrait` binding does not help us decide what the\n-            // type `Foo` is (at least, not more specifically than\n-            // what we already knew).\n-            //\n-            // But wait, you say! What about an example like this:\n-            //\n-            // ```\n-            // fn bar<T:SomeTrait<Foo=usize>>(...) { ... }\n-            // ```\n-            //\n-            // Doesn't the `T : Sometrait<Foo=usize>` predicate help\n-            // resolve `T::Foo`? And of course it does, but in fact\n-            // that single predicate is desugared into two predicates\n-            // in the compiler: a trait predicate (`T : SomeTrait`) and a\n-            // projection. And the projection where clause is handled\n-            // in `assemble_candidates_from_param_env`.\n-        }\n-        super::VtableDefaultImpl(..) |\n-        super::VtableBuiltin(..) => {\n-            // These traits have no associated types.\n-            span_bug!(\n-                obligation.cause.span,\n-                \"Cannot project an associated type from `{:?}`\",\n-                vtable);\n+                candidate_set.vec.push(ProjectionTyCandidate::Select);\n+            }\n+            super::VtableImpl(ref impl_data) if !selcx.projection_mode().is_any() => {\n+                // We have to be careful when projecting out of an\n+                // impl because of specialization. If we are not in\n+                // trans (i.e., projection mode is not \"any\"), and the\n+                // impl's type is declared as default, then we disable\n+                // projection (even if the trait ref is fully\n+                // monomorphic). In the case where trait ref is not\n+                // fully monomorphic (i.e., includes type parameters),\n+                // this is because those type parameters may\n+                // ultimately be bound to types from other crates that\n+                // may have specialized impls we can't see. In the\n+                // case where the trait ref IS fully monomorphic, this\n+                // is a policy decision that we made in the RFC in\n+                // order to preserve flexibility for the crate that\n+                // defined the specializable impl to specialize later\n+                // for existing types.\n+                //\n+                // In either case, we handle this by not adding a\n+                // candidate for an impl if it contains a `default`\n+                // type.\n+                let opt_node_item = assoc_ty_def(selcx,\n+                                                 impl_data.impl_def_id,\n+                                                 obligation.predicate.item_name);\n+                let new_candidate = if let Some(node_item) = opt_node_item {\n+                    if node_item.node.is_from_trait() {\n+                        if node_item.item.ty.is_some() {\n+                            // The impl inherited a `type Foo =\n+                            // Bar` given in the trait, which is\n+                            // implicitly default. No candidate.\n+                            None\n+                        } else {\n+                            // The impl did not specify `type` and neither\n+                            // did the trait:\n+                            //\n+                            // ```rust\n+                            // trait Foo { type T; }\n+                            // impl Foo for Bar { }\n+                            // ```\n+                            //\n+                            // This is an error, but it will be\n+                            // reported in `check_impl_items_against_trait`.\n+                            // We accept it here but will flag it as\n+                            // an error when we confirm the candidate\n+                            // (which will ultimately lead to `normalize_to_error`\n+                            // being invoked).\n+                            Some(ProjectionTyCandidate::Select)\n+                        }\n+                    } else if node_item.item.defaultness.is_default() {\n+                        // The impl specified `default type Foo =\n+                        // Bar`. No candidate.\n+                        None\n+                    } else {\n+                        // The impl specified `type Foo = Bar`\n+                        // with no default. Add a candidate.\n+                        Some(ProjectionTyCandidate::Select)\n+                    }\n+                } else {\n+                    // This is saying that neither the trait nor\n+                    // the impl contain a definition for this\n+                    // associated type.  Normally this situation\n+                    // could only arise through a compiler bug --\n+                    // if the user wrote a bad item name, it\n+                    // should have failed in astconv. **However**,\n+                    // at coherence-checking time, we only look at\n+                    // the topmost impl (we don't even consider\n+                    // the trait itself) for the definition -- and\n+                    // so in that case it may be that the trait\n+                    // *DOES* have a declaration, but we don't see\n+                    // it, and we end up in this branch.\n+                    //\n+                    // This is kind of tricky to handle actually.\n+                    // For now, we just unconditionally ICE,\n+                    // because otherwise, examples like the\n+                    // following will succeed:\n+                    //\n+                    // ```\n+                    // trait Assoc {\n+                    //     type Output;\n+                    // }\n+                    //\n+                    // impl<T> Assoc for T {\n+                    //     default type Output = bool;\n+                    // }\n+                    //\n+                    // impl Assoc for u8 {}\n+                    // impl Assoc for u16 {}\n+                    //\n+                    // trait Foo {}\n+                    // impl Foo for <u8 as Assoc>::Output {}\n+                    // impl Foo for <u16 as Assoc>::Output {}\n+                    //     return None;\n+                    // }\n+                    // ```\n+                    //\n+                    // The essential problem here is that the\n+                    // projection fails, leaving two unnormalized\n+                    // types, which appear not to unify -- so the\n+                    // overlap check succeeds, when it should\n+                    // fail.\n+                    bug!(\"Tried to project an inherited associated type during \\\n+                          coherence checking, which is currently not supported.\");\n+                };\n+                candidate_set.vec.extend(new_candidate);\n+            }\n+            super::VtableImpl(_) => {\n+                // In trans mode, we can just project out of impls, no prob.\n+                assert!(selcx.projection_mode().is_any());\n+                candidate_set.vec.push(ProjectionTyCandidate::Select);\n+            }\n+            super::VtableParam(..) => {\n+                // This case tell us nothing about the value of an\n+                // associated type. Consider:\n+                //\n+                // ```\n+                // trait SomeTrait { type Foo; }\n+                // fn foo<T:SomeTrait>(...) { }\n+                // ```\n+                //\n+                // If the user writes `<T as SomeTrait>::Foo`, then the `T\n+                // : SomeTrait` binding does not help us decide what the\n+                // type `Foo` is (at least, not more specifically than\n+                // what we already knew).\n+                //\n+                // But wait, you say! What about an example like this:\n+                //\n+                // ```\n+                // fn bar<T:SomeTrait<Foo=usize>>(...) { ... }\n+                // ```\n+                //\n+                // Doesn't the `T : Sometrait<Foo=usize>` predicate help\n+                // resolve `T::Foo`? And of course it does, but in fact\n+                // that single predicate is desugared into two predicates\n+                // in the compiler: a trait predicate (`T : SomeTrait`) and a\n+                // projection. And the projection where clause is handled\n+                // in `assemble_candidates_from_param_env`.\n+            }\n+            super::VtableDefaultImpl(..) |\n+            super::VtableBuiltin(..) => {\n+                // These traits have no associated types.\n+                span_bug!(\n+                    obligation.cause.span,\n+                    \"Cannot project an associated type from `{:?}`\",\n+                    vtable);\n+            }\n         }\n-    }\n \n-    Ok(())\n+        Ok(())\n+    })\n }\n \n fn confirm_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate: ProjectionTyCandidate<'tcx>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n@@ -934,18 +929,116 @@ fn confirm_candidate<'cx, 'gcx, 'tcx>(\n             confirm_param_env_candidate(selcx, obligation, poly_projection)\n         }\n \n-        ProjectionTyCandidate::Impl(impl_vtable) => {\n-            confirm_impl_candidate(selcx, obligation, impl_vtable)\n+        ProjectionTyCandidate::Select => {\n+            confirm_select_candidate(selcx, obligation, obligation_trait_ref)\n+        }\n+    }\n+}\n+\n+fn confirm_select_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n+    let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n+    let vtable = match selcx.select(&trait_obligation) {\n+        Ok(Some(vtable)) => vtable,\n+        _ => {\n+            span_bug!(\n+                obligation.cause.span,\n+                \"Failed to select `{:?}`\",\n+                trait_obligation);\n         }\n+    };\n \n-        ProjectionTyCandidate::Closure(closure_vtable) => {\n-            confirm_closure_candidate(selcx, obligation, closure_vtable)\n+    match vtable {\n+        super::VtableImpl(data) =>\n+            confirm_impl_candidate(selcx, obligation, data),\n+        super::VtableClosure(data) =>\n+            confirm_closure_candidate(selcx, obligation, data),\n+        super::VtableFnPointer(data) =>\n+            confirm_fn_pointer_candidate(selcx, obligation, data),\n+        super::VtableObject(_) =>\n+            confirm_object_candidate(selcx, obligation, obligation_trait_ref),\n+        super::VtableDefaultImpl(..) |\n+        super::VtableParam(..) |\n+        super::VtableBuiltin(..) =>\n+            // we don't create Select candidates with this kind of resolution\n+            span_bug!(\n+                obligation.cause.span,\n+                \"Cannot project an associated type from `{:?}`\",\n+                vtable),\n+    }\n+}\n+\n+fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+    obligation:  &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let self_ty = obligation_trait_ref.self_ty();\n+    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n+    debug!(\"assemble_candidates_from_object_type(object_ty={:?})\",\n+           object_ty);\n+    let data = match object_ty.sty {\n+        ty::TyTrait(ref data) => data,\n+        _ => {\n+            span_bug!(\n+                obligation.cause.span,\n+                \"assemble_candidates_from_object_type called with non-object: {:?}\",\n+                object_ty);\n         }\n+    };\n+    let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n+    let env_predicates = projection_bounds.iter()\n+                                          .map(|p| p.to_predicate())\n+                                          .collect();\n+    let env_predicate = {\n+        let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n+\n+        // select only those projections that are actually projecting an\n+        // item with the correct name\n+        let env_predicates = env_predicates.filter_map(|p| match p {\n+            ty::Predicate::Projection(data) =>\n+                if data.item_name() == obligation.predicate.item_name {\n+                    Some(data)\n+                } else {\n+                    None\n+                },\n+            _ => None\n+        });\n \n-        ProjectionTyCandidate::FnPointer(fn_pointer_vtable) => {\n-            confirm_fn_pointer_candidate(selcx, obligation, fn_pointer_vtable)\n+        // select those with a relevant trait-ref\n+        let mut env_predicates = env_predicates.filter(|data| {\n+            let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n+            let data_poly_trait_ref = data.to_poly_trait_ref();\n+            let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n+            selcx.infcx().probe(|_| {\n+                selcx.infcx().sub_poly_trait_refs(false,\n+                                                  origin,\n+                                                  data_poly_trait_ref,\n+                                                  obligation_poly_trait_ref).is_ok()\n+            })\n+        });\n+\n+        // select the first matching one; there really ought to be one or\n+        // else the object type is not WF, since an object type should\n+        // include all of its projections explicitly\n+        match env_predicates.next() {\n+            Some(env_predicate) => env_predicate,\n+            None => {\n+                debug!(\"confirm_object_candidate: no env-predicate \\\n+                        found in object type `{:?}`; ill-formed\",\n+                       object_ty);\n+                return (selcx.tcx().types.err, vec!());\n+            }\n         }\n-    }\n+    };\n+\n+    confirm_param_env_candidate(selcx, obligation, env_predicate)\n }\n \n fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>("}]}