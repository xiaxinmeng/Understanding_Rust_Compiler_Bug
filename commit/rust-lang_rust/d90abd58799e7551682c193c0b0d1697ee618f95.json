{"sha": "d90abd58799e7551682c193c0b0d1697ee618f95", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MGFiZDU4Nzk5ZTc1NTE2ODJjMTkzYzBiMGQxNjk3ZWU2MThmOTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-09T18:20:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-09T18:20:55Z"}, "message": "auto merge of #4848 : nikomatsakis/rust/issue-4821-bad-kind-computation, r=catamorphism\n\n...ear\r\n\r\nvalues to be copied.  Rewrite kind computation so that instead of directly\r\ncomputing the kind it computes what kinds of values are present in the type,\r\nand then derive kinds based on that. I find this easier to think about.\r\n\r\nFixes #4821.\r\n\r\nr? @catamorphism", "tree": {"sha": "5b9a2ee7b5eefbe2d3f780520c89f4011e0a3c41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b9a2ee7b5eefbe2d3f780520c89f4011e0a3c41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d90abd58799e7551682c193c0b0d1697ee618f95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d90abd58799e7551682c193c0b0d1697ee618f95", "html_url": "https://github.com/rust-lang/rust/commit/d90abd58799e7551682c193c0b0d1697ee618f95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d90abd58799e7551682c193c0b0d1697ee618f95/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c2b4edff5009ff4d2330723d9acbc85af4b12ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c2b4edff5009ff4d2330723d9acbc85af4b12ab", "html_url": "https://github.com/rust-lang/rust/commit/0c2b4edff5009ff4d2330723d9acbc85af4b12ab"}, {"sha": "a380df809c8eb874540a123780612f14cfc7303e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a380df809c8eb874540a123780612f14cfc7303e", "html_url": "https://github.com/rust-lang/rust/commit/a380df809c8eb874540a123780612f14cfc7303e"}], "stats": {"total": 1143, "additions": 588, "deletions": 555}, "files": [{"sha": "79bf85021d88b4808f4445a3e0fcff4d0eeb1120", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -457,7 +457,7 @@ pub fn parse_source(name: ~str, j: &json::Json) -> @Source {\n     }\n \n     match *j {\n-        json::Object(j) => {\n+        json::Object(ref j) => {\n             let mut url = match j.find(&~\"url\") {\n                 Some(&json::String(u)) => copy u,\n                 _ => die!(~\"needed 'url' field in source\")\n@@ -563,7 +563,7 @@ pub fn load_one_source_package(src: @Source, p: &json::Object) {\n \n     let mut tags = ~[];\n     match p.find(&~\"tags\") {\n-        Some(&json::List(js)) => {\n+        Some(&json::List(ref js)) => {\n           for js.each |j| {\n                 match *j {\n                     json::String(ref j) => tags.grow(1u, j),\n@@ -635,11 +635,11 @@ pub fn load_source_packages(c: &Cargo, src: @Source) {\n     if !os::path_exists(&pkgfile) { return; }\n     let pkgstr = io::read_whole_file_str(&pkgfile);\n     match json::from_str(pkgstr.get()) {\n-        Ok(json::List(js)) => {\n+        Ok(json::List(ref js)) => {\n           for js.each |j| {\n                 match *j {\n-                    json::Object(p) => {\n-                        load_one_source_package(src, p);\n+                    json::Object(ref p) => {\n+                        load_one_source_package(src, *p);\n                     }\n                     _ => {\n                         warn(~\"malformed source json: \" + src.name +"}, {"sha": "47e68401485edc2f378a34927692ced97cce02ce", "filename": "src/libcore/str.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -220,6 +220,16 @@ pub pure fn connect(v: &[~str], sep: &str) -> ~str {\n     s\n }\n \n+/// Concatenate a vector of strings, placing a given separator between each\n+pub pure fn connect_slices(v: &[&str], sep: &str) -> ~str {\n+    let mut s = ~\"\", first = true;\n+    for vec::each(v) |ss| {\n+        if first { first = false; } else { unsafe { push_str(&mut s, sep); } }\n+        unsafe { push_str(&mut s, *ss) };\n+    }\n+    s\n+}\n+\n /// Given a string, make a new string with repeated copies of it\n pub pure fn repeat(ss: &str, nn: uint) -> ~str {\n     let mut acc = ~\"\";\n@@ -2667,6 +2677,17 @@ mod tests {\n         t(~[~\"hi\"], ~\" \", ~\"hi\");\n     }\n \n+    #[test]\n+    fn test_connect_slices() {\n+        fn t(v: &[&str], sep: &str, s: &str) {\n+            assert connect_slices(v, sep) == s.to_str();\n+        }\n+        t([\"you\", \"know\", \"I'm\", \"no\", \"good\"],\n+          \" \", \"you know I'm no good\");\n+        t([], \" \", \"\");\n+        t([\"hi\"], \" \", \"hi\");\n+    }\n+\n     #[test]\n     fn test_repeat() {\n         assert repeat(~\"x\", 4) == ~\"xxxx\";"}, {"sha": "a949b40bf7549825c143bfecee053aafdfd87624", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 67, "deletions": 62, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -15,7 +15,6 @@ use middle::freevars;\n use middle::lint::{non_implicitly_copyable_typarams, implicit_copies};\n use middle::liveness;\n use middle::pat_util;\n-use middle::ty::{Kind, kind_copyable, kind_noncopyable, kind_const};\n use middle::ty;\n use middle::typeck;\n use middle;\n@@ -61,26 +60,6 @@ use syntax::{visit, ast_util};\n \n pub const try_adding: &str = \"Try adding a move\";\n \n-pub fn kind_to_str(k: Kind) -> ~str {\n-    let mut kinds = ~[];\n-\n-    if ty::kind_lteq(kind_const(), k) {\n-        kinds.push(~\"const\");\n-    }\n-\n-    if ty::kind_can_be_copied(k) {\n-        kinds.push(~\"copy\");\n-    }\n-\n-    if ty::kind_can_be_sent(k) {\n-        kinds.push(~\"owned\");\n-    } else if ty::kind_is_durable(k) {\n-        kinds.push(~\"&static\");\n-    }\n-\n-    str::connect(kinds, ~\" \")\n-}\n-\n pub type rval_map = HashMap<node_id, ()>;\n \n pub type ctx = {\n@@ -119,11 +98,11 @@ type check_fn = fn@(ctx, @freevar_entry);\n // closure.\n fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n     fn check_for_uniq(cx: ctx, fv: @freevar_entry) {\n-        // all captured data must be sendable, regardless of whether it is\n-        // moved in or copied in.  Note that send implies owned.\n+        // all captured data must be owned, regardless of whether it is\n+        // moved in or copied in.\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n-        if !check_send(cx, var_t, fv.span) { return; }\n+        if !check_owned(cx, var_t, fv.span) { return; }\n \n         // check that only immutable variables are implicitly copied in\n         check_imm_free_var(cx, fv.def, fv.span);\n@@ -281,30 +260,54 @@ fn check_ty(aty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n     visit::visit_ty(aty, cx, v);\n }\n \n-pub fn check_bounds(cx: ctx, id: node_id, sp: span,\n-                    ty: ty::t, bounds: ty::param_bounds) {\n-    let kind = ty::type_kind(cx.tcx, ty);\n-    let p_kind = ty::param_bounds_to_kind(bounds);\n-    if !ty::kind_lteq(p_kind, kind) {\n-        // If the only reason the kind check fails is because the\n-        // argument type isn't implicitly copyable, consult the warning\n-        // settings to figure out what to do.\n-        let implicit = ty::kind_implicitly_copyable() - ty::kind_copyable();\n-        if ty::kind_lteq(p_kind, kind | implicit) {\n-            cx.tcx.sess.span_lint(\n-                non_implicitly_copyable_typarams,\n-                id, cx.current_item, sp,\n-                ~\"instantiating copy type parameter with a \\\n-                 not implicitly copyable type\");\n-        } else {\n-            cx.tcx.sess.span_err(\n-                sp,\n-                ~\"instantiating a type parameter with an incompatible type \" +\n-                ~\"(needs `\" + kind_to_str(p_kind) +\n-                ~\"`, got `\" + kind_to_str(kind) +\n-                ~\"`, missing `\" + kind_to_str(p_kind - kind) + ~\"`)\");\n+pub fn check_bounds(cx: ctx,\n+                    _type_parameter_id: node_id,\n+                    sp: span,\n+                    ty: ty::t,\n+                    bounds: ty::param_bounds)\n+{\n+    let kind = ty::type_contents(cx.tcx, ty);\n+    let mut missing = ~[];\n+    for bounds.each |bound| {\n+        match *bound {\n+            ty::bound_trait(_) => {\n+                /* Not our job, checking in typeck */\n+            }\n+\n+            ty::bound_copy => {\n+                if !kind.is_copy(cx.tcx) {\n+                    missing.push(\"Copy\");\n+                }\n+            }\n+\n+            ty::bound_durable => {\n+                if !kind.is_durable(cx.tcx) {\n+                    missing.push(\"&static\");\n+                }\n+            }\n+\n+            ty::bound_owned => {\n+                if !kind.is_owned(cx.tcx) {\n+                    missing.push(\"Owned\");\n+                }\n+            }\n+\n+            ty::bound_const => {\n+                if !kind.is_const(cx.tcx) {\n+                    missing.push(\"Const\");\n+                }\n+            }\n         }\n     }\n+\n+    if !missing.is_empty() {\n+        cx.tcx.sess.span_err(\n+            sp,\n+            fmt!(\"instantiating a type parameter with an incompatible type \\\n+                  `%s`, which does not fulfill `%s`\",\n+                 ty_to_str(cx.tcx, ty),\n+                 str::connect_slices(missing, \" \")));\n+    }\n }\n \n fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n@@ -342,16 +345,22 @@ fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n }\n \n fn check_copy(cx: ctx, ty: ty::t, sp: span, reason: &str) {\n-    let k = ty::type_kind(cx.tcx, ty);\n-    if !ty::kind_can_be_copied(k) {\n-        cx.tcx.sess.span_err(sp, ~\"copying a noncopyable value\");\n+    debug!(\"type_contents(%s)=%s\",\n+           ty_to_str(cx.tcx, ty),\n+           ty::type_contents(cx.tcx, ty).to_str());\n+    if !ty::type_is_copyable(cx.tcx, ty) {\n+        cx.tcx.sess.span_err(\n+            sp, fmt!(\"copying a value of non-copyable type `%s`\",\n+                     ty_to_str(cx.tcx, ty)));\n         cx.tcx.sess.span_note(sp, fmt!(\"%s\", reason));\n     }\n }\n \n-pub fn check_send(cx: ctx, ty: ty::t, sp: span) -> bool {\n-    if !ty::kind_can_be_sent(ty::type_kind(cx.tcx, ty)) {\n-        cx.tcx.sess.span_err(sp, ~\"not a sendable value\");\n+pub fn check_owned(cx: ctx, ty: ty::t, sp: span) -> bool {\n+    if !ty::type_is_owned(cx.tcx, ty) {\n+        cx.tcx.sess.span_err(\n+            sp, fmt!(\"value has non-owned type `%s`\",\n+                     ty_to_str(cx.tcx, ty)));\n         false\n     } else {\n         true\n@@ -360,7 +369,7 @@ pub fn check_send(cx: ctx, ty: ty::t, sp: span) -> bool {\n \n // note: also used from middle::typeck::regionck!\n pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n-    if !ty::kind_is_durable(ty::type_kind(tcx, ty)) {\n+    if !ty::type_is_durable(tcx, ty) {\n         match ty::get(ty).sty {\n           ty::ty_param(*) => {\n             tcx.sess.span_err(sp, ~\"value may contain borrowed \\\n@@ -403,8 +412,8 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n pub fn check_cast_for_escaping_regions(\n     cx: ctx,\n     source: @expr,\n-    target: @expr) {\n-\n+    target: @expr)\n+{\n     // Determine what type we are casting to; if it is not an trait, then no\n     // worries.\n     let target_ty = ty::expr_ty(cx.tcx, target);\n@@ -450,13 +459,9 @@ pub fn check_kind_bounds_of_cast(cx: ctx, source: @expr, target: @expr) {\n     match ty::get(target_ty).sty {\n         ty::ty_trait(_, _, ty::vstore_uniq) => {\n             let source_ty = ty::expr_ty(cx.tcx, source);\n-            let source_kind = ty::type_kind(cx.tcx, source_ty);\n-            if !ty::kind_can_be_copied(source_kind) {\n-                cx.tcx.sess.span_err(target.span,\n-                    ~\"uniquely-owned trait objects must be copyable\");\n-            }\n-            if !ty::kind_can_be_sent(source_kind) {\n-                cx.tcx.sess.span_err(target.span,\n+            if !ty::type_is_owned(cx.tcx, source_ty) {\n+                cx.tcx.sess.span_err(\n+                    target.span,\n                     ~\"uniquely-owned trait objects must be sendable\");\n             }\n         }"}, {"sha": "843b01bdb35dcf5f0a3be19b998900018608ed83", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -925,8 +925,8 @@ fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: ast::fn_decl,\n \n                     ast::infer(_) => {\n                         if tcx.legacy_modes {\n-                            let kind = ty::type_kind(tcx, arg_ty.ty);\n-                            if !ty::kind_is_safe_for_default_mode(kind) {\n+                            let kind = ty::type_contents(tcx, arg_ty.ty);\n+                            if !kind.is_safe_for_default_mode(tcx) {\n                                 tcx.sess.span_lint(\n                                     deprecated_mode, id, id,\n                                     span,"}, {"sha": "0d32bb7ecf6d7cdde1f92b85d7e468ced60b0b9f", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -374,7 +374,7 @@ impl VisitContext {\n          * not implicitly copyable.\n          */\n \n-        let result = if ty::type_implicitly_moves(self.tcx, ty) {\n+        let result = if ty::type_moves_by_default(self.tcx, ty) {\n             MoveInWhole\n         } else {\n             Read\n@@ -495,7 +495,7 @@ impl VisitContext {\n                     // moves-by-default:\n                     let consume_with = with_fields.any(|tf| {\n                         !fields.any(|f| f.node.ident == tf.ident) &&\n-                            ty::type_implicitly_moves(self.tcx, tf.mt.ty)\n+                            ty::type_moves_by_default(self.tcx, tf.mt.ty)\n                     });\n \n                     if consume_with {\n@@ -830,7 +830,7 @@ impl VisitContext {\n                 let fvar_ty = ty::node_id_to_type(self.tcx, fvar_def_id);\n                 debug!(\"fvar_def_id=%? fvar_ty=%s\",\n                        fvar_def_id, ppaux::ty_to_str(self.tcx, fvar_ty));\n-                let mode = if ty::type_implicitly_moves(self.tcx, fvar_ty) {\n+                let mode = if ty::type_moves_by_default(self.tcx, fvar_ty) {\n                     CapMove\n                 } else {\n                     CapCopy"}, {"sha": "2a43fc8a6019d1072e2dca6249800e4fcb6072c0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 401, "deletions": 422, "changes": 823, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -26,6 +26,7 @@ use session::Session;\n use util::ppaux::{note_and_explain_region, bound_region_to_str};\n use util::ppaux::{region_to_str, explain_region, vstore_to_str};\n use util::ppaux::{ty_to_str, tys_to_str};\n+use util::common::{indenter};\n \n use core::cast;\n use core::cmp;\n@@ -39,6 +40,7 @@ use core::result;\n use core::to_bytes;\n use core::uint;\n use core::vec;\n+use core::hashmap::linear::LinearMap;\n use std::oldmap::HashMap;\n use std::{oldmap, oldsmallintmap};\n use syntax::ast::*;\n@@ -259,7 +261,7 @@ struct ctxt_ {\n     short_names_cache: HashMap<t, @~str>,\n     needs_drop_cache: HashMap<t, bool>,\n     needs_unwind_cleanup_cache: HashMap<t, bool>,\n-    kind_cache: HashMap<t, Kind>,\n+    mut tc_cache: LinearMap<uint, TypeContents>,\n     ast_ty_to_ty_cache: HashMap<@ast::Ty, ast_ty_to_ty_cache_entry>,\n     enum_var_cache: HashMap<def_id, @~[VariantInfo]>,\n     trait_method_cache: HashMap<def_id, @~[method]>,\n@@ -737,37 +739,6 @@ pub impl RegionVid : to_bytes::IterBytes {\n     }\n }\n \n-pub fn kind_to_param_bounds(kind: Kind) -> param_bounds {\n-    let mut bounds = ~[];\n-    if kind_can_be_copied(kind) { bounds.push(bound_copy); }\n-    if kind_can_be_sent(kind) { bounds.push(bound_owned); }\n-    else if kind_is_durable(kind) { bounds.push(bound_durable); }\n-    if kind_is_const(kind) { bounds.push(bound_const); }\n-    return @bounds;\n-}\n-\n-pub fn param_bounds_to_kind(bounds: param_bounds) -> Kind {\n-    let mut kind = kind_noncopyable();\n-    for vec::each(*bounds) |bound| {\n-        match *bound {\n-          bound_copy => {\n-            kind = raise_kind(kind, kind_implicitly_copyable());\n-          }\n-          bound_durable => {\n-            kind = raise_kind(kind, kind_durable());\n-          }\n-          bound_owned => {\n-            kind = raise_kind(kind, kind_owned_only() | kind_durable());\n-          }\n-          bound_const => {\n-            kind = raise_kind(kind, kind_const());\n-          }\n-          bound_trait(_) => ()\n-        }\n-    }\n-    kind\n-}\n-\n /// A polytype.\n ///\n /// - `bounds`: The list of bounds for each type parameter.  The length of the\n@@ -851,7 +822,7 @@ pub fn mk_ctxt(s: session::Session,\n         short_names_cache: new_ty_hash(),\n         needs_drop_cache: new_ty_hash(),\n         needs_unwind_cleanup_cache: new_ty_hash(),\n-        kind_cache: new_ty_hash(),\n+        tc_cache: LinearMap::new(),\n         ast_ty_to_ty_cache: HashMap(),\n         enum_var_cache: HashMap(),\n         trait_method_cache: HashMap(),\n@@ -1507,10 +1478,6 @@ pub fn type_is_structural(ty: t) -> bool {\n     }\n }\n \n-pub fn type_is_copyable(cx: ctxt, ty: t) -> bool {\n-    return kind_can_be_copied(type_kind(cx, ty));\n-}\n-\n pub fn type_is_sequence(ty: t) -> bool {\n     match get(ty).sty {\n       ty_estr(_) | ty_evec(_, _) => true,\n@@ -1777,469 +1744,493 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n     return needs_unwind_cleanup;\n }\n \n-pub enum Kind { kind_(u32) }\n-\n-/// can be copied (implicitly or explicitly)\n-const KIND_MASK_COPY         : u32 = 0b000000000000000000000000001_u32;\n+/**\n+ * Type contents is how the type checker reasons about kinds.\n+ * They track what kinds of things are found within a type.  You can\n+ * think of them as kind of an \"anti-kind\".  They track the kinds of values\n+ * and thinks that are contained in types.  Having a larger contents for\n+ * a type tends to rule that type *out* from various kinds.  For example,\n+ * a type that contains a borrowed pointer is not sendable.\n+ *\n+ * The reason we compute type contents and not kinds is that it is\n+ * easier for me (nmatsakis) to think about what is contained within\n+ * a type than to think about what is *not* contained within a type.\n+ */\n+pub struct TypeContents {\n+    bits: u32\n+}\n \n-/// no shared box, borrowed ptr (must imply DURABLE)\n-const KIND_MASK_OWNED        : u32 = 0b000000000000000000000000010_u32;\n+pub impl TypeContents {\n+    fn intersects(&self, tc: TypeContents) -> bool {\n+        (self.bits & tc.bits) != 0\n+    }\n \n-/// is durable (no borrowed ptrs)\n-const KIND_MASK_DURABLE      : u32 = 0b000000000000000000000000100_u32;\n+    fn is_copy(&self, cx: ctxt) -> bool {\n+        !self.intersects(TypeContents::noncopyable(cx))\n+    }\n \n-/// is deeply immutable\n-const KIND_MASK_CONST        : u32 = 0b000000000000000000000001000_u32;\n+    static fn noncopyable(_cx: ctxt) -> TypeContents {\n+        TC_DTOR + TC_BORROWED_MUT + TC_ONCE_CLOSURE + TC_OWNED_CLOSURE +\n+            TC_EMPTY_ENUM\n+    }\n \n-/// can be implicitly copied (must imply COPY)\n-const KIND_MASK_IMPLICIT     : u32 = 0b000000000000000000000010000_u32;\n+    fn is_durable(&self, cx: ctxt) -> bool {\n+        !self.intersects(TypeContents::nondurable(cx))\n+    }\n \n-/// safe for default mode (subset of KIND_MASK_IMPLICIT)\n-const KIND_MASK_DEFAULT_MODE : u32 = 0b000000000000000000000100000_u32;\n+    static fn nondurable(_cx: ctxt) -> TypeContents {\n+        TC_BORROWED_POINTER\n+    }\n \n-pub fn kind_noncopyable() -> Kind {\n-    kind_(0u32)\n-}\n+    fn is_owned(&self, cx: ctxt) -> bool {\n+        !self.intersects(TypeContents::nonowned(cx))\n+    }\n \n-pub fn kind_copyable() -> Kind {\n-    kind_(KIND_MASK_COPY)\n-}\n+    static fn nonowned(_cx: ctxt) -> TypeContents {\n+        TC_MANAGED + TC_BORROWED_POINTER\n+    }\n \n-pub fn kind_implicitly_copyable() -> Kind {\n-    kind_(KIND_MASK_IMPLICIT | KIND_MASK_COPY)\n-}\n+    fn is_const(&self, cx: ctxt) -> bool {\n+        !self.intersects(TypeContents::nonconst(cx))\n+    }\n \n-fn kind_safe_for_default_mode() -> Kind {\n-    // similar to implicit copy, but always includes vectors and strings\n-    kind_(KIND_MASK_DEFAULT_MODE | KIND_MASK_IMPLICIT | KIND_MASK_COPY)\n-}\n+    static fn nonconst(_cx: ctxt) -> TypeContents {\n+        TC_MUTABLE\n+    }\n \n-fn kind_implicitly_sendable() -> Kind {\n-    kind_(KIND_MASK_IMPLICIT | KIND_MASK_COPY | KIND_MASK_OWNED)\n-}\n+    fn moves_by_default(&self, cx: ctxt) -> bool {\n+        self.intersects(TypeContents::nonimplicitly_copyable(cx))\n+    }\n \n-fn kind_safe_for_default_mode_send() -> Kind {\n-    // similar to implicit copy, but always includes vectors and strings\n-    kind_(KIND_MASK_DEFAULT_MODE | KIND_MASK_IMPLICIT |\n-          KIND_MASK_COPY | KIND_MASK_OWNED)\n-}\n+    static fn nonimplicitly_copyable(cx: ctxt) -> TypeContents {\n+        let base = TypeContents::noncopyable(cx) + TC_OWNED_POINTER;\n+        if cx.vecs_implicitly_copyable {base} else {base + TC_OWNED_SLICE}\n+    }\n \n+    fn is_safe_for_default_mode(&self, cx: ctxt) -> bool {\n+        !self.intersects(TypeContents::nondefault_mode(cx))\n+    }\n \n-fn kind_owned_copy() -> Kind {\n-    kind_(KIND_MASK_COPY | KIND_MASK_OWNED)\n+    static fn nondefault_mode(cx: ctxt) -> TypeContents {\n+        let tc = TypeContents::nonimplicitly_copyable(cx);\n+        tc + TC_BIG + TC_OWNED_SLICE // disregard cx.vecs_implicitly_copyable\n+    }\n }\n \n-fn kind_owned_only() -> Kind {\n-    kind_(KIND_MASK_OWNED)\n+impl TypeContents : ops::Add<TypeContents,TypeContents> {\n+    pure fn add(&self, other: &TypeContents) -> TypeContents {\n+        TypeContents {bits: self.bits | other.bits}\n+    }\n }\n \n-pub fn kind_const() -> Kind {\n-    kind_(KIND_MASK_CONST)\n+impl TypeContents : ops::Sub<TypeContents,TypeContents> {\n+    pure fn sub(&self, other: &TypeContents) -> TypeContents {\n+        TypeContents {bits: self.bits & !other.bits}\n+    }\n }\n \n-fn kind_durable() -> Kind {\n-    kind_(KIND_MASK_DURABLE)\n+impl TypeContents : ToStr {\n+    pure fn to_str(&self) -> ~str {\n+        fmt!(\"TypeContents(%s)\", u32::to_str_radix(self.bits, 2))\n+    }\n }\n \n-fn kind_top() -> Kind {\n-    kind_(0xffffffffu32)\n-}\n+/// Constant for a type containing nothing of interest.\n+const TC_NONE: TypeContents =             TypeContents{bits:0b0000_00000000};\n \n-fn remove_const(k: Kind) -> Kind {\n-    k - kind_const()\n-}\n+/// Contains a borrowed value with a lifetime other than static\n+const TC_BORROWED_POINTER: TypeContents = TypeContents{bits:0b0000_00000001};\n \n-fn remove_implicit(k: Kind) -> Kind {\n-    k - kind_(KIND_MASK_IMPLICIT | KIND_MASK_DEFAULT_MODE)\n-}\n+/// Contains an owned pointer (~T) but not slice of some kind\n+const TC_OWNED_POINTER: TypeContents =    TypeContents{bits:0b000000000010};\n \n-fn remove_owned(k: Kind) -> Kind {\n-    k - kind_(KIND_MASK_OWNED)\n-}\n+/// Contains an owned slice\n+const TC_OWNED_SLICE: TypeContents =      TypeContents{bits:0b000000000100};\n \n-fn remove_durable_owned(k: Kind) -> Kind {\n-    k - kind_(KIND_MASK_DURABLE) - kind_(KIND_MASK_OWNED)\n-}\n+/// Contains a ~fn() or a ~Trait, which is non-copyable.\n+const TC_OWNED_CLOSURE: TypeContents =    TypeContents{bits:0b000000001000};\n \n-fn remove_copyable(k: Kind) -> Kind {\n-    k - kind_(KIND_MASK_COPY | KIND_MASK_DEFAULT_MODE)\n-}\n+/// Type with a destructor\n+const TC_DTOR: TypeContents =             TypeContents{bits:0b000000010000};\n \n-impl Kind : ops::BitAnd<Kind,Kind> {\n-    pure fn bitand(&self, other: &Kind) -> Kind {\n-        unsafe {\n-            lower_kind(*self, *other)\n-        }\n-    }\n-}\n+/// Contains a managed value\n+const TC_MANAGED: TypeContents =          TypeContents{bits:0b000000100000};\n \n-impl Kind : ops::BitOr<Kind,Kind> {\n-    pure fn bitor(&self, other: &Kind) -> Kind {\n-        unsafe {\n-            raise_kind(*self, *other)\n-        }\n-    }\n-}\n+/// &mut with any region\n+const TC_BORROWED_MUT: TypeContents =     TypeContents{bits:0b000001000000};\n \n-impl Kind : ops::Sub<Kind,Kind> {\n-    pure fn sub(&self, other: &Kind) -> Kind {\n-        unsafe {\n-            kind_(**self & !**other)\n-        }\n-    }\n-}\n+/// Mutable content, whether owned or by ref\n+const TC_MUTABLE: TypeContents =          TypeContents{bits:0b000010000000};\n \n-// Using these query functions is preferable to direct comparison or matching\n-// against the kind constants, as we may modify the kind hierarchy in the\n-// future.\n-pub pure fn kind_can_be_implicitly_copied(k: Kind) -> bool {\n-    *k & KIND_MASK_IMPLICIT == KIND_MASK_IMPLICIT\n-}\n+/// Mutable content, whether owned or by ref\n+const TC_ONCE_CLOSURE: TypeContents =     TypeContents{bits:0b000100000000};\n \n-pub pure fn kind_is_safe_for_default_mode(k: Kind) -> bool {\n-    *k & KIND_MASK_DEFAULT_MODE == KIND_MASK_DEFAULT_MODE\n-}\n+/// Something we estimate to be \"big\"\n+const TC_BIG: TypeContents =              TypeContents{bits:0b001000000000};\n \n-pub pure fn kind_can_be_copied(k: Kind) -> bool {\n-    *k & KIND_MASK_COPY == KIND_MASK_COPY\n-}\n+/// An enum with no variants.\n+const TC_EMPTY_ENUM: TypeContents =       TypeContents{bits:0b010000000000};\n \n-pub pure fn kind_can_be_sent(k: Kind) -> bool {\n-    *k & KIND_MASK_OWNED == KIND_MASK_OWNED\n-}\n+/// All possible contents.\n+const TC_ALL: TypeContents =              TypeContents{bits:0b011111111111};\n \n-pub pure fn kind_is_durable(k: Kind) -> bool {\n-    *k & KIND_MASK_DURABLE == KIND_MASK_DURABLE\n+pub fn type_is_copyable(cx: ctxt, t: ty::t) -> bool {\n+    type_contents(cx, t).is_copy(cx)\n }\n \n-pure fn kind_is_const(k: Kind) -> bool {\n-    *k & KIND_MASK_CONST == KIND_MASK_CONST\n+pub fn type_is_durable(cx: ctxt, t: ty::t) -> bool {\n+    type_contents(cx, t).is_durable(cx)\n }\n \n-fn closure_kind(cty: &ClosureTy) -> Kind {\n-    let kind = match cty.sigil {\n-        ast::BorrowedSigil => kind_implicitly_copyable(),\n-        ast::ManagedSigil => kind_implicitly_copyable(),\n-        ast::OwnedSigil => kind_owned_only() | kind_durable(),\n-    };\n+pub fn type_is_owned(cx: ctxt, t: ty::t) -> bool {\n+    type_contents(cx, t).is_owned(cx)\n+}\n \n-    let kind = match cty.region {\n-        re_static => kind | kind_durable(),\n-        _ => kind - kind_owned_only() - kind_durable()\n-    };\n+pub fn type_is_const(cx: ctxt, t: ty::t) -> bool {\n+    type_contents(cx, t).is_const(cx)\n+}\n \n-    match cty.onceness {\n-        ast::Once => kind - kind_implicitly_copyable(),\n-        ast::Many => kind\n+pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n+    let ty_id = type_id(ty);\n+    match cx.tc_cache.find(&ty_id) {\n+        Some(tc) => { return *tc; }\n+        None => {}\n     }\n-}\n \n-pub fn kind_lteq(a: Kind, b: Kind) -> bool {\n-    *a & *b == *a\n-}\n+    let mut cache = LinearMap::new();\n+    let result = tc_ty(cx, ty, &mut cache);\n+    cx.tc_cache.insert(ty_id, result);\n+    return result;\n \n-fn lower_kind(a: Kind, b: Kind) -> Kind {\n-    kind_(*a & *b)\n-}\n+    fn tc_ty(cx: ctxt,\n+             ty: t,\n+             cache: &mut LinearMap<uint, TypeContents>) -> TypeContents\n+    {\n+        // Subtle: Note that we are *not* using cx.tc_cache here but rather a\n+        // private cache for this walk.  This is needed in the case of cyclic\n+        // types like:\n+        //\n+        //     struct List { next: ~Option<List>, ... }\n+        //\n+        // When computing the type contents of such a type, we wind up deeply\n+        // recursing as we go.  So when we encounter the recursive reference\n+        // to List, we temporarily use TC_NONE as its contents.  Later we'll\n+        // patch up the cache with the correct value, once we've computed it\n+        // (this is basically a co-inductive process, if that helps).  So in\n+        // the end we'll compute TC_OWNED_POINTER, in this case.\n+        //\n+        // The problem is, as we are doing the computation, we will also\n+        // compute an *intermediate* contents for, e.g., Option<List> of\n+        // TC_NONE.  This is ok during the computation of List itself, but if\n+        // we stored this intermediate value into cx.tc_cache, then later\n+        // requests for the contents of Option<List> would also yield TC_NONE\n+        // which is incorrect.  This value was computed based on the crutch\n+        // value for the type contents of list.  The correct value is\n+        // TC_OWNED_POINTER.  This manifested as issue #4821.\n+        let ty_id = type_id(ty);\n+        match cache.find(&ty_id) {\n+            Some(tc) => { return *tc; }\n+            None => {}\n+        }\n+        cache.insert(ty_id, TC_NONE);\n+\n+        debug!(\"computing contents of %s\", ty_to_str(cx, ty));\n+        let _i = indenter();\n+\n+        let mut result = match get(ty).sty {\n+            // Scalar and unique types are sendable, constant, and owned\n+            ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+            ty_bare_fn(_) | ty_ptr(_) => {\n+                TC_NONE\n+            }\n \n-fn raise_kind(a: Kind, b: Kind) -> Kind {\n-    kind_(*a | *b)\n-}\n+            ty_estr(vstore_uniq) => {\n+                TC_OWNED_SLICE\n+            }\n \n-#[test]\n-fn test_kinds() {\n-    // The kind \"lattice\" is defined by the subset operation on the\n-    // set of permitted operations.\n-    assert kind_lteq(kind_owned_copy(), kind_owned_copy());\n-    assert kind_lteq(kind_copyable(), kind_owned_copy());\n-    assert kind_lteq(kind_copyable(), kind_copyable());\n-    assert kind_lteq(kind_noncopyable(), kind_owned_copy());\n-    assert kind_lteq(kind_noncopyable(), kind_copyable());\n-    assert kind_lteq(kind_noncopyable(), kind_noncopyable());\n-    assert kind_lteq(kind_copyable(), kind_implicitly_copyable());\n-    assert kind_lteq(kind_copyable(), kind_implicitly_sendable());\n-    assert kind_lteq(kind_owned_copy(), kind_implicitly_sendable());\n-    assert !kind_lteq(kind_owned_copy(), kind_implicitly_copyable());\n-    assert !kind_lteq(kind_copyable(), kind_owned_only());\n-}\n+            ty_closure(ref c) => {\n+                closure_contents(c)\n+            }\n \n-// Return the most permissive kind that a composite object containing a field\n-// with the given mutability can have.\n-// This is used to prevent objects containing mutable state from being\n-// implicitly copied and to compute whether things have const kind.\n-fn mutability_kind(m: mutability) -> Kind {\n-    match (m) {\n-      m_mutbl => remove_const(remove_implicit(kind_top())),\n-      m_const => remove_implicit(kind_top()),\n-      m_imm => kind_top()\n-    }\n-}\n+            ty_box(mt) => {\n+                TC_MANAGED + nonowned(tc_mt(cx, mt, cache))\n+            }\n \n-fn mutable_type_kind(cx: ctxt, ty: mt) -> Kind {\n-    lower_kind(mutability_kind(ty.mutbl), type_kind(cx, ty.ty))\n-}\n+            ty_trait(_, _, vstore_uniq) => {\n+                TC_OWNED_CLOSURE\n+            }\n \n-pub fn type_kind(cx: ctxt, ty: t) -> Kind {\n-    type_kind_ext(cx, ty, false)\n-}\n+            ty_trait(_, _, vstore_box) => {\n+                TC_MANAGED\n+            }\n \n-// If `allow_ty_var` is true, then this is a conservative assumption; we\n-// assume that type variables *do* have all kinds.\n-pub fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n-    match cx.kind_cache.find(&ty) {\n-      Some(result) => return result,\n-      None => {/* fall through */ }\n-    }\n+            ty_trait(_, _, vstore_slice(r)) => {\n+                borrowed_contents(r, m_imm)\n+            }\n \n-    // Insert a default in case we loop back on self recursively.\n-    cx.kind_cache.insert(ty, kind_top());\n+            ty_rptr(r, mt) => {\n+                borrowed_contents(r, mt.mutbl) +\n+                    nonowned(tc_mt(cx, mt, cache))\n+            }\n \n-    let mut result = match /*bad*/copy get(ty).sty {\n-      // Scalar and unique types are sendable, constant, and owned\n-      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_bare_fn(_) | ty_ptr(_) => {\n-        kind_safe_for_default_mode_send() | kind_const() | kind_durable()\n-      }\n+            ty_uniq(mt) => {\n+                TC_OWNED_POINTER + tc_mt(cx, mt, cache)\n+            }\n \n-      // Implicit copyability of strs is configurable\n-      ty_estr(vstore_uniq) => {\n-        if cx.vecs_implicitly_copyable {\n-            kind_implicitly_sendable() | kind_const() | kind_durable()\n-        } else {\n-            kind_owned_copy() | kind_const() | kind_durable()\n-        }\n-      }\n+            ty_evec(mt, vstore_uniq) => {\n+                TC_OWNED_SLICE + tc_mt(cx, mt, cache)\n+            }\n \n-      ty_closure(ref c) => {\n-          closure_kind(c)\n-      }\n+            ty_evec(mt, vstore_box) => {\n+                TC_MANAGED + nonowned(tc_mt(cx, mt, cache))\n+            }\n \n-      // Those with refcounts raise noncopyable to copyable,\n-      // lower sendable to copyable. Therefore just set result to copyable.\n-      ty_box(tm) => {\n-        remove_owned(mutable_type_kind(cx, tm) | kind_safe_for_default_mode())\n-      }\n+            ty_evec(mt, vstore_slice(r)) => {\n+                borrowed_contents(r, mt.mutbl) +\n+                    nonowned(tc_mt(cx, mt, cache))\n+            }\n \n-      // XXX: This is wrong for ~Trait and &Trait!\n-      ty_trait(_, _, _) => kind_safe_for_default_mode() | kind_durable(),\n+            ty_evec(mt, vstore_fixed(_)) => {\n+                tc_mt(cx, mt, cache)\n+            }\n \n-      // Static region pointers are copyable and sendable, but not owned\n-      ty_rptr(re_static, mt) =>\n-      kind_safe_for_default_mode() | mutable_type_kind(cx, mt),\n+            ty_estr(vstore_box) => {\n+                TC_MANAGED\n+            }\n \n-      ty_rptr(_, mt) => {\n-        if mt.mutbl == ast::m_mutbl {\n-            // Mutable region pointers are noncopyable\n-            kind_noncopyable()\n-        } else {\n-            // General region pointers are copyable but NOT owned nor sendable\n-            kind_safe_for_default_mode()\n-        }\n-      }\n+            ty_estr(vstore_slice(r)) => {\n+                borrowed_contents(r, m_imm)\n+            }\n \n-      // Unique boxes and vecs have the kind of their contained type,\n-      // but unique boxes can't be implicitly copyable.\n-      ty_uniq(tm) => remove_implicit(mutable_type_kind(cx, tm)),\n+            ty_estr(vstore_fixed(_)) => {\n+                TC_NONE\n+            }\n \n-      // Implicit copyability of vecs is configurable\n-      ty_evec(tm, vstore_uniq) => {\n-          if cx.vecs_implicitly_copyable {\n-              mutable_type_kind(cx, tm)\n-          } else {\n-              remove_implicit(mutable_type_kind(cx, tm))\n-          }\n-      }\n+            ty_rec(ref flds) => {\n+                flds.foldl(\n+                    TC_NONE,\n+                    |tc, f| tc + tc_mt(cx, f.mt, cache))\n+            }\n \n-      // Slices, refcounted evecs are copyable; uniques depend on the their\n-      // contained type, but aren't implicitly copyable.  Fixed vectors have\n-      // the kind of the element they contain, taking mutability into account.\n-      ty_evec(tm, vstore_box) => {\n-        remove_owned(kind_safe_for_default_mode() | mutable_type_kind(cx, tm))\n-      }\n-      ty_evec(tm, vstore_slice(re_static)) => {\n-        kind_safe_for_default_mode() | mutable_type_kind(cx, tm)\n-      }\n-      ty_evec(tm, vstore_slice(_)) => {\n-        remove_durable_owned(kind_safe_for_default_mode() |\n-                           mutable_type_kind(cx, tm))\n-      }\n-      ty_evec(tm, vstore_fixed(_)) => {\n-        mutable_type_kind(cx, tm)\n-      }\n+            ty_struct(did, ref substs) => {\n+                let flds = struct_fields(cx, did, substs);\n+                let flds_tc = flds.foldl(\n+                    TC_NONE,\n+                    |tc, f| tc + tc_mt(cx, f.mt, cache));\n+                if ty::has_dtor(cx, did) {\n+                    flds_tc + TC_DTOR\n+                } else {\n+                    flds_tc\n+                }\n+            }\n \n-      // All estrs are copyable; uniques and interiors are sendable.\n-      ty_estr(vstore_box) => {\n-        kind_safe_for_default_mode() | kind_const() | kind_durable()\n-      }\n-      ty_estr(vstore_slice(re_static)) => {\n-        kind_safe_for_default_mode() | kind_owned_copy() | kind_const()\n-      }\n-      ty_estr(vstore_slice(_)) => {\n-        kind_safe_for_default_mode() | kind_const()\n-      }\n-      ty_estr(vstore_fixed(_)) => {\n-        kind_safe_for_default_mode_send() | kind_const() | kind_durable()\n-      }\n+            ty_tup(ref tys) => {\n+                tys.foldl(TC_NONE, |tc, ty| *tc + tc_ty(cx, *ty, cache))\n+            }\n \n-      // Records lower to the lowest of their members.\n-      ty_rec(flds) => {\n-        let mut lowest = kind_top();\n-        for flds.each |f| {\n-            lowest = lower_kind(lowest, mutable_type_kind(cx, f.mt));\n-        }\n-        lowest\n-      }\n+            ty_enum(did, ref substs) => {\n+                let variants = substd_enum_variants(cx, did, substs);\n+                if variants.is_empty() {\n+                    // we somewhat arbitrary declare that empty enums\n+                    // are non-copyable\n+                    TC_EMPTY_ENUM\n+                } else {\n+                    variants.foldl(TC_NONE, |tc, variant| {\n+                        variant.args.foldl(\n+                            *tc,\n+                            |tc, arg_ty| *tc + tc_ty(cx, *arg_ty, cache))\n+                    })\n+                }\n+            }\n \n-      ty_struct(did, ref substs) => {\n-        // Structs are sendable if all their fields are sendable,\n-        // likewise for copyable...\n-        // also factor out this code, copied from the records case\n-        let mut lowest = kind_top();\n-        let flds = struct_fields(cx, did, substs);\n-        for flds.each |f| {\n-            lowest = lower_kind(lowest, mutable_type_kind(cx, f.mt));\n-        }\n-        // ...but structs with dtors are never copyable (they can be\n-        // sendable)\n-        if ty::has_dtor(cx, did) {\n-           lowest = remove_copyable(lowest);\n-        }\n-        lowest\n-      }\n+            ty_param(p) => {\n+                // We only ever ask for the kind of types that are defined in\n+                // the current crate; therefore, the only type parameters that\n+                // could be in scope are those defined in the current crate.\n+                // If this assertion failures, it is likely because of a\n+                // failure in the cross-crate inlining code to translate a\n+                // def-id.\n+                assert p.def_id.crate == ast::local_crate;\n+\n+                param_bounds_to_contents(\n+                    cx, cx.ty_param_bounds.get(&p.def_id.node))\n+            }\n \n-      // Tuples lower to the lowest of their members.\n-      ty_tup(tys) => {\n-        let mut lowest = kind_top();\n-        for tys.each |ty| { lowest = lower_kind(lowest, type_kind(cx, *ty)); }\n-        lowest\n-      }\n+            ty_self => {\n+                // Currently, self is not bounded, so we must assume the\n+                // worst.  But in the future we should examine the super\n+                // traits.\n+                //\n+                // FIXME(#4678)---self should just be a ty param\n+                TC_ALL\n+            }\n \n-      // Enums lower to the lowest of their variants.\n-      ty_enum(did, ref substs) => {\n-        let mut lowest = kind_top();\n-        let variants = enum_variants(cx, did);\n-        if variants.is_empty() {\n-            lowest = kind_owned_only() | kind_durable();\n-        } else {\n-            for variants.each |variant| {\n-                for variant.args.each |aty| {\n-                    // Perform any type parameter substitutions.\n-                    let arg_ty = subst(cx, substs, *aty);\n-                    lowest = lower_kind(lowest, type_kind(cx, arg_ty));\n-                    if lowest == kind_noncopyable() { break; }\n-                }\n+            ty_infer(_) => {\n+                // This occurs during coherence, but shouldn't occur at other\n+                // times.\n+                TC_ALL\n+            }\n+\n+            ty_trait(_, _, vstore_fixed(_)) |\n+            ty_type |\n+            ty_opaque_closure_ptr(_) |\n+            ty_opaque_box |\n+            ty_unboxed_vec(_) |\n+            ty_err => {\n+                cx.sess.bug(~\"Asked to compute contents of fictitious type\");\n             }\n+        };\n+\n+        if type_size(cx, ty) > 4 {\n+            result = result + TC_BIG;\n         }\n-        lowest\n-      }\n \n-      ty_param(p) => {\n-          // We only ever ask for the kind of types that are defined in the\n-          // current crate; therefore, the only type parameters that could be\n-          // in scope are those defined in the current crate.  If this\n-          // assertion failures, it is likely because of a failure in the\n-          // cross-crate inlining code to translate a def-id.\n-          assert p.def_id.crate == ast::local_crate;\n+        debug!(\"result = %s\", result.to_str());\n \n-          param_bounds_to_kind(cx.ty_param_bounds.get(&p.def_id.node))\n-      }\n+        cache.insert(ty_id, result);\n+        return result;\n+    }\n \n-      // self is a special type parameter that can only appear in traits; it\n-      // is never bounded in any way, hence it has the bottom kind.\n-      ty_self => kind_noncopyable(),\n+    fn tc_mt(cx: ctxt,\n+             mt: mt,\n+             cache: &mut LinearMap<uint, TypeContents>) -> TypeContents\n+    {\n+        let mc = if mt.mutbl == m_mutbl {TC_MUTABLE} else {TC_NONE};\n+        mc + tc_ty(cx, mt.ty, cache)\n+    }\n \n-      ty_infer(_) => {\n-        if allow_ty_var {\n-            kind_top()\n+    fn borrowed_contents(region: ty::Region,\n+                         mutbl: ast::mutability) -> TypeContents\n+    {\n+        let mc = if mutbl == m_mutbl {\n+            TC_MUTABLE + TC_BORROWED_MUT\n         } else {\n-            cx.sess.bug(~\"Asked to compute kind of a type variable\")\n-        }\n-      }\n+            TC_NONE\n+        };\n+        let rc = if region != ty::re_static {\n+            TC_BORROWED_POINTER\n+        } else {\n+            TC_NONE\n+        };\n+        mc + rc\n+    }\n \n-      ty_type | ty_opaque_closure_ptr(_)\n-      | ty_opaque_box | ty_unboxed_vec(_) | ty_err => {\n-        cx.sess.bug(~\"Asked to compute kind of fictitious type\");\n-      }\n-    };\n+    fn nonowned(pointee: TypeContents) -> TypeContents {\n+        /*!\n+         *\n+         * Given a non-owning pointer to some type `T` with\n+         * contents `pointee` (like `@T` or\n+         * `&T`), returns the relevant bits that\n+         * apply to the owner of the pointer.\n+         */\n \n-    // arbitrary threshold to prevent by-value copying of big records\n-    if kind_is_safe_for_default_mode(result) {\n-        if type_size(cx, ty) > 4 {\n-            result = result - kind_(KIND_MASK_DEFAULT_MODE);\n-        }\n+        let mask = TC_MUTABLE.bits | TC_BORROWED_POINTER.bits;\n+        TypeContents {bits: pointee.bits & mask}\n     }\n \n-    cx.kind_cache.insert(ty, result);\n-    return result;\n-}\n+    fn closure_contents(cty: &ClosureTy) -> TypeContents {\n+        let st = match cty.sigil {\n+            ast::BorrowedSigil => TC_BORROWED_POINTER,\n+            ast::ManagedSigil => TC_MANAGED,\n+            ast::OwnedSigil => TC_OWNED_CLOSURE\n+        };\n+        let rt = borrowed_contents(cty.region, m_imm);\n+        let ot = match cty.onceness {\n+            ast::Once => TC_ONCE_CLOSURE,\n+            ast::Many => TC_NONE\n+        };\n+        st + rt + ot\n+    }\n+\n+    fn param_bounds_to_contents(cx: ctxt,\n+                                bounds: param_bounds) -> TypeContents\n+    {\n+        debug!(\"param_bounds_to_contents()\");\n+        let _i = indenter();\n+\n+        let r = bounds.foldl(TC_ALL, |tc, bound| {\n+            debug!(\"tc = %s, bound = %?\", tc.to_str(), bound);\n+            match *bound {\n+                bound_copy => tc - TypeContents::nonimplicitly_copyable(cx),\n+                bound_durable => tc - TypeContents::nondurable(cx),\n+                bound_owned => tc - TypeContents::nonowned(cx),\n+                bound_const => tc - TypeContents::nonconst(cx),\n+                bound_trait(_) => *tc\n+            }\n+        });\n \n-pub fn type_implicitly_moves(cx: ctxt, ty: t) -> bool {\n-    let kind = type_kind(cx, ty);\n-    !(kind_can_be_copied(kind) && kind_can_be_implicitly_copied(kind))\n-}\n+        debug!(\"result = %s\", r.to_str());\n+        return r;\n+    }\n \n-/// gives a rough estimate of how much space it takes to represent\n-/// an instance of `ty`.  Used for the mode transition.\n-fn type_size(cx: ctxt, ty: t) -> uint {\n-    match /*bad*/copy get(ty).sty {\n-      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_ptr(_) | ty_box(_) | ty_uniq(_) | ty_estr(vstore_uniq) |\n-      ty_trait(*) | ty_rptr(*) | ty_evec(_, vstore_uniq) |\n-      ty_evec(_, vstore_box) | ty_estr(vstore_box) => {\n-        1\n-      }\n+    /// gives a rough estimate of how much space it takes to represent\n+    /// an instance of `ty`.  Used for the mode transition.\n+    fn type_size(cx: ctxt, ty: t) -> uint {\n+        match /*bad*/copy get(ty).sty {\n+          ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+          ty_ptr(_) | ty_box(_) | ty_uniq(_) | ty_estr(vstore_uniq) |\n+          ty_trait(*) | ty_rptr(*) | ty_evec(_, vstore_uniq) |\n+          ty_evec(_, vstore_box) | ty_estr(vstore_box) => {\n+            1\n+          }\n \n-      ty_evec(_, vstore_slice(_)) |\n-      ty_estr(vstore_slice(_)) |\n-      ty_bare_fn(*) |\n-      ty_closure(*) => {\n-        2\n-      }\n+          ty_evec(_, vstore_slice(_)) |\n+          ty_estr(vstore_slice(_)) |\n+          ty_bare_fn(*) |\n+          ty_closure(*) => {\n+            2\n+          }\n \n-      ty_evec(t, vstore_fixed(n)) => {\n-        type_size(cx, t.ty) * n\n-      }\n+          ty_evec(t, vstore_fixed(n)) => {\n+            type_size(cx, t.ty) * n\n+          }\n \n-      ty_estr(vstore_fixed(n)) => {\n-        n\n-      }\n+          ty_estr(vstore_fixed(n)) => {\n+            n\n+          }\n \n-      ty_rec(flds) => {\n-        flds.foldl(0, |s, f| *s + type_size(cx, f.mt.ty))\n-      }\n+          ty_rec(flds) => {\n+            flds.foldl(0, |s, f| *s + type_size(cx, f.mt.ty))\n+          }\n \n-      ty_struct(did, ref substs) => {\n-        let flds = struct_fields(cx, did, substs);\n-        flds.foldl(0, |s, f| *s + type_size(cx, f.mt.ty))\n-      }\n+          ty_struct(did, ref substs) => {\n+            let flds = struct_fields(cx, did, substs);\n+            flds.foldl(0, |s, f| *s + type_size(cx, f.mt.ty))\n+          }\n \n-      ty_tup(tys) => {\n-        tys.foldl(0, |s, t| *s + type_size(cx, *t))\n-      }\n+          ty_tup(tys) => {\n+            tys.foldl(0, |s, t| *s + type_size(cx, *t))\n+          }\n \n-      ty_enum(did, ref substs) => {\n-        let variants = substd_enum_variants(cx, did, substs);\n-        variants.foldl( // find max size of any variant\n-            0,\n-            |m, v| uint::max(*m,\n-                             // find size of this variant:\n-                             v.args.foldl(0, |s, a| *s + type_size(cx, *a))))\n-      }\n+          ty_enum(did, ref substs) => {\n+            let variants = substd_enum_variants(cx, did, substs);\n+            variants.foldl( // find max size of any variant\n+                0,\n+                |m, v| uint::max(\n+                    *m,\n+                    // find size of this variant:\n+                    v.args.foldl(0, |s, a| *s + type_size(cx, *a))))\n+          }\n \n-      ty_param(_) | ty_self => {\n-        1\n-      }\n+          ty_param(_) | ty_self => {\n+            1\n+          }\n \n-      ty_infer(_) => {\n-        cx.sess.bug(~\"Asked to compute kind of a type variable\");\n-      }\n-      ty_type | ty_opaque_closure_ptr(_)\n-      | ty_opaque_box | ty_unboxed_vec(_) | ty_err => {\n-        cx.sess.bug(~\"Asked to compute kind of fictitious type\");\n-      }\n+          ty_infer(_) => {\n+            cx.sess.bug(~\"Asked to compute kind of a type variable\");\n+          }\n+          ty_type | ty_opaque_closure_ptr(_)\n+          | ty_opaque_box | ty_unboxed_vec(_) | ty_err => {\n+            cx.sess.bug(~\"Asked to compute kind of fictitious type\");\n+          }\n+        }\n     }\n }\n \n+pub fn type_moves_by_default(cx: ctxt, ty: t) -> bool {\n+    type_contents(cx, ty).moves_by_default(cx)\n+}\n+\n // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n     fn type_requires(cx: ctxt, seen: @mut ~[def_id],\n@@ -2678,12 +2669,6 @@ impl arg : to_bytes::IterBytes {\n     }\n }\n \n-impl Kind : to_bytes::IterBytes {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        (**self).iter_bytes(lsb0, f)\n-    }\n-}\n-\n impl FnSig : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.inputs,\n@@ -4549,12 +4534,6 @@ impl param_bound : cmp::Eq {\n     pure fn ne(&self, other: &param_bound) -> bool { !self.eq(other) }\n }\n \n-impl Kind : cmp::Eq {\n-    pure fn eq(&self, other: &Kind) -> bool { *(*self) == *(*other) }\n-    pure fn ne(&self, other: &Kind) -> bool { *(*self) != *(*other) }\n-}\n-\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "1790bd199250b49578c85e4ce3f0167ef0ff76b8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -24,13 +24,13 @@ use metadata::cstore::{CStore, iter_crate_data};\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::resolve::{Impl, MethodInfo};\n use middle::ty::{ProvidedMethodSource, ProvidedMethodInfo, bound_copy, get};\n-use middle::ty::{kind_can_be_copied, lookup_item_type, param_bounds, subst};\n+use middle::ty::{lookup_item_type, param_bounds, subst};\n use middle::ty::{substs, t, ty_bool, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_estr, ty_evec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_opaque_box, ty_param, ty_param_bounds_and_ty, ty_ptr};\n use middle::ty::{ty_rec, ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_type, ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n-use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_kind_ext};\n+use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec};\n use middle::ty::{type_is_ty_var};\n use middle::ty;\n use middle::typeck::CrateCtxt;\n@@ -578,11 +578,10 @@ pub impl CoherenceChecker {\n                                 for bounds.each |bound| {\n                                     match *bound {\n                                         bound_copy => {\n-                                            let kind = type_kind_ext(\n+                                            if !ty::type_is_copyable(\n                                                 self.inference_context.tcx,\n-                                                resolved_ty,\n-                                                true);\n-                                            if !kind_can_be_copied(kind) {\n+                                                resolved_ty)\n+                                            {\n                                                 might_unify = false;\n                                                 break;\n                                             }"}, {"sha": "404f1bcda9902f5a389c7f9d7c7594240499ff1e", "filename": "src/libstd/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -832,7 +832,7 @@ pub impl Decoder: serialize::Decoder {\n     fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T {\n         debug!(\"read_owned_vec()\");\n         let len = match *self.peek() {\n-            List(list) => list.len(),\n+            List(ref list) => list.len(),\n             _ => die!(~\"not a list\"),\n         };\n         let res = f(len);"}, {"sha": "112423a073e9e0746c2d4efe92f3490ca9cc2a98", "filename": "src/test/compile-fail/bad-method-typaram-kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn foo<T>() {\n-    1u.bar::<T>(); //~ ERROR: missing `copy`\n+    1u.bar::<T>(); //~ ERROR: does not fulfill `Copy`\n }\n \n trait bar {"}, {"sha": "eb135e188936318d4773b0fcf6a35087f17d4aab", "filename": "src/test/compile-fail/copy-a-resource.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: copying a noncopyable value\n-\n struct foo {\n   i: int,\n }\n@@ -24,4 +22,9 @@ fn foo(i:int) -> foo {\n     }\n }\n \n-fn main() { let x = move foo(10); let y = copy x; log(error, x); }\n+fn main() {\n+    let x = move foo(10);\n+    let _y = copy x;\n+    //~^ ERROR copying a value of non-copyable type `foo`\n+    log(error, x);\n+}"}, {"sha": "402e8ee831f9068e9e9a9803026e1e95307ec7f9", "filename": "src/test/compile-fail/issue-2548.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -34,7 +34,7 @@ fn main() {\n         let mut res = foo(x);\n \n         let mut v = ~[mut];\n-        v = move ~[mut (move res)] + v; //~ ERROR instantiating a type parameter with an incompatible type (needs `copy`, got `&static`, missing `copy`)\n+        v = move ~[mut (move res)] + v; //~ ERROR does not fulfill `Copy`\n         assert (v.len() == 2);\n     }\n "}, {"sha": "f2ea4faf48212bf732b6ff01da9c10851c9c540d", "filename": "src/test/compile-fail/issue-2823.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -20,6 +20,6 @@ impl C : Drop {\n \n fn main() {\n     let c = C{ x: 2};\n-    let d = copy c; //~ ERROR copying a noncopyable value\n+    let d = copy c; //~ ERROR copying a value of non-copyable type `C`\n     error!(\"%?\", d.x);\n }"}, {"sha": "f04740bae4c53f0b52cea42b495555913445723d", "filename": "src/test/compile-fail/kindck-nonsendable-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -12,7 +12,7 @@ fn foo(_x: @uint) {}\n \n fn main() {\n     let x = @3u;\n-    let _ = fn~() { foo(x); }; //~ ERROR not a sendable value\n-    let _ = fn~(copy x) { foo(x); }; //~ ERROR not a sendable value\n-    let _ = fn~(move x) { foo(x); }; //~ ERROR not a sendable value\n+    let _ = fn~() { foo(x); }; //~ ERROR value has non-owned type `@uint`\n+    let _ = fn~(copy x) { foo(x); }; //~ ERROR value has non-owned type `@uint`\n+    let _ = fn~(move x) { foo(x); }; //~ ERROR value has non-owned type `@uint`\n }\n\\ No newline at end of file"}, {"sha": "65f6f837c83a0d9c775cff261cf48d645e553dac", "filename": "src/test/compile-fail/kindck-owned.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -18,12 +18,12 @@ fn copy2<T: Copy &static>(t: T) -> fn@() -> T {\n \n fn main() {\n     let x = &3;\n-    copy2(&x); //~ ERROR missing `&static`\n+    copy2(&x); //~ ERROR does not fulfill `&static`\n \n     copy2(@3);\n-    copy2(@&x); //~ ERROR missing `&static`\n+    copy2(@&x); //~ ERROR does not fulfill `&static`\n \n     copy2(fn@() {});\n-    copy2(fn~() {}); //~ ERROR missing `copy`\n-    copy2(fn&() {}); //~ ERROR missing `&static`\n+    copy2(fn~() {}); //~ ERROR does not fulfill `Copy`\n+    copy2(fn&() {}); //~ ERROR does not fulfill `&static`\n }"}, {"sha": "351a63f062d7e9d3317c7d7b5665f52525526874", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -68,5 +68,5 @@ impl r : Drop {\n \n fn main() {\n     let x = r { x: () };\n-    fn@(move x) { copy x; }; //~ ERROR copying a noncopyable value\n+    fn@(move x) { copy x; }; //~ ERROR copying a value of non-copyable type\n }"}, {"sha": "4af3e1cbe8669a5e330fdc1ea0473cebd5b8493f", "filename": "src/test/compile-fail/moves-based-on-type-cyclic-types-issue-4821.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-cyclic-types-issue-4821.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-cyclic-types-issue-4821.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-cyclic-types-issue-4821.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test for a subtle failure computing kinds of cyclic types, in which\n+// temporary kinds wound up being stored in a cache and used later.\n+// See middle::ty::type_contents() for more information.\n+\n+extern mod std;\n+use core::cmp::Ord;\n+use core::option::swap_unwrap;\n+\n+struct List { key: int, next: Option<~List> }\n+\n+fn foo(node: ~List) -> int {\n+    let r = match node.next {\n+        Some(right) => consume(right),\n+        None => 0\n+    };\n+    consume(node) + r //~ ERROR use of partially moved value: `node`\n+}\n+\n+fn consume(v: ~List) -> int {\n+    v.key\n+}\n+\n+fn main() {}\n+"}, {"sha": "d0c216fe23122efa3cd443bb772be39688a1b24a", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -29,7 +29,7 @@ fn main() {\n \n     do task::spawn {\n         let mut y = None;\n-        *x <-> y; //~ ERROR not a sendable value\n+        *x <-> y; //~ ERROR value has non-owned type\n         log(error, y);\n     }\n }"}, {"sha": "84f34d0e9bdfb90e1f4f6be4c785fe6ecf701777", "filename": "src/test/compile-fail/non-const.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fnon-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fnon-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-const.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -42,14 +42,14 @@ fn r2(x:@mut int) -> r2 {\n \n fn main() {\n     foo({f: 3});\n-    foo({mut f: 3}); //~ ERROR missing `const`\n+    foo({mut f: 3}); //~ ERROR does not fulfill `Const`\n     foo(~[1]);\n-    foo(~[mut 1]); //~ ERROR missing `const`\n+    foo(~[mut 1]); //~ ERROR does not fulfill `Const`\n     foo(~1);\n-    foo(~mut 1); //~ ERROR missing `const`\n+    foo(~mut 1); //~ ERROR does not fulfill `Const`\n     foo(@1);\n-    foo(@mut 1); //~ ERROR missing `const`\n+    foo(@mut 1); //~ ERROR does not fulfill `Const`\n     foo(r(1)); // this is okay now.\n-    foo(r2(@mut 1)); //~ ERROR missing `const`\n-    foo({f: {mut f: 1}}); //~ ERROR missing `const`\n+    foo(r2(@mut 1)); //~ ERROR does not fulfill `Const`\n+    foo({f: {mut f: 1}}); //~ ERROR does not fulfill `Const`\n }"}, {"sha": "d8192a24652e68e37e06d56eb3b88b0b2fc85f85", "filename": "src/test/compile-fail/non-copyable-void.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -13,6 +13,6 @@ fn main() {\n     let y : *libc::c_void = x as *libc::c_void;\n     unsafe {\n         let _z = copy *y;\n-        //~^ ERROR copying a noncopyable value\n+        //~^ ERROR copying a value of non-copyable type\n     }\n }"}, {"sha": "360180ee4557e1dd5579dfe55ef119758143f3b5", "filename": "src/test/compile-fail/noncopyable-class.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: copying a noncopyable value\n-\n // Test that a class with a non-copyable field can't be\n // copied\n struct bar {\n@@ -38,4 +36,8 @@ fn foo(i:int) -> foo {\n     }\n }\n \n-fn main() { let x = move foo(10); let y = copy x; log(error, x); }\n+fn main() {\n+    let x = move foo(10);\n+    let _y = copy x; //~ ERROR copying a value of non-copyable type\n+    log(error, x);\n+}"}, {"sha": "a123cf9fc6f305b5c6a73a2d9dea3cccbfa2f052", "filename": "src/test/compile-fail/noncopyable-match-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let x = Some(private::exclusive(false));\n     match x {\n-        Some(copy z) => { //~ ERROR copying a noncopyable value\n+        Some(copy z) => { //~ ERROR copying a value of non-copyable type\n             do z.with |b| { assert !*b; }\n         }\n         None => die!()"}, {"sha": "80cf409f23986027daf253f44e19fd00c798e05f", "filename": "src/test/compile-fail/pinned-deep-copy.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: copying a noncopyable value\n-\n struct r {\n   i: @mut int,\n }\n@@ -31,7 +29,7 @@ fn main() {\n     {\n         // Can't do this copy\n         let x = ~~~{y: r(i)};\n-        let z = copy x;\n+        let _z = copy x; //~ ERROR copying a value of non-copyable type\n         log(debug, x);\n     }\n     log(error, *i);"}, {"sha": "c9dc77ce4d21b98ef5b7a343c6912704b5e083f7", "filename": "src/test/compile-fail/record-with-resource.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Frecord-with-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Frecord-with-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecord-with-resource.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: copying a noncopyable value\n-\n struct my_resource {\n   x: int,\n }\n@@ -29,7 +27,7 @@ fn my_resource(x: int) -> my_resource {\n fn main() {\n     {\n         let a = {x: 0, y: my_resource(20)};\n-        let b = {x: 2,.. copy a};\n+        let b = {x: 2,.. copy a}; //~ ERROR copying a value of non-copyable type\n         log(error, (a, b));\n     }\n }"}, {"sha": "58c07cc8ea6dba3cd9302d8ac6844ccd2eaddaa3", "filename": "src/test/compile-fail/repeat-to-run-dtor-twice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Frepeat-to-run-dtor-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Frepeat-to-run-dtor-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat-to-run-dtor-twice.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -24,6 +24,6 @@ impl Foo : Drop {\n \n fn main() {\n     let a = Foo { x: 3 };\n-    let _ = [ a, ..5 ];     //~ ERROR copying a noncopyable value\n+    let _ = [ a, ..5 ];     //~ ERROR copying a value of non-copyable type\n }\n "}, {"sha": "010161181f53ec7b3f6c4fe3d368bd2b892fc6fd", "filename": "src/test/compile-fail/unique-object-noncopyable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Funique-object-noncopyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Funique-object-noncopyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-object-noncopyable.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n trait Foo {\n-    fn f();\n+    fn f(&self);\n }\n \n struct Bar {\n@@ -21,14 +21,14 @@ impl Bar : Drop {\n }\n \n impl Bar : Foo {\n-    fn f() {\n+    fn f(&self) {\n         io::println(\"hi\");\n     }\n }\n \n fn main() {\n     let x = ~Bar { x: 10 };\n-    let y = (move x) as ~Foo;   //~ ERROR uniquely-owned trait objects must be copyable\n-    let _z = copy y;\n+    let y: ~Foo = x as ~Foo;\n+    let _z = copy y; //~ ERROR copying a value of non-copyable type\n }\n "}, {"sha": "0211fd3c01166c1435b34f2579686c535cd183a1", "filename": "src/test/compile-fail/unique-pinned-nocopy.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: copying a noncopyable value\n-\n struct r {\n   b:bool,\n }\n@@ -20,6 +18,6 @@ impl r : Drop {\n \n fn main() {\n     let i = move ~r { b: true };\n-    let j = copy i;\n+    let _j = copy i; //~ ERROR copying a value of non-copyable type\n     log(debug, i);\n }"}, {"sha": "25c42ab4adde508f205c21a581c52e4375075563", "filename": "src/test/compile-fail/unique-unique-kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -13,5 +13,5 @@ fn f<T: Owned>(_i: T) {\n \n fn main() {\n     let i = ~@100;\n-    f(move i); //~ ERROR missing `owned`\n+    f(move i); //~ ERROR does not fulfill `Owned`\n }"}, {"sha": "a97f47551e1ddc7e75f2ce28aa8470ff65c8c6a9", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: copying a noncopyable value\n-\n struct r {\n   i: @mut int,\n }\n@@ -20,7 +18,7 @@ impl r : Drop {\n     }\n }\n \n-fn f<T>(+i: ~[T], +j: ~[T]) {\n+fn f<T>(+_i: ~[T], +_j: ~[T]) {\n }\n \n fn main() {\n@@ -29,6 +27,8 @@ fn main() {\n     let r1 = move ~[~r { i: i1 }];\n     let r2 = move ~[~r { i: i2 }];\n     f(copy r1, copy r2);\n+    //~^ ERROR copying a value of non-copyable type\n+    //~^^ ERROR copying a value of non-copyable type\n     log(debug, (r2, *i1));\n     log(debug, (r1, *i2));\n }"}, {"sha": "e660884e40b9ef02df36009d9438cbfa5e60def7", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -25,6 +25,6 @@ fn foo(i:int, j: @~str) -> foo {\n \n fn main() {\n   let cat = ~\"kitty\";\n-    let (_, ch) = pipes::stream(); //~ ERROR missing `owned`\n-  ch.send(foo(42, @(move cat))); //~ ERROR missing `owned`\n+    let (_, ch) = pipes::stream(); //~ ERROR does not fulfill `Owned`\n+  ch.send(foo(42, @(move cat))); //~ ERROR does not fulfill `Owned`\n }"}, {"sha": "6e789b7ff1ed1835889b911c3336fea4ce3412a6", "filename": "src/test/run-pass/explicit-self-objects-uniq.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-uniq.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -26,8 +26,6 @@ pub fn main() {\n     let x = ~S { x: 3 };\n     let y = x as ~Foo;\n     y.f();\n-    y.f();\n-    y.f();\n }\n \n "}, {"sha": "4ad8ab38e4b8d3ea6d3442053a4752fde1e6ae98", "filename": "src/test/run-pass/unique-object.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Frun-pass%2Funique-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90abd58799e7551682c193c0b0d1697ee618f95/src%2Ftest%2Frun-pass%2Funique-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-object.rs?ref=d90abd58799e7551682c193c0b0d1697ee618f95", "patch": "@@ -9,24 +9,22 @@\n // except according to those terms.\n \n trait Foo {\n-    fn f();\n+    fn f(&self) -> int;\n }\n \n struct Bar {\n     x: int\n }\n \n impl Bar : Foo {\n-    fn f() {\n-        io::println(\"hi\");\n+    fn f(&self) -> int {\n+        self.x\n     }\n }\n \n pub fn main() {\n     let x = ~Bar { x: 10 };\n     let y = x as ~Foo;\n-    let z = copy y;\n-    y.f();\n-    z.f();\n+    assert y.f() == 10;\n }\n "}]}