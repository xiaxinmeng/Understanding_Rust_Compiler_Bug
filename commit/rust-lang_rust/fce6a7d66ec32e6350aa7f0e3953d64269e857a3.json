{"sha": "fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "node_id": "C_kwDOAAsO6NoAKGZjZTZhN2Q2NmVjMzJlNjM1MGFhN2YwZTM5NTNkNjQyNjllODU3YTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-30T14:52:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-30T14:52:02Z"}, "message": "Auto merge of #101195 - Dylan-DPC:rollup-rhjaz6r, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #99517 (Display raw pointer as *{mut,const} T instead of *-ptr in errors)\n - #99928 (Do not leak type variables from opaque type relation)\n - #100473 (Attempt to normalize `FnDef` signature in `InferCtxt::cmp`)\n - #100653 (Move the cast_float_to_int fallback code to GCC)\n - #100941 (Point at the string inside literal and mention if we need string inte\u2026)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "d4d26ae55d9a074fae36504b1e371ce7aef739d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4d26ae55d9a074fae36504b1e371ce7aef739d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "html_url": "https://github.com/rust-lang/rust/commit/fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "230a8ee364b693c286a2187e56239cd2cc3be318", "url": "https://api.github.com/repos/rust-lang/rust/commits/230a8ee364b693c286a2187e56239cd2cc3be318", "html_url": "https://github.com/rust-lang/rust/commit/230a8ee364b693c286a2187e56239cd2cc3be318"}, {"sha": "467d2c18334eaedb5b8adda7a0b8a8a20d2ccb56", "url": "https://api.github.com/repos/rust-lang/rust/commits/467d2c18334eaedb5b8adda7a0b8a8a20d2ccb56", "html_url": "https://github.com/rust-lang/rust/commit/467d2c18334eaedb5b8adda7a0b8a8a20d2ccb56"}], "stats": {"total": 707, "additions": 501, "deletions": 206}, "files": [{"sha": "6a375528347f23aeedf3f059e4b1f740f623aa75", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -3370,7 +3370,6 @@ dependencies = [\n  \"object 0.29.0\",\n  \"pathdiff\",\n  \"regex\",\n- \"rustc_apfloat\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_attr\","}, {"sha": "6994eeb00c3e2e6de92639e6039d5e00e8d0c63a", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 169, "deletions": 5, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -15,8 +15,11 @@ use gccjit::{\n     Type,\n     UnaryOp,\n };\n+use rustc_apfloat::{ieee, Float, Round, Status};\n use rustc_codegen_ssa::MemFlags;\n-use rustc_codegen_ssa::common::{AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope};\n+use rustc_codegen_ssa::common::{\n+    AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope, TypeKind,\n+};\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{\n@@ -31,6 +34,7 @@ use rustc_codegen_ssa::traits::{\n     StaticBuilderMethods,\n };\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_middle::bug;\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_span::Span;\n@@ -1271,12 +1275,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         val\n     }\n \n-    fn fptoui_sat(&mut self, _val: RValue<'gcc>, _dest_ty: Type<'gcc>) -> Option<RValue<'gcc>> {\n-        None\n+    fn fptoui_sat(&mut self, val: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.fptoint_sat(false, val, dest_ty)\n     }\n \n-    fn fptosi_sat(&mut self, _val: RValue<'gcc>, _dest_ty: Type<'gcc>) -> Option<RValue<'gcc>> {\n-        None\n+    fn fptosi_sat(&mut self, val: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.fptoint_sat(true, val, dest_ty)\n     }\n \n     fn instrprof_increment(&mut self, _fn_name: RValue<'gcc>, _hash: RValue<'gcc>, _num_counters: RValue<'gcc>, _index: RValue<'gcc>) {\n@@ -1285,6 +1289,166 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n }\n \n impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n+    fn fptoint_sat(&mut self, signed: bool, val: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        let src_ty = self.cx.val_ty(val);\n+        let (float_ty, int_ty) = if self.cx.type_kind(src_ty) == TypeKind::Vector {\n+            assert_eq!(self.cx.vector_length(src_ty), self.cx.vector_length(dest_ty));\n+            (self.cx.element_type(src_ty), self.cx.element_type(dest_ty))\n+        } else {\n+            (src_ty, dest_ty)\n+        };\n+\n+        // FIXME(jistone): the following was originally the fallback SSA implementation, before LLVM 13\n+        // added native `fptosi.sat` and `fptoui.sat` conversions, but it was used by GCC as well.\n+        // Now that LLVM always relies on its own, the code has been moved to GCC, but the comments are\n+        // still LLVM-specific. This should be updated, and use better GCC specifics if possible.\n+\n+        let int_width = self.cx.int_width(int_ty);\n+        let float_width = self.cx.float_width(float_ty);\n+        // LLVM's fpto[su]i returns undef when the input val is infinite, NaN, or does not fit into the\n+        // destination integer type after rounding towards zero. This `undef` value can cause UB in\n+        // safe code (see issue #10184), so we implement a saturating conversion on top of it:\n+        // Semantically, the mathematical value of the input is rounded towards zero to the next\n+        // mathematical integer, and then the result is clamped into the range of the destination\n+        // integer type. Positive and negative infinity are mapped to the maximum and minimum value of\n+        // the destination integer type. NaN is mapped to 0.\n+        //\n+        // Define f_min and f_max as the largest and smallest (finite) floats that are exactly equal to\n+        // a value representable in int_ty.\n+        // They are exactly equal to int_ty::{MIN,MAX} if float_ty has enough significand bits.\n+        // Otherwise, int_ty::MAX must be rounded towards zero, as it is one less than a power of two.\n+        // int_ty::MIN, however, is either zero or a negative power of two and is thus exactly\n+        // representable. Note that this only works if float_ty's exponent range is sufficiently large.\n+        // f16 or 256 bit integers would break this property. Right now the smallest float type is f32\n+        // with exponents ranging up to 127, which is barely enough for i128::MIN = -2^127.\n+        // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n+        // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n+        // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n+        let int_max = |signed: bool, int_width: u64| -> u128 {\n+            let shift_amount = 128 - int_width;\n+            if signed { i128::MAX as u128 >> shift_amount } else { u128::MAX >> shift_amount }\n+        };\n+        let int_min = |signed: bool, int_width: u64| -> i128 {\n+            if signed { i128::MIN >> (128 - int_width) } else { 0 }\n+        };\n+\n+        let compute_clamp_bounds_single = |signed: bool, int_width: u64| -> (u128, u128) {\n+            let rounded_min =\n+                ieee::Single::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n+            assert_eq!(rounded_min.status, Status::OK);\n+            let rounded_max =\n+                ieee::Single::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n+            assert!(rounded_max.value.is_finite());\n+            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n+        };\n+        let compute_clamp_bounds_double = |signed: bool, int_width: u64| -> (u128, u128) {\n+            let rounded_min =\n+                ieee::Double::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n+            assert_eq!(rounded_min.status, Status::OK);\n+            let rounded_max =\n+                ieee::Double::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n+            assert!(rounded_max.value.is_finite());\n+            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n+        };\n+        // To implement saturation, we perform the following steps:\n+        //\n+        // 1. Cast val to an integer with fpto[su]i. This may result in undef.\n+        // 2. Compare val to f_min and f_max, and use the comparison results to select:\n+        //  a) int_ty::MIN if val < f_min or val is NaN\n+        //  b) int_ty::MAX if val > f_max\n+        //  c) the result of fpto[su]i otherwise\n+        // 3. If val is NaN, return 0.0, otherwise return the result of step 2.\n+        //\n+        // This avoids resulting undef because values in range [f_min, f_max] by definition fit into the\n+        // destination type. It creates an undef temporary, but *producing* undef is not UB. Our use of\n+        // undef does not introduce any non-determinism either.\n+        // More importantly, the above procedure correctly implements saturating conversion.\n+        // Proof (sketch):\n+        // If val is NaN, 0 is returned by definition.\n+        // Otherwise, val is finite or infinite and thus can be compared with f_min and f_max.\n+        // This yields three cases to consider:\n+        // (1) if val in [f_min, f_max], the result of fpto[su]i is returned, which agrees with\n+        //     saturating conversion for inputs in that range.\n+        // (2) if val > f_max, then val is larger than int_ty::MAX. This holds even if f_max is rounded\n+        //     (i.e., if f_max < int_ty::MAX) because in those cases, nextUp(f_max) is already larger\n+        //     than int_ty::MAX. Because val is larger than int_ty::MAX, the return value of int_ty::MAX\n+        //     is correct.\n+        // (3) if val < f_min, then val is smaller than int_ty::MIN. As shown earlier, f_min exactly equals\n+        //     int_ty::MIN and therefore the return value of int_ty::MIN is correct.\n+        // QED.\n+\n+        let float_bits_to_llval = |bx: &mut Self, bits| {\n+            let bits_llval = match float_width {\n+                32 => bx.cx().const_u32(bits as u32),\n+                64 => bx.cx().const_u64(bits as u64),\n+                n => bug!(\"unsupported float width {}\", n),\n+            };\n+            bx.bitcast(bits_llval, float_ty)\n+        };\n+        let (f_min, f_max) = match float_width {\n+            32 => compute_clamp_bounds_single(signed, int_width),\n+            64 => compute_clamp_bounds_double(signed, int_width),\n+            n => bug!(\"unsupported float width {}\", n),\n+        };\n+        let f_min = float_bits_to_llval(self, f_min);\n+        let f_max = float_bits_to_llval(self, f_max);\n+        let int_max = self.cx.const_uint_big(int_ty, int_max(signed, int_width));\n+        let int_min = self.cx.const_uint_big(int_ty, int_min(signed, int_width) as u128);\n+        let zero = self.cx.const_uint(int_ty, 0);\n+\n+        // If we're working with vectors, constants must be \"splatted\": the constant is duplicated\n+        // into each lane of the vector.  The algorithm stays the same, we are just using the\n+        // same constant across all lanes.\n+        let maybe_splat = |bx: &mut Self, val| {\n+            if bx.cx().type_kind(dest_ty) == TypeKind::Vector {\n+                bx.vector_splat(bx.vector_length(dest_ty), val)\n+            } else {\n+                val\n+            }\n+        };\n+        let f_min = maybe_splat(self, f_min);\n+        let f_max = maybe_splat(self, f_max);\n+        let int_max = maybe_splat(self, int_max);\n+        let int_min = maybe_splat(self, int_min);\n+        let zero = maybe_splat(self, zero);\n+\n+        // Step 1 ...\n+        let fptosui_result = if signed { self.fptosi(val, dest_ty) } else { self.fptoui(val, dest_ty) };\n+        let less_or_nan = self.fcmp(RealPredicate::RealULT, val, f_min);\n+        let greater = self.fcmp(RealPredicate::RealOGT, val, f_max);\n+\n+        // Step 2: We use two comparisons and two selects, with %s1 being the\n+        // result:\n+        //     %less_or_nan = fcmp ult %val, %f_min\n+        //     %greater = fcmp olt %val, %f_max\n+        //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n+        //     %s1 = select %greater, int_ty::MAX, %s0\n+        // Note that %less_or_nan uses an *unordered* comparison. This\n+        // comparison is true if the operands are not comparable (i.e., if val is\n+        // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n+        // val is NaN.\n+        //\n+        // Performance note: Unordered comparison can be lowered to a \"flipped\"\n+        // comparison and a negation, and the negation can be merged into the\n+        // select. Therefore, it not necessarily any more expensive than an\n+        // ordered (\"normal\") comparison. Whether these optimizations will be\n+        // performed is ultimately up to the backend, but at least x86 does\n+        // perform them.\n+        let s0 = self.select(less_or_nan, int_min, fptosui_result);\n+        let s1 = self.select(greater, int_max, s0);\n+\n+        // Step 3: NaN replacement.\n+        // For unsigned types, the above step already yielded int_ty::MIN == 0 if val is NaN.\n+        // Therefore we only need to execute this step for signed integer types.\n+        if signed {\n+            // LLVM has no isNaN predicate, so we use (val == val) instead\n+            let cmp = self.fcmp(RealPredicate::RealOEQ, val, val);\n+            self.select(cmp, s1, zero)\n+        } else {\n+            s1\n+        }\n+    }\n+\n     #[cfg(feature=\"master\")]\n     pub fn shuffle_vector(&mut self, v1: RValue<'gcc>, v2: RValue<'gcc>, mask: RValue<'gcc>) -> RValue<'gcc> {\n         let struct_type = mask.get_type().is_struct().expect(\"mask of struct type\");"}, {"sha": "223466fb9b51f26533243aa178b051483b563473", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -19,6 +19,7 @@\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n \n+extern crate rustc_apfloat;\n extern crate rustc_ast;\n extern crate rustc_codegen_ssa;\n extern crate rustc_data_structures;"}, {"sha": "e7e373bf45d11043f9e3ba32bd18d09f10313322", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -725,11 +725,11 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         unsafe { llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, UNNAMED) }\n     }\n \n-    fn fptoui_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n+    fn fptoui_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.fptoint_sat(false, val, dest_ty)\n     }\n \n-    fn fptosi_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n+    fn fptosi_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.fptoint_sat(true, val, dest_ty)\n     }\n \n@@ -1429,12 +1429,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn fptoint_sat(\n-        &mut self,\n-        signed: bool,\n-        val: &'ll Value,\n-        dest_ty: &'ll Type,\n-    ) -> Option<&'ll Value> {\n+    fn fptoint_sat(&mut self, signed: bool, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         let src_ty = self.cx.val_ty(val);\n         let (float_ty, int_ty, vector_length) = if self.cx.type_kind(src_ty) == TypeKind::Vector {\n             assert_eq!(self.cx.vector_length(src_ty), self.cx.vector_length(dest_ty));\n@@ -1459,7 +1454,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n             format!(\"llvm.{}.sat.i{}.f{}\", instr, int_width, float_width)\n         };\n         let f = self.declare_cfn(&name, llvm::UnnamedAddr::No, self.type_func(&[src_ty], dest_ty));\n-        Some(self.call(self.type_func(&[src_ty], dest_ty), f, &[val], None))\n+        self.call(self.type_func(&[src_ty], dest_ty), f, &[val], None)\n     }\n \n     pub(crate) fn landing_pad("}, {"sha": "d868e3d56ba6b33d240fe92b65b7e003ebe45726", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -26,7 +26,6 @@ rustc_arena = { path = \"../rustc_arena\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_middle = { path = \"../rustc_middle\" }\n-rustc_apfloat = { path = \"../rustc_apfloat\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "10cf8948b5a54fc55c73e100fc988f7752d7b607", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 3, "deletions": 154, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -1,6 +1,5 @@\n use super::abi::AbiBuilderMethods;\n use super::asm::AsmBuilderMethods;\n-use super::consts::ConstMethods;\n use super::coverageinfo::CoverageInfoBuilderMethods;\n use super::debuginfo::DebugInfoBuilderMethods;\n use super::intrinsic::IntrinsicCallMethods;\n@@ -15,7 +14,6 @@ use crate::mir::operand::OperandRef;\n use crate::mir::place::PlaceRef;\n use crate::MemFlags;\n \n-use rustc_apfloat::{ieee, Float, Round, Status};\n use rustc_middle::ty::layout::{HasParamEnv, TyAndLayout};\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n@@ -188,8 +186,8 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     fn trunc(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn sext(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n-    fn fptoui_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n-    fn fptosi_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n+    fn fptoui_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+    fn fptosi_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn fptoui(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn fptosi(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn uitofp(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n@@ -223,156 +221,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n             return if signed { self.fptosi(x, dest_ty) } else { self.fptoui(x, dest_ty) };\n         }\n \n-        let try_sat_result =\n-            if signed { self.fptosi_sat(x, dest_ty) } else { self.fptoui_sat(x, dest_ty) };\n-        if let Some(try_sat_result) = try_sat_result {\n-            return try_sat_result;\n-        }\n-\n-        let int_width = self.cx().int_width(int_ty);\n-        let float_width = self.cx().float_width(float_ty);\n-        // LLVM's fpto[su]i returns undef when the input x is infinite, NaN, or does not fit into the\n-        // destination integer type after rounding towards zero. This `undef` value can cause UB in\n-        // safe code (see issue #10184), so we implement a saturating conversion on top of it:\n-        // Semantically, the mathematical value of the input is rounded towards zero to the next\n-        // mathematical integer, and then the result is clamped into the range of the destination\n-        // integer type. Positive and negative infinity are mapped to the maximum and minimum value of\n-        // the destination integer type. NaN is mapped to 0.\n-        //\n-        // Define f_min and f_max as the largest and smallest (finite) floats that are exactly equal to\n-        // a value representable in int_ty.\n-        // They are exactly equal to int_ty::{MIN,MAX} if float_ty has enough significand bits.\n-        // Otherwise, int_ty::MAX must be rounded towards zero, as it is one less than a power of two.\n-        // int_ty::MIN, however, is either zero or a negative power of two and is thus exactly\n-        // representable. Note that this only works if float_ty's exponent range is sufficiently large.\n-        // f16 or 256 bit integers would break this property. Right now the smallest float type is f32\n-        // with exponents ranging up to 127, which is barely enough for i128::MIN = -2^127.\n-        // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n-        // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n-        // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n-        let int_max = |signed: bool, int_width: u64| -> u128 {\n-            let shift_amount = 128 - int_width;\n-            if signed { i128::MAX as u128 >> shift_amount } else { u128::MAX >> shift_amount }\n-        };\n-        let int_min = |signed: bool, int_width: u64| -> i128 {\n-            if signed { i128::MIN >> (128 - int_width) } else { 0 }\n-        };\n-\n-        let compute_clamp_bounds_single = |signed: bool, int_width: u64| -> (u128, u128) {\n-            let rounded_min =\n-                ieee::Single::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n-            assert_eq!(rounded_min.status, Status::OK);\n-            let rounded_max =\n-                ieee::Single::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n-            assert!(rounded_max.value.is_finite());\n-            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n-        };\n-        let compute_clamp_bounds_double = |signed: bool, int_width: u64| -> (u128, u128) {\n-            let rounded_min =\n-                ieee::Double::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n-            assert_eq!(rounded_min.status, Status::OK);\n-            let rounded_max =\n-                ieee::Double::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n-            assert!(rounded_max.value.is_finite());\n-            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n-        };\n-        // To implement saturation, we perform the following steps:\n-        //\n-        // 1. Cast x to an integer with fpto[su]i. This may result in undef.\n-        // 2. Compare x to f_min and f_max, and use the comparison results to select:\n-        //  a) int_ty::MIN if x < f_min or x is NaN\n-        //  b) int_ty::MAX if x > f_max\n-        //  c) the result of fpto[su]i otherwise\n-        // 3. If x is NaN, return 0.0, otherwise return the result of step 2.\n-        //\n-        // This avoids resulting undef because values in range [f_min, f_max] by definition fit into the\n-        // destination type. It creates an undef temporary, but *producing* undef is not UB. Our use of\n-        // undef does not introduce any non-determinism either.\n-        // More importantly, the above procedure correctly implements saturating conversion.\n-        // Proof (sketch):\n-        // If x is NaN, 0 is returned by definition.\n-        // Otherwise, x is finite or infinite and thus can be compared with f_min and f_max.\n-        // This yields three cases to consider:\n-        // (1) if x in [f_min, f_max], the result of fpto[su]i is returned, which agrees with\n-        //     saturating conversion for inputs in that range.\n-        // (2) if x > f_max, then x is larger than int_ty::MAX. This holds even if f_max is rounded\n-        //     (i.e., if f_max < int_ty::MAX) because in those cases, nextUp(f_max) is already larger\n-        //     than int_ty::MAX. Because x is larger than int_ty::MAX, the return value of int_ty::MAX\n-        //     is correct.\n-        // (3) if x < f_min, then x is smaller than int_ty::MIN. As shown earlier, f_min exactly equals\n-        //     int_ty::MIN and therefore the return value of int_ty::MIN is correct.\n-        // QED.\n-\n-        let float_bits_to_llval = |bx: &mut Self, bits| {\n-            let bits_llval = match float_width {\n-                32 => bx.cx().const_u32(bits as u32),\n-                64 => bx.cx().const_u64(bits as u64),\n-                n => bug!(\"unsupported float width {}\", n),\n-            };\n-            bx.bitcast(bits_llval, float_ty)\n-        };\n-        let (f_min, f_max) = match float_width {\n-            32 => compute_clamp_bounds_single(signed, int_width),\n-            64 => compute_clamp_bounds_double(signed, int_width),\n-            n => bug!(\"unsupported float width {}\", n),\n-        };\n-        let f_min = float_bits_to_llval(self, f_min);\n-        let f_max = float_bits_to_llval(self, f_max);\n-        let int_max = self.cx().const_uint_big(int_ty, int_max(signed, int_width));\n-        let int_min = self.cx().const_uint_big(int_ty, int_min(signed, int_width) as u128);\n-        let zero = self.cx().const_uint(int_ty, 0);\n-\n-        // If we're working with vectors, constants must be \"splatted\": the constant is duplicated\n-        // into each lane of the vector.  The algorithm stays the same, we are just using the\n-        // same constant across all lanes.\n-        let maybe_splat = |bx: &mut Self, val| {\n-            if bx.cx().type_kind(dest_ty) == TypeKind::Vector {\n-                bx.vector_splat(bx.vector_length(dest_ty), val)\n-            } else {\n-                val\n-            }\n-        };\n-        let f_min = maybe_splat(self, f_min);\n-        let f_max = maybe_splat(self, f_max);\n-        let int_max = maybe_splat(self, int_max);\n-        let int_min = maybe_splat(self, int_min);\n-        let zero = maybe_splat(self, zero);\n-\n-        // Step 1 ...\n-        let fptosui_result = if signed { self.fptosi(x, dest_ty) } else { self.fptoui(x, dest_ty) };\n-        let less_or_nan = self.fcmp(RealPredicate::RealULT, x, f_min);\n-        let greater = self.fcmp(RealPredicate::RealOGT, x, f_max);\n-\n-        // Step 2: We use two comparisons and two selects, with %s1 being the\n-        // result:\n-        //     %less_or_nan = fcmp ult %x, %f_min\n-        //     %greater = fcmp olt %x, %f_max\n-        //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n-        //     %s1 = select %greater, int_ty::MAX, %s0\n-        // Note that %less_or_nan uses an *unordered* comparison. This\n-        // comparison is true if the operands are not comparable (i.e., if x is\n-        // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n-        // x is NaN.\n-        //\n-        // Performance note: Unordered comparison can be lowered to a \"flipped\"\n-        // comparison and a negation, and the negation can be merged into the\n-        // select. Therefore, it not necessarily any more expensive than an\n-        // ordered (\"normal\") comparison. Whether these optimizations will be\n-        // performed is ultimately up to the backend, but at least x86 does\n-        // perform them.\n-        let s0 = self.select(less_or_nan, int_min, fptosui_result);\n-        let s1 = self.select(greater, int_max, s0);\n-\n-        // Step 3: NaN replacement.\n-        // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n-        // Therefore we only need to execute this step for signed integer types.\n-        if signed {\n-            // LLVM has no isNaN predicate, so we use (x == x) instead\n-            let cmp = self.fcmp(RealPredicate::RealOEQ, x, x);\n-            self.select(cmp, s1, zero)\n-        } else {\n-            s1\n-        }\n+        if signed { self.fptosi_sat(x, dest_ty) } else { self.fptoui_sat(x, dest_ty) }\n     }\n \n     fn icmp(&mut self, op: IntPredicate, lhs: Self::Value, rhs: Self::Value) -> Self::Value;"}, {"sha": "00e238648712ffaf103d6750c4c5c3b9ce6fbede", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -78,6 +78,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             err_count_on_creation: self.err_count_on_creation,\n             in_snapshot: self.in_snapshot.clone(),\n             universe: self.universe.clone(),\n+            normalize_fn_sig_for_diagnostic: self\n+                .normalize_fn_sig_for_diagnostic\n+                .as_ref()\n+                .map(|f| f.clone()),\n         }\n     }\n }"}, {"sha": "7dc4934db09d46c28515956fbd64278f036d9808", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -961,12 +961,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn normalize_fn_sig_for_diagnostic(&self, sig: ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx> {\n+        if let Some(normalize) = &self.normalize_fn_sig_for_diagnostic {\n+            normalize(self, sig)\n+        } else {\n+            sig\n+        }\n+    }\n+\n     /// Given two `fn` signatures highlight only sub-parts that are different.\n     fn cmp_fn_sig(\n         &self,\n         sig1: &ty::PolyFnSig<'tcx>,\n         sig2: &ty::PolyFnSig<'tcx>,\n     ) -> (DiagnosticStyledString, DiagnosticStyledString) {\n+        let sig1 = &self.normalize_fn_sig_for_diagnostic(*sig1);\n+        let sig2 = &self.normalize_fn_sig_for_diagnostic(*sig2);\n+\n         let get_lifetimes = |sig| {\n             use rustc_hir::def::Namespace;\n             let (_, sig, reg) = ty::print::FmtPrinter::new(self.tcx, Namespace::TypeNS)"}, {"sha": "60ebf8b949d26a6ae72868d758b7de75931a4ff4", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -337,6 +337,9 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// when we enter into a higher-ranked (`for<..>`) type or trait\n     /// bound.\n     universe: Cell<ty::UniverseIndex>,\n+\n+    normalize_fn_sig_for_diagnostic:\n+        Option<Lrc<dyn Fn(&InferCtxt<'_, 'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n }\n \n /// See the `error_reporting` module for more details.\n@@ -540,6 +543,8 @@ pub struct InferCtxtBuilder<'tcx> {\n     defining_use_anchor: DefiningAnchor,\n     considering_regions: bool,\n     fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n+    normalize_fn_sig_for_diagnostic:\n+        Option<Lrc<dyn Fn(&InferCtxt<'_, 'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -553,6 +558,7 @@ impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n             defining_use_anchor: DefiningAnchor::Error,\n             considering_regions: true,\n             fresh_typeck_results: None,\n+            normalize_fn_sig_for_diagnostic: None,\n         }\n     }\n }\n@@ -582,6 +588,14 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n+    pub fn with_normalize_fn_sig_for_diagnostic(\n+        mut self,\n+        fun: Lrc<dyn Fn(&InferCtxt<'_, 'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>,\n+    ) -> Self {\n+        self.normalize_fn_sig_for_diagnostic = Some(fun);\n+        self\n+    }\n+\n     /// Given a canonical value `C` as a starting point, create an\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n@@ -611,6 +625,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             defining_use_anchor,\n             considering_regions,\n             ref fresh_typeck_results,\n+            ref normalize_fn_sig_for_diagnostic,\n         } = *self;\n         let in_progress_typeck_results = fresh_typeck_results.as_ref();\n         f(InferCtxt {\n@@ -629,6 +644,9 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             in_snapshot: Cell::new(false),\n             skip_leak_check: Cell::new(false),\n             universe: Cell::new(ty::UniverseIndex::ROOT),\n+            normalize_fn_sig_for_diagnostic: normalize_fn_sig_for_diagnostic\n+                .as_ref()\n+                .map(|f| f.clone()),\n         })\n     }\n }"}, {"sha": "b7eab5d43285b121e16f34f0ec291e42f31703a7", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -4,6 +4,7 @@ use super::SubregionOrigin;\n use crate::infer::combine::ConstEquateRelation;\n use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::traits::Obligation;\n+use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::TyVar;\n@@ -141,17 +142,27 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n                     Ok(infcx.tcx.mk_ty_var(var))\n                 };\n                 let (a, b) = if self.a_is_expected { (a, b) } else { (b, a) };\n-                let (a, b) = match (a.kind(), b.kind()) {\n+                let (ga, gb) = match (a.kind(), b.kind()) {\n                     (&ty::Opaque(..), _) => (a, generalize(b, true)?),\n                     (_, &ty::Opaque(..)) => (generalize(a, false)?, b),\n                     _ => unreachable!(),\n                 };\n                 self.fields.obligations.extend(\n                     infcx\n-                        .handle_opaque_type(a, b, true, &self.fields.trace.cause, self.param_env())?\n+                        .handle_opaque_type(ga, gb, true, &self.fields.trace.cause, self.param_env())\n+                        // Don't leak any generalized type variables out of this\n+                        // subtyping relation in the case of a type error.\n+                        .map_err(|err| {\n+                            let (ga, gb) = self.fields.infcx.resolve_vars_if_possible((ga, gb));\n+                            if let TypeError::Sorts(sorts) = err && sorts.expected == ga && sorts.found == gb {\n+                                TypeError::Sorts(ExpectedFound { expected: a, found: b })\n+                            } else {\n+                                err\n+                            }\n+                        })?\n                         .obligations,\n                 );\n-                Ok(a)\n+                Ok(ga)\n             }\n \n             _ => {"}, {"sha": "da564c66a70e1519ea72e29c5886d3596bfab84f", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -276,10 +276,23 @@ impl<'tcx> Ty<'tcx> {\n             }\n             ty::Slice(ty) if ty.is_simple_ty() => format!(\"slice `{}`\", self).into(),\n             ty::Slice(_) => \"slice\".into(),\n-            ty::RawPtr(_) => \"*-ptr\".into(),\n+            ty::RawPtr(tymut) => {\n+                let tymut_string = match tymut.mutbl {\n+                    hir::Mutability::Mut => tymut.to_string(),\n+                    hir::Mutability::Not => format!(\"const {}\", tymut.ty),\n+                };\n+\n+                if tymut_string != \"_\" && (tymut.ty.is_simple_text() || tymut_string.len() < \"const raw pointer\".len()) {\n+                    format!(\"`*{}`\", tymut_string).into()\n+                } else {\n+                    // Unknown type name, it's long or has type arguments\n+                    \"raw pointer\".into()\n+                }\n+            },\n             ty::Ref(_, ty, mutbl) => {\n                 let tymut = ty::TypeAndMut { ty, mutbl };\n                 let tymut_string = tymut.to_string();\n+\n                 if tymut_string != \"_\"\n                     && (ty.is_simple_text() || tymut_string.len() < \"mutable reference\".len())\n                 {"}, {"sha": "5b79dd3d3ef25d3a14e0760bcb2587773e14dacd", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 71, "deletions": 11, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -229,6 +229,19 @@ enum VarKind {\n     Upvar(HirId, Symbol),\n }\n \n+struct CollectLitsVisitor<'tcx> {\n+    lit_exprs: Vec<&'tcx hir::Expr<'tcx>>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for CollectLitsVisitor<'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        if let hir::ExprKind::Lit(_) = expr.kind {\n+            self.lit_exprs.push(expr);\n+        }\n+        intravisit::walk_expr(self, expr);\n+    }\n+}\n+\n struct IrMaps<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     live_node_map: HirIdMap<LiveNode>,\n@@ -1333,7 +1346,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n     fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n-        self.check_unused_vars_in_pat(&local.pat, None, |spans, hir_id, ln, var| {\n+        self.check_unused_vars_in_pat(&local.pat, None, None, |spans, hir_id, ln, var| {\n             if local.init.is_some() {\n                 self.warn_about_dead_assign(spans, hir_id, ln, var);\n             }\n@@ -1348,7 +1361,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n     }\n \n     fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n-        self.check_unused_vars_in_pat(&arm.pat, None, |_, _, _, _| {});\n+        self.check_unused_vars_in_pat(&arm.pat, None, None, |_, _, _, _| {});\n         intravisit::walk_arm(self, arm);\n     }\n }\n@@ -1387,7 +1400,7 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n         }\n \n         hir::ExprKind::Let(let_expr) => {\n-            this.check_unused_vars_in_pat(let_expr.pat, None, |_, _, _, _| {});\n+            this.check_unused_vars_in_pat(let_expr.pat, None, None, |_, _, _, _| {});\n         }\n \n         // no correctness conditions related to liveness\n@@ -1508,20 +1521,26 @@ impl<'tcx> Liveness<'_, 'tcx> {\n \n     fn warn_about_unused_args(&self, body: &hir::Body<'_>, entry_ln: LiveNode) {\n         for p in body.params {\n-            self.check_unused_vars_in_pat(&p.pat, Some(entry_ln), |spans, hir_id, ln, var| {\n-                if !self.live_on_entry(ln, var) {\n-                    self.report_unused_assign(hir_id, spans, var, |name| {\n-                        format!(\"value passed to `{}` is never read\", name)\n-                    });\n-                }\n-            });\n+            self.check_unused_vars_in_pat(\n+                &p.pat,\n+                Some(entry_ln),\n+                Some(body),\n+                |spans, hir_id, ln, var| {\n+                    if !self.live_on_entry(ln, var) {\n+                        self.report_unused_assign(hir_id, spans, var, |name| {\n+                            format!(\"value passed to `{}` is never read\", name)\n+                        });\n+                    }\n+                },\n+            );\n         }\n     }\n \n     fn check_unused_vars_in_pat(\n         &self,\n         pat: &hir::Pat<'_>,\n         entry_ln: Option<LiveNode>,\n+        opt_body: Option<&hir::Body<'_>>,\n         on_used_on_entry: impl Fn(Vec<Span>, HirId, LiveNode, Variable),\n     ) {\n         // In an or-pattern, only consider the variable; any later patterns must have the same\n@@ -1549,7 +1568,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                     hir_ids_and_spans.into_iter().map(|(_, _, ident_span)| ident_span).collect();\n                 on_used_on_entry(spans, id, ln, var);\n             } else {\n-                self.report_unused(hir_ids_and_spans, ln, var, can_remove);\n+                self.report_unused(hir_ids_and_spans, ln, var, can_remove, pat, opt_body);\n             }\n         }\n     }\n@@ -1561,6 +1580,8 @@ impl<'tcx> Liveness<'_, 'tcx> {\n         ln: LiveNode,\n         var: Variable,\n         can_remove: bool,\n+        pat: &hir::Pat<'_>,\n+        opt_body: Option<&hir::Body<'_>>,\n     ) {\n         let first_hir_id = hir_ids_and_spans[0].0;\n \n@@ -1664,6 +1685,9 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                             .collect::<Vec<_>>(),\n                         |lint| {\n                             let mut err = lint.build(&format!(\"unused variable: `{}`\", name));\n+                            if self.has_added_lit_match_name_span(&name, opt_body, &mut err) {\n+                                err.span_label(pat.span, \"unused variable\");\n+                            }\n                             err.multipart_suggestion(\n                                 \"if this is intentional, prefix it with an underscore\",\n                                 non_shorthands,\n@@ -1677,6 +1701,42 @@ impl<'tcx> Liveness<'_, 'tcx> {\n         }\n     }\n \n+    fn has_added_lit_match_name_span(\n+        &self,\n+        name: &str,\n+        opt_body: Option<&hir::Body<'_>>,\n+        err: &mut rustc_errors::DiagnosticBuilder<'_, ()>,\n+    ) -> bool {\n+        let mut has_litstring = false;\n+        let Some(opt_body) = opt_body else {return false;};\n+        let mut visitor = CollectLitsVisitor { lit_exprs: vec![] };\n+        intravisit::walk_body(&mut visitor, opt_body);\n+        for lit_expr in visitor.lit_exprs {\n+            let hir::ExprKind::Lit(litx) = &lit_expr.kind else { continue };\n+            let rustc_ast::LitKind::Str(syb, _) = litx.node else{ continue; };\n+            let name_str: &str = syb.as_str();\n+            let mut name_pa = String::from(\"{\");\n+            name_pa.push_str(&name);\n+            name_pa.push('}');\n+            if name_str.contains(&name_pa) {\n+                err.span_label(\n+                    lit_expr.span,\n+                    \"you might have meant to use string interpolation in this string literal\",\n+                );\n+                err.multipart_suggestion(\n+                    \"string interpolation only works in `format!` invocations\",\n+                    vec![\n+                        (lit_expr.span.shrink_to_lo(), \"format!(\".to_string()),\n+                        (lit_expr.span.shrink_to_hi(), \")\".to_string()),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+                has_litstring = true;\n+            }\n+        }\n+        has_litstring\n+    }\n+\n     fn warn_about_dead_assign(&self, spans: Vec<Span>, hir_id: HirId, ln: LiveNode, var: Variable) {\n         if !self.live_on_exit(ln, var) {\n             self.report_unused_assign(hir_id, spans, var, |name| {"}, {"sha": "dba4d4f69dadb519244aa5000cff7ce46657aa3d", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -17,6 +17,7 @@ use rustc_span::Span;\n \n pub trait TraitEngineExt<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> Box<Self>;\n+    fn new_in_snapshot(tcx: TyCtxt<'tcx>) -> Box<Self>;\n }\n \n impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n@@ -27,6 +28,14 @@ impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n             Box::new(FulfillmentContext::new())\n         }\n     }\n+\n+    fn new_in_snapshot(tcx: TyCtxt<'tcx>) -> Box<Self> {\n+        if tcx.sess.opts.unstable_opts.chalk {\n+            Box::new(ChalkFulfillmentContext::new())\n+        } else {\n+            Box::new(FulfillmentContext::new_in_snapshot())\n+        }\n+    }\n }\n \n /// Used if you want to have pleasant experience when dealing\n@@ -41,6 +50,10 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         Self { infcx, engine: RefCell::new(<dyn TraitEngine<'_>>::new(infcx.tcx)) }\n     }\n \n+    pub fn new_in_snapshot(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+        Self { infcx, engine: RefCell::new(<dyn TraitEngine<'_>>::new_in_snapshot(infcx.tcx)) }\n+    }\n+\n     pub fn register_obligation(&self, obligation: PredicateObligation<'tcx>) {\n         self.engine.borrow_mut().register_predicate_obligation(self.infcx, obligation);\n     }"}, {"sha": "02adae5bde157f50c086e0b9c3784b1a9d126c0b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -20,7 +20,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::hir::map;\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n@@ -1589,32 +1589,38 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         expected: ty::PolyTraitRef<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         pub(crate) fn build_fn_sig_ty<'tcx>(\n-            tcx: TyCtxt<'tcx>,\n+            infcx: &InferCtxt<'_, 'tcx>,\n             trait_ref: ty::PolyTraitRef<'tcx>,\n         ) -> Ty<'tcx> {\n             let inputs = trait_ref.skip_binder().substs.type_at(1);\n             let sig = match inputs.kind() {\n                 ty::Tuple(inputs)\n-                    if tcx.fn_trait_kind_from_lang_item(trait_ref.def_id()).is_some() =>\n+                    if infcx.tcx.fn_trait_kind_from_lang_item(trait_ref.def_id()).is_some() =>\n                 {\n-                    tcx.mk_fn_sig(\n+                    infcx.tcx.mk_fn_sig(\n                         inputs.iter(),\n-                        tcx.mk_ty_infer(ty::TyVar(ty::TyVid::from_u32(0))),\n+                        infcx.next_ty_var(TypeVariableOrigin {\n+                            span: DUMMY_SP,\n+                            kind: TypeVariableOriginKind::MiscVariable,\n+                        }),\n                         false,\n                         hir::Unsafety::Normal,\n                         abi::Abi::Rust,\n                     )\n                 }\n-                _ => tcx.mk_fn_sig(\n+                _ => infcx.tcx.mk_fn_sig(\n                     std::iter::once(inputs),\n-                    tcx.mk_ty_infer(ty::TyVar(ty::TyVid::from_u32(0))),\n+                    infcx.next_ty_var(TypeVariableOrigin {\n+                        span: DUMMY_SP,\n+                        kind: TypeVariableOriginKind::MiscVariable,\n+                    }),\n                     false,\n                     hir::Unsafety::Normal,\n                     abi::Abi::Rust,\n                 ),\n             };\n \n-            tcx.mk_fn_ptr(trait_ref.rebind(sig))\n+            infcx.tcx.mk_fn_ptr(trait_ref.rebind(sig))\n         }\n \n         let argument_kind = match expected.skip_binder().self_ty().kind() {\n@@ -1634,11 +1640,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let found_span = found_span.unwrap_or(span);\n         err.span_label(found_span, \"found signature defined here\");\n \n-        let expected = build_fn_sig_ty(self.tcx, expected);\n-        let found = build_fn_sig_ty(self.tcx, found);\n+        let expected = build_fn_sig_ty(self, expected);\n+        let found = build_fn_sig_ty(self, found);\n \n-        let (expected_str, found_str) =\n-            self.tcx.infer_ctxt().enter(|infcx| infcx.cmp(expected, found));\n+        let (expected_str, found_str) = self.cmp(expected, found);\n \n         let signature_kind = format!(\"{argument_kind} signature\");\n         err.note_expected_found(&signature_kind, expected_str, &signature_kind, found_str);"}, {"sha": "1439baf54406d2e44d3700d73fecf8e6a3ea036a", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -1,6 +1,7 @@\n use super::callee::DeferredCallResolution;\n \n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::HirIdMap;\n@@ -12,7 +13,9 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::LocalDefIdMap;\n use rustc_span::{self, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::traits::{self, ObligationCause, TraitEngine, TraitEngineExt};\n+use rustc_trait_selection::traits::{\n+    self, ObligationCause, ObligationCtxt, TraitEngine, TraitEngineExt as _,\n+};\n \n use std::cell::RefCell;\n use std::ops::Deref;\n@@ -84,7 +87,29 @@ impl<'tcx> Inherited<'_, 'tcx> {\n             infcx: tcx\n                 .infer_ctxt()\n                 .ignoring_regions()\n-                .with_fresh_in_progress_typeck_results(hir_owner),\n+                .with_fresh_in_progress_typeck_results(hir_owner)\n+                .with_normalize_fn_sig_for_diagnostic(Lrc::new(move |infcx, fn_sig| {\n+                    if fn_sig.has_escaping_bound_vars() {\n+                        return fn_sig;\n+                    }\n+                    infcx.probe(|_| {\n+                        let ocx = ObligationCtxt::new_in_snapshot(infcx);\n+                        let normalized_fn_sig = ocx.normalize(\n+                            ObligationCause::dummy(),\n+                            // FIXME(compiler-errors): This is probably not the right param-env...\n+                            infcx.tcx.param_env(def_id),\n+                            fn_sig,\n+                        );\n+                        if ocx.select_all_or_error().is_empty() {\n+                            let normalized_fn_sig =\n+                                infcx.resolve_vars_if_possible(normalized_fn_sig);\n+                            if !normalized_fn_sig.needs_infer() {\n+                                return normalized_fn_sig;\n+                            }\n+                        }\n+                        fn_sig\n+                    })\n+                })),\n             def_id,\n         }\n     }"}, {"sha": "1845139659db55ff0380b9a57d4f70bebbad5b62", "filename": "src/test/ui/asm/type-check-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.stderr?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -106,7 +106,7 @@ error[E0308]: mismatched types\n   --> $DIR/type-check-1.rs:60:26\n    |\n LL |         asm!(\"{}\", const 0 as *mut u8);\n-   |                          ^^^^^^^^^^^^ expected integer, found *-ptr\n+   |                          ^^^^^^^^^^^^ expected integer, found `*mut u8`\n    |\n    = note:     expected type `{integer}`\n            found raw pointer `*mut u8`\n@@ -133,7 +133,7 @@ error[E0308]: mismatched types\n   --> $DIR/type-check-1.rs:78:25\n    |\n LL | global_asm!(\"{}\", const 0 as *mut u8);\n-   |                         ^^^^^^^^^^^^ expected integer, found *-ptr\n+   |                         ^^^^^^^^^^^^ expected integer, found `*mut u8`\n    |\n    = note:     expected type `{integer}`\n            found raw pointer `*mut u8`"}, {"sha": "0d6f4d0209f71b200e4cf1f224ecd2b7c7208add", "filename": "src/test/ui/dst/dst-bad-coercions.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Fdst%2Fdst-bad-coercions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Fdst%2Fdst-bad-coercions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-bad-coercions.stderr?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/dst-bad-coercions.rs:14:17\n    |\n LL |     let y: &S = x;\n-   |            --   ^ expected `&S`, found *-ptr\n+   |            --   ^ expected `&S`, found `*const S`\n    |            |\n    |            expected due to this\n    |\n@@ -13,7 +13,7 @@ error[E0308]: mismatched types\n   --> $DIR/dst-bad-coercions.rs:15:21\n    |\n LL |     let y: &dyn T = x;\n-   |            ------   ^ expected `&dyn T`, found *-ptr\n+   |            ------   ^ expected `&dyn T`, found `*const S`\n    |            |\n    |            expected due to this\n    |\n@@ -24,7 +24,7 @@ error[E0308]: mismatched types\n   --> $DIR/dst-bad-coercions.rs:19:17\n    |\n LL |     let y: &S = x;\n-   |            --   ^ expected `&S`, found *-ptr\n+   |            --   ^ expected `&S`, found `*mut S`\n    |            |\n    |            expected due to this\n    |\n@@ -35,7 +35,7 @@ error[E0308]: mismatched types\n   --> $DIR/dst-bad-coercions.rs:20:21\n    |\n LL |     let y: &dyn T = x;\n-   |            ------   ^ expected `&dyn T`, found *-ptr\n+   |            ------   ^ expected `&dyn T`, found `*mut S`\n    |            |\n    |            expected due to this\n    |"}, {"sha": "4324a0229a6ff2673fe5211bf501500e904bfe3a", "filename": "src/test/ui/impl-trait/issue-99914.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99914.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99914.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99914.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -0,0 +1,13 @@\n+// edition:2021\n+\n+fn main() {}\n+\n+struct Error;\n+struct Okay;\n+\n+fn foo(t: Result<Okay, Error>) {\n+    t.and_then(|t| -> _ { bar(t) });\n+    //~^ ERROR mismatched types\n+}\n+\n+async fn bar(t: Okay) {}"}, {"sha": "074d5d58d9a301afe0a265956ca5a0991fda1c2e", "filename": "src/test/ui/impl-trait/issue-99914.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99914.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99914.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99914.stderr?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -0,0 +1,21 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-99914.rs:9:27\n+   |\n+LL |     t.and_then(|t| -> _ { bar(t) });\n+   |                           ^^^^^^ expected enum `Result`, found opaque type\n+   |\n+note: while checking the return type of the `async fn`\n+  --> $DIR/issue-99914.rs:13:23\n+   |\n+LL | async fn bar(t: Okay) {}\n+   |                       ^ checked the `Output` of this `async fn`, found opaque type\n+   = note:     expected enum `Result<_, Error>`\n+           found opaque type `impl Future<Output = ()>`\n+help: try wrapping the expression in `Ok`\n+   |\n+LL |     t.and_then(|t| -> _ { Ok(bar(t)) });\n+   |                           +++      +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "5cef64bb1692619b49e1de466d21568d67570bda", "filename": "src/test/ui/mismatched_types/issue-19109.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-19109.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-19109.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-19109.stderr?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL | fn function(t: &mut dyn Trait) {\n    |                                - help: try adding a return type: `-> *mut dyn Trait`\n LL |     t as *mut dyn Trait\n-   |     ^^^^^^^^^^^^^^^^^^^ expected `()`, found *-ptr\n+   |     ^^^^^^^^^^^^^^^^^^^ expected `()`, found `*mut dyn Trait`\n    |\n    = note: expected unit type `()`\n             found raw pointer `*mut dyn Trait`"}, {"sha": "1a2093c44f02e721c493e553fe3f7a3ae29b263e", "filename": "src/test/ui/mismatched_types/normalize-fn-sig.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Fmismatched_types%2Fnormalize-fn-sig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Fmismatched_types%2Fnormalize-fn-sig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fnormalize-fn-sig.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -0,0 +1,16 @@\n+trait Foo {\n+    type Bar;\n+}\n+\n+impl<T> Foo for T {\n+    type Bar = i32;\n+}\n+\n+fn foo<T>(_: <T as Foo>::Bar, _: &'static <T as Foo>::Bar) {}\n+\n+fn needs_i32_ref_fn(_: fn(&'static i32, i32)) {}\n+\n+fn main() {\n+    needs_i32_ref_fn(foo::<()>);\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "6c55f29c5d153d514e83a4656f3a275316f679ae", "filename": "src/test/ui/mismatched_types/normalize-fn-sig.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Fmismatched_types%2Fnormalize-fn-sig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Fmismatched_types%2Fnormalize-fn-sig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fnormalize-fn-sig.stderr?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -0,0 +1,19 @@\n+error[E0308]: mismatched types\n+  --> $DIR/normalize-fn-sig.rs:14:22\n+   |\n+LL |     needs_i32_ref_fn(foo::<()>);\n+   |     ---------------- ^^^^^^^^^ expected `&i32`, found `i32`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected fn pointer `fn(&'static i32, i32)`\n+                 found fn item `fn(i32, &'static i32) {foo::<()>}`\n+note: function defined here\n+  --> $DIR/normalize-fn-sig.rs:11:4\n+   |\n+LL | fn needs_i32_ref_fn(_: fn(&'static i32, i32)) {}\n+   |    ^^^^^^^^^^^^^^^^ ------------------------\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "102846563231e25157226b39e7280e1286be9099", "filename": "src/test/ui/type/issue-100584.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Ftype%2Fissue-100584.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Ftype%2Fissue-100584.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fissue-100584.rs?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -0,0 +1,15 @@\n+#![deny(unused)]\n+fn foo(xyza: &str) {\n+//~^ ERROR unused variable: `xyza`\n+    let _ = \"{xyza}\";\n+}\n+\n+fn foo3(xyza: &str) {\n+//~^ ERROR unused variable: `xyza`\n+    let _ = \"aaa{xyza}bbb\";\n+}\n+\n+fn main() {\n+  foo(\"x\");\n+  foo3(\"xx\");\n+}"}, {"sha": "e1db14d1f001bd1dfe18a14d45f297654d1fcf8f", "filename": "src/test/ui/type/issue-100584.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Ftype%2Fissue-100584.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fce6a7d66ec32e6350aa7f0e3953d64269e857a3/src%2Ftest%2Fui%2Ftype%2Fissue-100584.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fissue-100584.stderr?ref=fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "patch": "@@ -0,0 +1,44 @@\n+error: unused variable: `xyza`\n+  --> $DIR/issue-100584.rs:2:8\n+   |\n+LL | fn foo(xyza: &str) {\n+   |        ^^^^ unused variable\n+LL |\n+LL |     let _ = \"{xyza}\";\n+   |             -------- you might have meant to use string interpolation in this string literal\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-100584.rs:1:9\n+   |\n+LL | #![deny(unused)]\n+   |         ^^^^^^\n+   = note: `#[deny(unused_variables)]` implied by `#[deny(unused)]`\n+help: string interpolation only works in `format!` invocations\n+   |\n+LL |     let _ = format!(\"{xyza}\");\n+   |             ++++++++        +\n+help: if this is intentional, prefix it with an underscore\n+   |\n+LL | fn foo(_xyza: &str) {\n+   |        ~~~~~\n+\n+error: unused variable: `xyza`\n+  --> $DIR/issue-100584.rs:7:9\n+   |\n+LL | fn foo3(xyza: &str) {\n+   |         ^^^^ unused variable\n+LL |\n+LL |     let _ = \"aaa{xyza}bbb\";\n+   |             -------------- you might have meant to use string interpolation in this string literal\n+   |\n+help: string interpolation only works in `format!` invocations\n+   |\n+LL |     let _ = format!(\"aaa{xyza}bbb\");\n+   |             ++++++++              +\n+help: if this is intentional, prefix it with an underscore\n+   |\n+LL | fn foo3(_xyza: &str) {\n+   |         ~~~~~\n+\n+error: aborting due to 2 previous errors\n+"}]}