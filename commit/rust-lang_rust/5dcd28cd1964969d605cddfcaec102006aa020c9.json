{"sha": "5dcd28cd1964969d605cddfcaec102006aa020c9", "node_id": "C_kwDOAAsO6NoAKDVkY2QyOGNkMTk2NDk2OWQ2MDVjZGRmY2FlYzEwMjAwNmFhMDIwYzk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-07-08T06:00:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-08T06:00:38Z"}, "message": "Rollup merge of #98795 - jackh726:lexical_region_resolve_cleanup, r=compiler-errors\n\nA few cleanups\n\nEach commit is (mostly) self-explanatory. These changes have come as I try to remove `ReEmpty` (#98559).", "tree": {"sha": "39714d0d9066b8d20195581af2e2927940707dd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39714d0d9066b8d20195581af2e2927940707dd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dcd28cd1964969d605cddfcaec102006aa020c9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJix8gGCRBK7hj4Ov3rIwAABrEIAHTEe34ePWJv/rZtNpNRl7G4\n8mtefuZ5I+OuorP1fW4cThwJwWQJ3soViURk3JSiWrgRNS9UNiSiJVt7Mmq3DHDE\nkSZ+6X/Q2Md/qW0vppPjpR8ukB6n2Dz4uMLVSsbY+RSQgHUzQhPtB7K5OWCG8aab\nrysqIBMF5DSJhbVCtBd/7zh8CtBncFY8Te9D6Eao9EgJlnx8QdSGHVmxxEFJ7vgU\nU0yOEPu2IO807KNWff+BcAC1Y1ka2WNVvJ7VfqJw6/pY/IzJhEBODFNsStMW7zeN\n5XtesYwYiSDEIrrIkfSP+gWfvu5NGo7lg5KpFmWhqg6XL4Vj5RR7bDZg1i7XOas=\n=fR2V\n-----END PGP SIGNATURE-----\n", "payload": "tree 39714d0d9066b8d20195581af2e2927940707dd8\nparent 9c6bcb60f30abee7648f8be67c880159db4366ce\nparent 31e1a777e7b055b240b507a7c04719c0563852e9\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1657260038 +0200\ncommitter GitHub <noreply@github.com> 1657260038 +0200\n\nRollup merge of #98795 - jackh726:lexical_region_resolve_cleanup, r=compiler-errors\n\nA few cleanups\n\nEach commit is (mostly) self-explanatory. These changes have come as I try to remove `ReEmpty` (#98559).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dcd28cd1964969d605cddfcaec102006aa020c9", "html_url": "https://github.com/rust-lang/rust/commit/5dcd28cd1964969d605cddfcaec102006aa020c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dcd28cd1964969d605cddfcaec102006aa020c9/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c6bcb60f30abee7648f8be67c880159db4366ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c6bcb60f30abee7648f8be67c880159db4366ce", "html_url": "https://github.com/rust-lang/rust/commit/9c6bcb60f30abee7648f8be67c880159db4366ce"}, {"sha": "31e1a777e7b055b240b507a7c04719c0563852e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/31e1a777e7b055b240b507a7c04719c0563852e9", "html_url": "https://github.com/rust-lang/rust/commit/31e1a777e7b055b240b507a7c04719c0563852e9"}], "stats": {"total": 1184, "additions": 585, "deletions": 599}, "files": [{"sha": "ea3602e8a056a52010bf6b269e8c47539a3aa5c6", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=5dcd28cd1964969d605cddfcaec102006aa020c9", "patch": "@@ -495,8 +495,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     }\n                 }\n \n-                NllRegionVariableOrigin::RootEmptyRegion\n-                | NllRegionVariableOrigin::Existential { .. } => {\n+                NllRegionVariableOrigin::Existential { .. } => {\n                     // For existential, regions, nothing to do.\n                 }\n             }\n@@ -1410,8 +1409,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_bound_universal_region(fr, placeholder, errors_buffer);\n                 }\n \n-                NllRegionVariableOrigin::RootEmptyRegion\n-                | NllRegionVariableOrigin::Existential { .. } => {\n+                NllRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n@@ -1513,8 +1511,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_bound_universal_region(fr, placeholder, errors_buffer);\n                 }\n \n-                NllRegionVariableOrigin::RootEmptyRegion\n-                | NllRegionVariableOrigin::Existential { .. } => {\n+                NllRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n@@ -1788,9 +1785,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 universe1.cannot_name(placeholder.universe)\n             }\n \n-            NllRegionVariableOrigin::RootEmptyRegion\n-            | NllRegionVariableOrigin::FreeRegion\n-            | NllRegionVariableOrigin::Existential { .. } => false,\n+            NllRegionVariableOrigin::FreeRegion | NllRegionVariableOrigin::Existential { .. } => {\n+                false\n+            }\n         }\n     }\n \n@@ -2152,8 +2149,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let blame_source = match from_region_origin {\n             NllRegionVariableOrigin::FreeRegion\n             | NllRegionVariableOrigin::Existential { from_forall: false } => true,\n-            NllRegionVariableOrigin::RootEmptyRegion\n-            | NllRegionVariableOrigin::Placeholder(_)\n+            NllRegionVariableOrigin::Placeholder(_)\n             | NllRegionVariableOrigin::Existential { from_forall: true } => false,\n         };\n "}, {"sha": "7c1fa28b8dfcc9c9e731e34b2beda85bcc2897bd", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 482, "deletions": 2, "changes": 484, "blob_url": "https://github.com/rust-lang/rust/blob/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=5dcd28cd1964969d605cddfcaec102006aa020c9", "patch": "@@ -1,11 +1,20 @@\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::def_id::DefId;\n use rustc_hir::OpaqueTyOrigin;\n+use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use rustc_infer::infer::InferCtxt;\n+use rustc_infer::infer::TyCtxtInferExt as _;\n+use rustc_infer::traits::{Obligation, ObligationCause, TraitEngine};\n+use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts};\n+use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n-    self, OpaqueHiddenType, OpaqueTypeKey, TyCtxt, TypeFoldable, TypeVisitable,\n+    self, OpaqueHiddenType, OpaqueTypeKey, ToPredicate, Ty, TyCtxt, TypeFoldable,\n };\n-use rustc_trait_selection::opaque_types::InferCtxtExt;\n+use rustc_span::Span;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::TraitEngineExt as _;\n \n use super::RegionInferenceContext;\n \n@@ -173,3 +182,474 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         })\n     }\n }\n+\n+pub trait InferCtxtExt<'tcx> {\n+    fn infer_opaque_definition_from_instantiation(\n+        &self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        instantiated_ty: OpaqueHiddenType<'tcx>,\n+        origin: OpaqueTyOrigin,\n+    ) -> Ty<'tcx>;\n+}\n+\n+impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n+    /// Given the fully resolved, instantiated type for an opaque\n+    /// type, i.e., the value of an inference variable like C1 or C2\n+    /// (*), computes the \"definition type\" for an opaque type\n+    /// definition -- that is, the inferred value of `Foo1<'x>` or\n+    /// `Foo2<'x>` that we would conceptually use in its definition:\n+    /// ```ignore (illustrative)\n+    /// type Foo1<'x> = impl Bar<'x> = AAA;  // <-- this type AAA\n+    /// type Foo2<'x> = impl Bar<'x> = BBB;  // <-- or this type BBB\n+    /// fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n+    /// ```\n+    /// Note that these values are defined in terms of a distinct set of\n+    /// generic parameters (`'x` instead of `'a`) from C1 or C2. The main\n+    /// purpose of this function is to do that translation.\n+    ///\n+    /// (*) C1 and C2 were introduced in the comments on\n+    /// `register_member_constraints`. Read that comment for more context.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `def_id`, the `impl Trait` type\n+    /// - `substs`, the substs  used to instantiate this opaque type\n+    /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n+    ///   `opaque_defn.concrete_ty`\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn infer_opaque_definition_from_instantiation(\n+        &self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        instantiated_ty: OpaqueHiddenType<'tcx>,\n+        origin: OpaqueTyOrigin,\n+    ) -> Ty<'tcx> {\n+        if self.is_tainted_by_errors() {\n+            return self.tcx.ty_error();\n+        }\n+\n+        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n+\n+        // Use substs to build up a reverse map from regions to their\n+        // identity mappings. This is necessary because of `impl\n+        // Trait` lifetimes are computed by replacing existing\n+        // lifetimes with 'static and remapping only those used in the\n+        // `impl Trait` return type, resulting in the parameters\n+        // shifting.\n+        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id);\n+        debug!(?id_substs);\n+        let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> =\n+            substs.iter().enumerate().map(|(index, subst)| (subst, id_substs[index])).collect();\n+        debug!(\"map = {:#?}\", map);\n+\n+        // Convert the type from the function into a type valid outside\n+        // the function, by replacing invalid regions with 'static,\n+        // after producing an error for each of them.\n+        let definition_ty = instantiated_ty.ty.fold_with(&mut ReverseMapper::new(\n+            self.tcx,\n+            def_id,\n+            map,\n+            instantiated_ty.ty,\n+            instantiated_ty.span,\n+        ));\n+        debug!(?definition_ty);\n+\n+        if !check_opaque_type_parameter_valid(\n+            self.tcx,\n+            opaque_type_key,\n+            origin,\n+            instantiated_ty.span,\n+        ) {\n+            return self.tcx.ty_error();\n+        }\n+\n+        // Only check this for TAIT. RPIT already supports `src/test/ui/impl-trait/nested-return-type2.rs`\n+        // on stable and we'd break that.\n+        if let OpaqueTyOrigin::TyAlias = origin {\n+            // This logic duplicates most of `check_opaque_meets_bounds`.\n+            // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n+            let param_env = self.tcx.param_env(def_id);\n+            let body_id = self.tcx.local_def_id_to_hir_id(def_id.as_local().unwrap());\n+            self.tcx.infer_ctxt().enter(move |infcx| {\n+                // Require the hidden type to be well-formed with only the generics of the opaque type.\n+                // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n+                // hidden type is well formed even without those bounds.\n+                let predicate =\n+                    ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n+                        .to_predicate(infcx.tcx);\n+                let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+\n+                // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n+                // the bounds that the function supplies.\n+                match infcx.register_hidden_type(\n+                    OpaqueTypeKey { def_id, substs: id_substs },\n+                    ObligationCause::misc(instantiated_ty.span, body_id),\n+                    param_env,\n+                    definition_ty,\n+                    origin,\n+                ) {\n+                    Ok(infer_ok) => {\n+                        for obligation in infer_ok.obligations {\n+                            fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+                        }\n+                    }\n+                    Err(err) => {\n+                        infcx\n+                            .report_mismatched_types(\n+                                &ObligationCause::misc(instantiated_ty.span, body_id),\n+                                self.tcx.mk_opaque(def_id, id_substs),\n+                                definition_ty,\n+                                err,\n+                            )\n+                            .emit();\n+                    }\n+                }\n+\n+                fulfillment_cx.register_predicate_obligation(\n+                    &infcx,\n+                    Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n+                );\n+\n+                // Check that all obligations are satisfied by the implementation's\n+                // version.\n+                let errors = fulfillment_cx.select_all_or_error(&infcx);\n+\n+                let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+\n+                if errors.is_empty() {\n+                    definition_ty\n+                } else {\n+                    infcx.report_fulfillment_errors(&errors, None, false);\n+                    self.tcx.ty_error()\n+                }\n+            })\n+        } else {\n+            definition_ty\n+        }\n+    }\n+}\n+\n+fn check_opaque_type_parameter_valid(\n+    tcx: TyCtxt<'_>,\n+    opaque_type_key: OpaqueTypeKey<'_>,\n+    origin: OpaqueTyOrigin,\n+    span: Span,\n+) -> bool {\n+    match origin {\n+        // No need to check return position impl trait (RPIT)\n+        // because for type and const parameters they are correct\n+        // by construction: we convert\n+        //\n+        // fn foo<P0..Pn>() -> impl Trait\n+        //\n+        // into\n+        //\n+        // type Foo<P0...Pn>\n+        // fn foo<P0..Pn>() -> Foo<P0...Pn>.\n+        //\n+        // For lifetime parameters we convert\n+        //\n+        // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n+        //\n+        // into\n+        //\n+        // type foo::<'p0..'pn>::Foo<'q0..'qm>\n+        // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n+        //\n+        // which would error here on all of the `'static` args.\n+        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return true,\n+        // Check these\n+        OpaqueTyOrigin::TyAlias => {}\n+    }\n+    let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n+    let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+    for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n+        let arg_is_param = match arg.unpack() {\n+            GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n+            GenericArgKind::Lifetime(lt) if lt.is_static() => {\n+                tcx.sess\n+                    .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                    .span_label(\n+                        tcx.def_span(opaque_generics.param_at(i, tcx).def_id),\n+                        \"cannot use static lifetime; use a bound lifetime \\\n+                                    instead or remove the lifetime parameter from the \\\n+                                    opaque type\",\n+                    )\n+                    .emit();\n+                return false;\n+            }\n+            GenericArgKind::Lifetime(lt) => {\n+                matches!(*lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n+            }\n+            GenericArgKind::Const(ct) => matches!(ct.kind(), ty::ConstKind::Param(_)),\n+        };\n+\n+        if arg_is_param {\n+            seen_params.entry(arg).or_default().push(i);\n+        } else {\n+            // Prevent `fn foo() -> Foo<u32>` from being defining.\n+            let opaque_param = opaque_generics.param_at(i, tcx);\n+            tcx.sess\n+                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                .span_note(\n+                    tcx.def_span(opaque_param.def_id),\n+                    &format!(\n+                        \"used non-generic {} `{}` for generic parameter\",\n+                        opaque_param.kind.descr(),\n+                        arg,\n+                    ),\n+                )\n+                .emit();\n+            return false;\n+        }\n+    }\n+\n+    for (_, indices) in seen_params {\n+        if indices.len() > 1 {\n+            let descr = opaque_generics.param_at(indices[0], tcx).kind.descr();\n+            let spans: Vec<_> = indices\n+                .into_iter()\n+                .map(|i| tcx.def_span(opaque_generics.param_at(i, tcx).def_id))\n+                .collect();\n+            tcx.sess\n+                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                .span_note(spans, &format!(\"{} used multiple times\", descr))\n+                .emit();\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+struct ReverseMapper<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    opaque_type_def_id: DefId,\n+    map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n+    map_missing_regions_to_empty: bool,\n+\n+    /// initially `Some`, set to `None` once error has been reported\n+    hidden_ty: Option<Ty<'tcx>>,\n+\n+    /// Span of function being checked.\n+    span: Span,\n+}\n+\n+impl<'tcx> ReverseMapper<'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        opaque_type_def_id: DefId,\n+        map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n+        hidden_ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> Self {\n+        Self {\n+            tcx,\n+            opaque_type_def_id,\n+            map,\n+            map_missing_regions_to_empty: false,\n+            hidden_ty: Some(hidden_ty),\n+            span,\n+        }\n+    }\n+\n+    fn fold_kind_mapping_missing_regions_to_empty(\n+        &mut self,\n+        kind: GenericArg<'tcx>,\n+    ) -> GenericArg<'tcx> {\n+        assert!(!self.map_missing_regions_to_empty);\n+        self.map_missing_regions_to_empty = true;\n+        let kind = kind.fold_with(self);\n+        self.map_missing_regions_to_empty = false;\n+        kind\n+    }\n+\n+    fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n+        assert!(!self.map_missing_regions_to_empty);\n+        kind.fold_with(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            // Ignore bound regions and `'static` regions that appear in the\n+            // type, we only need to remap regions that reference lifetimes\n+            // from the function declaration.\n+            // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n+            ty::ReLateBound(..) | ty::ReStatic => return r,\n+\n+            // If regions have been erased (by writeback), don't try to unerase\n+            // them.\n+            ty::ReErased => return r,\n+\n+            // The regions that we expect from borrow checking.\n+            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReEmpty(ty::UniverseIndex::ROOT) => {}\n+\n+            ty::ReEmpty(_) | ty::RePlaceholder(_) | ty::ReVar(_) => {\n+                // All of the regions in the type should either have been\n+                // erased by writeback, or mapped back to named regions by\n+                // borrow checking.\n+                bug!(\"unexpected region kind in opaque type: {:?}\", r);\n+            }\n+        }\n+\n+        let generics = self.tcx().generics_of(self.opaque_type_def_id);\n+        match self.map.get(&r.into()).map(|k| k.unpack()) {\n+            Some(GenericArgKind::Lifetime(r1)) => r1,\n+            Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n+            None if self.map_missing_regions_to_empty => self.tcx.lifetimes.re_root_empty,\n+            None if generics.parent.is_some() => {\n+                if let Some(hidden_ty) = self.hidden_ty.take() {\n+                    unexpected_hidden_region_diagnostic(\n+                        self.tcx,\n+                        self.tcx.def_span(self.opaque_type_def_id),\n+                        hidden_ty,\n+                        r,\n+                    )\n+                    .emit();\n+                }\n+                self.tcx.lifetimes.re_root_empty\n+            }\n+            None => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(self.span, \"non-defining opaque type use in defining scope\")\n+                    .span_label(\n+                        self.span,\n+                        format!(\n+                            \"lifetime `{}` is part of concrete type but not used in \\\n+                                 parameter list of the `impl Trait` type alias\",\n+                            r\n+                        ),\n+                    )\n+                    .emit();\n+\n+                self.tcx().lifetimes.re_static\n+            }\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match *ty.kind() {\n+            ty::Closure(def_id, substs) => {\n+                // I am a horrible monster and I pray for death. When\n+                // we encounter a closure here, it is always a closure\n+                // from within the function that we are currently\n+                // type-checking -- one that is now being encapsulated\n+                // in an opaque type. Ideally, we would\n+                // go through the types/lifetimes that it references\n+                // and treat them just like we would any other type,\n+                // which means we would error out if we find any\n+                // reference to a type/region that is not in the\n+                // \"reverse map\".\n+                //\n+                // **However,** in the case of closures, there is a\n+                // somewhat subtle (read: hacky) consideration. The\n+                // problem is that our closure types currently include\n+                // all the lifetime parameters declared on the\n+                // enclosing function, even if they are unused by the\n+                // closure itself. We can't readily filter them out,\n+                // so here we replace those values with `'empty`. This\n+                // can't really make a difference to the rest of the\n+                // compiler; those regions are ignored for the\n+                // outlives relation, and hence don't affect trait\n+                // selection or auto traits, and they are erased\n+                // during codegen.\n+\n+                let generics = self.tcx.generics_of(def_id);\n+                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n+                    if index < generics.parent_count {\n+                        // Accommodate missing regions in the parent kinds...\n+                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n+                    } else {\n+                        // ...but not elsewhere.\n+                        self.fold_kind_normally(kind)\n+                    }\n+                }));\n+\n+                self.tcx.mk_closure(def_id, substs)\n+            }\n+\n+            ty::Generator(def_id, substs, movability) => {\n+                let generics = self.tcx.generics_of(def_id);\n+                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n+                    if index < generics.parent_count {\n+                        // Accommodate missing regions in the parent kinds...\n+                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n+                    } else {\n+                        // ...but not elsewhere.\n+                        self.fold_kind_normally(kind)\n+                    }\n+                }));\n+\n+                self.tcx.mk_generator(def_id, substs, movability)\n+            }\n+\n+            ty::Param(param) => {\n+                // Look it up in the substitution list.\n+                match self.map.get(&ty.into()).map(|k| k.unpack()) {\n+                    // Found it in the substitution list; replace with the parameter from the\n+                    // opaque type.\n+                    Some(GenericArgKind::Type(t1)) => t1,\n+                    Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n+                    None => {\n+                        debug!(?param, ?self.map);\n+                        self.tcx\n+                            .sess\n+                            .struct_span_err(\n+                                self.span,\n+                                &format!(\n+                                    \"type parameter `{}` is part of concrete type but not \\\n+                                          used in parameter list for the `impl Trait` type alias\",\n+                                    ty\n+                                ),\n+                            )\n+                            .emit();\n+\n+                        self.tcx().ty_error()\n+                    }\n+                }\n+            }\n+\n+            _ => ty.super_fold_with(self),\n+        }\n+    }\n+\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        trace!(\"checking const {:?}\", ct);\n+        // Find a const parameter\n+        match ct.kind() {\n+            ty::ConstKind::Param(..) => {\n+                // Look it up in the substitution list.\n+                match self.map.get(&ct.into()).map(|k| k.unpack()) {\n+                    // Found it in the substitution list, replace with the parameter from the\n+                    // opaque type.\n+                    Some(GenericArgKind::Const(c1)) => c1,\n+                    Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n+                    None => {\n+                        self.tcx\n+                            .sess\n+                            .struct_span_err(\n+                                self.span,\n+                                &format!(\n+                                    \"const parameter `{}` is part of concrete type but not \\\n+                                          used in parameter list for the `impl Trait` type alias\",\n+                                    ct\n+                                ),\n+                            )\n+                            .emit();\n+\n+                        self.tcx().const_error(ct.ty())\n+                    }\n+                }\n+            }\n+\n+            _ => ct,\n+        }\n+    }\n+}"}, {"sha": "2a7713bc4df3b6d1e8be939ef07799a5c412f820", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=5dcd28cd1964969d605cddfcaec102006aa020c9", "patch": "@@ -503,7 +503,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         let root_empty = self\n             .infcx\n-            .next_nll_region_var(NllRegionVariableOrigin::RootEmptyRegion)\n+            .next_nll_region_var(NllRegionVariableOrigin::Existential { from_forall: true })\n             .to_region_vid();\n \n         UniversalRegions {"}, {"sha": "d566634a49203b9272a9ed4802f51f3d2fd70d04", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=5dcd28cd1964969d605cddfcaec102006aa020c9", "patch": "@@ -4,7 +4,7 @@\n //! and use that to decide when one free region outlives another, and so forth.\n \n use rustc_data_structures::transitive_relation::TransitiveRelation;\n-use rustc_middle::ty::{self, Lift, Region, TyCtxt};\n+use rustc_middle::ty::{Lift, Region, TyCtxt};\n \n /// Combines a `FreeRegionMap` and a `TyCtxt`.\n ///\n@@ -49,7 +49,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     // (with the exception that `'static: 'x` is not notable)\n     pub fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n         debug!(\"relate_regions(sub={:?}, sup={:?})\", sub, sup);\n-        if self.is_free_or_static(sub) && self.is_free(sup) {\n+        if sub.is_free_or_static() && sup.is_free() {\n             self.relation.add(sub, sup)\n         }\n     }\n@@ -68,7 +68,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         r_a: Region<'tcx>,\n         r_b: Region<'tcx>,\n     ) -> bool {\n-        assert!(self.is_free_or_static(r_a) && self.is_free_or_static(r_b));\n+        assert!(r_a.is_free_or_static() && r_b.is_free_or_static());\n         let re_static = tcx.lifetimes.re_static;\n         if self.check_relation(re_static, r_b) {\n             // `'a <= 'static` is always true, and not stored in the\n@@ -85,20 +85,6 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         r_a == r_b || self.relation.contains(r_a, r_b)\n     }\n \n-    /// True for free regions other than `'static`.\n-    pub fn is_free(&self, r: Region<'_>) -> bool {\n-        matches!(*r, ty::ReEarlyBound(_) | ty::ReFree(_))\n-    }\n-\n-    /// True if `r` is a free region or static of the sort that this\n-    /// free region map can be used with.\n-    pub fn is_free_or_static(&self, r: Region<'_>) -> bool {\n-        match *r {\n-            ty::ReStatic => true,\n-            _ => self.is_free(r),\n-        }\n-    }\n-\n     /// Computes the least-upper-bound of two free regions. In some\n     /// cases, this is more conservative than necessary, in order to\n     /// avoid making arbitrary choices. See\n@@ -110,8 +96,8 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         r_b: Region<'tcx>,\n     ) -> Region<'tcx> {\n         debug!(\"lub_free_regions(r_a={:?}, r_b={:?})\", r_a, r_b);\n-        assert!(self.is_free(r_a));\n-        assert!(self.is_free(r_b));\n+        assert!(r_a.is_free());\n+        assert!(r_b.is_free());\n         let result = if r_a == r_b {\n             r_a\n         } else {"}, {"sha": "3783cfb4cc5c85c85aaf53e674bdfb7916a95ba8", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=5dcd28cd1964969d605cddfcaec102006aa020c9", "patch": "@@ -47,7 +47,6 @@ pub(crate) fn resolve<'tcx>(\n #[derive(Clone)]\n pub struct LexicalRegionResolutions<'tcx> {\n     pub(crate) values: IndexVec<RegionVid, VarValue<'tcx>>,\n-    pub(crate) error_region: ty::Region<'tcx>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -140,7 +139,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     /// empty region. The `expansion` phase will grow this larger.\n     fn construct_var_data(&self, tcx: TyCtxt<'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n-            error_region: tcx.lifetimes.re_static,\n             values: IndexVec::from_fn_n(\n                 |vid| {\n                     let vid_universe = self.var_infos[vid].universe;\n@@ -310,7 +308,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         // Check for the case where we know that `'b: 'static` -- in that case,\n         // `a <= b` for all `a`.\n-        let b_free_or_static = self.region_rels.free_regions.is_free_or_static(b);\n+        let b_free_or_static = b.is_free_or_static();\n         if b_free_or_static && sub_free_regions(tcx.lifetimes.re_static, b) {\n             return true;\n         }\n@@ -320,7 +318,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         // `lub` relationship defined below, since sometimes the \"lub\"\n         // is actually the `postdom_upper_bound` (see\n         // `TransitiveRelation` for more details).\n-        let a_free_or_static = self.region_rels.free_regions.is_free_or_static(a);\n+        let a_free_or_static = a.is_free_or_static();\n         if a_free_or_static && b_free_or_static {\n             return sub_free_regions(a, b);\n         }\n@@ -864,10 +862,7 @@ impl<'tcx> LexicalRegionResolutions<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        tcx.fold_regions(value, |r, _db| match *r {\n-            ty::ReVar(rid) => self.resolve_var(rid),\n-            _ => r,\n-        })\n+        tcx.fold_regions(value, |r, _db| self.resolve_region(tcx, r))\n     }\n \n     fn value(&self, rid: RegionVid) -> &VarValue<'tcx> {\n@@ -878,12 +873,19 @@ impl<'tcx> LexicalRegionResolutions<'tcx> {\n         &mut self.values[rid]\n     }\n \n-    pub fn resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n-        let result = match self.values[rid] {\n-            VarValue::Value(r) => r,\n-            VarValue::ErrorValue => self.error_region,\n+    pub(crate) fn resolve_region(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        r: ty::Region<'tcx>,\n+    ) -> ty::Region<'tcx> {\n+        let result = match *r {\n+            ty::ReVar(rid) => match self.values[rid] {\n+                VarValue::Value(r) => r,\n+                VarValue::ErrorValue => tcx.lifetimes.re_static,\n+            },\n+            _ => r,\n         };\n-        debug!(\"resolve_var({:?}) = {:?}\", rid, result);\n+        debug!(\"resolve_region({:?}) = {:?}\", r, result);\n         result\n     }\n }"}, {"sha": "6e0f2d687437b6bc38324f1ddcc45385a3c2f65f", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=5dcd28cd1964969d605cddfcaec102006aa020c9", "patch": "@@ -466,9 +466,6 @@ pub enum NllRegionVariableOrigin {\n     /// from a `for<'a> T` binder). Meant to represent \"any region\".\n     Placeholder(ty::PlaceholderRegion),\n \n-    /// The variable we create to represent `'empty(U0)`.\n-    RootEmptyRegion,\n-\n     Existential {\n         /// If this is true, then this variable was created to represent a lifetime\n         /// bound in a `for` binder. For example, it might have been created to\n@@ -1250,7 +1247,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n \n         let lexical_region_resolutions = LexicalRegionResolutions {\n-            error_region: self.tcx.lifetimes.re_static,\n             values: rustc_index::vec::IndexVec::from_elem_n(\n                 crate::infer::lexical_region_resolve::VarValue::Value(self.tcx.lifetimes.re_erased),\n                 var_infos.len(),"}, {"sha": "3d99f0958f7f9a7220a0c8d946272b7520564ae5", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=5dcd28cd1964969d605cddfcaec102006aa020c9", "patch": "@@ -206,13 +206,13 @@ impl<'a, 'tcx> FallibleTypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n \n     fn try_fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n-            ty::ReVar(rid) => Ok(self\n+            ty::ReVar(_) => Ok(self\n                 .infcx\n                 .lexical_region_resolutions\n                 .borrow()\n                 .as_ref()\n                 .expect(\"region resolution not performed\")\n-                .resolve_var(rid)),\n+                .resolve_region(self.infcx.tcx, r)),\n             _ => Ok(r),\n         }\n     }"}, {"sha": "03e4319bbf1a8fa1ad1e212d80aadfbf37d3133c", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=5dcd28cd1964969d605cddfcaec102006aa020c9", "patch": "@@ -1570,6 +1570,19 @@ impl<'tcx> Region<'tcx> {\n             _ => bug!(\"free_region_binding_scope invoked on inappropriate region: {:?}\", self),\n         }\n     }\n+\n+    /// True for free regions other than `'static`.\n+    pub fn is_free(self) -> bool {\n+        matches!(*self, ty::ReEarlyBound(_) | ty::ReFree(_))\n+    }\n+\n+    /// True if `self` is a free region or static.\n+    pub fn is_free_or_static(self) -> bool {\n+        match *self {\n+            ty::ReStatic => true,\n+            _ => self.is_free(),\n+        }\n+    }\n }\n \n /// Type utilities"}, {"sha": "282ee632ce5817dcf32fd54458f6663f7bf2264b", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=5dcd28cd1964969d605cddfcaec102006aa020c9", "patch": "@@ -37,5 +37,4 @@ extern crate smallvec;\n \n pub mod autoderef;\n pub mod infer;\n-pub mod opaque_types;\n pub mod traits;"}, {"sha": "d290f7b074cb5a894d89d704c227324ae5afa762", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "removed", "additions": 0, "deletions": 545, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/9c6bcb60f30abee7648f8be67c880159db4366ce/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6bcb60f30abee7648f8be67c880159db4366ce/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=9c6bcb60f30abee7648f8be67c880159db4366ce", "patch": "@@ -1,545 +0,0 @@\n-use crate::traits;\n-use crate::traits::error_reporting::InferCtxtExt as _;\n-use crate::traits::TraitEngineExt as _;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::OpaqueTyOrigin;\n-use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n-use rustc_infer::infer::{InferCtxt, TyCtxtInferExt as _};\n-use rustc_infer::traits::{Obligation, ObligationCause, TraitEngine};\n-use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts};\n-use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, OpaqueHiddenType, OpaqueTypeKey, ToPredicate, Ty, TyCtxt};\n-use rustc_span::Span;\n-\n-pub trait InferCtxtExt<'tcx> {\n-    fn infer_opaque_definition_from_instantiation(\n-        &self,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        instantiated_ty: OpaqueHiddenType<'tcx>,\n-        origin: OpaqueTyOrigin,\n-    ) -> Ty<'tcx>;\n-}\n-\n-impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n-    /// Given the fully resolved, instantiated type for an opaque\n-    /// type, i.e., the value of an inference variable like C1 or C2\n-    /// (*), computes the \"definition type\" for an opaque type\n-    /// definition -- that is, the inferred value of `Foo1<'x>` or\n-    /// `Foo2<'x>` that we would conceptually use in its definition:\n-    /// ```ignore (illustrative)\n-    /// type Foo1<'x> = impl Bar<'x> = AAA;  // <-- this type AAA\n-    /// type Foo2<'x> = impl Bar<'x> = BBB;  // <-- or this type BBB\n-    /// fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n-    /// ```\n-    /// Note that these values are defined in terms of a distinct set of\n-    /// generic parameters (`'x` instead of `'a`) from C1 or C2. The main\n-    /// purpose of this function is to do that translation.\n-    ///\n-    /// (*) C1 and C2 were introduced in the comments on\n-    /// `register_member_constraints`. Read that comment for more context.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `def_id`, the `impl Trait` type\n-    /// - `substs`, the substs  used to instantiate this opaque type\n-    /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n-    ///   `opaque_defn.concrete_ty`\n-    #[instrument(level = \"debug\", skip(self))]\n-    fn infer_opaque_definition_from_instantiation(\n-        &self,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        instantiated_ty: OpaqueHiddenType<'tcx>,\n-        origin: OpaqueTyOrigin,\n-    ) -> Ty<'tcx> {\n-        if self.is_tainted_by_errors() {\n-            return self.tcx.ty_error();\n-        }\n-\n-        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n-\n-        // Use substs to build up a reverse map from regions to their\n-        // identity mappings. This is necessary because of `impl\n-        // Trait` lifetimes are computed by replacing existing\n-        // lifetimes with 'static and remapping only those used in the\n-        // `impl Trait` return type, resulting in the parameters\n-        // shifting.\n-        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id);\n-        debug!(?id_substs);\n-        let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> =\n-            substs.iter().enumerate().map(|(index, subst)| (subst, id_substs[index])).collect();\n-        debug!(\"map = {:#?}\", map);\n-\n-        // Convert the type from the function into a type valid outside\n-        // the function, by replacing invalid regions with 'static,\n-        // after producing an error for each of them.\n-        let definition_ty = instantiated_ty.ty.fold_with(&mut ReverseMapper::new(\n-            self.tcx,\n-            def_id,\n-            map,\n-            instantiated_ty.ty,\n-            instantiated_ty.span,\n-        ));\n-        debug!(?definition_ty);\n-\n-        if !check_opaque_type_parameter_valid(\n-            self.tcx,\n-            opaque_type_key,\n-            origin,\n-            instantiated_ty.span,\n-        ) {\n-            return self.tcx.ty_error();\n-        }\n-\n-        // Only check this for TAIT. RPIT already supports `src/test/ui/impl-trait/nested-return-type2.rs`\n-        // on stable and we'd break that.\n-        if let OpaqueTyOrigin::TyAlias = origin {\n-            // This logic duplicates most of `check_opaque_meets_bounds`.\n-            // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n-            let param_env = self.tcx.param_env(def_id);\n-            let body_id = self.tcx.local_def_id_to_hir_id(def_id.as_local().unwrap());\n-            self.tcx.infer_ctxt().enter(move |infcx| {\n-                // Require the hidden type to be well-formed with only the generics of the opaque type.\n-                // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n-                // hidden type is well formed even without those bounds.\n-                let predicate =\n-                    ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n-                        .to_predicate(infcx.tcx);\n-                let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-\n-                // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n-                // the bounds that the function supplies.\n-                match infcx.register_hidden_type(\n-                    OpaqueTypeKey { def_id, substs: id_substs },\n-                    ObligationCause::misc(instantiated_ty.span, body_id),\n-                    param_env,\n-                    definition_ty,\n-                    origin,\n-                ) {\n-                    Ok(infer_ok) => {\n-                        for obligation in infer_ok.obligations {\n-                            fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n-                        }\n-                    }\n-                    Err(err) => {\n-                        infcx\n-                            .report_mismatched_types(\n-                                &ObligationCause::misc(instantiated_ty.span, body_id),\n-                                self.tcx.mk_opaque(def_id, id_substs),\n-                                definition_ty,\n-                                err,\n-                            )\n-                            .emit();\n-                    }\n-                }\n-\n-                fulfillment_cx.register_predicate_obligation(\n-                    &infcx,\n-                    Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n-                );\n-\n-                // Check that all obligations are satisfied by the implementation's\n-                // version.\n-                let errors = fulfillment_cx.select_all_or_error(&infcx);\n-\n-                let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-\n-                if errors.is_empty() {\n-                    definition_ty\n-                } else {\n-                    infcx.report_fulfillment_errors(&errors, None, false);\n-                    self.tcx.ty_error()\n-                }\n-            })\n-        } else {\n-            definition_ty\n-        }\n-    }\n-}\n-\n-fn check_opaque_type_parameter_valid(\n-    tcx: TyCtxt<'_>,\n-    opaque_type_key: OpaqueTypeKey<'_>,\n-    origin: OpaqueTyOrigin,\n-    span: Span,\n-) -> bool {\n-    match origin {\n-        // No need to check return position impl trait (RPIT)\n-        // because for type and const parameters they are correct\n-        // by construction: we convert\n-        //\n-        // fn foo<P0..Pn>() -> impl Trait\n-        //\n-        // into\n-        //\n-        // type Foo<P0...Pn>\n-        // fn foo<P0..Pn>() -> Foo<P0...Pn>.\n-        //\n-        // For lifetime parameters we convert\n-        //\n-        // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n-        //\n-        // into\n-        //\n-        // type foo::<'p0..'pn>::Foo<'q0..'qm>\n-        // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n-        //\n-        // which would error here on all of the `'static` args.\n-        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return true,\n-        // Check these\n-        OpaqueTyOrigin::TyAlias => {}\n-    }\n-    let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n-    let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n-    for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n-        let arg_is_param = match arg.unpack() {\n-            GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n-            GenericArgKind::Lifetime(lt) if lt.is_static() => {\n-                tcx.sess\n-                    .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                    .span_label(\n-                        tcx.def_span(opaque_generics.param_at(i, tcx).def_id),\n-                        \"cannot use static lifetime; use a bound lifetime \\\n-                                    instead or remove the lifetime parameter from the \\\n-                                    opaque type\",\n-                    )\n-                    .emit();\n-                return false;\n-            }\n-            GenericArgKind::Lifetime(lt) => {\n-                matches!(*lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n-            }\n-            GenericArgKind::Const(ct) => matches!(ct.kind(), ty::ConstKind::Param(_)),\n-        };\n-\n-        if arg_is_param {\n-            seen_params.entry(arg).or_default().push(i);\n-        } else {\n-            // Prevent `fn foo() -> Foo<u32>` from being defining.\n-            let opaque_param = opaque_generics.param_at(i, tcx);\n-            tcx.sess\n-                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                .span_note(\n-                    tcx.def_span(opaque_param.def_id),\n-                    &format!(\n-                        \"used non-generic {} `{}` for generic parameter\",\n-                        opaque_param.kind.descr(),\n-                        arg,\n-                    ),\n-                )\n-                .emit();\n-            return false;\n-        }\n-    }\n-\n-    for (_, indices) in seen_params {\n-        if indices.len() > 1 {\n-            let descr = opaque_generics.param_at(indices[0], tcx).kind.descr();\n-            let spans: Vec<_> = indices\n-                .into_iter()\n-                .map(|i| tcx.def_span(opaque_generics.param_at(i, tcx).def_id))\n-                .collect();\n-            tcx.sess\n-                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                .span_note(spans, &format!(\"{} used multiple times\", descr))\n-                .emit();\n-            return false;\n-        }\n-    }\n-    true\n-}\n-\n-struct ReverseMapper<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-\n-    opaque_type_def_id: DefId,\n-    map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n-    map_missing_regions_to_empty: bool,\n-\n-    /// initially `Some`, set to `None` once error has been reported\n-    hidden_ty: Option<Ty<'tcx>>,\n-\n-    /// Span of function being checked.\n-    span: Span,\n-}\n-\n-impl<'tcx> ReverseMapper<'tcx> {\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        opaque_type_def_id: DefId,\n-        map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n-        hidden_ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> Self {\n-        Self {\n-            tcx,\n-            opaque_type_def_id,\n-            map,\n-            map_missing_regions_to_empty: false,\n-            hidden_ty: Some(hidden_ty),\n-            span,\n-        }\n-    }\n-\n-    fn fold_kind_mapping_missing_regions_to_empty(\n-        &mut self,\n-        kind: GenericArg<'tcx>,\n-    ) -> GenericArg<'tcx> {\n-        assert!(!self.map_missing_regions_to_empty);\n-        self.map_missing_regions_to_empty = true;\n-        let kind = kind.fold_with(self);\n-        self.map_missing_regions_to_empty = false;\n-        kind\n-    }\n-\n-    fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n-        assert!(!self.map_missing_regions_to_empty);\n-        kind.fold_with(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match *r {\n-            // Ignore bound regions and `'static` regions that appear in the\n-            // type, we only need to remap regions that reference lifetimes\n-            // from the function declaration.\n-            // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n-            ty::ReLateBound(..) | ty::ReStatic => return r,\n-\n-            // If regions have been erased (by writeback), don't try to unerase\n-            // them.\n-            ty::ReErased => return r,\n-\n-            // The regions that we expect from borrow checking.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReEmpty(ty::UniverseIndex::ROOT) => {}\n-\n-            ty::ReEmpty(_) | ty::RePlaceholder(_) | ty::ReVar(_) => {\n-                // All of the regions in the type should either have been\n-                // erased by writeback, or mapped back to named regions by\n-                // borrow checking.\n-                bug!(\"unexpected region kind in opaque type: {:?}\", r);\n-            }\n-        }\n-\n-        let generics = self.tcx().generics_of(self.opaque_type_def_id);\n-        match self.map.get(&r.into()).map(|k| k.unpack()) {\n-            Some(GenericArgKind::Lifetime(r1)) => r1,\n-            Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n-            None if self.map_missing_regions_to_empty => self.tcx.lifetimes.re_root_empty,\n-            None if generics.parent.is_some() => {\n-                if let Some(hidden_ty) = self.hidden_ty.take() {\n-                    unexpected_hidden_region_diagnostic(\n-                        self.tcx,\n-                        self.tcx.def_span(self.opaque_type_def_id),\n-                        hidden_ty,\n-                        r,\n-                    )\n-                    .emit();\n-                }\n-                self.tcx.lifetimes.re_root_empty\n-            }\n-            None => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(self.span, \"non-defining opaque type use in defining scope\")\n-                    .span_label(\n-                        self.span,\n-                        format!(\n-                            \"lifetime `{}` is part of concrete type but not used in \\\n-                                 parameter list of the `impl Trait` type alias\",\n-                            r\n-                        ),\n-                    )\n-                    .emit();\n-\n-                self.tcx().lifetimes.re_static\n-            }\n-        }\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match *ty.kind() {\n-            ty::Closure(def_id, substs) => {\n-                // I am a horrible monster and I pray for death. When\n-                // we encounter a closure here, it is always a closure\n-                // from within the function that we are currently\n-                // type-checking -- one that is now being encapsulated\n-                // in an opaque type. Ideally, we would\n-                // go through the types/lifetimes that it references\n-                // and treat them just like we would any other type,\n-                // which means we would error out if we find any\n-                // reference to a type/region that is not in the\n-                // \"reverse map\".\n-                //\n-                // **However,** in the case of closures, there is a\n-                // somewhat subtle (read: hacky) consideration. The\n-                // problem is that our closure types currently include\n-                // all the lifetime parameters declared on the\n-                // enclosing function, even if they are unused by the\n-                // closure itself. We can't readily filter them out,\n-                // so here we replace those values with `'empty`. This\n-                // can't really make a difference to the rest of the\n-                // compiler; those regions are ignored for the\n-                // outlives relation, and hence don't affect trait\n-                // selection or auto traits, and they are erased\n-                // during codegen.\n-\n-                let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n-                    if index < generics.parent_count {\n-                        // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n-                    } else {\n-                        // ...but not elsewhere.\n-                        self.fold_kind_normally(kind)\n-                    }\n-                }));\n-\n-                self.tcx.mk_closure(def_id, substs)\n-            }\n-\n-            ty::Generator(def_id, substs, movability) => {\n-                let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n-                    if index < generics.parent_count {\n-                        // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n-                    } else {\n-                        // ...but not elsewhere.\n-                        self.fold_kind_normally(kind)\n-                    }\n-                }));\n-\n-                self.tcx.mk_generator(def_id, substs, movability)\n-            }\n-\n-            ty::Param(param) => {\n-                // Look it up in the substitution list.\n-                match self.map.get(&ty.into()).map(|k| k.unpack()) {\n-                    // Found it in the substitution list; replace with the parameter from the\n-                    // opaque type.\n-                    Some(GenericArgKind::Type(t1)) => t1,\n-                    Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n-                    None => {\n-                        debug!(?param, ?self.map);\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                self.span,\n-                                &format!(\n-                                    \"type parameter `{}` is part of concrete type but not \\\n-                                          used in parameter list for the `impl Trait` type alias\",\n-                                    ty\n-                                ),\n-                            )\n-                            .emit();\n-\n-                        self.tcx().ty_error()\n-                    }\n-                }\n-            }\n-\n-            _ => ty.super_fold_with(self),\n-        }\n-    }\n-\n-    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n-        trace!(\"checking const {:?}\", ct);\n-        // Find a const parameter\n-        match ct.kind() {\n-            ty::ConstKind::Param(..) => {\n-                // Look it up in the substitution list.\n-                match self.map.get(&ct.into()).map(|k| k.unpack()) {\n-                    // Found it in the substitution list, replace with the parameter from the\n-                    // opaque type.\n-                    Some(GenericArgKind::Const(c1)) => c1,\n-                    Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n-                    None => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                self.span,\n-                                &format!(\n-                                    \"const parameter `{}` is part of concrete type but not \\\n-                                          used in parameter list for the `impl Trait` type alias\",\n-                                    ct\n-                                ),\n-                            )\n-                            .emit();\n-\n-                        self.tcx().const_error(ct.ty())\n-                    }\n-                }\n-            }\n-\n-            _ => ct,\n-        }\n-    }\n-}\n-\n-/// Given a set of predicates that apply to an object type, returns\n-/// the region bounds that the (erased) `Self` type must\n-/// outlive. Precisely *because* the `Self` type is erased, the\n-/// parameter `erased_self_ty` must be supplied to indicate what type\n-/// has been used to represent `Self` in the predicates\n-/// themselves. This should really be a unique type; `FreshTy(0)` is a\n-/// popular choice.\n-///\n-/// N.B., in some cases, particularly around higher-ranked bounds,\n-/// this function returns a kind of conservative approximation.\n-/// That is, all regions returned by this function are definitely\n-/// required, but there may be other region bounds that are not\n-/// returned, as well as requirements like `for<'a> T: 'a`.\n-///\n-/// Requires that trait definitions have been processed so that we can\n-/// elaborate predicates and walk supertraits.\n-#[instrument(skip(tcx, predicates), level = \"debug\")]\n-pub(crate) fn required_region_bounds<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    erased_self_ty: Ty<'tcx>,\n-    predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n-) -> Vec<ty::Region<'tcx>> {\n-    assert!(!erased_self_ty.has_escaping_bound_vars());\n-\n-    traits::elaborate_predicates(tcx, predicates)\n-        .filter_map(|obligation| {\n-            debug!(?obligation);\n-            match obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Projection(..)\n-                | ty::PredicateKind::Trait(..)\n-                | ty::PredicateKind::Subtype(..)\n-                | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::WellFormed(..)\n-                | ty::PredicateKind::ObjectSafe(..)\n-                | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::RegionOutlives(..)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n-                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n-                    // Search for a bound of the form `erased_self_ty\n-                    // : 'a`, but be wary of something like `for<'a>\n-                    // erased_self_ty : 'a` (we interpret a\n-                    // higher-ranked bound like that as 'static,\n-                    // though at present the code in `fulfill.rs`\n-                    // considers such bounds to be unsatisfiable, so\n-                    // it's kind of a moot point since you could never\n-                    // construct such an object, but this seems\n-                    // correct even if that code changes).\n-                    if t == &erased_self_ty && !r.has_escaping_bound_vars() {\n-                        Some(*r)\n-                    } else {\n-                        None\n-                    }\n-                }\n-            }\n-        })\n-        .collect()\n-}"}, {"sha": "3dfc7a9cacd97c69016e67242cc660040724c7bb", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dcd28cd1964969d605cddfcaec102006aa020c9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=5dcd28cd1964969d605cddfcaec102006aa020c9", "patch": "@@ -1,5 +1,4 @@\n use crate::infer::InferCtxt;\n-use crate::opaque_types::required_region_bounds;\n use crate::traits;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -810,3 +809,63 @@ pub fn object_region_bounds<'tcx>(\n \n     required_region_bounds(tcx, open_ty, predicates)\n }\n+\n+/// Given a set of predicates that apply to an object type, returns\n+/// the region bounds that the (erased) `Self` type must\n+/// outlive. Precisely *because* the `Self` type is erased, the\n+/// parameter `erased_self_ty` must be supplied to indicate what type\n+/// has been used to represent `Self` in the predicates\n+/// themselves. This should really be a unique type; `FreshTy(0)` is a\n+/// popular choice.\n+///\n+/// N.B., in some cases, particularly around higher-ranked bounds,\n+/// this function returns a kind of conservative approximation.\n+/// That is, all regions returned by this function are definitely\n+/// required, but there may be other region bounds that are not\n+/// returned, as well as requirements like `for<'a> T: 'a`.\n+///\n+/// Requires that trait definitions have been processed so that we can\n+/// elaborate predicates and walk supertraits.\n+#[instrument(skip(tcx, predicates), level = \"debug\")]\n+pub(crate) fn required_region_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    erased_self_ty: Ty<'tcx>,\n+    predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n+) -> Vec<ty::Region<'tcx>> {\n+    assert!(!erased_self_ty.has_escaping_bound_vars());\n+\n+    traits::elaborate_predicates(tcx, predicates)\n+        .filter_map(|obligation| {\n+            debug!(?obligation);\n+            match obligation.predicate.kind().skip_binder() {\n+                ty::PredicateKind::Projection(..)\n+                | ty::PredicateKind::Trait(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n+                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n+                    // Search for a bound of the form `erased_self_ty\n+                    // : 'a`, but be wary of something like `for<'a>\n+                    // erased_self_ty : 'a` (we interpret a\n+                    // higher-ranked bound like that as 'static,\n+                    // though at present the code in `fulfill.rs`\n+                    // considers such bounds to be unsatisfiable, so\n+                    // it's kind of a moot point since you could never\n+                    // construct such an object, but this seems\n+                    // correct even if that code changes).\n+                    if t == &erased_self_ty && !r.has_escaping_bound_vars() {\n+                        Some(*r)\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }\n+        })\n+        .collect()\n+}"}]}