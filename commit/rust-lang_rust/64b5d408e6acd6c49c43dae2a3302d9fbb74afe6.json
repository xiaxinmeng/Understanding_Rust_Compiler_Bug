{"sha": "64b5d408e6acd6c49c43dae2a3302d9fbb74afe6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0YjVkNDA4ZTZhY2Q2YzQ5YzQzZGFlMmEzMzAyZDlmYmI3NGFmZTY=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-04-06T12:52:36Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-04-25T09:25:40Z"}, "message": "Make DepGraph thread-safe", "tree": {"sha": "86f725e272f1e19f728059b5149fea85469dbf87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86f725e272f1e19f728059b5149fea85469dbf87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64b5d408e6acd6c49c43dae2a3302d9fbb74afe6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64b5d408e6acd6c49c43dae2a3302d9fbb74afe6", "html_url": "https://github.com/rust-lang/rust/commit/64b5d408e6acd6c49c43dae2a3302d9fbb74afe6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64b5d408e6acd6c49c43dae2a3302d9fbb74afe6/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc794209681d6b11a63282bcd1513caa50127816", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc794209681d6b11a63282bcd1513caa50127816", "html_url": "https://github.com/rust-lang/rust/commit/cc794209681d6b11a63282bcd1513caa50127816"}], "stats": {"total": 392, "additions": 205, "deletions": 187}, "files": [{"sha": "8cb4610ffedd463362e2bff1f46ae905cba9a415", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 188, "deletions": 132, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/64b5d408e6acd6c49c43dae2a3302d9fbb74afe6/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b5d408e6acd6c49c43dae2a3302d9fbb74afe6/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=64b5d408e6acd6c49c43dae2a3302d9fbb74afe6", "patch": "@@ -12,19 +12,17 @@ use errors::DiagnosticBuilder;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::sync::Lrc;\n-use std::cell::{Ref, RefCell};\n+use rustc_data_structures::sync::{Lrc, RwLock, ReadGuard, Lock};\n use std::env;\n use std::hash::Hash;\n-use ty::TyCtxt;\n+use ty::{self, TyCtxt};\n use util::common::{ProfileQueriesMsg, profq_msg};\n \n use ich::{StableHashingContext, StableHashingContextProvider, Fingerprint};\n \n use super::debug::EdgeFilter;\n use super::dep_node::{DepNode, DepKind, WorkProductId};\n use super::query::DepGraphQuery;\n-use super::raii;\n use super::safe::DepGraphSafe;\n use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n use super::prev::PreviousDepGraph;\n@@ -37,7 +35,7 @@ pub struct DepGraph {\n     // result value fingerprints. Do not rely on the length of this vector\n     // being the same as the number of nodes in the graph. The vector can\n     // contain an arbitrary number of zero-entries at the end.\n-    fingerprints: Lrc<RefCell<IndexVec<DepNodeIndex, Fingerprint>>>\n+    fingerprints: Lrc<Lock<IndexVec<DepNodeIndex, Fingerprint>>>\n }\n \n \n@@ -67,27 +65,27 @@ struct DepGraphData {\n     /// tracking. The `current` field is the dependency graph of only the\n     /// current compilation session: We don't merge the previous dep-graph into\n     /// current one anymore.\n-    current: RefCell<CurrentDepGraph>,\n+    current: Lock<CurrentDepGraph>,\n \n     /// The dep-graph from the previous compilation session. It contains all\n     /// nodes and edges as well as all fingerprints of nodes that have them.\n     previous: PreviousDepGraph,\n \n-    colors: RefCell<DepNodeColorMap>,\n+    colors: Lock<DepNodeColorMap>,\n \n     /// When we load, there may be `.o` files, cached mir, or other such\n     /// things available to us. If we find that they are not dirty, we\n     /// load the path to the file storing those work-products here into\n     /// this map. We can later look for and extract that data.\n-    previous_work_products: RefCell<FxHashMap<WorkProductId, WorkProduct>>,\n+    previous_work_products: RwLock<FxHashMap<WorkProductId, WorkProduct>>,\n \n     /// Work-products that we generate in this run.\n-    work_products: RefCell<FxHashMap<WorkProductId, WorkProduct>>,\n+    work_products: RwLock<FxHashMap<WorkProductId, WorkProduct>>,\n \n-    dep_node_debug: RefCell<FxHashMap<DepNode, String>>,\n+    dep_node_debug: Lock<FxHashMap<DepNode, String>>,\n \n     // Used for testing, only populated when -Zquery-dep-graph is specified.\n-    loaded_from_cache: RefCell<FxHashMap<DepNodeIndex, bool>>,\n+    loaded_from_cache: Lock<FxHashMap<DepNodeIndex, bool>>,\n }\n \n impl DepGraph {\n@@ -102,22 +100,22 @@ impl DepGraph {\n                                                  (prev_graph_node_count * 115) / 100);\n         DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n-                previous_work_products: RefCell::new(FxHashMap()),\n-                work_products: RefCell::new(FxHashMap()),\n-                dep_node_debug: RefCell::new(FxHashMap()),\n-                current: RefCell::new(CurrentDepGraph::new()),\n+                previous_work_products: RwLock::new(FxHashMap()),\n+                work_products: RwLock::new(FxHashMap()),\n+                dep_node_debug: Lock::new(FxHashMap()),\n+                current: Lock::new(CurrentDepGraph::new()),\n                 previous: prev_graph,\n-                colors: RefCell::new(DepNodeColorMap::new(prev_graph_node_count)),\n-                loaded_from_cache: RefCell::new(FxHashMap()),\n+                colors: Lock::new(DepNodeColorMap::new(prev_graph_node_count)),\n+                loaded_from_cache: Lock::new(FxHashMap()),\n             })),\n-            fingerprints: Lrc::new(RefCell::new(fingerprints)),\n+            fingerprints: Lrc::new(Lock::new(fingerprints)),\n         }\n     }\n \n     pub fn new_disabled() -> DepGraph {\n         DepGraph {\n             data: None,\n-            fingerprints: Lrc::new(RefCell::new(IndexVec::new())),\n+            fingerprints: Lrc::new(Lock::new(IndexVec::new())),\n         }\n     }\n \n@@ -144,21 +142,32 @@ impl DepGraph {\n \n     pub fn assert_ignored(&self)\n     {\n-        if let Some(ref data) = self.data {\n-            match data.current.borrow().task_stack.last() {\n-                Some(&OpenTask::Ignore) | None => {\n-                    // ignored\n+        if let Some(..) = self.data {\n+            ty::tls::with_context_opt(|icx| {\n+                let icx = if let Some(icx) = icx { icx } else { return };\n+                match *icx.task.lock() {\n+                    OpenTask::Ignore => {\n+                        // ignored\n+                    }\n+                    _ => panic!(\"expected an ignore context\")\n                 }\n-                _ => panic!(\"expected an ignore context\")\n-            }\n+            })\n         }\n     }\n \n     pub fn with_ignore<OP,R>(&self, op: OP) -> R\n         where OP: FnOnce() -> R\n     {\n-        let _task = self.data.as_ref().map(|data| raii::IgnoreTask::new(&data.current));\n-        op()\n+        ty::tls::with_context(|icx| {\n+            let icx = ty::tls::ImplicitCtxt {\n+                task: &Lock::new(OpenTask::Ignore),\n+                ..icx.clone()\n+            };\n+\n+            ty::tls::enter_context(&icx, |_| {\n+                op()\n+            })\n+        })\n     }\n \n     /// Starts a new dep-graph task. Dep-graph tasks are specified\n@@ -197,24 +206,49 @@ impl DepGraph {\n         where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n               R: HashStable<StableHashingContext<'gcx>>,\n     {\n-        self.with_task_impl(key, cx, arg, task,\n-            |data, key| data.borrow_mut().push_task(key),\n-            |data, key| data.borrow_mut().pop_task(key))\n+        self.with_task_impl(key, cx, arg, false, task,\n+            |key| OpenTask::Regular {\n+                node: key,\n+                reads: Vec::new(),\n+                read_set: FxHashSet(),\n+            },\n+            |data, key, task| data.borrow_mut().complete_task(key, task))\n+    }\n+\n+    /// Creates a new dep-graph input with value `input`\n+    pub fn input_task<'gcx, C, R>(&self,\n+                                   key: DepNode,\n+                                   cx: C,\n+                                   input: R)\n+                                   -> (R, DepNodeIndex)\n+        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n+              R: HashStable<StableHashingContext<'gcx>>,\n+    {\n+        fn identity_fn<C, A>(_: C, arg: A) -> A {\n+            arg\n+        }\n+\n+        self.with_task_impl(key, cx, input, true, identity_fn,\n+            |_| OpenTask::Ignore,\n+            |data, key, _| data.borrow_mut().alloc_node(key, Vec::new()))\n     }\n \n     fn with_task_impl<'gcx, C, A, R>(&self,\n-                                    key: DepNode,\n-                                    cx: C,\n-                                    arg: A,\n-                                    task: fn(C, A) -> R,\n-                                    push: fn(&RefCell<CurrentDepGraph>, DepNode),\n-                                    pop: fn(&RefCell<CurrentDepGraph>, DepNode) -> DepNodeIndex)\n-                                    -> (R, DepNodeIndex)\n+                                     key: DepNode,\n+                                     cx: C,\n+                                     arg: A,\n+                                     no_tcx: bool,\n+                                     task: fn(C, A) -> R,\n+                                     get_task: fn(DepNode) -> OpenTask,\n+                                     get_index: fn(&Lock<CurrentDepGraph>,\n+                                                   DepNode,\n+                                                   OpenTask) -> DepNodeIndex)\n+                                     -> (R, DepNodeIndex)\n         where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n               R: HashStable<StableHashingContext<'gcx>>,\n     {\n         if let Some(ref data) = self.data {\n-            push(&data.current, key);\n+            let open_task = get_task(key);\n \n             // In incremental mode, hash the result of the task. We don't\n             // do anything with the hash yet, but we are computing it\n@@ -227,13 +261,32 @@ impl DepGraph {\n                 profq_msg(hcx.sess(), ProfileQueriesMsg::TaskBegin(key.clone()))\n             };\n \n-            let result = task(cx, arg);\n+            let (result, open_task) = if no_tcx {\n+                (task(cx, arg), open_task)\n+            } else {\n+                ty::tls::with_context(|icx| {\n+                    let open_task = Lock::new(open_task);\n+\n+                    let r = {\n+                        let icx = ty::tls::ImplicitCtxt {\n+                            task: &open_task,\n+                            ..icx.clone()\n+                        };\n+\n+                        ty::tls::enter_context(&icx, |_| {\n+                            task(cx, arg)\n+                        })\n+                    };\n+\n+                    (r, open_task.into_inner())\n+                })\n+            };\n \n             if cfg!(debug_assertions) {\n                 profq_msg(hcx.sess(), ProfileQueriesMsg::TaskEnd)\n             };\n \n-            let dep_node_index = pop(&data.current, key);\n+            let dep_node_index = get_index(&data.current, key, open_task);\n \n             let mut stable_hasher = StableHasher::new();\n             result.hash_stable(&mut hcx, &mut stable_hasher);\n@@ -302,11 +355,28 @@ impl DepGraph {\n         where OP: FnOnce() -> R\n     {\n         if let Some(ref data) = self.data {\n-            data.current.borrow_mut().push_anon_task();\n-            let result = op();\n+            let (result, open_task) = ty::tls::with_context(|icx| {\n+                let task = Lock::new(OpenTask::Anon {\n+                    reads: Vec::new(),\n+                    read_set: FxHashSet(),\n+                });\n+\n+                let r = {\n+                    let icx = ty::tls::ImplicitCtxt {\n+                        task: &task,\n+                        ..icx.clone()\n+                    };\n+\n+                    ty::tls::enter_context(&icx, |_| {\n+                        op()\n+                    })\n+                };\n+\n+                (r, task.into_inner())\n+            });\n             let dep_node_index = data.current\n                                      .borrow_mut()\n-                                     .pop_anon_task(dep_kind);\n+                                     .pop_anon_task(dep_kind, open_task);\n             (result, dep_node_index)\n         } else {\n             (op(), DepNodeIndex::INVALID)\n@@ -324,9 +394,9 @@ impl DepGraph {\n         where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n               R: HashStable<StableHashingContext<'gcx>>,\n     {\n-        self.with_task_impl(key, cx, arg, task,\n-            |data, key| data.borrow_mut().push_eval_always_task(key),\n-            |data, key| data.borrow_mut().pop_eval_always_task(key))\n+        self.with_task_impl(key, cx, arg, false, task,\n+            |key| OpenTask::EvalAlways { node: key },\n+            |data, key, task| data.borrow_mut().complete_eval_always_task(key, task))\n     }\n \n     #[inline]\n@@ -432,13 +502,13 @@ impl DepGraph {\n \n     /// Access the map of work-products created during this run. Only\n     /// used during saving of the dep-graph.\n-    pub fn work_products(&self) -> Ref<FxHashMap<WorkProductId, WorkProduct>> {\n+    pub fn work_products(&self) -> ReadGuard<FxHashMap<WorkProductId, WorkProduct>> {\n         self.data.as_ref().unwrap().work_products.borrow()\n     }\n \n     /// Access the map of work-products created during the cached run. Only\n     /// used during saving of the dep-graph.\n-    pub fn previous_work_products(&self) -> Ref<FxHashMap<WorkProductId, WorkProduct>> {\n+    pub fn previous_work_products(&self) -> ReadGuard<FxHashMap<WorkProductId, WorkProduct>> {\n         self.data.as_ref().unwrap().previous_work_products.borrow()\n     }\n \n@@ -528,6 +598,7 @@ impl DepGraph {\n         debug!(\"try_mark_green({:?}) - BEGIN\", dep_node);\n         let data = self.data.as_ref().unwrap();\n \n+        #[cfg(not(parallel_queries))]\n         debug_assert!(!data.current.borrow().node_to_node_index.contains_key(dep_node));\n \n         if dep_node.kind.is_input() {\n@@ -668,16 +739,24 @@ impl DepGraph {\n             }\n         }\n \n-\n         // If we got here without hitting a `return` that means that all\n         // dependencies of this DepNode could be marked as green. Therefore we\n-        // can also mark this DepNode as green. We do so by...\n+        // can also mark this DepNode as green.\n \n-        // ... allocating an entry for it in the current dependency graph and\n-        // adding all the appropriate edges imported from the previous graph ...\n-        let dep_node_index = data.current\n-                                 .borrow_mut()\n-                                 .alloc_node(*dep_node, current_deps);\n+        // There may be multiple threads trying to mark the same dep node green concurrently\n+\n+        let (dep_node_index, did_allocation) = {\n+            let mut current = data.current.borrow_mut();\n+\n+            if let Some(&dep_node_index) = current.node_to_node_index.get(&dep_node) {\n+                // Someone else allocated it before us\n+                (dep_node_index, false)\n+            } else {\n+                // We allocating an entry for the node in the current dependency graph and\n+                // adding all the appropriate edges imported from the previous graph\n+                (current.alloc_node(*dep_node, current_deps), true)\n+            }\n+        };\n \n         // ... copying the fingerprint from the previous graph too, so we don't\n         // have to recompute it ...\n@@ -689,6 +768,8 @@ impl DepGraph {\n                 fingerprints.resize(dep_node_index.index() + 1, Fingerprint::ZERO);\n             }\n \n+            // Multiple threads can all write the same fingerprint here\n+            #[cfg(not(parallel_queries))]\n             debug_assert!(fingerprints[dep_node_index] == Fingerprint::ZERO,\n                 \"DepGraph::try_mark_green() - Duplicate fingerprint \\\n                 insertion for {:?}\", dep_node);\n@@ -697,7 +778,14 @@ impl DepGraph {\n         }\n \n         // ... emitting any stored diagnostic ...\n-        {\n+        if did_allocation {\n+            // Only the thread which did the allocation emits the error messages\n+\n+            // FIXME: Ensure that these are printed before returning for all threads.\n+            // Currently threads where did_allocation = false can continue on\n+            // and emit other diagnostics before these diagnostics are emitted.\n+            // Such diagnostics should be emitted after these.\n+            // See https://github.com/rust-lang/rust/issues/48685\n             let diagnostics = tcx.on_disk_query_result_cache\n                                  .load_diagnostics(tcx, prev_dep_node_index);\n \n@@ -716,6 +804,8 @@ impl DepGraph {\n \n         // ... and finally storing a \"Green\" entry in the color map.\n         let mut colors = data.colors.borrow_mut();\n+        // Multiple threads can all write the same color here\n+        #[cfg(not(parallel_queries))]\n         debug_assert!(colors.get(prev_dep_node_index).is_none(),\n                       \"DepGraph::try_mark_green() - Duplicate DepNodeColor \\\n                       insertion for {:?}\", dep_node);\n@@ -839,7 +929,6 @@ pub(super) struct CurrentDepGraph {\n     nodes: IndexVec<DepNodeIndex, DepNode>,\n     edges: IndexVec<DepNodeIndex, Vec<DepNodeIndex>>,\n     node_to_node_index: FxHashMap<DepNode, DepNodeIndex>,\n-    task_stack: Vec<OpenTask>,\n     forbidden_edge: Option<EdgeFilter>,\n \n     // Anonymous DepNodes are nodes the ID of which we compute from the list of\n@@ -888,38 +977,18 @@ impl CurrentDepGraph {\n             edges: IndexVec::new(),\n             node_to_node_index: FxHashMap(),\n             anon_id_seed: stable_hasher.finish(),\n-            task_stack: Vec::new(),\n             forbidden_edge,\n             total_read_count: 0,\n             total_duplicate_read_count: 0,\n         }\n     }\n \n-    pub(super) fn push_ignore(&mut self) {\n-        self.task_stack.push(OpenTask::Ignore);\n-    }\n-\n-    pub(super) fn pop_ignore(&mut self) {\n-        let popped_node = self.task_stack.pop().unwrap();\n-        debug_assert_eq!(popped_node, OpenTask::Ignore);\n-    }\n-\n-    pub(super) fn push_task(&mut self, key: DepNode) {\n-        self.task_stack.push(OpenTask::Regular {\n-            node: key,\n-            reads: Vec::new(),\n-            read_set: FxHashSet(),\n-        });\n-    }\n-\n-    pub(super) fn pop_task(&mut self, key: DepNode) -> DepNodeIndex {\n-        let popped_node = self.task_stack.pop().unwrap();\n-\n+    pub(super) fn complete_task(&mut self, key: DepNode, task: OpenTask) -> DepNodeIndex {\n         if let OpenTask::Regular {\n             node,\n             read_set: _,\n             reads\n-        } = popped_node {\n+        } = task {\n             assert_eq!(node, key);\n \n             // If this is an input node, we expect that it either has no\n@@ -946,24 +1015,15 @@ impl CurrentDepGraph {\n \n             self.alloc_node(node, reads)\n         } else {\n-            bug!(\"pop_task() - Expected regular task to be popped\")\n+            bug!(\"complete_task() - Expected regular task to be popped\")\n         }\n     }\n \n-    fn push_anon_task(&mut self) {\n-        self.task_stack.push(OpenTask::Anon {\n-            reads: Vec::new(),\n-            read_set: FxHashSet(),\n-        });\n-    }\n-\n-    fn pop_anon_task(&mut self, kind: DepKind) -> DepNodeIndex {\n-        let popped_node = self.task_stack.pop().unwrap();\n-\n+    fn pop_anon_task(&mut self, kind: DepKind, task: OpenTask) -> DepNodeIndex {\n         if let OpenTask::Anon {\n             read_set: _,\n             reads\n-        } = popped_node {\n+        } = task {\n             debug_assert!(!kind.is_input());\n \n             let mut fingerprint = self.anon_id_seed;\n@@ -997,62 +1057,58 @@ impl CurrentDepGraph {\n         }\n     }\n \n-    fn push_eval_always_task(&mut self, key: DepNode) {\n-        self.task_stack.push(OpenTask::EvalAlways { node: key });\n-    }\n-\n-    fn pop_eval_always_task(&mut self, key: DepNode) -> DepNodeIndex {\n-        let popped_node = self.task_stack.pop().unwrap();\n-\n+    fn complete_eval_always_task(&mut self, key: DepNode, task: OpenTask) -> DepNodeIndex {\n         if let OpenTask::EvalAlways {\n             node,\n-        } = popped_node {\n+        } = task {\n             debug_assert_eq!(node, key);\n             let krate_idx = self.node_to_node_index[&DepNode::new_no_params(DepKind::Krate)];\n             self.alloc_node(node, vec![krate_idx])\n         } else {\n-            bug!(\"pop_eval_always_task() - Expected eval always task to be popped\");\n+            bug!(\"complete_eval_always_task() - Expected eval always task to be popped\");\n         }\n     }\n \n     fn read_index(&mut self, source: DepNodeIndex) {\n-        match self.task_stack.last_mut() {\n-            Some(&mut OpenTask::Regular {\n-                ref mut reads,\n-                ref mut read_set,\n-                node: ref target,\n-            }) => {\n-                self.total_read_count += 1;\n-                if read_set.insert(source) {\n-                    reads.push(source);\n-\n-                    if cfg!(debug_assertions) {\n-                        if let Some(ref forbidden_edge) = self.forbidden_edge {\n-                            let source = self.nodes[source];\n-                            if forbidden_edge.test(&source, &target) {\n-                                bug!(\"forbidden edge {:?} -> {:?} created\",\n-                                     source,\n-                                     target)\n+        ty::tls::with_context_opt(|icx| {\n+            let icx = if let Some(icx) = icx { icx } else { return };\n+            match *icx.task.lock() {\n+                OpenTask::Regular {\n+                    ref mut reads,\n+                    ref mut read_set,\n+                    node: ref target,\n+                } => {\n+                    self.total_read_count += 1;\n+                    if read_set.insert(source) {\n+                        reads.push(source);\n+\n+                        if cfg!(debug_assertions) {\n+                            if let Some(ref forbidden_edge) = self.forbidden_edge {\n+                                let source = self.nodes[source];\n+                                if forbidden_edge.test(&source, &target) {\n+                                    bug!(\"forbidden edge {:?} -> {:?} created\",\n+                                        source,\n+                                        target)\n+                                }\n                             }\n                         }\n+                    } else {\n+                        self.total_duplicate_read_count += 1;\n                     }\n-                } else {\n-                    self.total_duplicate_read_count += 1;\n                 }\n-            }\n-            Some(&mut OpenTask::Anon {\n-                ref mut reads,\n-                ref mut read_set,\n-            }) => {\n-                if read_set.insert(source) {\n-                    reads.push(source);\n+                OpenTask::Anon {\n+                    ref mut reads,\n+                    ref mut read_set,\n+                } => {\n+                    if read_set.insert(source) {\n+                        reads.push(source);\n+                    }\n+                }\n+                OpenTask::Ignore | OpenTask::EvalAlways { .. } => {\n+                    // ignore\n                 }\n             }\n-            Some(&mut OpenTask::Ignore) |\n-            Some(&mut OpenTask::EvalAlways { .. }) | None => {\n-                // ignore\n-            }\n-        }\n+        })\n     }\n \n     fn alloc_node(&mut self,\n@@ -1071,7 +1127,7 @@ impl CurrentDepGraph {\n }\n \n #[derive(Clone, Debug, PartialEq)]\n-enum OpenTask {\n+pub enum OpenTask {\n     Regular {\n         node: DepNode,\n         reads: Vec<DepNodeIndex>,"}, {"sha": "8a6f66911ece408c6fa353f7dbd1f804dff38ff1", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/64b5d408e6acd6c49c43dae2a3302d9fbb74afe6/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b5d408e6acd6c49c43dae2a3302d9fbb74afe6/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=64b5d408e6acd6c49c43dae2a3302d9fbb74afe6", "patch": "@@ -14,13 +14,12 @@ mod dep_tracking_map;\n mod graph;\n mod prev;\n mod query;\n-mod raii;\n mod safe;\n mod serialized;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId, label_strs};\n-pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor};\n+pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor, OpenTask};\n pub use self::graph::WorkProductFileKind;\n pub use self::prev::PreviousDepGraph;\n pub use self::query::DepGraphQuery;"}, {"sha": "5728bcc7d27710dbccc7cfa69e32a904bc79976e", "filename": "src/librustc/dep_graph/raii.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cc794209681d6b11a63282bcd1513caa50127816/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc794209681d6b11a63282bcd1513caa50127816/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=cc794209681d6b11a63282bcd1513caa50127816", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use super::graph::CurrentDepGraph;\n-\n-use std::cell::RefCell;\n-\n-pub struct IgnoreTask<'graph> {\n-    graph: &'graph RefCell<CurrentDepGraph>,\n-}\n-\n-impl<'graph> IgnoreTask<'graph> {\n-    pub(super) fn new(graph: &'graph RefCell<CurrentDepGraph>) -> IgnoreTask<'graph> {\n-        graph.borrow_mut().push_ignore();\n-        IgnoreTask {\n-            graph,\n-        }\n-    }\n-}\n-\n-impl<'graph> Drop for IgnoreTask<'graph> {\n-    fn drop(&mut self) {\n-        self.graph.borrow_mut().pop_ignore();\n-    }\n-}\n-"}, {"sha": "38de8548f30d1022598dedd90ecefdf9a95d23a1", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/64b5d408e6acd6c49c43dae2a3302d9fbb74afe6/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b5d408e6acd6c49c43dae2a3302d9fbb74afe6/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=64b5d408e6acd6c49c43dae2a3302d9fbb74afe6", "patch": "@@ -79,26 +79,23 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                 body_ids: _,\n             } = *krate;\n \n-            root_mod_sig_dep_index = dep_graph.with_task(\n+            root_mod_sig_dep_index = dep_graph.input_task(\n                 root_mod_def_path_hash.to_dep_node(DepKind::Hir),\n                 &hcx,\n                 HirItemLike { item_like: (module, attrs, span), hash_bodies: false },\n-                identity_fn\n             ).1;\n-            root_mod_full_dep_index = dep_graph.with_task(\n+            root_mod_full_dep_index = dep_graph.input_task(\n                 root_mod_def_path_hash.to_dep_node(DepKind::HirBody),\n                 &hcx,\n                 HirItemLike { item_like: (module, attrs, span), hash_bodies: true },\n-                identity_fn\n             ).1;\n         }\n \n         {\n-            dep_graph.with_task(\n+            dep_graph.input_task(\n                 DepNode::new_no_params(DepKind::AllLocalTraitImpls),\n                 &hcx,\n                 &krate.trait_impls,\n-                identity_fn\n             );\n         }\n \n@@ -169,12 +166,11 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n         let (_, crate_dep_node_index) = self\n             .dep_graph\n-            .with_task(DepNode::new_no_params(DepKind::Krate),\n+            .input_task(DepNode::new_no_params(DepKind::Krate),\n                        &self.hcx,\n                        (((node_hashes, upstream_crates), source_file_names),\n                         (commandline_args_hash,\n-                         crate_disambiguator.to_fingerprint())),\n-                       identity_fn);\n+                         crate_disambiguator.to_fingerprint())));\n \n         let svh = Svh::new(self.dep_graph\n                                .fingerprint_of(crate_dep_node_index)\n@@ -267,18 +263,16 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n         let def_path_hash = self.definitions.def_path_hash(dep_node_owner);\n \n-        self.current_signature_dep_index = self.dep_graph.with_task(\n+        self.current_signature_dep_index = self.dep_graph.input_task(\n             def_path_hash.to_dep_node(DepKind::Hir),\n             &self.hcx,\n             HirItemLike { item_like, hash_bodies: false },\n-            identity_fn\n         ).1;\n \n-        self.current_full_dep_index = self.dep_graph.with_task(\n+        self.current_full_dep_index = self.dep_graph.input_task(\n             def_path_hash.to_dep_node(DepKind::HirBody),\n             &self.hcx,\n             HirItemLike { item_like, hash_bodies: true },\n-            identity_fn\n         ).1;\n \n         self.hir_body_nodes.push((def_path_hash, self.current_full_dep_index));\n@@ -520,12 +514,6 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n }\n \n-// We use this with DepGraph::with_task(). Since we are handling only input\n-// values here, the \"task\" computing them just passes them through.\n-fn identity_fn<T>(_: &StableHashingContext, item_like: T) -> T {\n-    item_like\n-}\n-\n // This is a wrapper structure that allows determining if span values within\n // the wrapped item should be hashed or not.\n struct HirItemLike<T> {"}, {"sha": "6a65b4ee0c393a3c953cd63012116a65f8650272", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/64b5d408e6acd6c49c43dae2a3302d9fbb74afe6/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b5d408e6acd6c49c43dae2a3302d9fbb74afe6/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=64b5d408e6acd6c49c43dae2a3302d9fbb74afe6", "patch": "@@ -1562,6 +1562,7 @@ impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n                 tcx,\n                 query: icx.query.clone(),\n                 layout_depth: icx.layout_depth,\n+                task: icx.task,\n             };\n             ty::tls::enter_context(&new_icx, |new_icx| {\n                 f(new_icx.tcx)\n@@ -1740,7 +1741,8 @@ pub mod tls {\n     use ty::maps;\n     use errors::{Diagnostic, TRACK_DIAGNOSTICS};\n     use rustc_data_structures::OnDrop;\n-    use rustc_data_structures::sync::Lrc;\n+    use rustc_data_structures::sync::{Lrc, Lock};\n+    use dep_graph::OpenTask;\n \n     /// This is the implicit state of rustc. It contains the current\n     /// TyCtxt and query. It is updated when creating a local interner or\n@@ -1759,6 +1761,10 @@ pub mod tls {\n \n         /// Used to prevent layout from recursing too deeply.\n         pub layout_depth: usize,\n+\n+        /// The current dep graph task. This is used to add dependencies to queries\n+        /// when executing them\n+        pub task: &'a Lock<OpenTask>,\n     }\n \n     // A thread local value which stores a pointer to the current ImplicitCtxt\n@@ -1845,6 +1851,7 @@ pub mod tls {\n                 tcx,\n                 query: None,\n                 layout_depth: 0,\n+                task: &Lock::new(OpenTask::Ignore),\n             };\n             enter_context(&icx, |_| {\n                 f(tcx)"}, {"sha": "61a4eb58531027d8435703525c5a94ae0967d2fe", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/64b5d408e6acd6c49c43dae2a3302d9fbb74afe6/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b5d408e6acd6c49c43dae2a3302d9fbb74afe6/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=64b5d408e6acd6c49c43dae2a3302d9fbb74afe6", "patch": "@@ -530,6 +530,7 @@ macro_rules! define_maps {\n                             tcx,\n                             query: Some(job.clone()),\n                             layout_depth: icx.layout_depth,\n+                            task: icx.task,\n                         };\n \n                         // Use the ImplicitCtxt while we execute the query"}]}