{"sha": "fe26fc9a1cada15beb553adf0922286eb0bce274", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMjZmYzlhMWNhZGExNWJlYjU1M2FkZjA5MjIyODZlYjBiY2UyNzQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-10T03:14:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-10T03:14:09Z"}, "message": "Rollup merge of #62393 - petrochenkov:notto-disu, r=Mark-Simulacrum\n\nFix pretty-printing of `$crate` (take 4)\n\nPretty-print `$crate` as `crate` or `crate_name` in unstructured tokens like `a $crate c` in `foo!(a $crate c)`, but only if those tokens are printed as a part of AST pretty-printing, rather than as a standalone token stream.\n\nFixes https://github.com/rust-lang/rust/issues/62325\nPrevious iterations - https://github.com/rust-lang/rust/pull/56647, https://github.com/rust-lang/rust/pull/57155, https://github.com/rust-lang/rust/pull/57915.", "tree": {"sha": "e0a7ad7d7685c8175830ecf80845d0c6077e374d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0a7ad7d7685c8175830ecf80845d0c6077e374d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe26fc9a1cada15beb553adf0922286eb0bce274", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdJVgBCRBK7hj4Ov3rIwAAdHIIAEPt1+TEJzSx7eUybamQZpmn\niBeDB47oA91TyASBHSPAJ9GVdxDnSnpGuuV0yl+ZLau98a+ZSNqO9lapNjuHh9iN\nThi1vkSrt+7/SPJ5ZEL3Sd86yO1fhfZ7fQf1iFM8W3jXMjmMA90IDP3R38o4kj7S\n2hekBOfs2QqFBmMvWZbWWC0fDOXkeOu7VVEQVvtPU/WywrALoCpG4gq++6HjYVLB\nURfHpVbq2gXAw8f3Ib9ANkLyp0tQIZGHGQUMkOHCHUtTu9U1TyyGyQpc0yntPOsm\n1wQyc2nJTTRdbMtjuf/tUE5AoQ+VibBt/vPp+15Gt0zTIBsvwp/+Qe/BCMrnbwY=\n=+WwS\n-----END PGP SIGNATURE-----\n", "payload": "tree e0a7ad7d7685c8175830ecf80845d0c6077e374d\nparent 1e48be948afabf176f9e913d8d829650320becc2\nparent 4cb67c0f1c429a1a1e2ec8c3e02714557feeb60d\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1562728449 +0200\ncommitter GitHub <noreply@github.com> 1562728449 +0200\n\nRollup merge of #62393 - petrochenkov:notto-disu, r=Mark-Simulacrum\n\nFix pretty-printing of `$crate` (take 4)\n\nPretty-print `$crate` as `crate` or `crate_name` in unstructured tokens like `a $crate c` in `foo!(a $crate c)`, but only if those tokens are printed as a part of AST pretty-printing, rather than as a standalone token stream.\n\nFixes https://github.com/rust-lang/rust/issues/62325\nPrevious iterations - https://github.com/rust-lang/rust/pull/56647, https://github.com/rust-lang/rust/pull/57155, https://github.com/rust-lang/rust/pull/57915.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe26fc9a1cada15beb553adf0922286eb0bce274", "html_url": "https://github.com/rust-lang/rust/commit/fe26fc9a1cada15beb553adf0922286eb0bce274", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe26fc9a1cada15beb553adf0922286eb0bce274/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e48be948afabf176f9e913d8d829650320becc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e48be948afabf176f9e913d8d829650320becc2", "html_url": "https://github.com/rust-lang/rust/commit/1e48be948afabf176f9e913d8d829650320becc2"}, {"sha": "4cb67c0f1c429a1a1e2ec8c3e02714557feeb60d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cb67c0f1c429a1a1e2ec8c3e02714557feeb60d", "html_url": "https://github.com/rust-lang/rust/commit/4cb67c0f1c429a1a1e2ec8c3e02714557feeb60d"}], "stats": {"total": 336, "additions": 247, "deletions": 89}, "files": [{"sha": "49116f3f171e2620bba3f7a85de35bea886f49dd", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=fe26fc9a1cada15beb553adf0922286eb0bce274", "patch": "@@ -758,7 +758,10 @@ impl<'a> Resolver<'a> {\n     }\n \n     pub fn macro_def_scope(&mut self, expansion: Mark) -> Module<'a> {\n-        let def_id = self.macro_defs[&expansion];\n+        let def_id = match self.macro_defs.get(&expansion) {\n+            Some(def_id) => *def_id,\n+            None => return self.graph_root,\n+        };\n         if let Some(id) = self.definitions.as_local_node_id(def_id) {\n             self.local_macro_def_scopes[&id]\n         } else if def_id.krate == CrateNum::BuiltinMacros {"}, {"sha": "8f23c9813f7d9e43560fa6f9ecc0b4443eed3933", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=fe26fc9a1cada15beb553adf0922286eb0bce274", "patch": "@@ -17,12 +17,11 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::{self, Mark};\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{feature_err, emit_feature_err, is_builtin_attr_name};\n use syntax::feature_gate::{AttributeGate, GateIssue, Stability, BUILTIN_ATTRIBUTES};\n use syntax::symbol::{Symbol, kw, sym};\n-use syntax::visit::Visitor;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n use errors::Applicability;\n@@ -146,24 +145,14 @@ impl<'a> base::Resolver for Resolver<'a> {\n         mark\n     }\n \n-    fn resolve_dollar_crates(&mut self, fragment: &AstFragment) {\n-        struct ResolveDollarCrates<'a, 'b> {\n-            resolver: &'a mut Resolver<'b>\n-        }\n-        impl<'a> Visitor<'a> for ResolveDollarCrates<'a, '_> {\n-            fn visit_ident(&mut self, ident: Ident) {\n-                if ident.name == kw::DollarCrate {\n-                    let name = match self.resolver.resolve_crate_root(ident).kind {\n-                        ModuleKind::Def(.., name) if name != kw::Invalid => name,\n-                        _ => kw::Crate,\n-                    };\n-                    ident.span.ctxt().set_dollar_crate_name(name);\n-                }\n+    fn resolve_dollar_crates(&mut self) {\n+        hygiene::update_dollar_crate_names(|ctxt| {\n+            let ident = Ident::new(kw::DollarCrate, DUMMY_SP.with_ctxt(ctxt));\n+            match self.resolve_crate_root(ident).kind {\n+                ModuleKind::Def(.., name) if name != kw::Invalid => name,\n+                _ => kw::Crate,\n             }\n-            fn visit_mac(&mut self, _: &ast::Mac) {}\n-        }\n-\n-        fragment.visit_with(&mut ResolveDollarCrates { resolver: self });\n+        });\n     }\n \n     fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,"}, {"sha": "c0ba41b8af40562a83b94d6ee8478930657694bf", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=fe26fc9a1cada15beb553adf0922286eb0bce274", "patch": "@@ -701,7 +701,7 @@ pub trait Resolver {\n \n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark;\n \n-    fn resolve_dollar_crates(&mut self, fragment: &AstFragment);\n+    fn resolve_dollar_crates(&mut self);\n     fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n                                             derives: &[Mark]);\n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);"}, {"sha": "053686b8b1f275c1e02e0670f16493a182b8e18d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=fe26fc9a1cada15beb553adf0922286eb0bce274", "patch": "@@ -429,7 +429,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     fn collect_invocations(&mut self, mut fragment: AstFragment, derives: &[Mark])\n                            -> (AstFragment, Vec<Invocation>) {\n         // Resolve `$crate`s in the fragment for pretty-printing.\n-        self.cx.resolver.resolve_dollar_crates(&fragment);\n+        self.cx.resolver.resolve_dollar_crates();\n \n         let invocations = {\n             let mut collector = InvocationCollector {"}, {"sha": "7e099bc4d509510eb56a65e1c4a4d89e9bd67d73", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 62, "deletions": 47, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=fe26fc9a1cada15beb553adf0922286eb0bce274", "patch": "@@ -18,7 +18,7 @@ use crate::tokenstream::{self, TokenStream, TokenTree};\n \n use rustc_target::spec::abi::{self, Abi};\n use syntax_pos::{self, BytePos};\n-use syntax_pos::{DUMMY_SP, FileName};\n+use syntax_pos::{DUMMY_SP, FileName, Span};\n \n use std::borrow::Cow;\n use std::io::Read;\n@@ -181,7 +181,46 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n     out\n }\n \n+fn ident_to_string(ident: ast::Ident, is_raw: bool) -> String {\n+    ident_to_string_ext(ident.name, is_raw, Some(ident.span))\n+}\n+\n+// AST pretty-printer is used as a fallback for turning AST structures into token streams for\n+// proc macros. Additionally, proc macros may stringify their input and expect it survive the\n+// stringification (especially true for proc macro derives written between Rust 1.15 and 1.30).\n+// So we need to somehow pretty-print `$crate` in a way preserving at least some of its\n+// hygiene data, most importantly name of the crate it refers to.\n+// As a result we print `$crate` as `crate` if it refers to the local crate\n+// and as `::other_crate_name` if it refers to some other crate.\n+// Note, that this is only done if the ident token is printed from inside of AST pretty-pringing,\n+// but not otherwise. Pretty-printing is the only way for proc macros to discover token contents,\n+// so we should not perform this lossy conversion if the top level call to the pretty-printer was\n+// done for a token stream or a single token.\n+fn ident_to_string_ext(\n+    name: ast::Name, is_raw: bool, convert_dollar_crate: Option<Span>\n+) -> String {\n+    if is_raw {\n+        format!(\"r#{}\", name)\n+    } else {\n+        if name == kw::DollarCrate {\n+            if let Some(span) = convert_dollar_crate {\n+                let converted = span.ctxt().dollar_crate_name();\n+                return if converted.is_path_segment_keyword() {\n+                    converted.to_string()\n+                } else {\n+                    format!(\"::{}\", converted)\n+                }\n+            }\n+        }\n+        name.to_string()\n+    }\n+}\n+\n pub fn token_kind_to_string(tok: &TokenKind) -> String {\n+    token_kind_to_string_ext(tok, None)\n+}\n+\n+fn token_kind_to_string_ext(tok: &TokenKind, convert_dollar_crate: Option<Span>) -> String {\n     match *tok {\n         token::Eq                   => \"=\".to_string(),\n         token::Lt                   => \"<\".to_string(),\n@@ -227,8 +266,7 @@ pub fn token_kind_to_string(tok: &TokenKind) -> String {\n         token::Literal(lit) => literal_to_string(lit),\n \n         /* Name components */\n-        token::Ident(s, false)      => s.to_string(),\n-        token::Ident(s, true)       => format!(\"r#{}\", s),\n+        token::Ident(s, is_raw)     => ident_to_string_ext(s, is_raw, convert_dollar_crate),\n         token::Lifetime(s)          => s.to_string(),\n \n         /* Other */\n@@ -243,7 +281,12 @@ pub fn token_kind_to_string(tok: &TokenKind) -> String {\n }\n \n pub fn token_to_string(token: &Token) -> String {\n-    token_kind_to_string(&token.kind)\n+    token_to_string_ext(token, false)\n+}\n+\n+fn token_to_string_ext(token: &Token, convert_dollar_crate: bool) -> String {\n+    let convert_dollar_crate = if convert_dollar_crate { Some(token.span) } else { None };\n+    token_kind_to_string_ext(&token.kind, convert_dollar_crate)\n }\n \n crate fn nonterminal_to_string(nt: &Nonterminal) -> String {\n@@ -256,9 +299,8 @@ crate fn nonterminal_to_string(nt: &Nonterminal) -> String {\n         token::NtBlock(ref e)       => block_to_string(e),\n         token::NtStmt(ref e)        => stmt_to_string(e),\n         token::NtPat(ref e)         => pat_to_string(e),\n-        token::NtIdent(e, false)    => ident_to_string(e),\n-        token::NtIdent(e, true)     => format!(\"r#{}\", ident_to_string(e)),\n-        token::NtLifetime(e)        => ident_to_string(e),\n+        token::NtIdent(e, is_raw)   => ident_to_string(e, is_raw),\n+        token::NtLifetime(e)        => e.to_string(),\n         token::NtLiteral(ref e)     => expr_to_string(e),\n         token::NtTT(ref tree)       => tt_to_string(tree.clone()),\n         token::NtImplItem(ref e)    => impl_item_to_string(e),\n@@ -293,15 +335,15 @@ pub fn lifetime_to_string(lt: &ast::Lifetime) -> String {\n }\n \n pub fn tt_to_string(tt: tokenstream::TokenTree) -> String {\n-    to_string(|s| s.print_tt(tt))\n+    to_string(|s| s.print_tt(tt, false))\n }\n \n pub fn tts_to_string(tts: &[tokenstream::TokenTree]) -> String {\n-    to_string(|s| s.print_tts(tts.iter().cloned().collect()))\n+    tokens_to_string(tts.iter().cloned().collect())\n }\n \n pub fn tokens_to_string(tokens: TokenStream) -> String {\n-    to_string(|s| s.print_tts(tokens))\n+    to_string(|s| s.print_tts_ext(tokens, false))\n }\n \n pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n@@ -344,10 +386,6 @@ pub fn path_segment_to_string(p: &ast::PathSegment) -> String {\n     to_string(|s| s.print_path_segment(p, false))\n }\n \n-pub fn ident_to_string(id: ast::Ident) -> String {\n-    to_string(|s| s.print_ident(id))\n-}\n-\n pub fn vis_to_string(v: &ast::Visibility) -> String {\n     to_string(|s| s.print_visibility(v))\n }\n@@ -629,11 +667,7 @@ pub trait PrintState<'a> {\n                 self.writer().word(\"::\");\n             }\n             if segment.ident.name != kw::PathRoot {\n-                if segment.ident.name == kw::DollarCrate {\n-                    self.print_dollar_crate(segment.ident);\n-                } else {\n-                    self.writer().word(segment.ident.as_str().to_string());\n-                }\n+                self.writer().word(ident_to_string(segment.ident, segment.ident.is_raw_guess()));\n             }\n         }\n     }\n@@ -707,10 +741,10 @@ pub trait PrintState<'a> {\n     /// appropriate macro, transcribe back into the grammar we just parsed from,\n     /// and then pretty-print the resulting AST nodes (so, e.g., we print\n     /// expression arguments as expressions). It can be done! I think.\n-    fn print_tt(&mut self, tt: tokenstream::TokenTree) {\n+    fn print_tt(&mut self, tt: tokenstream::TokenTree, convert_dollar_crate: bool) {\n         match tt {\n             TokenTree::Token(ref token) => {\n-                self.writer().word(token_to_string(&token));\n+                self.writer().word(token_to_string_ext(&token, convert_dollar_crate));\n                 match token.kind {\n                     token::DocComment(..) => {\n                         self.writer().hardbreak()\n@@ -729,12 +763,16 @@ pub trait PrintState<'a> {\n     }\n \n     fn print_tts(&mut self, tts: tokenstream::TokenStream) {\n+        self.print_tts_ext(tts, true)\n+    }\n+\n+    fn print_tts_ext(&mut self, tts: tokenstream::TokenStream, convert_dollar_crate: bool) {\n         self.ibox(0);\n         for (i, tt) in tts.into_trees().enumerate() {\n             if i != 0 {\n                 self.writer().space();\n             }\n-            self.print_tt(tt);\n+            self.print_tt(tt, convert_dollar_crate);\n         }\n         self.end();\n     }\n@@ -744,21 +782,6 @@ pub trait PrintState<'a> {\n     }\n \n     fn nbsp(&mut self) { self.writer().word(\" \") }\n-\n-    // AST pretty-printer is used as a fallback for turning AST structures into token streams for\n-    // proc macros. Additionally, proc macros may stringify their input and expect it survive the\n-    // stringification (especially true for proc macro derives written between Rust 1.15 and 1.30).\n-    // So we need to somehow pretty-print `$crate` in paths in a way preserving at least some of\n-    // its hygiene data, most importantly name of the crate it refers to.\n-    // As a result we print `$crate` as `crate` if it refers to the local crate\n-    // and as `::other_crate_name` if it refers to some other crate.\n-    fn print_dollar_crate(&mut self, ident: ast::Ident) {\n-        let name = ident.span.ctxt().dollar_crate_name();\n-        if !ast::Ident::with_empty_ctxt(name).is_path_segment_keyword() {\n-            self.writer().word(\"::\");\n-        }\n-        self.writer().word(name.as_str().to_string())\n-    }\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n@@ -2287,11 +2310,7 @@ impl<'a> State<'a> {\n     }\n \n     crate fn print_ident(&mut self, ident: ast::Ident) {\n-        if ident.is_raw_guess() {\n-            self.s.word(format!(\"r#{}\", ident));\n-        } else {\n-            self.s.word(ident.as_str().to_string());\n-        }\n+        self.s.word(ident_to_string(ident, ident.is_raw_guess()));\n         self.ann.post(self, AnnNode::Ident(&ident))\n     }\n \n@@ -2322,11 +2341,7 @@ impl<'a> State<'a> {\n                           segment: &ast::PathSegment,\n                           colons_before_params: bool) {\n         if segment.ident.name != kw::PathRoot {\n-            if segment.ident.name == kw::DollarCrate {\n-                self.print_dollar_crate(segment.ident);\n-            } else {\n-                self.print_ident(segment.ident);\n-            }\n+            self.print_ident(segment.ident);\n             if let Some(ref args) = segment.args {\n                 self.print_generic_args(args, colons_before_params);\n             }"}, {"sha": "f52952ca40274017ecfbca8fd1bbd5bb54f827fd", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=fe26fc9a1cada15beb553adf0922286eb0bce274", "patch": "@@ -33,7 +33,7 @@ use crate::symbol::{kw, Symbol};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n-use std::{fmt, mem};\n+use std::fmt;\n \n /// A SyntaxContext represents a chain of macro expansions (represented by marks).\n #[derive(Clone, Copy, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n@@ -387,6 +387,23 @@ pub fn walk_chain(span: Span, to: SyntaxContext) -> Span {\n     HygieneData::with(|data| data.walk_chain(span, to))\n }\n \n+pub fn update_dollar_crate_names(mut get_name: impl FnMut(SyntaxContext) -> Symbol) {\n+    // The new contexts that need updating are at the end of the list and have `$crate` as a name.\n+    let (len, to_update) = HygieneData::with(|data| (\n+        data.syntax_contexts.len(),\n+        data.syntax_contexts.iter().rev()\n+            .take_while(|scdata| scdata.dollar_crate_name == kw::DollarCrate).count()\n+    ));\n+    // The callback must be called from outside of the `HygieneData` lock,\n+    // since it will try to acquire it too.\n+    let range_to_update = len - to_update .. len;\n+    let names: Vec<_> =\n+        range_to_update.clone().map(|idx| get_name(SyntaxContext::from_u32(idx as u32))).collect();\n+    HygieneData::with(|data| range_to_update.zip(names.into_iter()).for_each(|(idx, name)| {\n+        data.syntax_contexts[idx].dollar_crate_name = name;\n+    }))\n+}\n+\n impl SyntaxContext {\n     #[inline]\n     pub const fn empty() -> Self {\n@@ -614,17 +631,6 @@ impl SyntaxContext {\n     pub fn dollar_crate_name(self) -> Symbol {\n         HygieneData::with(|data| data.syntax_contexts[self.0 as usize].dollar_crate_name)\n     }\n-\n-    pub fn set_dollar_crate_name(self, dollar_crate_name: Symbol) {\n-        HygieneData::with(|data| {\n-            let prev_dollar_crate_name = mem::replace(\n-                &mut data.syntax_contexts[self.0 as usize].dollar_crate_name, dollar_crate_name\n-            );\n-            assert!(dollar_crate_name == prev_dollar_crate_name ||\n-                    prev_dollar_crate_name == kw::DollarCrate,\n-                    \"$crate name is reset for a syntax context\");\n-        })\n-    }\n }\n \n impl fmt::Debug for SyntaxContext {"}, {"sha": "bdcdb7922ca57a674f21ad4008422ac6189da4b3", "filename": "src/test/ui/proc-macro/auxiliary/dollar-crate-external.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate-external.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate-external.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate-external.rs?ref=fe26fc9a1cada15beb553adf0922286eb0bce274", "patch": "@@ -14,3 +14,9 @@ macro_rules! external {\n         struct D($crate::S);\n     };\n }\n+\n+#[macro_export]\n+macro_rules! issue_62325 { () => {\n+    #[print_attr]\n+    struct B(identity!($crate::S));\n+}}"}, {"sha": "84821259d7b9b9bd05fa967dc5777b8d1dc93185", "filename": "src/test/ui/proc-macro/dollar-crate-issue-57089.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout?ref=fe26fc9a1cada15beb553adf0922286eb0bce274", "patch": "@@ -1,4 +1,4 @@\n-PRINT-BANG INPUT (DISPLAY): struct M ( $crate :: S ) ;\n+PRINT-BANG INPUT (DISPLAY): struct M ( crate :: S ) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -39,7 +39,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( $crate :: S ) ;\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( crate :: S ) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\","}, {"sha": "b7b152e669213beea31d60755375f2ec85034bde", "filename": "src/test/ui/proc-macro/dollar-crate-issue-62325.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.rs?ref=fe26fc9a1cada15beb553adf0922286eb0bce274", "patch": "@@ -0,0 +1,27 @@\n+// check-pass\n+// edition:2018\n+// aux-build:test-macros.rs\n+// aux-build:dollar-crate-external.rs\n+\n+// Anonymize unstable non-dummy spans while still showing dummy spans `0..0`.\n+// normalize-stdout-test \"bytes\\([^0]\\w*\\.\\.(\\w+)\\)\" -> \"bytes(LO..$1)\"\n+// normalize-stdout-test \"bytes\\((\\w+)\\.\\.[^0]\\w*\\)\" -> \"bytes($1..HI)\"\n+\n+#![feature(proc_macro_hygiene)]\n+\n+#[macro_use]\n+extern crate test_macros;\n+extern crate dollar_crate_external;\n+\n+type S = u8;\n+\n+macro_rules! m { () => {\n+    #[print_attr]\n+    struct A(identity!($crate::S));\n+}}\n+\n+m!();\n+\n+dollar_crate_external::issue_62325!();\n+\n+fn main() {}"}, {"sha": "17ad1a7af7046888f7a3629121ec7f4a7ed38ae1", "filename": "src/test/ui/proc-macro/dollar-crate-issue-62325.stdout", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout?ref=fe26fc9a1cada15beb553adf0922286eb0bce274", "patch": "@@ -0,0 +1,112 @@\n+PRINT-ATTR INPUT (DISPLAY): struct A(identity!(crate :: S));\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( identity ! ( crate :: S ) ) ;\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: #2 bytes(LO..HI),\n+    },\n+    Ident {\n+        ident: \"A\",\n+        span: #2 bytes(LO..HI),\n+    },\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"identity\",\n+                span: #2 bytes(LO..HI),\n+            },\n+            Punct {\n+                ch: '!',\n+                spacing: Alone,\n+                span: #2 bytes(LO..HI),\n+            },\n+            Group {\n+                delimiter: Parenthesis,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"$crate\",\n+                        span: #2 bytes(LO..HI),\n+                    },\n+                    Punct {\n+                        ch: ':',\n+                        spacing: Joint,\n+                        span: #2 bytes(LO..HI),\n+                    },\n+                    Punct {\n+                        ch: ':',\n+                        spacing: Alone,\n+                        span: #2 bytes(LO..HI),\n+                    },\n+                    Ident {\n+                        ident: \"S\",\n+                        span: #2 bytes(LO..HI),\n+                    },\n+                ],\n+                span: #2 bytes(LO..HI),\n+            },\n+        ],\n+        span: #2 bytes(LO..HI),\n+    },\n+    Punct {\n+        ch: ';',\n+        spacing: Alone,\n+        span: #2 bytes(LO..HI),\n+    },\n+]\n+PRINT-ATTR INPUT (DISPLAY): struct B(identity!(::dollar_crate_external :: S));\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct B ( identity ! ( ::dollar_crate_external :: S ) ) ;\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: #7 bytes(LO..HI),\n+    },\n+    Ident {\n+        ident: \"B\",\n+        span: #7 bytes(LO..HI),\n+    },\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"identity\",\n+                span: #7 bytes(LO..HI),\n+            },\n+            Punct {\n+                ch: '!',\n+                spacing: Alone,\n+                span: #7 bytes(LO..HI),\n+            },\n+            Group {\n+                delimiter: Parenthesis,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"$crate\",\n+                        span: #7 bytes(LO..HI),\n+                    },\n+                    Punct {\n+                        ch: ':',\n+                        spacing: Joint,\n+                        span: #7 bytes(LO..HI),\n+                    },\n+                    Punct {\n+                        ch: ':',\n+                        spacing: Alone,\n+                        span: #7 bytes(LO..HI),\n+                    },\n+                    Ident {\n+                        ident: \"S\",\n+                        span: #7 bytes(LO..HI),\n+                    },\n+                ],\n+                span: #7 bytes(LO..HI),\n+            },\n+        ],\n+        span: #7 bytes(LO..HI),\n+    },\n+    Punct {\n+        ch: ';',\n+        spacing: Alone,\n+        span: #7 bytes(LO..HI),\n+    },\n+]"}, {"sha": "9d9677d49e31898e48450f5c10e04865542a0685", "filename": "src/test/ui/proc-macro/dollar-crate.stdout", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fe26fc9a1cada15beb553adf0922286eb0bce274/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout?ref=fe26fc9a1cada15beb553adf0922286eb0bce274", "patch": "@@ -1,4 +1,4 @@\n-PRINT-BANG INPUT (DISPLAY): struct M ( $crate :: S ) ;\n+PRINT-BANG INPUT (DISPLAY): struct M ( crate :: S ) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -39,7 +39,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( $crate :: S ) ;\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( crate :: S ) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -80,7 +80,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): struct D(crate::S);\n-PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ( $crate :: S ) ;\n+PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ( crate :: S ) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -120,7 +120,7 @@ PRINT-DERIVE INPUT (DEBUG): TokenStream [\n         span: #2 bytes(LO..HI),\n     },\n ]\n-PRINT-BANG INPUT (DISPLAY): struct M ( $crate :: S ) ;\n+PRINT-BANG INPUT (DISPLAY): struct M ( ::dollar_crate_external :: S ) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -161,7 +161,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(::dollar_crate_external::S);\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( $crate :: S ) ;\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( ::dollar_crate_external :: S ) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -202,7 +202,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): struct D(::dollar_crate_external::S);\n-PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ( $crate :: S ) ;\n+PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ( ::dollar_crate_external :: S ) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\","}]}