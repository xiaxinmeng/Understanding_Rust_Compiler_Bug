{"sha": "f49349bf333001166e3a215b7b2eb5b5cb1c9989", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0OTM0OWJmMzMzMDAxMTY2ZTNhMjE1YjdiMmViNWI1Y2IxYzk5ODk=", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-06T10:40:34Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-11T10:40:24Z"}, "message": "move or_fun_call to its own module", "tree": {"sha": "2af17fb2061ddaade70f3b788fe1e323f71ed3c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2af17fb2061ddaade70f3b788fe1e323f71ed3c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f49349bf333001166e3a215b7b2eb5b5cb1c9989", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f49349bf333001166e3a215b7b2eb5b5cb1c9989", "html_url": "https://github.com/rust-lang/rust/commit/f49349bf333001166e3a215b7b2eb5b5cb1c9989", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f49349bf333001166e3a215b7b2eb5b5cb1c9989/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0824bf75fba159f40e498dd88386174feea5cf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0824bf75fba159f40e498dd88386174feea5cf5", "html_url": "https://github.com/rust-lang/rust/commit/b0824bf75fba159f40e498dd88386174feea5cf5"}], "stats": {"total": 341, "additions": 178, "deletions": 163}, "files": [{"sha": "857c1bf0ec08a63d427c04a9ee988946835151ff", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 163, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/f49349bf333001166e3a215b7b2eb5b5cb1c9989/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49349bf333001166e3a215b7b2eb5b5cb1c9989/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=f49349bf333001166e3a215b7b2eb5b5cb1c9989", "patch": "@@ -33,6 +33,7 @@ mod ok_expect;\n mod option_as_ref_deref;\n mod option_map_or_none;\n mod option_map_unwrap_or;\n+mod or_fun_call;\n mod search_is_some;\n mod single_char_insert_string;\n mod single_char_pattern;\n@@ -66,12 +67,11 @@ use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, Symbol, SymbolStr};\n use rustc_typeck::hir_ty_to_ty;\n \n-use crate::utils::eager_or_lazy::is_lazyness_candidate;\n use crate::utils::{\n     contains_return, contains_ty, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of,\n-    is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path, match_qpath, match_type, method_calls,\n-    method_chain_args, paths, return_ty, single_segment_path, snippet, snippet_with_applicability,\n-    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg, SpanlessEq,\n+    is_type_diagnostic_item, iter_input_pats, match_def_path, match_qpath, method_calls, method_chain_args, paths,\n+    return_ty, single_segment_path, snippet, snippet_with_applicability, span_lint, span_lint_and_help,\n+    span_lint_and_sugg, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -1778,7 +1778,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 }\n             },\n             hir::ExprKind::MethodCall(ref method_call, ref method_span, ref args, _) => {\n-                lint_or_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n+                or_fun_call::check(cx, expr, *method_span, &method_call.ident.as_str(), args);\n                 lint_expect_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n \n                 let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n@@ -1973,164 +1973,6 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n     extract_msrv_attr!(LateContext);\n }\n \n-/// Checks for the `OR_FUN_CALL` lint.\n-#[allow(clippy::too_many_lines)]\n-fn lint_or_fun_call<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &hir::Expr<'_>,\n-    method_span: Span,\n-    name: &str,\n-    args: &'tcx [hir::Expr<'_>],\n-) {\n-    /// Checks for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n-    fn check_unwrap_or_default(\n-        cx: &LateContext<'_>,\n-        name: &str,\n-        fun: &hir::Expr<'_>,\n-        self_expr: &hir::Expr<'_>,\n-        arg: &hir::Expr<'_>,\n-        or_has_args: bool,\n-        span: Span,\n-    ) -> bool {\n-        if_chain! {\n-            if !or_has_args;\n-            if name == \"unwrap_or\";\n-            if let hir::ExprKind::Path(ref qpath) = fun.kind;\n-            let path = &*last_path_segment(qpath).ident.as_str();\n-            if [\"default\", \"new\"].contains(&path);\n-            let arg_ty = cx.typeck_results().expr_ty(arg);\n-            if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n-            if implements_trait(cx, arg_ty, default_trait_id, &[]);\n-\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                span_lint_and_sugg(\n-                    cx,\n-                    OR_FUN_CALL,\n-                    span,\n-                    &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n-                    \"try this\",\n-                    format!(\n-                        \"{}.unwrap_or_default()\",\n-                        snippet_with_applicability(cx, self_expr.span, \"..\", &mut applicability)\n-                    ),\n-                    applicability,\n-                );\n-\n-                true\n-            } else {\n-                false\n-            }\n-        }\n-    }\n-\n-    /// Checks for `*or(foo())`.\n-    #[allow(clippy::too_many_arguments)]\n-    fn check_general_case<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        name: &str,\n-        method_span: Span,\n-        self_expr: &hir::Expr<'_>,\n-        arg: &'tcx hir::Expr<'_>,\n-        span: Span,\n-        // None if lambda is required\n-        fun_span: Option<Span>,\n-    ) {\n-        // (path, fn_has_argument, methods, suffix)\n-        static KNOW_TYPES: [(&[&str], bool, &[&str], &str); 4] = [\n-            (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-            (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-            (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n-            (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n-        ];\n-\n-        if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = &arg.kind {\n-            if path.ident.as_str() == \"len\" {\n-                let ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n-\n-                match ty.kind() {\n-                    ty::Slice(_) | ty::Array(_, _) => return,\n-                    _ => (),\n-                }\n-\n-                if is_type_diagnostic_item(cx, ty, sym::vec_type) {\n-                    return;\n-                }\n-            }\n-        }\n-\n-        if_chain! {\n-            if KNOW_TYPES.iter().any(|k| k.2.contains(&name));\n-\n-            if is_lazyness_candidate(cx, arg);\n-            if !contains_return(&arg);\n-\n-            let self_ty = cx.typeck_results().expr_ty(self_expr);\n-\n-            if let Some(&(_, fn_has_arguments, poss, suffix)) =\n-                KNOW_TYPES.iter().find(|&&i| match_type(cx, self_ty, i.0));\n-\n-            if poss.contains(&name);\n-\n-            then {\n-                let macro_expanded_snipped;\n-                let sugg: Cow<'_, str> = {\n-                    let (snippet_span, use_lambda) = match (fn_has_arguments, fun_span) {\n-                        (false, Some(fun_span)) => (fun_span, false),\n-                        _ => (arg.span, true),\n-                    };\n-                    let snippet = {\n-                        let not_macro_argument_snippet = snippet_with_macro_callsite(cx, snippet_span, \"..\");\n-                        if not_macro_argument_snippet == \"vec![]\" {\n-                            macro_expanded_snipped = snippet(cx, snippet_span, \"..\");\n-                            match macro_expanded_snipped.strip_prefix(\"$crate::vec::\") {\n-                                Some(stripped) => Cow::from(stripped),\n-                                None => macro_expanded_snipped\n-                            }\n-                        }\n-                        else {\n-                            not_macro_argument_snippet\n-                        }\n-                    };\n-\n-                    if use_lambda {\n-                        let l_arg = if fn_has_arguments { \"_\" } else { \"\" };\n-                        format!(\"|{}| {}\", l_arg, snippet).into()\n-                    } else {\n-                        snippet\n-                    }\n-                };\n-                let span_replace_word = method_span.with_hi(span.hi());\n-                span_lint_and_sugg(\n-                    cx,\n-                    OR_FUN_CALL,\n-                    span_replace_word,\n-                    &format!(\"use of `{}` followed by a function call\", name),\n-                    \"try this\",\n-                    format!(\"{}_{}({})\", name, suffix, sugg),\n-                    Applicability::HasPlaceholders,\n-                );\n-            }\n-        }\n-    }\n-\n-    if args.len() == 2 {\n-        match args[1].kind {\n-            hir::ExprKind::Call(ref fun, ref or_args) => {\n-                let or_has_args = !or_args.is_empty();\n-                if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n-                    let fun_span = if or_has_args { None } else { Some(fun.span) };\n-                    check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, fun_span);\n-                }\n-            },\n-            hir::ExprKind::Index(..) | hir::ExprKind::MethodCall(..) => {\n-                check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, None);\n-            },\n-            _ => {},\n-        }\n-    }\n-}\n-\n /// Checks for the `EXPECT_FUN_CALL` lint.\n #[allow(clippy::too_many_lines)]\n fn lint_expect_fun_call("}, {"sha": "5f7fc431d22483edca2dbf1c8ce14b0021bf60c5", "filename": "clippy_lints/src/methods/or_fun_call.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/f49349bf333001166e3a215b7b2eb5b5cb1c9989/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49349bf333001166e3a215b7b2eb5b5cb1c9989/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=f49349bf333001166e3a215b7b2eb5b5cb1c9989", "patch": "@@ -0,0 +1,173 @@\n+use crate::utils::eager_or_lazy::is_lazyness_candidate;\n+use crate::utils::{\n+    contains_return, get_trait_def_id, implements_trait, is_type_diagnostic_item, last_path_segment, match_type, paths,\n+    snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::sym;\n+use std::borrow::Cow;\n+\n+use super::OR_FUN_CALL;\n+\n+/// Checks for the `OR_FUN_CALL` lint.\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    method_span: Span,\n+    name: &str,\n+    args: &'tcx [hir::Expr<'_>],\n+) {\n+    /// Checks for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n+    fn check_unwrap_or_default(\n+        cx: &LateContext<'_>,\n+        name: &str,\n+        fun: &hir::Expr<'_>,\n+        self_expr: &hir::Expr<'_>,\n+        arg: &hir::Expr<'_>,\n+        or_has_args: bool,\n+        span: Span,\n+    ) -> bool {\n+        if_chain! {\n+            if !or_has_args;\n+            if name == \"unwrap_or\";\n+            if let hir::ExprKind::Path(ref qpath) = fun.kind;\n+            let path = &*last_path_segment(qpath).ident.as_str();\n+            if [\"default\", \"new\"].contains(&path);\n+            let arg_ty = cx.typeck_results().expr_ty(arg);\n+            if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n+            if implements_trait(cx, arg_ty, default_trait_id, &[]);\n+\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                span_lint_and_sugg(\n+                    cx,\n+                    OR_FUN_CALL,\n+                    span,\n+                    &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n+                    \"try this\",\n+                    format!(\n+                        \"{}.unwrap_or_default()\",\n+                        snippet_with_applicability(cx, self_expr.span, \"..\", &mut applicability)\n+                    ),\n+                    applicability,\n+                );\n+\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Checks for `*or(foo())`.\n+    #[allow(clippy::too_many_arguments)]\n+    fn check_general_case<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        name: &str,\n+        method_span: Span,\n+        self_expr: &hir::Expr<'_>,\n+        arg: &'tcx hir::Expr<'_>,\n+        span: Span,\n+        // None if lambda is required\n+        fun_span: Option<Span>,\n+    ) {\n+        // (path, fn_has_argument, methods, suffix)\n+        static KNOW_TYPES: [(&[&str], bool, &[&str], &str); 4] = [\n+            (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+            (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+            (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n+            (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n+        ];\n+\n+        if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = &arg.kind {\n+            if path.ident.as_str() == \"len\" {\n+                let ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n+\n+                match ty.kind() {\n+                    ty::Slice(_) | ty::Array(_, _) => return,\n+                    _ => (),\n+                }\n+\n+                if is_type_diagnostic_item(cx, ty, sym::vec_type) {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        if_chain! {\n+            if KNOW_TYPES.iter().any(|k| k.2.contains(&name));\n+\n+            if is_lazyness_candidate(cx, arg);\n+            if !contains_return(&arg);\n+\n+            let self_ty = cx.typeck_results().expr_ty(self_expr);\n+\n+            if let Some(&(_, fn_has_arguments, poss, suffix)) =\n+                KNOW_TYPES.iter().find(|&&i| match_type(cx, self_ty, i.0));\n+\n+            if poss.contains(&name);\n+\n+            then {\n+                let macro_expanded_snipped;\n+                let sugg: Cow<'_, str> = {\n+                    let (snippet_span, use_lambda) = match (fn_has_arguments, fun_span) {\n+                        (false, Some(fun_span)) => (fun_span, false),\n+                        _ => (arg.span, true),\n+                    };\n+                    let snippet = {\n+                        let not_macro_argument_snippet = snippet_with_macro_callsite(cx, snippet_span, \"..\");\n+                        if not_macro_argument_snippet == \"vec![]\" {\n+                            macro_expanded_snipped = snippet(cx, snippet_span, \"..\");\n+                            match macro_expanded_snipped.strip_prefix(\"$crate::vec::\") {\n+                                Some(stripped) => Cow::from(stripped),\n+                                None => macro_expanded_snipped\n+                            }\n+                        }\n+                        else {\n+                            not_macro_argument_snippet\n+                        }\n+                    };\n+\n+                    if use_lambda {\n+                        let l_arg = if fn_has_arguments { \"_\" } else { \"\" };\n+                        format!(\"|{}| {}\", l_arg, snippet).into()\n+                    } else {\n+                        snippet\n+                    }\n+                };\n+                let span_replace_word = method_span.with_hi(span.hi());\n+                span_lint_and_sugg(\n+                    cx,\n+                    OR_FUN_CALL,\n+                    span_replace_word,\n+                    &format!(\"use of `{}` followed by a function call\", name),\n+                    \"try this\",\n+                    format!(\"{}_{}({})\", name, suffix, sugg),\n+                    Applicability::HasPlaceholders,\n+                );\n+            }\n+        }\n+    }\n+\n+    if args.len() == 2 {\n+        match args[1].kind {\n+            hir::ExprKind::Call(ref fun, ref or_args) => {\n+                let or_has_args = !or_args.is_empty();\n+                if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n+                    let fun_span = if or_has_args { None } else { Some(fun.span) };\n+                    check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, fun_span);\n+                }\n+            },\n+            hir::ExprKind::Index(..) | hir::ExprKind::MethodCall(..) => {\n+                check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, None);\n+            },\n+            _ => {},\n+        }\n+    }\n+}"}]}