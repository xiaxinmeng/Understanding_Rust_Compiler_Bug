{"sha": "f420726566587862ef4da9153fbc2800ed444033", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0MjA3MjY1NjY1ODc4NjJlZjRkYTkxNTNmYmMyODAwZWQ0NDQwMzM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-05-11T02:26:59Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-05-12T02:37:22Z"}, "message": "Remove `RawVec::double`.\n\nIt's only used once, for `VecDeque`, and can easily be replaced by\nsomething else. The commit changes `grow_if_necessary` to `grow` to\navoid some small regressions caused by changed inlining.\n\nThe commit also removes `Strategy::Double`, and streamlines the\nremaining variants of `Strategy`.\n\nIt's a compile time win on some benchmarks because the many\ninstantations of `RawVec::grow` are a little smaller.", "tree": {"sha": "2b0b3e3167f6f62312027e080085826716673173", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b0b3e3167f6f62312027e080085826716673173"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f420726566587862ef4da9153fbc2800ed444033", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f420726566587862ef4da9153fbc2800ed444033", "html_url": "https://github.com/rust-lang/rust/commit/f420726566587862ef4da9153fbc2800ed444033", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f420726566587862ef4da9153fbc2800ed444033/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3cc435f5755f5550d4235779de58b53a22f0f1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3cc435f5755f5550d4235779de58b53a22f0f1e", "html_url": "https://github.com/rust-lang/rust/commit/a3cc435f5755f5550d4235779de58b53a22f0f1e"}], "stats": {"total": 111, "additions": 23, "deletions": 88}, "files": [{"sha": "540649c61b332345e59f143efcc318839d39bd7f", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f420726566587862ef4da9153fbc2800ed444033/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f420726566587862ef4da9153fbc2800ed444033/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=f420726566587862ef4da9153fbc2800ed444033", "patch": "@@ -1354,7 +1354,9 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, value: T) {\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         self.tail = self.wrap_sub(self.tail, 1);\n         let tail = self.tail;\n@@ -1377,7 +1379,9 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, value: T) {\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         let head = self.head;\n         self.head = self.wrap_add(self.head, 1);\n@@ -1485,7 +1489,9 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn insert(&mut self, index: usize, value: T) {\n         assert!(index <= self.len(), \"index out of bounds\");\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         // Move the least number of elements in the ring buffer and insert\n         // the given object\n@@ -2003,11 +2009,13 @@ impl<T> VecDeque<T> {\n     }\n \n     // This may panic or abort\n-    #[inline]\n-    fn grow_if_necessary(&mut self) {\n+    #[inline(never)]\n+    fn grow(&mut self) {\n         if self.is_full() {\n             let old_cap = self.cap();\n-            self.buf.double();\n+            // Double the buffer size.\n+            self.buf.reserve_exact(old_cap, old_cap);\n+            assert!(self.cap() == old_cap * 2);\n             unsafe {\n                 self.handle_capacity_increase(old_cap);\n             }"}, {"sha": "921ef447be0524a864461c3fb24019b115aeec42", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 9, "deletions": 82, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f420726566587862ef4da9153fbc2800ed444033/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f420726566587862ef4da9153fbc2800ed444033/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=f420726566587862ef4da9153fbc2800ed444033", "patch": "@@ -211,64 +211,6 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         }\n     }\n \n-    /// Doubles the size of the type's backing allocation. This is common enough\n-    /// to want to do that it's easiest to just have a dedicated method. Slightly\n-    /// more efficient logic can be provided for this than the general case.\n-    ///\n-    /// This function is ideal for when pushing elements one-at-a-time because\n-    /// you don't need to incur the costs of the more general computations\n-    /// reserve needs to do to guard against overflow. You do however need to\n-    /// manually check if your `len == capacity`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n-    ///   all `usize::MAX` slots in your imaginary buffer.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n-    ///\n-    /// # Aborts\n-    ///\n-    /// Aborts on OOM\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(raw_vec_internals)]\n-    /// # extern crate alloc;\n-    /// # use std::ptr;\n-    /// # use alloc::raw_vec::RawVec;\n-    /// struct MyVec<T> {\n-    ///     buf: RawVec<T>,\n-    ///     len: usize,\n-    /// }\n-    ///\n-    /// impl<T> MyVec<T> {\n-    ///     pub fn push(&mut self, elem: T) {\n-    ///         if self.len == self.buf.capacity() { self.buf.double(); }\n-    ///         // double would have aborted or panicked if the len exceeded\n-    ///         // `isize::MAX` so this is safe to do unchecked now.\n-    ///         unsafe {\n-    ///             ptr::write(self.buf.ptr().add(self.len), elem);\n-    ///         }\n-    ///         self.len += 1;\n-    ///     }\n-    /// }\n-    /// # fn main() {\n-    /// #   let mut vec = MyVec { buf: RawVec::new(), len: 0 };\n-    /// #   vec.push(1);\n-    /// # }\n-    /// ```\n-    #[inline(never)]\n-    #[cold]\n-    pub fn double(&mut self) {\n-        match self.grow(Double, MayMove, Uninitialized) {\n-            Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n-            Ok(()) => { /* yay */ }\n-        }\n-    }\n-\n     /// Ensures that the buffer contains at least enough space to hold\n     /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n     /// enough capacity, will reallocate enough space plus comfortable slack\n@@ -336,7 +278,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         needed_extra_capacity: usize,\n     ) -> Result<(), TryReserveError> {\n         if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow(Amortized { used_capacity, needed_extra_capacity }, MayMove, Uninitialized)\n+            self.grow(Amortized, used_capacity, needed_extra_capacity, MayMove, Uninitialized)\n         } else {\n             Ok(())\n         }\n@@ -363,7 +305,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         // This is more readable than putting this in one line:\n         // `!self.needs_to_grow(...) || self.grow(...).is_ok()`\n         if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow(Amortized { used_capacity, needed_extra_capacity }, InPlace, Uninitialized)\n+            self.grow(Amortized, used_capacity, needed_extra_capacity, InPlace, Uninitialized)\n                 .is_ok()\n         } else {\n             true\n@@ -405,7 +347,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         needed_extra_capacity: usize,\n     ) -> Result<(), TryReserveError> {\n         if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow(Exact { used_capacity, needed_extra_capacity }, MayMove, Uninitialized)\n+            self.grow(Exact, used_capacity, needed_extra_capacity, MayMove, Uninitialized)\n         } else {\n             Ok(())\n         }\n@@ -432,9 +374,8 @@ impl<T, A: AllocRef> RawVec<T, A> {\n \n #[derive(Copy, Clone)]\n enum Strategy {\n-    Double,\n-    Amortized { used_capacity: usize, needed_extra_capacity: usize },\n-    Exact { used_capacity: usize, needed_extra_capacity: usize },\n+    Amortized,\n+    Exact,\n }\n use Strategy::*;\n \n@@ -459,6 +400,8 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     fn grow(\n         &mut self,\n         strategy: Strategy,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n         placement: ReallocPlacement,\n         init: AllocInit,\n     ) -> Result<(), TryReserveError> {\n@@ -469,23 +412,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n             return Err(CapacityOverflow);\n         }\n         let new_layout = match strategy {\n-            Double => unsafe {\n-                // Since we guarantee that we never allocate more than `isize::MAX` bytes,\n-                // `elem_size * self.cap <= isize::MAX` as a precondition, so this can't overflow.\n-                // Additionally the alignment will never be too large as to \"not be satisfiable\",\n-                // so `Layout::from_size_align` will always return `Some`.\n-                //\n-                // TL;DR, we bypass runtime checks due to dynamic assertions in this module,\n-                // allowing us to use `from_size_align_unchecked`.\n-                let cap = if self.cap == 0 {\n-                    // Skip to 4 because tiny `Vec`'s are dumb; but not if that would cause overflow.\n-                    if elem_size > usize::MAX / 8 { 1 } else { 4 }\n-                } else {\n-                    self.cap * 2\n-                };\n-                Layout::from_size_align_unchecked(cap * elem_size, mem::align_of::<T>())\n-            },\n-            Amortized { used_capacity, needed_extra_capacity } => {\n+            Amortized => {\n                 // Nothing we can really do about these checks, sadly.\n                 let required_cap =\n                     used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n@@ -495,7 +422,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                 let cap = cmp::max(double_cap, required_cap);\n                 Layout::array::<T>(cap).map_err(|_| CapacityOverflow)?\n             }\n-            Exact { used_capacity, needed_extra_capacity } => {\n+            Exact => {\n                 let cap =\n                     used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n                 Layout::array::<T>(cap).map_err(|_| CapacityOverflow)?"}]}