{"sha": "526e74884640ded4e7d32d3b73a03c395f10991b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNmU3NDg4NDY0MGRlZDRlN2QzMmQzYjczYTAzYzM5NWYxMDk5MWI=", "commit": {"author": {"name": "Ingo Blechschmidt", "email": "iblech@web.de", "date": "2015-02-06T23:39:28Z"}, "committer": {"name": "Ingo Blechschmidt", "email": "iblech@web.de", "date": "2015-02-06T23:39:28Z"}, "message": "Fix several tiny typos", "tree": {"sha": "1a7832bb54c22c887b39901b0c4452b8aa65336f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a7832bb54c22c887b39901b0c4452b8aa65336f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/526e74884640ded4e7d32d3b73a03c395f10991b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/526e74884640ded4e7d32d3b73a03c395f10991b", "html_url": "https://github.com/rust-lang/rust/commit/526e74884640ded4e7d32d3b73a03c395f10991b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/526e74884640ded4e7d32d3b73a03c395f10991b/comments", "author": {"login": "iblech", "id": 3661115, "node_id": "MDQ6VXNlcjM2NjExMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/3661115?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iblech", "html_url": "https://github.com/iblech", "followers_url": "https://api.github.com/users/iblech/followers", "following_url": "https://api.github.com/users/iblech/following{/other_user}", "gists_url": "https://api.github.com/users/iblech/gists{/gist_id}", "starred_url": "https://api.github.com/users/iblech/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iblech/subscriptions", "organizations_url": "https://api.github.com/users/iblech/orgs", "repos_url": "https://api.github.com/users/iblech/repos", "events_url": "https://api.github.com/users/iblech/events{/privacy}", "received_events_url": "https://api.github.com/users/iblech/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iblech", "id": 3661115, "node_id": "MDQ6VXNlcjM2NjExMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/3661115?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iblech", "html_url": "https://github.com/iblech", "followers_url": "https://api.github.com/users/iblech/followers", "following_url": "https://api.github.com/users/iblech/following{/other_user}", "gists_url": "https://api.github.com/users/iblech/gists{/gist_id}", "starred_url": "https://api.github.com/users/iblech/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iblech/subscriptions", "organizations_url": "https://api.github.com/users/iblech/orgs", "repos_url": "https://api.github.com/users/iblech/repos", "events_url": "https://api.github.com/users/iblech/events{/privacy}", "received_events_url": "https://api.github.com/users/iblech/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "994ccd30a09f57fb0055cf987f006fa19206902d", "url": "https://api.github.com/repos/rust-lang/rust/commits/994ccd30a09f57fb0055cf987f006fa19206902d", "html_url": "https://github.com/rust-lang/rust/commit/994ccd30a09f57fb0055cf987f006fa19206902d"}], "stats": {"total": 28, "additions": 14, "deletions": 14}, "files": [{"sha": "46dadbfe0cb0928bff75c9eba50d578b75705558", "filename": "src/doc/trpl/documentation.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdocumentation.md?ref=526e74884640ded4e7d32d3b73a03c395f10991b", "patch": "@@ -15,7 +15,7 @@ comments\":\n // the \"link\" crate attribute is currently required for rustdoc, but normally\n // isn't needed.\n #![crate_id = \"universe\"]\n-#![crate_type=\"lib\"]\n+#![crate_type = \"lib\"]\n \n //! Tools for dealing with universes (this is a doc comment, and is shown on\n //! the crate index page. The ! makes it apply to the parent of the comment,"}, {"sha": "14c57014e38e0e962cf43a2d5a46df1bfc0d57fb", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=526e74884640ded4e7d32d3b73a03c395f10991b", "patch": "@@ -163,7 +163,7 @@ The syntax `$(...)*` on the left-hand side of the `=>` in a macro definition\n accepts zero or more occurrences of its contents. It works much\n like the `*` operator in regular expressions. It also supports a\n separator token (a comma-separated list could be written `$(...),*`), and `+`\n-instead of `*` to mean \"at least one\".\n+instead of `*` to mean \"at least one.\"\n \n ~~~~\n # enum T { SpecialA(u32), SpecialB(u32), SpecialC(u32), SpecialD(u32) }\n@@ -195,7 +195,7 @@ As the above example demonstrates, `$(...)*` is also valid on the right-hand\n side of a macro definition. The behavior of `*` in transcription,\n especially in cases where multiple `*`s are nested, and multiple different\n names are involved, can seem somewhat magical and unintuitive at first. The\n-system that interprets them is called \"Macro By Example\". The two rules to\n+system that interprets them is called \"Macro By Example.\" The two rules to\n keep in mind are (1) the behavior of `$(...)*` is to walk through one \"layer\"\n of repetitions for all of the `$name`s it contains in lockstep, and (2) each\n `$name` must be under at least as many `$(...)*`s as it was matched against.\n@@ -309,7 +309,7 @@ there is a solution.\n \n A macro may accept multiple different input grammars. The first one to\n successfully match the actual argument to a macro invocation is the one that\n-\"wins\".\n+\"wins.\"\n \n In the case of the example above, we want to write a recursive macro to\n process the semicolon-terminated lines, one-by-one. So, we want the following"}, {"sha": "26aa6e26b30cadf0cde5d724785472e17d4f7a25", "filename": "src/doc/trpl/match.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Fdoc%2Ftrpl%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Fdoc%2Ftrpl%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmatch.md?ref=526e74884640ded4e7d32d3b73a03c395f10991b", "patch": "@@ -23,7 +23,7 @@ match x {\n `match` takes an expression and then branches based on its value. Each *arm* of\n the branch is of the form `val => expression`. When the value matches, that arm's\n expression will be evaluated. It's called `match` because of the term 'pattern\n-matching', which `match` is an implementation of.\n+matching,' which `match` is an implementation of.\n \n So what's the big advantage here? Well, there are a few. First of all, `match`\n enforces *exhaustiveness checking*. Do you see that last arm, the one with the"}, {"sha": "6da834b617c24f89ccb30d6125ce66408a32011e", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=526e74884640ded4e7d32d3b73a03c395f10991b", "patch": "@@ -61,7 +61,7 @@ multiplications later, and we have our area.\n ## Chaining method calls\n \n So, now we know how to call a method, such as `foo.bar()`. But what about our\n-original example, `foo.bar().baz()`? This is called 'method chaining', and we\n+original example, `foo.bar().baz()`? This is called 'method chaining,' and we\n can do it by returning `self`.\n \n ```"}, {"sha": "9af4304253c94e346f6e2aa7eb44e82af5791d94", "filename": "src/doc/trpl/more-strings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmore-strings.md?ref=526e74884640ded4e7d32d3b73a03c395f10991b", "patch": "@@ -14,7 +14,7 @@ Rust has two main types of strings: `&str` and `String`.\n \n # &str\n \n-The first kind is a `&str`. This is pronounced a 'string slice'.\n+The first kind is a `&str`. This is pronounced a 'string slice.'\n String literals are of the type `&str`:\n \n ```"}, {"sha": "e1d6bd697d4a98fef7c639632d64e1864c9e0027", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=526e74884640ded4e7d32d3b73a03c395f10991b", "patch": "@@ -293,7 +293,7 @@ struct Foo<'a> {\n }\n \n fn main() {\n-    let y = &5; // this is the same as `let _y = 5; let y = &_y;\n+    let y = &5; // this is the same as `let _y = 5; let y = &_y;`\n     let f = Foo { x: y };\n \n     println!(\"{}\", f.x);"}, {"sha": "ee498f25690a12eda88093d0cda05ad676cec9f1", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=526e74884640ded4e7d32d3b73a03c395f10991b", "patch": "@@ -308,7 +308,7 @@ crate to allow) and of course requires an `unsafe` block.\n ## Assembly template\n \n The `assembly template` is the only required parameter and must be a\n-literal string (i.e `\"\"`)\n+literal string (i.e. `\"\"`)\n \n ```\n #![feature(asm)]\n@@ -412,15 +412,15 @@ memory, `memory` should also be specified.\n ## Options\n \n The last section, `options` is specific to Rust. The format is comma\n-separated literal strings (i.e `:\"foo\", \"bar\", \"baz\"`). It's used to\n+separated literal strings (i.e. `:\"foo\", \"bar\", \"baz\"`). It's used to\n specify some extra info about the inline assembly:\n \n Current valid options are:\n \n 1. *volatile* - specifying this is analogous to\n    `__asm__ __volatile__ (...)` in gcc/clang.\n 2. *alignstack* - certain instructions expect the stack to be\n-   aligned a certain way (i.e SSE) and specifying this indicates to\n+   aligned a certain way (i.e. SSE) and specifying this indicates to\n    the compiler to insert its usual stack alignment code\n 3. *intel* - use intel syntax instead of the default AT&T.\n \n@@ -649,7 +649,7 @@ functionality that isn't hard-coded into the language, but is\n implemented in libraries, with a special marker to tell the compiler\n it exists. The marker is the attribute `#[lang=\"...\"]` and there are\n various different values of `...`, i.e. various different \"lang\n-items\".\n+items.\"\n \n For example, `Box` pointers require two lang items, one for allocation\n and one for deallocation. A freestanding program that uses the `Box`"}, {"sha": "2c0691dede48416d9fcb086c7915ec3d158ccd40", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526e74884640ded4e7d32d3b73a03c395f10991b/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=526e74884640ded4e7d32d3b73a03c395f10991b", "patch": "@@ -2348,7 +2348,7 @@ impl<A, St, F> Iterator for Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n /// iteration\n #[derive(Clone)]\n #[unstable(feature = \"core\",\n-           reason = \"may be renamed or replaced by range notation adapaters\")]\n+           reason = \"may be renamed or replaced by range notation adapters\")]\n pub struct Counter<A> {\n     /// The current state the counter is at (next value to be yielded)\n     state: A,\n@@ -2359,7 +2359,7 @@ pub struct Counter<A> {\n /// Creates a new counter with the specified start/step\n #[inline]\n #[unstable(feature = \"core\",\n-           reason = \"may be renamed or replaced by range notation adapaters\")]\n+           reason = \"may be renamed or replaced by range notation adapters\")]\n pub fn count<A>(start: A, step: A) -> Counter<A> {\n     Counter{state: start, step: step}\n }"}]}