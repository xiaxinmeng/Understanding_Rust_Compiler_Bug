{"sha": "2f601ef527a37de9fb181c5fb1a6c06d06218ed3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNjAxZWY1MjdhMzdkZTlmYjE4MWM1ZmIxYTZjMDZkMDYyMThlZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-02T13:11:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-02T13:11:41Z"}, "message": "Auto merge of #85337 - cjgillot:less-anon, r=michaelwoerister\n\nAvoid creating anonymous nodes with zero or one dependency.\n\nAnonymous nodes are only useful to encode dependencies, and cannot be replayed from one compilation session to another.\nAs such, anonymous nodes without dependency are always green.\nAnonymous nodes with only one dependency are equivalent to this dependency.\n\ncc #45408\ncc `@michaelwoerister`", "tree": {"sha": "dec9b7c6fad4e580096394cd24907b9fe6a991cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dec9b7c6fad4e580096394cd24907b9fe6a991cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f601ef527a37de9fb181c5fb1a6c06d06218ed3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f601ef527a37de9fb181c5fb1a6c06d06218ed3", "html_url": "https://github.com/rust-lang/rust/commit/2f601ef527a37de9fb181c5fb1a6c06d06218ed3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f601ef527a37de9fb181c5fb1a6c06d06218ed3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e13a9bb33debb931d603278b7f1a706b0d11660", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e13a9bb33debb931d603278b7f1a706b0d11660", "html_url": "https://github.com/rust-lang/rust/commit/1e13a9bb33debb931d603278b7f1a706b0d11660"}, {"sha": "b51f24f021a985e689f35214302ed5844907962d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b51f24f021a985e689f35214302ed5844907962d", "html_url": "https://github.com/rust-lang/rust/commit/b51f24f021a985e689f35214302ed5844907962d"}], "stats": {"total": 81, "additions": 54, "deletions": 27}, "files": [{"sha": "a8455854ebb5fd97809e26f170c29c13beb4cfca", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f601ef527a37de9fb181c5fb1a6c06d06218ed3/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f601ef527a37de9fb181c5fb1a6c06d06218ed3/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=2f601ef527a37de9fb181c5fb1a6c06d06218ed3", "patch": "@@ -229,6 +229,7 @@ pub fn build_dep_graph(\n     }\n \n     Some(DepGraph::new(\n+        &sess.prof,\n         prev_graph,\n         prev_work_products,\n         encoder,"}, {"sha": "71e67dfee538bdee7f553a687eb03e3aed6e8e72", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 53, "deletions": 27, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2f601ef527a37de9fb181c5fb1a6c06d06218ed3/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f601ef527a37de9fb181c5fb1a6c06d06218ed3/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=2f601ef527a37de9fb181c5fb1a6c06d06218ed3", "patch": "@@ -44,6 +44,7 @@ rustc_index::newtype_index! {\n \n impl DepNodeIndex {\n     pub const INVALID: DepNodeIndex = DepNodeIndex::MAX;\n+    pub const SINGLETON_DEPENDENCYLESS_ANON_NODE: DepNodeIndex = DepNodeIndex::from_u32(0);\n }\n \n impl std::convert::From<DepNodeIndex> for QueryInvocationId {\n@@ -108,6 +109,7 @@ where\n \n impl<K: DepKind> DepGraph<K> {\n     pub fn new(\n+        profiler: &SelfProfilerRef,\n         prev_graph: SerializedDepGraph<K>,\n         prev_work_products: FxHashMap<WorkProductId, WorkProduct>,\n         encoder: FileEncoder,\n@@ -116,16 +118,23 @@ impl<K: DepKind> DepGraph<K> {\n     ) -> DepGraph<K> {\n         let prev_graph_node_count = prev_graph.node_count();\n \n+        let current =\n+            CurrentDepGraph::new(prev_graph_node_count, encoder, record_graph, record_stats);\n+\n+        // Instantiate a dependy-less node only once for anonymous queries.\n+        let _green_node_index = current.intern_new_node(\n+            profiler,\n+            DepNode { kind: DepKind::NULL, hash: current.anon_id_seed.into() },\n+            smallvec![],\n+            Fingerprint::ZERO,\n+        );\n+        debug_assert_eq!(_green_node_index, DepNodeIndex::SINGLETON_DEPENDENCYLESS_ANON_NODE);\n+\n         DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: prev_work_products,\n                 dep_node_debug: Default::default(),\n-                current: CurrentDepGraph::new(\n-                    prev_graph_node_count,\n-                    encoder,\n-                    record_graph,\n-                    record_stats,\n-                ),\n+                current,\n                 emitting_diagnostics: Default::default(),\n                 emitting_diagnostics_cond_var: Condvar::new(),\n                 previous: prev_graph,\n@@ -287,30 +296,47 @@ impl<K: DepKind> DepGraph<K> {\n             let task_deps = Lock::new(TaskDeps::default());\n             let result = K::with_deps(Some(&task_deps), op);\n             let task_deps = task_deps.into_inner();\n+            let task_deps = task_deps.reads;\n+\n+            let dep_node_index = match task_deps.len() {\n+                0 => {\n+                    // Because the dep-node id of anon nodes is computed from the sets of its\n+                    // dependencies we already know what the ID of this dependency-less node is\n+                    // going to be (i.e. equal to the precomputed\n+                    // `SINGLETON_DEPENDENCYLESS_ANON_NODE`). As a consequence we can skip creating\n+                    // a `StableHasher` and sending the node through interning.\n+                    DepNodeIndex::SINGLETON_DEPENDENCYLESS_ANON_NODE\n+                }\n+                1 => {\n+                    // When there is only one dependency, don't bother creating a node.\n+                    task_deps[0]\n+                }\n+                _ => {\n+                    // The dep node indices are hashed here instead of hashing the dep nodes of the\n+                    // dependencies. These indices may refer to different nodes per session, but this isn't\n+                    // a problem here because we that ensure the final dep node hash is per session only by\n+                    // combining it with the per session random number `anon_id_seed`. This hash only need\n+                    // to map the dependencies to a single value on a per session basis.\n+                    let mut hasher = StableHasher::new();\n+                    task_deps.hash(&mut hasher);\n+\n+                    let target_dep_node = DepNode {\n+                        kind: dep_kind,\n+                        // Fingerprint::combine() is faster than sending Fingerprint\n+                        // through the StableHasher (at least as long as StableHasher\n+                        // is so slow).\n+                        hash: data.current.anon_id_seed.combine(hasher.finish()).into(),\n+                    };\n \n-            // The dep node indices are hashed here instead of hashing the dep nodes of the\n-            // dependencies. These indices may refer to different nodes per session, but this isn't\n-            // a problem here because we that ensure the final dep node hash is per session only by\n-            // combining it with the per session random number `anon_id_seed`. This hash only need\n-            // to map the dependencies to a single value on a per session basis.\n-            let mut hasher = StableHasher::new();\n-            task_deps.reads.hash(&mut hasher);\n-\n-            let target_dep_node = DepNode {\n-                kind: dep_kind,\n-                // Fingerprint::combine() is faster than sending Fingerprint\n-                // through the StableHasher (at least as long as StableHasher\n-                // is so slow).\n-                hash: data.current.anon_id_seed.combine(hasher.finish()).into(),\n+                    data.current.intern_new_node(\n+                        cx.profiler(),\n+                        target_dep_node,\n+                        task_deps,\n+                        Fingerprint::ZERO,\n+                    )\n+                }\n             };\n \n-            let dep_node_index = data.current.intern_new_node(\n-                cx.profiler(),\n-                target_dep_node,\n-                task_deps.reads,\n-                Fingerprint::ZERO,\n-            );\n-\n             (result, dep_node_index)\n         } else {\n             (op(), self.next_virtual_depnode_index())"}]}