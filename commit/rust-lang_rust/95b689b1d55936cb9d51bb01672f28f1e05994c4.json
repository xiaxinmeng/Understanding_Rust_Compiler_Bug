{"sha": "95b689b1d55936cb9d51bb01672f28f1e05994c4", "node_id": "C_kwDOAAsO6NoAKDk1YjY4OWIxZDU1OTM2Y2I5ZDUxYmIwMTY3MmYyOGYxZTA1OTk0YzQ", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-10-03T00:06:14Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-10-03T14:12:03Z"}, "message": "Move utils from rustc_middle to rustc_ty_utils", "tree": {"sha": "31b3edc17042649bb3df103d807483d774807428", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31b3edc17042649bb3df103d807483d774807428"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95b689b1d55936cb9d51bb01672f28f1e05994c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95b689b1d55936cb9d51bb01672f28f1e05994c4", "html_url": "https://github.com/rust-lang/rust/commit/95b689b1d55936cb9d51bb01672f28f1e05994c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95b689b1d55936cb9d51bb01672f28f1e05994c4/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8a847e30d206f5ff913c5286f92bce427f0f7f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8a847e30d206f5ff913c5286f92bce427f0f7f3", "html_url": "https://github.com/rust-lang/rust/commit/a8a847e30d206f5ff913c5286f92bce427f0f7f3"}], "stats": {"total": 4680, "additions": 2337, "deletions": 2343}, "files": [{"sha": "20d0a4767197013ea2bde79381af31d87802ec93", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95b689b1d55936cb9d51bb01672f28f1e05994c4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/95b689b1d55936cb9d51bb01672f28f1e05994c4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=95b689b1d55936cb9d51bb01672f28f1e05994c4", "patch": "@@ -3781,8 +3781,6 @@ dependencies = [\n  \"either\",\n  \"gsgdt\",\n  \"polonius-engine\",\n- \"rand 0.8.5\",\n- \"rand_xoshiro\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n  \"rustc_apfloat\",\n@@ -4228,6 +4226,8 @@ dependencies = [\n name = \"rustc_ty_utils\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rand 0.8.5\",\n+ \"rand_xoshiro\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\","}, {"sha": "de916ea8c49733f9df5b0619025c544d4d745def", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=95b689b1d55936cb9d51bb01672f28f1e05994c4", "patch": "@@ -12,8 +12,6 @@ chalk-ir = \"0.80.0\"\n either = \"1.5.0\"\n gsgdt = \"0.1.2\"\n polonius-engine = \"0.13.0\"\n-rand = \"0.8.4\"\n-rand_xoshiro = \"0.6.0\"\n rustc_apfloat = { path = \"../rustc_apfloat\" }\n rustc_arena = { path = \"../rustc_arena\" }\n rustc_ast = { path = \"../rustc_ast\" }"}, {"sha": "4fb4c9b11e7ea13e55527e3a8c801b8a1ae2efe0", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 5, "deletions": 2334, "changes": 2339, "blob_url": "https://github.com/rust-lang/rust/blob/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=95b689b1d55936cb9d51bb01672f28f1e05994c4"}, {"sha": "753d7bffe84c2ea84c7f4b98be000148da732b08", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=95b689b1d55936cb9d51bb01672f28f1e05994c4", "patch": "@@ -130,7 +130,6 @@ mod erase_regions;\n mod generics;\n mod impls_ty;\n mod instance;\n-mod layout_sanity_check;\n mod list;\n mod parameterized;\n mod rvalue_scopes;\n@@ -2593,7 +2592,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     closure::provide(providers);\n     context::provide(providers);\n     erase_regions::provide(providers);\n-    layout::provide(providers);\n     util::provide(providers);\n     print::provide(providers);\n     super::util::bug::provide(providers);"}, {"sha": "5e4ba47306192b907e63c9f224b0b42da8faa32e", "filename": "compiler/rustc_ty_utils/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_ty_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_ty_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2FCargo.toml?ref=95b689b1d55936cb9d51bb01672f28f1e05994c4", "patch": "@@ -4,6 +4,8 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [dependencies]\n+rand = \"0.8.4\"\n+rand_xoshiro = \"0.6.0\"\n tracing = \"0.1\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "6e34ee21082eab8a98a39849e5c0305397c9b7ab", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "added", "additions": 518, "deletions": 0, "changes": 518, "blob_url": "https://github.com/rust-lang/rust/blob/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=95b689b1d55936cb9d51bb01672f28f1e05994c4", "patch": "@@ -0,0 +1,518 @@\n+use rustc_hir as hir;\n+use rustc_hir::lang_items::LangItem;\n+use rustc_middle::ty::layout::{\n+    fn_can_unwind, FnAbiError, HasParamEnv, HasTyCtxt, LayoutCx, LayoutOf, TyAndLayout,\n+};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::def_id::DefId;\n+use rustc_target::abi::call::{\n+    ArgAbi, ArgAttribute, ArgAttributes, ArgExtension, Conv, FnAbi, PassMode, Reg, RegKind,\n+};\n+use rustc_target::abi::*;\n+use rustc_target::spec::abi::Abi as SpecAbi;\n+\n+use std::iter;\n+\n+pub fn provide(providers: &mut ty::query::Providers) {\n+    *providers = ty::query::Providers { fn_abi_of_fn_ptr, fn_abi_of_instance, ..*providers };\n+}\n+\n+// NOTE(eddyb) this is private to avoid using it from outside of\n+// `fn_abi_of_instance` - any other uses are either too high-level\n+// for `Instance` (e.g. typeck would use `Ty::fn_sig` instead),\n+// or should go through `FnAbi` instead, to avoid losing any\n+// adjustments `fn_abi_of_instance` might be performing.\n+#[tracing::instrument(level = \"debug\", skip(tcx, param_env))]\n+fn fn_sig_for_fn_abi<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    instance: ty::Instance<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> ty::PolyFnSig<'tcx> {\n+    let ty = instance.ty(tcx, param_env);\n+    match *ty.kind() {\n+        ty::FnDef(..) => {\n+            // HACK(davidtwco,eddyb): This is a workaround for polymorphization considering\n+            // parameters unused if they show up in the signature, but not in the `mir::Body`\n+            // (i.e. due to being inside a projection that got normalized, see\n+            // `src/test/ui/polymorphization/normalized_sig_types.rs`), and codegen not keeping\n+            // track of a polymorphization `ParamEnv` to allow normalizing later.\n+            //\n+            // We normalize the `fn_sig` again after substituting at a later point.\n+            let mut sig = match *ty.kind() {\n+                ty::FnDef(def_id, substs) => tcx\n+                    .bound_fn_sig(def_id)\n+                    .map_bound(|fn_sig| {\n+                        tcx.normalize_erasing_regions(tcx.param_env(def_id), fn_sig)\n+                    })\n+                    .subst(tcx, substs),\n+                _ => unreachable!(),\n+            };\n+\n+            if let ty::InstanceDef::VTableShim(..) = instance.def {\n+                // Modify `fn(self, ...)` to `fn(self: *mut Self, ...)`.\n+                sig = sig.map_bound(|mut sig| {\n+                    let mut inputs_and_output = sig.inputs_and_output.to_vec();\n+                    inputs_and_output[0] = tcx.mk_mut_ptr(inputs_and_output[0]);\n+                    sig.inputs_and_output = tcx.intern_type_list(&inputs_and_output);\n+                    sig\n+                });\n+            }\n+            sig\n+        }\n+        ty::Closure(def_id, substs) => {\n+            let sig = substs.as_closure().sig();\n+\n+            let bound_vars = tcx.mk_bound_variable_kinds(\n+                sig.bound_vars().iter().chain(iter::once(ty::BoundVariableKind::Region(ty::BrEnv))),\n+            );\n+            let br = ty::BoundRegion {\n+                var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n+                kind: ty::BoundRegionKind::BrEnv,\n+            };\n+            let env_region = ty::ReLateBound(ty::INNERMOST, br);\n+            let env_ty = tcx.closure_env_ty(def_id, substs, env_region).unwrap();\n+\n+            let sig = sig.skip_binder();\n+            ty::Binder::bind_with_vars(\n+                tcx.mk_fn_sig(\n+                    iter::once(env_ty).chain(sig.inputs().iter().cloned()),\n+                    sig.output(),\n+                    sig.c_variadic,\n+                    sig.unsafety,\n+                    sig.abi,\n+                ),\n+                bound_vars,\n+            )\n+        }\n+        ty::Generator(_, substs, _) => {\n+            let sig = substs.as_generator().poly_sig();\n+\n+            let bound_vars = tcx.mk_bound_variable_kinds(\n+                sig.bound_vars().iter().chain(iter::once(ty::BoundVariableKind::Region(ty::BrEnv))),\n+            );\n+            let br = ty::BoundRegion {\n+                var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n+                kind: ty::BoundRegionKind::BrEnv,\n+            };\n+            let env_region = ty::ReLateBound(ty::INNERMOST, br);\n+            let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n+\n+            let pin_did = tcx.require_lang_item(LangItem::Pin, None);\n+            let pin_adt_ref = tcx.adt_def(pin_did);\n+            let pin_substs = tcx.intern_substs(&[env_ty.into()]);\n+            let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n+\n+            let sig = sig.skip_binder();\n+            let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n+            let state_adt_ref = tcx.adt_def(state_did);\n+            let state_substs = tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n+            let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n+            ty::Binder::bind_with_vars(\n+                tcx.mk_fn_sig(\n+                    [env_ty, sig.resume_ty].iter(),\n+                    &ret_ty,\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    rustc_target::spec::abi::Abi::Rust,\n+                ),\n+                bound_vars,\n+            )\n+        }\n+        _ => bug!(\"unexpected type {:?} in Instance::fn_sig\", ty),\n+    }\n+}\n+\n+#[inline]\n+fn conv_from_spec_abi(tcx: TyCtxt<'_>, abi: SpecAbi) -> Conv {\n+    use rustc_target::spec::abi::Abi::*;\n+    match tcx.sess.target.adjust_abi(abi) {\n+        RustIntrinsic | PlatformIntrinsic | Rust | RustCall => Conv::Rust,\n+        RustCold => Conv::RustCold,\n+\n+        // It's the ABI's job to select this, not ours.\n+        System { .. } => bug!(\"system abi should be selected elsewhere\"),\n+        EfiApi => bug!(\"eficall abi should be selected elsewhere\"),\n+\n+        Stdcall { .. } => Conv::X86Stdcall,\n+        Fastcall { .. } => Conv::X86Fastcall,\n+        Vectorcall { .. } => Conv::X86VectorCall,\n+        Thiscall { .. } => Conv::X86ThisCall,\n+        C { .. } => Conv::C,\n+        Unadjusted => Conv::C,\n+        Win64 { .. } => Conv::X86_64Win64,\n+        SysV64 { .. } => Conv::X86_64SysV,\n+        Aapcs { .. } => Conv::ArmAapcs,\n+        CCmseNonSecureCall => Conv::CCmseNonSecureCall,\n+        PtxKernel => Conv::PtxKernel,\n+        Msp430Interrupt => Conv::Msp430Intr,\n+        X86Interrupt => Conv::X86Intr,\n+        AmdGpuKernel => Conv::AmdGpuKernel,\n+        AvrInterrupt => Conv::AvrInterrupt,\n+        AvrNonBlockingInterrupt => Conv::AvrNonBlockingInterrupt,\n+        Wasm => Conv::C,\n+\n+        // These API constants ought to be more specific...\n+        Cdecl { .. } => Conv::C,\n+    }\n+}\n+\n+fn fn_abi_of_fn_ptr<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    query: ty::ParamEnvAnd<'tcx, (ty::PolyFnSig<'tcx>, &'tcx ty::List<Ty<'tcx>>)>,\n+) -> Result<&'tcx FnAbi<'tcx, Ty<'tcx>>, FnAbiError<'tcx>> {\n+    let (param_env, (sig, extra_args)) = query.into_parts();\n+\n+    let cx = LayoutCx { tcx, param_env };\n+    fn_abi_new_uncached(&cx, sig, extra_args, None, None, false)\n+}\n+\n+fn fn_abi_of_instance<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    query: ty::ParamEnvAnd<'tcx, (ty::Instance<'tcx>, &'tcx ty::List<Ty<'tcx>>)>,\n+) -> Result<&'tcx FnAbi<'tcx, Ty<'tcx>>, FnAbiError<'tcx>> {\n+    let (param_env, (instance, extra_args)) = query.into_parts();\n+\n+    let sig = fn_sig_for_fn_abi(tcx, instance, param_env);\n+\n+    let caller_location = if instance.def.requires_caller_location(tcx) {\n+        Some(tcx.caller_location_ty())\n+    } else {\n+        None\n+    };\n+\n+    fn_abi_new_uncached(\n+        &LayoutCx { tcx, param_env },\n+        sig,\n+        extra_args,\n+        caller_location,\n+        Some(instance.def_id()),\n+        matches!(instance.def, ty::InstanceDef::Virtual(..)),\n+    )\n+}\n+\n+// Handle safe Rust thin and fat pointers.\n+fn adjust_for_rust_scalar<'tcx>(\n+    cx: LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    attrs: &mut ArgAttributes,\n+    scalar: Scalar,\n+    layout: TyAndLayout<'tcx>,\n+    offset: Size,\n+    is_return: bool,\n+) {\n+    // Booleans are always a noundef i1 that needs to be zero-extended.\n+    if scalar.is_bool() {\n+        attrs.ext(ArgExtension::Zext);\n+        attrs.set(ArgAttribute::NoUndef);\n+        return;\n+    }\n+\n+    // Scalars which have invalid values cannot be undef.\n+    if !scalar.is_always_valid(&cx) {\n+        attrs.set(ArgAttribute::NoUndef);\n+    }\n+\n+    // Only pointer types handled below.\n+    let Scalar::Initialized { value: Pointer, valid_range} = scalar else { return };\n+\n+    if !valid_range.contains(0) {\n+        attrs.set(ArgAttribute::NonNull);\n+    }\n+\n+    if let Some(pointee) = layout.pointee_info_at(&cx, offset) {\n+        if let Some(kind) = pointee.safe {\n+            attrs.pointee_align = Some(pointee.align);\n+\n+            // `Box` (`UniqueBorrowed`) are not necessarily dereferenceable\n+            // for the entire duration of the function as they can be deallocated\n+            // at any time. Same for shared mutable references. If LLVM had a\n+            // way to say \"dereferenceable on entry\" we could use it here.\n+            attrs.pointee_size = match kind {\n+                PointerKind::UniqueBorrowed\n+                | PointerKind::UniqueBorrowedPinned\n+                | PointerKind::Frozen => pointee.size,\n+                PointerKind::SharedMutable | PointerKind::UniqueOwned => Size::ZERO,\n+            };\n+\n+            // `Box`, `&T`, and `&mut T` cannot be undef.\n+            // Note that this only applies to the value of the pointer itself;\n+            // this attribute doesn't make it UB for the pointed-to data to be undef.\n+            attrs.set(ArgAttribute::NoUndef);\n+\n+            // The aliasing rules for `Box<T>` are still not decided, but currently we emit\n+            // `noalias` for it. This can be turned off using an unstable flag.\n+            // See https://github.com/rust-lang/unsafe-code-guidelines/issues/326\n+            let noalias_for_box = cx.tcx.sess.opts.unstable_opts.box_noalias.unwrap_or(true);\n+\n+            // `&mut` pointer parameters never alias other parameters,\n+            // or mutable global data\n+            //\n+            // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n+            // and can be marked as both `readonly` and `noalias`, as\n+            // LLVM's definition of `noalias` is based solely on memory\n+            // dependencies rather than pointer equality\n+            //\n+            // Due to past miscompiles in LLVM, we apply a separate NoAliasMutRef attribute\n+            // for UniqueBorrowed arguments, so that the codegen backend can decide whether\n+            // or not to actually emit the attribute. It can also be controlled with the\n+            // `-Zmutable-noalias` debugging option.\n+            let no_alias = match kind {\n+                PointerKind::SharedMutable\n+                | PointerKind::UniqueBorrowed\n+                | PointerKind::UniqueBorrowedPinned => false,\n+                PointerKind::UniqueOwned => noalias_for_box,\n+                PointerKind::Frozen => !is_return,\n+            };\n+            if no_alias {\n+                attrs.set(ArgAttribute::NoAlias);\n+            }\n+\n+            if kind == PointerKind::Frozen && !is_return {\n+                attrs.set(ArgAttribute::ReadOnly);\n+            }\n+\n+            if kind == PointerKind::UniqueBorrowed && !is_return {\n+                attrs.set(ArgAttribute::NoAliasMutRef);\n+            }\n+        }\n+    }\n+}\n+\n+// FIXME(eddyb) perhaps group the signature/type-containing (or all of them?)\n+// arguments of this method, into a separate `struct`.\n+#[tracing::instrument(level = \"debug\", skip(cx, caller_location, fn_def_id, force_thin_self_ptr))]\n+fn fn_abi_new_uncached<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    sig: ty::PolyFnSig<'tcx>,\n+    extra_args: &[Ty<'tcx>],\n+    caller_location: Option<Ty<'tcx>>,\n+    fn_def_id: Option<DefId>,\n+    // FIXME(eddyb) replace this with something typed, like an `enum`.\n+    force_thin_self_ptr: bool,\n+) -> Result<&'tcx FnAbi<'tcx, Ty<'tcx>>, FnAbiError<'tcx>> {\n+    let sig = cx.tcx.normalize_erasing_late_bound_regions(cx.param_env, sig);\n+\n+    let conv = conv_from_spec_abi(cx.tcx(), sig.abi);\n+\n+    let mut inputs = sig.inputs();\n+    let extra_args = if sig.abi == RustCall {\n+        assert!(!sig.c_variadic && extra_args.is_empty());\n+\n+        if let Some(input) = sig.inputs().last() {\n+            if let ty::Tuple(tupled_arguments) = input.kind() {\n+                inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n+                tupled_arguments\n+            } else {\n+                bug!(\n+                    \"argument to function with \\\"rust-call\\\" ABI \\\n+                        is not a tuple\"\n+                );\n+            }\n+        } else {\n+            bug!(\n+                \"argument to function with \\\"rust-call\\\" ABI \\\n+                    is not a tuple\"\n+            );\n+        }\n+    } else {\n+        assert!(sig.c_variadic || extra_args.is_empty());\n+        extra_args\n+    };\n+\n+    let target = &cx.tcx.sess.target;\n+    let target_env_gnu_like = matches!(&target.env[..], \"gnu\" | \"musl\" | \"uclibc\");\n+    let win_x64_gnu = target.os == \"windows\" && target.arch == \"x86_64\" && target.env == \"gnu\";\n+    let linux_s390x_gnu_like =\n+        target.os == \"linux\" && target.arch == \"s390x\" && target_env_gnu_like;\n+    let linux_sparc64_gnu_like =\n+        target.os == \"linux\" && target.arch == \"sparc64\" && target_env_gnu_like;\n+    let linux_powerpc_gnu_like =\n+        target.os == \"linux\" && target.arch == \"powerpc\" && target_env_gnu_like;\n+    use SpecAbi::*;\n+    let rust_abi = matches!(sig.abi, RustIntrinsic | PlatformIntrinsic | Rust | RustCall);\n+\n+    let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| -> Result<_, FnAbiError<'tcx>> {\n+        let span = tracing::debug_span!(\"arg_of\");\n+        let _entered = span.enter();\n+        let is_return = arg_idx.is_none();\n+\n+        let layout = cx.layout_of(ty)?;\n+        let layout = if force_thin_self_ptr && arg_idx == Some(0) {\n+            // Don't pass the vtable, it's not an argument of the virtual fn.\n+            // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n+            // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n+            make_thin_self_ptr(cx, layout)\n+        } else {\n+            layout\n+        };\n+\n+        let mut arg = ArgAbi::new(cx, layout, |layout, scalar, offset| {\n+            let mut attrs = ArgAttributes::new();\n+            adjust_for_rust_scalar(*cx, &mut attrs, scalar, *layout, offset, is_return);\n+            attrs\n+        });\n+\n+        if arg.layout.is_zst() {\n+            // For some forsaken reason, x86_64-pc-windows-gnu\n+            // doesn't ignore zero-sized struct arguments.\n+            // The same is true for {s390x,sparc64,powerpc}-unknown-linux-{gnu,musl,uclibc}.\n+            if is_return\n+                || rust_abi\n+                || (!win_x64_gnu\n+                    && !linux_s390x_gnu_like\n+                    && !linux_sparc64_gnu_like\n+                    && !linux_powerpc_gnu_like)\n+            {\n+                arg.mode = PassMode::Ignore;\n+            }\n+        }\n+\n+        Ok(arg)\n+    };\n+\n+    let mut fn_abi = FnAbi {\n+        ret: arg_of(sig.output(), None)?,\n+        args: inputs\n+            .iter()\n+            .copied()\n+            .chain(extra_args.iter().copied())\n+            .chain(caller_location)\n+            .enumerate()\n+            .map(|(i, ty)| arg_of(ty, Some(i)))\n+            .collect::<Result<_, _>>()?,\n+        c_variadic: sig.c_variadic,\n+        fixed_count: inputs.len() as u32,\n+        conv,\n+        can_unwind: fn_can_unwind(cx.tcx(), fn_def_id, sig.abi),\n+    };\n+    fn_abi_adjust_for_abi(cx, &mut fn_abi, sig.abi)?;\n+    debug!(\"fn_abi_new_uncached = {:?}\", fn_abi);\n+    Ok(cx.tcx.arena.alloc(fn_abi))\n+}\n+\n+#[tracing::instrument(level = \"trace\", skip(cx))]\n+fn fn_abi_adjust_for_abi<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    fn_abi: &mut FnAbi<'tcx, Ty<'tcx>>,\n+    abi: SpecAbi,\n+) -> Result<(), FnAbiError<'tcx>> {\n+    if abi == SpecAbi::Unadjusted {\n+        return Ok(());\n+    }\n+\n+    if abi == SpecAbi::Rust\n+        || abi == SpecAbi::RustCall\n+        || abi == SpecAbi::RustIntrinsic\n+        || abi == SpecAbi::PlatformIntrinsic\n+    {\n+        let fixup = |arg: &mut ArgAbi<'tcx, Ty<'tcx>>| {\n+            if arg.is_ignore() {\n+                return;\n+            }\n+\n+            match arg.layout.abi {\n+                Abi::Aggregate { .. } => {}\n+\n+                // This is a fun case! The gist of what this is doing is\n+                // that we want callers and callees to always agree on the\n+                // ABI of how they pass SIMD arguments. If we were to *not*\n+                // make these arguments indirect then they'd be immediates\n+                // in LLVM, which means that they'd used whatever the\n+                // appropriate ABI is for the callee and the caller. That\n+                // means, for example, if the caller doesn't have AVX\n+                // enabled but the callee does, then passing an AVX argument\n+                // across this boundary would cause corrupt data to show up.\n+                //\n+                // This problem is fixed by unconditionally passing SIMD\n+                // arguments through memory between callers and callees\n+                // which should get them all to agree on ABI regardless of\n+                // target feature sets. Some more information about this\n+                // issue can be found in #44367.\n+                //\n+                // Note that the platform intrinsic ABI is exempt here as\n+                // that's how we connect up to LLVM and it's unstable\n+                // anyway, we control all calls to it in libstd.\n+                Abi::Vector { .. }\n+                    if abi != SpecAbi::PlatformIntrinsic\n+                        && cx.tcx.sess.target.simd_types_indirect =>\n+                {\n+                    arg.make_indirect();\n+                    return;\n+                }\n+\n+                _ => return,\n+            }\n+\n+            let size = arg.layout.size;\n+            if arg.layout.is_unsized() || size > Pointer.size(cx) {\n+                arg.make_indirect();\n+            } else {\n+                // We want to pass small aggregates as immediates, but using\n+                // a LLVM aggregate type for this leads to bad optimizations,\n+                // so we pick an appropriately sized integer type instead.\n+                arg.cast_to(Reg { kind: RegKind::Integer, size });\n+            }\n+        };\n+        fixup(&mut fn_abi.ret);\n+        for arg in fn_abi.args.iter_mut() {\n+            fixup(arg);\n+        }\n+    } else {\n+        fn_abi.adjust_for_foreign_abi(cx, abi)?;\n+    }\n+\n+    Ok(())\n+}\n+\n+#[tracing::instrument(level = \"debug\", skip(cx))]\n+fn make_thin_self_ptr<'tcx>(\n+    cx: &(impl HasTyCtxt<'tcx> + HasParamEnv<'tcx>),\n+    layout: TyAndLayout<'tcx>,\n+) -> TyAndLayout<'tcx> {\n+    let tcx = cx.tcx();\n+    let fat_pointer_ty = if layout.is_unsized() {\n+        // unsized `self` is passed as a pointer to `self`\n+        // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n+        tcx.mk_mut_ptr(layout.ty)\n+    } else {\n+        match layout.abi {\n+            Abi::ScalarPair(..) | Abi::Scalar(..) => (),\n+            _ => bug!(\"receiver type has unsupported layout: {:?}\", layout),\n+        }\n+\n+        // In the case of Rc<Self>, we need to explicitly pass a *mut RcBox<Self>\n+        // with a Scalar (not ScalarPair) ABI. This is a hack that is understood\n+        // elsewhere in the compiler as a method on a `dyn Trait`.\n+        // To get the type `*mut RcBox<Self>`, we just keep unwrapping newtypes until we\n+        // get a built-in pointer type\n+        let mut fat_pointer_layout = layout;\n+        'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n+            && !fat_pointer_layout.ty.is_region_ptr()\n+        {\n+            for i in 0..fat_pointer_layout.fields.count() {\n+                let field_layout = fat_pointer_layout.field(cx, i);\n+\n+                if !field_layout.is_zst() {\n+                    fat_pointer_layout = field_layout;\n+                    continue 'descend_newtypes;\n+                }\n+            }\n+\n+            bug!(\"receiver has no non-zero-sized fields {:?}\", fat_pointer_layout);\n+        }\n+\n+        fat_pointer_layout.ty\n+    };\n+\n+    // we now have a type like `*mut RcBox<dyn Trait>`\n+    // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n+    // this is understood as a special case elsewhere in the compiler\n+    let unit_ptr_ty = tcx.mk_mut_ptr(tcx.mk_unit());\n+\n+    TyAndLayout {\n+        ty: fat_pointer_ty,\n+\n+        // NOTE(eddyb) using an empty `ParamEnv`, and `unwrap`-ing the `Result`\n+        // should always work because the type is always `*mut ()`.\n+        ..tcx.layout_of(ty::ParamEnv::reveal_all().and(unit_ptr_ty)).unwrap()\n+    }\n+}"}, {"sha": "9e4dc26bfd4d2f17224f41a8b14e4e42d661be80", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "added", "additions": 1804, "deletions": 0, "changes": 1804, "blob_url": "https://github.com/rust-lang/rust/blob/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=95b689b1d55936cb9d51bb01672f28f1e05994c4", "patch": "@@ -0,0 +1,1804 @@\n+use rustc_hir as hir;\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::mir::{GeneratorLayout, GeneratorSavedLocal};\n+use rustc_middle::ty::layout::{\n+    IntegerExt, LayoutCx, LayoutError, LayoutOf, TyAndLayout, MAX_SIMD_LANES,\n+};\n+use rustc_middle::ty::{\n+    self, subst::SubstsRef, EarlyBinder, ReprOptions, Ty, TyCtxt, TypeVisitable,\n+};\n+use rustc_session::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n+use rustc_span::symbol::Symbol;\n+use rustc_span::DUMMY_SP;\n+use rustc_target::abi::*;\n+\n+use std::cmp::{self, Ordering};\n+use std::iter;\n+use std::num::NonZeroUsize;\n+use std::ops::Bound;\n+\n+use rand::{seq::SliceRandom, SeedableRng};\n+use rand_xoshiro::Xoshiro128StarStar;\n+\n+use crate::layout_sanity_check::sanity_check_layout;\n+\n+pub fn provide(providers: &mut ty::query::Providers) {\n+    *providers = ty::query::Providers { layout_of, ..*providers };\n+}\n+\n+#[instrument(skip(tcx, query), level = \"debug\")]\n+fn layout_of<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+) -> Result<TyAndLayout<'tcx>, LayoutError<'tcx>> {\n+    let (param_env, ty) = query.into_parts();\n+    debug!(?ty);\n+\n+    let param_env = param_env.with_reveal_all_normalized(tcx);\n+    let unnormalized_ty = ty;\n+\n+    // FIXME: We might want to have two different versions of `layout_of`:\n+    // One that can be called after typecheck has completed and can use\n+    // `normalize_erasing_regions` here and another one that can be called\n+    // before typecheck has completed and uses `try_normalize_erasing_regions`.\n+    let ty = match tcx.try_normalize_erasing_regions(param_env, ty) {\n+        Ok(t) => t,\n+        Err(normalization_error) => {\n+            return Err(LayoutError::NormalizationFailure(ty, normalization_error));\n+        }\n+    };\n+\n+    if ty != unnormalized_ty {\n+        // Ensure this layout is also cached for the normalized type.\n+        return tcx.layout_of(param_env.and(ty));\n+    }\n+\n+    let cx = LayoutCx { tcx, param_env };\n+\n+    let layout = layout_of_uncached(&cx, ty)?;\n+    let layout = TyAndLayout { ty, layout };\n+\n+    record_layout_for_printing(&cx, layout);\n+\n+    sanity_check_layout(&cx, &layout);\n+\n+    Ok(layout)\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum StructKind {\n+    /// A tuple, closure, or univariant which cannot be coerced to unsized.\n+    AlwaysSized,\n+    /// A univariant, the last field of which may be coerced to unsized.\n+    MaybeUnsized,\n+    /// A univariant, but with a prefix of an arbitrary size & alignment (e.g., enum tag).\n+    Prefixed(Size, Align),\n+}\n+\n+// Invert a bijective mapping, i.e. `invert(map)[y] = x` if `map[x] = y`.\n+// This is used to go between `memory_index` (source field order to memory order)\n+// and `inverse_memory_index` (memory order to source field order).\n+// See also `FieldsShape::Arbitrary::memory_index` for more details.\n+// FIXME(eddyb) build a better abstraction for permutations, if possible.\n+fn invert_mapping(map: &[u32]) -> Vec<u32> {\n+    let mut inverse = vec![0; map.len()];\n+    for i in 0..map.len() {\n+        inverse[map[i] as usize] = i as u32;\n+    }\n+    inverse\n+}\n+\n+fn scalar_pair<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, a: Scalar, b: Scalar) -> LayoutS<'tcx> {\n+    let dl = cx.data_layout();\n+    let b_align = b.align(dl);\n+    let align = a.align(dl).max(b_align).max(dl.aggregate_align);\n+    let b_offset = a.size(dl).align_to(b_align.abi);\n+    let size = (b_offset + b.size(dl)).align_to(align.abi);\n+\n+    // HACK(nox): We iter on `b` and then `a` because `max_by_key`\n+    // returns the last maximum.\n+    let largest_niche = Niche::from_scalar(dl, b_offset, b)\n+        .into_iter()\n+        .chain(Niche::from_scalar(dl, Size::ZERO, a))\n+        .max_by_key(|niche| niche.available(dl));\n+\n+    LayoutS {\n+        variants: Variants::Single { index: VariantIdx::new(0) },\n+        fields: FieldsShape::Arbitrary {\n+            offsets: vec![Size::ZERO, b_offset],\n+            memory_index: vec![0, 1],\n+        },\n+        abi: Abi::ScalarPair(a, b),\n+        largest_niche,\n+        align,\n+        size,\n+    }\n+}\n+\n+fn univariant_uninterned<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    ty: Ty<'tcx>,\n+    fields: &[TyAndLayout<'_>],\n+    repr: &ReprOptions,\n+    kind: StructKind,\n+) -> Result<LayoutS<'tcx>, LayoutError<'tcx>> {\n+    let dl = cx.data_layout();\n+    let pack = repr.pack;\n+    if pack.is_some() && repr.align.is_some() {\n+        cx.tcx.sess.delay_span_bug(DUMMY_SP, \"struct cannot be packed and aligned\");\n+        return Err(LayoutError::Unknown(ty));\n+    }\n+\n+    let mut align = if pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n+\n+    let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n+\n+    let optimize = !repr.inhibit_struct_field_reordering_opt();\n+    if optimize {\n+        let end = if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n+        let optimizing = &mut inverse_memory_index[..end];\n+        let field_align = |f: &TyAndLayout<'_>| {\n+            if let Some(pack) = pack { f.align.abi.min(pack) } else { f.align.abi }\n+        };\n+\n+        // If `-Z randomize-layout` was enabled for the type definition we can shuffle\n+        // the field ordering to try and catch some code making assumptions about layouts\n+        // we don't guarantee\n+        if repr.can_randomize_type_layout() {\n+            // `ReprOptions.layout_seed` is a deterministic seed that we can use to\n+            // randomize field ordering with\n+            let mut rng = Xoshiro128StarStar::seed_from_u64(repr.field_shuffle_seed);\n+\n+            // Shuffle the ordering of the fields\n+            optimizing.shuffle(&mut rng);\n+\n+            // Otherwise we just leave things alone and actually optimize the type's fields\n+        } else {\n+            match kind {\n+                StructKind::AlwaysSized | StructKind::MaybeUnsized => {\n+                    optimizing.sort_by_key(|&x| {\n+                        // Place ZSTs first to avoid \"interesting offsets\",\n+                        // especially with only one or two non-ZST fields.\n+                        let f = &fields[x as usize];\n+                        (!f.is_zst(), cmp::Reverse(field_align(f)))\n+                    });\n+                }\n+\n+                StructKind::Prefixed(..) => {\n+                    // Sort in ascending alignment so that the layout stays optimal\n+                    // regardless of the prefix\n+                    optimizing.sort_by_key(|&x| field_align(&fields[x as usize]));\n+                }\n+            }\n+\n+            // FIXME(Kixiron): We can always shuffle fields within a given alignment class\n+            //                 regardless of the status of `-Z randomize-layout`\n+        }\n+    }\n+\n+    // inverse_memory_index holds field indices by increasing memory offset.\n+    // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n+    // We now write field offsets to the corresponding offset slot;\n+    // field 5 with offset 0 puts 0 in offsets[5].\n+    // At the bottom of this function, we invert `inverse_memory_index` to\n+    // produce `memory_index` (see `invert_mapping`).\n+\n+    let mut sized = true;\n+    let mut offsets = vec![Size::ZERO; fields.len()];\n+    let mut offset = Size::ZERO;\n+    let mut largest_niche = None;\n+    let mut largest_niche_available = 0;\n+\n+    if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n+        let prefix_align =\n+            if let Some(pack) = pack { prefix_align.min(pack) } else { prefix_align };\n+        align = align.max(AbiAndPrefAlign::new(prefix_align));\n+        offset = prefix_size.align_to(prefix_align);\n+    }\n+\n+    for &i in &inverse_memory_index {\n+        let field = fields[i as usize];\n+        if !sized {\n+            cx.tcx.sess.delay_span_bug(\n+                DUMMY_SP,\n+                &format!(\n+                    \"univariant: field #{} of `{}` comes after unsized field\",\n+                    offsets.len(),\n+                    ty\n+                ),\n+            );\n+        }\n+\n+        if field.is_unsized() {\n+            sized = false;\n+        }\n+\n+        // Invariant: offset < dl.obj_size_bound() <= 1<<61\n+        let field_align = if let Some(pack) = pack {\n+            field.align.min(AbiAndPrefAlign::new(pack))\n+        } else {\n+            field.align\n+        };\n+        offset = offset.align_to(field_align.abi);\n+        align = align.max(field_align);\n+\n+        debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n+        offsets[i as usize] = offset;\n+\n+        if let Some(mut niche) = field.largest_niche {\n+            let available = niche.available(dl);\n+            if available > largest_niche_available {\n+                largest_niche_available = available;\n+                niche.offset += offset;\n+                largest_niche = Some(niche);\n+            }\n+        }\n+\n+        offset = offset.checked_add(field.size, dl).ok_or(LayoutError::SizeOverflow(ty))?;\n+    }\n+\n+    if let Some(repr_align) = repr.align {\n+        align = align.max(AbiAndPrefAlign::new(repr_align));\n+    }\n+\n+    debug!(\"univariant min_size: {:?}\", offset);\n+    let min_size = offset;\n+\n+    // As stated above, inverse_memory_index holds field indices by increasing offset.\n+    // This makes it an already-sorted view of the offsets vec.\n+    // To invert it, consider:\n+    // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n+    // Field 5 would be the first element, so memory_index is i:\n+    // Note: if we didn't optimize, it's already right.\n+\n+    let memory_index =\n+        if optimize { invert_mapping(&inverse_memory_index) } else { inverse_memory_index };\n+\n+    let size = min_size.align_to(align.abi);\n+    let mut abi = Abi::Aggregate { sized };\n+\n+    // Unpack newtype ABIs and find scalar pairs.\n+    if sized && size.bytes() > 0 {\n+        // All other fields must be ZSTs.\n+        let mut non_zst_fields = fields.iter().enumerate().filter(|&(_, f)| !f.is_zst());\n+\n+        match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n+            // We have exactly one non-ZST field.\n+            (Some((i, field)), None, None) => {\n+                // Field fills the struct and it has a scalar or scalar pair ABI.\n+                if offsets[i].bytes() == 0 && align.abi == field.align.abi && size == field.size {\n+                    match field.abi {\n+                        // For plain scalars, or vectors of them, we can't unpack\n+                        // newtypes for `#[repr(C)]`, as that affects C ABIs.\n+                        Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n+                            abi = field.abi;\n+                        }\n+                        // But scalar pairs are Rust-specific and get\n+                        // treated as aggregates by C ABIs anyway.\n+                        Abi::ScalarPair(..) => {\n+                            abi = field.abi;\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+\n+            // Two non-ZST fields, and they're both scalars.\n+            (Some((i, a)), Some((j, b)), None) => {\n+                match (a.abi, b.abi) {\n+                    (Abi::Scalar(a), Abi::Scalar(b)) => {\n+                        // Order by the memory placement, not source order.\n+                        let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n+                            ((i, a), (j, b))\n+                        } else {\n+                            ((j, b), (i, a))\n+                        };\n+                        let pair = scalar_pair(cx, a, b);\n+                        let pair_offsets = match pair.fields {\n+                            FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n+                                assert_eq!(memory_index, &[0, 1]);\n+                                offsets\n+                            }\n+                            _ => bug!(),\n+                        };\n+                        if offsets[i] == pair_offsets[0]\n+                            && offsets[j] == pair_offsets[1]\n+                            && align == pair.align\n+                            && size == pair.size\n+                        {\n+                            // We can use `ScalarPair` only when it matches our\n+                            // already computed layout (including `#[repr(C)]`).\n+                            abi = pair.abi;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+\n+    if fields.iter().any(|f| f.abi.is_uninhabited()) {\n+        abi = Abi::Uninhabited;\n+    }\n+\n+    Ok(LayoutS {\n+        variants: Variants::Single { index: VariantIdx::new(0) },\n+        fields: FieldsShape::Arbitrary { offsets, memory_index },\n+        abi,\n+        largest_niche,\n+        align,\n+        size,\n+    })\n+}\n+\n+fn layout_of_uncached<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    ty: Ty<'tcx>,\n+) -> Result<Layout<'tcx>, LayoutError<'tcx>> {\n+    let tcx = cx.tcx;\n+    let param_env = cx.param_env;\n+    let dl = cx.data_layout();\n+    let scalar_unit = |value: Primitive| {\n+        let size = value.size(dl);\n+        assert!(size.bits() <= 128);\n+        Scalar::Initialized { value, valid_range: WrappingRange::full(size) }\n+    };\n+    let scalar = |value: Primitive| tcx.intern_layout(LayoutS::scalar(cx, scalar_unit(value)));\n+\n+    let univariant = |fields: &[TyAndLayout<'_>], repr: &ReprOptions, kind| {\n+        Ok(tcx.intern_layout(univariant_uninterned(cx, ty, fields, repr, kind)?))\n+    };\n+    debug_assert!(!ty.has_infer_types_or_consts());\n+\n+    Ok(match *ty.kind() {\n+        // Basic scalars.\n+        ty::Bool => tcx.intern_layout(LayoutS::scalar(\n+            cx,\n+            Scalar::Initialized {\n+                value: Int(I8, false),\n+                valid_range: WrappingRange { start: 0, end: 1 },\n+            },\n+        )),\n+        ty::Char => tcx.intern_layout(LayoutS::scalar(\n+            cx,\n+            Scalar::Initialized {\n+                value: Int(I32, false),\n+                valid_range: WrappingRange { start: 0, end: 0x10FFFF },\n+            },\n+        )),\n+        ty::Int(ity) => scalar(Int(Integer::from_int_ty(dl, ity), true)),\n+        ty::Uint(ity) => scalar(Int(Integer::from_uint_ty(dl, ity), false)),\n+        ty::Float(fty) => scalar(match fty {\n+            ty::FloatTy::F32 => F32,\n+            ty::FloatTy::F64 => F64,\n+        }),\n+        ty::FnPtr(_) => {\n+            let mut ptr = scalar_unit(Pointer);\n+            ptr.valid_range_mut().start = 1;\n+            tcx.intern_layout(LayoutS::scalar(cx, ptr))\n+        }\n+\n+        // The never type.\n+        ty::Never => tcx.intern_layout(LayoutS {\n+            variants: Variants::Single { index: VariantIdx::new(0) },\n+            fields: FieldsShape::Primitive,\n+            abi: Abi::Uninhabited,\n+            largest_niche: None,\n+            align: dl.i8_align,\n+            size: Size::ZERO,\n+        }),\n+\n+        // Potentially-wide pointers.\n+        ty::Ref(_, pointee, _) | ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+            let mut data_ptr = scalar_unit(Pointer);\n+            if !ty.is_unsafe_ptr() {\n+                data_ptr.valid_range_mut().start = 1;\n+            }\n+\n+            let pointee = tcx.normalize_erasing_regions(param_env, pointee);\n+            if pointee.is_sized(tcx.at(DUMMY_SP), param_env) {\n+                return Ok(tcx.intern_layout(LayoutS::scalar(cx, data_ptr)));\n+            }\n+\n+            let unsized_part = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n+            let metadata = match unsized_part.kind() {\n+                ty::Foreign(..) => {\n+                    return Ok(tcx.intern_layout(LayoutS::scalar(cx, data_ptr)));\n+                }\n+                ty::Slice(_) | ty::Str => scalar_unit(Int(dl.ptr_sized_integer(), false)),\n+                ty::Dynamic(..) => {\n+                    let mut vtable = scalar_unit(Pointer);\n+                    vtable.valid_range_mut().start = 1;\n+                    vtable\n+                }\n+                _ => return Err(LayoutError::Unknown(unsized_part)),\n+            };\n+\n+            // Effectively a (ptr, meta) tuple.\n+            tcx.intern_layout(scalar_pair(cx, data_ptr, metadata))\n+        }\n+\n+        ty::Dynamic(_, _, ty::DynStar) => {\n+            let mut data = scalar_unit(Int(dl.ptr_sized_integer(), false));\n+            data.valid_range_mut().start = 0;\n+            let mut vtable = scalar_unit(Pointer);\n+            vtable.valid_range_mut().start = 1;\n+            tcx.intern_layout(scalar_pair(cx, data, vtable))\n+        }\n+\n+        // Arrays and slices.\n+        ty::Array(element, mut count) => {\n+            if count.has_projections() {\n+                count = tcx.normalize_erasing_regions(param_env, count);\n+                if count.has_projections() {\n+                    return Err(LayoutError::Unknown(ty));\n+                }\n+            }\n+\n+            let count = count.try_eval_usize(tcx, param_env).ok_or(LayoutError::Unknown(ty))?;\n+            let element = cx.layout_of(element)?;\n+            let size = element.size.checked_mul(count, dl).ok_or(LayoutError::SizeOverflow(ty))?;\n+\n+            let abi = if count != 0 && tcx.conservative_is_privately_uninhabited(param_env.and(ty))\n+            {\n+                Abi::Uninhabited\n+            } else {\n+                Abi::Aggregate { sized: true }\n+            };\n+\n+            let largest_niche = if count != 0 { element.largest_niche } else { None };\n+\n+            tcx.intern_layout(LayoutS {\n+                variants: Variants::Single { index: VariantIdx::new(0) },\n+                fields: FieldsShape::Array { stride: element.size, count },\n+                abi,\n+                largest_niche,\n+                align: element.align,\n+                size,\n+            })\n+        }\n+        ty::Slice(element) => {\n+            let element = cx.layout_of(element)?;\n+            tcx.intern_layout(LayoutS {\n+                variants: Variants::Single { index: VariantIdx::new(0) },\n+                fields: FieldsShape::Array { stride: element.size, count: 0 },\n+                abi: Abi::Aggregate { sized: false },\n+                largest_niche: None,\n+                align: element.align,\n+                size: Size::ZERO,\n+            })\n+        }\n+        ty::Str => tcx.intern_layout(LayoutS {\n+            variants: Variants::Single { index: VariantIdx::new(0) },\n+            fields: FieldsShape::Array { stride: Size::from_bytes(1), count: 0 },\n+            abi: Abi::Aggregate { sized: false },\n+            largest_niche: None,\n+            align: dl.i8_align,\n+            size: Size::ZERO,\n+        }),\n+\n+        // Odd unit types.\n+        ty::FnDef(..) => univariant(&[], &ReprOptions::default(), StructKind::AlwaysSized)?,\n+        ty::Dynamic(_, _, ty::Dyn) | ty::Foreign(..) => {\n+            let mut unit = univariant_uninterned(\n+                cx,\n+                ty,\n+                &[],\n+                &ReprOptions::default(),\n+                StructKind::AlwaysSized,\n+            )?;\n+            match unit.abi {\n+                Abi::Aggregate { ref mut sized } => *sized = false,\n+                _ => bug!(),\n+            }\n+            tcx.intern_layout(unit)\n+        }\n+\n+        ty::Generator(def_id, substs, _) => generator_layout(cx, ty, def_id, substs)?,\n+\n+        ty::Closure(_, ref substs) => {\n+            let tys = substs.as_closure().upvar_tys();\n+            univariant(\n+                &tys.map(|ty| cx.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+                &ReprOptions::default(),\n+                StructKind::AlwaysSized,\n+            )?\n+        }\n+\n+        ty::Tuple(tys) => {\n+            let kind =\n+                if tys.len() == 0 { StructKind::AlwaysSized } else { StructKind::MaybeUnsized };\n+\n+            univariant(\n+                &tys.iter().map(|k| cx.layout_of(k)).collect::<Result<Vec<_>, _>>()?,\n+                &ReprOptions::default(),\n+                kind,\n+            )?\n+        }\n+\n+        // SIMD vector types.\n+        ty::Adt(def, substs) if def.repr().simd() => {\n+            if !def.is_struct() {\n+                // Should have yielded E0517 by now.\n+                tcx.sess.delay_span_bug(\n+                    DUMMY_SP,\n+                    \"#[repr(simd)] was applied to an ADT that is not a struct\",\n+                );\n+                return Err(LayoutError::Unknown(ty));\n+            }\n+\n+            // Supported SIMD vectors are homogeneous ADTs with at least one field:\n+            //\n+            // * #[repr(simd)] struct S(T, T, T, T);\n+            // * #[repr(simd)] struct S { x: T, y: T, z: T, w: T }\n+            // * #[repr(simd)] struct S([T; 4])\n+            //\n+            // where T is a primitive scalar (integer/float/pointer).\n+\n+            // SIMD vectors with zero fields are not supported.\n+            // (should be caught by typeck)\n+            if def.non_enum_variant().fields.is_empty() {\n+                tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` of zero length\", ty));\n+            }\n+\n+            // Type of the first ADT field:\n+            let f0_ty = def.non_enum_variant().fields[0].ty(tcx, substs);\n+\n+            // Heterogeneous SIMD vectors are not supported:\n+            // (should be caught by typeck)\n+            for fi in &def.non_enum_variant().fields {\n+                if fi.ty(tcx, substs) != f0_ty {\n+                    tcx.sess.fatal(&format!(\"monomorphising heterogeneous SIMD type `{}`\", ty));\n+                }\n+            }\n+\n+            // The element type and number of elements of the SIMD vector\n+            // are obtained from:\n+            //\n+            // * the element type and length of the single array field, if\n+            // the first field is of array type, or\n+            //\n+            // * the homogeneous field type and the number of fields.\n+            let (e_ty, e_len, is_array) = if let ty::Array(e_ty, _) = f0_ty.kind() {\n+                // First ADT field is an array:\n+\n+                // SIMD vectors with multiple array fields are not supported:\n+                // (should be caught by typeck)\n+                if def.non_enum_variant().fields.len() != 1 {\n+                    tcx.sess.fatal(&format!(\n+                        \"monomorphising SIMD type `{}` with more than one array field\",\n+                        ty\n+                    ));\n+                }\n+\n+                // Extract the number of elements from the layout of the array field:\n+                let FieldsShape::Array { count, .. } = cx.layout_of(f0_ty)?.layout.fields() else {\n+                        return Err(LayoutError::Unknown(ty));\n+                    };\n+\n+                (*e_ty, *count, true)\n+            } else {\n+                // First ADT field is not an array:\n+                (f0_ty, def.non_enum_variant().fields.len() as _, false)\n+            };\n+\n+            // SIMD vectors of zero length are not supported.\n+            // Additionally, lengths are capped at 2^16 as a fixed maximum backends must\n+            // support.\n+            //\n+            // Can't be caught in typeck if the array length is generic.\n+            if e_len == 0 {\n+                tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` of zero length\", ty));\n+            } else if e_len > MAX_SIMD_LANES {\n+                tcx.sess.fatal(&format!(\n+                    \"monomorphising SIMD type `{}` of length greater than {}\",\n+                    ty, MAX_SIMD_LANES,\n+                ));\n+            }\n+\n+            // Compute the ABI of the element type:\n+            let e_ly = cx.layout_of(e_ty)?;\n+            let Abi::Scalar(e_abi) = e_ly.abi else {\n+                    // This error isn't caught in typeck, e.g., if\n+                    // the element type of the vector is generic.\n+                    tcx.sess.fatal(&format!(\n+                        \"monomorphising SIMD type `{}` with a non-primitive-scalar \\\n+                        (integer/float/pointer) element type `{}`\",\n+                        ty, e_ty\n+                    ))\n+                };\n+\n+            // Compute the size and alignment of the vector:\n+            let size = e_ly.size.checked_mul(e_len, dl).ok_or(LayoutError::SizeOverflow(ty))?;\n+            let align = dl.vector_align(size);\n+            let size = size.align_to(align.abi);\n+\n+            // Compute the placement of the vector fields:\n+            let fields = if is_array {\n+                FieldsShape::Arbitrary { offsets: vec![Size::ZERO], memory_index: vec![0] }\n+            } else {\n+                FieldsShape::Array { stride: e_ly.size, count: e_len }\n+            };\n+\n+            tcx.intern_layout(LayoutS {\n+                variants: Variants::Single { index: VariantIdx::new(0) },\n+                fields,\n+                abi: Abi::Vector { element: e_abi, count: e_len },\n+                largest_niche: e_ly.largest_niche,\n+                size,\n+                align,\n+            })\n+        }\n+\n+        // ADTs.\n+        ty::Adt(def, substs) => {\n+            // Cache the field layouts.\n+            let variants = def\n+                .variants()\n+                .iter()\n+                .map(|v| {\n+                    v.fields\n+                        .iter()\n+                        .map(|field| cx.layout_of(field.ty(tcx, substs)))\n+                        .collect::<Result<Vec<_>, _>>()\n+                })\n+                .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n+\n+            if def.is_union() {\n+                if def.repr().pack.is_some() && def.repr().align.is_some() {\n+                    cx.tcx.sess.delay_span_bug(\n+                        tcx.def_span(def.did()),\n+                        \"union cannot be packed and aligned\",\n+                    );\n+                    return Err(LayoutError::Unknown(ty));\n+                }\n+\n+                let mut align =\n+                    if def.repr().pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n+\n+                if let Some(repr_align) = def.repr().align {\n+                    align = align.max(AbiAndPrefAlign::new(repr_align));\n+                }\n+\n+                let optimize = !def.repr().inhibit_union_abi_opt();\n+                let mut size = Size::ZERO;\n+                let mut abi = Abi::Aggregate { sized: true };\n+                let index = VariantIdx::new(0);\n+                for field in &variants[index] {\n+                    assert!(!field.is_unsized());\n+                    align = align.max(field.align);\n+\n+                    // If all non-ZST fields have the same ABI, forward this ABI\n+                    if optimize && !field.is_zst() {\n+                        // Discard valid range information and allow undef\n+                        let field_abi = match field.abi {\n+                            Abi::Scalar(x) => Abi::Scalar(x.to_union()),\n+                            Abi::ScalarPair(x, y) => Abi::ScalarPair(x.to_union(), y.to_union()),\n+                            Abi::Vector { element: x, count } => {\n+                                Abi::Vector { element: x.to_union(), count }\n+                            }\n+                            Abi::Uninhabited | Abi::Aggregate { .. } => {\n+                                Abi::Aggregate { sized: true }\n+                            }\n+                        };\n+\n+                        if size == Size::ZERO {\n+                            // first non ZST: initialize 'abi'\n+                            abi = field_abi;\n+                        } else if abi != field_abi {\n+                            // different fields have different ABI: reset to Aggregate\n+                            abi = Abi::Aggregate { sized: true };\n+                        }\n+                    }\n+\n+                    size = cmp::max(size, field.size);\n+                }\n+\n+                if let Some(pack) = def.repr().pack {\n+                    align = align.min(AbiAndPrefAlign::new(pack));\n+                }\n+\n+                return Ok(tcx.intern_layout(LayoutS {\n+                    variants: Variants::Single { index },\n+                    fields: FieldsShape::Union(\n+                        NonZeroUsize::new(variants[index].len()).ok_or(LayoutError::Unknown(ty))?,\n+                    ),\n+                    abi,\n+                    largest_niche: None,\n+                    align,\n+                    size: size.align_to(align.abi),\n+                }));\n+            }\n+\n+            // A variant is absent if it's uninhabited and only has ZST fields.\n+            // Present uninhabited variants only require space for their fields,\n+            // but *not* an encoding of the discriminant (e.g., a tag value).\n+            // See issue #49298 for more details on the need to leave space\n+            // for non-ZST uninhabited data (mostly partial initialization).\n+            let absent = |fields: &[TyAndLayout<'_>]| {\n+                let uninhabited = fields.iter().any(|f| f.abi.is_uninhabited());\n+                let is_zst = fields.iter().all(|f| f.is_zst());\n+                uninhabited && is_zst\n+            };\n+            let (present_first, present_second) = {\n+                let mut present_variants = variants\n+                    .iter_enumerated()\n+                    .filter_map(|(i, v)| if absent(v) { None } else { Some(i) });\n+                (present_variants.next(), present_variants.next())\n+            };\n+            let present_first = match present_first {\n+                Some(present_first) => present_first,\n+                // Uninhabited because it has no variants, or only absent ones.\n+                None if def.is_enum() => {\n+                    return Ok(tcx.layout_of(param_env.and(tcx.types.never))?.layout);\n+                }\n+                // If it's a struct, still compute a layout so that we can still compute the\n+                // field offsets.\n+                None => VariantIdx::new(0),\n+            };\n+\n+            let is_struct = !def.is_enum() ||\n+                    // Only one variant is present.\n+                    (present_second.is_none() &&\n+                        // Representation optimizations are allowed.\n+                        !def.repr().inhibit_enum_layout_opt());\n+            if is_struct {\n+                // Struct, or univariant enum equivalent to a struct.\n+                // (Typechecking will reject discriminant-sizing attrs.)\n+\n+                let v = present_first;\n+                let kind = if def.is_enum() || variants[v].is_empty() {\n+                    StructKind::AlwaysSized\n+                } else {\n+                    let param_env = tcx.param_env(def.did());\n+                    let last_field = def.variant(v).fields.last().unwrap();\n+                    let always_sized =\n+                        tcx.type_of(last_field.did).is_sized(tcx.at(DUMMY_SP), param_env);\n+                    if !always_sized { StructKind::MaybeUnsized } else { StructKind::AlwaysSized }\n+                };\n+\n+                let mut st = univariant_uninterned(cx, ty, &variants[v], &def.repr(), kind)?;\n+                st.variants = Variants::Single { index: v };\n+\n+                if def.is_unsafe_cell() {\n+                    let hide_niches = |scalar: &mut _| match scalar {\n+                        Scalar::Initialized { value, valid_range } => {\n+                            *valid_range = WrappingRange::full(value.size(dl))\n+                        }\n+                        // Already doesn't have any niches\n+                        Scalar::Union { .. } => {}\n+                    };\n+                    match &mut st.abi {\n+                        Abi::Uninhabited => {}\n+                        Abi::Scalar(scalar) => hide_niches(scalar),\n+                        Abi::ScalarPair(a, b) => {\n+                            hide_niches(a);\n+                            hide_niches(b);\n+                        }\n+                        Abi::Vector { element, count: _ } => hide_niches(element),\n+                        Abi::Aggregate { sized: _ } => {}\n+                    }\n+                    st.largest_niche = None;\n+                    return Ok(tcx.intern_layout(st));\n+                }\n+\n+                let (start, end) = cx.tcx.layout_scalar_valid_range(def.did());\n+                match st.abi {\n+                    Abi::Scalar(ref mut scalar) | Abi::ScalarPair(ref mut scalar, _) => {\n+                        // the asserts ensure that we are not using the\n+                        // `#[rustc_layout_scalar_valid_range(n)]`\n+                        // attribute to widen the range of anything as that would probably\n+                        // result in UB somewhere\n+                        // FIXME(eddyb) the asserts are probably not needed,\n+                        // as larger validity ranges would result in missed\n+                        // optimizations, *not* wrongly assuming the inner\n+                        // value is valid. e.g. unions enlarge validity ranges,\n+                        // because the values may be uninitialized.\n+                        if let Bound::Included(start) = start {\n+                            // FIXME(eddyb) this might be incorrect - it doesn't\n+                            // account for wrap-around (end < start) ranges.\n+                            let valid_range = scalar.valid_range_mut();\n+                            assert!(valid_range.start <= start);\n+                            valid_range.start = start;\n+                        }\n+                        if let Bound::Included(end) = end {\n+                            // FIXME(eddyb) this might be incorrect - it doesn't\n+                            // account for wrap-around (end < start) ranges.\n+                            let valid_range = scalar.valid_range_mut();\n+                            assert!(valid_range.end >= end);\n+                            valid_range.end = end;\n+                        }\n+\n+                        // Update `largest_niche` if we have introduced a larger niche.\n+                        let niche = Niche::from_scalar(dl, Size::ZERO, *scalar);\n+                        if let Some(niche) = niche {\n+                            match st.largest_niche {\n+                                Some(largest_niche) => {\n+                                    // Replace the existing niche even if they're equal,\n+                                    // because this one is at a lower offset.\n+                                    if largest_niche.available(dl) <= niche.available(dl) {\n+                                        st.largest_niche = Some(niche);\n+                                    }\n+                                }\n+                                None => st.largest_niche = Some(niche),\n+                            }\n+                        }\n+                    }\n+                    _ => assert!(\n+                        start == Bound::Unbounded && end == Bound::Unbounded,\n+                        \"nonscalar layout for layout_scalar_valid_range type {:?}: {:#?}\",\n+                        def,\n+                        st,\n+                    ),\n+                }\n+\n+                return Ok(tcx.intern_layout(st));\n+            }\n+\n+            // At this point, we have handled all unions and\n+            // structs. (We have also handled univariant enums\n+            // that allow representation optimization.)\n+            assert!(def.is_enum());\n+\n+            // Until we've decided whether to use the tagged or\n+            // niche filling LayoutS, we don't want to intern the\n+            // variant layouts, so we can't store them in the\n+            // overall LayoutS. Store the overall LayoutS\n+            // and the variant LayoutSs here until then.\n+            struct TmpLayout<'tcx> {\n+                layout: LayoutS<'tcx>,\n+                variants: IndexVec<VariantIdx, LayoutS<'tcx>>,\n+            }\n+\n+            let calculate_niche_filling_layout =\n+                || -> Result<Option<TmpLayout<'tcx>>, LayoutError<'tcx>> {\n+                    // The current code for niche-filling relies on variant indices\n+                    // instead of actual discriminants, so enums with\n+                    // explicit discriminants (RFC #2363) would misbehave.\n+                    if def.repr().inhibit_enum_layout_opt()\n+                        || def\n+                            .variants()\n+                            .iter_enumerated()\n+                            .any(|(i, v)| v.discr != ty::VariantDiscr::Relative(i.as_u32()))\n+                    {\n+                        return Ok(None);\n+                    }\n+\n+                    if variants.len() < 2 {\n+                        return Ok(None);\n+                    }\n+\n+                    let mut align = dl.aggregate_align;\n+                    let mut variant_layouts = variants\n+                        .iter_enumerated()\n+                        .map(|(j, v)| {\n+                            let mut st = univariant_uninterned(\n+                                cx,\n+                                ty,\n+                                v,\n+                                &def.repr(),\n+                                StructKind::AlwaysSized,\n+                            )?;\n+                            st.variants = Variants::Single { index: j };\n+\n+                            align = align.max(st.align);\n+\n+                            Ok(st)\n+                        })\n+                        .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n+\n+                    let largest_variant_index = match variant_layouts\n+                        .iter_enumerated()\n+                        .max_by_key(|(_i, layout)| layout.size.bytes())\n+                        .map(|(i, _layout)| i)\n+                    {\n+                        None => return Ok(None),\n+                        Some(i) => i,\n+                    };\n+\n+                    let all_indices = VariantIdx::new(0)..=VariantIdx::new(variants.len() - 1);\n+                    let needs_disc = |index: VariantIdx| {\n+                        index != largest_variant_index && !absent(&variants[index])\n+                    };\n+                    let niche_variants = all_indices.clone().find(|v| needs_disc(*v)).unwrap()\n+                        ..=all_indices.rev().find(|v| needs_disc(*v)).unwrap();\n+\n+                    let count = niche_variants.size_hint().1.unwrap() as u128;\n+\n+                    // Find the field with the largest niche\n+                    let (field_index, niche, (niche_start, niche_scalar)) = match variants\n+                        [largest_variant_index]\n+                        .iter()\n+                        .enumerate()\n+                        .filter_map(|(j, field)| Some((j, field.largest_niche?)))\n+                        .max_by_key(|(_, niche)| niche.available(dl))\n+                        .and_then(|(j, niche)| Some((j, niche, niche.reserve(cx, count)?)))\n+                    {\n+                        None => return Ok(None),\n+                        Some(x) => x,\n+                    };\n+\n+                    let niche_offset = niche.offset\n+                        + variant_layouts[largest_variant_index].fields.offset(field_index);\n+                    let niche_size = niche.value.size(dl);\n+                    let size = variant_layouts[largest_variant_index].size.align_to(align.abi);\n+\n+                    let all_variants_fit =\n+                        variant_layouts.iter_enumerated_mut().all(|(i, layout)| {\n+                            if i == largest_variant_index {\n+                                return true;\n+                            }\n+\n+                            layout.largest_niche = None;\n+\n+                            if layout.size <= niche_offset {\n+                                // This variant will fit before the niche.\n+                                return true;\n+                            }\n+\n+                            // Determine if it'll fit after the niche.\n+                            let this_align = layout.align.abi;\n+                            let this_offset = (niche_offset + niche_size).align_to(this_align);\n+\n+                            if this_offset + layout.size > size {\n+                                return false;\n+                            }\n+\n+                            // It'll fit, but we need to make some adjustments.\n+                            match layout.fields {\n+                                FieldsShape::Arbitrary { ref mut offsets, .. } => {\n+                                    for (j, offset) in offsets.iter_mut().enumerate() {\n+                                        if !variants[i][j].is_zst() {\n+                                            *offset += this_offset;\n+                                        }\n+                                    }\n+                                }\n+                                _ => {\n+                                    panic!(\"Layout of fields should be Arbitrary for variants\")\n+                                }\n+                            }\n+\n+                            // It can't be a Scalar or ScalarPair because the offset isn't 0.\n+                            if !layout.abi.is_uninhabited() {\n+                                layout.abi = Abi::Aggregate { sized: true };\n+                            }\n+                            layout.size += this_offset;\n+\n+                            true\n+                        });\n+\n+                    if !all_variants_fit {\n+                        return Ok(None);\n+                    }\n+\n+                    let largest_niche = Niche::from_scalar(dl, niche_offset, niche_scalar);\n+\n+                    let others_zst = variant_layouts\n+                        .iter_enumerated()\n+                        .all(|(i, layout)| i == largest_variant_index || layout.size == Size::ZERO);\n+                    let same_size = size == variant_layouts[largest_variant_index].size;\n+                    let same_align = align == variant_layouts[largest_variant_index].align;\n+\n+                    let abi = if variant_layouts.iter().all(|v| v.abi.is_uninhabited()) {\n+                        Abi::Uninhabited\n+                    } else if same_size && same_align && others_zst {\n+                        match variant_layouts[largest_variant_index].abi {\n+                            // When the total alignment and size match, we can use the\n+                            // same ABI as the scalar variant with the reserved niche.\n+                            Abi::Scalar(_) => Abi::Scalar(niche_scalar),\n+                            Abi::ScalarPair(first, second) => {\n+                                // Only the niche is guaranteed to be initialised,\n+                                // so use union layouts for the other primitive.\n+                                if niche_offset == Size::ZERO {\n+                                    Abi::ScalarPair(niche_scalar, second.to_union())\n+                                } else {\n+                                    Abi::ScalarPair(first.to_union(), niche_scalar)\n+                                }\n+                            }\n+                            _ => Abi::Aggregate { sized: true },\n+                        }\n+                    } else {\n+                        Abi::Aggregate { sized: true }\n+                    };\n+\n+                    let layout = LayoutS {\n+                        variants: Variants::Multiple {\n+                            tag: niche_scalar,\n+                            tag_encoding: TagEncoding::Niche {\n+                                untagged_variant: largest_variant_index,\n+                                niche_variants,\n+                                niche_start,\n+                            },\n+                            tag_field: 0,\n+                            variants: IndexVec::new(),\n+                        },\n+                        fields: FieldsShape::Arbitrary {\n+                            offsets: vec![niche_offset],\n+                            memory_index: vec![0],\n+                        },\n+                        abi,\n+                        largest_niche,\n+                        size,\n+                        align,\n+                    };\n+\n+                    Ok(Some(TmpLayout { layout, variants: variant_layouts }))\n+                };\n+\n+            let niche_filling_layout = calculate_niche_filling_layout()?;\n+\n+            let (mut min, mut max) = (i128::MAX, i128::MIN);\n+            let discr_type = def.repr().discr_type();\n+            let bits = Integer::from_attr(cx, discr_type).size().bits();\n+            for (i, discr) in def.discriminants(tcx) {\n+                if variants[i].iter().any(|f| f.abi.is_uninhabited()) {\n+                    continue;\n+                }\n+                let mut x = discr.val as i128;\n+                if discr_type.is_signed() {\n+                    // sign extend the raw representation to be an i128\n+                    x = (x << (128 - bits)) >> (128 - bits);\n+                }\n+                if x < min {\n+                    min = x;\n+                }\n+                if x > max {\n+                    max = x;\n+                }\n+            }\n+            // We might have no inhabited variants, so pretend there's at least one.\n+            if (min, max) == (i128::MAX, i128::MIN) {\n+                min = 0;\n+                max = 0;\n+            }\n+            assert!(min <= max, \"discriminant range is {}...{}\", min, max);\n+            let (min_ity, signed) = Integer::repr_discr(tcx, ty, &def.repr(), min, max);\n+\n+            let mut align = dl.aggregate_align;\n+            let mut size = Size::ZERO;\n+\n+            // We're interested in the smallest alignment, so start large.\n+            let mut start_align = Align::from_bytes(256).unwrap();\n+            assert_eq!(Integer::for_align(dl, start_align), None);\n+\n+            // repr(C) on an enum tells us to make a (tag, union) layout,\n+            // so we need to grow the prefix alignment to be at least\n+            // the alignment of the union. (This value is used both for\n+            // determining the alignment of the overall enum, and the\n+            // determining the alignment of the payload after the tag.)\n+            let mut prefix_align = min_ity.align(dl).abi;\n+            if def.repr().c() {\n+                for fields in &variants {\n+                    for field in fields {\n+                        prefix_align = prefix_align.max(field.align.abi);\n+                    }\n+                }\n+            }\n+\n+            // Create the set of structs that represent each variant.\n+            let mut layout_variants = variants\n+                .iter_enumerated()\n+                .map(|(i, field_layouts)| {\n+                    let mut st = univariant_uninterned(\n+                        cx,\n+                        ty,\n+                        &field_layouts,\n+                        &def.repr(),\n+                        StructKind::Prefixed(min_ity.size(), prefix_align),\n+                    )?;\n+                    st.variants = Variants::Single { index: i };\n+                    // Find the first field we can't move later\n+                    // to make room for a larger discriminant.\n+                    for field in st.fields.index_by_increasing_offset().map(|j| field_layouts[j]) {\n+                        if !field.is_zst() || field.align.abi.bytes() != 1 {\n+                            start_align = start_align.min(field.align.abi);\n+                            break;\n+                        }\n+                    }\n+                    size = cmp::max(size, st.size);\n+                    align = align.max(st.align);\n+                    Ok(st)\n+                })\n+                .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n+\n+            // Align the maximum variant size to the largest alignment.\n+            size = size.align_to(align.abi);\n+\n+            if size.bytes() >= dl.obj_size_bound() {\n+                return Err(LayoutError::SizeOverflow(ty));\n+            }\n+\n+            let typeck_ity = Integer::from_attr(dl, def.repr().discr_type());\n+            if typeck_ity < min_ity {\n+                // It is a bug if Layout decided on a greater discriminant size than typeck for\n+                // some reason at this point (based on values discriminant can take on). Mostly\n+                // because this discriminant will be loaded, and then stored into variable of\n+                // type calculated by typeck. Consider such case (a bug): typeck decided on\n+                // byte-sized discriminant, but layout thinks we need a 16-bit to store all\n+                // discriminant values. That would be a bug, because then, in codegen, in order\n+                // to store this 16-bit discriminant into 8-bit sized temporary some of the\n+                // space necessary to represent would have to be discarded (or layout is wrong\n+                // on thinking it needs 16 bits)\n+                bug!(\n+                    \"layout decided on a larger discriminant type ({:?}) than typeck ({:?})\",\n+                    min_ity,\n+                    typeck_ity\n+                );\n+                // However, it is fine to make discr type however large (as an optimisation)\n+                // after this point \u2013 we\u2019ll just truncate the value we load in codegen.\n+            }\n+\n+            // Check to see if we should use a different type for the\n+            // discriminant. We can safely use a type with the same size\n+            // as the alignment of the first field of each variant.\n+            // We increase the size of the discriminant to avoid LLVM copying\n+            // padding when it doesn't need to. This normally causes unaligned\n+            // load/stores and excessive memcpy/memset operations. By using a\n+            // bigger integer size, LLVM can be sure about its contents and\n+            // won't be so conservative.\n+\n+            // Use the initial field alignment\n+            let mut ity = if def.repr().c() || def.repr().int.is_some() {\n+                min_ity\n+            } else {\n+                Integer::for_align(dl, start_align).unwrap_or(min_ity)\n+            };\n+\n+            // If the alignment is not larger than the chosen discriminant size,\n+            // don't use the alignment as the final size.\n+            if ity <= min_ity {\n+                ity = min_ity;\n+            } else {\n+                // Patch up the variants' first few fields.\n+                let old_ity_size = min_ity.size();\n+                let new_ity_size = ity.size();\n+                for variant in &mut layout_variants {\n+                    match variant.fields {\n+                        FieldsShape::Arbitrary { ref mut offsets, .. } => {\n+                            for i in offsets {\n+                                if *i <= old_ity_size {\n+                                    assert_eq!(*i, old_ity_size);\n+                                    *i = new_ity_size;\n+                                }\n+                            }\n+                            // We might be making the struct larger.\n+                            if variant.size <= old_ity_size {\n+                                variant.size = new_ity_size;\n+                            }\n+                        }\n+                        _ => bug!(),\n+                    }\n+                }\n+            }\n+\n+            let tag_mask = ity.size().unsigned_int_max();\n+            let tag = Scalar::Initialized {\n+                value: Int(ity, signed),\n+                valid_range: WrappingRange {\n+                    start: (min as u128 & tag_mask),\n+                    end: (max as u128 & tag_mask),\n+                },\n+            };\n+            let mut abi = Abi::Aggregate { sized: true };\n+\n+            if layout_variants.iter().all(|v| v.abi.is_uninhabited()) {\n+                abi = Abi::Uninhabited;\n+            } else if tag.size(dl) == size {\n+                // Make sure we only use scalar layout when the enum is entirely its\n+                // own tag (i.e. it has no padding nor any non-ZST variant fields).\n+                abi = Abi::Scalar(tag);\n+            } else {\n+                // Try to use a ScalarPair for all tagged enums.\n+                let mut common_prim = None;\n+                let mut common_prim_initialized_in_all_variants = true;\n+                for (field_layouts, layout_variant) in iter::zip(&variants, &layout_variants) {\n+                    let FieldsShape::Arbitrary { ref offsets, .. } = layout_variant.fields else {\n+                            bug!();\n+                        };\n+                    let mut fields = iter::zip(field_layouts, offsets).filter(|p| !p.0.is_zst());\n+                    let (field, offset) = match (fields.next(), fields.next()) {\n+                        (None, None) => {\n+                            common_prim_initialized_in_all_variants = false;\n+                            continue;\n+                        }\n+                        (Some(pair), None) => pair,\n+                        _ => {\n+                            common_prim = None;\n+                            break;\n+                        }\n+                    };\n+                    let prim = match field.abi {\n+                        Abi::Scalar(scalar) => {\n+                            common_prim_initialized_in_all_variants &=\n+                                matches!(scalar, Scalar::Initialized { .. });\n+                            scalar.primitive()\n+                        }\n+                        _ => {\n+                            common_prim = None;\n+                            break;\n+                        }\n+                    };\n+                    if let Some(pair) = common_prim {\n+                        // This is pretty conservative. We could go fancier\n+                        // by conflating things like i32 and u32, or even\n+                        // realising that (u8, u8) could just cohabit with\n+                        // u16 or even u32.\n+                        if pair != (prim, offset) {\n+                            common_prim = None;\n+                            break;\n+                        }\n+                    } else {\n+                        common_prim = Some((prim, offset));\n+                    }\n+                }\n+                if let Some((prim, offset)) = common_prim {\n+                    let prim_scalar = if common_prim_initialized_in_all_variants {\n+                        scalar_unit(prim)\n+                    } else {\n+                        // Common prim might be uninit.\n+                        Scalar::Union { value: prim }\n+                    };\n+                    let pair = scalar_pair(cx, tag, prim_scalar);\n+                    let pair_offsets = match pair.fields {\n+                        FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n+                            assert_eq!(memory_index, &[0, 1]);\n+                            offsets\n+                        }\n+                        _ => bug!(),\n+                    };\n+                    if pair_offsets[0] == Size::ZERO\n+                        && pair_offsets[1] == *offset\n+                        && align == pair.align\n+                        && size == pair.size\n+                    {\n+                        // We can use `ScalarPair` only when it matches our\n+                        // already computed layout (including `#[repr(C)]`).\n+                        abi = pair.abi;\n+                    }\n+                }\n+            }\n+\n+            // If we pick a \"clever\" (by-value) ABI, we might have to adjust the ABI of the\n+            // variants to ensure they are consistent. This is because a downcast is\n+            // semantically a NOP, and thus should not affect layout.\n+            if matches!(abi, Abi::Scalar(..) | Abi::ScalarPair(..)) {\n+                for variant in &mut layout_variants {\n+                    // We only do this for variants with fields; the others are not accessed anyway.\n+                    // Also do not overwrite any already existing \"clever\" ABIs.\n+                    if variant.fields.count() > 0 && matches!(variant.abi, Abi::Aggregate { .. }) {\n+                        variant.abi = abi;\n+                        // Also need to bump up the size and alignment, so that the entire value fits in here.\n+                        variant.size = cmp::max(variant.size, size);\n+                        variant.align.abi = cmp::max(variant.align.abi, align.abi);\n+                    }\n+                }\n+            }\n+\n+            let largest_niche = Niche::from_scalar(dl, Size::ZERO, tag);\n+\n+            let tagged_layout = LayoutS {\n+                variants: Variants::Multiple {\n+                    tag,\n+                    tag_encoding: TagEncoding::Direct,\n+                    tag_field: 0,\n+                    variants: IndexVec::new(),\n+                },\n+                fields: FieldsShape::Arbitrary { offsets: vec![Size::ZERO], memory_index: vec![0] },\n+                largest_niche,\n+                abi,\n+                align,\n+                size,\n+            };\n+\n+            let tagged_layout = TmpLayout { layout: tagged_layout, variants: layout_variants };\n+\n+            let mut best_layout = match (tagged_layout, niche_filling_layout) {\n+                (tl, Some(nl)) => {\n+                    // Pick the smaller layout; otherwise,\n+                    // pick the layout with the larger niche; otherwise,\n+                    // pick tagged as it has simpler codegen.\n+                    use Ordering::*;\n+                    let niche_size = |tmp_l: &TmpLayout<'_>| {\n+                        tmp_l.layout.largest_niche.map_or(0, |n| n.available(dl))\n+                    };\n+                    match (\n+                        tl.layout.size.cmp(&nl.layout.size),\n+                        niche_size(&tl).cmp(&niche_size(&nl)),\n+                    ) {\n+                        (Greater, _) => nl,\n+                        (Equal, Less) => nl,\n+                        _ => tl,\n+                    }\n+                }\n+                (tl, None) => tl,\n+            };\n+\n+            // Now we can intern the variant layouts and store them in the enum layout.\n+            best_layout.layout.variants = match best_layout.layout.variants {\n+                Variants::Multiple { tag, tag_encoding, tag_field, .. } => Variants::Multiple {\n+                    tag,\n+                    tag_encoding,\n+                    tag_field,\n+                    variants: best_layout\n+                        .variants\n+                        .into_iter()\n+                        .map(|layout| tcx.intern_layout(layout))\n+                        .collect(),\n+                },\n+                _ => bug!(),\n+            };\n+\n+            tcx.intern_layout(best_layout.layout)\n+        }\n+\n+        // Types with no meaningful known layout.\n+        ty::Projection(_) | ty::Opaque(..) => {\n+            // NOTE(eddyb) `layout_of` query should've normalized these away,\n+            // if that was possible, so there's no reason to try again here.\n+            return Err(LayoutError::Unknown(ty));\n+        }\n+\n+        ty::Placeholder(..) | ty::GeneratorWitness(..) | ty::Infer(_) => {\n+            bug!(\"Layout::compute: unexpected type `{}`\", ty)\n+        }\n+\n+        ty::Bound(..) | ty::Param(_) | ty::Error(_) => {\n+            return Err(LayoutError::Unknown(ty));\n+        }\n+    })\n+}\n+\n+/// Overlap eligibility and variant assignment for each GeneratorSavedLocal.\n+#[derive(Clone, Debug, PartialEq)]\n+enum SavedLocalEligibility {\n+    Unassigned,\n+    Assigned(VariantIdx),\n+    // FIXME: Use newtype_index so we aren't wasting bytes\n+    Ineligible(Option<u32>),\n+}\n+\n+// When laying out generators, we divide our saved local fields into two\n+// categories: overlap-eligible and overlap-ineligible.\n+//\n+// Those fields which are ineligible for overlap go in a \"prefix\" at the\n+// beginning of the layout, and always have space reserved for them.\n+//\n+// Overlap-eligible fields are only assigned to one variant, so we lay\n+// those fields out for each variant and put them right after the\n+// prefix.\n+//\n+// Finally, in the layout details, we point to the fields from the\n+// variants they are assigned to. It is possible for some fields to be\n+// included in multiple variants. No field ever \"moves around\" in the\n+// layout; its offset is always the same.\n+//\n+// Also included in the layout are the upvars and the discriminant.\n+// These are included as fields on the \"outer\" layout; they are not part\n+// of any variant.\n+\n+/// Compute the eligibility and assignment of each local.\n+fn generator_saved_local_eligibility<'tcx>(\n+    info: &GeneratorLayout<'tcx>,\n+) -> (BitSet<GeneratorSavedLocal>, IndexVec<GeneratorSavedLocal, SavedLocalEligibility>) {\n+    use SavedLocalEligibility::*;\n+\n+    let mut assignments: IndexVec<GeneratorSavedLocal, SavedLocalEligibility> =\n+        IndexVec::from_elem_n(Unassigned, info.field_tys.len());\n+\n+    // The saved locals not eligible for overlap. These will get\n+    // \"promoted\" to the prefix of our generator.\n+    let mut ineligible_locals = BitSet::new_empty(info.field_tys.len());\n+\n+    // Figure out which of our saved locals are fields in only\n+    // one variant. The rest are deemed ineligible for overlap.\n+    for (variant_index, fields) in info.variant_fields.iter_enumerated() {\n+        for local in fields {\n+            match assignments[*local] {\n+                Unassigned => {\n+                    assignments[*local] = Assigned(variant_index);\n+                }\n+                Assigned(idx) => {\n+                    // We've already seen this local at another suspension\n+                    // point, so it is no longer a candidate.\n+                    trace!(\n+                        \"removing local {:?} in >1 variant ({:?}, {:?})\",\n+                        local,\n+                        variant_index,\n+                        idx\n+                    );\n+                    ineligible_locals.insert(*local);\n+                    assignments[*local] = Ineligible(None);\n+                }\n+                Ineligible(_) => {}\n+            }\n+        }\n+    }\n+\n+    // Next, check every pair of eligible locals to see if they\n+    // conflict.\n+    for local_a in info.storage_conflicts.rows() {\n+        let conflicts_a = info.storage_conflicts.count(local_a);\n+        if ineligible_locals.contains(local_a) {\n+            continue;\n+        }\n+\n+        for local_b in info.storage_conflicts.iter(local_a) {\n+            // local_a and local_b are storage live at the same time, therefore they\n+            // cannot overlap in the generator layout. The only way to guarantee\n+            // this is if they are in the same variant, or one is ineligible\n+            // (which means it is stored in every variant).\n+            if ineligible_locals.contains(local_b) || assignments[local_a] == assignments[local_b] {\n+                continue;\n+            }\n+\n+            // If they conflict, we will choose one to make ineligible.\n+            // This is not always optimal; it's just a greedy heuristic that\n+            // seems to produce good results most of the time.\n+            let conflicts_b = info.storage_conflicts.count(local_b);\n+            let (remove, other) =\n+                if conflicts_a > conflicts_b { (local_a, local_b) } else { (local_b, local_a) };\n+            ineligible_locals.insert(remove);\n+            assignments[remove] = Ineligible(None);\n+            trace!(\"removing local {:?} due to conflict with {:?}\", remove, other);\n+        }\n+    }\n+\n+    // Count the number of variants in use. If only one of them, then it is\n+    // impossible to overlap any locals in our layout. In this case it's\n+    // always better to make the remaining locals ineligible, so we can\n+    // lay them out with the other locals in the prefix and eliminate\n+    // unnecessary padding bytes.\n+    {\n+        let mut used_variants = BitSet::new_empty(info.variant_fields.len());\n+        for assignment in &assignments {\n+            if let Assigned(idx) = assignment {\n+                used_variants.insert(*idx);\n+            }\n+        }\n+        if used_variants.count() < 2 {\n+            for assignment in assignments.iter_mut() {\n+                *assignment = Ineligible(None);\n+            }\n+            ineligible_locals.insert_all();\n+        }\n+    }\n+\n+    // Write down the order of our locals that will be promoted to the prefix.\n+    {\n+        for (idx, local) in ineligible_locals.iter().enumerate() {\n+            assignments[local] = Ineligible(Some(idx as u32));\n+        }\n+    }\n+    debug!(\"generator saved local assignments: {:?}\", assignments);\n+\n+    (ineligible_locals, assignments)\n+}\n+\n+/// Compute the full generator layout.\n+fn generator_layout<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    ty: Ty<'tcx>,\n+    def_id: hir::def_id::DefId,\n+    substs: SubstsRef<'tcx>,\n+) -> Result<Layout<'tcx>, LayoutError<'tcx>> {\n+    use SavedLocalEligibility::*;\n+    let tcx = cx.tcx;\n+    let subst_field = |ty: Ty<'tcx>| EarlyBinder(ty).subst(tcx, substs);\n+\n+    let Some(info) = tcx.generator_layout(def_id) else {\n+            return Err(LayoutError::Unknown(ty));\n+        };\n+    let (ineligible_locals, assignments) = generator_saved_local_eligibility(&info);\n+\n+    // Build a prefix layout, including \"promoting\" all ineligible\n+    // locals as part of the prefix. We compute the layout of all of\n+    // these fields at once to get optimal packing.\n+    let tag_index = substs.as_generator().prefix_tys().count();\n+\n+    // `info.variant_fields` already accounts for the reserved variants, so no need to add them.\n+    let max_discr = (info.variant_fields.len() - 1) as u128;\n+    let discr_int = Integer::fit_unsigned(max_discr);\n+    let discr_int_ty = discr_int.to_ty(tcx, false);\n+    let tag = Scalar::Initialized {\n+        value: Primitive::Int(discr_int, false),\n+        valid_range: WrappingRange { start: 0, end: max_discr },\n+    };\n+    let tag_layout = cx.tcx.intern_layout(LayoutS::scalar(cx, tag));\n+    let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout };\n+\n+    let promoted_layouts = ineligible_locals\n+        .iter()\n+        .map(|local| subst_field(info.field_tys[local]))\n+        .map(|ty| tcx.mk_maybe_uninit(ty))\n+        .map(|ty| cx.layout_of(ty));\n+    let prefix_layouts = substs\n+        .as_generator()\n+        .prefix_tys()\n+        .map(|ty| cx.layout_of(ty))\n+        .chain(iter::once(Ok(tag_layout)))\n+        .chain(promoted_layouts)\n+        .collect::<Result<Vec<_>, _>>()?;\n+    let prefix = univariant_uninterned(\n+        cx,\n+        ty,\n+        &prefix_layouts,\n+        &ReprOptions::default(),\n+        StructKind::AlwaysSized,\n+    )?;\n+\n+    let (prefix_size, prefix_align) = (prefix.size, prefix.align);\n+\n+    // Split the prefix layout into the \"outer\" fields (upvars and\n+    // discriminant) and the \"promoted\" fields. Promoted fields will\n+    // get included in each variant that requested them in\n+    // GeneratorLayout.\n+    debug!(\"prefix = {:#?}\", prefix);\n+    let (outer_fields, promoted_offsets, promoted_memory_index) = match prefix.fields {\n+        FieldsShape::Arbitrary { mut offsets, memory_index } => {\n+            let mut inverse_memory_index = invert_mapping(&memory_index);\n+\n+            // \"a\" (`0..b_start`) and \"b\" (`b_start..`) correspond to\n+            // \"outer\" and \"promoted\" fields respectively.\n+            let b_start = (tag_index + 1) as u32;\n+            let offsets_b = offsets.split_off(b_start as usize);\n+            let offsets_a = offsets;\n+\n+            // Disentangle the \"a\" and \"b\" components of `inverse_memory_index`\n+            // by preserving the order but keeping only one disjoint \"half\" each.\n+            // FIXME(eddyb) build a better abstraction for permutations, if possible.\n+            let inverse_memory_index_b: Vec<_> =\n+                inverse_memory_index.iter().filter_map(|&i| i.checked_sub(b_start)).collect();\n+            inverse_memory_index.retain(|&i| i < b_start);\n+            let inverse_memory_index_a = inverse_memory_index;\n+\n+            // Since `inverse_memory_index_{a,b}` each only refer to their\n+            // respective fields, they can be safely inverted\n+            let memory_index_a = invert_mapping(&inverse_memory_index_a);\n+            let memory_index_b = invert_mapping(&inverse_memory_index_b);\n+\n+            let outer_fields =\n+                FieldsShape::Arbitrary { offsets: offsets_a, memory_index: memory_index_a };\n+            (outer_fields, offsets_b, memory_index_b)\n+        }\n+        _ => bug!(),\n+    };\n+\n+    let mut size = prefix.size;\n+    let mut align = prefix.align;\n+    let variants = info\n+        .variant_fields\n+        .iter_enumerated()\n+        .map(|(index, variant_fields)| {\n+            // Only include overlap-eligible fields when we compute our variant layout.\n+            let variant_only_tys = variant_fields\n+                .iter()\n+                .filter(|local| match assignments[**local] {\n+                    Unassigned => bug!(),\n+                    Assigned(v) if v == index => true,\n+                    Assigned(_) => bug!(\"assignment does not match variant\"),\n+                    Ineligible(_) => false,\n+                })\n+                .map(|local| subst_field(info.field_tys[*local]));\n+\n+            let mut variant = univariant_uninterned(\n+                cx,\n+                ty,\n+                &variant_only_tys.map(|ty| cx.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+                &ReprOptions::default(),\n+                StructKind::Prefixed(prefix_size, prefix_align.abi),\n+            )?;\n+            variant.variants = Variants::Single { index };\n+\n+            let FieldsShape::Arbitrary { offsets, memory_index } = variant.fields else {\n+                    bug!();\n+                };\n+\n+            // Now, stitch the promoted and variant-only fields back together in\n+            // the order they are mentioned by our GeneratorLayout.\n+            // Because we only use some subset (that can differ between variants)\n+            // of the promoted fields, we can't just pick those elements of the\n+            // `promoted_memory_index` (as we'd end up with gaps).\n+            // So instead, we build an \"inverse memory_index\", as if all of the\n+            // promoted fields were being used, but leave the elements not in the\n+            // subset as `INVALID_FIELD_IDX`, which we can filter out later to\n+            // obtain a valid (bijective) mapping.\n+            const INVALID_FIELD_IDX: u32 = !0;\n+            let mut combined_inverse_memory_index =\n+                vec![INVALID_FIELD_IDX; promoted_memory_index.len() + memory_index.len()];\n+            let mut offsets_and_memory_index = iter::zip(offsets, memory_index);\n+            let combined_offsets = variant_fields\n+                .iter()\n+                .enumerate()\n+                .map(|(i, local)| {\n+                    let (offset, memory_index) = match assignments[*local] {\n+                        Unassigned => bug!(),\n+                        Assigned(_) => {\n+                            let (offset, memory_index) = offsets_and_memory_index.next().unwrap();\n+                            (offset, promoted_memory_index.len() as u32 + memory_index)\n+                        }\n+                        Ineligible(field_idx) => {\n+                            let field_idx = field_idx.unwrap() as usize;\n+                            (promoted_offsets[field_idx], promoted_memory_index[field_idx])\n+                        }\n+                    };\n+                    combined_inverse_memory_index[memory_index as usize] = i as u32;\n+                    offset\n+                })\n+                .collect();\n+\n+            // Remove the unused slots and invert the mapping to obtain the\n+            // combined `memory_index` (also see previous comment).\n+            combined_inverse_memory_index.retain(|&i| i != INVALID_FIELD_IDX);\n+            let combined_memory_index = invert_mapping(&combined_inverse_memory_index);\n+\n+            variant.fields = FieldsShape::Arbitrary {\n+                offsets: combined_offsets,\n+                memory_index: combined_memory_index,\n+            };\n+\n+            size = size.max(variant.size);\n+            align = align.max(variant.align);\n+            Ok(tcx.intern_layout(variant))\n+        })\n+        .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n+\n+    size = size.align_to(align.abi);\n+\n+    let abi = if prefix.abi.is_uninhabited() || variants.iter().all(|v| v.abi().is_uninhabited()) {\n+        Abi::Uninhabited\n+    } else {\n+        Abi::Aggregate { sized: true }\n+    };\n+\n+    let layout = tcx.intern_layout(LayoutS {\n+        variants: Variants::Multiple {\n+            tag,\n+            tag_encoding: TagEncoding::Direct,\n+            tag_field: tag_index,\n+            variants,\n+        },\n+        fields: outer_fields,\n+        abi,\n+        largest_niche: prefix.largest_niche,\n+        size,\n+        align,\n+    });\n+    debug!(\"generator layout ({:?}): {:#?}\", ty, layout);\n+    Ok(layout)\n+}\n+\n+/// This is invoked by the `layout_of` query to record the final\n+/// layout of each type.\n+#[inline(always)]\n+fn record_layout_for_printing<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: TyAndLayout<'tcx>) {\n+    // If we are running with `-Zprint-type-sizes`, maybe record layouts\n+    // for dumping later.\n+    if cx.tcx.sess.opts.unstable_opts.print_type_sizes {\n+        record_layout_for_printing_outlined(cx, layout)\n+    }\n+}\n+\n+fn record_layout_for_printing_outlined<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    layout: TyAndLayout<'tcx>,\n+) {\n+    // Ignore layouts that are done with non-empty environments or\n+    // non-monomorphic layouts, as the user only wants to see the stuff\n+    // resulting from the final codegen session.\n+    if layout.ty.has_param_types_or_consts() || !cx.param_env.caller_bounds().is_empty() {\n+        return;\n+    }\n+\n+    // (delay format until we actually need it)\n+    let record = |kind, packed, opt_discr_size, variants| {\n+        let type_desc = format!(\"{:?}\", layout.ty);\n+        cx.tcx.sess.code_stats.record_type_size(\n+            kind,\n+            type_desc,\n+            layout.align.abi,\n+            layout.size,\n+            packed,\n+            opt_discr_size,\n+            variants,\n+        );\n+    };\n+\n+    let adt_def = match *layout.ty.kind() {\n+        ty::Adt(ref adt_def, _) => {\n+            debug!(\"print-type-size t: `{:?}` process adt\", layout.ty);\n+            adt_def\n+        }\n+\n+        ty::Closure(..) => {\n+            debug!(\"print-type-size t: `{:?}` record closure\", layout.ty);\n+            record(DataTypeKind::Closure, false, None, vec![]);\n+            return;\n+        }\n+\n+        _ => {\n+            debug!(\"print-type-size t: `{:?}` skip non-nominal\", layout.ty);\n+            return;\n+        }\n+    };\n+\n+    let adt_kind = adt_def.adt_kind();\n+    let adt_packed = adt_def.repr().pack.is_some();\n+\n+    let build_variant_info = |n: Option<Symbol>, flds: &[Symbol], layout: TyAndLayout<'tcx>| {\n+        let mut min_size = Size::ZERO;\n+        let field_info: Vec<_> = flds\n+            .iter()\n+            .enumerate()\n+            .map(|(i, &name)| {\n+                let field_layout = layout.field(cx, i);\n+                let offset = layout.fields.offset(i);\n+                let field_end = offset + field_layout.size;\n+                if min_size < field_end {\n+                    min_size = field_end;\n+                }\n+                FieldInfo {\n+                    name,\n+                    offset: offset.bytes(),\n+                    size: field_layout.size.bytes(),\n+                    align: field_layout.align.abi.bytes(),\n+                }\n+            })\n+            .collect();\n+\n+        VariantInfo {\n+            name: n,\n+            kind: if layout.is_unsized() { SizeKind::Min } else { SizeKind::Exact },\n+            align: layout.align.abi.bytes(),\n+            size: if min_size.bytes() == 0 { layout.size.bytes() } else { min_size.bytes() },\n+            fields: field_info,\n+        }\n+    };\n+\n+    match layout.variants {\n+        Variants::Single { index } => {\n+            if !adt_def.variants().is_empty() && layout.fields != FieldsShape::Primitive {\n+                debug!(\"print-type-size `{:#?}` variant {}\", layout, adt_def.variant(index).name);\n+                let variant_def = &adt_def.variant(index);\n+                let fields: Vec<_> = variant_def.fields.iter().map(|f| f.name).collect();\n+                record(\n+                    adt_kind.into(),\n+                    adt_packed,\n+                    None,\n+                    vec![build_variant_info(Some(variant_def.name), &fields, layout)],\n+                );\n+            } else {\n+                // (This case arises for *empty* enums; so give it\n+                // zero variants.)\n+                record(adt_kind.into(), adt_packed, None, vec![]);\n+            }\n+        }\n+\n+        Variants::Multiple { tag, ref tag_encoding, .. } => {\n+            debug!(\n+                \"print-type-size `{:#?}` adt general variants def {}\",\n+                layout.ty,\n+                adt_def.variants().len()\n+            );\n+            let variant_infos: Vec<_> = adt_def\n+                .variants()\n+                .iter_enumerated()\n+                .map(|(i, variant_def)| {\n+                    let fields: Vec<_> = variant_def.fields.iter().map(|f| f.name).collect();\n+                    build_variant_info(Some(variant_def.name), &fields, layout.for_variant(cx, i))\n+                })\n+                .collect();\n+            record(\n+                adt_kind.into(),\n+                adt_packed,\n+                match tag_encoding {\n+                    TagEncoding::Direct => Some(tag.size(cx)),\n+                    _ => None,\n+                },\n+                variant_infos,\n+            );\n+        }\n+    }\n+}"}, {"sha": "100926ad446853951644c75dbd28bbe8924c9ec6", "filename": "compiler/rustc_ty_utils/src/layout_sanity_check.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs?ref=95b689b1d55936cb9d51bb01672f28f1e05994c4", "patch": "@@ -1,4 +1,4 @@\n-use crate::ty::{\n+use rustc_middle::ty::{\n     layout::{LayoutCx, TyAndLayout},\n     TyCtxt,\n };", "previous_filename": "compiler/rustc_middle/src/ty/layout_sanity_check.rs"}, {"sha": "f97fc4c199dd97fe2035b04b2a9283d45e66eefa", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b689b1d55936cb9d51bb01672f28f1e05994c4/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=95b689b1d55936cb9d51bb01672f28f1e05994c4", "patch": "@@ -9,8 +9,6 @@\n #![feature(never_type)]\n #![feature(box_patterns)]\n #![recursion_limit = \"256\"]\n-#![deny(rustc::untranslatable_diagnostic)]\n-#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_middle;\n@@ -19,21 +17,26 @@ extern crate tracing;\n \n use rustc_middle::ty::query::Providers;\n \n+mod abi;\n mod assoc;\n mod common_traits;\n mod consts;\n mod errors;\n mod implied_bounds;\n pub mod instance;\n+mod layout;\n+mod layout_sanity_check;\n mod needs_drop;\n pub mod representability;\n mod ty;\n \n pub fn provide(providers: &mut Providers) {\n+    abi::provide(providers);\n     assoc::provide(providers);\n     common_traits::provide(providers);\n     consts::provide(providers);\n     implied_bounds::provide(providers);\n+    layout::provide(providers);\n     needs_drop::provide(providers);\n     ty::provide(providers);\n     instance::provide(providers);"}]}