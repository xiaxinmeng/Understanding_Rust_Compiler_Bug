{"sha": "d7db38fff9c251c36d0796309b43678bdf9e5bd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZGIzOGZmZjljMjUxYzM2ZDA3OTYzMDliNDM2NzhiZGY5ZTViZDg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-24T22:37:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-24T22:37:48Z"}, "message": "Merge #7907\n\n7907: Autoderef with visibility r=cynecx a=cynecx\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/7841.\r\n\r\nI am not sure about the general approach here. Right now this simply tries to check whether the autoderef candidate is reachable from the current module. ~~However this doesn't exactly work with traits (see the `tests::macros::infer_derive_clone_in_core` test, which fails right now).~~ see comment below\r\n\r\nRefs:\r\n\r\n- `rustc_typeck` checking fields: https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler/rustc_typeck/src/check/expr.rs#L1610 \r\n\r\n\r\nr? @flodiebold\n\nCo-authored-by: cynecx <me@cynecx.net>", "tree": {"sha": "83b422d45c28e3ae9a2eac550ce8a6048bf5fd71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83b422d45c28e3ae9a2eac550ce8a6048bf5fd71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7db38fff9c251c36d0796309b43678bdf9e5bd8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgW788CRBK7hj4Ov3rIwAAdHIIABU+uto6e4WHHBKvyvEJ9wMW\n1v8bXrO4VHC9z4gDYAfEdFm7OYA+Pq0q0HB71iw5D+m1Ngrw4G5ZfuquWIolqygW\nNM+MGZjeuEPicNOupz5pPUon2FVP3rgqEWVkT4zJAJaBlT2Cz2YvXbD2TOkskytQ\nNqUxokPDnEhhUv/CXEBWlqxt0VoSjbByZ30K/Lw7BLIFjUWc+FzABaVOeyNvTPrv\ncq9HtodF1MohQesRcBmxAMq+sGPfoADjXBS9U2DA60vgmoJ3XhSMgXAiEbsQ9YQt\nc9CiGhkz66t5z81iYLXbYYBoL3uaXvlErm4p23NOJ+YDImm6dhnFAQrYtEhSQ6k=\n=yCA6\n-----END PGP SIGNATURE-----\n", "payload": "tree 83b422d45c28e3ae9a2eac550ce8a6048bf5fd71\nparent 9d81618f11eb403cc0644a22f30648393ec77cf6\nparent d1156bb52e900c015afd490f509d744c7a5adf10\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1616625468 +0000\ncommitter GitHub <noreply@github.com> 1616625468 +0000\n\nMerge #7907\n\n7907: Autoderef with visibility r=cynecx a=cynecx\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/7841.\r\n\r\nI am not sure about the general approach here. Right now this simply tries to check whether the autoderef candidate is reachable from the current module. ~~However this doesn't exactly work with traits (see the `tests::macros::infer_derive_clone_in_core` test, which fails right now).~~ see comment below\r\n\r\nRefs:\r\n\r\n- `rustc_typeck` checking fields: https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler/rustc_typeck/src/check/expr.rs#L1610 \r\n\r\n\r\nr? @flodiebold\n\nCo-authored-by: cynecx <me@cynecx.net>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7db38fff9c251c36d0796309b43678bdf9e5bd8", "html_url": "https://github.com/rust-lang/rust/commit/d7db38fff9c251c36d0796309b43678bdf9e5bd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7db38fff9c251c36d0796309b43678bdf9e5bd8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d81618f11eb403cc0644a22f30648393ec77cf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d81618f11eb403cc0644a22f30648393ec77cf6", "html_url": "https://github.com/rust-lang/rust/commit/9d81618f11eb403cc0644a22f30648393ec77cf6"}, {"sha": "d1156bb52e900c015afd490f509d744c7a5adf10", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1156bb52e900c015afd490f509d744c7a5adf10", "html_url": "https://github.com/rust-lang/rust/commit/d1156bb52e900c015afd490f509d744c7a5adf10"}], "stats": {"total": 287, "additions": 250, "deletions": 37}, "files": [{"sha": "6fa676c4d21a02033c7a90c49ae330f594d1822c", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=d7db38fff9c251c36d0796309b43678bdf9e5bd8", "patch": "@@ -1999,6 +1999,7 @@ impl Type {\n             env,\n             krate,\n             traits_in_scope,\n+            None,\n             name,\n             method_resolution::LookupMode::MethodCall,\n             |ty, it| match it {\n@@ -2031,6 +2032,7 @@ impl Type {\n             env,\n             krate,\n             traits_in_scope,\n+            None,\n             name,\n             method_resolution::LookupMode::Path,\n             |ty, it| callback(ty, it.into()),"}, {"sha": "068b2ee3858b6936d5d8056da8caa80fea631770", "filename": "crates/hir_def/src/db.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdb.rs?ref=d7db38fff9c251c36d0796309b43678bdf9e5bd8", "patch": "@@ -16,6 +16,7 @@ use crate::{\n     item_tree::ItemTree,\n     lang_item::{LangItemTarget, LangItems},\n     nameres::DefMap,\n+    visibility::{self, Visibility},\n     AttrDefId, BlockId, BlockLoc, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, FunctionId,\n     FunctionLoc, GenericDefId, ImplId, ImplLoc, LocalEnumVariantId, LocalFieldId, StaticId,\n     StaticLoc, StructId, StructLoc, TraitId, TraitLoc, TypeAliasId, TypeAliasLoc, UnionId,\n@@ -131,6 +132,12 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n \n     #[salsa::invoke(ImportMap::import_map_query)]\n     fn import_map(&self, krate: CrateId) -> Arc<ImportMap>;\n+\n+    #[salsa::invoke(visibility::field_visibilities_query)]\n+    fn field_visibilities(&self, var: VariantId) -> Arc<ArenaMap<LocalFieldId, Visibility>>;\n+\n+    #[salsa::invoke(visibility::function_visibility_query)]\n+    fn function_visibility(&self, def: FunctionId) -> Visibility;\n }\n \n fn crate_def_map_wait(db: &dyn DefDatabase, krate: CrateId) -> Arc<DefMap> {"}, {"sha": "7d00a37c40fa4e8160762d0bc7d08976e4eedd80", "filename": "crates/hir_def/src/visibility.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fvisibility.rs?ref=d7db38fff9c251c36d0796309b43678bdf9e5bd8", "patch": "@@ -1,13 +1,17 @@\n //! Defines hir-level representation of visibility (e.g. `pub` and `pub(crate)`).\n \n+use std::sync::Arc;\n+\n use hir_expand::{hygiene::Hygiene, InFile};\n+use la_arena::ArenaMap;\n use syntax::ast;\n \n use crate::{\n     db::DefDatabase,\n     nameres::DefMap,\n     path::{ModPath, PathKind},\n-    ModuleId,\n+    resolver::HasResolver,\n+    FunctionId, HasModule, LocalFieldId, ModuleDefId, ModuleId, VariantId,\n };\n \n /// Visibility of an item, not yet resolved.\n@@ -190,3 +194,29 @@ impl Visibility {\n         }\n     }\n }\n+\n+/// Resolve visibility of all specific fields of a struct or union variant.\n+pub(crate) fn field_visibilities_query(\n+    db: &dyn DefDatabase,\n+    variant_id: VariantId,\n+) -> Arc<ArenaMap<LocalFieldId, Visibility>> {\n+    let var_data = match variant_id {\n+        VariantId::StructId(it) => db.struct_data(it).variant_data.clone(),\n+        VariantId::UnionId(it) => db.union_data(it).variant_data.clone(),\n+        VariantId::EnumVariantId(it) => {\n+            db.enum_data(it.parent).variants[it.local_id].variant_data.clone()\n+        }\n+    };\n+    let resolver = variant_id.module(db).resolver(db);\n+    let mut res = ArenaMap::default();\n+    for (field_id, field_data) in var_data.fields().iter() {\n+        res.insert(field_id, field_data.visibility.resolve(db, &resolver))\n+    }\n+    Arc::new(res)\n+}\n+\n+/// Resolve visibility of a function.\n+pub(crate) fn function_visibility_query(db: &dyn DefDatabase, def: FunctionId) -> Visibility {\n+    let resolver = ModuleDefId::from(def).module(db).unwrap().resolver(db);\n+    db.function_data(def).visibility.resolve(db, &resolver)\n+}"}, {"sha": "3f3187ea275d4fd3c2c90bbb89563bfbcc95d976", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=d7db38fff9c251c36d0796309b43678bdf9e5bd8", "patch": "@@ -443,27 +443,47 @@ impl<'a> InferenceContext<'a> {\n                     },\n                 )\n                 .find_map(|derefed_ty| {\n+                    let def_db = self.db.upcast();\n+                    let module = self.resolver.module();\n+                    let is_visible = |field_id: &FieldId| {\n+                        module\n+                            .map(|mod_id| {\n+                                self.db.field_visibilities(field_id.parent)[field_id.local_id]\n+                                    .is_visible_from(def_db, mod_id)\n+                            })\n+                            .unwrap_or(true)\n+                    };\n                     match canonicalized.decanonicalize_ty(derefed_ty.value).interned(&Interner) {\n                         TyKind::Tuple(_, substs) => {\n                             name.as_tuple_index().and_then(|idx| substs.0.get(idx).cloned())\n                         }\n                         TyKind::Adt(AdtId(hir_def::AdtId::StructId(s)), parameters) => {\n-                            self.db.struct_data(*s).variant_data.field(name).map(|local_id| {\n-                                let field = FieldId { parent: (*s).into(), local_id };\n+                            let local_id = self.db.struct_data(*s).variant_data.field(name)?;\n+                            let field = FieldId { parent: (*s).into(), local_id };\n+                            if is_visible(&field) {\n                                 self.write_field_resolution(tgt_expr, field);\n-                                self.db.field_types((*s).into())[field.local_id]\n-                                    .clone()\n-                                    .subst(&parameters)\n-                            })\n+                                Some(\n+                                    self.db.field_types((*s).into())[field.local_id]\n+                                        .clone()\n+                                        .subst(&parameters),\n+                                )\n+                            } else {\n+                                None\n+                            }\n                         }\n                         TyKind::Adt(AdtId(hir_def::AdtId::UnionId(u)), parameters) => {\n-                            self.db.union_data(*u).variant_data.field(name).map(|local_id| {\n-                                let field = FieldId { parent: (*u).into(), local_id };\n+                            let local_id = self.db.union_data(*u).variant_data.field(name)?;\n+                            let field = FieldId { parent: (*u).into(), local_id };\n+                            if is_visible(&field) {\n                                 self.write_field_resolution(tgt_expr, field);\n-                                self.db.field_types((*u).into())[field.local_id]\n-                                    .clone()\n-                                    .subst(&parameters)\n-                            })\n+                                Some(\n+                                    self.db.field_types((*u).into())[field.local_id]\n+                                        .clone()\n+                                        .subst(&parameters),\n+                                )\n+                            } else {\n+                                None\n+                            }\n                         }\n                         _ => None,\n                     }\n@@ -828,6 +848,7 @@ impl<'a> InferenceContext<'a> {\n                 self.trait_env.clone(),\n                 krate,\n                 &traits_in_scope,\n+                self.resolver.module(),\n                 method_name,\n             )\n         });"}, {"sha": "cefa385094865db16c239d3257c1e821db7b751d", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=d7db38fff9c251c36d0796309b43678bdf9e5bd8", "patch": "@@ -230,6 +230,7 @@ impl<'a> InferenceContext<'a> {\n             self.trait_env.clone(),\n             krate,\n             &traits_in_scope,\n+            None,\n             Some(name),\n             method_resolution::LookupMode::Path,\n             move |_ty, item| {"}, {"sha": "84d9a1e186c4e3c9ae2400fa094cfe80e39b31e2", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=d7db38fff9c251c36d0796309b43678bdf9e5bd8", "patch": "@@ -296,6 +296,7 @@ pub(crate) fn lookup_method(\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n+    visible_from_module: Option<ModuleId>,\n     name: &Name,\n ) -> Option<(Ty, FunctionId)> {\n     iterate_method_candidates(\n@@ -304,6 +305,7 @@ pub(crate) fn lookup_method(\n         env,\n         krate,\n         &traits_in_scope,\n+        visible_from_module,\n         Some(name),\n         LookupMode::MethodCall,\n         |ty, f| match f {\n@@ -334,6 +336,7 @@ pub fn iterate_method_candidates<T>(\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n+    visible_from_module: Option<ModuleId>,\n     name: Option<&Name>,\n     mode: LookupMode,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n@@ -345,6 +348,7 @@ pub fn iterate_method_candidates<T>(\n         env,\n         krate,\n         traits_in_scope,\n+        visible_from_module,\n         name,\n         mode,\n         &mut |ty, item| {\n@@ -362,6 +366,7 @@ fn iterate_method_candidates_impl(\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n+    visible_from_module: Option<ModuleId>,\n     name: Option<&Name>,\n     mode: LookupMode,\n     callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n@@ -399,6 +404,7 @@ fn iterate_method_candidates_impl(\n                     env.clone(),\n                     krate,\n                     traits_in_scope,\n+                    visible_from_module,\n                     name,\n                     callback,\n                 ) {\n@@ -415,6 +421,7 @@ fn iterate_method_candidates_impl(\n                 env,\n                 krate,\n                 traits_in_scope,\n+                visible_from_module,\n                 name,\n                 callback,\n             )\n@@ -428,6 +435,7 @@ fn iterate_method_candidates_with_autoref(\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n+    visible_from_module: Option<ModuleId>,\n     name: Option<&Name>,\n     mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n ) -> bool {\n@@ -438,6 +446,7 @@ fn iterate_method_candidates_with_autoref(\n         env.clone(),\n         krate,\n         &traits_in_scope,\n+        visible_from_module,\n         name,\n         &mut callback,\n     ) {\n@@ -454,6 +463,7 @@ fn iterate_method_candidates_with_autoref(\n         env.clone(),\n         krate,\n         &traits_in_scope,\n+        visible_from_module,\n         name,\n         &mut callback,\n     ) {\n@@ -470,6 +480,7 @@ fn iterate_method_candidates_with_autoref(\n         env,\n         krate,\n         &traits_in_scope,\n+        visible_from_module,\n         name,\n         &mut callback,\n     ) {\n@@ -485,14 +496,23 @@ fn iterate_method_candidates_by_receiver(\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n+    visible_from_module: Option<ModuleId>,\n     name: Option<&Name>,\n     mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n ) -> bool {\n     // We're looking for methods with *receiver* type receiver_ty. These could\n     // be found in any of the derefs of receiver_ty, so we have to go through\n     // that.\n     for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n-        if iterate_inherent_methods(self_ty, db, name, Some(receiver_ty), krate, &mut callback) {\n+        if iterate_inherent_methods(\n+            self_ty,\n+            db,\n+            name,\n+            Some(receiver_ty),\n+            krate,\n+            visible_from_module,\n+            &mut callback,\n+        ) {\n             return true;\n         }\n     }\n@@ -519,10 +539,12 @@ fn iterate_method_candidates_for_self_ty(\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n+    visible_from_module: Option<ModuleId>,\n     name: Option<&Name>,\n     mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n ) -> bool {\n-    if iterate_inherent_methods(self_ty, db, name, None, krate, &mut callback) {\n+    if iterate_inherent_methods(self_ty, db, name, None, krate, visible_from_module, &mut callback)\n+    {\n         return true;\n     }\n     iterate_trait_method_candidates(self_ty, db, env, krate, traits_in_scope, name, None, callback)\n@@ -559,7 +581,9 @@ fn iterate_trait_method_candidates(\n         // iteration\n         let mut known_implemented = false;\n         for (_name, item) in data.items.iter() {\n-            if !is_valid_candidate(db, name, receiver_ty, *item, self_ty) {\n+            // Don't pass a `visible_from_module` down to `is_valid_candidate`,\n+            // since only inherent methods should be included into visibility checking.\n+            if !is_valid_candidate(db, name, receiver_ty, *item, self_ty, None) {\n                 continue;\n             }\n             if !known_implemented {\n@@ -583,6 +607,7 @@ fn iterate_inherent_methods(\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n     krate: CrateId,\n+    visible_from_module: Option<ModuleId>,\n     callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n ) -> bool {\n     let def_crates = match self_ty.value.def_crates(db, krate) {\n@@ -594,7 +619,7 @@ fn iterate_inherent_methods(\n \n         for &impl_def in impls.for_self_ty(&self_ty.value) {\n             for &item in db.impl_data(impl_def).items.iter() {\n-                if !is_valid_candidate(db, name, receiver_ty, item, self_ty) {\n+                if !is_valid_candidate(db, name, receiver_ty, item, self_ty, visible_from_module) {\n                     continue;\n                 }\n                 // we have to check whether the self type unifies with the type\n@@ -639,6 +664,7 @@ fn is_valid_candidate(\n     receiver_ty: Option<&Canonical<Ty>>,\n     item: AssocItemId,\n     self_ty: &Canonical<Ty>,\n+    visible_from_module: Option<ModuleId>,\n ) -> bool {\n     match item {\n         AssocItemId::FunctionId(m) => {\n@@ -660,6 +686,13 @@ fn is_valid_candidate(\n                     return false;\n                 }\n             }\n+            if let Some(from_module) = visible_from_module {\n+                if !db.function_visibility(m).is_visible_from(db.upcast(), from_module) {\n+                    cov_mark::hit!(autoderef_candidate_not_visible);\n+                    return false;\n+                }\n+            }\n+\n             true\n         }\n         AssocItemId::ConstId(c) => {"}, {"sha": "7eda518663aedbad797237d0b200c5c7785dce2b", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=d7db38fff9c251c36d0796309b43678bdf9e5bd8", "patch": "@@ -31,12 +31,12 @@ struct S;\n \n #[cfg(not(test))]\n impl S {\n-    fn foo3(&self) -> i32 { 0 }\n+    pub fn foo3(&self) -> i32 { 0 }\n }\n \n #[cfg(test)]\n impl S {\n-    fn foo4(&self) -> i32 { 0 }\n+    pub fn foo4(&self) -> i32 { 0 }\n }\n \"#,\n     );"}, {"sha": "61f18b0d2069d155ff36a9faee49fee54ad806ab", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=d7db38fff9c251c36d0796309b43678bdf9e5bd8", "patch": "@@ -1173,3 +1173,122 @@ fn main() {\n \"#,\n     );\n }\n+\n+#[test]\n+fn autoderef_visibility_field() {\n+    check_infer(\n+        r#\"\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+mod a {\n+    pub struct Foo(pub char);\n+    pub struct Bar(i32);\n+    impl Bar {\n+        pub fn new() -> Self {\n+            Self(0)\n+        }\n+    }\n+    impl super::Deref for Bar {\n+        type Target = Foo;\n+        fn deref(&self) -> &Foo {\n+            &Foo('z')\n+        }\n+    }\n+}\n+mod b {\n+    fn foo() {\n+        let x = super::a::Bar::new().0;\n+    }\n+}\n+        \"#,\n+        expect![[r#\"\n+            67..71 'self': &Self\n+            200..231 '{     ...     }': Bar\n+            214..218 'Self': Bar(i32) -> Bar\n+            214..221 'Self(0)': Bar\n+            219..220 '0': i32\n+            315..319 'self': &Bar\n+            329..362 '{     ...     }': &Foo\n+            343..352 '&Foo('z')': &Foo\n+            344..347 'Foo': Foo(char) -> Foo\n+            344..352 'Foo('z')': Foo\n+            348..351 ''z'': char\n+            392..439 '{     ...     }': ()\n+            406..407 'x': char\n+            410..428 'super:...r::new': fn new() -> Bar\n+            410..430 'super:...:new()': Bar\n+            410..432 'super:...ew().0': char\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn autoderef_visibility_method() {\n+    cov_mark::check!(autoderef_candidate_not_visible);\n+    check_infer(\n+        r#\"\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+mod a {\n+    pub struct Foo(pub char);\n+    impl Foo {\n+        pub fn mango(&self) -> char {\n+            self.0\n+        }\n+    }\n+    pub struct Bar(i32);\n+    impl Bar {\n+        pub fn new() -> Self {\n+            Self(0)\n+        }\n+        fn mango(&self) -> i32 {\n+            self.0\n+        }\n+    }\n+    impl super::Deref for Bar {\n+        type Target = Foo;\n+        fn deref(&self) -> &Foo {\n+            &Foo('z')\n+        }\n+    }\n+}\n+mod b {\n+    fn foo() {\n+        let x = super::a::Bar::new().mango();\n+    }\n+}\n+        \"#,\n+        expect![[r#\"\n+            67..71 'self': &Self\n+            168..172 'self': &Foo\n+            182..212 '{     ...     }': char\n+            196..200 'self': &Foo\n+            196..202 'self.0': char\n+            288..319 '{     ...     }': Bar\n+            302..306 'Self': Bar(i32) -> Bar\n+            302..309 'Self(0)': Bar\n+            307..308 '0': i32\n+            338..342 'self': &Bar\n+            351..381 '{     ...     }': i32\n+            365..369 'self': &Bar\n+            365..371 'self.0': i32\n+            465..469 'self': &Bar\n+            479..512 '{     ...     }': &Foo\n+            493..502 '&Foo('z')': &Foo\n+            494..497 'Foo': Foo(char) -> Foo\n+            494..502 'Foo('z')': Foo\n+            498..501 ''z'': char\n+            542..595 '{     ...     }': ()\n+            556..557 'x': char\n+            560..578 'super:...r::new': fn new() -> Bar\n+            560..580 'super:...:new()': Bar\n+            560..588 'super:...ango()': char\n+        \"#]],\n+    )\n+}"}, {"sha": "361cd63026fdec3662d8195c4809d97bea5551b1", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=d7db38fff9c251c36d0796309b43678bdf9e5bd8", "patch": "@@ -1103,7 +1103,7 @@ fn infer_inherent_method() {\n \n         mod b {\n             impl super::A {\n-                fn bar(&self, x: u64) -> i64 {}\n+                pub fn bar(&self, x: u64) -> i64 {}\n             }\n         }\n \n@@ -1117,21 +1117,21 @@ fn infer_inherent_method() {\n             31..35 'self': A\n             37..38 'x': u32\n             52..54 '{}': ()\n-            102..106 'self': &A\n-            108..109 'x': u64\n-            123..125 '{}': ()\n-            143..144 'a': A\n-            149..197 '{     ...(1); }': ()\n-            155..156 'a': A\n-            155..163 'a.foo(1)': i32\n-            161..162 '1': u32\n-            169..180 '(&a).bar(1)': i64\n-            170..172 '&a': &A\n-            171..172 'a': A\n-            178..179 '1': u64\n-            186..187 'a': A\n-            186..194 'a.bar(1)': i64\n-            192..193 '1': u64\n+            106..110 'self': &A\n+            112..113 'x': u64\n+            127..129 '{}': ()\n+            147..148 'a': A\n+            153..201 '{     ...(1); }': ()\n+            159..160 'a': A\n+            159..167 'a.foo(1)': i32\n+            165..166 '1': u32\n+            173..184 '(&a).bar(1)': i64\n+            174..176 '&a': &A\n+            175..176 'a': A\n+            182..183 '1': u64\n+            190..191 'a': A\n+            190..198 'a.bar(1)': i64\n+            196..197 '1': u64\n         \"#]],\n     );\n }"}, {"sha": "2ba97f814dd1b869d18aab33fe1ba455db73334c", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7db38fff9c251c36d0796309b43678bdf9e5bd8/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=d7db38fff9c251c36d0796309b43678bdf9e5bd8", "patch": "@@ -187,8 +187,8 @@ mod iter {\n mod collections {\n     struct Vec<T> {}\n     impl<T> Vec<T> {\n-        fn new() -> Self { Vec {} }\n-        fn push(&mut self, t: T) { }\n+        pub fn new() -> Self { Vec {} }\n+        pub fn push(&mut self, t: T) { }\n     }\n \n     impl<T> IntoIterator for Vec<T> {"}]}