{"sha": "57e5d43c770201d837298175a2d55818867bdb33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZTVkNDNjNzcwMjAxZDgzNzI5ODE3NWEyZDU1ODE4ODY3YmRiMzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-05T17:55:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-05T17:55:38Z"}, "message": "Auto merge of #32743 - Manishearth:rollup, r=Manishearth\n\nRollup of 11 pull requests\n\n- Successful merges: #32403, #32596, #32675, #32678, #32685, #32686, #32692, #32710, #32712, #32714, #32715\n- Failed merges: #32488", "tree": {"sha": "d2aff29aff613d9023bb26d7a8bc5b4ee3ee2ec7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2aff29aff613d9023bb26d7a8bc5b4ee3ee2ec7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57e5d43c770201d837298175a2d55818867bdb33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57e5d43c770201d837298175a2d55818867bdb33", "html_url": "https://github.com/rust-lang/rust/commit/57e5d43c770201d837298175a2d55818867bdb33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57e5d43c770201d837298175a2d55818867bdb33/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "953c3b5f502437398711ca442be0a10ad575b667", "url": "https://api.github.com/repos/rust-lang/rust/commits/953c3b5f502437398711ca442be0a10ad575b667", "html_url": "https://github.com/rust-lang/rust/commit/953c3b5f502437398711ca442be0a10ad575b667"}, {"sha": "e8ab71fa00f2264f4587ca536e93b909a9358e27", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8ab71fa00f2264f4587ca536e93b909a9358e27", "html_url": "https://github.com/rust-lang/rust/commit/e8ab71fa00f2264f4587ca536e93b909a9358e27"}], "stats": {"total": 1337, "additions": 913, "deletions": 424}, "files": [{"sha": "6591812280122067c5ec3aee46686d7f4616c070", "filename": "mk/rt.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -157,6 +157,8 @@ else ifeq ($(findstring android, $(OSTYPE_$(1))), android)\n   # If the test suite passes, however, without symbol prefixes then we should be\n   # good to go!\n   JEMALLOC_ARGS_$(1) := --disable-tls --with-jemalloc-prefix=je_\n+else ifeq ($(findstring dragonfly, $(OSTYPE_$(1))), dragonfly)\n+  JEMALLOC_ARGS_$(1) := --with-jemalloc-prefix=je_\n endif\n \n ifdef CFG_ENABLE_DEBUG_JEMALLOC"}, {"sha": "5d521913b48f3b1d30ce2689d90a784ee949ef87", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -86,6 +86,8 @@ fn main() {\n         // should be good to go!\n         cmd.arg(\"--with-jemalloc-prefix=je_\");\n         cmd.arg(\"--disable-tls\");\n+    } else if target.contains(\"dragonfly\") {\n+        cmd.arg(\"--with-jemalloc-prefix=je_\");\n     }\n \n     if cfg!(feature = \"debug-jemalloc\") {"}, {"sha": "3a30bebec547889c4f1772b1b33d43849cb9b7d7", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -42,22 +42,27 @@ use libc::{c_int, c_void, size_t};\n extern {}\n \n // Note that the symbols here are prefixed by default on OSX (we don't\n-// explicitly request it), and on Android we explicitly request it as\n-// unprefixing cause segfaults (mismatches in allocators).\n+// explicitly request it), and on Android and DragonFly we explicitly request\n+// it as unprefixing cause segfaults (mismatches in allocators).\n extern {\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\"),\n+    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                   target_os = \"dragonfly\"),\n                link_name = \"je_mallocx\")]\n     fn mallocx(size: size_t, flags: c_int) -> *mut c_void;\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\"),\n+    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                   target_os = \"dragonfly\"),\n                link_name = \"je_rallocx\")]\n     fn rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\"),\n+    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                   target_os = \"dragonfly\"),\n                link_name = \"je_xallocx\")]\n     fn xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\"),\n+    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                   target_os = \"dragonfly\"),\n                link_name = \"je_sdallocx\")]\n     fn sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\"),\n+    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                   target_os = \"dragonfly\"),\n                link_name = \"je_nallocx\")]\n     fn nallocx(size: size_t, flags: c_int) -> size_t;\n }"}, {"sha": "67669c54ac5eb047ffdd1322df97c638173e71e6", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -37,7 +37,7 @@ use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n-use super::{InferCtxt};\n+use super::InferCtxt;\n use super::{MiscVariable, TypeTrace};\n use super::type_variable::{RelationDir, BiTo, EqTo, SubtypeOf, SupertypeOf};\n \n@@ -46,6 +46,7 @@ use ty::{self, Ty, TyCtxt};\n use ty::error::TypeError;\n use ty::fold::{TypeFolder, TypeFoldable};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n+use traits::PredicateObligations;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -56,6 +57,7 @@ pub struct CombineFields<'a, 'tcx: 'a> {\n     pub a_is_expected: bool,\n     pub trace: TypeTrace<'tcx>,\n     pub cause: Option<ty::relate::Cause>,\n+    pub obligations: PredicateObligations<'tcx>,\n }\n \n pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,"}, {"sha": "5540046c9e36345f4a082f8ebbb6ec72c5aa2a88", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -16,6 +16,7 @@ use super::type_variable::{EqTo};\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n+use traits::PredicateObligations;\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n pub struct Equate<'a, 'tcx: 'a> {\n@@ -26,6 +27,10 @@ impl<'a, 'tcx> Equate<'a, 'tcx> {\n     pub fn new(fields: CombineFields<'a, 'tcx>) -> Equate<'a, 'tcx> {\n         Equate { fields: fields }\n     }\n+\n+    pub fn obligations(self) -> PredicateObligations<'tcx> {\n+        self.fields.obligations\n+    }\n }\n \n impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {"}, {"sha": "37717c2b6bc99dab3541b2106b9720b358773552", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -16,6 +16,7 @@ use super::Subtype;\n \n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n+use traits::PredicateObligations;\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'a, 'tcx: 'a> {\n@@ -26,6 +27,10 @@ impl<'a, 'tcx> Glb<'a, 'tcx> {\n     pub fn new(fields: CombineFields<'a, 'tcx>) -> Glb<'a, 'tcx> {\n         Glb { fields: fields }\n     }\n+\n+    pub fn obligations(self) -> PredicateObligations<'tcx> {\n+        self.fields.obligations\n+    }\n }\n \n impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx> {"}, {"sha": "32b2fe911e86dda8375c4d552faeaf019b1859e2", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -16,6 +16,7 @@ use super::Subtype;\n \n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n+use traits::PredicateObligations;\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'a, 'tcx: 'a> {\n@@ -26,6 +27,10 @@ impl<'a, 'tcx> Lub<'a, 'tcx> {\n     pub fn new(fields: CombineFields<'a, 'tcx>) -> Lub<'a, 'tcx> {\n         Lub { fields: fields }\n     }\n+\n+    pub fn obligations(self) -> PredicateObligations<'tcx> {\n+        self.fields.obligations\n+    }\n }\n \n impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx> {"}, {"sha": "e22fb98890438c77f45a4045a2a73e1c5aec089f", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 61, "deletions": 36, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -27,13 +27,13 @@ use middle::region::CodeExtent;\n use ty::subst;\n use ty::subst::Substs;\n use ty::subst::Subst;\n-use traits::{self, ProjectionMode};\n use ty::adjustment;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::{TypeFolder, TypeFoldable};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n+use traits::{self, PredicateObligations, ProjectionMode};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{RefCell, Ref};\n use std::fmt;\n@@ -63,6 +63,12 @@ pub mod sub;\n pub mod type_variable;\n pub mod unify_key;\n \n+pub struct InferOk<'tcx, T> {\n+    pub value: T,\n+    pub obligations: PredicateObligations<'tcx>,\n+}\n+pub type InferResult<'tcx, T> = Result<InferOk<'tcx, T>, TypeError<'tcx>>;\n+\n pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n@@ -391,16 +397,15 @@ pub fn mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                           origin: TypeOrigin,\n                           a: Ty<'tcx>,\n                           b: Ty<'tcx>)\n-                          -> UnitResult<'tcx>\n+    -> InferResult<'tcx, ()>\n {\n     debug!(\"mk_subty({:?} <: {:?})\", a, b);\n     cx.sub_types(a_is_expected, origin, a, b)\n }\n \n-pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                              a: Ty<'tcx>,\n-                              b: Ty<'tcx>)\n-                              -> UnitResult<'tcx> {\n+pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n+    -> UnitResult<'tcx>\n+{\n     debug!(\"can_mk_subty({:?} <: {:?})\", a, b);\n     cx.probe(|_| {\n         let trace = TypeTrace {\n@@ -412,7 +417,7 @@ pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n }\n \n pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n-                             -> UnitResult<'tcx>\n+    -> UnitResult<'tcx>\n {\n     cx.can_equate(&a, &b)\n }\n@@ -432,7 +437,7 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                          origin: TypeOrigin,\n                          a: Ty<'tcx>,\n                          b: Ty<'tcx>)\n-                         -> UnitResult<'tcx>\n+    -> InferResult<'tcx, ()>\n {\n     debug!(\"mk_eqty({:?} <: {:?})\", a, b);\n     cx.eq_types(a_is_expected, origin, a, b)\n@@ -443,7 +448,7 @@ pub fn mk_eq_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                   origin: TypeOrigin,\n                                   a: ty::TraitRef<'tcx>,\n                                   b: ty::TraitRef<'tcx>)\n-                                  -> UnitResult<'tcx>\n+    -> InferResult<'tcx, ()>\n {\n     debug!(\"mk_eq_trait_refs({:?} = {:?})\", a, b);\n     cx.eq_trait_refs(a_is_expected, origin, a, b)\n@@ -454,7 +459,7 @@ pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                         origin: TypeOrigin,\n                                         a: ty::PolyTraitRef<'tcx>,\n                                         b: ty::PolyTraitRef<'tcx>)\n-                                        -> UnitResult<'tcx>\n+    -> InferResult<'tcx, ()>\n {\n     debug!(\"mk_sub_poly_trait_refs({:?} <: {:?})\", a, b);\n     cx.sub_poly_trait_refs(a_is_expected, origin, a, b)\n@@ -465,7 +470,7 @@ pub fn mk_eq_impl_headers<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                     origin: TypeOrigin,\n                                     a: &ty::ImplHeader<'tcx>,\n                                     b: &ty::ImplHeader<'tcx>)\n-                                    -> UnitResult<'tcx>\n+    -> InferResult<'tcx, ()>\n {\n     debug!(\"mk_eq_impl_header({:?} = {:?})\", a, b);\n     match (a.trait_ref, b.trait_ref) {\n@@ -574,6 +579,12 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     Ok(infcx.tcx.erase_regions(&result))\n }\n \n+impl<'tcx, T> InferOk<'tcx, T> {\n+    fn unit(self) -> InferOk<'tcx, ()> {\n+        InferOk { value: (), obligations: self.obligations }\n+    }\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn projection_mode(&self) -> ProjectionMode {\n         self.projection_mode\n@@ -661,39 +672,51 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     fn combine_fields(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                      -> CombineFields<'a, 'tcx> {\n-        CombineFields {infcx: self,\n-                       a_is_expected: a_is_expected,\n-                       trace: trace,\n-                       cause: None}\n+        -> CombineFields<'a, 'tcx>\n+    {\n+        CombineFields {\n+            infcx: self,\n+            a_is_expected: a_is_expected,\n+            trace: trace,\n+            cause: None,\n+            obligations: PredicateObligations::new(),\n+        }\n     }\n \n     pub fn equate<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> RelateResult<'tcx, T>\n+        -> InferResult<'tcx, T>\n         where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).equate().relate(a, b)\n+        let mut equate = self.combine_fields(a_is_expected, trace).equate();\n+        let result = equate.relate(a, b);\n+        result.map(|t| InferOk { value: t, obligations: equate.obligations() })\n     }\n \n     pub fn sub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> RelateResult<'tcx, T>\n+        -> InferResult<'tcx, T>\n         where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).sub().relate(a, b)\n+        let mut sub = self.combine_fields(a_is_expected, trace).sub();\n+        let result = sub.relate(a, b);\n+        result.map(|t| InferOk { value: t, obligations: sub.obligations() })\n     }\n \n     pub fn lub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> RelateResult<'tcx, T>\n+        -> InferResult<'tcx, T>\n         where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).lub().relate(a, b)\n+        let mut lub = self.combine_fields(a_is_expected, trace).lub();\n+        let result = lub.relate(a, b);\n+        result.map(|t| InferOk { value: t, obligations: lub.obligations() })\n     }\n \n     pub fn glb<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> RelateResult<'tcx, T>\n+        -> InferResult<'tcx, T>\n         where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).glb().relate(a, b)\n+        let mut glb = self.combine_fields(a_is_expected, trace).glb();\n+        let result = glb.relate(a, b);\n+        result.map(|t| InferOk { value: t, obligations: glb.obligations() })\n     }\n \n     fn start_snapshot(&self) -> CombinedSnapshot {\n@@ -829,12 +852,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                      origin: TypeOrigin,\n                      a: Ty<'tcx>,\n                      b: Ty<'tcx>)\n-                     -> UnitResult<'tcx>\n+        -> InferResult<'tcx, ()>\n     {\n         debug!(\"sub_types({:?} <: {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.sub(a_is_expected, trace, &a, &b).map(|_| ())\n+            self.sub(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n@@ -843,11 +866,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     origin: TypeOrigin,\n                     a: Ty<'tcx>,\n                     b: Ty<'tcx>)\n-                    -> UnitResult<'tcx>\n+        -> InferResult<'tcx, ()>\n     {\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.equate(a_is_expected, trace, &a, &b).map(|_| ())\n+            self.equate(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n@@ -856,7 +879,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                           origin: TypeOrigin,\n                           a: ty::TraitRef<'tcx>,\n                           b: ty::TraitRef<'tcx>)\n-                          -> UnitResult<'tcx>\n+        -> InferResult<'tcx, ()>\n     {\n         debug!(\"eq_trait_refs({:?} <: {:?})\",\n                a,\n@@ -866,7 +889,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.equate(a_is_expected, trace, &a, &b).map(|_| ())\n+            self.equate(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n@@ -875,7 +898,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                origin: TypeOrigin,\n                                a: ty::PolyTraitRef<'tcx>,\n                                b: ty::PolyTraitRef<'tcx>)\n-                               -> UnitResult<'tcx>\n+        -> InferResult<'tcx, ()>\n     {\n         debug!(\"sub_poly_trait_refs({:?} <: {:?})\",\n                a,\n@@ -885,7 +908,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: PolyTraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace, &a, &b).map(|_| ())\n+            self.sub(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n@@ -928,20 +951,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn equality_predicate(&self,\n                               span: Span,\n                               predicate: &ty::PolyEquatePredicate<'tcx>)\n-                              -> UnitResult<'tcx> {\n+        -> InferResult<'tcx, ()>\n+    {\n         self.commit_if_ok(|snapshot| {\n             let (ty::EquatePredicate(a, b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = TypeOrigin::EquatePredicate(span);\n-            let () = mk_eqty(self, false, origin, a, b)?;\n-            self.leak_check(&skol_map, snapshot)\n+            let eqty_ok = mk_eqty(self, false, origin, a, b)?;\n+            self.leak_check(&skol_map, snapshot).map(|_| eqty_ok.unit())\n         })\n     }\n \n     pub fn region_outlives_predicate(&self,\n                                      span: Span,\n                                      predicate: &ty::PolyRegionOutlivesPredicate)\n-                                     -> UnitResult<'tcx> {\n+        -> UnitResult<'tcx>\n+    {\n         self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);"}, {"sha": "ece8c0c696af83ad35acc7646a447bda1f118204", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -16,6 +16,7 @@ use super::type_variable::{SubtypeOf, SupertypeOf};\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n+use traits::PredicateObligations;\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n@@ -27,6 +28,10 @@ impl<'a, 'tcx> Sub<'a, 'tcx> {\n     pub fn new(f: CombineFields<'a, 'tcx>) -> Sub<'a, 'tcx> {\n         Sub { fields: f }\n     }\n+\n+    pub fn obligations(self) -> PredicateObligations<'tcx> {\n+        self.fields.obligations\n+    }\n }\n \n impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {"}, {"sha": "1573d0c4292ac047fc66028c07e8484a5ae1408f", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -179,6 +179,12 @@ declare_lint! {\n     \"lints that have been renamed or removed\"\n }\n \n+declare_lint! {\n+    pub SUPER_OR_SELF_IN_GLOBAL_PATH,\n+    Warn,\n+    \"detects super or self keywords at the beginning of global path\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -213,7 +219,8 @@ impl LintPass for HardwiredLints {\n             RAW_POINTER_DERIVE,\n             TRANSMUTE_FROM_FN_ITEM_TYPES,\n             OVERLAPPING_INHERENT_IMPLS,\n-            RENAMED_AND_REMOVED_LINTS\n+            RENAMED_AND_REMOVED_LINTS,\n+            SUPER_OR_SELF_IN_GLOBAL_PATH\n         )\n     }\n }"}, {"sha": "4451e7ac472e544c463c49c35c6c74359d4b41f1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -1502,7 +1502,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 } else {\n                     let ends_with_stmt = match body.expr {\n                         None if !body.stmts.is_empty() =>\n-                            match body.stmts.first().unwrap().node {\n+                            match body.stmts.last().unwrap().node {\n                                 hir::StmtSemi(ref e, _) => {\n                                     self.ir.tcx.expr_ty(&e) == t_ret\n                                 },\n@@ -1515,7 +1515,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                                                    E0269,\n                                                    \"not all control paths return a value\");\n                     if ends_with_stmt {\n-                        let last_stmt = body.stmts.first().unwrap();\n+                        let last_stmt = body.stmts.last().unwrap();\n                         let original_span = original_sp(self.ir.tcx.sess.codemap(),\n                                                         last_stmt.span, sp);\n                         let span_semicolon = Span {"}, {"sha": "11e8dae8717649577970d340f2bfab536e78b492", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use dep_graph::DepGraph;\n-use infer::InferCtxt;\n+use infer::{InferCtxt, InferOk};\n use ty::{self, Ty, TyCtxt, TypeFoldable, ToPolyTraitRef};\n use rustc_data_structures::obligation_forest::{Backtrace, ObligationForest, Error};\n use std::iter;\n@@ -580,7 +580,11 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n \n         ty::Predicate::Equate(ref binder) => {\n             match selcx.infcx().equality_predicate(obligation.cause.span, binder) {\n-                Ok(()) => Ok(Some(Vec::new())),\n+                Ok(InferOk { obligations, .. }) => {\n+                    // FIXME(#32730) propagate obligations\n+                    assert!(obligations.is_empty());\n+                    Ok(Some(Vec::new()))\n+                },\n                 Err(_) => Err(CodeSelectionError(Unimplemented)),\n             }\n         }"}, {"sha": "d4d61ec024471b1e39f118ff484676e8664a0e3a", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -24,7 +24,7 @@ use super::VtableImplData;\n use super::util;\n \n use middle::def_id::DefId;\n-use infer::{self, TypeOrigin};\n+use infer::{self, InferOk, TypeOrigin};\n use ty::subst::Subst;\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n@@ -232,7 +232,11 @@ fn project_and_unify_type<'cx,'tcx>(\n     let infcx = selcx.infcx();\n     let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n     match infer::mk_eqty(infcx, true, origin, normalized_ty, obligation.predicate.ty) {\n-        Ok(()) => Ok(Some(obligations)),\n+        Ok(InferOk { obligations: inferred_obligations, .. }) => {\n+            // FIXME(#32730) propagate obligations\n+            assert!(inferred_obligations.is_empty());\n+            Ok(Some(obligations))\n+        },\n         Err(err) => Err(MismatchedProjectionTypes { err: err }),\n     }\n }\n@@ -278,7 +282,10 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n             let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n             let obligation_ty = obligation.predicate.ty;\n             match infer::mk_eqty(infcx, true, origin, obligation_ty, ret_type) {\n-                Ok(()) => { }\n+                Ok(InferOk { obligations, .. }) => {\n+                    // FIXME(#32730) propagate obligations\n+                    assert!(obligations.is_empty());\n+                }\n                 Err(_) => { /* ignore errors */ }\n             }\n         }\n@@ -829,7 +836,10 @@ fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n                     infcx.sub_poly_trait_refs(false,\n                                               origin,\n                                               data_poly_trait_ref,\n-                                              obligation_poly_trait_ref).is_ok()\n+                                              obligation_poly_trait_ref)\n+                        // FIXME(#32730) propagate obligations\n+                        .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+                        .is_ok()\n                 });\n \n                 debug!(\"assemble_candidates_from_predicates: candidate={:?} \\\n@@ -1082,7 +1092,10 @@ fn confirm_param_env_candidate<'cx,'tcx>(\n                               origin,\n                               obligation.predicate.trait_ref.clone(),\n                               projection.projection_ty.trait_ref.clone()) {\n-        Ok(()) => { }\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#32730) propagate obligations\n+            assert!(obligations.is_empty());\n+        }\n         Err(e) => {\n             span_bug!(\n                 obligation.cause.span,"}, {"sha": "f68386feddb59641c2fa5546a19a8244b510d8a3", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 50, "deletions": 33, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -38,7 +38,7 @@ use super::util;\n \n use middle::def_id::DefId;\n use infer;\n-use infer::{InferCtxt, TypeFreshener, TypeOrigin};\n+use infer::{InferCtxt, InferOk, TypeFreshener, TypeOrigin};\n use ty::subst::{Subst, Substs, TypeSpace};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use traits;\n@@ -484,7 +484,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::Predicate::Equate(ref p) => {\n                 // does this code ever run?\n                 match self.infcx.equality_predicate(obligation.cause.span, p) {\n-                    Ok(()) => EvaluatedToOk,\n+                    Ok(InferOk { obligations, .. }) => {\n+                        // FIXME(#32730) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        EvaluatedToOk\n+                    },\n                     Err(_) => EvaluatedToErr\n                 }\n             }\n@@ -1185,7 +1189,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                              origin,\n                                              trait_bound.clone(),\n                                              ty::Binder(skol_trait_ref.clone())) {\n-            Ok(()) => { }\n+            Ok(InferOk { obligations, .. }) => {\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n+            }\n             Err(_) => { return false; }\n         }\n \n@@ -2487,13 +2494,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let origin = TypeOrigin::RelateOutputImplTypes(obligation_cause.span);\n \n         let obligation_trait_ref = obligation_trait_ref.clone();\n-        match self.infcx.sub_poly_trait_refs(false,\n-                                             origin,\n-                                             expected_trait_ref.clone(),\n-                                             obligation_trait_ref.clone()) {\n-            Ok(()) => Ok(()),\n-            Err(e) => Err(OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n-        }\n+        self.infcx.sub_poly_trait_refs(false,\n+                                       origin,\n+                                       expected_trait_ref.clone(),\n+                                       obligation_trait_ref.clone())\n+            // FIXME(#32730) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+            .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n     }\n \n     fn confirm_builtin_unsize_candidate(&mut self,\n@@ -2524,9 +2531,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 let new_trait = tcx.mk_trait(data_a.principal.clone(), bounds);\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n-                if self.infcx.sub_types(false, origin, new_trait, target).is_err() {\n-                    return Err(Unimplemented);\n-                }\n+                let InferOk { obligations, .. } =\n+                    self.infcx.sub_types(false, origin, new_trait, target)\n+                    .map_err(|_| Unimplemented)?;\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n \n                 // Register one obligation for 'a: 'b.\n                 let cause = ObligationCause::new(obligation.cause.span,\n@@ -2589,9 +2598,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // [T; n] -> [T].\n             (&ty::TyArray(a, _), &ty::TySlice(b)) => {\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n-                if self.infcx.sub_types(false, origin, a, b).is_err() {\n-                    return Err(Unimplemented);\n-                }\n+                let InferOk { obligations, .. } =\n+                    self.infcx.sub_types(false, origin, a, b)\n+                    .map_err(|_| Unimplemented)?;\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n             }\n \n             // Struct<T> -> Struct<U>.\n@@ -2647,9 +2658,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n                 let new_struct = tcx.mk_struct(def, tcx.mk_substs(new_substs));\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n-                if self.infcx.sub_types(false, origin, new_struct, target).is_err() {\n-                    return Err(Unimplemented);\n-                }\n+                let InferOk { obligations, .. } =\n+                    self.infcx.sub_types(false, origin, new_struct, target)\n+                    .map_err(|_| Unimplemented)?;\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n \n                 // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n                 nested.push(util::predicate_for_trait_def(tcx,\n@@ -2734,13 +2747,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                skol_obligation_trait_ref);\n \n         let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n-        if let Err(e) = self.infcx.eq_trait_refs(false,\n-                                                 origin,\n-                                                 impl_trait_ref.value.clone(),\n-                                                 skol_obligation_trait_ref) {\n-            debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n-            return Err(());\n-        }\n+        let InferOk { obligations, .. } =\n+            self.infcx.eq_trait_refs(false,\n+                                     origin,\n+                                     impl_trait_ref.value.clone(),\n+                                     skol_obligation_trait_ref)\n+            .map_err(|e| {\n+                debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n+                ()\n+            })?;\n+        // FIXME(#32730) propagate obligations\n+        assert!(obligations.is_empty());\n \n         if let Err(e) = self.infcx.leak_check(&skol_map, snapshot) {\n             debug!(\"match_impl: failed leak check due to `{}`\", e);\n@@ -2803,13 +2820,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                poly_trait_ref);\n \n         let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n-        match self.infcx.sub_poly_trait_refs(false,\n-                                             origin,\n-                                             poly_trait_ref,\n-                                             obligation.predicate.to_poly_trait_ref()) {\n-            Ok(()) => Ok(()),\n-            Err(_) => Err(()),\n-        }\n+        self.infcx.sub_poly_trait_refs(false,\n+                                       origin,\n+                                       poly_trait_ref,\n+                                       obligation.predicate.to_poly_trait_ref())\n+            // FIXME(#32730) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+            .map_err(|_| ())\n     }\n \n     ///////////////////////////////////////////////////////////////////////////"}, {"sha": "ce0d42203b987baf56ebe03fe2d0e3e64adb98df", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -24,8 +24,8 @@ use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n use rustc::traits::ProjectionMode;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::relate::{TypeRelation, RelateResult};\n-use rustc::infer::{self, TypeOrigin};\n+use rustc::ty::relate::TypeRelation;\n+use rustc::infer::{self, InferOk, InferResult, TypeOrigin};\n use rustc_metadata::cstore::CStore;\n use rustc::front::map as hir_map;\n use rustc::session::{self, config};\n@@ -355,17 +355,17 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         infer::TypeTrace::dummy(self.tcx())\n     }\n \n-    pub fn sub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+    pub fn sub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n         self.infcx.sub(true, trace, t1, t2)\n     }\n \n-    pub fn lub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+    pub fn lub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n         self.infcx.lub(true, trace, t1, t2)\n     }\n \n-    pub fn glb(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+    pub fn glb(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n         self.infcx.glb(true, trace, t1, t2)\n     }\n@@ -374,7 +374,10 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n         match self.sub(&t1, &t2) {\n-            Ok(_) => {}\n+            Ok(InferOk { obligations, .. }) => {\n+                // FIXME(#32730) once obligations are being propagated, assert the right thing.\n+                assert!(obligations.is_empty());\n+            }\n             Err(ref e) => {\n                 panic!(\"unexpected error computing sub({:?},{:?}): {}\", t1, t2, e);\n             }\n@@ -395,7 +398,10 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `LUB(t1,t2) == t_lub`\n     pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n         match self.lub(&t1, &t2) {\n-            Ok(t) => {\n+            Ok(InferOk { obligations, value: t }) => {\n+                // FIXME(#32730) once obligations are being propagated, assert the right thing.\n+                assert!(obligations.is_empty());\n+\n                 self.assert_eq(t, t_lub);\n             }\n             Err(ref e) => {\n@@ -411,7 +417,10 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             Err(e) => {\n                 panic!(\"unexpected error computing LUB: {:?}\", e)\n             }\n-            Ok(t) => {\n+            Ok(InferOk { obligations, value: t }) => {\n+                // FIXME(#32730) once obligations are being propagated, assert the right thing.\n+                assert!(obligations.is_empty());\n+\n                 self.assert_eq(t, t_glb);\n \n                 // sanity check for good measure:"}, {"sha": "0780e4cd04834ff2f6437808f40b1db2a13fdadf", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -167,6 +167,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(INVALID_TYPE_PARAM_DEFAULT),\n             reference: \"PR 30742 <https://github.com/rust-lang/rust/pull/30724>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(SUPER_OR_SELF_IN_GLOBAL_PATH),\n+            reference: \"PR #32403 <https://github.com/rust-lang/rust/pull/32403>\",\n+        },\n         FutureIncompatibleInfo {\n             id: LintId::of(MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT),\n             reference: \"RFC 218 <https://github.com/rust-lang/rfcs/blob/\\"}, {"sha": "ce8ede7f4b9592be12d82a5caf829bc507c81e67", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -12,7 +12,7 @@\n #![allow(unreachable_code)]\n \n use rustc::dep_graph::DepNode;\n-use rustc::infer::{self, InferCtxt};\n+use rustc::infer::{self, InferCtxt, InferOk};\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -338,13 +338,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     {\n         infer::mk_subty(self.infcx, false, infer::TypeOrigin::Misc(span),\n                         sup, sub)\n+            // FIXME(#32730) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     fn mk_eqty(&self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n                 -> infer::UnitResult<'tcx>\n     {\n         infer::mk_eqty(self.infcx, false, infer::TypeOrigin::Misc(span),\n                        a, b)\n+            // FIXME(#32730) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     fn tcx(&self) -> &'a TyCtxt<'tcx> {"}, {"sha": "f36a8269dc002290d83bec2e34d835ef1b64e9c8", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -23,13 +23,14 @@ use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n use rustc::middle::cstore::{CrateStore, ChildItem, DlDef};\n+use rustc::lint;\n use rustc::middle::def::*;\n use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty::VariantKind;\n \n use syntax::ast::Name;\n use syntax::attr::AttrMetaMethods;\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::{special_idents, SELF_KEYWORD_NAME, SUPER_KEYWORD_NAME};\n use syntax::codemap::{Span, DUMMY_SP};\n \n use rustc_front::hir;\n@@ -116,8 +117,10 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 // Extract and intern the module part of the path. For\n                 // globs and lists, the path is found directly in the AST;\n                 // for simple paths we have to munge the path a little.\n-                let module_path = match view_path.node {\n+                let is_global;\n+                let module_path: Vec<Name> = match view_path.node {\n                     ViewPathSimple(_, ref full_path) => {\n+                        is_global = full_path.global;\n                         full_path.segments\n                                  .split_last()\n                                  .unwrap()\n@@ -129,13 +132,26 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n                     ViewPathGlob(ref module_ident_path) |\n                     ViewPathList(ref module_ident_path, _) => {\n+                        is_global = module_ident_path.global;\n                         module_ident_path.segments\n                                          .iter()\n                                          .map(|seg| seg.identifier.name)\n                                          .collect()\n                     }\n                 };\n \n+                // Checking for special identifiers in path\n+                // prevent `self` or `super` at beginning of global path\n+                if is_global && (module_path.first() == Some(&SELF_KEYWORD_NAME) ||\n+                                 module_path.first() == Some(&SUPER_KEYWORD_NAME)) {\n+                    self.session.add_lint(\n+                        lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH,\n+                        item.id,\n+                        item.span,\n+                        format!(\"expected identifier, found keyword `{}`\",\n+                                module_path.first().unwrap().as_str()));\n+                }\n+\n                 // Build up the import directives.\n                 let is_prelude = item.attrs.iter().any(|attr| {\n                     attr.name() == special_idents::prelude_import.name.as_str()"}, {"sha": "55c3a5add37bb9e96ff59e78b8fc9c55e1c331b9", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::def::{self, Def};\n-use rustc::infer::{self, TypeOrigin};\n+use rustc::infer::{self, InferOk, TypeOrigin};\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n use middle::pat_util::pat_is_resolved_const;\n use rustc::ty::subst::Substs;\n@@ -531,7 +531,12 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n         let result = if is_if_let_fallback {\n-            fcx.infcx().eq_types(true, origin, arm_ty, result_ty).map(|_| arm_ty)\n+            fcx.infcx().eq_types(true, origin, arm_ty, result_ty)\n+                .map(|InferOk { obligations, .. }| {\n+                    // FIXME(#32730) propagate obligations\n+                    assert!(obligations.is_empty());\n+                    arm_ty\n+                })\n         } else if i == 0 {\n             // Special-case the first arm, as it has no \"previous expressions\".\n             coercion::try(fcx, &arm.body, coerce_first)"}, {"sha": "cafd0519c2821645ae939f4149f502fb43445689", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -62,7 +62,7 @@\n \n use check::{autoderef, FnCtxt, UnresolvedTypeAction};\n \n-use rustc::infer::{Coercion, TypeOrigin, TypeTrace};\n+use rustc::infer::{Coercion, InferOk, TypeOrigin, TypeTrace};\n use rustc::traits::{self, ObligationCause};\n use rustc::traits::{predicate_for_trait_def, report_selection_error};\n use rustc::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n@@ -118,8 +118,18 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             let trace = TypeTrace::types(self.origin, false, a, b);\n             if self.use_lub {\n                 infcx.lub(false, trace, &a, &b)\n+                    .map(|InferOk { value, obligations }| {\n+                        // FIXME(#32730) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        value\n+                    })\n             } else {\n                 infcx.sub(false, trace, &a, &b)\n+                    .map(|InferOk { value, obligations }| {\n+                        // FIXME(#32730) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        value\n+                    })\n             }\n         })\n     }\n@@ -655,12 +665,22 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n         (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n          &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n             // The signature must always match.\n-            let fty = fcx.infcx().lub(true, trace.clone(), a_fty, b_fty)?;\n+            let fty = fcx.infcx().lub(true, trace.clone(), a_fty, b_fty)\n+                .map(|InferOk { value, obligations }| {\n+                    // FIXME(#32730) propagate obligations\n+                    assert!(obligations.is_empty());\n+                    value\n+                })?;\n \n             if a_def_id == b_def_id {\n                 // Same function, maybe the parameters match.\n                 let substs = fcx.infcx().commit_if_ok(|_| {\n                     fcx.infcx().lub(true, trace.clone(), a_substs, b_substs)\n+                        .map(|InferOk { value, obligations }| {\n+                            // FIXME(#32730) propagate obligations\n+                            assert!(obligations.is_empty());\n+                            value\n+                        })\n                 }).map(|s| fcx.tcx().mk_substs(s));\n \n                 if let Ok(substs) = substs {\n@@ -724,6 +744,11 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n         if !noop {\n             return fcx.infcx().commit_if_ok(|_| {\n                 fcx.infcx().lub(true, trace.clone(), &prev_ty, &new_ty)\n+                    .map(|InferOk { value, obligations }| {\n+                        // FIXME(#32730) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        value\n+                    })\n             });\n         }\n     }\n@@ -736,6 +761,11 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n             } else {\n                 fcx.infcx().commit_if_ok(|_| {\n                     fcx.infcx().lub(true, trace, &prev_ty, &new_ty)\n+                        .map(|InferOk { value, obligations }| {\n+                            // FIXME(#32730) propagate obligations\n+                            assert!(obligations.is_empty());\n+                            value\n+                        })\n                 })\n             }\n         }"}, {"sha": "3c12ab8d59840ea61ade8994d21005ed7ca109f8", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::free_region::FreeRegionMap;\n-use rustc::infer::{self, TypeOrigin};\n+use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty::{self, TyCtxt};\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace};\n@@ -475,7 +475,10 @@ pub fn compare_const_impl<'tcx>(tcx: &TyCtxt<'tcx>,\n     });\n \n     match err {\n-        Ok(()) => { }\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#32730) propagate obligations\n+            assert!(obligations.is_empty())\n+        }\n         Err(terr) => {\n             debug!(\"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n                    impl_ty,"}, {"sha": "bc2ef9aafee59d4b669000991d0f8b7606ba0d18", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -11,7 +11,7 @@\n \n use check::{coercion, FnCtxt};\n use rustc::ty::Ty;\n-use rustc::infer::TypeOrigin;\n+use rustc::infer::{InferOk, TypeOrigin};\n \n use syntax::codemap::Span;\n use rustc_front::hir;\n@@ -21,16 +21,28 @@ use rustc_front::hir;\n pub fn suptype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n                          expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     let origin = TypeOrigin::Misc(sp);\n-    if let Err(e) = fcx.infcx().sub_types(false, origin, actual, expected) {\n-        fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n+    match fcx.infcx().sub_types(false, origin, actual, expected) {\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#32730) propagate obligations\n+            assert!(obligations.is_empty());\n+        },\n+        Err(e) => {\n+            fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n+        }\n     }\n }\n \n pub fn eqtype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     let origin = TypeOrigin::Misc(sp);\n-    if let Err(e) = fcx.infcx().eq_types(false, origin, actual, expected) {\n-        fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n+    match fcx.infcx().eq_types(false, origin, actual, expected) {\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#32730) propagate obligations\n+            assert!(obligations.is_empty());\n+        },\n+        Err(e) => {\n+            fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n+        }\n     }\n }\n "}, {"sha": "2e15ac0e13084d3fb7dba28f99dee9d282e3fc21", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -21,8 +21,7 @@ use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n use rustc::traits;\n use rustc::ty::{self, NoPreference, Ty, TyCtxt, ToPolyTraitRef, TraitRef, TypeFoldable};\n-use rustc::infer;\n-use rustc::infer::{InferCtxt, TypeOrigin};\n+use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin};\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n use rustc_front::hir;\n@@ -1151,6 +1150,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn make_sub_ty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>) -> infer::UnitResult<'tcx> {\n         self.infcx().sub_types(false, TypeOrigin::Misc(DUMMY_SP), sub, sup)\n+            // FIXME(#32730) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     fn has_applicable_self(&self, item: &ty::ImplOrTraitItem) -> bool {"}, {"sha": "32b5a63817ea5e7cd586df4e9d07256b6e988e30", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -14,14 +14,15 @@\n use CrateCtxt;\n \n use astconv::AstConv;\n-use check::{self, FnCtxt};\n+use check::{self, FnCtxt, UnresolvedTypeAction, autoderef};\n use front::map as hir_map;\n use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use middle::cstore::{self, CrateStore};\n use middle::def::Def;\n use middle::def_id::DefId;\n use middle::lang_items::FnOnceTraitLangItem;\n use rustc::ty::subst::Substs;\n+use rustc::ty::LvaluePreference;\n use rustc::traits::{Obligation, SelectionContext};\n use util::nodemap::{FnvHashSet};\n \n@@ -50,23 +51,37 @@ fn is_fn_ty<'a, 'tcx>(ty: &Ty<'tcx>, fcx: &FnCtxt<'a, 'tcx>, span: Span) -> bool\n             if let Ok(fn_once_trait_did) =\n                     cx.lang_items.require(FnOnceTraitLangItem) {\n                 let infcx = fcx.infcx();\n-                infcx.probe(|_| {\n-                    let fn_once_substs =\n-                        Substs::new_trait(vec![infcx.next_ty_var()],\n-                                          Vec::new(),\n-                                          ty);\n-                    let trait_ref =\n-                      ty::TraitRef::new(fn_once_trait_did,\n-                                        cx.mk_substs(fn_once_substs));\n-                    let poly_trait_ref = trait_ref.to_poly_trait_ref();\n-                    let obligation = Obligation::misc(span,\n-                                                      fcx.body_id,\n-                                                      poly_trait_ref\n-                                                         .to_predicate());\n-                    let mut selcx = SelectionContext::new(infcx);\n-\n-                    return selcx.evaluate_obligation(&obligation)\n-                })\n+                let (_, _, opt_is_fn) = autoderef(fcx,\n+                                                  span,\n+                                                  ty,\n+                                                  || None,\n+                                                  UnresolvedTypeAction::Ignore,\n+                                                  LvaluePreference::NoPreference,\n+                                                  |ty, _| {\n+                    infcx.probe(|_| {\n+                        let fn_once_substs =\n+                            Substs::new_trait(vec![infcx.next_ty_var()],\n+                                              Vec::new(),\n+                                              ty);\n+                        let trait_ref =\n+                          ty::TraitRef::new(fn_once_trait_did,\n+                                            cx.mk_substs(fn_once_substs));\n+                        let poly_trait_ref = trait_ref.to_poly_trait_ref();\n+                        let obligation = Obligation::misc(span,\n+                                                          fcx.body_id,\n+                                                          poly_trait_ref\n+                                                             .to_predicate());\n+                        let mut selcx = SelectionContext::new(infcx);\n+\n+                        if selcx.evaluate_obligation(&obligation) {\n+                            Some(())\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                });\n+\n+                opt_is_fn.is_some()\n             } else {\n                 false\n             }"}, {"sha": "e485fbe1621c87413f2ff696d77ffaef97a04826", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -88,8 +88,7 @@ use middle::astconv_util::prohibit_type_params;\n use middle::cstore::LOCAL_CRATE;\n use middle::def::{self, Def};\n use middle::def_id::DefId;\n-use rustc::infer;\n-use rustc::infer::{TypeOrigin, TypeTrace, type_variable};\n+use rustc::infer::{self, InferOk, TypeOrigin, TypeTrace, type_variable};\n use middle::pat_util::{self, pat_id_map};\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n use rustc::traits::{self, report_fulfillment_errors, ProjectionMode};\n@@ -1627,6 +1626,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     sup: Ty<'tcx>)\n                     -> Result<(), TypeError<'tcx>> {\n         infer::mk_subty(self.infcx(), a_is_expected, origin, sub, sup)\n+            // FIXME(#32730) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     pub fn mk_eqty(&self,\n@@ -1636,6 +1637,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                    sup: Ty<'tcx>)\n                    -> Result<(), TypeError<'tcx>> {\n         infer::mk_eqty(self.infcx(), a_is_expected, origin, sub, sup)\n+            // FIXME(#32730) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     pub fn mk_subr(&self,\n@@ -1914,7 +1917,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     match infer::mk_eqty(self.infcx(), false,\n                                                          TypeOrigin::Misc(default.origin_span),\n                                                          ty, default.ty) {\n-                                        Ok(()) => {}\n+                                        Ok(InferOk { obligations, .. }) => {\n+                                            // FIXME(#32730) propagate obligations\n+                                            assert!(obligations.is_empty())\n+                                        },\n                                         Err(_) => {\n                                             conflicts.push((*ty, default));\n                                         }\n@@ -2007,7 +2013,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             match infer::mk_eqty(self.infcx(), false,\n                                                  TypeOrigin::Misc(default.origin_span),\n                                                  ty, default.ty) {\n-                                Ok(()) => {}\n+                                // FIXME(#32730) propagate obligations\n+                                Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n                                 Err(_) => {\n                                     result = Some(default);\n                                 }\n@@ -2773,8 +2780,10 @@ fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 let ures = fcx.infcx().sub_types(false, origin, formal_ret_ty, ret_ty);\n                 // FIXME(#15760) can't use try! here, FromError doesn't default\n                 // to identity so the resulting type is not constrained.\n-                if let Err(e) = ures {\n-                    return Err(e);\n+                match ures {\n+                    // FIXME(#32730) propagate obligations\n+                    Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n+                    Err(e) => return Err(e),\n                 }\n \n                 // Record all the argument types, with the substitutions\n@@ -2902,13 +2911,23 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 fcx.infcx().commit_if_ok(|_| {\n                     let trace = TypeTrace::types(origin, true, then_ty, else_ty);\n                     fcx.infcx().lub(true, trace, &then_ty, &else_ty)\n+                        .map(|InferOk { value, obligations }| {\n+                            // FIXME(#32730) propagate obligations\n+                            assert!(obligations.is_empty());\n+                            value\n+                        })\n                 })\n             };\n             (origin, then_ty, else_ty, result)\n         } else {\n             let origin = TypeOrigin::IfExpressionWithNoElse(sp);\n             (origin, unit, then_ty,\n-             fcx.infcx().eq_types(true, origin, unit, then_ty).map(|_| unit))\n+             fcx.infcx().eq_types(true, origin, unit, then_ty)\n+                 .map(|InferOk { obligations, .. }| {\n+                     // FIXME(#32730) propagate obligations\n+                     assert!(obligations.is_empty());\n+                     unit\n+                 }))\n         };\n \n         let if_ty = match result {"}, {"sha": "15bf6671de50129227a05570fe1fc311da5c0063", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -92,7 +92,7 @@ use middle::region::{self, CodeExtent};\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, MethodCall, TypeFoldable};\n-use rustc::infer::{self, GenericKind, InferCtxt, SubregionOrigin, TypeOrigin, VerifyBound};\n+use rustc::infer::{self, GenericKind, InferCtxt, InferOk, SubregionOrigin, TypeOrigin, VerifyBound};\n use middle::pat_util;\n use rustc::ty::adjustment;\n use rustc::ty::wf::ImpliedBound;\n@@ -1841,7 +1841,11 @@ fn declared_projection_bounds_from_trait<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n                 // check whether this predicate applies to our current projection\n                 match infer::mk_eqty(infcx, false, TypeOrigin::Misc(span), ty, outlives.0) {\n-                    Ok(()) => { Ok(outlives.1) }\n+                    Ok(InferOk { obligations, .. }) => {\n+                        // FIXME(#32730) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        Ok(outlives.1)\n+                    }\n                     Err(_) => { Err(()) }\n                 }\n             });"}, {"sha": "7437d6087718acbb1bc1b4b0d55faded67f7c441", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -14,7 +14,6 @@\n pub use self::Type::*;\n pub use self::PrimitiveType::*;\n pub use self::TypeKind::*;\n-pub use self::StructField::*;\n pub use self::VariantKind::*;\n pub use self::Mutability::*;\n pub use self::Import::*;\n@@ -53,6 +52,7 @@ use std::env::current_dir;\n use core::DocContext;\n use doctree;\n use visit_ast;\n+use html::item_type::ItemType;\n \n /// A stable identifier to the particular version of JSON output.\n /// Increment this when the `Crate` and related structures change.\n@@ -273,36 +273,49 @@ impl Item {\n     }\n     pub fn is_crate(&self) -> bool {\n         match self.inner {\n-            ModuleItem(Module { items: _, is_crate: true }) => true,\n-            _ => false\n+            StrippedItem(box ModuleItem(Module { is_crate: true, ..})) |\n+            ModuleItem(Module { is_crate: true, ..}) => true,\n+            _ => false,\n         }\n     }\n     pub fn is_mod(&self) -> bool {\n-        match self.inner { ModuleItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Module\n     }\n     pub fn is_trait(&self) -> bool {\n-        match self.inner { TraitItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Trait\n     }\n     pub fn is_struct(&self) -> bool {\n-        match self.inner { StructItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Struct\n     }\n     pub fn is_enum(&self) -> bool {\n-        match self.inner { EnumItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Module\n     }\n     pub fn is_fn(&self) -> bool {\n-        match self.inner { FunctionItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Function\n     }\n     pub fn is_associated_type(&self) -> bool {\n-        match self.inner { AssociatedTypeItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::AssociatedType\n     }\n     pub fn is_associated_const(&self) -> bool {\n-        match self.inner { AssociatedConstItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::AssociatedConst\n     }\n     pub fn is_method(&self) -> bool {\n-        match self.inner { MethodItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Method\n     }\n     pub fn is_ty_method(&self) -> bool {\n-        match self.inner { TyMethodItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::TyMethod\n+    }\n+    pub fn is_stripped(&self) -> bool {\n+        match self.inner { StrippedItem(..) => true, _ => false }\n+    }\n+    pub fn has_stripped_fields(&self) -> Option<bool> {\n+        match self.inner {\n+            StructItem(ref _struct) => Some(_struct.fields_stripped),\n+            VariantItem(Variant { kind: StructVariant(ref vstruct)} ) => {\n+                Some(vstruct.fields_stripped)\n+            },\n+            _ => None,\n+        }\n     }\n \n     pub fn stability_class(&self) -> String {\n@@ -341,7 +354,7 @@ pub enum ItemEnum {\n     TyMethodItem(TyMethod),\n     /// A method with a body.\n     MethodItem(Method),\n-    StructFieldItem(StructField),\n+    StructFieldItem(Type),\n     VariantItem(Variant),\n     /// `fn`s from an extern block\n     ForeignFunctionItem(Function),\n@@ -352,6 +365,8 @@ pub enum ItemEnum {\n     AssociatedConstItem(Type, Option<String>),\n     AssociatedTypeItem(Vec<TyParamBound>, Option<Type>),\n     DefaultImplItem(DefaultImpl),\n+    /// An item that has been stripped by a rustdoc pass\n+    StrippedItem(Box<ItemEnum>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -1733,12 +1748,6 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum StructField {\n-    HiddenStructField, // inserted later by strip passes\n-    TypedStructField(Type),\n-}\n-\n impl Clean<Item> for hir::StructField {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n@@ -1749,7 +1758,7 @@ impl Clean<Item> for hir::StructField {\n             stability: get_stability(cx, cx.map.local_def_id(self.id)),\n             deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n             def_id: cx.map.local_def_id(self.id),\n-            inner: StructFieldItem(TypedStructField(self.ty.clean(cx))),\n+            inner: StructFieldItem(self.ty.clean(cx)),\n         }\n     }\n }\n@@ -1766,7 +1775,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n             stability: get_stability(cx, self.did),\n             deprecation: get_deprecation(cx, self.did),\n             def_id: self.did,\n-            inner: StructFieldItem(TypedStructField(self.unsubst_ty().clean(cx))),\n+            inner: StructFieldItem(self.unsubst_ty().clean(cx)),\n         }\n     }\n }\n@@ -1897,9 +1906,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n                             def_id: field.did,\n                             stability: get_stability(cx, field.did),\n                             deprecation: get_deprecation(cx, field.did),\n-                            inner: StructFieldItem(\n-                                TypedStructField(field.unsubst_ty().clean(cx))\n-                            )\n+                            inner: StructFieldItem(field.unsubst_ty().clean(cx))\n                         }\n                     }).collect()\n                 })"}, {"sha": "5595c749256dfc7971a46edbd2b42c3b36806b7d", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -10,28 +10,50 @@\n \n use clean::*;\n \n+pub enum FoldItem {\n+    Retain(Item),\n+    Strip(Item),\n+    Erase,\n+}\n+\n+impl FoldItem {\n+    pub fn fold(self) -> Option<Item> {\n+        match self {\n+            FoldItem::Erase => None,\n+            FoldItem::Retain(i) => Some(i),\n+            FoldItem::Strip(item@ Item { inner: StrippedItem(..), .. } ) => Some(item),\n+            FoldItem::Strip(mut i) => {\n+                i.inner = StrippedItem(box i.inner);\n+                Some(i)\n+            }\n+        }\n+    }\n+}\n+\n pub trait DocFolder : Sized {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n         self.fold_item_recur(item)\n     }\n \n     /// don't override!\n-    fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n-        let Item { attrs, name, source, visibility, def_id, inner, stability, deprecation } = item;\n-        let inner = match inner {\n+    fn fold_inner_recur(&mut self, inner: ItemEnum) -> ItemEnum {\n+        match inner {\n+            StrippedItem(..) => unreachable!(),\n+            ModuleItem(i) => {\n+                ModuleItem(self.fold_mod(i))\n+            },\n             StructItem(mut i) => {\n                 let num_fields = i.fields.len();\n                 i.fields = i.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                i.fields_stripped |= num_fields != i.fields.len();\n+                i.fields_stripped |= num_fields != i.fields.len() ||\n+                                     i.fields.iter().any(|f| f.is_stripped());\n                 StructItem(i)\n             },\n-            ModuleItem(i) => {\n-                ModuleItem(self.fold_mod(i))\n-            },\n             EnumItem(mut i) => {\n                 let num_variants = i.variants.len();\n                 i.variants = i.variants.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                i.variants_stripped |= num_variants != i.variants.len();\n+                i.variants_stripped |= num_variants != i.variants.len() ||\n+                                       i.variants.iter().any(|f| f.is_stripped());\n                 EnumItem(i)\n             },\n             TraitItem(mut i) => {\n@@ -48,13 +70,24 @@ pub trait DocFolder : Sized {\n                     StructVariant(mut j) => {\n                         let num_fields = j.fields.len();\n                         j.fields = j.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                        j.fields_stripped |= num_fields != j.fields.len();\n+                        j.fields_stripped |= num_fields != j.fields.len() ||\n+                                             j.fields.iter().any(|f| f.is_stripped());\n                         VariantItem(Variant {kind: StructVariant(j), ..i2})\n                     },\n                     _ => VariantItem(i2)\n                 }\n             },\n             x => x\n+        }\n+    }\n+\n+    /// don't override!\n+    fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n+        let Item { attrs, name, source, visibility, def_id, inner, stability, deprecation } = item;\n+\n+        let inner = match inner {\n+            StrippedItem(box i) => StrippedItem(box self.fold_inner_recur(i)),\n+            _ => self.fold_inner_recur(inner),\n         };\n \n         Some(Item { attrs: attrs, name: name, source: source, inner: inner,\n@@ -70,9 +103,8 @@ pub trait DocFolder : Sized {\n     }\n \n     fn fold_crate(&mut self, mut c: Crate) -> Crate {\n-        c.module = c.module.and_then(|module| {\n-            self.fold_item(module)\n-        });\n+        c.module = c.module.and_then(|module| self.fold_item(module));\n+\n         c.external_traits = c.external_traits.into_iter().map(|(k, mut v)| {\n             v.items = v.items.into_iter().filter_map(|i| self.fold_item(i)).collect();\n             (k, v)"}, {"sha": "7ca4703a2e1859e298a9ba486156f196758526c6", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -17,22 +17,36 @@ use html::escape::Escape;\n \n use std::io;\n use std::io::prelude::*;\n-use syntax::parse::lexer;\n+use syntax::parse::lexer::{self, Reader};\n use syntax::parse::token;\n use syntax::parse;\n \n-/// Highlights some source code, returning the HTML output.\n-pub fn highlight(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n+/// Highlights `src`, returning the HTML output.\n+pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n     let sess = parse::ParseSess::new();\n     let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), src.to_string());\n \n     let mut out = Vec::new();\n-    doit(&sess,\n-         lexer::StringReader::new(&sess.span_diagnostic, fm),\n-         class,\n-         id,\n-         &mut out).unwrap();\n+    write_header(class, id, &mut out).unwrap();\n+    write_source(&sess,\n+                 lexer::StringReader::new(&sess.span_diagnostic, fm),\n+                 &mut out).unwrap();\n+    write_footer(&mut out).unwrap();\n+    String::from_utf8_lossy(&out[..]).into_owned()\n+}\n+\n+/// Highlights `src`, returning the HTML output. Returns only the inner html to\n+/// be inserted into an element. C.f., `render_with_highlighting` which includes\n+/// an enclosing `<pre>` block.\n+pub fn render_inner_with_highlighting(src: &str) -> String {\n+    let sess = parse::ParseSess::new();\n+    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), src.to_string());\n+\n+    let mut out = Vec::new();\n+    write_source(&sess,\n+                 lexer::StringReader::new(&sess.span_diagnostic, fm),\n+                 &mut out).unwrap();\n     String::from_utf8_lossy(&out[..]).into_owned()\n }\n \n@@ -43,17 +57,10 @@ pub fn highlight(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n /// it's used. All source code emission is done as slices from the source map,\n /// not from the tokens themselves, in order to stay true to the original\n /// source.\n-fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n-        class: Option<&str>, id: Option<&str>,\n-        out: &mut Write) -> io::Result<()> {\n-    use syntax::parse::lexer::Reader;\n-\n-    write!(out, \"<pre \")?;\n-    match id {\n-        Some(id) => write!(out, \"id='{}' \", id)?,\n-        None => {}\n-    }\n-    write!(out, \"class='rust {}'>\\n\", class.unwrap_or(\"\"))?;\n+fn write_source(sess: &parse::ParseSess,\n+                mut lexer: lexer::StringReader,\n+                out: &mut Write)\n+                -> io::Result<()> {\n     let mut is_attribute = false;\n     let mut is_macro = false;\n     let mut is_macro_nonterminal = false;\n@@ -184,5 +191,21 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n         }\n     }\n \n+    Ok(())\n+}\n+\n+fn write_header(class: Option<&str>,\n+                id: Option<&str>,\n+                out: &mut Write)\n+                -> io::Result<()> {\n+    write!(out, \"<pre \")?;\n+    match id {\n+        Some(id) => write!(out, \"id='{}' \", id)?,\n+        None => {}\n+    }\n+    write!(out, \"class='rust {}'>\\n\", class.unwrap_or(\"\"))\n+}\n+\n+fn write_footer(out: &mut Write) -> io::Result<()> {\n     write!(out, \"</pre>\\n\")\n }"}, {"sha": "74f7b099044f16b3700faf88061e6567ae82cb87", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -44,7 +44,12 @@ pub enum ItemType {\n \n impl ItemType {\n     pub fn from_item(item: &clean::Item) -> ItemType {\n-        match item.inner {\n+        let inner = match item.inner {\n+            clean::StrippedItem(box ref item) => item,\n+            ref inner@_ => inner,\n+        };\n+\n+        match *inner {\n             clean::ModuleItem(..)          => ItemType::Module,\n             clean::ExternCrateItem(..)     => ItemType::ExternCrate,\n             clean::ImportItem(..)          => ItemType::Import,\n@@ -67,6 +72,7 @@ impl ItemType {\n             clean::AssociatedConstItem(..) => ItemType::AssociatedConst,\n             clean::AssociatedTypeItem(..)  => ItemType::AssociatedType,\n             clean::DefaultImplItem(..)     => ItemType::Impl,\n+            clean::StrippedItem(..)        => unreachable!(),\n         }\n     }\n "}, {"sha": "3baf22b38ef6874b2fca3e4199c3c11c96fead9e", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -262,9 +262,9 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                                               &Default::default());\n                     s.push_str(&format!(\"<span class='rusttest'>{}</span>\", Escape(&test)));\n                 });\n-                s.push_str(&highlight::highlight(&text,\n-                                                 Some(\"rust-example-rendered\"),\n-                                                 None));\n+                s.push_str(&highlight::render_with_highlighting(&text,\n+                                                                Some(\"rust-example-rendered\"),\n+                                                                None));\n                 let output = CString::new(s).unwrap();\n                 hoedown_buffer_puts(ob, output.as_ptr());\n             })"}, {"sha": "1427dfcbaf178341dbb61b9302f22eacc04c4c6a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 147, "deletions": 168, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -91,12 +91,20 @@ pub struct Context {\n     /// String representation of how to get back to the root path of the 'doc/'\n     /// folder in terms of a relative URL.\n     pub root_path: String,\n-    /// The path to the crate root source minus the file name.\n-    /// Used for simplifying paths to the highlighted source code files.\n-    pub src_root: PathBuf,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n     pub dst: PathBuf,\n+    /// A flag, which when `true`, will render pages which redirect to the\n+    /// real location of an item. This is used to allow external links to\n+    /// publicly reused items to redirect to the right location.\n+    pub render_redirect_pages: bool,\n+    pub shared: Arc<SharedContext>,\n+}\n+\n+pub struct SharedContext {\n+    /// The path to the crate root source minus the file name.\n+    /// Used for simplifying paths to the highlighted source code files.\n+    pub src_root: PathBuf,\n     /// This describes the layout of each page, and is not modified after\n     /// creation of the context (contains info like the favicon and added html).\n     pub layout: layout::Layout,\n@@ -106,10 +114,6 @@ pub struct Context {\n     pub include_sources: bool,\n     /// The local file sources we've emitted and their respective url-paths.\n     pub local_sources: HashMap<PathBuf, String>,\n-    /// A flag, which when turned off, will render pages which redirect to the\n-    /// real location of an item. This is used to allow external links to\n-    /// publicly reused items to redirect to the right location.\n-    pub render_redirect_pages: bool,\n     /// All the passes that were run on this crate.\n     pub passes: HashSet<String>,\n     /// The base-URL of the issue tracker for when an item has been tagged with\n@@ -245,8 +249,7 @@ pub struct Cache {\n     parent_stack: Vec<DefId>,\n     parent_is_trait_impl: bool,\n     search_index: Vec<IndexItem>,\n-    privmod: bool,\n-    remove_priv: bool,\n+    stripped_mod: bool,\n     access_levels: AccessLevels<DefId>,\n     deref_trait_did: Option<DefId>,\n \n@@ -260,7 +263,7 @@ pub struct Cache {\n \n /// Helper struct to render all source code to HTML pages\n struct SourceCollector<'a> {\n-    cx: &'a mut Context,\n+    scx: &'a mut SharedContext,\n \n     /// Root destination to place all HTML output into\n     dst: PathBuf,\n@@ -413,43 +416,37 @@ pub fn run(mut krate: clean::Crate,\n         Some(p) => p.to_path_buf(),\n         None => PathBuf::new(),\n     };\n-    let mut cx = Context {\n-        dst: dst,\n+    let mut scx = SharedContext {\n         src_root: src_root,\n         passes: passes,\n-        current: Vec::new(),\n-        root_path: String::new(),\n+        include_sources: true,\n+        local_sources: HashMap::new(),\n+        issue_tracker_base_url: None,\n         layout: layout::Layout {\n             logo: \"\".to_string(),\n             favicon: \"\".to_string(),\n             external_html: external_html.clone(),\n             krate: krate.name.clone(),\n             playground_url: \"\".to_string(),\n         },\n-        include_sources: true,\n-        local_sources: HashMap::new(),\n-        render_redirect_pages: false,\n-        issue_tracker_base_url: None,\n     };\n \n-    try_err!(mkdir(&cx.dst), &cx.dst);\n-\n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n     if let Some(attrs) = krate.module.as_ref().map(|m| m.attrs.list(\"doc\")) {\n         for attr in attrs {\n             match *attr {\n                 clean::NameValue(ref x, ref s)\n                         if \"html_favicon_url\" == *x => {\n-                    cx.layout.favicon = s.to_string();\n+                    scx.layout.favicon = s.to_string();\n                 }\n                 clean::NameValue(ref x, ref s)\n                         if \"html_logo_url\" == *x => {\n-                    cx.layout.logo = s.to_string();\n+                    scx.layout.logo = s.to_string();\n                 }\n                 clean::NameValue(ref x, ref s)\n                         if \"html_playground_url\" == *x => {\n-                    cx.layout.playground_url = s.to_string();\n+                    scx.layout.playground_url = s.to_string();\n                     markdown::PLAYGROUND_KRATE.with(|slot| {\n                         if slot.borrow().is_none() {\n                             let name = krate.name.clone();\n@@ -459,16 +456,25 @@ pub fn run(mut krate: clean::Crate,\n                 }\n                 clean::NameValue(ref x, ref s)\n                         if \"issue_tracker_base_url\" == *x => {\n-                    cx.issue_tracker_base_url = Some(s.to_string());\n+                    scx.issue_tracker_base_url = Some(s.to_string());\n                 }\n                 clean::Word(ref x)\n                         if \"html_no_source\" == *x => {\n-                    cx.include_sources = false;\n+                    scx.include_sources = false;\n                 }\n                 _ => {}\n             }\n         }\n     }\n+    try_err!(mkdir(&dst), &dst);\n+    krate = render_sources(&dst, &mut scx, krate)?;\n+    let cx = Context {\n+        current: Vec::new(),\n+        root_path: String::new(),\n+        dst: dst,\n+        render_redirect_pages: false,\n+        shared: Arc::new(scx),\n+    };\n \n     // Crawl the crate to build various caches used for the output\n     let analysis = ::ANALYSISKEY.with(|a| a.clone());\n@@ -492,8 +498,7 @@ pub fn run(mut krate: clean::Crate,\n         parent_is_trait_impl: false,\n         extern_locations: HashMap::new(),\n         primitive_locations: HashMap::new(),\n-        remove_priv: cx.passes.contains(\"strip-private\"),\n-        privmod: false,\n+        stripped_mod: false,\n         access_levels: access_levels,\n         orphan_methods: Vec::new(),\n         traits: mem::replace(&mut krate.external_traits, HashMap::new()),\n@@ -540,7 +545,6 @@ pub fn run(mut krate: clean::Crate,\n     CURRENT_LOCATION_KEY.with(|s| s.borrow_mut().clear());\n \n     write_shared(&cx, &krate, &*cache, index)?;\n-    let krate = render_sources(&mut cx, krate)?;\n \n     // And finally render the whole crate's documentation\n     cx.krate(krate)\n@@ -762,16 +766,16 @@ fn write_shared(cx: &Context,\n     Ok(())\n }\n \n-fn render_sources(cx: &mut Context,\n+fn render_sources(dst: &Path, scx: &mut SharedContext,\n                   krate: clean::Crate) -> Result<clean::Crate, Error> {\n     info!(\"emitting source files\");\n-    let dst = cx.dst.join(\"src\");\n+    let dst = dst.join(\"src\");\n     try_err!(mkdir(&dst), &dst);\n     let dst = dst.join(&krate.name);\n     try_err!(mkdir(&dst), &dst);\n     let mut folder = SourceCollector {\n         dst: dst,\n-        cx: cx,\n+        scx: scx,\n     };\n     Ok(folder.fold_crate(krate))\n }\n@@ -849,7 +853,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         // If we're including source files, and we haven't seen this file yet,\n         // then we need to render it out to the filesystem\n-        if self.cx.include_sources\n+        if self.scx.include_sources\n             // skip all invalid spans\n             && item.source.filename != \"\"\n             // macros from other libraries get special filenames which we can\n@@ -862,7 +866,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n             // something like that), so just don't include sources for the\n             // entire crate. The other option is maintaining this mapping on a\n             // per-file basis, but that's probably not worth it...\n-            self.cx\n+            self.scx\n                 .include_sources = match self.emit_source(&item.source.filename) {\n                 Ok(()) => true,\n                 Err(e) => {\n@@ -874,7 +878,6 @@ impl<'a> DocFolder for SourceCollector<'a> {\n                 }\n             };\n         }\n-\n         self.fold_item_recur(item)\n     }\n }\n@@ -883,7 +886,7 @@ impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &str) -> io::Result<()> {\n         let p = PathBuf::from(filename);\n-        if self.cx.local_sources.contains_key(&p) {\n+        if self.scx.local_sources.contains_key(&p) {\n             // We've already emitted this source\n             return Ok(());\n         }\n@@ -904,7 +907,7 @@ impl<'a> SourceCollector<'a> {\n         let mut cur = self.dst.clone();\n         let mut root_path = String::from(\"../../\");\n         let mut href = String::new();\n-        clean_srcpath(&self.cx.src_root, &p, false, |component| {\n+        clean_srcpath(&self.scx.src_root, &p, false, |component| {\n             cur.push(component);\n             mkdir(&cur).unwrap();\n             root_path.push_str(\"../\");\n@@ -928,24 +931,25 @@ impl<'a> SourceCollector<'a> {\n             description: &desc,\n             keywords: BASIC_KEYWORDS,\n         };\n-        layout::render(&mut w, &self.cx.layout,\n+        layout::render(&mut w, &self.scx.layout,\n                        &page, &(\"\"), &Source(contents))?;\n         w.flush()?;\n-        self.cx.local_sources.insert(p, href);\n+        self.scx.local_sources.insert(p, href);\n         Ok(())\n     }\n }\n \n impl DocFolder for Cache {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        // If this is a private module, we don't want it in the search index.\n-        let orig_privmod = match item.inner {\n-            clean::ModuleItem(..) => {\n-                let prev = self.privmod;\n-                self.privmod = prev || (self.remove_priv && item.visibility != Some(hir::Public));\n+        // If this is a stripped module,\n+        // we don't want it or its children in the search index.\n+        let orig_stripped_mod = match item.inner {\n+            clean::StrippedItem(box clean::ModuleItem(..)) => {\n+                let prev = self.stripped_mod;\n+                self.stripped_mod = true;\n                 prev\n             }\n-            _ => self.privmod,\n+            _ => self.stripped_mod,\n         };\n \n         // Register any generics to their corresponding string. This is used\n@@ -983,6 +987,7 @@ impl DocFolder for Cache {\n         // Index this method for searching later on\n         if let Some(ref s) = item.name {\n             let (parent, is_method) = match item.inner {\n+                clean::StrippedItem(..) => ((None, None), false),\n                 clean::AssociatedConstItem(..) |\n                 clean::TypedefItem(_, true) if self.parent_is_trait_impl => {\n                     // skip associated items in trait impls\n@@ -1021,20 +1026,17 @@ impl DocFolder for Cache {\n                 }\n                 _ => ((None, Some(&*self.stack)), false)\n             };\n-            let hidden_field = match item.inner {\n-                clean::StructFieldItem(clean::HiddenStructField) => true,\n-                _ => false\n-            };\n \n             match parent {\n-                (parent, Some(path)) if is_method || (!self.privmod && !hidden_field) => {\n+                (parent, Some(path)) if is_method || (!self.stripped_mod) => {\n                     // Needed to determine `self` type.\n                     let parent_basename = self.parent_stack.first().and_then(|parent| {\n                         match self.paths.get(parent) {\n                             Some(&(ref fqp, _)) => Some(fqp[fqp.len() - 1].clone()),\n                             _ => None\n                         }\n                     });\n+                    debug_assert!(!item.is_stripped());\n \n                     // A crate has a module at its root, containing all items,\n                     // which should not be indexed. The crate-item itself is\n@@ -1051,7 +1053,7 @@ impl DocFolder for Cache {\n                         });\n                     }\n                 }\n-                (Some(parent), None) if is_method || (!self.privmod && !hidden_field)=> {\n+                (Some(parent), None) if is_method || (!self.stripped_mod)=> {\n                     if parent.is_local() {\n                         // We have a parent, but we don't know where they're\n                         // defined yet. Wait for later to index this item.\n@@ -1075,7 +1077,7 @@ impl DocFolder for Cache {\n             clean::StructItem(..) | clean::EnumItem(..) |\n             clean::TypedefItem(..) | clean::TraitItem(..) |\n             clean::FunctionItem(..) | clean::ModuleItem(..) |\n-            clean::ForeignFunctionItem(..) if !self.privmod => {\n+            clean::ForeignFunctionItem(..) if !self.stripped_mod => {\n                 // Reexported items mean that the same id can show up twice\n                 // in the rustdoc ast that we're looking at. We know,\n                 // however, that a reexported item doesn't show up in the\n@@ -1093,7 +1095,7 @@ impl DocFolder for Cache {\n             }\n             // link variants to their parent enum because pages aren't emitted\n             // for each variant\n-            clean::VariantItem(..) if !self.privmod => {\n+            clean::VariantItem(..) if !self.stripped_mod => {\n                 let mut stack = self.stack.clone();\n                 stack.pop();\n                 self.paths.insert(item.def_id, (stack, ItemType::Enum));\n@@ -1176,7 +1178,7 @@ impl DocFolder for Cache {\n \n         if pushed { self.stack.pop().unwrap(); }\n         if parent_pushed { self.parent_stack.pop().unwrap(); }\n-        self.privmod = orig_privmod;\n+        self.stripped_mod = orig_stripped_mod;\n         self.parent_is_trait_impl = orig_parent_is_trait_impl;\n         return ret;\n     }\n@@ -1233,15 +1235,12 @@ impl Context {\n \n         // render the crate documentation\n         let mut work = vec!((self, item));\n-        loop {\n-            match work.pop() {\n-                Some((mut cx, item)) => cx.item(item, |cx, item| {\n-                    work.push((cx.clone(), item));\n-                })?,\n-                None => break,\n-            }\n-        }\n \n+        while let Some((mut cx, item)) = work.pop() {\n+            cx.item(item, |cx, item| {\n+                work.push((cx.clone(), item))\n+            })?\n+        }\n         Ok(())\n     }\n \n@@ -1272,10 +1271,10 @@ impl Context {\n             let tyname = shortty(it).to_static_str();\n             let desc = if it.is_crate() {\n                 format!(\"API documentation for the Rust `{}` crate.\",\n-                        cx.layout.krate)\n+                        cx.shared.layout.krate)\n             } else {\n                 format!(\"API documentation for the Rust `{}` {} in crate `{}`.\",\n-                        it.name.as_ref().unwrap(), tyname, cx.layout.krate)\n+                        it.name.as_ref().unwrap(), tyname, cx.shared.layout.krate)\n             };\n             let keywords = make_item_keywords(it);\n             let page = layout::Page {\n@@ -1293,90 +1292,83 @@ impl Context {\n             // write syscall all the time.\n             let mut writer = BufWriter::new(w);\n             if !cx.render_redirect_pages {\n-                layout::render(&mut writer, &cx.layout, &page,\n+                layout::render(&mut writer, &cx.shared.layout, &page,\n                                &Sidebar{ cx: cx, item: it },\n                                &Item{ cx: cx, item: it })?;\n+\n             } else {\n                 let mut url = repeat(\"../\").take(cx.current.len())\n                                            .collect::<String>();\n-                match cache().paths.get(&it.def_id) {\n-                    Some(&(ref names, _)) => {\n-                        for name in &names[..names.len() - 1] {\n-                            url.push_str(name);\n-                            url.push_str(\"/\");\n-                        }\n-                        url.push_str(&item_path(it));\n-                        layout::redirect(&mut writer, &url)?;\n+                if let Some(&(ref names, _)) = cache().paths.get(&it.def_id) {\n+                    for name in &names[..names.len() - 1] {\n+                        url.push_str(name);\n+                        url.push_str(\"/\");\n                     }\n-                    None => {}\n+                    url.push_str(&item_path(it));\n+                    layout::redirect(&mut writer, &url)?;\n                 }\n             }\n             writer.flush()\n         }\n \n-        // Private modules may survive the strip-private pass if they\n-        // contain impls for public types. These modules can also\n+        // Stripped modules survive the rustdoc passes (i.e. `strip-private`)\n+        // if they contain impls for public types. These modules can also\n         // contain items such as publicly reexported structures.\n         //\n         // External crates will provide links to these structures, so\n-        // these modules are recursed into, but not rendered normally (a\n-        // flag on the context).\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n         if !self.render_redirect_pages {\n-            self.render_redirect_pages = self.ignore_private_item(&item);\n+            self.render_redirect_pages = self.maybe_ignore_item(&item);\n         }\n \n-        match item.inner {\n+        if item.is_mod() {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n-            clean::ModuleItem(..) => {\n-                let name = item.name.as_ref().unwrap().to_string();\n-                let mut item = Some(item);\n-                self.recurse(name, |this| {\n-                    let item = item.take().unwrap();\n-                    let joint_dst = this.dst.join(\"index.html\");\n-                    let dst = try_err!(File::create(&joint_dst), &joint_dst);\n-                    try_err!(render(dst, this, &item, false), &joint_dst);\n-\n-                    let m = match item.inner {\n-                        clean::ModuleItem(m) => m,\n-                        _ => unreachable!()\n-                    };\n-\n-                    // render sidebar-items.js used throughout this module\n-                    {\n-                        let items = this.build_sidebar_items(&m);\n-                        let js_dst = this.dst.join(\"sidebar-items.js\");\n-                        let mut js_out = BufWriter::new(try_err!(File::create(&js_dst), &js_dst));\n-                        try_err!(write!(&mut js_out, \"initSidebarItems({});\",\n-                                    as_json(&items)), &js_dst);\n-                    }\n+            let name = item.name.as_ref().unwrap().to_string();\n+            let mut item = Some(item);\n+            self.recurse(name, |this| {\n+                let item = item.take().unwrap();\n+                let joint_dst = this.dst.join(\"index.html\");\n+                let dst = try_err!(File::create(&joint_dst), &joint_dst);\n+                try_err!(render(dst, this, &item, false), &joint_dst);\n \n-                    for item in m.items {\n-                        f(this,item);\n-                    }\n-                    Ok(())\n-                })\n-            }\n+                let m = match item.inner {\n+                    clean::StrippedItem(box clean::ModuleItem(m)) |\n+                    clean::ModuleItem(m) => m,\n+                    _ => unreachable!()\n+                };\n \n-            // Things which don't have names (like impls) don't get special\n-            // pages dedicated to them.\n-            _ if item.name.is_some() => {\n-                let joint_dst = self.dst.join(&item_path(&item));\n+                // render sidebar-items.js used throughout this module\n+                {\n+                    let items = this.build_sidebar_items(&m);\n+                    let js_dst = this.dst.join(\"sidebar-items.js\");\n+                    let mut js_out = BufWriter::new(try_err!(File::create(&js_dst), &js_dst));\n+                    try_err!(write!(&mut js_out, \"initSidebarItems({});\",\n+                                    as_json(&items)), &js_dst);\n+                }\n \n-                let dst = try_err!(File::create(&joint_dst), &joint_dst);\n-                try_err!(render(dst, self, &item, true), &joint_dst);\n+                for item in m.items {\n+                    f(this,item);\n+                }\n                 Ok(())\n-            }\n+            })\n+        } else if item.name.is_some() {\n+            let joint_dst = self.dst.join(&item_path(&item));\n \n-            _ => Ok(())\n+            let dst = try_err!(File::create(&joint_dst), &joint_dst);\n+            try_err!(render(dst, self, &item, true), &joint_dst);\n+            Ok(())\n+        } else {\n+            Ok(())\n         }\n     }\n \n     fn build_sidebar_items(&self, m: &clean::Module) -> BTreeMap<String, Vec<NameDoc>> {\n         // BTreeMap instead of HashMap to get a sorted output\n         let mut map = BTreeMap::new();\n         for item in &m.items {\n-            if self.ignore_private_item(item) { continue }\n+            if self.maybe_ignore_item(item) { continue }\n \n             let short = shortty(item).to_static_str();\n             let myname = match item.name {\n@@ -1394,27 +1386,18 @@ impl Context {\n         return map;\n     }\n \n-    fn ignore_private_item(&self, it: &clean::Item) -> bool {\n+    fn maybe_ignore_item(&self, it: &clean::Item) -> bool {\n         match it.inner {\n+            clean::StrippedItem(..) => true,\n             clean::ModuleItem(ref m) => {\n-                (m.items.is_empty() &&\n-                 it.doc_value().is_none() &&\n-                 it.visibility != Some(hir::Public)) ||\n-                (self.passes.contains(\"strip-private\") && it.visibility != Some(hir::Public))\n-            }\n-            clean::PrimitiveItem(..) => it.visibility != Some(hir::Public),\n+                it.doc_value().is_none() && m.items.is_empty() && it.visibility != Some(hir::Public)\n+            },\n             _ => false,\n         }\n     }\n }\n \n impl<'a> Item<'a> {\n-    fn ismodule(&self) -> bool {\n-        match self.item.inner {\n-            clean::ModuleItem(..) => true, _ => false\n-        }\n-    }\n-\n     /// Generate a url appropriate for an `href` attribute back to the source of\n     /// this item.\n     ///\n@@ -1457,10 +1440,11 @@ impl<'a> Item<'a> {\n         // know the span, so we plow forward and generate a proper url. The url\n         // has anchors for the line numbers that we're linking to.\n         } else if self.item.def_id.is_local() {\n-            self.cx.local_sources.get(&PathBuf::from(&self.item.source.filename)).map(|path| {\n+            let path = PathBuf::from(&self.item.source.filename);\n+            self.cx.shared.local_sources.get(&path).map(|path| {\n                 format!(\"{root}src/{krate}/{path}#{href}\",\n                         root = self.cx.root_path,\n-                        krate = self.cx.layout.krate,\n+                        krate = self.cx.shared.layout.krate,\n                         path = path,\n                         href = href)\n             })\n@@ -1495,6 +1479,7 @@ impl<'a> Item<'a> {\n \n impl<'a> fmt::Display for Item<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        debug_assert!(!self.item.is_stripped());\n         // Write the breadcrumb trail header for the top\n         write!(fmt, \"\\n<h1 class='fqn'><span class='in-band'>\")?;\n         match self.item.inner {\n@@ -1516,7 +1501,7 @@ impl<'a> fmt::Display for Item<'a> {\n         };\n         if !is_primitive {\n             let cur = &self.cx.current;\n-            let amt = if self.ismodule() { cur.len() - 1 } else { cur.len() };\n+            let amt = if self.item.is_mod() { cur.len() - 1 } else { cur.len() };\n             for (i, component) in cur.iter().enumerate().take(amt) {\n                 write!(fmt, \"<a href='{}index.html'>{}</a>::<wbr>\",\n                        repeat(\"../\").take(cur.len() - i - 1)\n@@ -1542,7 +1527,7 @@ impl<'a> fmt::Display for Item<'a> {\n         // [src] link in the downstream documentation will actually come back to\n         // this page, and this link will be auto-clicked. The `id` attribute is\n         // used to find the link to auto-click.\n-        if self.cx.include_sources && !is_primitive {\n+        if self.cx.shared.include_sources && !is_primitive {\n             if let Some(l) = self.href() {\n                 write!(fmt, \"<a id='src-{}' class='srclink' \\\n                               href='{}' title='{}'>[src]</a>\",\n@@ -1575,15 +1560,12 @@ impl<'a> fmt::Display for Item<'a> {\n }\n \n fn item_path(item: &clean::Item) -> String {\n-    match item.inner {\n-        clean::ModuleItem(..) => {\n-            format!(\"{}/index.html\", item.name.as_ref().unwrap())\n-        }\n-        _ => {\n-            format!(\"{}.{}.html\",\n-                    shortty(item).to_static_str(),\n-                    *item.name.as_ref().unwrap())\n-        }\n+    if item.is_mod() {\n+        format!(\"{}/index.html\", item.name.as_ref().unwrap())\n+    } else {\n+        format!(\"{}.{}.html\",\n+                shortty(item).to_static_str(),\n+                *item.name.as_ref().unwrap())\n     }\n }\n \n@@ -1626,7 +1608,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     document(w, cx, item)?;\n \n     let mut indices = (0..items.len()).filter(|i| {\n-        !cx.ignore_private_item(&items[*i])\n+        !cx.maybe_ignore_item(&items[*i])\n     }).collect::<Vec<usize>>();\n \n     // the order of item types in the listing\n@@ -1670,6 +1652,9 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     let mut curty = None;\n     for &idx in &indices {\n         let myitem = &items[idx];\n+        if myitem.is_stripped() {\n+            continue;\n+        }\n \n         let myty = Some(shortty(myitem));\n         if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n@@ -1774,7 +1759,7 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Optio\n             format!(\"Deprecated{}{}\", since, Markdown(&reason))\n         } else if stab.level == stability::Unstable {\n             let unstable_extra = if show_reason {\n-                match (!stab.feature.is_empty(), &cx.issue_tracker_base_url, stab.issue) {\n+                match (!stab.feature.is_empty(), &cx.shared.issue_tracker_base_url, stab.issue) {\n                     (true, &Some(ref tracker_url), Some(issue_no)) if issue_no > 0 =>\n                         format!(\" (<code>{}</code> <a href=\\\"{}{}\\\">#{}</a>)\",\n                                 Escape(&stab.feature), tracker_url, issue_no, issue_no),\n@@ -2146,6 +2131,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                where_clause = WhereClause(g))\n     }\n     match item.inner {\n+        clean::StrippedItem(..) => Ok(()),\n         clean::TyMethodItem(ref m) => {\n             method(w, item, m.unsafety, hir::Constness::NotConst,\n                    m.abi, &m.generics, &m.self_, &m.decl, link)\n@@ -2182,8 +2168,7 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)?;\n     let mut fields = s.fields.iter().filter(|f| {\n         match f.inner {\n-            clean::StructFieldItem(clean::HiddenStructField) => false,\n-            clean::StructFieldItem(clean::TypedStructField(..)) => true,\n+            clean::StructFieldItem(..) => true,\n             _ => false,\n         }\n     }).peekable();\n@@ -2273,7 +2258,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             if let clean::VariantItem( Variant { kind: StructVariant(ref s) } ) = variant.inner {\n                 let fields = s.fields.iter().filter(|f| {\n                     match f.inner {\n-                        clean::StructFieldItem(clean::TypedStructField(..)) => true,\n+                        clean::StructFieldItem(..) => true,\n                         _ => false,\n                     }\n                 });\n@@ -2332,24 +2317,17 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n     match ty {\n         doctree::Plain => {\n             write!(w, \" {{\\n{}\", tab)?;\n-            let mut fields_stripped = false;\n             for field in fields {\n-                match field.inner {\n-                    clean::StructFieldItem(clean::HiddenStructField) => {\n-                        fields_stripped = true;\n-                    }\n-                    clean::StructFieldItem(clean::TypedStructField(ref ty)) => {\n-                        write!(w, \"    {}{}: {},\\n{}\",\n-                               VisSpace(field.visibility),\n-                               field.name.as_ref().unwrap(),\n-                               *ty,\n-                               tab)?;\n-                    }\n-                    _ => unreachable!(),\n-                };\n+                if let clean::StructFieldItem(ref ty) = field.inner {\n+                    write!(w, \"    {}{}: {},\\n{}\",\n+                           VisSpace(field.visibility),\n+                           field.name.as_ref().unwrap(),\n+                           *ty,\n+                           tab)?;\n+                }\n             }\n \n-            if fields_stripped {\n+            if it.has_stripped_fields().unwrap() {\n                 write!(w, \"    // some fields omitted\\n{}\", tab)?;\n             }\n             write!(w, \"}}\")?;\n@@ -2361,10 +2339,10 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                     write!(w, \", \")?;\n                 }\n                 match field.inner {\n-                    clean::StructFieldItem(clean::HiddenStructField) => {\n+                    clean::StrippedItem(box clean::StructFieldItem(..)) => {\n                         write!(w, \"_\")?\n                     }\n-                    clean::StructFieldItem(clean::TypedStructField(ref ty)) => {\n+                    clean::StructFieldItem(ref ty) => {\n                         write!(w, \"{}{}\", VisSpace(field.visibility), *ty)?\n                     }\n                     _ => unreachable!()\n@@ -2540,6 +2518,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                 assoc_type(w, item, bounds, default.as_ref(), link)?;\n                 write!(w, \"</code></h4>\\n\")?;\n             }\n+            clean::StrippedItem(..) => return Ok(()),\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n \n@@ -2661,16 +2640,16 @@ impl<'a> fmt::Display for Source<'a> {\n             write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols)?;\n         }\n         write!(fmt, \"</pre>\")?;\n-        write!(fmt, \"{}\", highlight::highlight(s, None, None))?;\n+        write!(fmt, \"{}\", highlight::render_with_highlighting(s, None, None))?;\n         Ok(())\n     }\n }\n \n fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n-    w.write_str(&highlight::highlight(&t.source,\n-                                      Some(\"macro\"),\n-                                      None))?;\n+    w.write_str(&highlight::render_with_highlighting(&t.source,\n+                                                     Some(\"macro\"),\n+                                                     None))?;\n     render_stability_since_raw(w, it.stable_since(), None)?;\n     document(w, cx, it)\n }"}, {"sha": "f93ecb46228c2b4baca320809f6378321e0c5a19", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -21,6 +21,7 @@ use clean::Item;\n use plugins;\n use fold;\n use fold::DocFolder;\n+use fold::FoldItem::Strip;\n \n /// Strip items marked `#[doc(hidden)]`\n pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n@@ -39,18 +40,12 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n \n                     // use a dedicated hidden item for given item type if any\n                     match i.inner {\n-                        clean::StructFieldItem(..) => {\n-                            return Some(clean::Item {\n-                                inner: clean::StructFieldItem(clean::HiddenStructField),\n-                                ..i\n-                            });\n-                        }\n-                        _ => {\n-                            return None;\n+                        clean::StructFieldItem(..) | clean::ModuleItem(..) => {\n+                            return Strip(i).fold()\n                         }\n+                        _ => return None,\n                     }\n                 }\n-\n                 self.fold_item_recur(i)\n             }\n         }\n@@ -125,36 +120,32 @@ struct Stripper<'a> {\n impl<'a> fold::DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n+            clean::StrippedItem(..) => return Some(i),\n             // These items can all get re-exported\n             clean::TypedefItem(..) | clean::StaticItem(..) |\n             clean::StructItem(..) | clean::EnumItem(..) |\n             clean::TraitItem(..) | clean::FunctionItem(..) |\n             clean::VariantItem(..) | clean::MethodItem(..) |\n-            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) => {\n+            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n+            clean::ConstantItem(..) => {\n                 if i.def_id.is_local() {\n                     if !self.access_levels.is_exported(i.def_id) {\n                         return None;\n                     }\n                 }\n             }\n \n-            clean::ConstantItem(..) => {\n-                if i.def_id.is_local() && !self.access_levels.is_exported(i.def_id) {\n-                    return None;\n-                }\n-            }\n-\n             clean::StructFieldItem(..) => {\n                 if i.visibility != Some(hir::Public) {\n-                    return Some(clean::Item {\n-                        inner: clean::StructFieldItem(clean::HiddenStructField),\n-                        ..i\n-                    })\n+                    return Strip(i).fold();\n                 }\n             }\n \n-            // handled below\n-            clean::ModuleItem(..) => {}\n+            clean::ModuleItem(..) => {\n+                if i.def_id.is_local() && i.visibility != Some(hir::Public) {\n+                    return Strip(self.fold_item_recur(i).unwrap()).fold()\n+                }\n+            }\n \n             // trait impls for private items should be stripped\n             clean::ImplItem(clean::Impl{\n@@ -165,7 +156,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n                 }\n             }\n             // handled in the `strip-priv-imports` pass\n-            clean::ExternCrateItem(..) | clean::ImportItem(_) => {}\n+            clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n \n             clean::DefaultImplItem(..) | clean::ImplItem(..) => {}\n \n@@ -187,7 +178,6 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n \n             // implementations of traits are always public.\n             clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n-\n             // Struct variant fields have inherited visibility\n             clean::VariantItem(clean::Variant {\n                 kind: clean::StructVariant(..)\n@@ -202,19 +192,17 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             self.fold_item_recur(i)\n         };\n \n-        i.and_then(|i| {\n-            match i.inner {\n-                // emptied modules/impls have no need to exist\n-                clean::ModuleItem(ref m)\n-                    if m.items.is_empty() &&\n-                       i.doc_value().is_none() => None,\n-                clean::ImplItem(ref i) if i.items.is_empty() => None,\n-                _ => {\n-                    self.retained.insert(i.def_id);\n-                    Some(i)\n-                }\n+        i.and_then(|i| { match i.inner {\n+            // emptied modules/impls have no need to exist\n+            clean::ModuleItem(ref m)\n+                if m.items.is_empty() &&\n+                   i.doc_value().is_none() => None,\n+            clean::ImplItem(ref i) if i.items.is_empty() => None,\n+            _ => {\n+                self.retained.insert(i.def_id);\n+                Some(i)\n             }\n-        })\n+        }})\n     }\n }\n "}, {"sha": "5bd3b9c4f59e706448321db39f9bc58d32ec38e9", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -431,7 +431,7 @@ impl Collector {\n                 // compiler failures are test failures\n                 should_panic: testing::ShouldPanic::No,\n             },\n-            testfn: testing::DynTestFn(Box::new(move|| {\n+            testfn: testing::DynTestFn(box move|| {\n                 runtest(&test,\n                         &cratename,\n                         cfgs,\n@@ -442,7 +442,7 @@ impl Collector {\n                         as_test_harness,\n                         compile_fail,\n                         &opts);\n-            }))\n+            })\n         });\n     }\n "}, {"sha": "8a50f07e6d85419d0253edbb9365519db5e9259a", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -52,6 +52,7 @@ impl Duration {\n     /// If the nanoseconds is greater than 1 billion (the number of nanoseconds\n     /// in a second), then it will carry over into the seconds provided.\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n+    #[inline]\n     pub fn new(secs: u64, nanos: u32) -> Duration {\n         let secs = secs + (nanos / NANOS_PER_SEC) as u64;\n         let nanos = nanos % NANOS_PER_SEC;\n@@ -60,12 +61,14 @@ impl Duration {\n \n     /// Creates a new `Duration` from the specified number of seconds.\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n+    #[inline]\n     pub fn from_secs(secs: u64) -> Duration {\n         Duration { secs: secs, nanos: 0 }\n     }\n \n     /// Creates a new `Duration` from the specified number of milliseconds.\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n+    #[inline]\n     pub fn from_millis(millis: u64) -> Duration {\n         let secs = millis / MILLIS_PER_SEC;\n         let nanos = ((millis % MILLIS_PER_SEC) as u32) * NANOS_PER_MILLI;\n@@ -77,6 +80,7 @@ impl Duration {\n     /// The extra precision represented by this duration is ignored (e.g. extra\n     /// nanoseconds are not represented in the returned value).\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n+    #[inline]\n     pub fn as_secs(&self) -> u64 { self.secs }\n \n     /// Returns the nanosecond precision represented by this duration.\n@@ -85,6 +89,7 @@ impl Duration {\n     /// represented by nanoseconds. The returned number always represents a\n     /// fractional portion of a second (e.g. it is less than one billion).\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n+    #[inline]\n     pub fn subsec_nanos(&self) -> u32 { self.nanos }\n }\n "}, {"sha": "f369582bc5c30f674c5a8fe78462ab9345a520d0", "filename": "src/libsyntax/errors/json.rs", "status": "modified", "additions": 60, "deletions": 15, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibsyntax%2Ferrors%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibsyntax%2Ferrors%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fjson.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -20,7 +20,7 @@\n // FIXME spec the JSON output properly.\n \n \n-use codemap::{Span, MultiSpan, CodeMap};\n+use codemap::{self, Span, MultiSpan, CodeMap};\n use diagnostics::registry::Registry;\n use errors::{Level, DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion};\n use errors::emitter::Emitter;\n@@ -197,8 +197,8 @@ impl DiagnosticSpan {\n \n     fn from_render_span(rsp: &RenderSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n         match *rsp {\n-            // FIXME(#30701) handle Suggestion properly\n             RenderSpan::FullSpan(ref msp) |\n+            // FIXME(#30701) handle Suggestion properly\n             RenderSpan::Suggestion(CodeSuggestion { ref msp, .. }) => {\n                 DiagnosticSpan::from_multispan(msp, je)\n             }\n@@ -207,13 +207,13 @@ impl DiagnosticSpan {\n                     let end = je.cm.lookup_char_pos(span.hi);\n                     DiagnosticSpan {\n                         file_name: end.file.name.clone(),\n-                        byte_start: span.lo.0,\n+                        byte_start: span.hi.0,\n                         byte_end: span.hi.0,\n-                        line_start: 0,\n+                        line_start: end.line,\n                         line_end: end.line,\n-                        column_start: 0,\n+                        column_start: end.col.0 + 1,\n                         column_end: end.col.0 + 1,\n-                        text: DiagnosticSpanLine::from_span(span, je),\n+                        text: DiagnosticSpanLine::from_span_end(span, je),\n                     }\n                 }).collect()\n             }\n@@ -237,25 +237,70 @@ impl DiagnosticSpan {\n     }\n }\n \n-impl DiagnosticSpanLine {\n-    fn from_span(span: &Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n-        let lines = match je.cm.span_to_lines(*span) {\n+macro_rules! get_lines_for_span {\n+    ($span: ident, $je: ident) => {\n+        match $je.cm.span_to_lines(*$span) {\n             Ok(lines) => lines,\n             Err(_) => {\n                 debug!(\"unprintable span\");\n                 return Vec::new();\n             }\n-        };\n+        }\n+    }\n+}\n+\n+impl DiagnosticSpanLine {\n+    fn line_from_filemap(fm: &codemap::FileMap,\n+                         index: usize,\n+                         h_start: usize,\n+                         h_end: usize)\n+                         -> DiagnosticSpanLine {\n+        DiagnosticSpanLine {\n+            text: fm.get_line(index).unwrap().to_owned(),\n+            highlight_start: h_start,\n+            highlight_end: h_end,\n+        }\n+    }\n+\n+    /// Create a list of DiagnosticSpanLines from span - each line with any part\n+    /// of `span` gets a DiagnosticSpanLine, with the highlight indicating the\n+    /// `span` within the line.\n+    fn from_span(span: &Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n+        let lines = get_lines_for_span!(span, je);\n \n         let mut result = Vec::new();\n         let fm = &*lines.file;\n \n         for line in &lines.lines {\n-            result.push(DiagnosticSpanLine {\n-                text: fm.get_line(line.line_index).unwrap().to_owned(),\n-                highlight_start: line.start_col.0 + 1,\n-                highlight_end: line.end_col.0 + 1,\n-            });\n+            result.push(DiagnosticSpanLine::line_from_filemap(fm,\n+                                                              line.line_index,\n+                                                              line.start_col.0 + 1,\n+                                                              line.end_col.0 + 1));\n+        }\n+\n+        result\n+    }\n+\n+    /// Create a list of DiagnosticSpanLines from span - the result covers all\n+    /// of `span`, but the highlight is zero-length and at the end of `span`.\n+    fn from_span_end(span: &Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n+        let lines = get_lines_for_span!(span, je);\n+\n+        let mut result = Vec::new();\n+        let fm = &*lines.file;\n+\n+        for (i, line) in lines.lines.iter().enumerate() {\n+            // Invariant - CodeMap::span_to_lines will not return extra context\n+            // lines - the last line returned is the last line of `span`.\n+            let highlight = if i == lines.lines.len() - 1 {\n+                (line.end_col.0 + 1, line.end_col.0 + 1)\n+            } else {\n+                (0, 0)\n+            };\n+            result.push(DiagnosticSpanLine::line_from_filemap(fm,\n+                                                              line.line_index,\n+                                                              highlight.0,\n+                                                              highlight.1));\n         }\n \n         result"}, {"sha": "75916b87c129d1ba6e9df8faecafa82ab44d7399", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -6124,7 +6124,7 @@ impl<'a> Parser<'a> {\n \n         // Allow a leading :: because the paths are absolute either way.\n         // This occurs with \"use $crate::...\" in macros.\n-        self.eat(&token::ModSep);\n+        let is_global = self.eat(&token::ModSep);\n \n         if self.check(&token::OpenDelim(token::Brace)) {\n             // use {foo,bar}\n@@ -6135,7 +6135,7 @@ impl<'a> Parser<'a> {\n                 |p| p.parse_path_list_item())?;\n             let path = ast::Path {\n                 span: mk_sp(lo, self.span.hi),\n-                global: false,\n+                global: is_global,\n                 segments: Vec::new()\n             };\n             return Ok(P(spanned(lo, self.span.hi, ViewPathList(path, idents))));\n@@ -6164,7 +6164,7 @@ impl<'a> Parser<'a> {\n                     )?;\n                     let path = ast::Path {\n                         span: mk_sp(lo, self.span.hi),\n-                        global: false,\n+                        global: is_global,\n                         segments: path.into_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n@@ -6180,7 +6180,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                     let path = ast::Path {\n                         span: mk_sp(lo, self.span.hi),\n-                        global: false,\n+                        global: is_global,\n                         segments: path.into_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n@@ -6203,7 +6203,7 @@ impl<'a> Parser<'a> {\n         let mut rename_to = path[path.len() - 1];\n         let path = ast::Path {\n             span: mk_sp(lo, self.last_span.hi),\n-            global: false,\n+            global: is_global,\n             segments: path.into_iter().map(|identifier| {\n                 ast::PathSegment {\n                     identifier: identifier,"}, {"sha": "16417ac004461f685f0d5a04756565f73aba8e9f", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -514,7 +514,7 @@ macro_rules! declare_special_idents_and_keywords {(\n // If the special idents get renumbered, remember to modify these two as appropriate\n pub const SELF_KEYWORD_NAME: ast::Name = ast::Name(SELF_KEYWORD_NAME_NUM);\n const STATIC_KEYWORD_NAME: ast::Name = ast::Name(STATIC_KEYWORD_NAME_NUM);\n-const SUPER_KEYWORD_NAME: ast::Name = ast::Name(SUPER_KEYWORD_NAME_NUM);\n+pub const SUPER_KEYWORD_NAME: ast::Name = ast::Name(SUPER_KEYWORD_NAME_NUM);\n const SELF_TYPE_KEYWORD_NAME: ast::Name = ast::Name(SELF_TYPE_KEYWORD_NAME_NUM);\n \n pub const SELF_KEYWORD_NAME_NUM: u32 = 1;"}, {"sha": "61dfd4f8f867d42280e1b53380cc47dc4beff782", "filename": "src/snapshots.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -9,13 +9,15 @@ S 2016-03-18 235d774\n   freebsd-x86_64 390b9a9f60f3d0d6a52c04d939a0355f572d03b3\n \n S 2016-02-17 4d3eebf\n+  dragonfly-x86_64 765bb5820ad406e966ec0ac51c8070b656459b02\n   linux-i386 5f194aa7628c0703f0fd48adc4ec7f3cc64b98c7\n   linux-x86_64 d29b7607d13d64078b6324aec82926fb493f59ba\n   macos-i386 4c8e42dd649e247f3576bf9dfa273327b4907f9c\n   macos-x86_64 411a41363f922d1d93fa62ff2fedf5c35e9cccb2\n   winnt-i386 0c336d794a65f8e285c121866c7d59aa2dd0d1e1\n   winnt-x86_64 27e75b1bf99770b3564bcebd7f3230be01135a92\n   openbsd-x86_64 ac957c6b84de2bd67f01df085d9ea515f96e22f3\n+  freebsd-i386 4e2af0b34eb335e173aebff543be693724a956c2\n   freebsd-x86_64 f38991fbb81c1cd8d0bbda396f98f13a55b42804\n \n S 2015-12-18 3391630"}, {"sha": "2b061e3997d844b99bb4458e52fdf685da49739c", "filename": "src/test/auxiliary/reexp_stripped.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Ftest%2Fauxiliary%2Freexp_stripped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Ftest%2Fauxiliary%2Freexp_stripped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Freexp_stripped.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use private::Quz;\n+pub use hidden::Bar;\n+\n+mod private {\n+    pub struct Quz;\n+}\n+\n+#[doc(hidden)]\n+pub mod hidden {\n+    pub struct Bar;\n+}"}, {"sha": "02148a138c9d905c9f02d23c2ae5476d2b694db3", "filename": "src/test/compile-fail/consider-removing-last-semi.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f() -> String {  //~ ERROR E0269\n+                    //~^ HELP detailed explanation\n+    0u8;\n+    \"bla\".to_string();  //~ HELP consider removing this semicolon\n+}\n+\n+fn g() -> String {  //~ ERROR E0269\n+                    //~^ HELP detailed explanation\n+    \"this won't work\".to_string();\n+    \"removeme\".to_string(); //~ HELP consider removing this semicolon\n+}\n+\n+fn main() {}"}, {"sha": "fe7e66a2116ebb7fa4d5740b7929dff14bc9db3d", "filename": "src/test/compile-fail/issue-32128.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Ftest%2Fcompile-fail%2Fissue-32128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Ftest%2Fcompile-fail%2Fissue-32128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32128.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Example {\n+    example: Box<Fn(i32) -> i32>\n+}\n+\n+fn main() {\n+    let demo = Example {\n+        example: Box::new(|x| {\n+            x + 1\n+        })\n+    };\n+\n+    demo.example(1);    //~ ERROR no method named `example`\n+                        //~^ NOTE use `(demo.example)(...)`\n+    // (demo.example)(1);\n+}"}, {"sha": "d721d428f29f597e7957a63fc9938ee1f6b2e6a9", "filename": "src/test/compile-fail/use-super-global-path.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Ftest%2Fcompile-fail%2Fuse-super-global-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Ftest%2Fcompile-fail%2Fuse-super-global-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-super-global-path.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+mod foo {\n+    pub fn g() {\n+        use ::super::main; //~ WARN expected identifier, found keyword `super`\n+        //~^ WARN this was previously accepted by the compiler but is being phased out\n+        main();\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { foo::g(); } //~ ERROR compilation successful"}, {"sha": "98e66e8c024bd3a49d48e574aa265db506cdba6b", "filename": "src/test/rustdoc/redirect.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Ftest%2Frustdoc%2Fredirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Ftest%2Frustdoc%2Fredirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fredirect.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:reexp_stripped.rs\n+// build-aux-docs\n+// ignore-cross-compile\n+\n+extern crate reexp_stripped;\n+\n+pub trait Foo {}\n+\n+// @has redirect/index.html\n+// @has - '//code' 'pub use reexp_stripped::Bar'\n+// @has - '//code/a' 'Bar'\n+// @has reexp_stripped/hidden/struct.Bar.html\n+// @has - '//p/a' '../../reexp_stripped/struct.Bar.html'\n+// @has 'reexp_stripped/struct.Bar.html'\n+#[doc(no_inline)]\n+pub use reexp_stripped::Bar;\n+impl Foo for Bar {}\n+\n+// @has redirect/index.html\n+// @has - '//code' 'pub use reexp_stripped::Quz'\n+// @has - '//code/a' 'Quz'\n+// @has reexp_stripped/private/struct.Quz.html\n+// @has - '//p/a' '../../reexp_stripped/struct.Quz.html'\n+// @has 'reexp_stripped/struct.Quz.html'\n+#[doc(no_inline)]\n+pub use reexp_stripped::Quz;\n+impl Foo for Quz {}\n+\n+mod private_no_inline {\n+    pub struct Qux;\n+    impl ::Foo for Qux {}\n+}\n+\n+// @has redirect/index.html\n+// @has - '//code' 'pub use private_no_inline::Qux'\n+// @!has - '//code/a' 'Qux'\n+#[doc(no_inline)]\n+pub use private_no_inline::Qux;"}, {"sha": "c4327f70728cb138d7d660b7f903c34f272d40e5", "filename": "src/test/rustdoc/structfields.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/57e5d43c770201d837298175a2d55818867bdb33/src%2Ftest%2Frustdoc%2Fstructfields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5d43c770201d837298175a2d55818867bdb33/src%2Ftest%2Frustdoc%2Fstructfields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fstructfields.rs?ref=57e5d43c770201d837298175a2d55818867bdb33", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// @has structfields/struct.Foo.html\n+pub struct Foo {\n+    // @has - //pre \"pub a: ()\"\n+    pub a: (),\n+    // @has - //pre \"// some fields omitted\"\n+    // @!has - //pre \"b: ()\"\n+    b: (),\n+    // @!has - //pre \"c: usize\"\n+    #[doc(hidden)]\n+    c: usize,\n+    // @has - //pre \"pub d: usize\"\n+    pub d: usize,\n+}\n+\n+// @has structfields/struct.Bar.html\n+pub struct Bar {\n+    // @has - //pre \"pub a: ()\"\n+    pub a: (),\n+    // @!has - //pre \"// some fields omitted\"\n+}\n+\n+// @has structfields/enum.Qux.html\n+pub enum Qux {\n+    Quz {\n+        // @has - //pre \"a: ()\"\n+        a: (),\n+        // @!has - //pre \"b: ()\"\n+        #[doc(hidden)]\n+        b: (),\n+        // @has - //pre \"c: usize\"\n+        c: usize,\n+        // @has - //pre \"// some fields omitted\"\n+    },\n+}"}]}