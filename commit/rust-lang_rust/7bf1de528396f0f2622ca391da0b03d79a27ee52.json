{"sha": "7bf1de528396f0f2622ca391da0b03d79a27ee52", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiZjFkZTUyODM5NmYwZjI2MjJjYTM5MWRhMGIwM2Q3OWEyN2VlNTI=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-04-08T16:07:23Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-05-16T17:00:13Z"}, "message": "workcache: add crate doc block", "tree": {"sha": "8b74bb81304a39c4cd12d27e2fe78a60b47714bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b74bb81304a39c4cd12d27e2fe78a60b47714bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bf1de528396f0f2622ca391da0b03d79a27ee52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bf1de528396f0f2622ca391da0b03d79a27ee52", "html_url": "https://github.com/rust-lang/rust/commit/7bf1de528396f0f2622ca391da0b03d79a27ee52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bf1de528396f0f2622ca391da0b03d79a27ee52/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ef2169bac46dbf68ec952669bd2b84e2a5bdd46", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ef2169bac46dbf68ec952669bd2b84e2a5bdd46", "html_url": "https://github.com/rust-lang/rust/commit/6ef2169bac46dbf68ec952669bd2b84e2a5bdd46"}], "stats": {"total": 134, "additions": 66, "deletions": 68}, "files": [{"sha": "b7386a97b45167fa86e26710210b42d012579f1c", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 66, "deletions": 68, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/7bf1de528396f0f2622ca391da0b03d79a27ee52/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bf1de528396f0f2622ca391da0b03d79a27ee52/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=7bf1de528396f0f2622ca391da0b03d79a27ee52", "patch": "@@ -8,6 +8,72 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! A simple function caching system.\n+//!\n+//! This is a loose clone of the [fbuild build system](https://github.com/felix-lang/fbuild),\n+//! made a touch more generic (not wired to special cases on files) and much\n+//! less metaprogram-y due to rust's comparative weakness there, relative to\n+//! python.\n+//!\n+//! It's based around _imperative builds_ that happen to have some function\n+//! calls cached. That is, it's _just_ a mechanism for describing cached\n+//! functions. This makes it much simpler and smaller than a \"build system\"\n+//! that produces an IR and evaluates it. The evaluation order is normal\n+//! function calls. Some of them just return really quickly.\n+//!\n+//! A cached function consumes and produces a set of _works_. A work has a\n+//! name, a kind (that determines how the value is to be checked for\n+//! freshness) and a value. Works must also be (de)serializable. Some\n+//! examples of works:\n+//!\n+//!    kind   name    value\n+//!   ------------------------\n+//!    cfg    os      linux\n+//!    file   foo.c   <sha1>\n+//!    url    foo.com <etag>\n+//!\n+//! Works are conceptually single units, but we store them most of the time\n+//! in maps of the form (type,name) => value. These are WorkMaps.\n+//!\n+//! A cached function divides the works it's interested in into inputs and\n+//! outputs, and subdivides those into declared (input) works and\n+//! discovered (input and output) works.\n+//!\n+//! A _declared_ input or is one that is given to the workcache before\n+//! any work actually happens, in the \"prep\" phase. Even when a function's\n+//! work-doing part (the \"exec\" phase) never gets called, it has declared\n+//! inputs, which can be checked for freshness (and potentially\n+//! used to determine that the function can be skipped).\n+//!\n+//! The workcache checks _all_ works for freshness, but uses the set of\n+//! discovered outputs from the _previous_ exec (which it will re-discover\n+//! and re-record each time the exec phase runs).\n+//!\n+//! Therefore the discovered works cached in the db might be a\n+//! mis-approximation of the current discoverable works, but this is ok for\n+//! the following reason: we assume that if an artifact A changed from\n+//! depending on B,C,D to depending on B,C,D,E, then A itself changed (as\n+//! part of the change-in-dependencies), so we will be ok.\n+//!\n+//! Each function has a single discriminated output work called its _result_.\n+//! This is only different from other works in that it is returned, by value,\n+//! from a call to the cacheable function; the other output works are used in\n+//! passing to invalidate dependencies elsewhere in the cache, but do not\n+//! otherwise escape from a function invocation. Most functions only have one\n+//! output work anyways.\n+//!\n+//! A database (the central store of a workcache) stores a mappings:\n+//!\n+//! (fn_name,{declared_input}) => ({discovered_input},\n+//!                                {discovered_output},result)\n+//!\n+//! (Note: fbuild, which workcache is based on, has the concept of a declared\n+//! output as separate from a discovered output. This distinction exists only\n+//! as an artifact of how fbuild works: via annotations on function types\n+//! and metaprogramming, with explicit dependency declaration as a fallback.\n+//! Workcache is more explicit about dependencies, and as such treats all\n+//! outputs the same, as discovered-during-the-last-run.)\n+\n #![crate_id = \"workcache#0.11.0-pre\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -33,74 +99,6 @@ use std::str;\n use std::io;\n use std::io::{File, MemWriter};\n \n-/**\n-*\n-* This is a loose clone of the [fbuild build system](https://github.com/felix-lang/fbuild),\n-* made a touch more generic (not wired to special cases on files) and much\n-* less metaprogram-y due to rust's comparative weakness there, relative to\n-* python.\n-*\n-* It's based around _imperative builds_ that happen to have some function\n-* calls cached. That is, it's _just_ a mechanism for describing cached\n-* functions. This makes it much simpler and smaller than a \"build system\"\n-* that produces an IR and evaluates it. The evaluation order is normal\n-* function calls. Some of them just return really quickly.\n-*\n-* A cached function consumes and produces a set of _works_. A work has a\n-* name, a kind (that determines how the value is to be checked for\n-* freshness) and a value. Works must also be (de)serializable. Some\n-* examples of works:\n-*\n-*    kind   name    value\n-*   ------------------------\n-*    cfg    os      linux\n-*    file   foo.c   <sha1>\n-*    url    foo.com <etag>\n-*\n-* Works are conceptually single units, but we store them most of the time\n-* in maps of the form (type,name) => value. These are WorkMaps.\n-*\n-* A cached function divides the works it's interested in into inputs and\n-* outputs, and subdivides those into declared (input) works and\n-* discovered (input and output) works.\n-*\n-* A _declared_ input or is one that is given to the workcache before\n-* any work actually happens, in the \"prep\" phase. Even when a function's\n-* work-doing part (the \"exec\" phase) never gets called, it has declared\n-* inputs, which can be checked for freshness (and potentially\n-* used to determine that the function can be skipped).\n-*\n-* The workcache checks _all_ works for freshness, but uses the set of\n-* discovered outputs from the _previous_ exec (which it will re-discover\n-* and re-record each time the exec phase runs).\n-*\n-* Therefore the discovered works cached in the db might be a\n-* mis-approximation of the current discoverable works, but this is ok for\n-* the following reason: we assume that if an artifact A changed from\n-* depending on B,C,D to depending on B,C,D,E, then A itself changed (as\n-* part of the change-in-dependencies), so we will be ok.\n-*\n-* Each function has a single discriminated output work called its _result_.\n-* This is only different from other works in that it is returned, by value,\n-* from a call to the cacheable function; the other output works are used in\n-* passing to invalidate dependencies elsewhere in the cache, but do not\n-* otherwise escape from a function invocation. Most functions only have one\n-* output work anyways.\n-*\n-* A database (the central store of a workcache) stores a mappings:\n-*\n-* (fn_name,{declared_input}) => ({discovered_input},\n-*                                {discovered_output},result)\n-*\n-* (Note: fbuild, which workcache is based on, has the concept of a declared\n-* output as separate from a discovered output. This distinction exists only\n-* as an artifact of how fbuild works: via annotations on function types\n-* and metaprogramming, with explicit dependency declaration as a fallback.\n-* Workcache is more explicit about dependencies, and as such treats all\n-* outputs the same, as discovered-during-the-last-run.)\n-*\n-*/\n-\n #[deriving(Clone, Eq, Encodable, Decodable, Ord, TotalOrd, TotalEq)]\n struct WorkKey {\n     kind: StrBuf,"}]}