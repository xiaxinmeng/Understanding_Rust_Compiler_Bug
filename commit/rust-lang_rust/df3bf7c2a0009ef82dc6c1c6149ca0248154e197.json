{"sha": "df3bf7c2a0009ef82dc6c1c6149ca0248154e197", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmM2JmN2MyYTAwMDllZjgyZGM2YzFjNjE0OWNhMDI0ODE1NGUxOTc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-05-08T13:37:32Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-05-08T14:09:40Z"}, "message": "parser: Consolidate some duplicated code", "tree": {"sha": "fe4b6bb9ab0484500a9b57c50ec52e91ce94a5cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe4b6bb9ab0484500a9b57c50ec52e91ce94a5cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df3bf7c2a0009ef82dc6c1c6149ca0248154e197", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df3bf7c2a0009ef82dc6c1c6149ca0248154e197", "html_url": "https://github.com/rust-lang/rust/commit/df3bf7c2a0009ef82dc6c1c6149ca0248154e197", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df3bf7c2a0009ef82dc6c1c6149ca0248154e197/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4885ffb5796e780fc4307c9342af082f747cb229", "url": "https://api.github.com/repos/rust-lang/rust/commits/4885ffb5796e780fc4307c9342af082f747cb229", "html_url": "https://github.com/rust-lang/rust/commit/4885ffb5796e780fc4307c9342af082f747cb229"}], "stats": {"total": 175, "additions": 79, "deletions": 96}, "files": [{"sha": "d6add5aae12e6ec598606277f43acc165ace2070", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 79, "deletions": 96, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/df3bf7c2a0009ef82dc6c1c6149ca0248154e197/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df3bf7c2a0009ef82dc6c1c6149ca0248154e197/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=df3bf7c2a0009ef82dc6c1c6149ca0248154e197", "patch": "@@ -618,7 +618,7 @@ fn parse_field(p: parser, sep: token::token) -> ast::field {\n     ret spanned(lo, e.span.hi, {mutbl: m, ident: i, expr: e});\n }\n \n-fn mk_expr(p: parser, lo: uint, hi: uint, node: ast::expr_) -> @ast::expr {\n+fn mk_expr(p: parser, lo: uint, hi: uint, +node: ast::expr_) -> @ast::expr {\n     ret @{id: p.get_id(), node: node, span: mk_sp(lo, hi)};\n }\n \n@@ -1501,7 +1501,7 @@ fn parse_instance_var(p:parser, pr: ast::privacy) -> @ast::class_member {\n           span: mk_sp(lo, p.last_span.hi)};\n }\n \n-fn parse_stmt(p: parser, first_item_attrs: [ast::attribute]) -> @ast::stmt {\n+fn parse_stmt(p: parser, +first_item_attrs: [ast::attribute]) -> @ast::stmt {\n     fn check_expected_item(p: parser, current_attrs: [ast::attribute]) {\n         // If we have attributes then we should have an item\n         if vec::is_not_empty(current_attrs) {\n@@ -1603,7 +1603,7 @@ fn parse_block_tail(p: parser, lo: uint, s: ast::blk_check_mode) -> ast::blk {\n }\n \n fn parse_block_tail_(p: parser, lo: uint, s: ast::blk_check_mode,\n-                     first_item_attrs: [ast::attribute]) -> ast::blk {\n+                     +first_item_attrs: [ast::attribute]) -> ast::blk {\n     let mut stmts = [];\n     let mut expr = none;\n     let view_items = maybe_parse_view_import_only(p, first_item_attrs);\n@@ -1788,24 +1788,22 @@ fn parse_fn_header(p: parser) -> {ident: ast::ident, tps: [ast::ty_param]} {\n     ret {ident: id, tps: ty_params};\n }\n \n-fn mk_item(p: parser, lo: uint, hi: uint, ident: ast::ident, node: ast::item_,\n-           attrs: [ast::attribute]) -> @ast::item {\n+fn mk_item(p: parser, lo: uint, hi: uint, +ident: ast::ident,\n+           +node: ast::item_, +attrs: [ast::attribute]) -> @ast::item {\n     ret @{ident: ident,\n           attrs: attrs,\n           id: p.get_id(),\n           node: node,\n           span: mk_sp(lo, hi)};\n }\n \n-fn parse_item_fn(p: parser, purity: ast::purity,\n-                 attrs: [ast::attribute]) -> @ast::item {\n-    let lo = p.last_span.lo;\n+type item_info = (ast::ident, ast::item_, option<[ast::attribute]>);\n+\n+fn parse_item_fn(p: parser, purity: ast::purity) -> item_info {\n     let t = parse_fn_header(p);\n     let (decl, _) = parse_fn_decl(p, purity, parse_arg);\n     let (inner_attrs, body) = parse_inner_attrs_and_block(p, true);\n-    let attrs = attrs + inner_attrs;\n-    ret mk_item(p, lo, body.span.hi, t.ident,\n-                ast::item_fn(decl, t.tps, body), attrs);\n+    (t.ident, ast::item_fn(decl, t.tps, body), some(inner_attrs))\n }\n \n fn parse_method_name(p: parser) -> ast::ident {\n@@ -1834,21 +1832,19 @@ fn parse_method(p: parser, pr: ast::privacy) -> @ast::method {\n       self_id: p.get_id(), privacy: pr}\n }\n \n-fn parse_item_iface(p: parser, attrs: [ast::attribute]) -> @ast::item {\n-    let lo = p.last_span.lo, ident = parse_ident(p);\n+fn parse_item_iface(p: parser) -> item_info {\n+    let ident = parse_ident(p);\n     let rp = parse_region_param(p);\n     let tps = parse_ty_params(p);\n     let meths = parse_ty_methods(p);\n-    ret mk_item(p, lo, p.last_span.hi, ident,\n-                ast::item_iface(tps, rp, meths), attrs);\n+    (ident, ast::item_iface(tps, rp, meths), none)\n }\n \n // Parses three variants (with the region/type params always optional):\n //    impl /&<T: copy> of to_str for [T] { ... }\n //    impl name/&<T> of to_str for [T] { ... }\n //    impl name/&<T> for [T] { ... }\n-fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n-    let lo = p.last_span.lo;\n+fn parse_item_impl(p: parser) -> item_info {\n     fn wrap_path(p: parser, pt: @ast::path) -> @ast::ty {\n         @{id: p.get_id(), node: ast::ty_path(pt, p.get_id()), span: pt.span}\n     }\n@@ -1882,12 +1878,10 @@ fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let mut meths = [];\n     expect(p, token::LBRACE);\n     while !eat(p, token::RBRACE) { meths += [parse_method(p, ast::pub)]; }\n-    ret mk_item(p, lo, p.last_span.hi, ident,\n-                ast::item_impl(tps, rp, ifce, ty, meths), attrs);\n+    (ident, ast::item_impl(tps, rp, ifce, ty, meths), none)\n }\n \n-fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n-    let lo = p.last_span.lo;\n+fn parse_item_res(p: parser) -> item_info {\n     let ident = parse_value_ident(p);\n     let rp = parse_region_param(p);\n     let ty_params = parse_ty_params(p);\n@@ -1897,20 +1891,17 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let t = parse_ty(p, false);\n     expect(p, token::RPAREN);\n     let dtor = parse_block_no_value(p);\n-    let decl =\n-        {inputs:\n-             [{mode: ast::expl(ast::by_ref), ty: t,\n-               ident: arg_ident, id: p.get_id()}],\n-         output: @{id: p.get_id(),\n-                   node: ast::ty_nil,\n-                   span: mk_sp(lo, lo)},\n-         purity: ast::impure_fn,\n-         cf: ast::return_val,\n-         constraints: []};\n-    ret mk_item(p, lo, dtor.span.hi, ident,\n-                ast::item_res(decl, ty_params, dtor,\n-                              p.get_id(), p.get_id(), rp),\n-                attrs);\n+    let decl = {\n+        inputs: [{mode: ast::expl(ast::by_ref), ty: t,\n+                  ident: arg_ident, id: p.get_id()}],\n+        output: @{id: p.get_id(), node: ast::ty_nil,\n+                  span: ast_util::dummy_sp()},\n+        purity: ast::impure_fn,\n+        cf: ast::return_val,\n+        constraints: []\n+    };\n+    (ident, ast::item_res(decl, ty_params, dtor,\n+                          p.get_id(), p.get_id(), rp), none)\n }\n \n // Instantiates ident <i> with references to <typarams> as arguments.  Used to\n@@ -1946,8 +1937,7 @@ fn parse_iface_ref_list(p:parser) -> [@ast::iface_ref] {\n                             parse_iface_ref, p)\n }\n \n-fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n-    let lo = p.last_span.lo;\n+fn parse_item_class(p: parser) -> item_info {\n     let class_name = parse_value_ident(p);\n     let rp = parse_region_param(p);\n     let ty_params = parse_ty_params(p);\n@@ -1970,13 +1960,15 @@ fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     p.bump();\n     alt the_ctor {\n       some((ct_d, ct_b, ct_s)) {\n-          ret mk_item(p, lo, p.last_span.hi, class_name,\n-                      ast::item_class(ty_params, ifaces, ms,\n-                                      {node: {id: ctor_id,\n-                                              self_id: p.get_id(),\n-                                              dec: ct_d,\n-                                              body: ct_b},\n-                                       span: ct_s}, rp), attrs); }\n+        (class_name,\n+         ast::item_class(ty_params, ifaces, ms, {\n+             node: {id: ctor_id,\n+                    self_id: p.get_id(),\n+                    dec: ct_d,\n+                    body: ct_b},\n+             span: ct_s}, rp),\n+        none)\n+      }\n        /*\n          Is it strange for the parser to check this?\n        */\n@@ -2034,13 +2026,14 @@ fn parse_class_item(p:parser, class_name_with_tps: @ast::path)\n }\n \n fn parse_mod_items(p: parser, term: token::token,\n-                   first_item_attrs: [ast::attribute]) -> ast::_mod {\n+                   +first_item_attrs: [ast::attribute]) -> ast::_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n     let view_items = maybe_parse_view(p, first_item_attrs);\n     let mut items: [@ast::item] = [];\n-    let mut initial_attrs = first_item_attrs;\n+    let mut first = true;\n     while p.token != term {\n-        let attrs = initial_attrs + parse_outer_attributes(p);\n+        let mut attrs = parse_outer_attributes(p);\n+        if first { attrs = first_item_attrs + attrs; first = false; }\n         #debug[\"parse_mod_items: parse_item(attrs=%?)\", attrs];\n         alt parse_item(p, attrs) {\n           some(i) { items += [i]; }\n@@ -2050,42 +2043,36 @@ fn parse_mod_items(p: parser, term: token::token,\n           }\n         }\n         #debug[\"parse_mod_items: attrs=%?\", attrs];\n-        initial_attrs = [];\n     }\n \n-    if vec::is_not_empty(initial_attrs) {\n+    if first && first_item_attrs.len() > 0u {\n         // We parsed attributes for the first item but didn't find the item\n         p.fatal(\"expected item\");\n     }\n \n     ret {view_items: view_items, items: items};\n }\n \n-fn parse_item_const(p: parser, attrs: [ast::attribute]) -> @ast::item {\n-    let lo = p.last_span.lo;\n+fn parse_item_const(p: parser) -> item_info {\n     let id = parse_value_ident(p);\n     expect(p, token::COLON);\n     let ty = parse_ty(p, false);\n     expect(p, token::EQ);\n     let e = parse_expr(p);\n-    let mut hi = p.span.hi;\n     expect(p, token::SEMI);\n-    ret mk_item(p, lo, hi, id, ast::item_const(ty, e), attrs);\n+    (id, ast::item_const(ty, e), none)\n }\n \n-fn parse_item_mod(p: parser, attrs: [ast::attribute]) -> @ast::item {\n-    let lo = p.last_span.lo;\n+fn parse_item_mod(p: parser) -> item_info {\n     let id = parse_ident(p);\n     expect(p, token::LBRACE);\n     let inner_attrs = parse_inner_attrs_and_next(p);\n-    let first_item_outer_attrs = inner_attrs.next;\n-    let m = parse_mod_items(p, token::RBRACE, first_item_outer_attrs);\n-    let mut hi = p.span.hi;\n+    let m = parse_mod_items(p, token::RBRACE, inner_attrs.next);\n     expect(p, token::RBRACE);\n-    ret mk_item(p, lo, hi, id, ast::item_mod(m), attrs + inner_attrs.inner);\n+    (id, ast::item_mod(m), some(inner_attrs.inner))\n }\n \n-fn parse_item_native_fn(p: parser, attrs: [ast::attribute],\n+fn parse_item_native_fn(p: parser, +attrs: [ast::attribute],\n                         purity: ast::purity) -> @ast::native_item {\n     let lo = p.last_span.lo;\n     let t = parse_fn_header(p);\n@@ -2109,12 +2096,12 @@ fn parse_fn_purity(p: parser) -> ast::purity {\n     else { unexpected(p); }\n }\n \n-fn parse_native_item(p: parser, attrs: [ast::attribute]) ->\n+fn parse_native_item(p: parser, +attrs: [ast::attribute]) ->\n    @ast::native_item {\n     parse_item_native_fn(p, attrs, parse_fn_purity(p))\n }\n \n-fn parse_native_mod_items(p: parser, first_item_attrs: [ast::attribute]) ->\n+fn parse_native_mod_items(p: parser, +first_item_attrs: [ast::attribute]) ->\n    ast::native_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n     let view_items =\n@@ -2132,18 +2119,14 @@ fn parse_native_mod_items(p: parser, first_item_attrs: [ast::attribute]) ->\n          items: items};\n }\n \n-fn parse_item_native_mod(p: parser, attrs: [ast::attribute]) -> @ast::item {\n-    let lo = p.last_span.lo;\n+fn parse_item_native_mod(p: parser) -> item_info {\n     expect_keyword(p, \"mod\");\n     let id = parse_ident(p);\n     expect(p, token::LBRACE);\n     let more_attrs = parse_inner_attrs_and_next(p);\n-    let inner_attrs = more_attrs.inner;\n-    let first_item_outer_attrs = more_attrs.next;\n-    let m = parse_native_mod_items(p, first_item_outer_attrs);\n-    let mut hi = p.span.hi;\n+    let m = parse_native_mod_items(p, more_attrs.next);\n     expect(p, token::RBRACE);\n-    ret mk_item(p, lo, hi, id, ast::item_native_mod(m), attrs + inner_attrs);\n+    (id, ast::item_native_mod(m), some(more_attrs.inner))\n }\n \n fn parse_type_decl(p: parser) -> {lo: uint, ident: ast::ident} {\n@@ -2152,15 +2135,14 @@ fn parse_type_decl(p: parser) -> {lo: uint, ident: ast::ident} {\n     ret {lo: lo, ident: id};\n }\n \n-fn parse_item_type(p: parser, attrs: [ast::attribute]) -> @ast::item {\n+fn parse_item_type(p: parser) -> item_info {\n     let t = parse_type_decl(p);\n     let rp = parse_region_param(p);\n     let tps = parse_ty_params(p);\n     expect(p, token::EQ);\n     let ty = parse_ty(p, false);\n-    let mut hi = p.span.hi;\n     expect(p, token::SEMI);\n-    ret mk_item(p, t.lo, hi, t.ident, ast::item_ty(ty, tps, rp), attrs);\n+    (t.ident, ast::item_ty(ty, tps, rp), none)\n }\n \n fn parse_region_param(p: parser) -> ast::region_param {\n@@ -2172,8 +2154,7 @@ fn parse_region_param(p: parser) -> ast::region_param {\n     }\n }\n \n-fn parse_item_enum(p: parser, attrs: [ast::attribute]) -> @ast::item {\n-    let lo = p.last_span.lo;\n+fn parse_item_enum(p: parser) -> item_info {\n     let id = parse_ident(p);\n     let rp = parse_region_param(p);\n     let ty_params = parse_ty_params(p);\n@@ -2191,8 +2172,7 @@ fn parse_item_enum(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                      args: [{ty: ty, id: p.get_id()}],\n                      id: p.get_id(),\n                      disr_expr: none});\n-        ret mk_item(p, lo, ty.span.hi, id,\n-                    ast::item_enum([variant], ty_params, rp), attrs);\n+        ret (id, ast::item_enum([variant], ty_params, rp), none);\n     }\n     expect(p, token::LBRACE);\n \n@@ -2227,8 +2207,7 @@ fn parse_item_enum(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     if (have_disr && !all_nullary) {\n         p.fatal(\"discriminator values can only be used with a c-like enum\");\n     }\n-    ret mk_item(p, lo, p.last_span.hi, id,\n-                ast::item_enum(variants, ty_params, rp), attrs);\n+    (id, ast::item_enum(variants, ty_params, rp), none)\n }\n \n fn parse_fn_ty_proto(p: parser) -> ast::proto {\n@@ -2262,40 +2241,44 @@ fn fn_expr_lookahead(tok: token::token) -> bool {\n     }\n }\n \n-fn parse_item(p: parser, attrs: [ast::attribute]) -> option<@ast::item> {\n-    if eat_keyword(p, \"const\") {\n-        ret some(parse_item_const(p, attrs));\n+fn parse_item(p: parser, +attrs: [ast::attribute]) -> option<@ast::item> {\n+    let lo = p.span.lo;\n+    let (ident, item_, extra_attrs) = if eat_keyword(p, \"const\") {\n+        parse_item_const(p)\n     } else if is_keyword(p, \"fn\") && !fn_expr_lookahead(p.look_ahead(1u)) {\n         p.bump();\n-        ret some(parse_item_fn(p, ast::impure_fn, attrs));\n+        parse_item_fn(p, ast::impure_fn)\n     } else if eat_keyword(p, \"pure\") {\n         expect_keyword(p, \"fn\");\n-        ret some(parse_item_fn(p, ast::pure_fn, attrs));\n+        parse_item_fn(p, ast::pure_fn)\n     } else if is_keyword(p, \"unsafe\") && p.look_ahead(1u) != token::LBRACE {\n         p.bump();\n         expect_keyword(p, \"fn\");\n-        ret some(parse_item_fn(p, ast::unsafe_fn, attrs));\n+        parse_item_fn(p, ast::unsafe_fn)\n     } else if eat_keyword(p, \"crust\") {\n         expect_keyword(p, \"fn\");\n-        ret some(parse_item_fn(p, ast::crust_fn, attrs));\n+        parse_item_fn(p, ast::crust_fn)\n     } else if eat_keyword(p, \"mod\") {\n-        ret some(parse_item_mod(p, attrs));\n+        parse_item_mod(p)\n     } else if eat_keyword(p, \"native\") {\n-        ret some(parse_item_native_mod(p, attrs));\n-    } if eat_keyword(p, \"type\") {\n-        ret some(parse_item_type(p, attrs));\n+        parse_item_native_mod(p)\n+    } else if eat_keyword(p, \"type\") {\n+        parse_item_type(p)\n     } else if eat_keyword(p, \"enum\") {\n-        ret some(parse_item_enum(p, attrs));\n+        parse_item_enum(p)\n     } else if eat_keyword(p, \"iface\") {\n-        ret some(parse_item_iface(p, attrs));\n+        parse_item_iface(p)\n     } else if eat_keyword(p, \"impl\") {\n-        ret some(parse_item_impl(p, attrs));\n+        parse_item_impl(p)\n     } else if eat_keyword(p, \"resource\") {\n-        ret some(parse_item_res(p, attrs));\n+        parse_item_res(p)\n     } else if eat_keyword(p, \"class\") {\n-        ret some(parse_item_class(p, attrs));\n-    }\n-else { ret none; }\n+        parse_item_class(p)\n+    } else { ret none; };\n+    some(mk_item(p, lo, p.last_span.hi, ident, item_, alt extra_attrs {\n+        some(as) { attrs + as }\n+        none { attrs }\n+    }))\n }\n \n fn parse_use(p: parser) -> ast::view_item_ {"}]}