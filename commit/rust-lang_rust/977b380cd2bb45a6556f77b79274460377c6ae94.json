{"sha": "977b380cd2bb45a6556f77b79274460377c6ae94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3N2IzODBjZDJiYjQ1YTY1NTZmNzdiNzkyNzQ0NjAzNzdjNmFlOTQ=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-06-26T21:39:54Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-06-28T04:41:17Z"}, "message": "cleanup and shiny new more-functional interface", "tree": {"sha": "3f66bcb05f40c272c6ba3f30ca09648b769c8416", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f66bcb05f40c272c6ba3f30ca09648b769c8416"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/977b380cd2bb45a6556f77b79274460377c6ae94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/977b380cd2bb45a6556f77b79274460377c6ae94", "html_url": "https://github.com/rust-lang/rust/commit/977b380cd2bb45a6556f77b79274460377c6ae94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/977b380cd2bb45a6556f77b79274460377c6ae94/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a18a63185ca79126842d94505746fccef3ade1b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a18a63185ca79126842d94505746fccef3ade1b8", "html_url": "https://github.com/rust-lang/rust/commit/a18a63185ca79126842d94505746fccef3ade1b8"}], "stats": {"total": 91, "additions": 36, "deletions": 55}, "files": [{"sha": "69f4fdb9f3fc4869d20dff388691d98e84d8c83f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 36, "deletions": 55, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/977b380cd2bb45a6556f77b79274460377c6ae94/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/977b380cd2bb45a6556f77b79274460377c6ae94/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=977b380cd2bb45a6556f77b79274460377c6ae94", "patch": "@@ -614,14 +614,10 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                     // oh dear heaven... this is going to include the enum\n                     // names, as well... but that should be okay, as long as\n                     // the new names are gensyms for the old ones.\n-                    let mut name_finder = new_name_finder(Vec::new());\n-                    name_finder.visit_pat(&*expanded_pat,());\n                     // generate fresh names, push them to a new pending list\n-                    let mut new_pending_renames = Vec::new();\n-                    for ident in name_finder.ident_accumulator.iter() {\n-                        let new_name = fresh_name(ident);\n-                        new_pending_renames.push((*ident,new_name));\n-                    }\n+                    let idents = pattern_bindings(expanded_pat);\n+                    let mut new_pending_renames =\n+                        idents.iter().map(|ident| (*ident, fresh_name(ident))).collect();\n                     let rewritten_pat = {\n                         let mut rename_fld =\n                             IdentRenamer{renames: &mut new_pending_renames};\n@@ -668,10 +664,8 @@ fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     // code duplicated from 'let', above. Perhaps this can be lifted\n     // into a separate function:\n     let expanded_pat = fld.fold_pat(*first_pat);\n-    let mut name_finder = new_name_finder(Vec::new());\n-    name_finder.visit_pat(&*expanded_pat,());\n     let mut new_pending_renames = Vec::new();\n-    for ident in name_finder.ident_accumulator.iter() {\n+    for ident in pattern_bindings(expanded_pat).iter() {\n         let new_name = fresh_name(ident);\n         new_pending_renames.push((*ident,new_name));\n     }\n@@ -681,8 +675,6 @@ fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n         // ones have already been applied):\n         rename_fld.fold_pat(expanded_pat)\n     };\n-    /*\n-    */\n     ast::Arm {\n         attrs: arm.attrs.iter().map(|x| fld.fold_attribute(*x)).collect(),\n         pats: arm.pats.iter().map(|x| fld.fold_pat(*x)).collect(),\n@@ -695,7 +687,7 @@ fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n \n // a visitor that extracts the pat_ident (binding) paths\n // from a given thingy and puts them in a mutable\n-// array (passed in to the traversal).\n+// array\n #[deriving(Clone)]\n struct NameFinderContext {\n     ident_accumulator: Vec<ast::Ident> ,\n@@ -735,13 +727,11 @@ impl Visitor<()> for NameFinderContext {\n \n }\n \n-// return a visitor that extracts the pat_ident paths\n-// from a given thingy and puts them in a mutable\n-// array (passed in to the traversal)\n-fn new_name_finder(idents: Vec<ast::Ident> ) -> NameFinderContext {\n-    NameFinderContext {\n-        ident_accumulator: idents,\n-    }\n+// find the pat_ident paths in a pattern\n+fn pattern_bindings(pat : &ast::Pat) -> Vec<ast::Ident> {\n+    let mut name_finder = NameFinderContext{ident_accumulator:Vec::new()};\n+    name_finder.visit_pat(pat,());\n+    name_finder.ident_accumulator\n }\n \n // expand a block. pushes a new exts_frame, then calls expand_block_elts\n@@ -1046,7 +1036,8 @@ fn original_span(cx: &ExtCtxt) -> Gc<codemap::ExpnInfo> {\n \n #[cfg(test)]\n mod test {\n-    use super::{new_name_finder, expand_crate, contains_macro_escape};\n+    use super::{pattern_bindings, expand_crate, contains_macro_escape};\n+    use super::{NameFinderContext};\n     use ast;\n     use ast::{Attribute_, AttrOuter, MetaWord};\n     use attr;\n@@ -1076,22 +1067,22 @@ mod test {\n             match *expr {\n                 ast::Expr{id:_,span:_,node:ast::ExprPath(ref p)} => {\n                     self.path_accumulator.push(p.clone());\n-                    // not calling visit_path, should be fine.\n+                    // not calling visit_path, but it should be fine.\n                 }\n                 _ => visit::walk_expr(self,expr,())\n             }\n         }\n     }\n \n-    // return a visitor that extracts the paths\n-    // from a given thingy and puts them in a mutable\n-    // array (passed in to the traversal)\n-    fn new_path_finder(paths: Vec<ast::Path> ) -> PathExprFinderContext {\n-        PathExprFinderContext {\n-            path_accumulator: paths\n-        }\n+    // find the variable references in a crate\n+    fn crate_varrefs(the_crate : &ast::Crate) -> Vec<ast::Path> {\n+        let mut path_finder = PathExprFinderContext{path_accumulator:Vec::new()};\n+        visit::walk_crate(&mut path_finder, the_crate, ());\n+        path_finder.path_accumulator\n     }\n \n+\n+\n     // these following tests are quite fragile, in that they don't test what\n     // *kind* of failure occurs.\n \n@@ -1183,6 +1174,14 @@ mod test {\n         expand_crate(&ps,cfg,vec!(),vec!(),crate_ast)\n     }\n \n+    // find the pat_ident paths in a crate\n+    fn crate_bindings(the_crate : &ast::Crate) -> Vec<ast::Ident> {\n+        let mut name_finder = NameFinderContext{ident_accumulator:Vec::new()};\n+        visit::walk_crate(&mut name_finder, the_crate, ());\n+        name_finder.ident_accumulator\n+    }\n+\n+\n     //fn expand_and_resolve(crate_str: @str) -> ast::crate {\n         //let expanded_ast = expand_crate_str(crate_str);\n         // println!(\"expanded: {:?}\\n\",expanded_ast);\n@@ -1315,15 +1314,8 @@ mod test {\n             (ref str,ref conns, bic) => (str.to_owned(), conns.clone(), bic)\n         };\n         let cr = expand_crate_str(teststr.to_string());\n-        // find the bindings:\n-        let mut name_finder = new_name_finder(Vec::new());\n-        visit::walk_crate(&mut name_finder,&cr,());\n-        let bindings = name_finder.ident_accumulator;\n-\n-        // find the varrefs:\n-        let mut path_finder = new_path_finder(Vec::new());\n-        visit::walk_crate(&mut path_finder,&cr,());\n-        let varrefs = path_finder.path_accumulator;\n+        let bindings = crate_bindings(&cr);\n+        let varrefs = crate_varrefs(&cr);\n \n         // must be one check clause for each binding:\n         assert_eq!(bindings.len(),bound_connections.len());\n@@ -1392,10 +1384,7 @@ foo_module!()\n \".to_string();\n         let cr = expand_crate_str(crate_str);\n         // find the xx binding\n-        let mut name_finder = new_name_finder(Vec::new());\n-        visit::walk_crate(&mut name_finder, &cr, ());\n-        let bindings = name_finder.ident_accumulator;\n-\n+        let bindings = crate_bindings(&cr);\n         let cxbinds: Vec<&ast::Ident> =\n             bindings.iter().filter(|b| {\n                 let ident = token::get_ident(**b);\n@@ -1408,10 +1397,7 @@ foo_module!()\n             _ => fail!(\"expected just one binding for ext_cx\")\n         };\n         let resolved_binding = mtwt::resolve(*cxbind);\n-        // find all the xx varrefs:\n-        let mut path_finder = new_path_finder(Vec::new());\n-        visit::walk_crate(&mut path_finder, &cr, ());\n-        let varrefs = path_finder.path_accumulator;\n+        let varrefs = crate_varrefs(&cr);\n \n         // the xx binding should bind all of the xx varrefs:\n         for (idx,v) in varrefs.iter().filter(|p| {\n@@ -1437,10 +1423,8 @@ foo_module!()\n     fn pat_idents(){\n         let pat = string_to_pat(\n             \"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\".to_string());\n-        let mut pat_idents = new_name_finder(Vec::new());\n-        pat_idents.visit_pat(pat, ());\n-        assert_eq!(pat_idents.ident_accumulator,\n-                   strs_to_idents(vec!(\"a\",\"c\",\"b\",\"d\")));\n+        let idents = pattern_bindings(pat);\n+        assert_eq!(idents, strs_to_idents(vec!(\"a\",\"c\",\"b\",\"d\")));\n     }\n \n     // test the list of identifier patterns gathered by the visitor. Note that\n@@ -1450,11 +1434,8 @@ foo_module!()\n     fn crate_idents(){\n         let the_crate = string_to_crate(\"fn main (a : int) -> int {|b| {\n         match 34 {None => 3, Some(i) | i => j, Foo{k:z,l:y} => \\\"banana\\\"}} }\".to_string());\n-        let mut idents = new_name_finder(Vec::new());\n-        //visit::walk_crate(&mut idents, &the_crate, ());\n-        idents.visit_mod(&the_crate.module, the_crate.span, ast::CRATE_NODE_ID, ());\n-        assert_eq!(idents.ident_accumulator,\n-                   strs_to_idents(vec!(\"a\",\"b\",\"None\",\"i\",\"i\",\"z\",\"y\")));\n+        let idents = crate_bindings(&the_crate);\n+        assert_eq!(idents, strs_to_idents(vec!(\"a\",\"b\",\"None\",\"i\",\"i\",\"z\",\"y\")));\n     }\n \n "}]}