{"sha": "df1f41530509308d4271f5b8204809e025293857", "node_id": "C_kwDOAAsO6NoAKGRmMWY0MTUzMDUwOTMwOGQ0MjcxZjViODIwNDgwOWUwMjUyOTM4NTc", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-06T09:19:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-06T09:19:10Z"}, "message": "Rollup merge of #98884 - davidtwco:translation-on-lints-derive, r=oli-obk\n\nmacros: `LintDiagnostic` derive\n\n- Move `LintDiagnosticBuilder` into `rustc_errors` so that a diagnostic derive can refer to it.\n- Introduce a `DecorateLint` trait, which is equivalent to `SessionDiagnostic` or `AddToDiagnostic` but for lints. Necessary without making more changes to the lint infrastructure as `DecorateLint` takes a `LintDiagnosticBuilder` and re-uses all of the existing logic for determining what type of diagnostic a lint should be emitted as (e.g. error/warning).\n- Various refactorings of the diagnostic derive machinery (extracting `build_field_mapping` helper and moving `sess` field out of the `DiagnosticDeriveBuilder`).\n- Introduce a `LintDiagnostic` derive macro that works almost exactly like the `SessionDiagnostic` derive macro  except that it derives a `DecorateLint` implementation instead. A new derive is necessary for this because `SessionDiagnostic` is intended for when the generated code creates the diagnostic. `AddToDiagnostic` could have been used but it would have required more changes to the lint machinery.\n\n~~At time of opening this pull request, ignore all of the commits from #98624, it's just the last few commits that are new.~~\n\nr? `@oli-obk`", "tree": {"sha": "7ec6ff3f05d000b730606be79d40a2bb354d7ab7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ec6ff3f05d000b730606be79d40a2bb354d7ab7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df1f41530509308d4271f5b8204809e025293857", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJixVOOCRBK7hj4Ov3rIwAAtHsIAHngENlc/P/chKLDV/E+49gB\n6wMUAUF2v1PKS7fJVWElF3VDAZQr45XAmsW3Low3vZmoMKLt0s0GiM3QqP3+hPQp\nLXJnO+1W4EWY3URmEKAGmqatpuKKaK5K1MnSsPfxpW/ZWWYrFADzoWVp9DDrjHbU\nI6qY5mvPTvyvmKsxOEI31p3i7t/SpX5pdjPwYmta3qXkOSicBRv9DKLa2rd6OMJd\nIopmgw0bKE412/6S5KeB2BcgpxefHyFjc+S8MMRuO04MHSxJpRexL9liQ1MkNkFf\nsWxGRFLwiXtob+Jol54fLlrU53d1oIBoDzd6Mr0xUz2oGCqpvrNJBAdeRa7o+cY=\n=n1iZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 7ec6ff3f05d000b730606be79d40a2bb354d7ab7\nparent 707c0d9a2d37da38b21222cd4b98e10a93a2643d\nparent 9d864c8d56fee09abae2be2bed1d4dc1a86b457b\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1657099150 +0530\ncommitter GitHub <noreply@github.com> 1657099150 +0530\n\nRollup merge of #98884 - davidtwco:translation-on-lints-derive, r=oli-obk\n\nmacros: `LintDiagnostic` derive\n\n- Move `LintDiagnosticBuilder` into `rustc_errors` so that a diagnostic derive can refer to it.\n- Introduce a `DecorateLint` trait, which is equivalent to `SessionDiagnostic` or `AddToDiagnostic` but for lints. Necessary without making more changes to the lint infrastructure as `DecorateLint` takes a `LintDiagnosticBuilder` and re-uses all of the existing logic for determining what type of diagnostic a lint should be emitted as (e.g. error/warning).\n- Various refactorings of the diagnostic derive machinery (extracting `build_field_mapping` helper and moving `sess` field out of the `DiagnosticDeriveBuilder`).\n- Introduce a `LintDiagnostic` derive macro that works almost exactly like the `SessionDiagnostic` derive macro  except that it derives a `DecorateLint` implementation instead. A new derive is necessary for this because `SessionDiagnostic` is intended for when the generated code creates the diagnostic. `AddToDiagnostic` could have been used but it would have required more changes to the lint machinery.\n\n~~At time of opening this pull request, ignore all of the commits from #98624, it's just the last few commits that are new.~~\n\nr? `@oli-obk`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df1f41530509308d4271f5b8204809e025293857", "html_url": "https://github.com/rust-lang/rust/commit/df1f41530509308d4271f5b8204809e025293857", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df1f41530509308d4271f5b8204809e025293857/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "707c0d9a2d37da38b21222cd4b98e10a93a2643d", "url": "https://api.github.com/repos/rust-lang/rust/commits/707c0d9a2d37da38b21222cd4b98e10a93a2643d", "html_url": "https://github.com/rust-lang/rust/commit/707c0d9a2d37da38b21222cd4b98e10a93a2643d"}, {"sha": "9d864c8d56fee09abae2be2bed1d4dc1a86b457b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d864c8d56fee09abae2be2bed1d4dc1a86b457b", "html_url": "https://github.com/rust-lang/rust/commit/9d864c8d56fee09abae2be2bed1d4dc1a86b457b"}], "stats": {"total": 1648, "additions": 965, "deletions": 683}, "files": [{"sha": "75b9c0fce2295e8e7d85eb356643cfaecd86f7ec", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -4009,6 +4009,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_infer\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_parse_format\",\n  \"rustc_session\","}, {"sha": "0d1d017d87458655a8af1a162a4e991271ef2151", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -1,7 +1,7 @@\n use crate::snippet::Style;\n use crate::{\n-    CodeSuggestion, DiagnosticMessage, Level, MultiSpan, SubdiagnosticMessage, Substitution,\n-    SubstitutionPart, SuggestionStyle,\n+    CodeSuggestion, DiagnosticMessage, EmissionGuarantee, Level, LintDiagnosticBuilder, MultiSpan,\n+    SubdiagnosticMessage, Substitution, SubstitutionPart, SuggestionStyle,\n };\n use rustc_data_structures::stable_map::FxHashMap;\n use rustc_error_messages::FluentValue;\n@@ -168,6 +168,14 @@ pub trait AddSubdiagnostic {\n     fn add_to_diagnostic(self, diag: &mut Diagnostic);\n }\n \n+/// Trait implemented by lint types. This should not be implemented manually. Instead, use\n+/// `#[derive(LintDiagnostic)]` -- see [rustc_macros::LintDiagnostic].\n+#[rustc_diagnostic_item = \"DecorateLint\"]\n+pub trait DecorateLint<'a, G: EmissionGuarantee> {\n+    /// Decorate and emit a lint.\n+    fn decorate_lint(self, diag: LintDiagnosticBuilder<'a, G>);\n+}\n+\n #[must_use]\n #[derive(Clone, Debug, Encodable, Decodable)]\n pub struct Diagnostic {"}, {"sha": "c3341fd68f4a53addf046ef4f1f368050e29ebc7", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -589,3 +589,26 @@ macro_rules! struct_span_err {\n macro_rules! error_code {\n     ($code:ident) => {{ $crate::DiagnosticId::Error(stringify!($code).to_owned()) }};\n }\n+\n+/// Wrapper around a `DiagnosticBuilder` for creating lints.\n+pub struct LintDiagnosticBuilder<'a, G: EmissionGuarantee>(DiagnosticBuilder<'a, G>);\n+\n+impl<'a, G: EmissionGuarantee> LintDiagnosticBuilder<'a, G> {\n+    /// Return the inner `DiagnosticBuilder`, first setting the primary message to `msg`.\n+    pub fn build(mut self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'a, G> {\n+        self.0.set_primary_message(msg);\n+        self.0.set_is_lint();\n+        self.0\n+    }\n+\n+    /// Create a `LintDiagnosticBuilder` from some existing `DiagnosticBuilder`.\n+    pub fn new(err: DiagnosticBuilder<'a, G>) -> LintDiagnosticBuilder<'a, G> {\n+        LintDiagnosticBuilder(err)\n+    }\n+}\n+\n+impl<'a> LintDiagnosticBuilder<'a, ErrorGuaranteed> {\n+    pub fn forget_guarantee(self) -> LintDiagnosticBuilder<'a, ()> {\n+        LintDiagnosticBuilder(self.0.forget_guarantee())\n+    }\n+}"}, {"sha": "ffe4ecebb2e3681a92a2d86f2d501dc35eae9e21", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -370,10 +370,10 @@ impl fmt::Display for ExplicitBug {\n impl error::Error for ExplicitBug {}\n \n pub use diagnostic::{\n-    AddSubdiagnostic, Diagnostic, DiagnosticArg, DiagnosticArgValue, DiagnosticId,\n+    AddSubdiagnostic, DecorateLint, Diagnostic, DiagnosticArg, DiagnosticArgValue, DiagnosticId,\n     DiagnosticStyledString, IntoDiagnosticArg, SubDiagnostic,\n };\n-pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee};\n+pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee, LintDiagnosticBuilder};\n use std::backtrace::Backtrace;\n \n /// A handler deals with errors and other compiler output."}, {"sha": "7c0f2c440d51d291a029dfbf6eae5dc840fe1a0c", "filename": "compiler/rustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2FCargo.toml?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -22,3 +22,4 @@ rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_parse_format = { path = \"../rustc_parse_format\" }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n+rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "363978926a75a350572a8baa72f1e9a8b5c000da", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -32,15 +32,16 @@ use rustc_ast_pretty::pprust::{self, expr_to_string};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{\n-    fluent, Applicability, Diagnostic, DiagnosticMessage, DiagnosticStyledString, MultiSpan,\n+    fluent, Applicability, Diagnostic, DiagnosticMessage, DiagnosticStyledString,\n+    LintDiagnosticBuilder, MultiSpan,\n };\n use rustc_feature::{deprecated_attributes, AttributeGate, BuiltinAttribute, GateIssue, Stability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet, CRATE_DEF_ID};\n use rustc_hir::{ForeignItemKind, GenericParamKind, HirId, PatKind, PredicateOrigin};\n use rustc_index::vec::Idx;\n-use rustc_middle::lint::{in_external_macro, LintDiagnosticBuilder};\n+use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::GenericArgKind;"}, {"sha": "83328093e9fa81aba558a49efd81a01a17959687", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -22,12 +22,13 @@ use rustc_ast::util::unicode::TEXT_FLOW_CONTROL_CHARS;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync;\n use rustc_errors::{add_elided_lifetime_in_path_suggestion, struct_span_err};\n-use rustc_errors::{Applicability, MultiSpan, SuggestionStyle};\n+use rustc_errors::{\n+    Applicability, DecorateLint, LintDiagnosticBuilder, MultiSpan, SuggestionStyle,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n-use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::middle::stability;\n use rustc_middle::ty::layout::{LayoutError, LayoutOfHelpers, TyAndLayout};\n@@ -871,6 +872,17 @@ pub trait LintContext: Sized {\n         decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a, ()>),\n     );\n \n+    /// Emit a lint at `span` from a lint struct (some type that implements `DecorateLint`,\n+    /// typically generated by `#[derive(LintDiagnostic)]`).\n+    fn emit_spanned_lint<S: Into<MultiSpan>>(\n+        &self,\n+        lint: &'static Lint,\n+        span: S,\n+        decorator: impl for<'a> DecorateLint<'a, ()>,\n+    ) {\n+        self.lookup(lint, Some(span), |diag| decorator.decorate_lint(diag));\n+    }\n+\n     fn struct_span_lint<S: Into<MultiSpan>>(\n         &self,\n         lint: &'static Lint,\n@@ -879,6 +891,13 @@ pub trait LintContext: Sized {\n     ) {\n         self.lookup(lint, Some(span), decorate);\n     }\n+\n+    /// Emit a lint from a lint struct (some type that implements `DecorateLint`, typically\n+    /// generated by `#[derive(LintDiagnostic)]`).\n+    fn emit_lint(&self, lint: &'static Lint, decorator: impl for<'a> DecorateLint<'a, ()>) {\n+        self.lookup(lint, None as Option<Span>, |diag| decorator.decorate_lint(diag));\n+    }\n+\n     /// Emit a lint at the appropriate level, with no associated span.\n     fn lint(\n         &self,"}, {"sha": "738f475983e9b692c2a803338393ae0e2dd40491", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -414,7 +414,7 @@ impl LateLintPass<'_> for Diagnostics {\n                 let Impl { of_trait: Some(of_trait), .. } = impl_ &&\n                 let Some(def_id) = of_trait.trait_def_id() &&\n                 let Some(name) = cx.tcx.get_diagnostic_name(def_id) &&\n-                matches!(name, sym::SessionDiagnostic | sym::AddSubdiagnostic)\n+                matches!(name, sym::SessionDiagnostic | sym::AddSubdiagnostic | sym::DecorateLint)\n             {\n                 found_impl = true;\n                 break;"}, {"sha": "00e96f20d1aaaec4ecd24c2349ecad72949e58da", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -3,13 +3,13 @@ use crate::late::unerased_lint_store;\n use rustc_ast as ast;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{struct_span_err, Applicability, Diagnostic, MultiSpan};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic, LintDiagnosticBuilder, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::{intravisit, HirId};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::lint::{\n-    struct_lint_level, LevelAndSource, LintDiagnosticBuilder, LintExpectation, LintLevelMap,\n-    LintLevelSets, LintLevelSource, LintSet, LintStackIndex, COMMAND_LINE,\n+    struct_lint_level, LevelAndSource, LintExpectation, LintLevelMap, LintLevelSets,\n+    LintLevelSource, LintSet, LintStackIndex, COMMAND_LINE,\n };\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{RegisteredTools, TyCtxt};"}, {"sha": "be4843c7ff1532a2a2036bdccf81d87e2aa17bd5", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -5,6 +5,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{fluent, Applicability, DiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::{is_range_literal, Expr, ExprKind, Node};\n+use rustc_macros::LintDiagnostic;\n use rustc_middle::ty::layout::{IntegerExt, LayoutOf, SizeSkeleton};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtKind, DefIdTree, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable};\n@@ -1553,13 +1554,20 @@ impl InvalidAtomicOrdering {\n         let Some(fail_ordering) = Self::match_ordering(cx, fail_order_arg) else { return };\n \n         if matches!(fail_ordering, sym::Release | sym::AcqRel) {\n-            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, fail_order_arg.span, |diag| {\n-                diag.build(fluent::lint::atomic_ordering_invalid)\n-                    .set_arg(\"method\", method)\n-                    .span_label(fail_order_arg.span, fluent::lint::label)\n-                    .help(fluent::lint::help)\n-                    .emit();\n-            });\n+            #[derive(LintDiagnostic)]\n+            #[lint(lint::atomic_ordering_invalid)]\n+            #[help]\n+            struct InvalidAtomicOrderingDiag {\n+                method: Symbol,\n+                #[label]\n+                fail_order_arg_span: Span,\n+            }\n+\n+            cx.emit_spanned_lint(\n+                INVALID_ATOMIC_ORDERING,\n+                fail_order_arg.span,\n+                InvalidAtomicOrderingDiag { method, fail_order_arg_span: fail_order_arg.span },\n+            );\n         }\n \n         let Some(success_ordering) = Self::match_ordering(cx, success_order_arg) else { return };"}, {"sha": "027f377b0acc72398b740029bf2285001d5e2be5", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 107, "deletions": 597, "changes": 704, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -1,140 +1,75 @@\n #![deny(unused_must_use)]\n \n-use crate::diagnostics::error::{\n-    invalid_nested_attr, span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err,\n-    SessionDiagnosticDeriveError,\n-};\n-use crate::diagnostics::utils::{\n-    report_error_if_not_applied_to_span, report_type_error, type_is_unit, type_matches_path,\n-    Applicability, FieldInfo, FieldInnerTy, HasFieldMap, SetOnce,\n-};\n-use proc_macro2::{Ident, TokenStream};\n-use quote::{format_ident, quote};\n-use std::collections::HashMap;\n-use std::str::FromStr;\n-use syn::{\n-    parse_quote, spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path, Type,\n-};\n-use synstructure::{BindingInfo, Structure};\n+use crate::diagnostics::diagnostic_builder::{DiagnosticDeriveBuilder, DiagnosticDeriveKind};\n+use crate::diagnostics::error::{span_err, DiagnosticDeriveError};\n+use crate::diagnostics::utils::{build_field_mapping, SetOnce};\n+use proc_macro2::TokenStream;\n+use quote::quote;\n+use syn::spanned::Spanned;\n+use synstructure::Structure;\n \n /// The central struct for constructing the `into_diagnostic` method from an annotated struct.\n pub(crate) struct SessionDiagnosticDerive<'a> {\n     structure: Structure<'a>,\n-    builder: SessionDiagnosticDeriveBuilder,\n+    sess: syn::Ident,\n+    builder: DiagnosticDeriveBuilder,\n }\n \n impl<'a> SessionDiagnosticDerive<'a> {\n     pub(crate) fn new(diag: syn::Ident, sess: syn::Ident, structure: Structure<'a>) -> Self {\n-        // Build the mapping of field names to fields. This allows attributes to peek values from\n-        // other fields.\n-        let mut fields_map = HashMap::new();\n-\n-        // Convenience bindings.\n-        let ast = structure.ast();\n-\n-        if let syn::Data::Struct(syn::DataStruct { fields, .. }) = &ast.data {\n-            for field in fields.iter() {\n-                if let Some(ident) = &field.ident {\n-                    fields_map.insert(ident.to_string(), quote! { &self.#ident });\n-                }\n-            }\n-        }\n-\n         Self {\n-            builder: SessionDiagnosticDeriveBuilder {\n+            builder: DiagnosticDeriveBuilder {\n                 diag,\n-                sess,\n-                fields: fields_map,\n+                fields: build_field_mapping(&structure),\n                 kind: None,\n                 code: None,\n                 slug: None,\n             },\n+            sess,\n             structure,\n         }\n     }\n \n     pub(crate) fn into_tokens(self) -> TokenStream {\n-        let SessionDiagnosticDerive { mut structure, mut builder } = self;\n+        let SessionDiagnosticDerive { mut structure, sess, mut builder } = self;\n \n         let ast = structure.ast();\n-        let attrs = &ast.attrs;\n-\n         let (implementation, param_ty) = {\n             if let syn::Data::Struct(..) = ast.data {\n-                let preamble = {\n-                    let preamble = attrs.iter().map(|attr| {\n-                        builder\n-                            .generate_structure_code(attr)\n-                            .unwrap_or_else(|v| v.to_compile_error())\n-                    });\n-\n-                    quote! {\n-                        #(#preamble)*;\n-                    }\n-                };\n-\n-                // Keep track of which fields are subdiagnostics or have no attributes.\n-                let mut subdiagnostics_or_empty = std::collections::HashSet::new();\n-\n-                // Generates calls to `span_label` and similar functions based on the attributes\n-                // on fields. Code for suggestions uses formatting machinery and the value of\n-                // other fields - because any given field can be referenced multiple times, it\n-                // should be accessed through a borrow. When passing fields to `add_subdiagnostic`\n-                // or `set_arg` (which happens below) for Fluent, we want to move the data, so that\n-                // has to happen in a separate pass over the fields.\n-                let attrs = structure\n-                    .clone()\n-                    .filter(|field_binding| {\n-                        let attrs = &field_binding.ast().attrs;\n-\n-                        (!attrs.is_empty()\n-                            && attrs.iter().all(|attr| {\n-                                \"subdiagnostic\"\n-                                    != attr.path.segments.last().unwrap().ident.to_string()\n-                            }))\n-                            || {\n-                                subdiagnostics_or_empty.insert(field_binding.binding.clone());\n-                                false\n-                            }\n-                    })\n-                    .each(|field_binding| builder.generate_field_attrs_code(field_binding));\n-\n-                structure.bind_with(|_| synstructure::BindStyle::Move);\n-                // When a field has attributes like `#[label]` or `#[note]` then it doesn't\n-                // need to be passed as an argument to the diagnostic. But when a field has no\n-                // attributes or a `#[subdiagnostic]` attribute then it must be passed as an\n-                // argument to the diagnostic so that it can be referred to by Fluent messages.\n-                let args = structure\n-                    .filter(|field_binding| {\n-                        subdiagnostics_or_empty.contains(&field_binding.binding)\n-                    })\n-                    .each(|field_binding| builder.generate_field_attrs_code(field_binding));\n+                let preamble = builder.preamble(&structure);\n+                let (attrs, args) = builder.body(&mut structure);\n \n                 let span = ast.span().unwrap();\n-                let (diag, sess) = (&builder.diag, &builder.sess);\n-                let init = match (builder.kind, builder.slug) {\n+                let diag = &builder.diag;\n+                let init = match (builder.kind.value(), builder.slug.value()) {\n                     (None, _) => {\n                         span_err(span, \"diagnostic kind not specified\")\n                             .help(\"use the `#[error(...)]` attribute to create an error\")\n                             .emit();\n-                        return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                        return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n                     }\n-                    (Some((kind, _)), None) => {\n+                    (Some(kind), None) => {\n                         span_err(span, \"diagnostic slug not specified\")\n                             .help(&format!(\n                                 \"specify the slug as the first argument to the attribute, such as \\\n                                  `#[{}(typeck::example_error)]`\",\n                                 kind.descr()\n                             ))\n                             .emit();\n-                        return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                        return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n                     }\n-                    (Some((SessionDiagnosticKind::Error, _)), Some((slug, _))) => {\n+                    (Some(DiagnosticDeriveKind::Lint), _) => {\n+                        span_err(span, \"only `#[error(..)]` and `#[warn(..)]` are supported\")\n+                            .help(\"use the `#[error(...)]` attribute to create a error\")\n+                            .emit();\n+                        return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                    }\n+                    (Some(DiagnosticDeriveKind::Error), Some(slug)) => {\n                         quote! {\n                             let mut #diag = #sess.struct_err(rustc_errors::fluent::#slug);\n                         }\n                     }\n-                    (Some((SessionDiagnosticKind::Warn, _)), Some((slug, _))) => {\n+                    (Some(DiagnosticDeriveKind::Warn), Some(slug)) => {\n                         quote! {\n                             let mut #diag = #sess.struct_warn(rustc_errors::fluent::#slug);\n                         }\n@@ -153,10 +88,12 @@ impl<'a> SessionDiagnosticDerive<'a> {\n                     #diag\n                 };\n                 let param_ty = match builder.kind {\n-                    Some((SessionDiagnosticKind::Error, _)) => {\n+                    Some((DiagnosticDeriveKind::Error, _)) => {\n                         quote! { rustc_errors::ErrorGuaranteed }\n                     }\n-                    Some((SessionDiagnosticKind::Warn, _)) => quote! { () },\n+                    Some((DiagnosticDeriveKind::Lint | DiagnosticDeriveKind::Warn, _)) => {\n+                        quote! { () }\n+                    }\n                     _ => unreachable!(),\n                 };\n \n@@ -168,13 +105,12 @@ impl<'a> SessionDiagnosticDerive<'a> {\n                 )\n                 .emit();\n \n-                let implementation = SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                let implementation = DiagnosticDeriveError::ErrorHandled.to_compile_error();\n                 let param_ty = quote! { rustc_errors::ErrorGuaranteed };\n                 (implementation, param_ty)\n             }\n         };\n \n-        let sess = &builder.sess;\n         structure.gen_impl(quote! {\n             gen impl<'__session_diagnostic_sess> rustc_session::SessionDiagnostic<'__session_diagnostic_sess, #param_ty>\n                     for @Self\n@@ -191,525 +127,99 @@ impl<'a> SessionDiagnosticDerive<'a> {\n     }\n }\n \n-/// What kind of session diagnostic is being derived - an error or a warning?\n-#[derive(Copy, Clone)]\n-enum SessionDiagnosticKind {\n-    /// `#[error(..)]`\n-    Error,\n-    /// `#[warn(..)]`\n-    Warn,\n+/// The central struct for constructing the `decorate_lint` method from an annotated struct.\n+pub(crate) struct LintDiagnosticDerive<'a> {\n+    structure: Structure<'a>,\n+    builder: DiagnosticDeriveBuilder,\n }\n \n-impl SessionDiagnosticKind {\n-    /// Returns human-readable string corresponding to the kind.\n-    fn descr(&self) -> &'static str {\n-        match self {\n-            SessionDiagnosticKind::Error => \"error\",\n-            SessionDiagnosticKind::Warn => \"warning\",\n+impl<'a> LintDiagnosticDerive<'a> {\n+    pub(crate) fn new(diag: syn::Ident, structure: Structure<'a>) -> Self {\n+        Self {\n+            builder: DiagnosticDeriveBuilder {\n+                diag,\n+                fields: build_field_mapping(&structure),\n+                kind: None,\n+                code: None,\n+                slug: None,\n+            },\n+            structure,\n         }\n     }\n-}\n-\n-/// Tracks persistent information required for building up the individual calls to diagnostic\n-/// methods for the final generated method. This is a separate struct to `SessionDiagnosticDerive`\n-/// only to be able to destructure and split `self.builder` and the `self.structure` up to avoid a\n-/// double mut borrow later on.\n-struct SessionDiagnosticDeriveBuilder {\n-    /// Name of the session parameter that's passed in to the `as_error` method.\n-    sess: syn::Ident,\n-    /// The identifier to use for the generated `DiagnosticBuilder` instance.\n-    diag: syn::Ident,\n-\n-    /// Store a map of field name to its corresponding field. This is built on construction of the\n-    /// derive builder.\n-    fields: HashMap<String, TokenStream>,\n-\n-    /// Kind of diagnostic requested via the struct attribute.\n-    kind: Option<(SessionDiagnosticKind, proc_macro::Span)>,\n-    /// Slug is a mandatory part of the struct attribute as corresponds to the Fluent message that\n-    /// has the actual diagnostic message.\n-    slug: Option<(Path, proc_macro::Span)>,\n-    /// Error codes are a optional part of the struct attribute - this is only set to detect\n-    /// multiple specifications.\n-    code: Option<(String, proc_macro::Span)>,\n-}\n-\n-impl HasFieldMap for SessionDiagnosticDeriveBuilder {\n-    fn get_field_binding(&self, field: &String) -> Option<&TokenStream> {\n-        self.fields.get(field)\n-    }\n-}\n-\n-impl SessionDiagnosticDeriveBuilder {\n-    /// Establishes state in the `SessionDiagnosticDeriveBuilder` resulting from the struct\n-    /// attributes like `#[error(..)`, such as the diagnostic kind and slug. Generates\n-    /// diagnostic builder calls for setting error code and creating note/help messages.\n-    fn generate_structure_code(\n-        &mut self,\n-        attr: &Attribute,\n-    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n-        let diag = &self.diag;\n-        let span = attr.span().unwrap();\n-\n-        let name = attr.path.segments.last().unwrap().ident.to_string();\n-        let name = name.as_str();\n-        let meta = attr.parse_meta()?;\n-\n-        let is_help_or_note = matches!(name, \"help\" | \"note\");\n-\n-        let nested = match meta {\n-            // Most attributes are lists, like `#[error(..)]`/`#[warning(..)]` for most cases or\n-            // `#[help(..)]`/`#[note(..)]` when the user is specifying a alternative slug.\n-            Meta::List(MetaList { ref nested, .. }) => nested,\n-            // Subdiagnostics without spans can be applied to the type too, and these are just\n-            // paths: `#[help]` and `#[note]`\n-            Meta::Path(_) if is_help_or_note => {\n-                let fn_name = proc_macro2::Ident::new(name, attr.span());\n-                return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::_subdiag::#fn_name); });\n-            }\n-            _ => throw_invalid_attr!(attr, &meta),\n-        };\n-\n-        // Check the kind before doing any further processing so that there aren't misleading\n-        // \"no kind specified\" errors if there are failures later.\n-        match name {\n-            \"error\" => self.kind.set_once((SessionDiagnosticKind::Error, span)),\n-            \"warning\" => self.kind.set_once((SessionDiagnosticKind::Warn, span)),\n-            \"help\" | \"note\" => (),\n-            _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\"only `error`, `warning`, `help` and `note` are valid attributes\")\n-            }),\n-        }\n \n-        // First nested element should always be the path, e.g. `#[error(typeck::invalid)]` or\n-        // `#[help(typeck::another_help)]`.\n-        let mut nested_iter = nested.into_iter();\n-        if let Some(nested_attr) = nested_iter.next() {\n-            // Report an error if there are any other list items after the path.\n-            if is_help_or_note && nested_iter.next().is_some() {\n-                throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                    diag.help(\"`help` and `note` struct attributes can only have one argument\")\n-                });\n-            }\n-\n-            match nested_attr {\n-                NestedMeta::Meta(Meta::Path(path)) if is_help_or_note => {\n-                    let fn_name = proc_macro2::Ident::new(name, attr.span());\n-                    return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::#path); });\n-                }\n-                NestedMeta::Meta(Meta::Path(path)) => {\n-                    self.slug.set_once((path.clone(), span));\n-                }\n-                NestedMeta::Meta(meta @ Meta::NameValue(_))\n-                    if !is_help_or_note\n-                        && meta.path().segments.last().unwrap().ident.to_string() == \"code\" =>\n-                {\n-                    // don't error for valid follow-up attributes\n-                }\n-                nested_attr => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                    diag.help(\"first argument of the attribute should be the diagnostic slug\")\n-                }),\n-            };\n-        }\n+    pub(crate) fn into_tokens(self) -> TokenStream {\n+        let LintDiagnosticDerive { mut structure, mut builder } = self;\n \n-        // Remaining attributes are optional, only `code = \"..\"` at the moment.\n-        let mut tokens = Vec::new();\n-        for nested_attr in nested_iter {\n-            let meta = match nested_attr {\n-                syn::NestedMeta::Meta(meta) => meta,\n-                _ => throw_invalid_nested_attr!(attr, &nested_attr),\n-            };\n+        let ast = structure.ast();\n+        let implementation = {\n+            if let syn::Data::Struct(..) = ast.data {\n+                let preamble = builder.preamble(&structure);\n+                let (attrs, args) = builder.body(&mut structure);\n \n-            let path = meta.path();\n-            let nested_name = path.segments.last().unwrap().ident.to_string();\n-            // Struct attributes are only allowed to be applied once, and the diagnostic\n-            // changes will be set in the initialisation code.\n-            if let Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) = &meta {\n-                let span = s.span().unwrap();\n-                match nested_name.as_str() {\n-                    \"code\" => {\n-                        self.code.set_once((s.value(), span));\n-                        let code = &self.code.as_ref().map(|(v, _)| v);\n-                        tokens.push(quote! {\n-                            #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n-                        });\n+                let diag = &builder.diag;\n+                let span = ast.span().unwrap();\n+                let init = match (builder.kind.value(), builder.slug.value()) {\n+                    (None, _) => {\n+                        span_err(span, \"diagnostic kind not specified\")\n+                            .help(\"use the `#[error(...)]` attribute to create an error\")\n+                            .emit();\n+                        return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n                     }\n-                    _ => invalid_nested_attr(attr, &nested_attr)\n-                        .help(\"only `code` is a valid nested attributes following the slug\")\n-                        .emit(),\n-                }\n-            } else {\n-                invalid_nested_attr(attr, &nested_attr).emit()\n-            }\n-        }\n-\n-        Ok(tokens.drain(..).collect())\n-    }\n-\n-    fn generate_field_attrs_code(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {\n-        let field = binding_info.ast();\n-        let field_binding = &binding_info.binding;\n-\n-        let inner_ty = FieldInnerTy::from_type(&field.ty);\n-\n-        // When generating `set_arg` or `add_subdiagnostic` calls, move data rather than\n-        // borrow it to avoid requiring clones - this must therefore be the last use of\n-        // each field (for example, any formatting machinery that might refer to a field\n-        // should be generated already).\n-        if field.attrs.is_empty() {\n-            let diag = &self.diag;\n-            let ident = field.ident.as_ref().unwrap();\n-            quote! {\n-                #diag.set_arg(\n-                    stringify!(#ident),\n-                    #field_binding\n-                );\n-            }\n-        } else {\n-            field\n-                .attrs\n-                .iter()\n-                .map(move |attr| {\n-                    let name = attr.path.segments.last().unwrap().ident.to_string();\n-                    let (binding, needs_destructure) = match (name.as_str(), &inner_ty) {\n-                        // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n-                        (\"primary_span\", FieldInnerTy::Vec(_)) => {\n-                            (quote! { #field_binding.clone() }, false)\n+                    (Some(kind), None) => {\n+                        span_err(span, \"diagnostic slug not specified\")\n+                            .help(&format!(\n+                                \"specify the slug as the first argument to the attribute, such as \\\n+                                 `#[{}(typeck::example_error)]`\",\n+                                kind.descr()\n+                            ))\n+                            .emit();\n+                        return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                    }\n+                    (Some(DiagnosticDeriveKind::Error | DiagnosticDeriveKind::Warn), _) => {\n+                        span_err(span, \"only `#[lint(..)]` is supported\")\n+                            .help(\"use the `#[lint(...)]` attribute to create a lint\")\n+                            .emit();\n+                        return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                    }\n+                    (Some(DiagnosticDeriveKind::Lint), Some(slug)) => {\n+                        quote! {\n+                            let mut #diag = #diag.build(rustc_errors::fluent::#slug);\n                         }\n-                        // `subdiagnostics` are not derefed because they are bound by value.\n-                        (\"subdiagnostic\", _) => (quote! { #field_binding }, true),\n-                        _ => (quote! { *#field_binding }, true),\n-                    };\n-\n-                    let generated_code = self\n-                        .generate_inner_field_code(\n-                            attr,\n-                            FieldInfo {\n-                                binding: binding_info,\n-                                ty: inner_ty.inner_type().unwrap_or(&field.ty),\n-                                span: &field.span(),\n-                            },\n-                            binding,\n-                        )\n-                        .unwrap_or_else(|v| v.to_compile_error());\n-\n-                    if needs_destructure {\n-                        inner_ty.with(field_binding, generated_code)\n-                    } else {\n-                        generated_code\n                     }\n-                })\n-                .collect()\n-        }\n-    }\n-\n-    fn generate_inner_field_code(\n-        &mut self,\n-        attr: &Attribute,\n-        info: FieldInfo<'_>,\n-        binding: TokenStream,\n-    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n-        let meta = attr.parse_meta()?;\n-        match meta {\n-            Meta::Path(_) => self.generate_inner_field_code_path(attr, info, binding),\n-            Meta::List(MetaList { .. }) => self.generate_inner_field_code_list(attr, info, binding),\n-            _ => throw_invalid_attr!(attr, &meta),\n-        }\n-    }\n-\n-    fn generate_inner_field_code_path(\n-        &mut self,\n-        attr: &Attribute,\n-        info: FieldInfo<'_>,\n-        binding: TokenStream,\n-    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n-        assert!(matches!(attr.parse_meta()?, Meta::Path(_)));\n-        let diag = &self.diag;\n-\n-        let meta = attr.parse_meta()?;\n-\n-        let ident = &attr.path.segments.last().unwrap().ident;\n-        let name = ident.to_string();\n-        let name = name.as_str();\n-        match name {\n-            \"skip_arg\" => {\n-                // Don't need to do anything - by virtue of the attribute existing, the\n-                // `set_arg` call will not be generated.\n-                Ok(quote! {})\n-            }\n-            \"primary_span\" => {\n-                report_error_if_not_applied_to_span(attr, &info)?;\n-                Ok(quote! {\n-                    #diag.set_span(#binding);\n-                })\n-            }\n-            \"label\" => {\n-                report_error_if_not_applied_to_span(attr, &info)?;\n-                Ok(self.add_spanned_subdiagnostic(binding, ident, parse_quote! { _subdiag::label }))\n-            }\n-            \"note\" | \"help\" => {\n-                let path = match name {\n-                    \"note\" => parse_quote! { _subdiag::note },\n-                    \"help\" => parse_quote! { _subdiag::help },\n-                    _ => unreachable!(),\n                 };\n-                if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n-                    Ok(self.add_spanned_subdiagnostic(binding, ident, path))\n-                } else if type_is_unit(&info.ty) {\n-                    Ok(self.add_subdiagnostic(ident, path))\n-                } else {\n-                    report_type_error(attr, \"`Span` or `()`\")?;\n-                }\n-            }\n-            \"subdiagnostic\" => Ok(quote! { #diag.subdiagnostic(#binding); }),\n-            _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\n-                    \"only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` \\\n-                     are valid field attributes\",\n-                )\n-            }),\n-        }\n-    }\n-\n-    fn generate_inner_field_code_list(\n-        &mut self,\n-        attr: &Attribute,\n-        info: FieldInfo<'_>,\n-        binding: TokenStream,\n-    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n-        let meta = attr.parse_meta()?;\n-        let Meta::List(MetaList { ref path, ref nested, .. }) = meta  else { unreachable!() };\n-\n-        let ident = &attr.path.segments.last().unwrap().ident;\n-        let name = path.segments.last().unwrap().ident.to_string();\n-        let name = name.as_ref();\n-        match name {\n-            \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\" | \"suggestion_verbose\" => {\n-                return self.generate_inner_field_code_suggestion(attr, info);\n-            }\n-            \"label\" | \"help\" | \"note\" => (),\n-            _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\n-                    \"only `label`, `note`, `help` or `suggestion{,_short,_hidden,_verbose}` are \\\n-                     valid field attributes\",\n-                )\n-            }),\n-        }\n \n-        // For `#[label(..)]`, `#[note(..)]` and `#[help(..)]`, the first nested element must be a\n-        // path, e.g. `#[label(typeck::label)]`.\n-        let mut nested_iter = nested.into_iter();\n-        let msg = match nested_iter.next() {\n-            Some(NestedMeta::Meta(Meta::Path(path))) => path.clone(),\n-            Some(nested_attr) => throw_invalid_nested_attr!(attr, &nested_attr),\n-            None => throw_invalid_attr!(attr, &meta),\n-        };\n-\n-        // None of these attributes should have anything following the slug.\n-        if nested_iter.next().is_some() {\n-            throw_invalid_attr!(attr, &meta);\n-        }\n-\n-        match name {\n-            \"label\" => {\n-                report_error_if_not_applied_to_span(attr, &info)?;\n-                Ok(self.add_spanned_subdiagnostic(binding, ident, msg))\n-            }\n-            \"note\" | \"help\" if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) => {\n-                Ok(self.add_spanned_subdiagnostic(binding, ident, msg))\n-            }\n-            \"note\" | \"help\" if type_is_unit(&info.ty) => Ok(self.add_subdiagnostic(ident, msg)),\n-            \"note\" | \"help\" => {\n-                report_type_error(attr, \"`Span` or `()`\")?;\n-            }\n-            _ => unreachable!(),\n-        }\n-    }\n-\n-    fn generate_inner_field_code_suggestion(\n-        &mut self,\n-        attr: &Attribute,\n-        info: FieldInfo<'_>,\n-    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n-        let diag = &self.diag;\n-\n-        let mut meta = attr.parse_meta()?;\n-        let Meta::List(MetaList { ref path, ref mut nested, .. }) = meta  else { unreachable!() };\n-\n-        let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n-\n-        let mut msg = None;\n-        let mut code = None;\n-\n-        let mut nested_iter = nested.into_iter().peekable();\n-        if let Some(nested_attr) = nested_iter.peek() {\n-            if let NestedMeta::Meta(Meta::Path(path)) = nested_attr {\n-                msg = Some(path.clone());\n-            }\n-        };\n-        // Move the iterator forward if a path was found (don't otherwise so that\n-        // code/applicability can be found or an error emitted).\n-        if msg.is_some() {\n-            let _ = nested_iter.next();\n-        }\n-\n-        for nested_attr in nested_iter {\n-            let meta = match nested_attr {\n-                syn::NestedMeta::Meta(ref meta) => meta,\n-                syn::NestedMeta::Lit(_) => throw_invalid_nested_attr!(attr, &nested_attr),\n-            };\n-\n-            let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-            let nested_name = nested_name.as_str();\n-            match meta {\n-                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                    let span = meta.span().unwrap();\n-                    match nested_name {\n-                        \"code\" => {\n-                            let formatted_str = self.build_format(&s.value(), s.span());\n-                            code = Some(formatted_str);\n-                        }\n-                        \"applicability\" => {\n-                            applicability = match applicability {\n-                                Some(v) => {\n-                                    span_err(\n-                                        span,\n-                                        \"applicability cannot be set in both the field and \\\n-                                         attribute\",\n-                                    )\n-                                    .emit();\n-                                    Some(v)\n-                                }\n-                                None => match Applicability::from_str(&s.value()) {\n-                                    Ok(v) => Some(quote! { #v }),\n-                                    Err(()) => {\n-                                        span_err(span, \"invalid applicability\").emit();\n-                                        None\n-                                    }\n-                                },\n-                            }\n-                        }\n-                        _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                            diag.help(\n-                                \"only `message`, `code` and `applicability` are valid field \\\n-                                 attributes\",\n-                            )\n-                        }),\n+                let implementation = quote! {\n+                    #init\n+                    #preamble\n+                    match self {\n+                        #attrs\n                     }\n-                }\n-                _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                    if matches!(meta, Meta::Path(_)) {\n-                        diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n-                    } else {\n-                        diag\n+                    match self {\n+                        #args\n                     }\n-                }),\n-            }\n-        }\n-\n-        let applicability =\n-            applicability.unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n-\n-        let name = path.segments.last().unwrap().ident.to_string();\n-        let method = format_ident!(\"span_{}\", name);\n-\n-        let msg = msg.unwrap_or_else(|| parse_quote! { _subdiag::suggestion });\n-        let msg = quote! { rustc_errors::fluent::#msg };\n-        let code = code.unwrap_or_else(|| quote! { String::new() });\n-\n-        Ok(quote! { #diag.#method(#span_field, #msg, #code, #applicability); })\n-    }\n-\n-    /// Adds a spanned subdiagnostic by generating a `diag.span_$kind` call with the current slug\n-    /// and `fluent_attr_identifier`.\n-    fn add_spanned_subdiagnostic(\n-        &self,\n-        field_binding: TokenStream,\n-        kind: &Ident,\n-        fluent_attr_identifier: Path,\n-    ) -> TokenStream {\n-        let diag = &self.diag;\n-        let fn_name = format_ident!(\"span_{}\", kind);\n-        quote! {\n-            #diag.#fn_name(\n-                #field_binding,\n-                rustc_errors::fluent::#fluent_attr_identifier\n-            );\n-        }\n-    }\n+                    #diag.emit();\n+                };\n \n-    /// Adds a subdiagnostic by generating a `diag.span_$kind` call with the current slug\n-    /// and `fluent_attr_identifier`.\n-    fn add_subdiagnostic(&self, kind: &Ident, fluent_attr_identifier: Path) -> TokenStream {\n-        let diag = &self.diag;\n-        quote! {\n-            #diag.#kind(rustc_errors::fluent::#fluent_attr_identifier);\n-        }\n-    }\n+                implementation\n+            } else {\n+                span_err(\n+                    ast.span().unwrap(),\n+                    \"`#[derive(LintDiagnostic)]` can only be used on structs\",\n+                )\n+                .emit();\n \n-    fn span_and_applicability_of_ty(\n-        &self,\n-        info: FieldInfo<'_>,\n-    ) -> Result<(TokenStream, Option<TokenStream>), SessionDiagnosticDeriveError> {\n-        match &info.ty {\n-            // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n-            ty @ Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n-                let binding = &info.binding.binding;\n-                Ok((quote!(*#binding), None))\n+                DiagnosticDeriveError::ErrorHandled.to_compile_error()\n             }\n-            // If `ty` is `(Span, Applicability)` then return tokens accessing those.\n-            Type::Tuple(tup) => {\n-                let mut span_idx = None;\n-                let mut applicability_idx = None;\n-\n-                for (idx, elem) in tup.elems.iter().enumerate() {\n-                    if type_matches_path(elem, &[\"rustc_span\", \"Span\"]) {\n-                        if span_idx.is_none() {\n-                            span_idx = Some(syn::Index::from(idx));\n-                        } else {\n-                            throw_span_err!(\n-                                info.span.unwrap(),\n-                                \"type of field annotated with `#[suggestion(...)]` contains more \\\n-                                 than one `Span`\"\n-                            );\n-                        }\n-                    } else if type_matches_path(elem, &[\"rustc_errors\", \"Applicability\"]) {\n-                        if applicability_idx.is_none() {\n-                            applicability_idx = Some(syn::Index::from(idx));\n-                        } else {\n-                            throw_span_err!(\n-                                info.span.unwrap(),\n-                                \"type of field annotated with `#[suggestion(...)]` contains more \\\n-                                 than one Applicability\"\n-                            );\n-                        }\n-                    }\n-                }\n-\n-                if let Some(span_idx) = span_idx {\n-                    let binding = &info.binding.binding;\n-                    let span = quote!(#binding.#span_idx);\n-                    let applicability = applicability_idx\n-                        .map(|applicability_idx| quote!(#binding.#applicability_idx))\n-                        .unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n+        };\n \n-                    return Ok((span, Some(applicability)));\n+        let diag = &builder.diag;\n+        structure.gen_impl(quote! {\n+            gen impl<'__a> rustc_errors::DecorateLint<'__a, ()> for @Self {\n+                fn decorate_lint(self, #diag: rustc_errors::LintDiagnosticBuilder<'__a, ()>) {\n+                    use rustc_errors::IntoDiagnosticArg;\n+                    #implementation\n                 }\n-\n-                throw_span_err!(info.span.unwrap(), \"wrong types for suggestion\", |diag| {\n-                    diag.help(\n-                        \"`#[suggestion(...)]` on a tuple field must be applied to fields of type \\\n-                         `(Span, Applicability)`\",\n-                    )\n-                });\n             }\n-            // If `ty` isn't a `Span` or `(Span, Applicability)` then emit an error.\n-            _ => throw_span_err!(info.span.unwrap(), \"wrong field type for suggestion\", |diag| {\n-                diag.help(\n-                    \"`#[suggestion(...)]` should be applied to fields of type `Span` or \\\n-                     `(Span, Applicability)`\",\n-                )\n-            }),\n-        }\n+        })\n     }\n }"}, {"sha": "74ce1ab08c2648a6a66b1c0be345f15f9bbe4ed9", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "added", "additions": 590, "deletions": 0, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -0,0 +1,590 @@\n+#![deny(unused_must_use)]\n+\n+use crate::diagnostics::error::{\n+    invalid_nested_attr, span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err,\n+    DiagnosticDeriveError,\n+};\n+use crate::diagnostics::utils::{\n+    report_error_if_not_applied_to_span, report_type_error, type_is_unit, type_matches_path,\n+    Applicability, FieldInfo, FieldInnerTy, HasFieldMap, SetOnce,\n+};\n+use proc_macro2::{Ident, TokenStream};\n+use quote::{format_ident, quote};\n+use std::collections::HashMap;\n+use std::str::FromStr;\n+use syn::{\n+    parse_quote, spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path, Type,\n+};\n+use synstructure::{BindingInfo, Structure};\n+\n+/// What kind of diagnostic is being derived - an error, a warning or a lint?\n+#[derive(Copy, Clone)]\n+pub(crate) enum DiagnosticDeriveKind {\n+    /// `#[error(..)]`\n+    Error,\n+    /// `#[warn(..)]`\n+    Warn,\n+    /// `#[lint(..)]`\n+    Lint,\n+}\n+\n+impl DiagnosticDeriveKind {\n+    /// Returns human-readable string corresponding to the kind.\n+    pub fn descr(&self) -> &'static str {\n+        match self {\n+            DiagnosticDeriveKind::Error => \"error\",\n+            DiagnosticDeriveKind::Warn => \"warning\",\n+            DiagnosticDeriveKind::Lint => \"lint\",\n+        }\n+    }\n+}\n+\n+/// Tracks persistent information required for building up individual calls to diagnostic methods\n+/// for generated diagnostic derives - both `SessionDiagnostic` for errors/warnings and\n+/// `LintDiagnostic` for lints.\n+pub(crate) struct DiagnosticDeriveBuilder {\n+    /// The identifier to use for the generated `DiagnosticBuilder` instance.\n+    pub diag: syn::Ident,\n+\n+    /// Store a map of field name to its corresponding field. This is built on construction of the\n+    /// derive builder.\n+    pub fields: HashMap<String, TokenStream>,\n+\n+    /// Kind of diagnostic requested via the struct attribute.\n+    pub kind: Option<(DiagnosticDeriveKind, proc_macro::Span)>,\n+    /// Slug is a mandatory part of the struct attribute as corresponds to the Fluent message that\n+    /// has the actual diagnostic message.\n+    pub slug: Option<(Path, proc_macro::Span)>,\n+    /// Error codes are a optional part of the struct attribute - this is only set to detect\n+    /// multiple specifications.\n+    pub code: Option<(String, proc_macro::Span)>,\n+}\n+\n+impl HasFieldMap for DiagnosticDeriveBuilder {\n+    fn get_field_binding(&self, field: &String) -> Option<&TokenStream> {\n+        self.fields.get(field)\n+    }\n+}\n+\n+impl DiagnosticDeriveBuilder {\n+    pub fn preamble<'s>(&mut self, structure: &Structure<'s>) -> TokenStream {\n+        let ast = structure.ast();\n+        let attrs = &ast.attrs;\n+        let preamble = attrs.iter().map(|attr| {\n+            self.generate_structure_code_for_attr(attr).unwrap_or_else(|v| v.to_compile_error())\n+        });\n+\n+        quote! {\n+            #(#preamble)*;\n+        }\n+    }\n+\n+    pub fn body<'s>(&mut self, structure: &mut Structure<'s>) -> (TokenStream, TokenStream) {\n+        // Keep track of which fields are subdiagnostics or have no attributes.\n+        let mut subdiagnostics_or_empty = std::collections::HashSet::new();\n+\n+        // Generates calls to `span_label` and similar functions based on the attributes\n+        // on fields. Code for suggestions uses formatting machinery and the value of\n+        // other fields - because any given field can be referenced multiple times, it\n+        // should be accessed through a borrow. When passing fields to `add_subdiagnostic`\n+        // or `set_arg` (which happens below) for Fluent, we want to move the data, so that\n+        // has to happen in a separate pass over the fields.\n+        let attrs = structure\n+            .clone()\n+            .filter(|field_binding| {\n+                let attrs = &field_binding.ast().attrs;\n+\n+                (!attrs.is_empty()\n+                    && attrs.iter().all(|attr| {\n+                        \"subdiagnostic\" != attr.path.segments.last().unwrap().ident.to_string()\n+                    }))\n+                    || {\n+                        subdiagnostics_or_empty.insert(field_binding.binding.clone());\n+                        false\n+                    }\n+            })\n+            .each(|field_binding| self.generate_field_attrs_code(field_binding));\n+\n+        structure.bind_with(|_| synstructure::BindStyle::Move);\n+        // When a field has attributes like `#[label]` or `#[note]` then it doesn't\n+        // need to be passed as an argument to the diagnostic. But when a field has no\n+        // attributes or a `#[subdiagnostic]` attribute then it must be passed as an\n+        // argument to the diagnostic so that it can be referred to by Fluent messages.\n+        let args = structure\n+            .filter(|field_binding| subdiagnostics_or_empty.contains(&field_binding.binding))\n+            .each(|field_binding| self.generate_field_attrs_code(field_binding));\n+\n+        (attrs, args)\n+    }\n+\n+    /// Establishes state in the `DiagnosticDeriveBuilder` resulting from the struct\n+    /// attributes like `#[error(..)`, such as the diagnostic kind and slug. Generates\n+    /// diagnostic builder calls for setting error code and creating note/help messages.\n+    fn generate_structure_code_for_attr(\n+        &mut self,\n+        attr: &Attribute,\n+    ) -> Result<TokenStream, DiagnosticDeriveError> {\n+        let diag = &self.diag;\n+        let span = attr.span().unwrap();\n+\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_str();\n+        let meta = attr.parse_meta()?;\n+\n+        let is_help_or_note = matches!(name, \"help\" | \"note\");\n+\n+        let nested = match meta {\n+            // Most attributes are lists, like `#[error(..)]`/`#[warning(..)]` for most cases or\n+            // `#[help(..)]`/`#[note(..)]` when the user is specifying a alternative slug.\n+            Meta::List(MetaList { ref nested, .. }) => nested,\n+            // Subdiagnostics without spans can be applied to the type too, and these are just\n+            // paths: `#[help]` and `#[note]`\n+            Meta::Path(_) if is_help_or_note => {\n+                let fn_name = proc_macro2::Ident::new(name, attr.span());\n+                return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::_subdiag::#fn_name); });\n+            }\n+            _ => throw_invalid_attr!(attr, &meta),\n+        };\n+\n+        // Check the kind before doing any further processing so that there aren't misleading\n+        // \"no kind specified\" errors if there are failures later.\n+        match name {\n+            \"error\" => self.kind.set_once((DiagnosticDeriveKind::Error, span)),\n+            \"warning\" => self.kind.set_once((DiagnosticDeriveKind::Warn, span)),\n+            \"lint\" => self.kind.set_once((DiagnosticDeriveKind::Lint, span)),\n+            \"help\" | \"note\" => (),\n+            _ => throw_invalid_attr!(attr, &meta, |diag| {\n+                diag.help(\"only `error`, `warning`, `help` and `note` are valid attributes\")\n+            }),\n+        }\n+\n+        // First nested element should always be the path, e.g. `#[error(typeck::invalid)]` or\n+        // `#[help(typeck::another_help)]`.\n+        let mut nested_iter = nested.into_iter();\n+        if let Some(nested_attr) = nested_iter.next() {\n+            // Report an error if there are any other list items after the path.\n+            if is_help_or_note && nested_iter.next().is_some() {\n+                throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                    diag.help(\"`help` and `note` struct attributes can only have one argument\")\n+                });\n+            }\n+\n+            match nested_attr {\n+                NestedMeta::Meta(Meta::Path(path)) if is_help_or_note => {\n+                    let fn_name = proc_macro2::Ident::new(name, attr.span());\n+                    return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::#path); });\n+                }\n+                NestedMeta::Meta(Meta::Path(path)) => {\n+                    self.slug.set_once((path.clone(), span));\n+                }\n+                NestedMeta::Meta(meta @ Meta::NameValue(_))\n+                    if !is_help_or_note\n+                        && meta.path().segments.last().unwrap().ident.to_string() == \"code\" =>\n+                {\n+                    // don't error for valid follow-up attributes\n+                }\n+                nested_attr => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                    diag.help(\"first argument of the attribute should be the diagnostic slug\")\n+                }),\n+            };\n+        }\n+\n+        // Remaining attributes are optional, only `code = \"..\"` at the moment.\n+        let mut tokens = Vec::new();\n+        for nested_attr in nested_iter {\n+            let meta = match nested_attr {\n+                syn::NestedMeta::Meta(meta) => meta,\n+                _ => throw_invalid_nested_attr!(attr, &nested_attr),\n+            };\n+\n+            let path = meta.path();\n+            let nested_name = path.segments.last().unwrap().ident.to_string();\n+            // Struct attributes are only allowed to be applied once, and the diagnostic\n+            // changes will be set in the initialisation code.\n+            if let Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) = &meta {\n+                let span = s.span().unwrap();\n+                match nested_name.as_str() {\n+                    \"code\" => {\n+                        self.code.set_once((s.value(), span));\n+                        let code = &self.code.as_ref().map(|(v, _)| v);\n+                        tokens.push(quote! {\n+                            #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n+                        });\n+                    }\n+                    _ => invalid_nested_attr(attr, &nested_attr)\n+                        .help(\"only `code` is a valid nested attributes following the slug\")\n+                        .emit(),\n+                }\n+            } else {\n+                invalid_nested_attr(attr, &nested_attr).emit()\n+            }\n+        }\n+\n+        Ok(tokens.drain(..).collect())\n+    }\n+\n+    fn generate_field_attrs_code(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {\n+        let field = binding_info.ast();\n+        let field_binding = &binding_info.binding;\n+\n+        let inner_ty = FieldInnerTy::from_type(&field.ty);\n+\n+        // When generating `set_arg` or `add_subdiagnostic` calls, move data rather than\n+        // borrow it to avoid requiring clones - this must therefore be the last use of\n+        // each field (for example, any formatting machinery that might refer to a field\n+        // should be generated already).\n+        if field.attrs.is_empty() {\n+            let diag = &self.diag;\n+            let ident = field.ident.as_ref().unwrap();\n+            quote! {\n+                #diag.set_arg(\n+                    stringify!(#ident),\n+                    #field_binding\n+                );\n+            }\n+        } else {\n+            field\n+                .attrs\n+                .iter()\n+                .map(move |attr| {\n+                    let name = attr.path.segments.last().unwrap().ident.to_string();\n+                    let (binding, needs_destructure) = match (name.as_str(), &inner_ty) {\n+                        // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n+                        (\"primary_span\", FieldInnerTy::Vec(_)) => {\n+                            (quote! { #field_binding.clone() }, false)\n+                        }\n+                        // `subdiagnostics` are not derefed because they are bound by value.\n+                        (\"subdiagnostic\", _) => (quote! { #field_binding }, true),\n+                        _ => (quote! { *#field_binding }, true),\n+                    };\n+\n+                    let generated_code = self\n+                        .generate_inner_field_code(\n+                            attr,\n+                            FieldInfo {\n+                                binding: binding_info,\n+                                ty: inner_ty.inner_type().unwrap_or(&field.ty),\n+                                span: &field.span(),\n+                            },\n+                            binding,\n+                        )\n+                        .unwrap_or_else(|v| v.to_compile_error());\n+\n+                    if needs_destructure {\n+                        inner_ty.with(field_binding, generated_code)\n+                    } else {\n+                        generated_code\n+                    }\n+                })\n+                .collect()\n+        }\n+    }\n+\n+    fn generate_inner_field_code(\n+        &mut self,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+        binding: TokenStream,\n+    ) -> Result<TokenStream, DiagnosticDeriveError> {\n+        let meta = attr.parse_meta()?;\n+        match meta {\n+            Meta::Path(_) => self.generate_inner_field_code_path(attr, info, binding),\n+            Meta::List(MetaList { .. }) => self.generate_inner_field_code_list(attr, info, binding),\n+            _ => throw_invalid_attr!(attr, &meta),\n+        }\n+    }\n+\n+    fn generate_inner_field_code_path(\n+        &mut self,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+        binding: TokenStream,\n+    ) -> Result<TokenStream, DiagnosticDeriveError> {\n+        assert!(matches!(attr.parse_meta()?, Meta::Path(_)));\n+        let diag = &self.diag;\n+\n+        let meta = attr.parse_meta()?;\n+\n+        let ident = &attr.path.segments.last().unwrap().ident;\n+        let name = ident.to_string();\n+        let name = name.as_str();\n+        match name {\n+            \"skip_arg\" => {\n+                // Don't need to do anything - by virtue of the attribute existing, the\n+                // `set_arg` call will not be generated.\n+                Ok(quote! {})\n+            }\n+            \"primary_span\" => {\n+                report_error_if_not_applied_to_span(attr, &info)?;\n+                Ok(quote! {\n+                    #diag.set_span(#binding);\n+                })\n+            }\n+            \"label\" => {\n+                report_error_if_not_applied_to_span(attr, &info)?;\n+                Ok(self.add_spanned_subdiagnostic(binding, ident, parse_quote! { _subdiag::label }))\n+            }\n+            \"note\" | \"help\" => {\n+                let path = match name {\n+                    \"note\" => parse_quote! { _subdiag::note },\n+                    \"help\" => parse_quote! { _subdiag::help },\n+                    _ => unreachable!(),\n+                };\n+                if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n+                    Ok(self.add_spanned_subdiagnostic(binding, ident, path))\n+                } else if type_is_unit(&info.ty) {\n+                    Ok(self.add_subdiagnostic(ident, path))\n+                } else {\n+                    report_type_error(attr, \"`Span` or `()`\")?\n+                }\n+            }\n+            \"subdiagnostic\" => Ok(quote! { #diag.subdiagnostic(#binding); }),\n+            _ => throw_invalid_attr!(attr, &meta, |diag| {\n+                diag.help(\n+                    \"only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` \\\n+                     are valid field attributes\",\n+                )\n+            }),\n+        }\n+    }\n+\n+    fn generate_inner_field_code_list(\n+        &mut self,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+        binding: TokenStream,\n+    ) -> Result<TokenStream, DiagnosticDeriveError> {\n+        let meta = attr.parse_meta()?;\n+        let Meta::List(MetaList { ref path, ref nested, .. }) = meta  else { unreachable!() };\n+\n+        let ident = &attr.path.segments.last().unwrap().ident;\n+        let name = path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_ref();\n+        match name {\n+            \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\" | \"suggestion_verbose\" => {\n+                return self.generate_inner_field_code_suggestion(attr, info);\n+            }\n+            \"label\" | \"help\" | \"note\" => (),\n+            _ => throw_invalid_attr!(attr, &meta, |diag| {\n+                diag.help(\n+                    \"only `label`, `note`, `help` or `suggestion{,_short,_hidden,_verbose}` are \\\n+                     valid field attributes\",\n+                )\n+            }),\n+        }\n+\n+        // For `#[label(..)]`, `#[note(..)]` and `#[help(..)]`, the first nested element must be a\n+        // path, e.g. `#[label(typeck::label)]`.\n+        let mut nested_iter = nested.into_iter();\n+        let msg = match nested_iter.next() {\n+            Some(NestedMeta::Meta(Meta::Path(path))) => path.clone(),\n+            Some(nested_attr) => throw_invalid_nested_attr!(attr, &nested_attr),\n+            None => throw_invalid_attr!(attr, &meta),\n+        };\n+\n+        // None of these attributes should have anything following the slug.\n+        if nested_iter.next().is_some() {\n+            throw_invalid_attr!(attr, &meta);\n+        }\n+\n+        match name {\n+            \"label\" => {\n+                report_error_if_not_applied_to_span(attr, &info)?;\n+                Ok(self.add_spanned_subdiagnostic(binding, ident, msg))\n+            }\n+            \"note\" | \"help\" if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) => {\n+                Ok(self.add_spanned_subdiagnostic(binding, ident, msg))\n+            }\n+            \"note\" | \"help\" if type_is_unit(&info.ty) => Ok(self.add_subdiagnostic(ident, msg)),\n+            \"note\" | \"help\" => report_type_error(attr, \"`Span` or `()`\")?,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    fn generate_inner_field_code_suggestion(\n+        &mut self,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<TokenStream, DiagnosticDeriveError> {\n+        let diag = &self.diag;\n+\n+        let mut meta = attr.parse_meta()?;\n+        let Meta::List(MetaList { ref path, ref mut nested, .. }) = meta  else { unreachable!() };\n+\n+        let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n+\n+        let mut msg = None;\n+        let mut code = None;\n+\n+        let mut nested_iter = nested.into_iter().peekable();\n+        if let Some(nested_attr) = nested_iter.peek() {\n+            if let NestedMeta::Meta(Meta::Path(path)) = nested_attr {\n+                msg = Some(path.clone());\n+            }\n+        };\n+        // Move the iterator forward if a path was found (don't otherwise so that\n+        // code/applicability can be found or an error emitted).\n+        if msg.is_some() {\n+            let _ = nested_iter.next();\n+        }\n+\n+        for nested_attr in nested_iter {\n+            let meta = match nested_attr {\n+                syn::NestedMeta::Meta(ref meta) => meta,\n+                syn::NestedMeta::Lit(_) => throw_invalid_nested_attr!(attr, &nested_attr),\n+            };\n+\n+            let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+            let nested_name = nested_name.as_str();\n+            match meta {\n+                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                    let span = meta.span().unwrap();\n+                    match nested_name {\n+                        \"code\" => {\n+                            let formatted_str = self.build_format(&s.value(), s.span());\n+                            code = Some(formatted_str);\n+                        }\n+                        \"applicability\" => {\n+                            applicability = match applicability {\n+                                Some(v) => {\n+                                    span_err(\n+                                        span,\n+                                        \"applicability cannot be set in both the field and \\\n+                                         attribute\",\n+                                    )\n+                                    .emit();\n+                                    Some(v)\n+                                }\n+                                None => match Applicability::from_str(&s.value()) {\n+                                    Ok(v) => Some(quote! { #v }),\n+                                    Err(()) => {\n+                                        span_err(span, \"invalid applicability\").emit();\n+                                        None\n+                                    }\n+                                },\n+                            }\n+                        }\n+                        _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                            diag.help(\n+                                \"only `message`, `code` and `applicability` are valid field \\\n+                                 attributes\",\n+                            )\n+                        }),\n+                    }\n+                }\n+                _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                    if matches!(meta, Meta::Path(_)) {\n+                        diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n+                    } else {\n+                        diag\n+                    }\n+                }),\n+            }\n+        }\n+\n+        let applicability =\n+            applicability.unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n+\n+        let name = path.segments.last().unwrap().ident.to_string();\n+        let method = format_ident!(\"span_{}\", name);\n+\n+        let msg = msg.unwrap_or_else(|| parse_quote! { _subdiag::suggestion });\n+        let msg = quote! { rustc_errors::fluent::#msg };\n+        let code = code.unwrap_or_else(|| quote! { String::new() });\n+\n+        Ok(quote! { #diag.#method(#span_field, #msg, #code, #applicability); })\n+    }\n+\n+    /// Adds a spanned subdiagnostic by generating a `diag.span_$kind` call with the current slug\n+    /// and `fluent_attr_identifier`.\n+    fn add_spanned_subdiagnostic(\n+        &self,\n+        field_binding: TokenStream,\n+        kind: &Ident,\n+        fluent_attr_identifier: Path,\n+    ) -> TokenStream {\n+        let diag = &self.diag;\n+        let fn_name = format_ident!(\"span_{}\", kind);\n+        quote! {\n+            #diag.#fn_name(\n+                #field_binding,\n+                rustc_errors::fluent::#fluent_attr_identifier\n+            );\n+        }\n+    }\n+\n+    /// Adds a subdiagnostic by generating a `diag.span_$kind` call with the current slug\n+    /// and `fluent_attr_identifier`.\n+    fn add_subdiagnostic(&self, kind: &Ident, fluent_attr_identifier: Path) -> TokenStream {\n+        let diag = &self.diag;\n+        quote! {\n+            #diag.#kind(rustc_errors::fluent::#fluent_attr_identifier);\n+        }\n+    }\n+\n+    fn span_and_applicability_of_ty(\n+        &self,\n+        info: FieldInfo<'_>,\n+    ) -> Result<(TokenStream, Option<TokenStream>), DiagnosticDeriveError> {\n+        match &info.ty {\n+            // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n+            ty @ Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n+                let binding = &info.binding.binding;\n+                Ok((quote!(*#binding), None))\n+            }\n+            // If `ty` is `(Span, Applicability)` then return tokens accessing those.\n+            Type::Tuple(tup) => {\n+                let mut span_idx = None;\n+                let mut applicability_idx = None;\n+\n+                for (idx, elem) in tup.elems.iter().enumerate() {\n+                    if type_matches_path(elem, &[\"rustc_span\", \"Span\"]) {\n+                        if span_idx.is_none() {\n+                            span_idx = Some(syn::Index::from(idx));\n+                        } else {\n+                            throw_span_err!(\n+                                info.span.unwrap(),\n+                                \"type of field annotated with `#[suggestion(...)]` contains more \\\n+                                 than one `Span`\"\n+                            );\n+                        }\n+                    } else if type_matches_path(elem, &[\"rustc_errors\", \"Applicability\"]) {\n+                        if applicability_idx.is_none() {\n+                            applicability_idx = Some(syn::Index::from(idx));\n+                        } else {\n+                            throw_span_err!(\n+                                info.span.unwrap(),\n+                                \"type of field annotated with `#[suggestion(...)]` contains more \\\n+                                 than one Applicability\"\n+                            );\n+                        }\n+                    }\n+                }\n+\n+                if let Some(span_idx) = span_idx {\n+                    let binding = &info.binding.binding;\n+                    let span = quote!(#binding.#span_idx);\n+                    let applicability = applicability_idx\n+                        .map(|applicability_idx| quote!(#binding.#applicability_idx))\n+                        .unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n+\n+                    return Ok((span, Some(applicability)));\n+                }\n+\n+                throw_span_err!(info.span.unwrap(), \"wrong types for suggestion\", |diag| {\n+                    diag.help(\n+                        \"`#[suggestion(...)]` on a tuple field must be applied to fields of type \\\n+                         `(Span, Applicability)`\",\n+                    )\n+                });\n+            }\n+            // If `ty` isn't a `Span` or `(Span, Applicability)` then emit an error.\n+            _ => throw_span_err!(info.span.unwrap(), \"wrong field type for suggestion\", |diag| {\n+                diag.help(\n+                    \"`#[suggestion(...)]` should be applied to fields of type `Span` or \\\n+                     `(Span, Applicability)`\",\n+                )\n+            }),\n+        }\n+    }\n+}"}, {"sha": "0b1ededa77510fe44f43472ea9d40ef71410d063", "filename": "compiler/rustc_macros/src/diagnostics/error.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -4,16 +4,16 @@ use quote::quote;\n use syn::{spanned::Spanned, Attribute, Error as SynError, Meta, NestedMeta};\n \n #[derive(Debug)]\n-pub(crate) enum SessionDiagnosticDeriveError {\n+pub(crate) enum DiagnosticDeriveError {\n     SynError(SynError),\n     ErrorHandled,\n }\n \n-impl SessionDiagnosticDeriveError {\n+impl DiagnosticDeriveError {\n     pub(crate) fn to_compile_error(self) -> TokenStream {\n         match self {\n-            SessionDiagnosticDeriveError::SynError(e) => e.to_compile_error(),\n-            SessionDiagnosticDeriveError::ErrorHandled => {\n+            DiagnosticDeriveError::SynError(e) => e.to_compile_error(),\n+            DiagnosticDeriveError::ErrorHandled => {\n                 // Return ! to avoid having to create a blank DiagnosticBuilder to return when an\n                 // error has already been emitted to the compiler.\n                 quote! {\n@@ -24,19 +24,19 @@ impl SessionDiagnosticDeriveError {\n     }\n }\n \n-impl From<SynError> for SessionDiagnosticDeriveError {\n+impl From<SynError> for DiagnosticDeriveError {\n     fn from(e: SynError) -> Self {\n-        SessionDiagnosticDeriveError::SynError(e)\n+        DiagnosticDeriveError::SynError(e)\n     }\n }\n \n /// Helper function for use with `throw_*` macros - constraints `$f` to an `impl FnOnce`.\n pub(crate) fn _throw_err(\n     diag: Diagnostic,\n     f: impl FnOnce(Diagnostic) -> Diagnostic,\n-) -> SessionDiagnosticDeriveError {\n+) -> DiagnosticDeriveError {\n     f(diag).emit();\n-    SessionDiagnosticDeriveError::ErrorHandled\n+    DiagnosticDeriveError::ErrorHandled\n }\n \n /// Helper function for printing `syn::Path` - doesn't handle arguments in paths and these are\n@@ -60,7 +60,7 @@ pub(crate) fn span_err(span: impl MultiSpan, msg: &str) -> Diagnostic {\n /// Emit a diagnostic on span `$span` with msg `$msg` (optionally performing additional decoration\n /// using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n ///\n-/// For methods that return a `Result<_, SessionDiagnosticDeriveError>`:\n+/// For methods that return a `Result<_, DiagnosticDeriveError>`:\n macro_rules! throw_span_err {\n     ($span:expr, $msg:expr) => {{ throw_span_err!($span, $msg, |diag| diag) }};\n     ($span:expr, $msg:expr, $f:expr) => {{\n@@ -87,7 +87,7 @@ pub(crate) fn invalid_attr(attr: &Attribute, meta: &Meta) -> Diagnostic {\n /// Emit a error diagnostic for an invalid attribute (optionally performing additional decoration\n /// using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n ///\n-/// For methods that return a `Result<_, SessionDiagnosticDeriveError>`:\n+/// For methods that return a `Result<_, DiagnosticDeriveError>`:\n macro_rules! throw_invalid_attr {\n     ($attr:expr, $meta:expr) => {{ throw_invalid_attr!($attr, $meta, |diag| diag) }};\n     ($attr:expr, $meta:expr, $f:expr) => {{\n@@ -129,7 +129,7 @@ pub(crate) fn invalid_nested_attr(attr: &Attribute, nested: &NestedMeta) -> Diag\n /// Emit a error diagnostic for an invalid nested attribute (optionally performing additional\n /// decoration using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n ///\n-/// For methods that return a `Result<_, SessionDiagnosticDeriveError>`:\n+/// For methods that return a `Result<_, DiagnosticDeriveError>`:\n macro_rules! throw_invalid_nested_attr {\n     ($attr:expr, $nested_attr:expr) => {{ throw_invalid_nested_attr!($attr, $nested_attr, |diag| diag) }};\n     ($attr:expr, $nested_attr:expr, $f:expr) => {{"}, {"sha": "3997900266641c79e133d054836490a55c2cadd8", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -1,10 +1,11 @@\n mod diagnostic;\n+mod diagnostic_builder;\n mod error;\n mod fluent;\n mod subdiagnostic;\n mod utils;\n \n-use diagnostic::SessionDiagnosticDerive;\n+use diagnostic::{LintDiagnosticDerive, SessionDiagnosticDerive};\n pub(crate) use fluent::fluent_messages;\n use proc_macro2::TokenStream;\n use quote::format_ident;\n@@ -56,13 +57,55 @@ use synstructure::Structure;\n /// ```\n ///\n /// See rustc dev guide for more examples on using the `#[derive(SessionDiagnostic)]`:\n-/// <https://rustc-dev-guide.rust-lang.org/diagnostics/sessiondiagnostic.html>\n+/// <https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-structs.html>\n pub fn session_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n-    // Names for the diagnostic we build and the session we build it from.\n-    let diag = format_ident!(\"diag\");\n-    let sess = format_ident!(\"sess\");\n+    SessionDiagnosticDerive::new(format_ident!(\"diag\"), format_ident!(\"sess\"), s).into_tokens()\n+}\n \n-    SessionDiagnosticDerive::new(diag, sess, s).into_tokens()\n+/// Implements `#[derive(LintDiagnostic)]`, which allows for lints to be specified as a struct,\n+/// independent from the actual lint emitting code.\n+///\n+/// ```ignore (rust)\n+/// #[derive(LintDiagnostic)]\n+/// #[lint(lint::atomic_ordering_invalid_fail_success)]\n+/// pub struct AtomicOrderingInvalidLint {\n+///     method: Symbol,\n+///     success_ordering: Symbol,\n+///     fail_ordering: Symbol,\n+///     #[label(lint::fail_label)]\n+///     fail_order_arg_span: Span,\n+///     #[label(lint::success_label)]\n+///     #[suggestion(\n+///         code = \"std::sync::atomic::Ordering::{success_suggestion}\",\n+///         applicability = \"maybe-incorrect\"\n+///     )]\n+///     success_order_arg_span: Span,\n+/// }\n+/// ```\n+///\n+/// ```fluent\n+/// lint-atomic-ordering-invalid-fail-success = `{$method}`'s success ordering must be at least as strong as its failure ordering\n+///     .fail-label = `{$fail_ordering}` failure ordering\n+///     .success-label = `{$success_ordering}` success ordering\n+///     .suggestion = consider using `{$success_suggestion}` success ordering instead\n+/// ```\n+///\n+/// Then, later, to emit the error:\n+///\n+/// ```ignore (rust)\n+/// cx.struct_span_lint(INVALID_ATOMIC_ORDERING, fail_order_arg_span, AtomicOrderingInvalidLint {\n+///     method,\n+///     success_ordering,\n+///     fail_ordering,\n+///     fail_order_arg_span,\n+///     success_order_arg_span,\n+/// });\n+/// ```\n+///\n+/// See rustc dev guide for more examples on using the `#[derive(LintDiagnostic)]`:\n+/// <https://rustc-dev-guide.rust-lang.org/diagnostics/sessiondiagnostic.html>\n+pub fn lint_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n+    LintDiagnosticDerive::new(format_ident!(\"diag\"), s).into_tokens()\n }\n \n /// Implements `#[derive(SessionSubdiagnostic)]`, which allows for labels, notes, helps and"}, {"sha": "2a5b6beba94bbed5afd3470646fb171050a170f0", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -1,8 +1,7 @@\n #![deny(unused_must_use)]\n \n use crate::diagnostics::error::{\n-    span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err,\n-    SessionDiagnosticDeriveError,\n+    span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err, DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n     report_error_if_not_applied_to_applicability, report_error_if_not_applied_to_span,\n@@ -214,7 +213,7 @@ impl<'a> HasFieldMap for SessionSubdiagnosticDeriveBuilder<'a> {\n }\n \n impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n-    fn identify_kind(&mut self) -> Result<(), SessionDiagnosticDeriveError> {\n+    fn identify_kind(&mut self) -> Result<(), DiagnosticDeriveError> {\n         for attr in self.variant.ast().attrs {\n             let span = attr.span().unwrap();\n \n@@ -351,7 +350,7 @@ impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n         &mut self,\n         binding: &BindingInfo<'_>,\n         is_suggestion: bool,\n-    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+    ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let ast = binding.ast();\n \n         let inner_ty = FieldInnerTy::from_type(&ast.ty);\n@@ -411,7 +410,7 @@ impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n         Ok(inner_ty.with(binding, generated))\n     }\n \n-    fn into_tokens(&mut self) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+    fn into_tokens(&mut self) -> Result<TokenStream, DiagnosticDeriveError> {\n         self.identify_kind()?;\n         let Some(kind) = self.kind.map(|(kind, _)| kind) else {\n             throw_span_err!("}, {"sha": "8977db4606c5694851ab358aeb340e2b9f689bcc", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -1,11 +1,11 @@\n-use crate::diagnostics::error::{span_err, throw_span_err, SessionDiagnosticDeriveError};\n+use crate::diagnostics::error::{span_err, throw_span_err, DiagnosticDeriveError};\n use proc_macro::Span;\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote, ToTokens};\n-use std::collections::BTreeSet;\n+use std::collections::{BTreeSet, HashMap};\n use std::str::FromStr;\n use syn::{spanned::Spanned, Attribute, Meta, Type, TypeTuple};\n-use synstructure::BindingInfo;\n+use synstructure::{BindingInfo, Structure};\n \n /// Checks whether the type name of `ty` matches `name`.\n ///\n@@ -34,7 +34,7 @@ pub(crate) fn type_is_unit(ty: &Type) -> bool {\n pub(crate) fn report_type_error(\n     attr: &Attribute,\n     ty_name: &str,\n-) -> Result<!, SessionDiagnosticDeriveError> {\n+) -> Result<!, DiagnosticDeriveError> {\n     let name = attr.path.segments.last().unwrap().ident.to_string();\n     let meta = attr.parse_meta()?;\n \n@@ -59,7 +59,7 @@ fn report_error_if_not_applied_to_ty(\n     info: &FieldInfo<'_>,\n     path: &[&str],\n     ty_name: &str,\n-) -> Result<(), SessionDiagnosticDeriveError> {\n+) -> Result<(), DiagnosticDeriveError> {\n     if !type_matches_path(&info.ty, path) {\n         report_type_error(attr, ty_name)?;\n     }\n@@ -71,7 +71,7 @@ fn report_error_if_not_applied_to_ty(\n pub(crate) fn report_error_if_not_applied_to_applicability(\n     attr: &Attribute,\n     info: &FieldInfo<'_>,\n-) -> Result<(), SessionDiagnosticDeriveError> {\n+) -> Result<(), DiagnosticDeriveError> {\n     report_error_if_not_applied_to_ty(\n         attr,\n         info,\n@@ -84,7 +84,7 @@ pub(crate) fn report_error_if_not_applied_to_applicability(\n pub(crate) fn report_error_if_not_applied_to_span(\n     attr: &Attribute,\n     info: &FieldInfo<'_>,\n-) -> Result<(), SessionDiagnosticDeriveError> {\n+) -> Result<(), DiagnosticDeriveError> {\n     report_error_if_not_applied_to_ty(attr, info, &[\"rustc_span\", \"Span\"], \"`Span`\")\n }\n \n@@ -166,10 +166,12 @@ pub(crate) struct FieldInfo<'a> {\n /// Small helper trait for abstracting over `Option` fields that contain a value and a `Span`\n /// for error reporting if they are set more than once.\n pub(crate) trait SetOnce<T> {\n-    fn set_once(&mut self, value: T);\n+    fn set_once(&mut self, _: (T, Span));\n+\n+    fn value(self) -> Option<T>;\n }\n \n-impl<T> SetOnce<(T, Span)> for Option<(T, Span)> {\n+impl<T> SetOnce<T> for Option<(T, Span)> {\n     fn set_once(&mut self, (value, span): (T, Span)) {\n         match self {\n             None => {\n@@ -182,6 +184,10 @@ impl<T> SetOnce<(T, Span)> for Option<(T, Span)> {\n             }\n         }\n     }\n+\n+    fn value(self) -> Option<T> {\n+        self.map(|(v, _)| v)\n+    }\n }\n \n pub(crate) trait HasFieldMap {\n@@ -325,3 +331,20 @@ impl quote::ToTokens for Applicability {\n         });\n     }\n }\n+\n+/// Build the mapping of field names to fields. This allows attributes to peek values from\n+/// other fields.\n+pub(crate) fn build_field_mapping<'a>(structure: &Structure<'a>) -> HashMap<String, TokenStream> {\n+    let mut fields_map = HashMap::new();\n+\n+    let ast = structure.ast();\n+    if let syn::Data::Struct(syn::DataStruct { fields, .. }) = &ast.data {\n+        for field in fields.iter() {\n+            if let Some(ident) = &field.ident {\n+                fields_map.insert(ident.to_string(), quote! { &self.#ident });\n+            }\n+        }\n+    }\n+\n+    fields_map\n+}"}, {"sha": "168530c54b99ecfe0122f3091fad5a14b4f3254f", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -129,6 +129,7 @@ decl_derive!(\n         // struct attributes\n         warning,\n         error,\n+        lint,\n         note,\n         help,\n         // field attributes\n@@ -141,6 +142,24 @@ decl_derive!(\n         suggestion_hidden,\n         suggestion_verbose)] => diagnostics::session_diagnostic_derive\n );\n+decl_derive!(\n+    [LintDiagnostic, attributes(\n+        // struct attributes\n+        warning,\n+        error,\n+        lint,\n+        note,\n+        help,\n+        // field attributes\n+        skip_arg,\n+        primary_span,\n+        label,\n+        subdiagnostic,\n+        suggestion,\n+        suggestion_short,\n+        suggestion_hidden,\n+        suggestion_verbose)] => diagnostics::lint_diagnostic_derive\n+);\n decl_derive!(\n     [SessionSubdiagnostic, attributes(\n         // struct/variant attributes"}, {"sha": "4b156de410d88efcb57b2745fad3b5262c0f9602", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -2,10 +2,7 @@ use std::cmp;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_errors::{\n-    Diagnostic, DiagnosticBuilder, DiagnosticId, DiagnosticMessage, EmissionGuarantee,\n-    ErrorGuaranteed, MultiSpan,\n-};\n+use rustc_errors::{Diagnostic, DiagnosticId, LintDiagnosticBuilder, MultiSpan};\n use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n use rustc_query_system::ich::StableHashingContext;\n@@ -228,28 +225,6 @@ impl LintExpectation {\n     }\n }\n \n-pub struct LintDiagnosticBuilder<'a, G: EmissionGuarantee>(DiagnosticBuilder<'a, G>);\n-\n-impl<'a, G: EmissionGuarantee> LintDiagnosticBuilder<'a, G> {\n-    /// Return the inner `DiagnosticBuilder`, first setting the primary message to `msg`.\n-    pub fn build(mut self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'a, G> {\n-        self.0.set_primary_message(msg);\n-        self.0.set_is_lint();\n-        self.0\n-    }\n-\n-    /// Create a `LintDiagnosticBuilder` from some existing `DiagnosticBuilder`.\n-    pub fn new(err: DiagnosticBuilder<'a, G>) -> LintDiagnosticBuilder<'a, G> {\n-        LintDiagnosticBuilder(err)\n-    }\n-}\n-\n-impl<'a> LintDiagnosticBuilder<'a, ErrorGuaranteed> {\n-    pub fn forget_guarantee(self) -> LintDiagnosticBuilder<'a, ()> {\n-        LintDiagnosticBuilder(self.0.forget_guarantee())\n-    }\n-}\n-\n pub fn explain_lint_level_source(\n     lint: &'static Lint,\n     level: Level,"}, {"sha": "af071b4e939034a05121b3e165d282ac5f0e7813", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -4,7 +4,7 @@ use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKind, DepKindStruct};\n use crate::hir::place::Place as HirPlace;\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n-use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n+use crate::lint::{struct_lint_level, LintLevelSource};\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::resolve_lifetime;\n use crate::middle::stability;\n@@ -34,7 +34,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n use rustc_data_structures::vec_map::VecMap;\n-use rustc_errors::{ErrorGuaranteed, MultiSpan};\n+use rustc_errors::{DecorateLint, ErrorGuaranteed, LintDiagnosticBuilder, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n@@ -2787,6 +2787,18 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Emit a lint at `span` from a lint struct (some type that implements `DecorateLint`,\n+    /// typically generated by `#[derive(LintDiagnostic)]`).\n+    pub fn emit_spanned_lint(\n+        self,\n+        lint: &'static Lint,\n+        hir_id: HirId,\n+        span: impl Into<MultiSpan>,\n+        decorator: impl for<'a> DecorateLint<'a, ()>,\n+    ) {\n+        self.struct_span_lint_hir(lint, hir_id, span, |diag| decorator.decorate_lint(diag))\n+    }\n+\n     pub fn struct_span_lint_hir(\n         self,\n         lint: &'static Lint,\n@@ -2798,6 +2810,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         struct_lint_level(self.sess, lint, level, src, Some(span.into()), decorate);\n     }\n \n+    /// Emit a lint from a lint struct (some type that implements `DecorateLint`, typically\n+    /// generated by `#[derive(LintDiagnostic)]`).\n+    pub fn emit_lint(\n+        self,\n+        lint: &'static Lint,\n+        id: HirId,\n+        decorator: impl for<'a> DecorateLint<'a, ()>,\n+    ) {\n+        self.struct_lint_node(lint, id, |diag| decorator.decorate_lint(diag))\n+    }\n+\n     pub fn struct_lint_node(\n         self,\n         lint: &'static Lint,"}, {"sha": "8838b14c53a589898278d121d398a475dcba4320", "filename": "compiler/rustc_mir_transform/src/check_const_item_mutation.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -1,5 +1,4 @@\n-use rustc_errors::DiagnosticBuilder;\n-use rustc_middle::lint::LintDiagnosticBuilder;\n+use rustc_errors::{DiagnosticBuilder, LintDiagnosticBuilder};\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;"}, {"sha": "65a2a18e02f8f5ea3b826f59324abd6d9977ef19", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -173,6 +173,7 @@ symbols! {\n         DebugTuple,\n         Decodable,\n         Decoder,\n+        DecorateLint,\n         Default,\n         Deref,\n         DiagnosticMessage,"}, {"sha": "7efb0360b7f25c7582108dddea2481ced0a445d6", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -16,9 +16,8 @@ use crate::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{struct_span_err, EmissionGuarantee};\n+use rustc_errors::{struct_span_err, EmissionGuarantee, LintDiagnosticBuilder};\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::{self, ImplSubject, TyCtxt};\n use rustc_session::lint::builtin::COHERENCE_LEAK_CHECK;"}, {"sha": "8bf0971ccb5a566643eb30c30bfbb5cabbc3edd4", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -1,7 +1,8 @@\n //! Validates syntax inside Rust code blocks (\\`\\`\\`rust).\n use rustc_data_structures::sync::{Lock, Lrc};\n-use rustc_errors::{emitter::Emitter, Applicability, Diagnostic, Handler, LazyFallbackBundle};\n-use rustc_middle::lint::LintDiagnosticBuilder;\n+use rustc_errors::{\n+    emitter::Emitter, Applicability, Diagnostic, Handler, LazyFallbackBundle, LintDiagnosticBuilder,\n+};\n use rustc_parse::parse_stream_from_source_str;\n use rustc_session::parse::ParseSess;\n use rustc_span::hygiene::{AstPass, ExpnData, ExpnKind, LocalExpnId};"}, {"sha": "56e95d70fd53d75013ac6b105b7b0bf341e4b58e", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -17,7 +17,7 @@ use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n extern crate rustc_macros;\n-use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_macros::{SessionDiagnostic, LintDiagnostic, SessionSubdiagnostic};\n \n extern crate rustc_middle;\n use rustc_middle::ty::Ty;\n@@ -535,3 +535,20 @@ struct LabelWithTrailingList {\n     //~^ ERROR `#[label(...)]` is not a valid attribute\n     span: Span,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[lint(typeck::ambiguous_lifetime_bound)]\n+//~^ ERROR only `#[error(..)]` and `#[warn(..)]` are supported\n+struct LintsBad {\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(typeck::ambiguous_lifetime_bound)]\n+struct LintsGood {\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[error(typeck::ambiguous_lifetime_bound)]\n+//~^ ERROR only `#[lint(..)]` is supported\n+struct ErrorsBad {\n+}"}, {"sha": "98c22af387e85eb72cdbc512bbc1464672a7b519", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/df1f41530509308d4271f5b8204809e025293857/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df1f41530509308d4271f5b8204809e025293857/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=df1f41530509308d4271f5b8204809e025293857", "patch": "@@ -363,6 +363,28 @@ error: `#[label(...)]` is not a valid attribute\n LL |     #[label(typeck::label, foo(\"...\"))]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: only `#[error(..)]` and `#[warn(..)]` are supported\n+  --> $DIR/diagnostic-derive.rs:540:1\n+   |\n+LL | / #[lint(typeck::ambiguous_lifetime_bound)]\n+LL | |\n+LL | | struct LintsBad {\n+LL | | }\n+   | |_^\n+   |\n+   = help: use the `#[error(...)]` attribute to create a error\n+\n+error: only `#[lint(..)]` is supported\n+  --> $DIR/diagnostic-derive.rs:551:1\n+   |\n+LL | / #[error(typeck::ambiguous_lifetime_bound)]\n+LL | |\n+LL | | struct ErrorsBad {\n+LL | | }\n+   | |_^\n+   |\n+   = help: use the `#[lint(...)]` attribute to create a lint\n+\n error: cannot find attribute `nonsense` in this scope\n   --> $DIR/diagnostic-derive.rs:53:3\n    |\n@@ -395,7 +417,7 @@ LL |         arg: impl IntoDiagnosticArg,\n    |                   ^^^^^^^^^^^^^^^^^ required by this bound in `DiagnosticBuilder::<'a, G>::set_arg`\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 46 previous errors\n+error: aborting due to 48 previous errors\n \n Some errors have detailed explanations: E0277, E0425.\n For more information about an error, try `rustc --explain E0277`."}]}