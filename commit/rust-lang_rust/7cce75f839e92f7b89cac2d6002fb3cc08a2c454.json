{"sha": "7cce75f839e92f7b89cac2d6002fb3cc08a2c454", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjY2U3NWY4MzllOTJmN2I4OWNhYzJkNjAwMmZiM2NjMDhhMmM0NTQ=", "commit": {"author": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-07-04T02:26:38Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-07-04T08:33:33Z"}, "message": "librustc: Apply null pointer optimization to slices, closures and trait\nobjects.", "tree": {"sha": "99a1f9ec7f4bbe3e5e36943ed612ddfc4e19f83e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99a1f9ec7f4bbe3e5e36943ed612ddfc4e19f83e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cce75f839e92f7b89cac2d6002fb3cc08a2c454", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cce75f839e92f7b89cac2d6002fb3cc08a2c454", "html_url": "https://github.com/rust-lang/rust/commit/7cce75f839e92f7b89cac2d6002fb3cc08a2c454", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cce75f839e92f7b89cac2d6002fb3cc08a2c454/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d5c20647f45f2eb74f337e5434bbe63b0c43345", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d5c20647f45f2eb74f337e5434bbe63b0c43345", "html_url": "https://github.com/rust-lang/rust/commit/5d5c20647f45f2eb74f337e5434bbe63b0c43345"}], "stats": {"total": 143, "additions": 100, "deletions": 43}, "files": [{"sha": "4e88176e53d402331e086e7399fc444e5c7fcd2e", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 99, "deletions": 42, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/7cce75f839e92f7b89cac2d6002fb3cc08a2c454/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cce75f839e92f7b89cac2d6002fb3cc08a2c454/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=7cce75f839e92f7b89cac2d6002fb3cc08a2c454", "patch": "@@ -111,7 +111,7 @@ pub enum Repr {\n     StructWrappedNullablePointer {\n         pub nonnull: Struct,\n         pub nndiscr: Disr,\n-        pub ptrfield: uint,\n+        pub ptrfield: PointerField,\n         pub nullfields: Vec<ty::t>,\n     }\n }\n@@ -211,24 +211,21 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                 let mut discr = 0;\n                 while discr < 2 {\n                     if cases.get(1 - discr).is_zerolen(cx) {\n+                        let st = mk_struct(cx, cases.get(discr).tys.as_slice(), false);\n                         match cases.get(discr).find_ptr() {\n+                            Some(ThinPointer(_)) if st.fields.len() == 1 => {\n+                                return RawNullablePointer {\n+                                    nndiscr: discr as Disr,\n+                                    nnty: *st.fields.get(0),\n+                                    nullfields: cases.get(1 - discr).tys.clone()\n+                                };\n+                            }\n                             Some(ptrfield) => {\n-                                let st = mk_struct(cx, cases.get(discr).tys.as_slice(),\n-                                                   false);\n-\n-                                return if st.fields.len() == 1 {\n-                                    RawNullablePointer {\n-                                        nndiscr: discr as Disr,\n-                                        nnty: *st.fields.get(0),\n-                                        nullfields: cases.get(1 - discr).tys.clone()\n-                                    }\n-                                } else {\n-                                    StructWrappedNullablePointer {\n-                                        nndiscr: discr as Disr,\n-                                        nonnull: st,\n-                                        ptrfield: ptrfield,\n-                                        nullfields: cases.get(1 - discr).tys.clone()\n-                                    }\n+                                return StructWrappedNullablePointer {\n+                                    nndiscr: discr as Disr,\n+                                    nonnull: st,\n+                                    ptrfield: ptrfield,\n+                                    nullfields: cases.get(1 - discr).tys.clone()\n                                 };\n                             }\n                             None => { }\n@@ -283,23 +280,67 @@ pub fn is_ffi_safe(tcx: &ty::ctxt, def_id: ast::DefId) -> bool {\n }\n \n // this should probably all be in ty\n-struct Case { discr: Disr, tys: Vec<ty::t> }\n+struct Case {\n+    discr: Disr,\n+    tys: Vec<ty::t>\n+}\n+\n+\n+#[deriving(Show)]\n+pub enum PointerField {\n+    ThinPointer(uint),\n+    FatPointer(uint, uint)\n+}\n+\n impl Case {\n     fn is_zerolen(&self, cx: &CrateContext) -> bool {\n         mk_struct(cx, self.tys.as_slice(), false).size == 0\n     }\n-    fn find_ptr(&self) -> Option<uint> {\n-        self.tys.iter().position(|&ty| {\n+    fn find_ptr(&self) -> Option<PointerField> {\n+        use back::abi::{fn_field_code, slice_elt_base, trt_field_box};\n+\n+        for (i, &ty) in self.tys.iter().enumerate() {\n             match ty::get(ty).sty {\n-                ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n-                    ty::ty_vec(_, None) | ty::ty_str| ty::ty_trait(..) => false,\n-                    _ => true,\n+                // &T/&mut T could either be a thin or fat pointer depending on T\n+                ty::ty_rptr(_, ty::mt { ty, .. }) => match ty::get(ty).sty {\n+                    // &[T] and &str are a pointer and length pair\n+                    ty::ty_vec(_, None) | ty::ty_str => return Some(FatPointer(i, slice_elt_base)),\n+\n+                    // &Trait/&mut Trait are a pair of pointers: the actual object and a vtable\n+                    ty::ty_trait(..) => return Some(FatPointer(i, trt_field_box)),\n+\n+                    // Any other &T/&mut T is just a pointer\n+                    _ => return Some(ThinPointer(i))\n+                },\n+\n+                // Box<T> could either be a thin or fat pointer depending on T\n+                ty::ty_uniq(t) => match ty::get(t).sty {\n+                    // Box<[T]>/Box<str> might be FatPointer in a post DST world\n+                    ty::ty_vec(_, None) | ty::ty_str => continue,\n+\n+                    // Box<Trait> is a pair of pointers: the actual object and a vtable\n+                    ty::ty_trait(..) => return Some(FatPointer(i, trt_field_box)),\n+\n+                    // Any other Box<T> is just a pointer\n+                    _ => return Some(ThinPointer(i))\n                 },\n-                ty::ty_box(..) | ty::ty_bare_fn(..) => true,\n-                // Is that everything?  Would closures or slices qualify?\n-                _ => false\n+\n+                // Gc<T> is just a pointer\n+                ty::ty_box(..) => return Some(ThinPointer(i)),\n+\n+                // Functions are just pointers\n+                ty::ty_bare_fn(..) => return Some(ThinPointer(i)),\n+\n+                // Closures are a pair of pointers: the code and environment\n+                ty::ty_closure(..) => return Some(FatPointer(i, fn_field_code)),\n+\n+                // Anything else is not a pointer\n+                _ => continue\n+\n             }\n-        })\n+        }\n+\n+        None\n     }\n }\n \n@@ -552,8 +593,8 @@ pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n             val = ICmp(bcx, cmp, Load(bcx, scrutinee), C_null(llptrty));\n             signed = false;\n         }\n-        StructWrappedNullablePointer { nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n-            val = struct_wrapped_nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee);\n+        StructWrappedNullablePointer { nndiscr, ptrfield, .. } => {\n+            val = struct_wrapped_nullable_bitdiscr(bcx, nndiscr, ptrfield, scrutinee);\n             signed = false;\n         }\n     }\n@@ -563,12 +604,15 @@ pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n     }\n }\n \n-fn struct_wrapped_nullable_bitdiscr(bcx: &Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n+fn struct_wrapped_nullable_bitdiscr(bcx: &Block, nndiscr: Disr, ptrfield: PointerField,\n                                     scrutinee: ValueRef) -> ValueRef {\n-    let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n+    let llptrptr = match ptrfield {\n+        ThinPointer(field) => GEPi(bcx, scrutinee, [0, field]),\n+        FatPointer(field, pair) => GEPi(bcx, scrutinee, [0, field, pair])\n+    };\n+    let llptr = Load(bcx, llptrptr);\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n-    let llptrty = type_of::type_of(bcx.ccx(), *nonnull.fields.get(ptrfield));\n-    ICmp(bcx, cmp, llptr, C_null(llptrty))\n+    ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)))\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n@@ -655,9 +699,15 @@ pub fn trans_start_init(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n         }\n         StructWrappedNullablePointer { nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n             if discr != nndiscr {\n-                let llptrptr = GEPi(bcx, val, [0, ptrfield]);\n-                let llptrty = type_of::type_of(bcx.ccx(),\n-                                               *nonnull.fields.get(ptrfield));\n+                let (llptrptr, llptrty) = match ptrfield {\n+                    ThinPointer(field) =>\n+                        (GEPi(bcx, val, [0, field]),\n+                         type_of::type_of(bcx.ccx(), *nonnull.fields.get(field))),\n+                    FatPointer(field, pair) => {\n+                        let v = GEPi(bcx, val, [0, field, pair]);\n+                        (v, val_ty(v).element_type())\n+                    }\n+                };\n                 Store(bcx, C_null(llptrty), llptrptr)\n             }\n         }\n@@ -925,7 +975,11 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n             }\n         }\n         StructWrappedNullablePointer { nndiscr, ptrfield, .. } => {\n-            if is_null(const_struct_field(ccx, val, ptrfield)) {\n+            let (idx, sub_idx) = match ptrfield {\n+                ThinPointer(field) => (field, None),\n+                FatPointer(field, pair) => (field, Some(pair))\n+            };\n+            if is_null(const_struct_field(ccx, val, idx, sub_idx)) {\n                 /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n                 (1 - nndiscr) as Disr\n             } else {\n@@ -946,26 +1000,29 @@ pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n                        _discr: Disr, ix: uint) -> ValueRef {\n     match *r {\n         CEnum(..) => ccx.sess().bug(\"element access in C-like enum const\"),\n-        Univariant(..) => const_struct_field(ccx, val, ix),\n-        General(..) => const_struct_field(ccx, val, ix + 1),\n+        Univariant(..) => const_struct_field(ccx, val, ix, None),\n+        General(..) => const_struct_field(ccx, val, ix + 1, None),\n         RawNullablePointer { .. } => {\n             assert_eq!(ix, 0);\n             val\n         }\n-        StructWrappedNullablePointer{ .. } => const_struct_field(ccx, val, ix)\n+        StructWrappedNullablePointer{ .. } => const_struct_field(ccx, val, ix, None)\n     }\n }\n \n /// Extract field of struct-like const, skipping our alignment padding.\n-fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: uint)\n+fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: uint, sub_idx: Option<uint>)\n     -> ValueRef {\n     // Get the ix-th non-undef element of the struct.\n     let mut real_ix = 0; // actual position in the struct\n     let mut ix = ix; // logical index relative to real_ix\n     let mut field;\n     loop {\n         loop {\n-            field = const_get_elt(ccx, val, [real_ix]);\n+            field = match sub_idx {\n+                Some(si) => const_get_elt(ccx, val, [real_ix, si as u32]),\n+                None => const_get_elt(ccx, val, [real_ix])\n+            };\n             if !is_undef(field) {\n                 break;\n             }"}, {"sha": "eaa4ce23f1a78b8498d9b75c2eea488df73ae306", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cce75f839e92f7b89cac2d6002fb3cc08a2c454/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cce75f839e92f7b89cac2d6002fb3cc08a2c454/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=7cce75f839e92f7b89cac2d6002fb3cc08a2c454", "patch": "@@ -2196,7 +2196,7 @@ impl VariantMemberDescriptionFactory {\n \n enum EnumDiscriminantInfo {\n     RegularDiscriminant(DIType),\n-    OptimizedDiscriminant(uint),\n+    OptimizedDiscriminant(adt::PointerField),\n     NoDiscriminant\n }\n "}]}