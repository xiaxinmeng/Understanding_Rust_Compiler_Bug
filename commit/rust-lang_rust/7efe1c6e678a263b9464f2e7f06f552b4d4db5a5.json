{"sha": "7efe1c6e678a263b9464f2e7f06f552b4d4db5a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZmUxYzZlNjc4YTI2M2I5NDY0ZjJlN2YwNmY1NTJiNGQ0ZGI1YTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-17T18:23:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-17T18:23:30Z"}, "message": "Auto merge of #64525 - nikomatsakis:issue-64512-drop-order-tail-temp, r=davidtwco\n\nadjust desugaring for async fn to correct drop order\n\nOld desugaring, given a user function body `{ $stmts; $expr }`\n\n```\n{\n    let $param_pattern0 = $raw_param0;\n    ...\n    let $param_patternN = $raw_paramN;\n    $stmts;\n    $expr\n}\n```\n\nNew desugaring:\n\n```\n{\n    let $param_pattern0 = $raw_param0;\n    ...\n    let $param_patternN = $raw_paramN;\n    drop-temps {\n        $stmts;\n        $expr\n    }\n}\n```\n\nThe drop-temps is an internal bit of HIR that drops temporaries from the resulting expression, but it should be equivalent to `return { $stmts; $expr }`.\n\nFixes #64512\nFixes #64391", "tree": {"sha": "661b25cd2917b50d931ac4576fedd7da26a96ca0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/661b25cd2917b50d931ac4576fedd7da26a96ca0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5", "html_url": "https://github.com/rust-lang/rust/commit/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9150f844e2624eb013ec78ca08c1d416e6644026", "url": "https://api.github.com/repos/rust-lang/rust/commits/9150f844e2624eb013ec78ca08c1d416e6644026", "html_url": "https://github.com/rust-lang/rust/commit/9150f844e2624eb013ec78ca08c1d416e6644026"}, {"sha": "2d8b10f63c394c99f2268de3132086bc72ee5a2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d8b10f63c394c99f2268de3132086bc72ee5a2b", "html_url": "https://github.com/rust-lang/rust/commit/2d8b10f63c394c99f2268de3132086bc72ee5a2b"}], "stats": {"total": 187, "additions": 161, "deletions": 26}, "files": [{"sha": "48f7fc4446505369371b1964685155d742a2e981", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7efe1c6e678a263b9464f2e7f06f552b4d4db5a5", "patch": "@@ -2682,12 +2682,8 @@ impl<'a> LoweringContext<'a> {\n         bounds.iter().map(|bound| self.lower_param_bound(bound, itctx.reborrow())).collect()\n     }\n \n-    fn lower_block_with_stmts(\n-        &mut self,\n-        b: &Block,\n-        targeted_by_break: bool,\n-        mut stmts: Vec<hir::Stmt>,\n-    ) -> P<hir::Block> {\n+    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n+        let mut stmts = vec![];\n         let mut expr = None;\n \n         for (index, stmt) in b.stmts.iter().enumerate() {\n@@ -2712,8 +2708,11 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n-        self.lower_block_with_stmts(b, targeted_by_break, vec![])\n+    /// Lowers a block directly to an expression, presuming that it\n+    /// has no attributes and is not targeted by a `break`.\n+    fn lower_block_expr(&mut self, b: &Block) -> hir::Expr {\n+        let block = self.lower_block(b, false);\n+        self.expr_block(block, ThinVec::new())\n     }\n \n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {"}, {"sha": "990728fa0e68079b795e01a82e2cc85380e6a513", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=7efe1c6e678a263b9464f2e7f06f552b4d4db5a5", "patch": "@@ -90,10 +90,7 @@ impl LoweringContext<'_> {\n             ),\n             ExprKind::Async(capture_clause, closure_node_id, ref block) => {\n                 self.make_async_expr(capture_clause, closure_node_id, None, block.span, |this| {\n-                    this.with_new_scopes(|this| {\n-                        let block = this.lower_block(block, false);\n-                        this.expr_block(block, ThinVec::new())\n-                    })\n+                    this.with_new_scopes(|this| this.lower_block_expr(block))\n                 })\n             }\n             ExprKind::Await(ref expr) => self.lower_expr_await(e.span, expr),\n@@ -284,8 +281,7 @@ impl LoweringContext<'_> {\n         let else_arm = self.arm(hir_vec![else_pat], P(else_expr));\n \n         // Handle then + scrutinee:\n-        let then_blk = self.lower_block(then, false);\n-        let then_expr = self.expr_block(then_blk, ThinVec::new());\n+        let then_expr = self.lower_block_expr(then);\n         let (then_pat, scrutinee, desugar) = match cond.node {\n             // `<pat> => <then>`:\n             ExprKind::Let(ref pat, ref scrutinee) => {\n@@ -335,8 +331,7 @@ impl LoweringContext<'_> {\n         };\n \n         // Handle then + scrutinee:\n-        let then_blk = self.lower_block(body, false);\n-        let then_expr = self.expr_block(then_blk, ThinVec::new());\n+        let then_expr = self.lower_block_expr(body);\n         let (then_pat, scrutinee, desugar, source) = match cond.node {\n             ExprKind::Let(ref pat, ref scrutinee) => {\n                 // to:\n@@ -356,7 +351,7 @@ impl LoweringContext<'_> {\n                 //\n                 // ```\n                 // 'label: loop {\n-                //     match DropTemps($cond) {\n+                //     match drop-temps { $cond } {\n                 //         true => $body,\n                 //         _ => break,\n                 //     }\n@@ -1310,7 +1305,7 @@ impl LoweringContext<'_> {\n     /// `{ let _t = $expr; _t }` but should provide better compile-time performance.\n     ///\n     /// The drop order can be important in e.g. `if expr { .. }`.\n-    fn expr_drop_temps(\n+    pub(super) fn expr_drop_temps(\n         &mut self,\n         span: Span,\n         expr: P<hir::Expr>,"}, {"sha": "61be40a6b907f63e6ea69cd712bcc7bdeb7c9ae2", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=7efe1c6e678a263b9464f2e7f06f552b4d4db5a5", "patch": "@@ -1071,10 +1071,7 @@ impl LoweringContext<'_> {\n     }\n \n     fn lower_fn_body_block(&mut self, decl: &FnDecl, body: &Block) -> hir::BodyId {\n-        self.lower_fn_body(decl, |this| {\n-            let body = this.lower_block(body, false);\n-            this.expr_block(body, ThinVec::new())\n-        })\n+        self.lower_fn_body(decl, |this| this.lower_block_expr(body))\n     }\n \n     pub(super) fn lower_const_body(&mut self, expr: &Expr) -> hir::BodyId {\n@@ -1102,8 +1099,7 @@ impl LoweringContext<'_> {\n             // from:\n             //\n             //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n-            //       async move {\n-            //       }\n+            //         <body>\n             //     }\n             //\n             // into:\n@@ -1116,11 +1112,19 @@ impl LoweringContext<'_> {\n             //         let <pattern> = __arg1;\n             //         let __arg0 = __arg0;\n             //         let <pattern> = __arg0;\n+            //         drop-temps { <body> } // see comments later in fn for details\n             //       }\n             //     }\n             //\n             // If `<pattern>` is a simple ident, then it is lowered to a single\n             // `let <pattern> = <pattern>;` statement as an optimization.\n+            //\n+            // Note that the body is embedded in `drop-temps`; an\n+            // equivalent desugaring would be `return { <body>\n+            // };`. The key point is that we wish to drop all the\n+            // let-bound variables and temporaries created in the body\n+            // (and its tail expression!) before we drop the\n+            // parameters (c.f. rust-lang/rust#64512).\n             for (index, parameter) in decl.inputs.iter().enumerate() {\n                 let parameter = this.lower_param(parameter);\n                 let span = parameter.pat.span;\n@@ -1219,8 +1223,36 @@ impl LoweringContext<'_> {\n             let async_expr = this.make_async_expr(\n                 CaptureBy::Value, closure_id, None, body.span,\n                 |this| {\n-                    let body = this.lower_block_with_stmts(body, false, statements);\n-                    this.expr_block(body, ThinVec::new())\n+                    // Create a block from the user's function body:\n+                    let user_body = this.lower_block_expr(body);\n+\n+                    // Transform into `drop-temps { <user-body> }`, an expression:\n+                    let desugared_span = this.mark_span_with_reason(\n+                        DesugaringKind::Async,\n+                        user_body.span,\n+                        None,\n+                    );\n+                    let user_body = this.expr_drop_temps(\n+                        desugared_span,\n+                        P(user_body),\n+                        ThinVec::new(),\n+                    );\n+\n+                    // As noted above, create the final block like\n+                    //\n+                    // ```\n+                    // {\n+                    //   let $param_pattern = $raw_param;\n+                    //   ...\n+                    //   drop-temps { <user-body> }\n+                    // }\n+                    // ```\n+                    let body = this.block_all(\n+                        desugared_span,\n+                        statements.into(),\n+                        Some(P(user_body)),\n+                    );\n+                    this.expr_block(P(body), ThinVec::new())\n                 });\n             (HirVec::from(parameters), this.expr(body.span, async_expr, ThinVec::new()))\n         })"}, {"sha": "e40acff6dc1175af0966a7fd5d5bafe6670b57d7", "filename": "src/test/ui/async-await/drop-order/drop-order-for-temporary-in-tail-return-expr.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-temporary-in-tail-return-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-temporary-in-tail-return-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-temporary-in-tail-return-expr.rs?ref=7efe1c6e678a263b9464f2e7f06f552b4d4db5a5", "patch": "@@ -0,0 +1,95 @@\n+// aux-build:arc_wake.rs\n+// edition:2018\n+// run-pass\n+\n+#![allow(unused_variables)]\n+\n+// Test the drop order for parameters relative to local variables and\n+// temporaries created in the tail return expression of the function\n+// body. In particular, check that this drop order is the same between\n+// a `async fn` and an ordinary `fn`. See #64512.\n+\n+extern crate arc_wake;\n+\n+use arc_wake::ArcWake;\n+use std::cell::RefCell;\n+use std::future::Future;\n+use std::sync::Arc;\n+use std::rc::Rc;\n+use std::task::Context;\n+\n+struct EmptyWaker;\n+\n+impl ArcWake for EmptyWaker {\n+    fn wake(self: Arc<Self>) {}\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+enum DropOrder {\n+    Function,\n+    Val(&'static str),\n+}\n+\n+type DropOrderListPtr = Rc<RefCell<Vec<DropOrder>>>;\n+\n+struct D(&'static str, DropOrderListPtr);\n+\n+impl Drop for D {\n+    fn drop(&mut self) {\n+        self.1.borrow_mut().push(DropOrder::Val(self.0));\n+    }\n+}\n+\n+/// Check drop order of temporary \"temp\" as compared to `x`, `y`, and `z`.\n+///\n+/// Expected order:\n+/// - `z`\n+/// - temp\n+/// - `y`\n+/// - `x`\n+async fn foo_async(x: D, _y: D) {\n+    let l = x.1.clone();\n+    let z = D(\"z\", l.clone());\n+    l.borrow_mut().push(DropOrder::Function);\n+    helper_async(&D(\"temp\", l)).await\n+}\n+\n+async fn helper_async(v: &D) { }\n+\n+fn foo_sync(x: D, _y: D) {\n+    let l = x.1.clone();\n+    let z = D(\"z\", l.clone());\n+    l.borrow_mut().push(DropOrder::Function);\n+    helper_sync(&D(\"temp\", l))\n+}\n+\n+fn helper_sync(v: &D) { }\n+\n+fn assert_drop_order_after_poll<Fut: Future<Output = ()>>(\n+    f: impl FnOnce(DropOrderListPtr) -> Fut,\n+    g: impl FnOnce(DropOrderListPtr),\n+) {\n+    let empty = Arc::new(EmptyWaker);\n+    let waker = ArcWake::into_waker(empty);\n+    let mut cx = Context::from_waker(&waker);\n+\n+    let actual_order = Rc::new(RefCell::new(Vec::new()));\n+    let mut fut = Box::pin(f(actual_order.clone()));\n+    let r = fut.as_mut().poll(&mut cx);\n+\n+    assert!(match r {\n+        std::task::Poll::Ready(()) => true,\n+        _ => false,\n+    });\n+\n+    let expected_order = Rc::new(RefCell::new(Vec::new()));\n+    g(expected_order.clone());\n+\n+    assert_eq!(*actual_order.borrow(), *expected_order.borrow());\n+}\n+\n+fn main() {\n+    // Free functions (see doc comment on function for what it tests).\n+    assert_drop_order_after_poll(|l| foo_async(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 |l| foo_sync(D(\"x\", l.clone()), D(\"_y\", l.clone())));\n+}"}, {"sha": "c6faad3aad064e1434aab3adb272afc38b3d5540", "filename": "src/test/ui/async-await/issue-64391.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5/src%2Ftest%2Fui%2Fasync-await%2Fissue-64391.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5/src%2Ftest%2Fui%2Fasync-await%2Fissue-64391.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64391.rs?ref=7efe1c6e678a263b9464f2e7f06f552b4d4db5a5", "patch": "@@ -0,0 +1,14 @@\n+// Regression test for Issue #64391. The goal here is that this\n+// function compiles. In the past, due to incorrect drop order for\n+// temporaries in the tail expression, we failed to compile this\n+// example. The drop order itself is directly tested in\n+// `drop-order/drop-order-for-temporary-in-tail-return-expr.rs`.\n+//\n+// check-pass\n+// edition:2018\n+\n+async fn add(x: u32, y: u32) -> u32 {\n+    async { x + y }.await\n+}\n+\n+fn main() { }"}]}