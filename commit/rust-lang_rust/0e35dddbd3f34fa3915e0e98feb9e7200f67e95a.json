{"sha": "0e35dddbd3f34fa3915e0e98feb9e7200f67e95a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMzVkZGRiZDNmMzRmYTM5MTVlMGU5OGZlYjllNzIwMGY2N2U5NWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-06T21:50:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-06T21:50:12Z"}, "message": "Auto merge of #49392 - retep007:nll-issue-48962, r=nikomatsakis\n\nfixes move analysis\n\nFixed compiler error by correct checking when dereferencing\n\nFix #48962\n\nr? @nikomatsakis", "tree": {"sha": "e0aeb6a2c970679c7facaba6eea018160f089917", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0aeb6a2c970679c7facaba6eea018160f089917"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e35dddbd3f34fa3915e0e98feb9e7200f67e95a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e35dddbd3f34fa3915e0e98feb9e7200f67e95a", "html_url": "https://github.com/rust-lang/rust/commit/0e35dddbd3f34fa3915e0e98feb9e7200f67e95a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e35dddbd3f34fa3915e0e98feb9e7200f67e95a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eeea94c11d02ff62fb011d1afdda9301fdf9726b", "url": "https://api.github.com/repos/rust-lang/rust/commits/eeea94c11d02ff62fb011d1afdda9301fdf9726b", "html_url": "https://github.com/rust-lang/rust/commit/eeea94c11d02ff62fb011d1afdda9301fdf9726b"}, {"sha": "9056c7a8498b73844d2196e43e81120db75db789", "url": "https://api.github.com/repos/rust-lang/rust/commits/9056c7a8498b73844d2196e43e81120db75db789", "html_url": "https://github.com/rust-lang/rust/commit/9056c7a8498b73844d2196e43e81120db75db789"}], "stats": {"total": 190, "additions": 167, "deletions": 23}, "files": [{"sha": "aaed1dd871bac458bff5698002d6c3dea5e5ed50", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e35dddbd3f34fa3915e0e98feb9e7200f67e95a/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e35dddbd3f34fa3915e0e98feb9e7200f67e95a/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=0e35dddbd3f34fa3915e0e98feb9e7200f67e95a", "patch": "@@ -37,6 +37,23 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             .collect::<Vec<_>>();\n \n         if mois.is_empty() {\n+            let root_place = self.prefixes(&place, PrefixSet::All)\n+                .last()\n+                .unwrap();\n+\n+            if self.moved_error_reported\n+                .contains(&root_place.clone())\n+            {\n+                debug!(\n+                    \"report_use_of_moved_or_uninitialized place: error about {:?} suppressed\",\n+                    root_place\n+                );\n+                return;\n+            }\n+\n+            self.moved_error_reported\n+                .insert(root_place.clone());\n+\n             let item_msg = match self.describe_place(place) {\n                 Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),"}, {"sha": "fe7aedb4127f9121a4f32e1e1af5ddf71b1f9d9c", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 69, "deletions": 23, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/0e35dddbd3f34fa3915e0e98feb9e7200f67e95a/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e35dddbd3f34fa3915e0e98feb9e7200f67e95a/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=0e35dddbd3f34fa3915e0e98feb9e7200f67e95a", "patch": "@@ -239,6 +239,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         },\n         access_place_error_reported: FxHashSet(),\n         reservation_error_reported: FxHashSet(),\n+        moved_error_reported: FxHashSet(),\n         nonlexical_regioncx: opt_regioncx,\n         nonlexical_cause_info: None,\n     };\n@@ -285,6 +286,9 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// but it is currently inconvenient to track down the BorrowIndex\n     /// at the time we detect and report a reservation error.\n     reservation_error_reported: FxHashSet<Place<'tcx>>,\n+    /// This field keeps track of errors reported in the checking of moved variables,\n+    /// so that we don't report report seemingly duplicate errors.\n+    moved_error_reported: FxHashSet<Place<'tcx>>,\n     /// Non-lexical region inference context, if NLL is enabled.  This\n     /// contains the results from region inference and lets us e.g.\n     /// find out which CFG points are contained in each borrow region.\n@@ -368,7 +372,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                             LocalMutationIsAllowed::No,\n                             flow_state,\n                         );\n-                        self.check_if_path_is_moved(\n+                        self.check_if_path_or_subpath_is_moved(\n                             context,\n                             InitializationRequiringAction::Use,\n                             (output, span),\n@@ -965,7 +969,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n         match mode {\n             MutateMode::WriteAndRead => {\n-                self.check_if_path_is_moved(\n+                self.check_if_path_or_subpath_is_moved(\n                     context,\n                     InitializationRequiringAction::Update,\n                     place_span,\n@@ -1025,7 +1029,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     flow_state,\n                 );\n \n-                self.check_if_path_is_moved(\n+                self.check_if_path_or_subpath_is_moved(\n                     context,\n                     InitializationRequiringAction::Borrow,\n                     (place, span),\n@@ -1053,7 +1057,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     LocalMutationIsAllowed::No,\n                     flow_state,\n                 );\n-                self.check_if_path_is_moved(\n+                self.check_if_path_or_subpath_is_moved(\n                     context,\n                     InitializationRequiringAction::Use,\n                     (place, span),\n@@ -1100,7 +1104,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n \n                 // Finally, check if path was already moved.\n-                self.check_if_path_is_moved(\n+                self.check_if_path_or_subpath_is_moved(\n                     context,\n                     InitializationRequiringAction::Use,\n                     (place, span),\n@@ -1118,7 +1122,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n \n                 // Finally, check if path was already moved.\n-                self.check_if_path_is_moved(\n+                self.check_if_path_or_subpath_is_moved(\n                     context,\n                     InitializationRequiringAction::Use,\n                     (place, span),\n@@ -1269,7 +1273,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     LocalMutationIsAllowed::No,\n                     flow_state,\n                 );\n-                // We do not need to call `check_if_path_is_moved`\n+                // We do not need to call `check_if_path_or_subpath_is_moved`\n                 // again, as we already called it when we made the\n                 // initial reservation.\n             }\n@@ -1304,7 +1308,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_if_path_is_moved(\n+    fn check_if_full_path_is_moved(\n         &mut self,\n         context: Context,\n         desired_action: InitializationRequiringAction,\n@@ -1322,18 +1326,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         //\n         // 1. Move of `a.b.c`, use of `a.b.c`\n         // 2. Move of `a.b.c`, use of `a.b.c.d` (without first reinitializing `a.b.c.d`)\n-        // 3. Move of `a.b.c`, use of `a` or `a.b`\n-        // 4. Uninitialized `(a.b.c: &_)`, use of `*a.b.c`; note that with\n+        // 3. Uninitialized `(a.b.c: &_)`, use of `*a.b.c`; note that with\n         //    partial initialization support, one might have `a.x`\n         //    initialized but not `a.b`.\n         //\n         // OK scenarios:\n         //\n-        // 5. Move of `a.b.c`, use of `a.b.d`\n-        // 6. Uninitialized `a.x`, initialized `a.b`, use of `a.b`\n-        // 7. Copied `(a.b: &_)`, use of `*(a.b).c`; note that `a.b`\n+        // 4. Move of `a.b.c`, use of `a.b.d`\n+        // 5. Uninitialized `a.x`, initialized `a.b`, use of `a.b`\n+        // 6. Copied `(a.b: &_)`, use of `*(a.b).c`; note that `a.b`\n         //    must have been initialized for the use to be sound.\n-        // 8. Move of `a.b.c` then reinit of `a.b.c.d`, use of `a.b.c.d`\n+        // 7. Move of `a.b.c` then reinit of `a.b.c.d`, use of `a.b.c.d`\n \n         // The dataflow tracks shallow prefixes distinctly (that is,\n         // field-accesses on P distinctly from P itself), in order to\n@@ -1352,9 +1355,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // have a MovePath, that should capture the initialization\n         // state for the place scenario.\n         //\n-        // This code covers scenarios 1, 2, and 4.\n+        // This code covers scenarios 1, 2, and 3.\n \n-        debug!(\"check_if_path_is_moved part1 place: {:?}\", place);\n+        debug!(\"check_if_full_path_is_moved place: {:?}\", place);\n         match self.move_path_closest_to(place) {\n             Ok(mpi) => {\n                 if maybe_uninits.contains(&mpi) {\n@@ -1374,18 +1377,52 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n               // ancestors; dataflow recurs on children when parents\n               // move (to support partial (re)inits).\n               //\n-              // (I.e. querying parents breaks scenario 8; but may want\n+              // (I.e. querying parents breaks scenario 7; but may want\n               // to do such a query based on partial-init feature-gate.)\n         }\n+    }\n+\n+    fn check_if_path_or_subpath_is_moved(\n+        &mut self,\n+        context: Context,\n+        desired_action: InitializationRequiringAction,\n+        place_span: (&Place<'tcx>, Span),\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+    ) {\n+        // FIXME: analogous code in check_loans first maps `place` to\n+        // its base_path ... but is that what we want here?\n+        let place = self.base_path(place_span.0);\n+\n+        let maybe_uninits = &flow_state.uninits;\n+        let curr_move_outs = &flow_state.move_outs;\n+\n+        // Bad scenarios:\n+        //\n+        // 1. Move of `a.b.c`, use of `a` or `a.b`\n+        //    partial initialization support, one might have `a.x`\n+        //    initialized but not `a.b`.\n+        // 2. All bad scenarios from `check_if_full_path_is_moved`\n+        //\n+        // OK scenarios:\n+        //\n+        // 3. Move of `a.b.c`, use of `a.b.d`\n+        // 4. Uninitialized `a.x`, initialized `a.b`, use of `a.b`\n+        // 5. Copied `(a.b: &_)`, use of `*(a.b).c`; note that `a.b`\n+        //    must have been initialized for the use to be sound.\n+        // 6. Move of `a.b.c` then reinit of `a.b.c.d`, use of `a.b.c.d`\n+\n+        self.check_if_full_path_is_moved(context, desired_action, place_span, flow_state);\n \n         // A move of any shallow suffix of `place` also interferes\n         // with an attempt to use `place`. This is scenario 3 above.\n         //\n         // (Distinct from handling of scenarios 1+2+4 above because\n         // `place` does not interfere with suffixes of its prefixes,\n         // e.g. `a.b.c` does not interfere with `a.b.d`)\n+        //\n+        // This code covers scenario 1.\n \n-        debug!(\"check_if_path_is_moved part2 place: {:?}\", place);\n+        debug!(\"check_if_path_or_subpath_is_moved place: {:?}\", place);\n         if let Some(mpi) = self.move_path_for_place(place) {\n             if let Some(child_mpi) = maybe_uninits.has_any_child_of(mpi) {\n                 self.report_use_of_moved_or_uninitialized(\n@@ -1445,7 +1482,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, span): (&Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n-        // recur down place; dispatch to check_if_path_is_moved when necessary\n+        debug!(\"check_if_assigned_path_is_moved place: {:?}\", place);\n+        // recur down place; dispatch to external checks when necessary\n         let mut place = place;\n         loop {\n             match *place {\n@@ -1456,17 +1494,25 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 Place::Projection(ref proj) => {\n                     let Projection { ref base, ref elem } = **proj;\n                     match *elem {\n-                        ProjectionElem::Deref |\n-                        // assigning to *P requires `P` initialized.\n                         ProjectionElem::Index(_/*operand*/) |\n                         ProjectionElem::ConstantIndex { .. } |\n-                        // assigning to P[i] requires `P` initialized.\n+                        // assigning to P[i] requires P to be valid.\n                         ProjectionElem::Downcast(_/*adt_def*/, _/*variant_idx*/) =>\n                         // assigning to (P->variant) is okay if assigning to `P` is okay\n                         //\n                         // FIXME: is this true even if P is a adt with a dtor?\n                         { }\n \n+                        // assigning to (*P) requires P to be initialized\n+                        ProjectionElem::Deref => {\n+                            self.check_if_full_path_is_moved(\n+                                context, InitializationRequiringAction::Use,\n+                                (base, span), flow_state);\n+                            // (base initialized; no need to\n+                            // recur further)\n+                            break;\n+                        }\n+\n                         ProjectionElem::Subslice { .. } => {\n                             panic!(\"we don't allow assignments to subslices, context: {:?}\",\n                                    context);\n@@ -1484,7 +1530,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // check_loans.rs first maps\n                                     // `base` to its base_path.\n \n-                                    self.check_if_path_is_moved(\n+                                    self.check_if_path_or_subpath_is_moved(\n                                         context, InitializationRequiringAction::Assignment,\n                                         (base, span), flow_state);\n "}, {"sha": "e3bbfd9d5fef6739503610795117c30b37dd4861", "filename": "src/test/compile-fail/borrowck/borrowck-issue-48962.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0e35dddbd3f34fa3915e0e98feb9e7200f67e95a/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-issue-48962.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e35dddbd3f34fa3915e0e98feb9e7200f67e95a/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-issue-48962.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-issue-48962.rs?ref=0e35dddbd3f34fa3915e0e98feb9e7200f67e95a", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+\n+struct Node {\n+    elem: i32,\n+    next: Option<Box<Node>>,\n+}\n+\n+fn a() {\n+    let mut node = Node {\n+        elem: 5,\n+        next: None,\n+    };\n+\n+    let mut src = &mut node;\n+    {src};\n+    src.next = None; //~ ERROR use of moved value: `src` [E0382]\n+}\n+\n+fn b() {\n+    let mut src = &mut (22, 44);\n+    {src};\n+    src.0 = 66; //~ ERROR use of moved value: `src` [E0382]\n+}\n+\n+fn main() {\n+    a();\n+    b();\n+}"}, {"sha": "a603dfbfe5fa5fde5e463affda9d566b875f3a56", "filename": "src/test/run-pass/issue-48962.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0e35dddbd3f34fa3915e0e98feb9e7200f67e95a/src%2Ftest%2Frun-pass%2Fissue-48962.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e35dddbd3f34fa3915e0e98feb9e7200f67e95a/src%2Ftest%2Frun-pass%2Fissue-48962.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-48962.rs?ref=0e35dddbd3f34fa3915e0e98feb9e7200f67e95a", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to reinitilize box with moved referent\n+#![feature(nll)]\n+static mut ORDER: [usize; 3] = [0, 0, 0];\n+static mut INDEX: usize = 0;\n+\n+struct Dropee (usize);\n+\n+impl Drop for Dropee {\n+    fn drop(&mut self) {\n+        unsafe {\n+            ORDER[INDEX] = self.0;\n+            INDEX = INDEX + 1;\n+        }\n+    }\n+}\n+\n+fn add_sentintel() {\n+    unsafe {\n+        ORDER[INDEX] = 2;\n+        INDEX = INDEX + 1;\n+    }\n+}\n+\n+fn main() {\n+    let mut x = Box::new(Dropee(1));\n+    *x;  // move out from `*x`\n+    add_sentintel();\n+    *x = Dropee(3); // re-initialize `*x`\n+    {x}; // drop value\n+    unsafe {\n+        assert_eq!(ORDER, [1, 2, 3]);\n+    }\n+}"}]}