{"sha": "5daf13cae371ce4ee90450a1d3006b53395a40d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkYWYxM2NhZTM3MWNlNGVlOTA0NTBhMWQzMDA2YjUzMzk1YTQwZDc=", "commit": {"author": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2016-01-13T06:23:31Z"}, "committer": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2016-02-27T07:01:41Z"}, "message": "libsyntax: parse inclusive ranges", "tree": {"sha": "6849c2db6354ec908cf1f51e9e9e3b5b33e58851", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6849c2db6354ec908cf1f51e9e9e3b5b33e58851"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5daf13cae371ce4ee90450a1d3006b53395a40d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5daf13cae371ce4ee90450a1d3006b53395a40d7", "html_url": "https://github.com/rust-lang/rust/commit/5daf13cae371ce4ee90450a1d3006b53395a40d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5daf13cae371ce4ee90450a1d3006b53395a40d7/comments", "author": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "committer": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5d58de665819f7330b3d64bdd084d25a412830a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5d58de665819f7330b3d64bdd084d25a412830a", "html_url": "https://github.com/rust-lang/rust/commit/c5d58de665819f7330b3d64bdd084d25a412830a"}], "stats": {"total": 131, "additions": 81, "deletions": 50}, "files": [{"sha": "0dbfb2c7be65470ee70d7a0f22d771bfd6f0071a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5daf13cae371ce4ee90450a1d3006b53395a40d7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5daf13cae371ce4ee90450a1d3006b53395a40d7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5daf13cae371ce4ee90450a1d3006b53395a40d7", "patch": "@@ -886,6 +886,15 @@ impl fmt::Debug for Expr {\n     }\n }\n \n+/// Limit types of a range (inclusive or exclusive)\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum RangeLimits {\n+    /// Inclusive at the beginning, exclusive at the end\n+    HalfOpen,\n+    /// Inclusive at the beginning and end\n+    Closed,\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ExprKind {\n     /// A `box x` expression.\n@@ -974,8 +983,8 @@ pub enum ExprKind {\n     TupField(P<Expr>, Spanned<usize>),\n     /// An indexing operation (`foo[2]`)\n     Index(P<Expr>, P<Expr>),\n-    /// A range (`1..2`, `1..`, or `..2`)\n-    Range(Option<P<Expr>>, Option<P<Expr>>),\n+    /// A range (`1..2`, `1..`, `..2`, `1...2`, `1...`, `...2`)\n+    Range(Option<P<Expr>>, Option<P<Expr>>, RangeLimits),\n \n     /// Variable reference, possibly containing `::` and/or type\n     /// parameters, e.g. foo::bar::<baz>."}, {"sha": "591c1295d66412746f56666c518b54af33b89441", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5daf13cae371ce4ee90450a1d3006b53395a40d7/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5daf13cae371ce4ee90450a1d3006b53395a40d7/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=5daf13cae371ce4ee90450a1d3006b53395a40d7", "patch": "@@ -1273,9 +1273,10 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n             ExprKind::Index(el, er) => {\n                 ExprKind::Index(folder.fold_expr(el), folder.fold_expr(er))\n             }\n-            ExprKind::Range(e1, e2) => {\n+            ExprKind::Range(e1, e2, lim) => {\n                 ExprKind::Range(e1.map(|x| folder.fold_expr(x)),\n-                          e2.map(|x| folder.fold_expr(x)))\n+                                e2.map(|x| folder.fold_expr(x)),\n+                                lim)\n             }\n             ExprKind::Path(qself, path) => {\n                 let qself = qself.map(|QSelf { ty, position }| {"}, {"sha": "8b563ef00f31e14aeb9410d3054f2a4c8ae06102", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/5daf13cae371ce4ee90450a1d3006b53395a40d7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5daf13cae371ce4ee90450a1d3006b53395a40d7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5daf13cae371ce4ee90450a1d3006b53395a40d7", "patch": "@@ -20,7 +20,7 @@ use ast::{BlockCheckMode, CaptureBy};\n use ast::{Constness, Crate, CrateConfig};\n use ast::{Decl, DeclKind};\n use ast::{EMPTY_CTXT, EnumDef, ExplicitSelf};\n-use ast::{Expr, ExprKind};\n+use ast::{Expr, ExprKind, RangeLimits};\n use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n use ast::{Ident, ImplItem, Item, ItemKind};\n@@ -2054,9 +2054,10 @@ impl<'a> Parser<'a> {\n \n     pub fn mk_range(&mut self,\n                     start: Option<P<Expr>>,\n-                    end: Option<P<Expr>>)\n-                    -> ast::ExprKind {\n-        ExprKind::Range(start, end)\n+                    end: Option<P<Expr>>,\n+                    limits: RangeLimits)\n+                    -> ast::Expr_ {\n+        ExprKind::Range(start, end, limits)\n     }\n \n     pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent) -> ast::ExprKind {\n@@ -2894,7 +2895,7 @@ impl<'a> Parser<'a> {\n                 LhsExpr::AttributesParsed(attrs) => Some(attrs),\n                 _ => None,\n             };\n-            if self.token == token::DotDot {\n+            if self.token == token::DotDot || self.token == token::DotDotDot {\n                 return self.parse_prefix_range_expr(attrs);\n             } else {\n                 try!(self.parse_prefix_expr(attrs))\n@@ -2940,32 +2941,32 @@ impl<'a> Parser<'a> {\n                                    ExprKind::Type(lhs, rhs), None);\n                 continue\n             } else if op == AssocOp::DotDot {\n-                    // If we didn\u2019t have to handle `x..`, it would be pretty easy to generalise\n-                    // it to the Fixity::None code.\n-                    //\n-                    // We have 2 alternatives here: `x..y` and `x..` The other two variants are\n-                    // handled with `parse_prefix_range_expr` call above.\n-                    let rhs = if self.is_at_start_of_range_notation_rhs() {\n-                        let rhs = self.parse_assoc_expr_with(op.precedence() + 1,\n-                                                             LhsExpr::NotYetParsed);\n-                        match rhs {\n-                            Ok(e) => Some(e),\n-                            Err(mut e) => {\n-                                e.cancel();\n-                                None\n-                            }\n+                // If we didn\u2019t have to handle `x..`, it would be pretty easy to generalise\n+                // it to the Fixity::None code.\n+                //\n+                // We have 2 alternatives here: `x..y` and `x..` The other two variants are\n+                // handled with `parse_prefix_range_expr` call above.\n+                let rhs = if self.is_at_start_of_range_notation_rhs() {\n+                    let rhs = self.parse_assoc_expr_with(op.precedence() + 1,\n+                                                         LhsExpr::NotYetParsed);\n+                    match rhs {\n+                        Ok(e) => Some(e),\n+                        Err(mut e) => {\n+                            e.cancel();\n+                            None\n                         }\n-                    } else {\n-                        None\n-                    };\n-                    let (lhs_span, rhs_span) = (lhs_span, if let Some(ref x) = rhs {\n-                        x.span\n-                    } else {\n-                        cur_op_span\n-                    });\n-                    let r = self.mk_range(Some(lhs), rhs);\n-                    lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r, None);\n-                    break\n+                    }\n+                } else {\n+                    None\n+                };\n+                let (lhs_span, rhs_span) = (lhs.span, if let Some(ref x) = rhs {\n+                    x.span\n+                } else {\n+                    cur_op_span\n+                });\n+                let r = self.mk_range(Some(lhs), rhs, RangeLimits::HalfOpen);\n+                lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r, None);\n+                break\n             }\n \n             let rhs = try!(match op.fixity() {\n@@ -2981,8 +2982,8 @@ impl<'a> Parser<'a> {\n                         this.parse_assoc_expr_with(op.precedence() + 1,\n                             LhsExpr::NotYetParsed)\n                 }),\n-                // We currently have no non-associative operators that are not handled above by\n-                // the special cases. The code is here only for future convenience.\n+                // the only operator handled here is `...` (the other non-associative operators are\n+                // special-cased above)\n                 Fixity::None => self.with_res(\n                     restrictions - Restrictions::RESTRICTION_STMT_EXPR,\n                     |this| {\n@@ -3023,6 +3024,11 @@ impl<'a> Parser<'a> {\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n                     self.mk_expr(lhs_span.lo, rhs_span.hi, aopexpr, None)\n                 }\n+                AssocOp::DotDotDot => {\n+                    let (lhs_span, rhs_span) = (lhs.span, rhs.span);\n+                    let r = self.mk_range(Some(lhs), Some(rhs), RangeLimits::Closed);\n+                    self.mk_expr(lhs_span.lo, rhs_span.hi, r, None)\n+                }\n                 AssocOp::As | AssocOp::Colon | AssocOp::DotDot => {\n                     self.bug(\"As, Colon or DotDot branch reached\")\n                 }\n@@ -3054,18 +3060,19 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse prefix-forms of range notation: `..expr` and `..`\n+    /// Parse prefix-forms of range notation: `..expr`, `..`, `...expr`\n     fn parse_prefix_range_expr(&mut self,\n                                already_parsed_attrs: Option<ThinAttributes>)\n                                -> PResult<'a, P<Expr>> {\n-        debug_assert!(self.token == token::DotDot);\n+        debug_assert!(self.token == token::DotDot || self.token == token::DotDotDot);\n+        let tok = self.token.clone();\n         let attrs = try!(self.parse_or_use_outer_attributes(already_parsed_attrs));\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n         self.bump();\n         let opt_end = if self.is_at_start_of_range_notation_rhs() {\n-            // RHS must be parsed with more associativity than DotDot.\n-            let next_prec = AssocOp::from_token(&token::DotDot).unwrap().precedence() + 1;\n+            // RHS must be parsed with more associativity than the dots.\n+            let next_prec = AssocOp::from_token(&tok).unwrap().precedence() + 1;\n             Some(try!(self.parse_assoc_expr_with(next_prec,\n                                                  LhsExpr::NotYetParsed)\n             .map(|x|{\n@@ -3075,7 +3082,13 @@ impl<'a> Parser<'a> {\n          } else {\n             None\n         };\n-        let r = self.mk_range(None, opt_end);\n+        let r = self.mk_range(None,\n+                              opt_end,\n+                              if tok == token::DotDot {\n+                                  RangeLimits::HalfOpen\n+                              } else {\n+                                  RangeLimits::Closed\n+                              });\n         Ok(self.mk_expr(lo, hi, r, attrs))\n     }\n "}, {"sha": "0c59c240bcdd81bedeb0d5a810a7427a6f29ec95", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5daf13cae371ce4ee90450a1d3006b53395a40d7/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5daf13cae371ce4ee90450a1d3006b53395a40d7/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5daf13cae371ce4ee90450a1d3006b53395a40d7", "patch": "@@ -196,7 +196,7 @@ impl Token {\n             BinOp(Or)                   => true, // in lambda syntax\n             OrOr                        => true, // in lambda syntax\n             AndAnd                      => true, // double borrow\n-            DotDot                      => true, // range notation\n+            DotDot | DotDotDot          => true, // range notation\n             ModSep                      => true,\n             Interpolated(NtExpr(..))    => true,\n             Interpolated(NtIdent(..))   => true,"}, {"sha": "8d81787d922473c9d1f09b1e31fc146f183eb36e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5daf13cae371ce4ee90450a1d3006b53395a40d7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5daf13cae371ce4ee90450a1d3006b53395a40d7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5daf13cae371ce4ee90450a1d3006b53395a40d7", "patch": "@@ -2163,11 +2163,15 @@ impl<'a> State<'a> {\n                 try!(self.print_expr(&index));\n                 try!(word(&mut self.s, \"]\"));\n             }\n-            ast::ExprKind::Range(ref start, ref end) => {\n+            ast::ExprKing::Range(ref start, ref end, limits) => {\n                 if let &Some(ref e) = start {\n                     try!(self.print_expr(&e));\n                 }\n-                try!(word(&mut self.s, \"..\"));\n+                if limits == ast::RangeLimits::HalfOpen {\n+                    try!(word(&mut self.s, \"..\"));\n+                } else {\n+                    try!(word(&mut self.s, \"...\"));\n+                }\n                 if let &Some(ref e) = end {\n                     try!(self.print_expr(&e));\n                 }"}, {"sha": "df4eb1c9ed7d8053ac5382f817c502e42d4d608c", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5daf13cae371ce4ee90450a1d3006b53395a40d7/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5daf13cae371ce4ee90450a1d3006b53395a40d7/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=5daf13cae371ce4ee90450a1d3006b53395a40d7", "patch": "@@ -61,6 +61,8 @@ pub enum AssocOp {\n     As,\n     /// `..` range\n     DotDot,\n+    /// `...` range\n+    DotDotDot,\n     /// `:`\n     Colon,\n }\n@@ -102,6 +104,7 @@ impl AssocOp {\n             Token::AndAnd => Some(LAnd),\n             Token::OrOr => Some(LOr),\n             Token::DotDot => Some(DotDot),\n+            Token::DotDotDot => Some(DotDotDot),\n             Token::Colon => Some(Colon),\n             _ if t.is_keyword(keywords::As) => Some(As),\n             _ => None\n@@ -147,7 +150,7 @@ impl AssocOp {\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => 7,\n             LAnd => 6,\n             LOr => 5,\n-            DotDot => 4,\n+            DotDot | DotDotDot => 4,\n             Inplace => 3,\n             Assign | AssignOp(_) => 2,\n         }\n@@ -162,7 +165,7 @@ impl AssocOp {\n             As | Multiply | Divide | Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd |\n             BitXor | BitOr | Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual |\n             LAnd | LOr | Colon => Fixity::Left,\n-            DotDot => Fixity::None\n+            DotDot | DotDotDot => Fixity::None\n         }\n     }\n \n@@ -171,7 +174,8 @@ impl AssocOp {\n         match *self {\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => true,\n             Inplace | Assign | AssignOp(_) | As | Multiply | Divide | Modulus | Add | Subtract |\n-            ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd | LOr | DotDot | Colon => false\n+            ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd | LOr |\n+            DotDot | DotDotDot | Colon => false\n         }\n     }\n \n@@ -181,7 +185,7 @@ impl AssocOp {\n             Assign | AssignOp(_) | Inplace => true,\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual | As | Multiply | Divide |\n             Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd |\n-            LOr | DotDot | Colon => false\n+            LOr | DotDot | DotDotDot | Colon => false\n         }\n     }\n \n@@ -206,7 +210,7 @@ impl AssocOp {\n             BitOr => Some(BinOpKind::BitOr),\n             LAnd => Some(BinOpKind::And),\n             LOr => Some(BinOpKind::Or),\n-            Inplace | Assign | AssignOp(_) | As | DotDot | Colon => None\n+            Inplace | Assign | AssignOp(_) | As | DotDot | DotDotDot | Colon => None\n         }\n     }\n }"}, {"sha": "73ad488e55c931d1e6e4a87d695a76cc541a3e0b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5daf13cae371ce4ee90450a1d3006b53395a40d7/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5daf13cae371ce4ee90450a1d3006b53395a40d7/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=5daf13cae371ce4ee90450a1d3006b53395a40d7", "patch": "@@ -763,7 +763,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)\n         }\n-        ExprKind::Range(ref start, ref end) => {\n+        ExprKind::Range(ref start, ref end, _) => {\n             walk_list!(visitor, visit_expr, start);\n             walk_list!(visitor, visit_expr, end);\n         }"}]}