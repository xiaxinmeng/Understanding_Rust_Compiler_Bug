{"sha": "fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMzdiZjAwMzc4MzMwMjZjM2ZmZTZlYzFmZTMzNjdmZWM1YTVlMGU=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-06-14T09:29:52Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-06-19T07:53:32Z"}, "message": "Weave the alignment through `ByRef`", "tree": {"sha": "966e94af028804fe58a49fdd927d2b008d71f9f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/966e94af028804fe58a49fdd927d2b008d71f9f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "html_url": "https://github.com/rust-lang/rust/commit/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "921f0d9ca919245dfce2e0e672601619e7b0bf58", "url": "https://api.github.com/repos/rust-lang/rust/commits/921f0d9ca919245dfce2e0e672601619e7b0bf58", "html_url": "https://github.com/rust-lang/rust/commit/921f0d9ca919245dfce2e0e672601619e7b0bf58"}], "stats": {"total": 83, "additions": 41, "deletions": 42}, "files": [{"sha": "904576a2c1d5c1da191527e4ea71eb9b6ce74067", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "patch": "@@ -2,7 +2,7 @@ use std::fmt;\n use rustc_macros::HashStable;\n use rustc_apfloat::{Float, ieee::{Double, Single}};\n \n-use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}, subst::SubstsRef};\n+use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size, Align}, subst::SubstsRef};\n use crate::ty::PlaceholderConst;\n use crate::hir::def_id::DefId;\n \n@@ -45,7 +45,9 @@ pub enum ConstValue<'tcx> {\n \n     /// An allocation together with a pointer into the allocation.\n     /// Invariant: the pointer's `AllocId` resolves to the allocation.\n-    ByRef(Pointer, &'tcx Allocation),\n+    /// The alignment exists to allow `const_field` to have `ByRef` access to nonprimitive fields\n+    /// of packed structs.\n+    ByRef(Pointer, Align, &'tcx Allocation),\n \n     /// Used in the HIR by using `Unevaluated` everywhere and later normalizing to one of the other\n     /// variants when the code is monomorphic enough for that."}, {"sha": "4cd0fd3e824f5d5ddb887da6d1f63f8da4b59894", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "patch": "@@ -1335,7 +1335,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ConstValue::ByRef(ptr, alloc) => ConstValue::ByRef(ptr, alloc),\n+            ConstValue::ByRef(ptr, align, alloc) => ConstValue::ByRef(ptr, align, alloc),\n             ConstValue::Infer(ic) => ConstValue::Infer(ic.fold_with(folder)),\n             ConstValue::Param(p) => ConstValue::Param(p.fold_with(folder)),\n             ConstValue::Placeholder(p) => ConstValue::Placeholder(p),"}, {"sha": "f21f203fcc99f0abea1f89e242014445b3dc37a5", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "patch": "@@ -11,7 +11,7 @@ use crate::value::Value;\n use rustc_codegen_ssa::traits::*;\n \n use crate::consts::const_alloc_to_llvm;\n-use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size};\n+use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size, Align};\n use rustc::mir::interpret::{Scalar, GlobalAlloc, Allocation};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n \n@@ -344,19 +344,20 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn from_const_alloc(\n         &self,\n         layout: TyLayout<'tcx>,\n+        align: Align,\n         alloc: &Allocation,\n         offset: Size,\n     ) -> PlaceRef<'tcx, &'ll Value> {\n         let init = const_alloc_to_llvm(self, alloc);\n-        let base_addr = self.static_addr_of(init, layout.align.abi, None);\n+        let base_addr = self.static_addr_of(init, align, None);\n \n         let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n             self.const_bitcast(base_addr, self.type_i8p()),\n             &self.const_usize(offset.bytes()),\n             1,\n         )};\n         let llval = self.const_bitcast(llval, self.type_ptr_to(layout.llvm_type(self)));\n-        PlaceRef::new_sized(llval, layout, alloc.align)\n+        PlaceRef::new_sized(llval, layout, align)\n     }\n \n     fn const_ptrcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {"}, {"sha": "4bf91bbed60eaeec8c0c64d37ea7ad58504db011", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "patch": "@@ -71,7 +71,9 @@ pub fn codegen_static_initializer(\n     let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n \n     let alloc = match static_.val {\n-        ConstValue::ByRef(ptr, alloc) if ptr.offset.bytes() == 0 => alloc,\n+        ConstValue::ByRef(ptr, align, alloc) if ptr.offset.bytes() == 0 && align == alloc.align => {\n+            alloc\n+        },\n         _ => bug!(\"static const eval returned {:#?}\", static_),\n     };\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))"}, {"sha": "c1626d31c780182f5adba6de03e9177e902cfd03", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "patch": "@@ -109,8 +109,8 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 let b_llval = bx.const_usize((end - start) as u64);\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n-            ConstValue::ByRef(ptr, alloc) => {\n-                return bx.load_operand(bx.from_const_alloc(layout, alloc, ptr.offset));\n+            ConstValue::ByRef(ptr, align, alloc) => {\n+                return bx.load_operand(bx.from_const_alloc(layout, align, alloc, ptr.offset));\n             },\n         };\n "}, {"sha": "72aedb4812a21f4e18a91acfd1c6b41e8eaca449", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "patch": "@@ -424,8 +424,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 match bx.tcx().const_eval(param_env.and(cid)) {\n                     Ok(val) => match val.val {\n-                        mir::interpret::ConstValue::ByRef(ptr, alloc) => {\n-                            bx.cx().from_const_alloc(layout, alloc, ptr.offset)\n+                        mir::interpret::ConstValue::ByRef(ptr, align, alloc) => {\n+                            bx.cx().from_const_alloc(layout, align, alloc, ptr.offset)\n                         }\n                         _ => bug!(\"promoteds should have an allocation: {:?}\", val),\n                     },"}, {"sha": "46286b5329e435d138698698871fe158c006de45", "filename": "src/librustc_codegen_ssa/traits/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs?ref=fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "patch": "@@ -34,6 +34,7 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     fn from_const_alloc(\n         &self,\n         layout: layout::TyLayout<'tcx>,\n+        align: layout::Align,\n         alloc: &Allocation,\n         offset: layout::Size,\n     ) -> PlaceRef<'tcx, Self::Value>;"}, {"sha": "284a8f40e1f35c2d9c964f9979027a5f789a7ee5", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "patch": "@@ -99,7 +99,7 @@ fn op_to_const<'tcx>(\n         Ok(mplace) => {\n             let ptr = mplace.ptr.to_ptr().unwrap();\n             let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-            ConstValue::ByRef(ptr, alloc)\n+            ConstValue::ByRef(ptr, mplace.align, alloc)\n         },\n         // see comment on `let try_as_immediate` above\n         Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n@@ -113,7 +113,7 @@ fn op_to_const<'tcx>(\n                 let mplace = op.to_mem_place();\n                 let ptr = mplace.ptr.to_ptr().unwrap();\n                 let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-                ConstValue::ByRef(ptr, alloc)\n+                ConstValue::ByRef(ptr, mplace.align, alloc)\n             },\n         },\n         Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n@@ -482,10 +482,7 @@ pub fn const_field<'tcx>(\n     trace!(\"const_field: {:?}, {:?}\", field, value);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n     // get the operand again\n-    let mut op = ecx.eval_const_to_op(value, None).unwrap();\n-    // Ignore the alignment when accessing the field, since it may be a field of a\n-    // packed struct and thus end up causing an alignment error if we read from it.\n-    op.force_unaligned_access();\n+    let op = ecx.eval_const_to_op(value, None).unwrap();\n     // downcast\n     let down = match variant {\n         None => op,\n@@ -544,7 +541,11 @@ fn validate_and_turn_into_const<'tcx>(\n         if tcx.is_static(def_id) || cid.promoted.is_some() {\n             let ptr = mplace.ptr.to_ptr()?;\n             Ok(tcx.mk_const(ty::Const {\n-                val: ConstValue::ByRef(ptr, ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id)),\n+                val: ConstValue::ByRef(\n+                    ptr,\n+                    mplace.align,\n+                    ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n+                ),\n                 ty: mplace.layout.ty,\n             }))\n         } else {"}, {"sha": "71daae5a7096ec401cd9e304f4288c05912fbfdc", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "patch": "@@ -215,10 +215,15 @@ impl LiteralExpander<'tcx> {\n         debug!(\"fold_const_value_deref {:?} {:?} {:?}\", val, rty, crty);\n         match (val, &crty.sty, &rty.sty) {\n             // the easy case, deref a reference\n-            (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => ConstValue::ByRef(\n-                p,\n-                self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id),\n-            ),\n+            (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => {\n+                let alloc = self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id);\n+                ConstValue::ByRef(\n+                    p,\n+                    // FIXME(oli-obk): this should be the type's layout\n+                    alloc.align,\n+                    alloc,\n+                )\n+            },\n             // unsize array to slice if pattern is array but match value or other patterns are slice\n             (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n                 assert_eq!(t, u);\n@@ -1431,7 +1436,7 @@ fn slice_pat_covered_by_const<'tcx>(\n     suffix: &[Pattern<'tcx>],\n ) -> Result<bool, ErrorReported> {\n     let data: &[u8] = match (const_val.val, &const_val.ty.sty) {\n-        (ConstValue::ByRef(ptr, alloc), ty::Array(t, n)) => {\n+        (ConstValue::ByRef(ptr, _, alloc), ty::Array(t, n)) => {\n             assert_eq!(*t, tcx.types.u8);\n             let n = n.assert_usize(tcx).unwrap();\n             alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n@@ -1753,7 +1758,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                     let (alloc, offset, n, ty) = match value.ty.sty {\n                         ty::Array(t, n) => {\n                             match value.val {\n-                                ConstValue::ByRef(ptr, alloc) => (\n+                                ConstValue::ByRef(ptr, _, alloc) => (\n                                     alloc,\n                                     ptr.offset,\n                                     n.unwrap_usize(cx.tcx),"}, {"sha": "1b451e0b8f18f7e5c1cbc25e731d289dd97ad828", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "patch": "@@ -5,7 +5,7 @@ use std::convert::TryInto;\n \n use rustc::{mir, ty};\n use rustc::ty::layout::{\n-    self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt, VariantIdx, Align,\n+    self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt, VariantIdx,\n };\n \n use rustc::mir::interpret::{\n@@ -179,19 +179,6 @@ impl<'tcx, Tag> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     }\n }\n \n-impl<'tcx, Tag> OpTy<'tcx, Tag> {\n-    /// This function exists solely for pattern matching. If we pattern match a packed struct with\n-    /// an ADT field, the constant representing that field will have lost the information about the\n-    /// packedness. We could clone the allocation and adjust the alignment, but that seems wasteful,\n-    /// since the alignment is already encoded in the allocation. We know it is alright, because\n-    /// validation checked everything before the initial constant entered match checking.\n-    pub(crate) fn force_unaligned_access(&mut self) {\n-        if let Operand::Indirect(mplace) = &mut self.op {\n-            mplace.align = Align::from_bytes(1).unwrap();\n-        }\n-    }\n-}\n-\n impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag>\n {\n     #[inline]\n@@ -551,11 +538,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n             self.layout_of(self.monomorphize(val.ty)?)\n         })?;\n         let op = match val.val {\n-            ConstValue::ByRef(ptr, _alloc) => {\n+            ConstValue::ByRef(ptr, align, _alloc) => {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen.\n                 let ptr = self.tag_static_base_pointer(ptr);\n-                Operand::Indirect(MemPlace::from_ptr(ptr, layout.align.abi))\n+                Operand::Indirect(MemPlace::from_ptr(ptr, align))\n             },\n             ConstValue::Scalar(x) =>\n                 Operand::Immediate(Immediate::Scalar(tag_scalar(x).into())),"}, {"sha": "c64bb73802dc822cdf834d0441cbdb4dc0a04e44", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "patch": "@@ -1262,7 +1262,7 @@ fn collect_const<'tcx>(\n         ConstValue::Scalar(Scalar::Ptr(ptr)) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n         ConstValue::Slice { data: alloc, start: _, end: _ } |\n-        ConstValue::ByRef(_, alloc) => {\n+        ConstValue::ByRef(_, _, alloc) => {\n             for &((), id) in alloc.relocations.values() {\n                 collect_miri(tcx, id, output);\n             }"}, {"sha": "1c0b77b2778cfc3ce2c4d3f144b337f2bcbb8d96", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fb37bf0037833026c3ffe6ec1fe3367fec5a5e0e", "patch": "@@ -1448,7 +1448,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: DefId, span: Span)\n     };\n     let param_env = ty::ParamEnv::reveal_all();\n     if let Ok(static_) = tcx.const_eval(param_env.and(cid)) {\n-        let alloc = if let ConstValue::ByRef(_, allocation) = static_.val {\n+        let alloc = if let ConstValue::ByRef(_, _, allocation) = static_.val {\n             allocation\n         } else {\n             bug!(\"Matching on non-ByRef static\")"}]}