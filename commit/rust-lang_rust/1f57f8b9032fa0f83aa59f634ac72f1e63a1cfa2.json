{"sha": "1f57f8b9032fa0f83aa59f634ac72f1e63a1cfa2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmNTdmOGI5MDMyZmEwZjgzYWE1OWY2MzRhYzcyZjFlNjNhMWNmYTI=", "commit": {"author": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2021-09-06T23:44:24Z"}, "committer": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2021-09-09T00:32:03Z"}, "message": "remove `WorkNode`", "tree": {"sha": "21fcb43967882c55b2a3328a47843125cbdff2fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21fcb43967882c55b2a3328a47843125cbdff2fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f57f8b9032fa0f83aa59f634ac72f1e63a1cfa2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f57f8b9032fa0f83aa59f634ac72f1e63a1cfa2", "html_url": "https://github.com/rust-lang/rust/commit/1f57f8b9032fa0f83aa59f634ac72f1e63a1cfa2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f57f8b9032fa0f83aa59f634ac72f1e63a1cfa2/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cbcb0936a3ae16a99f977427a6a01646a1ed8dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cbcb0936a3ae16a99f977427a6a01646a1ed8dd", "html_url": "https://github.com/rust-lang/rust/commit/4cbcb0936a3ae16a99f977427a6a01646a1ed8dd"}], "stats": {"total": 61, "additions": 10, "deletions": 51}, "files": [{"sha": "c47b0c31ca01c09db8a2fdfc64a88105443d4aee", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 10, "deletions": 51, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1f57f8b9032fa0f83aa59f634ac72f1e63a1cfa2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57f8b9032fa0f83aa59f634ac72f1e63a1cfa2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=1f57f8b9032fa0f83aa59f634ac72f1e63a1cfa2", "patch": "@@ -224,24 +224,13 @@ impl<'tcx> AbstractConst<'tcx> {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-struct WorkNode<'tcx> {\n-    node: Node<'tcx>,\n-    span: Span,\n-    used: bool,\n-}\n-\n struct AbstractConstBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body_id: thir::ExprId,\n+    /// `Lrc` is used to avoid borrowck difficulties in `recurse_build`\n     body: Lrc<&'a thir::Thir<'tcx>>,\n     /// The current WIP node tree.\n-    ///\n-    /// We require all nodes to be used in the final abstract const,\n-    /// so we store this here. Note that we also consider nodes as used\n-    /// if they are mentioned in an assert, so some used nodes are never\n-    /// actually reachable by walking the [`AbstractConst`].\n-    nodes: IndexVec<NodeId, WorkNode<'tcx>>,\n+    nodes: IndexVec<NodeId, Node<'tcx>>,\n }\n \n impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n@@ -301,30 +290,6 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         Ok(Some(builder))\n     }\n \n-    fn add_node(&mut self, node: Node<'tcx>, span: Span) -> NodeId {\n-        // Mark used nodes.\n-        match node {\n-            Node::Leaf(_) => (),\n-            Node::Binop(_, lhs, rhs) => {\n-                self.nodes[lhs].used = true;\n-                self.nodes[rhs].used = true;\n-            }\n-            Node::UnaryOp(_, input) => {\n-                self.nodes[input].used = true;\n-            }\n-            Node::FunctionCall(func, nodes) => {\n-                self.nodes[func].used = true;\n-                nodes.iter().for_each(|&n| self.nodes[n].used = true);\n-            }\n-            Node::Cast(operand, _) => {\n-                self.nodes[operand].used = true;\n-            }\n-        }\n-\n-        // Nodes start as unused.\n-        self.nodes.push(WorkNode { node, span, used: false })\n-    }\n-\n     /// We do not allow all binary operations in abstract consts, so filter disallowed ones.\n     fn check_binop(op: mir::BinOp) -> bool {\n         use mir::BinOp::*;\n@@ -348,23 +313,17 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n     /// encountering an unspported operation.\n     fn build(mut self) -> Result<&'tcx [Node<'tcx>], ErrorReported> {\n         debug!(\"Abstractconstbuilder::build: body={:?}\", &*self.body);\n-        let last = self.recurse_build(self.body_id)?;\n-        self.nodes[last].used = true;\n+        self.recurse_build(self.body_id)?;\n \n         for n in self.nodes.iter() {\n-            if let Node::Leaf(ty::Const { val: ty::ConstKind::Unevaluated(ct), ty: _ }) = n.node {\n+            if let Node::Leaf(ty::Const { val: ty::ConstKind::Unevaluated(ct), ty: _ }) = n {\n                 // `AbstractConst`s should not contain any promoteds as they require references which\n                 // are not allowed.\n                 assert_eq!(ct.promoted, None);\n             }\n         }\n \n-        // FIXME I dont even think we can get unused nodes anymore with thir abstract const\n-        if let Some(&unused) = self.nodes.iter().find(|n| !n.used) {\n-            self.error(Some(unused.span), \"dead code\")?;\n-        }\n-\n-        Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter().map(|n| n.node)))\n+        Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter()))\n     }\n \n     fn recurse_build(&mut self, node: thir::ExprId) -> Result<NodeId, ErrorReported> {\n@@ -380,7 +339,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             // subtle: associated consts are literals this arm handles\n             // `<T as Trait>::ASSOC` as well as `12`\n             &ExprKind::Literal { literal, .. }\n-            | &ExprKind::StaticRef { literal, .. } => self.add_node(Node::Leaf(literal), node.span),\n+            | &ExprKind::StaticRef { literal, .. } => self.nodes.push(Node::Leaf(literal)),\n \n             // FIXME(generic_const_exprs) handle `from_hir_call` field\n             ExprKind::Call { fun, args,  .. } => {\n@@ -391,16 +350,16 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                     new_args.push(self.recurse_build(id)?);\n                 }\n                 let new_args = self.tcx.arena.alloc_slice(&new_args);\n-                self.add_node(Node::FunctionCall(fun, new_args), node.span)\n+                self.nodes.push(Node::FunctionCall(fun, new_args))\n             },\n             &ExprKind::Binary { op, lhs, rhs } if Self::check_binop(op) => {\n                 let lhs = self.recurse_build(lhs)?;\n                 let rhs = self.recurse_build(rhs)?;\n-                self.add_node(Node::Binop(op, lhs, rhs), node.span)\n+                self.nodes.push(Node::Binop(op, lhs, rhs))\n             }\n             &ExprKind::Unary { op, arg } if Self::check_unop(op) => {\n                 let arg = self.recurse_build(arg)?;\n-                self.add_node(Node::UnaryOp(op, arg), node.span)\n+                self.nodes.push(Node::UnaryOp(op, arg))\n             },\n             // this is necessary so that the following compiles:\n             //\n@@ -416,7 +375,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             &ExprKind::Use { source}\n             | &ExprKind::Cast { source } => {\n                 let arg = self.recurse_build(source)?;\n-                self.add_node(Node::Cast(arg, node.ty), node.span)\n+                self.nodes.push(Node::Cast(arg, node.ty))\n             },\n \n             // FIXME(generic_const_exprs) we want to support these"}]}