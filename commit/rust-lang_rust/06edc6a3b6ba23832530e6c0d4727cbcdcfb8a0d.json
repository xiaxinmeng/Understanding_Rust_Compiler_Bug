{"sha": "06edc6a3b6ba23832530e6c0d4727cbcdcfb8a0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ZWRjNmEzYjZiYTIzODMyNTMwZTZjMGQ0NzI3Y2JjZGNmYjhhMGQ=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-04-14T03:30:08Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-16T02:45:00Z"}, "message": "More default impl and docs removal in treemap", "tree": {"sha": "2849466d4a99a9eab68ae197c70f46bff5be6ac0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2849466d4a99a9eab68ae197c70f46bff5be6ac0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06edc6a3b6ba23832530e6c0d4727cbcdcfb8a0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06edc6a3b6ba23832530e6c0d4727cbcdcfb8a0d", "html_url": "https://github.com/rust-lang/rust/commit/06edc6a3b6ba23832530e6c0d4727cbcdcfb8a0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06edc6a3b6ba23832530e6c0d4727cbcdcfb8a0d/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7325bdd8e29d57e7bc971b86accfb352c4262bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7325bdd8e29d57e7bc971b86accfb352c4262bc", "html_url": "https://github.com/rust-lang/rust/commit/c7325bdd8e29d57e7bc971b86accfb352c4262bc"}], "stats": {"total": 27, "additions": 0, "deletions": 27}, "files": [{"sha": "3db12b5a538cbbc5fdac07e62129cf6c2345e14a", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/06edc6a3b6ba23832530e6c0d4727cbcdcfb8a0d/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06edc6a3b6ba23832530e6c0d4727cbcdcfb8a0d/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=06edc6a3b6ba23832530e6c0d4727cbcdcfb8a0d", "patch": "@@ -64,32 +64,20 @@ fn lt<K: Ord + TotalOrd, V: Ord>(a: &TreeMap<K, V>,\n impl<K: Ord + TotalOrd, V: Ord> Ord for TreeMap<K, V> {\n     #[inline]\n     fn lt(&self, other: &TreeMap<K, V>) -> bool { lt(self, other) }\n-    #[inline]\n-    fn le(&self, other: &TreeMap<K, V>) -> bool { !lt(other, self) }\n-    #[inline]\n-    fn ge(&self, other: &TreeMap<K, V>) -> bool { !lt(self, other) }\n-    #[inline]\n-    fn gt(&self, other: &TreeMap<K, V>) -> bool { lt(other, self) }\n }\n \n impl<K: TotalOrd, V> Container for TreeMap<K, V> {\n-    /// Return the number of elements in the map\n     fn len(&self) -> uint { self.length }\n-\n-    /// Return true if the map contains no elements\n-    fn is_empty(&self) -> bool { self.root.is_none() }\n }\n \n impl<K: TotalOrd, V> Mutable for TreeMap<K, V> {\n-    /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n         self.root = None;\n         self.length = 0\n     }\n }\n \n impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n-    /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n         let mut current: &'a Option<~TreeNode<K, V>> = &self.root;\n         loop {\n@@ -108,22 +96,17 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n }\n \n impl<K: TotalOrd, V> MutableMap<K, V> for TreeMap<K, V> {\n-    /// Return a mutable reference to the value corresponding to the key\n     #[inline]\n     fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> {\n         find_mut(&mut self.root, key)\n     }\n \n-    /// Insert a key-value pair from the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise None is returned.\n     fn swap(&mut self, key: K, value: V) -> Option<V> {\n         let ret = insert(&mut self.root, key, value);\n         if ret.is_none() { self.length += 1 }\n         ret\n     }\n \n-    /// Removes a key from the map, returning the value at the key if the key\n-    /// was previously in the map.\n     fn pop(&mut self, key: &K) -> Option<V> {\n         let ret = remove(&mut self.root, key);\n         if ret.is_some() { self.length -= 1 }\n@@ -531,15 +514,13 @@ impl<K, V> Iterator<(K, V)> for MoveEntries<K,V> {\n }\n \n impl<'a, T> Iterator<&'a T> for SetItems<'a, T> {\n-    /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n         self.iter.next().map(|(value, _)| value)\n     }\n }\n \n impl<'a, T> Iterator<&'a T> for RevSetItems<'a, T> {\n-    /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n         self.iter.next().map(|(value, _)| value)\n@@ -557,19 +538,11 @@ pub struct TreeSet<T> {\n impl<T: Eq + TotalOrd> Eq for TreeSet<T> {\n     #[inline]\n     fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n-    #[inline]\n-    fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n }\n \n impl<T: Ord + TotalOrd> Ord for TreeSet<T> {\n     #[inline]\n     fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n-    #[inline]\n-    fn le(&self, other: &TreeSet<T>) -> bool { self.map <= other.map }\n-    #[inline]\n-    fn ge(&self, other: &TreeSet<T>) -> bool { self.map >= other.map }\n-    #[inline]\n-    fn gt(&self, other: &TreeSet<T>) -> bool { self.map > other.map }\n }\n \n impl<T: TotalOrd> Container for TreeSet<T> {"}]}