{"sha": "dba11cb060f3632a590a4f9c585d58218f17cced", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYTExY2IwNjBmMzYzMmE1OTBhNGY5YzU4NWQ1ODIxOGYxN2NjZWQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T17:01:16Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T17:01:16Z"}, "message": "-mMake it harder to accidently early-exit the loop", "tree": {"sha": "deea8e9c657a6c769d4c239eef228836c5fcc09d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deea8e9c657a6c769d4c239eef228836c5fcc09d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dba11cb060f3632a590a4f9c585d58218f17cced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dba11cb060f3632a590a4f9c585d58218f17cced", "html_url": "https://github.com/rust-lang/rust/commit/dba11cb060f3632a590a4f9c585d58218f17cced", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dba11cb060f3632a590a4f9c585d58218f17cced/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5aa92bab94880a289372c66c99117ae5e6e9e1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5aa92bab94880a289372c66c99117ae5e6e9e1f", "html_url": "https://github.com/rust-lang/rust/commit/b5aa92bab94880a289372c66c99117ae5e6e9e1f"}], "stats": {"total": 326, "additions": 166, "deletions": 160}, "files": [{"sha": "94b9c0ca2cf1e577aecc4d1092c390aedf49e003", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 166, "deletions": 160, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/dba11cb060f3632a590a4f9c585d58218f17cced/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba11cb060f3632a590a4f9c585d58218f17cced/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=dba11cb060f3632a590a4f9c585d58218f17cced", "patch": "@@ -126,6 +126,45 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n     Ok(())\n }\n \n+enum Event {\n+    Lsp(lsp_server::Message),\n+    Task(Task),\n+    Vfs(vfs::loader::Message),\n+    Flycheck(flycheck::Message),\n+}\n+\n+impl fmt::Debug for Event {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let debug_verbose_not = |not: &Notification, f: &mut fmt::Formatter| {\n+            f.debug_struct(\"Notification\").field(\"method\", &not.method).finish()\n+        };\n+\n+        match self {\n+            Event::Lsp(lsp_server::Message::Notification(not)) => {\n+                if notification_is::<lsp_types::notification::DidOpenTextDocument>(not)\n+                    || notification_is::<lsp_types::notification::DidChangeTextDocument>(not)\n+                {\n+                    return debug_verbose_not(not, f);\n+                }\n+            }\n+            Event::Task(Task::Respond(resp)) => {\n+                return f\n+                    .debug_struct(\"Response\")\n+                    .field(\"id\", &resp.id)\n+                    .field(\"error\", &resp.error)\n+                    .finish();\n+            }\n+            _ => (),\n+        }\n+        match self {\n+            Event::Lsp(it) => fmt::Debug::fmt(it, f),\n+            Event::Task(it) => fmt::Debug::fmt(it, f),\n+            Event::Vfs(it) => fmt::Debug::fmt(it, f),\n+            Event::Flycheck(it) => fmt::Debug::fmt(it, f),\n+        }\n+    }\n+}\n+\n impl GlobalState {\n     fn next_event(&self, inbox: &Receiver<lsp_server::Message>) -> Option<Event> {\n         select! {\n@@ -145,97 +184,150 @@ impl GlobalState {\n \n     fn run(mut self, inbox: Receiver<lsp_server::Message>) -> Result<()> {\n         while let Some(event) = self.next_event(&inbox) {\n-            let loop_start = Instant::now();\n-            // NOTE: don't count blocking select! call as a loop-turn time\n-            let _p = profile(\"main_loop_inner/loop-turn\");\n-\n-            log::info!(\"loop turn = {:?}\", event);\n-            let queue_count = self.task_pool.0.len();\n-            if queue_count > 0 {\n-                log::info!(\"queued count = {}\", queue_count);\n+            if let Event::Lsp(lsp_server::Message::Notification(not)) = &event {\n+                if not.method == lsp_types::notification::Exit::METHOD {\n+                    return Ok(());\n+                }\n             }\n+            self.loop_turn(event)?\n+        }\n+        Err(\"client exited without proper shutdown sequence\")?\n+    }\n \n-            let mut became_ready = false;\n-            match event {\n-                Event::Lsp(msg) => match msg {\n-                    lsp_server::Message::Request(req) => self.on_request(loop_start, req)?,\n-                    lsp_server::Message::Notification(not) => {\n-                        if not.method == lsp_types::notification::Exit::METHOD {\n-                            return Ok(());\n+    fn loop_turn(&mut self, event: Event) -> Result<()> {\n+        let loop_start = Instant::now();\n+        // NOTE: don't count blocking select! call as a loop-turn time\n+        let _p = profile(\"main_loop_inner/loop-turn\");\n+\n+        log::info!(\"loop turn = {:?}\", event);\n+        let queue_count = self.task_pool.0.len();\n+        if queue_count > 0 {\n+            log::info!(\"queued count = {}\", queue_count);\n+        }\n+\n+        let mut became_ready = false;\n+        match event {\n+            Event::Lsp(msg) => match msg {\n+                lsp_server::Message::Request(req) => self.on_request(loop_start, req)?,\n+                lsp_server::Message::Notification(not) => {\n+                    self.on_notification(not)?;\n+                }\n+                lsp_server::Message::Response(resp) => {\n+                    let handler = self.req_queue.outgoing.complete(resp.id.clone());\n+                    handler(self, resp)\n+                }\n+            },\n+            Event::Task(task) => {\n+                self.on_task(task);\n+                self.maybe_collect_garbage();\n+            }\n+            Event::Vfs(task) => match task {\n+                vfs::loader::Message::Loaded { files } => {\n+                    let vfs = &mut self.vfs.write().0;\n+                    for (path, contents) in files {\n+                        let path = VfsPath::from(path);\n+                        if !self.mem_docs.contains(&path) {\n+                            vfs.set_file_contents(path, contents)\n                         }\n-                        self.on_notification(not)?;\n                     }\n-                    lsp_server::Message::Response(resp) => {\n-                        let handler = self.req_queue.outgoing.complete(resp.id.clone());\n-                        handler(&mut self, resp)\n-                    }\n-                },\n-                Event::Task(task) => {\n-                    self.on_task(task);\n-                    self.maybe_collect_garbage();\n                 }\n-                Event::Vfs(task) => match task {\n-                    vfs::loader::Message::Loaded { files } => {\n-                        let vfs = &mut self.vfs.write().0;\n-                        for (path, contents) in files {\n-                            let path = VfsPath::from(path);\n-                            if !self.mem_docs.contains(&path) {\n-                                vfs.set_file_contents(path, contents)\n+                vfs::loader::Message::Progress { n_total, n_done } => {\n+                    let state = if n_done == 0 {\n+                        Progress::Begin\n+                    } else if n_done < n_total {\n+                        Progress::Report\n+                    } else {\n+                        assert_eq!(n_done, n_total);\n+                        self.status = Status::Ready;\n+                        became_ready = true;\n+                        Progress::End\n+                    };\n+                    report_progress(\n+                        self,\n+                        \"roots scanned\",\n+                        state,\n+                        Some(format!(\"{}/{}\", n_done, n_total)),\n+                        Some(percentage(n_done, n_total)),\n+                    )\n+                }\n+            },\n+            Event::Flycheck(task) => match task {\n+                flycheck::Message::ClearDiagnostics => {\n+                    on_diagnostic_task(DiagnosticTask::ClearCheck, self)\n+                }\n+\n+                flycheck::Message::AddDiagnostic { workspace_root, diagnostic } => {\n+                    let diagnostics = crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n+                        &self.config.diagnostics,\n+                        &diagnostic,\n+                        &workspace_root,\n+                    );\n+                    for diag in diagnostics {\n+                        let path = from_proto::vfs_path(&diag.location.uri)?;\n+                        let file_id = match self.vfs.read().0.file_id(&path) {\n+                            Some(file) => FileId(file.0),\n+                            None => {\n+                                log::error!(\n+                                    \"File with cargo diagnostic not found in VFS: {}\",\n+                                    path\n+                                );\n+                                return Ok(());\n                             }\n-                        }\n-                    }\n-                    vfs::loader::Message::Progress { n_total, n_done } => {\n-                        let state = if n_done == 0 {\n-                            Progress::Begin\n-                        } else if n_done < n_total {\n-                            Progress::Report\n-                        } else {\n-                            assert_eq!(n_done, n_total);\n-                            self.status = Status::Ready;\n-                            became_ready = true;\n-                            Progress::End\n                         };\n-                        report_progress(\n-                            &mut self,\n-                            \"roots scanned\",\n-                            state,\n-                            Some(format!(\"{}/{}\", n_done, n_total)),\n-                            Some(percentage(n_done, n_total)),\n+\n+                        on_diagnostic_task(\n+                            DiagnosticTask::AddCheck(\n+                                file_id,\n+                                diag.diagnostic,\n+                                diag.fixes.into_iter().map(|it| it.into()).collect(),\n+                            ),\n+                            self,\n                         )\n                     }\n-                },\n-                Event::Flycheck(task) => on_check_task(task, &mut self)?,\n-            }\n+                }\n \n-            let state_changed = self.process_changes();\n-            if became_ready {\n-                if let Some(flycheck) = &self.flycheck {\n-                    flycheck.0.update();\n+                flycheck::Message::Progress(status) => {\n+                    let (state, message) = match status {\n+                        flycheck::Progress::Being => (Progress::Begin, None),\n+                        flycheck::Progress::DidCheckCrate(target) => {\n+                            (Progress::Report, Some(target))\n+                        }\n+                        flycheck::Progress::End => (Progress::End, None),\n+                    };\n+\n+                    report_progress(self, \"cargo check\", state, message, None);\n                 }\n+            },\n+        }\n+\n+        let state_changed = self.process_changes();\n+        if became_ready {\n+            if let Some(flycheck) = &self.flycheck {\n+                flycheck.0.update();\n             }\n+        }\n \n-            if self.status == Status::Ready && (state_changed || became_ready) {\n-                let subscriptions = self\n-                    .mem_docs\n-                    .iter()\n-                    .map(|path| self.vfs.read().0.file_id(&path).unwrap())\n-                    .collect::<Vec<_>>();\n+        if self.status == Status::Ready && (state_changed || became_ready) {\n+            let subscriptions = self\n+                .mem_docs\n+                .iter()\n+                .map(|path| self.vfs.read().0.file_id(&path).unwrap())\n+                .collect::<Vec<_>>();\n \n-                self.update_file_notifications_on_threadpool(subscriptions);\n-            }\n+            self.update_file_notifications_on_threadpool(subscriptions);\n+        }\n \n-            let loop_duration = loop_start.elapsed();\n-            if loop_duration > Duration::from_millis(100) {\n-                log::error!(\"overly long loop turn: {:?}\", loop_duration);\n-                if env::var(\"RA_PROFILE\").is_ok() {\n-                    self.show_message(\n-                        lsp_types::MessageType::Error,\n-                        format!(\"overly long loop turn: {:?}\", loop_duration),\n-                    )\n-                }\n+        let loop_duration = loop_start.elapsed();\n+        if loop_duration > Duration::from_millis(100) {\n+            log::error!(\"overly long loop turn: {:?}\", loop_duration);\n+            if env::var(\"RA_PROFILE\").is_ok() {\n+                self.show_message(\n+                    lsp_types::MessageType::Error,\n+                    format!(\"overly long loop turn: {:?}\", loop_duration),\n+                )\n             }\n         }\n-        Err(\"client exited without proper shutdown sequence\")?\n+        Ok(())\n     }\n \n     fn on_request(&mut self, request_received: Instant, req: Request) -> Result<()> {\n@@ -461,96 +553,10 @@ pub(crate) enum Task {\n     Unit,\n }\n \n-enum Event {\n-    Lsp(lsp_server::Message),\n-    Task(Task),\n-    Vfs(vfs::loader::Message),\n-    Flycheck(flycheck::Message),\n-}\n-\n-impl fmt::Debug for Event {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let debug_verbose_not = |not: &Notification, f: &mut fmt::Formatter| {\n-            f.debug_struct(\"Notification\").field(\"method\", &not.method).finish()\n-        };\n-\n-        match self {\n-            Event::Lsp(lsp_server::Message::Notification(not)) => {\n-                if notification_is::<lsp_types::notification::DidOpenTextDocument>(not)\n-                    || notification_is::<lsp_types::notification::DidChangeTextDocument>(not)\n-                {\n-                    return debug_verbose_not(not, f);\n-                }\n-            }\n-            Event::Task(Task::Respond(resp)) => {\n-                return f\n-                    .debug_struct(\"Response\")\n-                    .field(\"id\", &resp.id)\n-                    .field(\"error\", &resp.error)\n-                    .finish();\n-            }\n-            _ => (),\n-        }\n-        match self {\n-            Event::Lsp(it) => fmt::Debug::fmt(it, f),\n-            Event::Task(it) => fmt::Debug::fmt(it, f),\n-            Event::Vfs(it) => fmt::Debug::fmt(it, f),\n-            Event::Flycheck(it) => fmt::Debug::fmt(it, f),\n-        }\n-    }\n-}\n-\n pub(crate) type ReqHandler = fn(&mut GlobalState, Response);\n pub(crate) type ReqQueue = lsp_server::ReqQueue<(&'static str, Instant), ReqHandler>;\n const DO_NOTHING: ReqHandler = |_, _| ();\n \n-fn on_check_task(task: flycheck::Message, global_state: &mut GlobalState) -> Result<()> {\n-    match task {\n-        flycheck::Message::ClearDiagnostics => {\n-            on_diagnostic_task(DiagnosticTask::ClearCheck, global_state)\n-        }\n-\n-        flycheck::Message::AddDiagnostic { workspace_root, diagnostic } => {\n-            let diagnostics = crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n-                &global_state.config.diagnostics,\n-                &diagnostic,\n-                &workspace_root,\n-            );\n-            for diag in diagnostics {\n-                let path = from_proto::vfs_path(&diag.location.uri)?;\n-                let file_id = match global_state.vfs.read().0.file_id(&path) {\n-                    Some(file) => FileId(file.0),\n-                    None => {\n-                        log::error!(\"File with cargo diagnostic not found in VFS: {}\", path);\n-                        return Ok(());\n-                    }\n-                };\n-\n-                on_diagnostic_task(\n-                    DiagnosticTask::AddCheck(\n-                        file_id,\n-                        diag.diagnostic,\n-                        diag.fixes.into_iter().map(|it| it.into()).collect(),\n-                    ),\n-                    global_state,\n-                )\n-            }\n-        }\n-\n-        flycheck::Message::Progress(status) => {\n-            let (state, message) = match status {\n-                flycheck::Progress::Being => (Progress::Begin, None),\n-                flycheck::Progress::DidCheckCrate(target) => (Progress::Report, Some(target)),\n-                flycheck::Progress::End => (Progress::End, None),\n-            };\n-\n-            report_progress(global_state, \"cargo check\", state, message, None);\n-        }\n-    };\n-\n-    Ok(())\n-}\n-\n fn on_diagnostic_task(task: DiagnosticTask, global_state: &mut GlobalState) {\n     let subscriptions = global_state.diagnostics.handle_task(task);\n "}]}