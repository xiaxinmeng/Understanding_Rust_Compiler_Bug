{"sha": "f73510560f93262ad2e375d63b526af37aa3ae48", "node_id": "C_kwDOAAsO6NoAKGY3MzUxMDU2MGY5MzI2MmFkMmUzNzVkNjNiNTI2YWYzN2FhM2FlNDg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-28T06:36:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-28T06:36:35Z"}, "message": "Auto merge of #14424 - Veykril:local-trait-impls, r=Veykril\n\nfix: Properly handle local trait impls\n\nBefore we only handled trait impls that came from the block of either the trait or the target type, we now handle them correctly by tracking the block we are currently inferring from, then walking that up to collect all block trait impls.", "tree": {"sha": "eedcb600582f950b41f13629d175bb0119bc3eda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eedcb600582f950b41f13629d175bb0119bc3eda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f73510560f93262ad2e375d63b526af37aa3ae48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f73510560f93262ad2e375d63b526af37aa3ae48", "html_url": "https://github.com/rust-lang/rust/commit/f73510560f93262ad2e375d63b526af37aa3ae48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f73510560f93262ad2e375d63b526af37aa3ae48/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a869ca3c29c19c7467864fc44a28877610433afe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a869ca3c29c19c7467864fc44a28877610433afe", "html_url": "https://github.com/rust-lang/rust/commit/a869ca3c29c19c7467864fc44a28877610433afe"}, {"sha": "342fd2b9f372888b069738eec1690d0661787a90", "url": "https://api.github.com/repos/rust-lang/rust/commits/342fd2b9f372888b069738eec1690d0661787a90", "html_url": "https://github.com/rust-lang/rust/commit/342fd2b9f372888b069738eec1690d0661787a90"}], "stats": {"total": 233, "additions": 138, "deletions": 95}, "files": [{"sha": "e6986dd1fce0f22b92a8770f70525379f9935a32", "filename": "crates/hir-def/src/db.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdb.rs?ref=f73510560f93262ad2e375d63b526af37aa3ae48", "patch": "@@ -93,6 +93,8 @@ pub trait DefDatabase: InternDatabase + ExpandDatabase + Upcast<dyn ExpandDataba\n     ///\n     /// The `block_def_map` for block 0 would return `None`, while `block_def_map` of block 1 would\n     /// return a `DefMap` containing `inner`.\n+    // FIXME: This actually can't return None anymore as we no longer allocate block scopes for\n+    // non item declaring blocks\n     #[salsa::invoke(DefMap::block_def_map_query)]\n     fn block_def_map(&self, block: BlockId) -> Option<Arc<DefMap>>;\n "}, {"sha": "68375f9e1eb7ab988c708293784a2326bb98eeff", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 35, "deletions": 48, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=f73510560f93262ad2e375d63b526af37aa3ae48", "patch": "@@ -1,8 +1,7 @@\n //! The implementation of `RustIrDatabase` for Chalk, which provides information\n //! about the code that Chalk needs.\n-use std::sync::Arc;\n+use std::{iter, sync::Arc};\n \n-use cov_mark::hit;\n use tracing::debug;\n \n use chalk_ir::{cast::Cast, fold::shift::Shift, CanonicalVarKinds};\n@@ -12,17 +11,16 @@ use base_db::CrateId;\n use hir_def::{\n     expr::Movability,\n     lang_item::{lang_attr, LangItem, LangItemTarget},\n-    AssocItemId, GenericDefId, HasModule, ItemContainerId, Lookup, ModuleId, TypeAliasId,\n+    AssocItemId, BlockId, GenericDefId, HasModule, ItemContainerId, Lookup, TypeAliasId,\n };\n use hir_expand::name::name;\n \n use crate::{\n     db::HirDatabase,\n     display::HirDisplay,\n-    from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id, make_binders,\n-    make_single_type_binders,\n+    from_assoc_type_id, from_chalk_trait_id, make_binders, make_single_type_binders,\n     mapping::{from_chalk, ToChalk, TypeAliasAsValue},\n-    method_resolution::{TraitImpls, TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n+    method_resolution::{TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n     to_assoc_type_id, to_chalk_trait_id,\n     traits::ChalkContext,\n     utils::generics,\n@@ -108,53 +106,41 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n             _ => self_ty_fp.as_ref().map(std::slice::from_ref).unwrap_or(&[]),\n         };\n \n-        fn local_impls(db: &dyn HirDatabase, module: ModuleId) -> Option<Arc<TraitImpls>> {\n-            let block = module.containing_block()?;\n-            hit!(block_local_impls);\n-            db.trait_impls_in_block(block)\n-        }\n-\n         // Note: Since we're using impls_for_trait, only impls where the trait\n         // can be resolved should ever reach Chalk. impl_datum relies on that\n         // and will panic if the trait can't be resolved.\n         let in_deps = self.db.trait_impls_in_deps(self.krate);\n         let in_self = self.db.trait_impls_in_crate(self.krate);\n-        let trait_module = trait_.module(self.db.upcast());\n-        let type_module = match self_ty_fp {\n-            Some(TyFingerprint::Adt(adt_id)) => Some(adt_id.module(self.db.upcast())),\n-            Some(TyFingerprint::ForeignType(type_id)) => {\n-                Some(from_foreign_def_id(type_id).module(self.db.upcast()))\n-            }\n-            Some(TyFingerprint::Dyn(trait_id)) => Some(trait_id.module(self.db.upcast())),\n-            _ => None,\n-        };\n-        let impl_maps = [\n-            Some(in_deps),\n-            Some(in_self),\n-            local_impls(self.db, trait_module),\n-            type_module.and_then(|m| local_impls(self.db, m)),\n-        ];\n \n-        let id_to_chalk = |id: hir_def::ImplId| id.to_chalk(self.db);\n+        let impl_maps = [in_deps, in_self];\n+        let block_impls = iter::successors(self.block, |&block_id| {\n+            cov_mark::hit!(block_local_impls);\n+            self.db\n+                .block_def_map(block_id)\n+                .and_then(|map| map.parent())\n+                .and_then(|module| module.containing_block())\n+        })\n+        .filter_map(|block_id| self.db.trait_impls_in_block(block_id));\n \n-        let result: Vec<_> = if fps.is_empty() {\n-            debug!(\"Unrestricted search for {:?} impls...\", trait_);\n-            impl_maps\n-                .iter()\n-                .filter_map(|o| o.as_ref())\n-                .flat_map(|impls| impls.for_trait(trait_).map(id_to_chalk))\n-                .collect()\n-        } else {\n-            impl_maps\n-                .iter()\n-                .filter_map(|o| o.as_ref())\n-                .flat_map(|impls| {\n-                    fps.iter().flat_map(move |fp| {\n-                        impls.for_trait_and_self_ty(trait_, *fp).map(id_to_chalk)\n-                    })\n-                })\n-                .collect()\n-        };\n+        let id_to_chalk = |id: hir_def::ImplId| id.to_chalk(self.db);\n+        let mut result = vec![];\n+        match fps {\n+            [] => {\n+                debug!(\"Unrestricted search for {:?} impls...\", trait_);\n+                impl_maps.into_iter().chain(block_impls).for_each(|impls| {\n+                    result.extend(impls.for_trait(trait_).map(id_to_chalk));\n+                });\n+            }\n+            fps => {\n+                impl_maps.into_iter().chain(block_impls).for_each(|impls| {\n+                    result.extend(\n+                        fps.iter().flat_map(|fp| {\n+                            impls.for_trait_and_self_ty(trait_, *fp).map(id_to_chalk)\n+                        }),\n+                    );\n+                });\n+            }\n+        }\n \n         debug!(\"impls_for_trait returned {} impls\", result.len());\n         result\n@@ -193,7 +179,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         &self,\n         environment: &chalk_ir::Environment<Interner>,\n     ) -> chalk_ir::ProgramClauses<Interner> {\n-        self.db.program_clauses_for_chalk_env(self.krate, environment.clone())\n+        self.db.program_clauses_for_chalk_env(self.krate, self.block, environment.clone())\n     }\n \n     fn opaque_ty_data(&self, id: chalk_ir::OpaqueTyId<Interner>) -> Arc<OpaqueTyDatum> {\n@@ -451,9 +437,10 @@ impl<'a> chalk_ir::UnificationDatabase<Interner> for &'a dyn HirDatabase {\n pub(crate) fn program_clauses_for_chalk_env_query(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n+    block: Option<BlockId>,\n     environment: chalk_ir::Environment<Interner>,\n ) -> chalk_ir::ProgramClauses<Interner> {\n-    chalk_solve::program_clauses_for_env(&ChalkContext { db, krate }, &environment)\n+    chalk_solve::program_clauses_for_env(&ChalkContext { db, krate, block }, &environment)\n }\n \n pub(crate) fn associated_ty_data_query("}, {"sha": "56f5d90bb3512f6a89d15ff6be628bcd88551e05", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=f73510560f93262ad2e375d63b526af37aa3ae48", "patch": "@@ -129,7 +129,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn trait_impls_in_crate(&self, krate: CrateId) -> Arc<TraitImpls>;\n \n     #[salsa::invoke(TraitImpls::trait_impls_in_block_query)]\n-    fn trait_impls_in_block(&self, krate: BlockId) -> Option<Arc<TraitImpls>>;\n+    fn trait_impls_in_block(&self, block: BlockId) -> Option<Arc<TraitImpls>>;\n \n     #[salsa::invoke(TraitImpls::trait_impls_in_deps_query)]\n     fn trait_impls_in_deps(&self, krate: CrateId) -> Arc<TraitImpls>;\n@@ -197,20 +197,23 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn trait_solve(\n         &self,\n         krate: CrateId,\n+        block: Option<BlockId>,\n         goal: crate::Canonical<crate::InEnvironment<crate::Goal>>,\n     ) -> Option<crate::Solution>;\n \n     #[salsa::invoke(crate::traits::trait_solve_query)]\n     fn trait_solve_query(\n         &self,\n         krate: CrateId,\n+        block: Option<BlockId>,\n         goal: crate::Canonical<crate::InEnvironment<crate::Goal>>,\n     ) -> Option<crate::Solution>;\n \n     #[salsa::invoke(chalk_db::program_clauses_for_chalk_env_query)]\n     fn program_clauses_for_chalk_env(\n         &self,\n         krate: CrateId,\n+        block: Option<BlockId>,\n         env: chalk_ir::Environment<Interner>,\n     ) -> chalk_ir::ProgramClauses<Interner>;\n }\n@@ -232,10 +235,11 @@ fn infer_wait(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult>\n fn trait_solve_wait(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n+    block: Option<BlockId>,\n     goal: crate::Canonical<crate::InEnvironment<crate::Goal>>,\n ) -> Option<crate::Solution> {\n     let _p = profile::span(\"trait_solve::wait\");\n-    db.trait_solve_query(krate, goal)\n+    db.trait_solve_query(krate, block, goal)\n }\n \n #[test]"}, {"sha": "493f45d40cea70bece643e8d336ef32b0324d953", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=f73510560f93262ad2e375d63b526af37aa3ae48", "patch": "@@ -40,7 +40,7 @@ use crate::{\n     db::HirDatabase, fold_tys, fold_tys_and_consts, infer::coerce::CoerceMany,\n     lower::ImplTraitLoweringMode, static_lifetime, to_assoc_type_id, AliasEq, AliasTy, Const,\n     DomainGoal, GenericArg, Goal, ImplTraitId, InEnvironment, Interner, ProjectionTy, RpitId,\n-    Substitution, TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -442,7 +442,6 @@ pub(crate) struct InferenceContext<'a> {\n     pub(crate) body: &'a Body,\n     pub(crate) resolver: Resolver,\n     table: unify::InferenceTable<'a>,\n-    trait_env: Arc<TraitEnvironment>,\n     /// The traits in scope, disregarding block modules. This is used for caching purposes.\n     traits_in_scope: FxHashSet<TraitId>,\n     pub(crate) result: InferenceResult,\n@@ -516,8 +515,7 @@ impl<'a> InferenceContext<'a> {\n         let trait_env = db.trait_environment_for_body(owner);\n         InferenceContext {\n             result: InferenceResult::default(),\n-            table: unify::InferenceTable::new(db, trait_env.clone()),\n-            trait_env,\n+            table: unify::InferenceTable::new(db, trait_env),\n             return_ty: TyKind::Error.intern(Interner), // set in collect_* calls\n             resume_yield_tys: None,\n             return_coercion: None,"}, {"sha": "6bf9f421fc90b4d385d92c023d8fa5591d126db5", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=f73510560f93262ad2e375d63b526af37aa3ae48", "patch": "@@ -636,7 +636,7 @@ impl<'a> InferenceTable<'a> {\n         // Need to find out in what cases this is necessary\n         let solution = self\n             .db\n-            .trait_solve(krate, canonicalized.value.clone().cast(Interner))\n+            .trait_solve(krate, self.trait_env.block, canonicalized.value.clone().cast(Interner))\n             .ok_or(TypeError)?;\n \n         match solution {"}, {"sha": "ea44fa1857a02c78ea1a8cd414f1c20c4145b5e6", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=f73510560f93262ad2e375d63b526af37aa3ae48", "patch": "@@ -3,6 +3,7 @@\n use std::{\n     iter::{repeat, repeat_with},\n     mem,\n+    sync::Arc,\n };\n \n use chalk_ir::{\n@@ -15,7 +16,7 @@ use hir_def::{\n     generics::TypeOrConstParamData,\n     lang_item::LangItem,\n     path::{GenericArg, GenericArgs},\n-    ConstParamId, FieldId, ItemContainerId, Lookup,\n+    BlockId, ConstParamId, FieldId, ItemContainerId, Lookup,\n };\n use hir_expand::name::{name, Name};\n use stdx::always;\n@@ -147,19 +148,19 @@ impl<'a> InferenceContext<'a> {\n                 self.infer_top_pat(pat, &input_ty);\n                 self.result.standard_types.bool_.clone()\n             }\n-            Expr::Block { statements, tail, label, id: _ } => {\n-                self.infer_block(tgt_expr, statements, *tail, *label, expected)\n+            Expr::Block { statements, tail, label, id } => {\n+                self.infer_block(tgt_expr, *id, statements, *tail, *label, expected)\n             }\n-            Expr::Unsafe { id: _, statements, tail } => {\n-                self.infer_block(tgt_expr, statements, *tail, None, expected)\n+            Expr::Unsafe { id, statements, tail } => {\n+                self.infer_block(tgt_expr, *id, statements, *tail, None, expected)\n             }\n-            Expr::Const { id: _, statements, tail } => {\n+            Expr::Const { id, statements, tail } => {\n                 self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n-                    this.infer_block(tgt_expr, statements, *tail, None, expected)\n+                    this.infer_block(tgt_expr, *id, statements, *tail, None, expected)\n                 })\n                 .1\n             }\n-            Expr::Async { id: _, statements, tail } => {\n+            Expr::Async { id, statements, tail } => {\n                 let ret_ty = self.table.new_type_var();\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n@@ -170,6 +171,7 @@ impl<'a> InferenceContext<'a> {\n                     self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n                         this.infer_block(\n                             tgt_expr,\n+                            *id,\n                             statements,\n                             *tail,\n                             None,\n@@ -394,7 +396,7 @@ impl<'a> InferenceContext<'a> {\n                                 }\n                             }\n                             let trait_ = fn_x\n-                                .get_id(self.db, self.trait_env.krate)\n+                                .get_id(self.db, self.table.trait_env.krate)\n                                 .expect(\"We just used it\");\n                             let trait_data = self.db.trait_data(trait_);\n                             if let Some(func) = trait_data.method_by_name(&fn_x.method_name()) {\n@@ -787,7 +789,7 @@ impl<'a> InferenceContext<'a> {\n                     let canonicalized = self.canonicalize(base_ty.clone());\n                     let receiver_adjustments = method_resolution::resolve_indexing_op(\n                         self.db,\n-                        self.trait_env.clone(),\n+                        self.table.trait_env.clone(),\n                         canonicalized.value,\n                         index_trait,\n                     );\n@@ -1205,13 +1207,19 @@ impl<'a> InferenceContext<'a> {\n     fn infer_block(\n         &mut self,\n         expr: ExprId,\n+        block_id: Option<BlockId>,\n         statements: &[Statement],\n         tail: Option<ExprId>,\n         label: Option<LabelId>,\n         expected: &Expectation,\n     ) -> Ty {\n         let coerce_ty = expected.coercion_target_type(&mut self.table);\n         let g = self.resolver.update_to_inner_scope(self.db.upcast(), self.owner, expr);\n+        let prev_env = block_id.map(|block_id| {\n+            let prev_env = self.table.trait_env.clone();\n+            Arc::make_mut(&mut self.table.trait_env).block = Some(block_id);\n+            prev_env\n+        });\n \n         let (break_ty, ty) =\n             self.with_breakable_ctx(BreakableKind::Block, Some(coerce_ty.clone()), label, |this| {\n@@ -1300,6 +1308,9 @@ impl<'a> InferenceContext<'a> {\n                 }\n             });\n         self.resolver.reset_to_guard(g);\n+        if let Some(prev_env) = prev_env {\n+            self.table.trait_env = prev_env;\n+        }\n \n         break_ty.unwrap_or(ty)\n     }\n@@ -1398,7 +1409,7 @@ impl<'a> InferenceContext<'a> {\n                     method_resolution::lookup_method(\n                         self.db,\n                         &canonicalized_receiver.value,\n-                        self.trait_env.clone(),\n+                        self.table.trait_env.clone(),\n                         self.get_traits_in_scope().as_ref().left_or_else(|&it| it),\n                         VisibleFromModule::Filter(self.resolver.module()),\n                         name,\n@@ -1431,7 +1442,7 @@ impl<'a> InferenceContext<'a> {\n         let resolved = method_resolution::lookup_method(\n             self.db,\n             &canonicalized_receiver.value,\n-            self.trait_env.clone(),\n+            self.table.trait_env.clone(),\n             self.get_traits_in_scope().as_ref().left_or_else(|&it| it),\n             VisibleFromModule::Filter(self.resolver.module()),\n             method_name,"}, {"sha": "f0e0714e1db203a0e99cced99aa92cefd2126076", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=f73510560f93262ad2e375d63b526af37aa3ae48", "patch": "@@ -462,7 +462,8 @@ impl<'a> InferenceTable<'a> {\n     pub(crate) fn try_obligation(&mut self, goal: Goal) -> Option<Solution> {\n         let in_env = InEnvironment::new(&self.trait_env.env, goal);\n         let canonicalized = self.canonicalize(in_env);\n-        let solution = self.db.trait_solve(self.trait_env.krate, canonicalized.value);\n+        let solution =\n+            self.db.trait_solve(self.trait_env.krate, self.trait_env.block, canonicalized.value);\n         solution\n     }\n \n@@ -597,7 +598,11 @@ impl<'a> InferenceTable<'a> {\n         &mut self,\n         canonicalized: &Canonicalized<InEnvironment<Goal>>,\n     ) -> bool {\n-        let solution = self.db.trait_solve(self.trait_env.krate, canonicalized.value.clone());\n+        let solution = self.db.trait_solve(\n+            self.trait_env.krate,\n+            self.trait_env.block,\n+            canonicalized.value.clone(),\n+        );\n \n         match solution {\n             Some(Solution::Unique(canonical_subst)) => {\n@@ -684,7 +689,11 @@ impl<'a> InferenceTable<'a> {\n             environment: trait_env.clone(),\n         };\n         let canonical = self.canonicalize(obligation.clone());\n-        if self.db.trait_solve(krate, canonical.value.cast(Interner)).is_some() {\n+        if self\n+            .db\n+            .trait_solve(krate, self.trait_env.block, canonical.value.cast(Interner))\n+            .is_some()\n+        {\n             self.register_obligation(obligation.goal);\n             let return_ty = self.normalize_projection_ty(projection);\n             for fn_x in [FnTrait::Fn, FnTrait::FnMut, FnTrait::FnOnce] {\n@@ -695,7 +704,11 @@ impl<'a> InferenceTable<'a> {\n                     environment: trait_env.clone(),\n                 };\n                 let canonical = self.canonicalize(obligation.clone());\n-                if self.db.trait_solve(krate, canonical.value.cast(Interner)).is_some() {\n+                if self\n+                    .db\n+                    .trait_solve(krate, self.trait_env.block, canonical.value.cast(Interner))\n+                    .is_some()\n+                {\n                     return Some((fn_x, arg_tys, return_ty));\n                 }\n             }"}, {"sha": "54bbda2ba007086a8d7d0266fec25758dfa167f3", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=f73510560f93262ad2e375d63b526af37aa3ae48", "patch": "@@ -1,6 +1,5 @@\n //! The type system. We currently use this to infer types for completion, hover\n //! information and various assists.\n-\n #![warn(rust_2018_idioms, unused_lifetimes, semicolon_in_expressions_from_macros)]\n \n #[allow(unused)]"}, {"sha": "797e9ad0e954f5176109f1c8c1284e45859f043b", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=f73510560f93262ad2e375d63b526af37aa3ae48", "patch": "@@ -1507,7 +1507,7 @@ pub(crate) fn trait_environment_query(\n \n     let env = chalk_ir::Environment::new(Interner).add_clauses(Interner, clauses);\n \n-    Arc::new(TraitEnvironment { krate, traits_from_clauses: traits_in_scope, env })\n+    Arc::new(TraitEnvironment { krate, block: None, traits_from_clauses: traits_in_scope, env })\n }\n \n /// Resolve the where clause(s) of an item with generics."}, {"sha": "94c0d3c0c19c7a550b25e5a9f172f3dd6357422a", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=f73510560f93262ad2e375d63b526af37aa3ae48", "patch": "@@ -271,6 +271,7 @@ pub struct InherentImpls {\n \n impl InherentImpls {\n     pub(crate) fn inherent_impls_in_crate_query(db: &dyn HirDatabase, krate: CrateId) -> Arc<Self> {\n+        let _p = profile::span(\"inherent_impls_in_crate_query\").detail(|| format!(\"{krate:?}\"));\n         let mut impls = Self { map: FxHashMap::default(), invalid_impls: Vec::default() };\n \n         let crate_def_map = db.crate_def_map(krate);\n@@ -284,13 +285,14 @@ impl InherentImpls {\n         db: &dyn HirDatabase,\n         block: BlockId,\n     ) -> Option<Arc<Self>> {\n+        let _p = profile::span(\"inherent_impls_in_block_query\");\n         let mut impls = Self { map: FxHashMap::default(), invalid_impls: Vec::default() };\n-        if let Some(block_def_map) = db.block_def_map(block) {\n-            impls.collect_def_map(db, &block_def_map);\n-            impls.shrink_to_fit();\n-            return Some(Arc::new(impls));\n-        }\n-        None\n+\n+        let block_def_map = db.block_def_map(block)?;\n+        impls.collect_def_map(db, &block_def_map);\n+        impls.shrink_to_fit();\n+\n+        Some(Arc::new(impls))\n     }\n \n     fn shrink_to_fit(&mut self) {\n@@ -1140,7 +1142,7 @@ fn iterate_trait_method_candidates(\n             };\n             if !known_implemented {\n                 let goal = generic_implements_goal(db, env.clone(), t, &canonical_self_ty);\n-                if db.trait_solve(env.krate, goal.cast(Interner)).is_none() {\n+                if db.trait_solve(env.krate, env.block, goal.cast(Interner)).is_none() {\n                     continue 'traits;\n                 }\n             }\n@@ -1317,7 +1319,7 @@ pub fn resolve_indexing_op(\n     let deref_chain = autoderef_method_receiver(&mut table, ty);\n     for (ty, adj) in deref_chain {\n         let goal = generic_implements_goal(db, env.clone(), index_trait, &ty);\n-        if db.trait_solve(env.krate, goal.cast(Interner)).is_some() {\n+        if db.trait_solve(env.krate, env.block, goal.cast(Interner)).is_some() {\n             return Some(adj);\n         }\n     }\n@@ -1342,14 +1344,12 @@ fn is_valid_candidate(\n ) -> IsValidCandidate {\n     let db = table.db;\n     match item {\n-        AssocItemId::FunctionId(m) => {\n-            is_valid_fn_candidate(table, m, name, receiver_ty, self_ty, visible_from_module)\n+        AssocItemId::FunctionId(f) => {\n+            is_valid_fn_candidate(table, f, name, receiver_ty, self_ty, visible_from_module)\n         }\n         AssocItemId::ConstId(c) => {\n-            let data = db.const_data(c);\n             check_that!(receiver_ty.is_none());\n-\n-            check_that!(name.map_or(true, |n| data.name.as_ref() == Some(n)));\n+            check_that!(name.map_or(true, |n| db.const_data(c).name.as_ref() == Some(n)));\n \n             if let Some(from_module) = visible_from_module {\n                 if !db.const_visibility(c).is_visible_from(db.upcast(), from_module) {\n@@ -1473,7 +1473,7 @@ pub fn implements_trait(\n     trait_: TraitId,\n ) -> bool {\n     let goal = generic_implements_goal(db, env.clone(), trait_, ty);\n-    let solution = db.trait_solve(env.krate, goal.cast(Interner));\n+    let solution = db.trait_solve(env.krate, env.block, goal.cast(Interner));\n \n     solution.is_some()\n }\n@@ -1485,7 +1485,7 @@ pub fn implements_trait_unique(\n     trait_: TraitId,\n ) -> bool {\n     let goal = generic_implements_goal(db, env.clone(), trait_, ty);\n-    let solution = db.trait_solve(env.krate, goal.cast(Interner));\n+    let solution = db.trait_solve(env.krate, env.block, goal.cast(Interner));\n \n     matches!(solution, Some(crate::Solution::Unique(_)))\n }"}, {"sha": "e9c26bf4734483f69e075387566985320201625f", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=f73510560f93262ad2e375d63b526af37aa3ae48", "patch": "@@ -3717,7 +3717,6 @@ async fn get_accounts() -> Result<u32, ()> {\n \n #[test]\n fn local_impl_1() {\n-    check!(block_local_impls);\n     check_types(\n         r#\"\n trait Trait<T> {\n@@ -3739,7 +3738,6 @@ fn test() {\n \n #[test]\n fn local_impl_2() {\n-    check!(block_local_impls);\n     check_types(\n         r#\"\n struct S;\n@@ -3761,7 +3759,6 @@ fn test() {\n \n #[test]\n fn local_impl_3() {\n-    check!(block_local_impls);\n     check_types(\n         r#\"\n trait Trait<T> {\n@@ -3785,6 +3782,33 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn foreign_trait_with_local_trait_impl() {\n+    check!(block_local_impls);\n+    check(\n+        r#\"\n+mod module {\n+    pub trait T {\n+        const C: usize;\n+        fn f(&self);\n+    }\n+}\n+\n+fn f() {\n+    use module::T;\n+    impl T for usize {\n+        const C: usize = 0;\n+        fn f(&self) {}\n+    }\n+    0usize.f();\n+  //^^^^^^^^^^ type: ()\n+    usize::C;\n+  //^^^^^^^^type: usize\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn associated_type_sized_bounds() {\n     check_infer("}, {"sha": "deb6ce56773d38d26b6d8182339bb28cca004eae", "filename": "crates/hir-ty/src/traits.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=f73510560f93262ad2e375d63b526af37aa3ae48", "patch": "@@ -9,7 +9,7 @@ use chalk_solve::{logging_db::LoggingRustIrDatabase, Solver};\n use base_db::CrateId;\n use hir_def::{\n     lang_item::{LangItem, LangItemTarget},\n-    TraitId,\n+    BlockId, TraitId,\n };\n use hir_expand::name::{name, Name};\n use stdx::panic_context;\n@@ -27,6 +27,7 @@ const CHALK_SOLVER_FUEL: i32 = 1000;\n pub(crate) struct ChalkContext<'a> {\n     pub(crate) db: &'a dyn HirDatabase,\n     pub(crate) krate: CrateId,\n+    pub(crate) block: Option<BlockId>,\n }\n \n fn create_chalk_solver() -> chalk_recursive::RecursiveSolver<Interner> {\n@@ -44,6 +45,7 @@ fn create_chalk_solver() -> chalk_recursive::RecursiveSolver<Interner> {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TraitEnvironment {\n     pub krate: CrateId,\n+    pub block: Option<BlockId>,\n     // FIXME make this a BTreeMap\n     pub(crate) traits_from_clauses: Vec<(Ty, TraitId)>,\n     pub env: chalk_ir::Environment<Interner>,\n@@ -53,6 +55,7 @@ impl TraitEnvironment {\n     pub fn empty(krate: CrateId) -> Self {\n         TraitEnvironment {\n             krate,\n+            block: None,\n             traits_from_clauses: Vec::new(),\n             env: chalk_ir::Environment::new(Interner),\n         }\n@@ -79,6 +82,7 @@ pub(crate) fn normalize_projection_query(\n pub(crate) fn trait_solve_query(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n+    block: Option<BlockId>,\n     goal: Canonical<InEnvironment<Goal>>,\n ) -> Option<Solution> {\n     let _p = profile::span(\"trait_solve_query\").detail(|| match &goal.value.goal.data(Interner) {\n@@ -104,15 +108,16 @@ pub(crate) fn trait_solve_query(\n     // We currently don't deal with universes (I think / hope they're not yet\n     // relevant for our use cases?)\n     let u_canonical = chalk_ir::UCanonical { canonical: goal, universes: 1 };\n-    solve(db, krate, &u_canonical)\n+    solve(db, krate, block, &u_canonical)\n }\n \n fn solve(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n+    block: Option<BlockId>,\n     goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal<Interner>>>,\n ) -> Option<chalk_solve::Solution<Interner>> {\n-    let context = ChalkContext { db, krate };\n+    let context = ChalkContext { db, krate, block };\n     tracing::debug!(\"solve goal: {:?}\", goal);\n     let mut solver = create_chalk_solver();\n "}, {"sha": "ea851a11a8556f759e8c4cffc889782ae9bbeb4a", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73510560f93262ad2e375d63b526af37aa3ae48/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=f73510560f93262ad2e375d63b526af37aa3ae48", "patch": "@@ -3331,7 +3331,7 @@ impl Type {\n             binders: CanonicalVarKinds::empty(Interner),\n         };\n \n-        db.trait_solve(self.env.krate, goal).is_some()\n+        db.trait_solve(self.env.krate, self.env.block, goal).is_some()\n     }\n \n     pub fn normalize_trait_assoc_type("}]}