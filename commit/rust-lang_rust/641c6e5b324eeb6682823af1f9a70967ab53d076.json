{"sha": "641c6e5b324eeb6682823af1f9a70967ab53d076", "node_id": "C_kwDOAAsO6NoAKDY0MWM2ZTViMzI0ZWViNjY4MjgyM2FmMWY5YTcwOTY3YWI1M2QwNzY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-16T16:04:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-16T16:04:10Z"}, "message": "Merge #11726\n\n11726: internal: More ide_completion refactoring r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "03f8ce8d7276bb65a34ce3557e590c7439acd22d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03f8ce8d7276bb65a34ce3557e590c7439acd22d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/641c6e5b324eeb6682823af1f9a70967ab53d076", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiMgp6CRBK7hj4Ov3rIwAA5xwIAC7b0D9ssB5DGTXBoSvzFFZN\nrfvXa6DWVL021fESQK4TWhSbaQLgdYvqaAopVMGWosVhExi9rFhcNOt8avq/UH6w\nnJr3Pi+2gMuSIwtrDEMNxsxzkpBAM77jlmi5XUL/LYOIZ0B4CxD8v5lWiI9Mhqff\ngzlytklnwO0o3tRn/oZuu6HwgER1MXckIM9mDDX19H+tnFg4AL8cmWln9Y5Jp2d8\nbcvDn5UdAYRV9Pzcfhc4tgVZjGB7EkiyuWMXOZGukAwxxEFj7eSbbCxntJaiaxj6\nd617y5GfgXYfkKuo99Qj1nv9tP/kOI466m+H/WU62dFif6MPOcWZb3NkxDQDKwk=\n=EIYE\n-----END PGP SIGNATURE-----\n", "payload": "tree 03f8ce8d7276bb65a34ce3557e590c7439acd22d\nparent c1cf2ef6f434975799d051d8d1ee71c975ac1df3\nparent a40a847d77833e01bf8227f06c149f2e22a27935\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1647446650 +0000\ncommitter GitHub <noreply@github.com> 1647446650 +0000\n\nMerge #11726\n\n11726: internal: More ide_completion refactoring r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/641c6e5b324eeb6682823af1f9a70967ab53d076", "html_url": "https://github.com/rust-lang/rust/commit/641c6e5b324eeb6682823af1f9a70967ab53d076", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/641c6e5b324eeb6682823af1f9a70967ab53d076/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1cf2ef6f434975799d051d8d1ee71c975ac1df3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1cf2ef6f434975799d051d8d1ee71c975ac1df3", "html_url": "https://github.com/rust-lang/rust/commit/c1cf2ef6f434975799d051d8d1ee71c975ac1df3"}, {"sha": "a40a847d77833e01bf8227f06c149f2e22a27935", "url": "https://api.github.com/repos/rust-lang/rust/commits/a40a847d77833e01bf8227f06c149f2e22a27935", "html_url": "https://github.com/rust-lang/rust/commit/a40a847d77833e01bf8227f06c149f2e22a27935"}], "stats": {"total": 874, "additions": 498, "deletions": 376}, "files": [{"sha": "428b8d1109f54a6cc6af09d113c013105f6ea521", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=641c6e5b324eeb6682823af1f9a70967ab53d076", "patch": "@@ -69,24 +69,17 @@ pub(crate) fn inlay_hints(\n \n     let mut hints = Vec::new();\n \n-    if let Some(range_limit) = range_limit {\n-        let range_limit = range_limit.range;\n-        match file.covering_element(range_limit) {\n+    let get_hints = |node| get_hints(&mut hints, &sema, config, node);\n+    match range_limit {\n+        Some(FileRange { range, .. }) => match file.covering_element(range) {\n             NodeOrToken::Token(_) => return hints,\n-            NodeOrToken::Node(n) => {\n-                for node in n\n-                    .descendants()\n-                    .filter(|descendant| range_limit.contains_range(descendant.text_range()))\n-                {\n-                    get_hints(&mut hints, &sema, config, node);\n-                }\n-            }\n-        }\n-    } else {\n-        for node in file.descendants() {\n-            get_hints(&mut hints, &sema, config, node);\n-        }\n-    }\n+            NodeOrToken::Node(n) => n\n+                .descendants()\n+                .filter(|descendant| range.contains_range(descendant.text_range()))\n+                .for_each(get_hints),\n+        },\n+        None => file.descendants().for_each(get_hints),\n+    };\n \n     hints\n }"}, {"sha": "867e6bcf48d5d695b78bb2dee058fa44858eba58", "filename": "crates/ide_completion/src/completions.rs", "status": "modified", "additions": 69, "deletions": 21, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions.rs?ref=641c6e5b324eeb6682823af1f9a70967ab53d076", "patch": "@@ -29,11 +29,11 @@ use crate::{\n     item::Builder,\n     render::{\n         const_::render_const,\n-        enum_variant::render_variant,\n         function::{render_fn, render_method},\n+        literal::{render_struct_literal, render_variant_lit},\n+        macro_::render_macro,\n         pattern::{render_struct_pat, render_variant_pat},\n-        render_field, render_resolution, render_tuple_field,\n-        struct_literal::render_struct_literal,\n+        render_field, render_resolution, render_resolution_simple, render_tuple_field,\n         type_alias::{render_type_alias, render_type_alias_with_eq},\n         union_literal::render_union_literal,\n         RenderContext,\n@@ -124,7 +124,37 @@ impl Completions {\n             cov_mark::hit!(qualified_path_doc_hidden);\n             return;\n         }\n-        self.add(render_resolution(RenderContext::new(ctx, false), local_name, resolution));\n+        self.add(render_resolution(RenderContext::new(ctx), local_name, resolution));\n+    }\n+\n+    pub(crate) fn add_resolution_simple(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        local_name: hir::Name,\n+        resolution: hir::ScopeDef,\n+    ) {\n+        if ctx.is_scope_def_hidden(resolution) {\n+            return;\n+        }\n+        self.add(render_resolution_simple(RenderContext::new(ctx), local_name, resolution));\n+    }\n+\n+    pub(crate) fn add_macro(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        mac: hir::Macro,\n+        local_name: hir::Name,\n+    ) {\n+        let is_private_editable = match ctx.is_visible(&mac) {\n+            Visible::Yes => false,\n+            Visible::Editable => true,\n+            Visible::No => return,\n+        };\n+        self.add(render_macro(\n+            RenderContext::new(ctx).private_editable(is_private_editable),\n+            local_name,\n+            mac,\n+        ));\n     }\n \n     pub(crate) fn add_function(\n@@ -138,7 +168,11 @@ impl Completions {\n             Visible::Editable => true,\n             Visible::No => return,\n         };\n-        self.add(render_fn(RenderContext::new(ctx, is_private_editable), None, local_name, func));\n+        self.add(render_fn(\n+            RenderContext::new(ctx).private_editable(is_private_editable),\n+            local_name,\n+            func,\n+        ));\n     }\n \n     pub(crate) fn add_method(\n@@ -154,8 +188,7 @@ impl Completions {\n             Visible::No => return,\n         };\n         self.add(render_method(\n-            RenderContext::new(ctx, is_private_editable),\n-            None,\n+            RenderContext::new(ctx).private_editable(is_private_editable),\n             receiver,\n             local_name,\n             func,\n@@ -168,7 +201,10 @@ impl Completions {\n             Visible::Editable => true,\n             Visible::No => return,\n         };\n-        self.add_opt(render_const(RenderContext::new(ctx, is_private_editable), konst));\n+        self.add_opt(render_const(\n+            RenderContext::new(ctx).private_editable(is_private_editable),\n+            konst,\n+        ));\n     }\n \n     pub(crate) fn add_type_alias(&mut self, ctx: &CompletionContext, type_alias: hir::TypeAlias) {\n@@ -177,15 +213,18 @@ impl Completions {\n             Visible::Editable => true,\n             Visible::No => return,\n         };\n-        self.add_opt(render_type_alias(RenderContext::new(ctx, is_private_editable), type_alias));\n+        self.add_opt(render_type_alias(\n+            RenderContext::new(ctx).private_editable(is_private_editable),\n+            type_alias,\n+        ));\n     }\n \n     pub(crate) fn add_type_alias_with_eq(\n         &mut self,\n         ctx: &CompletionContext,\n         type_alias: hir::TypeAlias,\n     ) {\n-        self.add_opt(render_type_alias_with_eq(RenderContext::new(ctx, false), type_alias));\n+        self.add_opt(render_type_alias_with_eq(RenderContext::new(ctx), type_alias));\n     }\n \n     pub(crate) fn add_qualified_enum_variant(\n@@ -194,8 +233,7 @@ impl Completions {\n         variant: hir::Variant,\n         path: hir::ModPath,\n     ) {\n-        let item = render_variant(RenderContext::new(ctx, false), None, None, variant, Some(path));\n-        self.add(item);\n+        self.add_opt(render_variant_lit(RenderContext::new(ctx), None, variant, Some(path)));\n     }\n \n     pub(crate) fn add_enum_variant(\n@@ -204,8 +242,7 @@ impl Completions {\n         variant: hir::Variant,\n         local_name: Option<hir::Name>,\n     ) {\n-        let item = render_variant(RenderContext::new(ctx, false), None, local_name, variant, None);\n-        self.add(item);\n+        self.add_opt(render_variant_lit(RenderContext::new(ctx), local_name, variant, None));\n     }\n \n     pub(crate) fn add_field(\n@@ -220,7 +257,12 @@ impl Completions {\n             Visible::Editable => true,\n             Visible::No => return,\n         };\n-        let item = render_field(RenderContext::new(ctx, is_private_editable), receiver, field, ty);\n+        let item = render_field(\n+            RenderContext::new(ctx).private_editable(is_private_editable),\n+            receiver,\n+            field,\n+            ty,\n+        );\n         self.add(item);\n     }\n \n@@ -231,7 +273,7 @@ impl Completions {\n         path: Option<hir::ModPath>,\n         local_name: Option<hir::Name>,\n     ) {\n-        let item = render_struct_literal(RenderContext::new(ctx, false), strukt, path, local_name);\n+        let item = render_struct_literal(RenderContext::new(ctx), strukt, path, local_name);\n         self.add_opt(item);\n     }\n \n@@ -242,7 +284,7 @@ impl Completions {\n         path: Option<hir::ModPath>,\n         local_name: Option<hir::Name>,\n     ) {\n-        let item = render_union_literal(RenderContext::new(ctx, false), un, path, local_name);\n+        let item = render_union_literal(RenderContext::new(ctx), un, path, local_name);\n         self.add_opt(item);\n     }\n \n@@ -253,7 +295,7 @@ impl Completions {\n         field: usize,\n         ty: &hir::Type,\n     ) {\n-        let item = render_tuple_field(RenderContext::new(ctx, false), receiver, field, ty);\n+        let item = render_tuple_field(RenderContext::new(ctx), receiver, field, ty);\n         self.add(item);\n     }\n \n@@ -272,7 +314,12 @@ impl Completions {\n         variant: hir::Variant,\n         local_name: Option<hir::Name>,\n     ) {\n-        self.add_opt(render_variant_pat(RenderContext::new(ctx, false), variant, local_name, None));\n+        self.add_opt(render_variant_pat(\n+            RenderContext::new(ctx),\n+            variant,\n+            local_name.clone(),\n+            None,\n+        ));\n     }\n \n     pub(crate) fn add_qualified_variant_pat(\n@@ -281,7 +328,8 @@ impl Completions {\n         variant: hir::Variant,\n         path: hir::ModPath,\n     ) {\n-        self.add_opt(render_variant_pat(RenderContext::new(ctx, false), variant, None, Some(path)));\n+        let path = Some(&path);\n+        self.add_opt(render_variant_pat(RenderContext::new(ctx), variant, None, path));\n     }\n \n     pub(crate) fn add_struct_pat(\n@@ -290,7 +338,7 @@ impl Completions {\n         strukt: hir::Struct,\n         local_name: Option<hir::Name>,\n     ) {\n-        self.add_opt(render_struct_pat(RenderContext::new(ctx, false), strukt, local_name));\n+        self.add_opt(render_struct_pat(RenderContext::new(ctx), strukt, local_name));\n     }\n }\n "}, {"sha": "6c8878a7bb0794e002e27899e4463e0c17351645", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=641c6e5b324eeb6682823af1f9a70967ab53d076", "patch": "@@ -198,7 +198,7 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n             })\n             .filter_map(|import| {\n                 render_resolution_with_import(\n-                    RenderContext::new(ctx, false),\n+                    RenderContext::new(ctx),\n                     ImportEdit { import, scope: import_scope.clone() },\n                 )\n             }),"}, {"sha": "6c17da07d6f57ebab53ada8d48bd1a4ab858d2d6", "filename": "crates/ide_completion/src/completions/pattern.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=641c6e5b324eeb6682823af1f9a70967ab53d076", "patch": "@@ -54,16 +54,15 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n     {\n         if refutable || single_variant_enum(e) {\n             super::enum_variants_with_paths(acc, ctx, e, |acc, ctx, variant, path| {\n-                acc.add_qualified_variant_pat(ctx, variant, path.clone());\n-                acc.add_qualified_enum_variant(ctx, variant, path);\n+                acc.add_qualified_variant_pat(ctx, variant, path);\n             });\n         }\n     }\n \n     // FIXME: ideally, we should look at the type we are matching against and\n     // suggest variants + auto-imports\n     ctx.process_all_names(&mut |name, res| {\n-        let add_resolution = match res {\n+        let add_simple_path = match res {\n             hir::ScopeDef::ModuleDef(def) => match def {\n                 hir::ModuleDef::Adt(hir::Adt::Struct(strukt)) => {\n                     acc.add_struct_pat(ctx, strukt, Some(name.clone()));\n@@ -76,22 +75,31 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n                     true\n                 }\n                 hir::ModuleDef::Adt(hir::Adt::Enum(e)) => refutable || single_variant_enum(e),\n-                hir::ModuleDef::Const(..) | hir::ModuleDef::Module(..) => refutable,\n-                hir::ModuleDef::Macro(mac) => mac.is_fn_like(ctx.db),\n+                hir::ModuleDef::Const(..) => refutable,\n+                hir::ModuleDef::Module(..) => true,\n+                hir::ModuleDef::Macro(mac) if mac.is_fn_like(ctx.db) => {\n+                    return acc.add_macro(ctx, mac, name)\n+                }\n                 _ => false,\n             },\n             hir::ScopeDef::ImplSelfType(impl_) => match impl_.self_ty(ctx.db).as_adt() {\n                 Some(hir::Adt::Struct(strukt)) => {\n                     acc.add_struct_pat(ctx, strukt, Some(name.clone()));\n                     true\n                 }\n-                Some(hir::Adt::Enum(_)) => refutable,\n-                _ => true,\n+                Some(hir::Adt::Enum(e)) => refutable || single_variant_enum(e),\n+                Some(hir::Adt::Union(_)) => true,\n+                _ => false,\n             },\n-            _ => false,\n+            ScopeDef::GenericParam(hir::GenericParam::ConstParam(_)) => true,\n+            ScopeDef::GenericParam(_)\n+            | ScopeDef::AdtSelfType(_)\n+            | ScopeDef::Local(_)\n+            | ScopeDef::Label(_)\n+            | ScopeDef::Unknown => false,\n         };\n-        if add_resolution {\n-            acc.add_resolution(ctx, name, res);\n+        if add_simple_path {\n+            acc.add_resolution_simple(ctx, name, res);\n         }\n     });\n }"}, {"sha": "5509ec922f3f1a9fd545cbb91cc544955a476693", "filename": "crates/ide_completion/src/completions/record.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=641c6e5b324eeb6682823af1f9a70967ab53d076", "patch": "@@ -84,13 +84,16 @@ pub(crate) fn complete_record_literal(\n     match ctx.expected_type.as_ref()?.as_adt()? {\n         hir::Adt::Struct(strukt) if ctx.path_qual().is_none() => {\n             let module = if let Some(module) = ctx.module { module } else { strukt.module(ctx.db) };\n-            let path = module.find_use_path(ctx.db, hir::ModuleDef::from(strukt));\n+            let path = module\n+                .find_use_path(ctx.db, hir::ModuleDef::from(strukt))\n+                .filter(|it| it.len() > 1);\n \n             acc.add_struct_literal(ctx, strukt, path, None);\n         }\n         hir::Adt::Union(un) if ctx.path_qual().is_none() => {\n             let module = if let Some(module) = ctx.module { module } else { un.module(ctx.db) };\n-            let path = module.find_use_path(ctx.db, hir::ModuleDef::from(un));\n+            let path =\n+                module.find_use_path(ctx.db, hir::ModuleDef::from(un)).filter(|it| it.len() > 1);\n \n             acc.add_union_literal(ctx, un, path, None);\n         }\n@@ -132,7 +135,7 @@ fn baz() {\n     #[test]\n     fn literal_struct_completion_from_sub_modules() {\n         check_edit(\n-            \"Struct {\u2026}\",\n+            \"submod::Struct {\u2026}\",\n             r#\"\n mod submod {\n     pub struct Struct {"}, {"sha": "ed59eb6bd3eb42f6e4e16157b65a6eec5984ee92", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=641c6e5b324eeb6682823af1f9a70967ab53d076", "patch": "@@ -58,7 +58,7 @@ pub(super) enum PathKind {\n \n #[derive(Debug)]\n pub(crate) struct PathCompletionCtx {\n-    /// If this is a call with () already there\n+    /// If this is a call with () already there (or {} in case of record patterns)\n     pub(super) has_call_parens: bool,\n     /// Whether this path stars with a `::`.\n     pub(super) is_absolute_path: bool,\n@@ -890,6 +890,7 @@ impl<'a> CompletionContext<'a> {\n                         Some(PathKind::Pat)\n                     },\n                     ast::RecordPat(it) => {\n+                        path_ctx.has_call_parens = true;\n                         pat_ctx = Some(pattern_context_for(original_file, it.into()));\n                         Some(PathKind::Pat)\n                     },"}, {"sha": "10211cd9710a395c863f48cb4582b2edf11f36ea", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 58, "deletions": 30, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=641c6e5b324eeb6682823af1f9a70967ab53d076", "patch": "@@ -3,13 +3,12 @@\n \n pub(crate) mod macro_;\n pub(crate) mod function;\n-pub(crate) mod enum_variant;\n pub(crate) mod const_;\n pub(crate) mod pattern;\n pub(crate) mod type_alias;\n-pub(crate) mod struct_literal;\n-pub(crate) mod compound;\n+pub(crate) mod variant;\n pub(crate) mod union_literal;\n+pub(crate) mod literal;\n \n use hir::{AsAssocItem, HasAttrs, HirDisplay, ScopeDef};\n use ide_db::{helpers::item_name, RootDatabase, SnippetCap, SymbolKind};\n@@ -18,22 +17,30 @@ use syntax::{SmolStr, SyntaxKind, TextRange};\n use crate::{\n     context::{PathCompletionCtx, PathKind},\n     item::{CompletionRelevanceTypeMatch, ImportEdit},\n-    render::{enum_variant::render_variant, function::render_fn, macro_::render_macro},\n+    render::{function::render_fn, literal::render_variant_lit, macro_::render_macro},\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance,\n };\n /// Interface for data and methods required for items rendering.\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub(crate) struct RenderContext<'a> {\n     completion: &'a CompletionContext<'a>,\n     is_private_editable: bool,\n+    import_to_add: Option<ImportEdit>,\n }\n \n impl<'a> RenderContext<'a> {\n-    pub(crate) fn new(\n-        completion: &'a CompletionContext<'a>,\n-        is_private_editable: bool,\n-    ) -> RenderContext<'a> {\n-        RenderContext { completion, is_private_editable }\n+    pub(crate) fn new(completion: &'a CompletionContext<'a>) -> RenderContext<'a> {\n+        RenderContext { completion, is_private_editable: false, import_to_add: None }\n+    }\n+\n+    pub(crate) fn private_editable(mut self, private_editable: bool) -> Self {\n+        self.is_private_editable = private_editable;\n+        self\n+    }\n+\n+    pub(crate) fn import_to_add(mut self, import_to_add: Option<ImportEdit>) -> Self {\n+        self.import_to_add = import_to_add;\n+        self\n     }\n \n     fn snippet_cap(&self) -> Option<SnippetCap> {\n@@ -139,6 +146,14 @@ pub(crate) fn render_resolution(\n     render_resolution_(ctx, local_name, None, resolution)\n }\n \n+pub(crate) fn render_resolution_simple(\n+    ctx: RenderContext<'_>,\n+    local_name: hir::Name,\n+    resolution: ScopeDef,\n+) -> CompletionItem {\n+    render_resolution_simple_(ctx, local_name, None, resolution)\n+}\n+\n pub(crate) fn render_resolution_with_import(\n     ctx: RenderContext<'_>,\n     import_edit: ImportEdit,\n@@ -162,31 +177,42 @@ fn render_resolution_(\n     let _p = profile::span(\"render_resolution\");\n     use hir::ModuleDef::*;\n \n-    let db = ctx.db();\n-\n-    let kind = match resolution {\n+    match resolution {\n+        ScopeDef::ModuleDef(Macro(mac)) => {\n+            let ctx = ctx.import_to_add(import_to_add);\n+            return render_macro(ctx, local_name, mac);\n+        }\n         ScopeDef::ModuleDef(Function(func)) => {\n-            return render_fn(ctx, import_to_add, Some(local_name), func);\n+            let ctx = ctx.import_to_add(import_to_add);\n+            return render_fn(ctx, Some(local_name), func);\n         }\n         ScopeDef::ModuleDef(Variant(var)) if ctx.completion.pattern_ctx.is_none() => {\n-            return render_variant(ctx, import_to_add, Some(local_name), var, None);\n-        }\n-        ScopeDef::ModuleDef(Macro(mac)) => {\n-            return render_macro(ctx, import_to_add, local_name, mac)\n-        }\n-        ScopeDef::Unknown => {\n-            let mut item = CompletionItem::new(\n-                CompletionItemKind::UnresolvedReference,\n-                ctx.source_range(),\n-                local_name.to_smol_str(),\n-            );\n-            if let Some(import_to_add) = import_to_add {\n-                item.add_import(import_to_add);\n+            let ctx = ctx.clone().import_to_add(import_to_add.clone());\n+            if let Some(item) = render_variant_lit(ctx, Some(local_name.clone()), var, None) {\n+                return item;\n             }\n-            return item.build();\n         }\n+        _ => (),\n+    }\n+    render_resolution_simple_(ctx, local_name, import_to_add, resolution)\n+}\n+\n+fn render_resolution_simple_(\n+    ctx: RenderContext<'_>,\n+    local_name: hir::Name,\n+    import_to_add: Option<ImportEdit>,\n+    resolution: ScopeDef,\n+) -> CompletionItem {\n+    let _p = profile::span(\"render_resolution\");\n+    use hir::ModuleDef::*;\n \n+    let db = ctx.db();\n+    let ctx = ctx.import_to_add(import_to_add);\n+    let kind = match resolution {\n+        ScopeDef::Unknown => CompletionItemKind::UnresolvedReference,\n+        ScopeDef::ModuleDef(Function(_)) => CompletionItemKind::SymbolKind(SymbolKind::Function),\n         ScopeDef::ModuleDef(Variant(_)) => CompletionItemKind::SymbolKind(SymbolKind::Variant),\n+        ScopeDef::ModuleDef(Macro(_)) => CompletionItemKind::SymbolKind(SymbolKind::Macro),\n         ScopeDef::ModuleDef(Module(..)) => CompletionItemKind::SymbolKind(SymbolKind::Module),\n         ScopeDef::ModuleDef(Adt(adt)) => CompletionItemKind::SymbolKind(match adt {\n             hir::Adt::Struct(_) => SymbolKind::Struct,\n@@ -253,7 +279,7 @@ fn render_resolution_(\n     item.set_documentation(scope_def_docs(db, resolution))\n         .set_deprecated(scope_def_is_deprecated(&ctx, resolution));\n \n-    if let Some(import_to_add) = import_to_add {\n+    if let Some(import_to_add) = ctx.import_to_add {\n         item.add_import(import_to_add);\n     }\n     item.build()\n@@ -577,7 +603,7 @@ fn main() { let _: m::Spam = S$0 }\n                         kind: SymbolKind(\n                             Variant,\n                         ),\n-                        lookup: \"Spam::Bar\",\n+                        lookup: \"Spam::Bar(\u2026)\",\n                         detail: \"m::Spam::Bar(i32)\",\n                         relevance: CompletionRelevance {\n                             exact_name_match: false,\n@@ -1156,6 +1182,7 @@ fn main() {\n             \"#,\n             expect![[r#\"\n                 lc s [type+name+local]\n+                st S [type]\n                 st S []\n                 fn main() []\n                 fn foo(\u2026) []\n@@ -1172,6 +1199,7 @@ fn main() {\n             \"#,\n             expect![[r#\"\n                 lc ssss [type+local]\n+                st S [type]\n                 st S []\n                 fn main() []\n                 fn foo(\u2026) []"}, {"sha": "5b485005d3fae5ce337d6412dc0ea0b4a893e75e", "filename": "crates/ide_completion/src/render/enum_variant.rs", "status": "removed", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/c1cf2ef6f434975799d051d8d1ee71c975ac1df3/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cf2ef6f434975799d051d8d1ee71c975ac1df3/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs?ref=c1cf2ef6f434975799d051d8d1ee71c975ac1df3", "patch": "@@ -1,101 +0,0 @@\n-//! Renderer for `enum` variants.\n-\n-use hir::{HasAttrs, StructKind};\n-use ide_db::SymbolKind;\n-use syntax::SmolStr;\n-\n-use crate::{\n-    item::{CompletionItem, ImportEdit},\n-    render::{\n-        compound::{format_literal_label, render_record, render_tuple, RenderedCompound},\n-        compute_ref_match, compute_type_match, RenderContext,\n-    },\n-    CompletionRelevance,\n-};\n-\n-pub(crate) fn render_variant(\n-    ctx: RenderContext<'_>,\n-    import_to_add: Option<ImportEdit>,\n-    local_name: Option<hir::Name>,\n-    variant: hir::Variant,\n-    path: Option<hir::ModPath>,\n-) -> CompletionItem {\n-    let _p = profile::span(\"render_enum_variant\");\n-    render(ctx, local_name, variant, path, import_to_add)\n-}\n-\n-fn render(\n-    ctx @ RenderContext { completion, .. }: RenderContext<'_>,\n-    local_name: Option<hir::Name>,\n-    variant: hir::Variant,\n-    path: Option<hir::ModPath>,\n-    import_to_add: Option<ImportEdit>,\n-) -> CompletionItem {\n-    let db = completion.db;\n-    let name = local_name.unwrap_or_else(|| variant.name(db));\n-    let variant_kind = variant.kind(db);\n-\n-    let (qualified_name, short_qualified_name, qualified) = match path {\n-        Some(path) => {\n-            let short = hir::ModPath::from_segments(\n-                hir::PathKind::Plain,\n-                path.segments().iter().skip(path.segments().len().saturating_sub(2)).cloned(),\n-            );\n-            (path, short, true)\n-        }\n-        None => (name.clone().into(), name.into(), false),\n-    };\n-    let qualified_name = qualified_name.to_string();\n-    let short_qualified_name: SmolStr = short_qualified_name.to_string().into();\n-\n-    let mut rendered = match variant_kind {\n-        StructKind::Tuple => {\n-            render_tuple(db, ctx.snippet_cap(), &variant.fields(db), Some(&qualified_name))\n-        }\n-        StructKind::Record => {\n-            render_record(db, ctx.snippet_cap(), &variant.fields(db), Some(&qualified_name))\n-        }\n-        StructKind::Unit => {\n-            RenderedCompound { literal: qualified_name.clone(), detail: qualified_name.clone() }\n-        }\n-    };\n-\n-    if ctx.snippet_cap().is_some() {\n-        rendered.literal.push_str(\"$0\");\n-    }\n-\n-    let mut item = CompletionItem::new(\n-        SymbolKind::Variant,\n-        ctx.source_range(),\n-        format_literal_label(&qualified_name, variant_kind),\n-    );\n-\n-    item.set_documentation(variant.docs(db))\n-        .set_deprecated(ctx.is_deprecated(variant))\n-        .detail(rendered.detail);\n-\n-    match ctx.snippet_cap() {\n-        Some(snippet_cap) => item.insert_snippet(snippet_cap, rendered.literal),\n-        None => item.insert_text(rendered.literal),\n-    };\n-\n-    if let Some(import_to_add) = import_to_add {\n-        item.add_import(import_to_add);\n-    }\n-\n-    if qualified {\n-        item.lookup_by(short_qualified_name);\n-    }\n-\n-    let ty = variant.parent_enum(completion.db).ty(completion.db);\n-    item.set_relevance(CompletionRelevance {\n-        type_match: compute_type_match(completion, &ty),\n-        ..ctx.completion_relevance()\n-    });\n-\n-    if let Some(ref_match) = compute_ref_match(completion, &ty) {\n-        item.ref_match(ref_match);\n-    }\n-\n-    item.build()\n-}"}, {"sha": "7df13988ad69c1ae759e3b1a49d0df48ead1b78f", "filename": "crates/ide_completion/src/render/function.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs?ref=641c6e5b324eeb6682823af1f9a70967ab53d076", "patch": "@@ -8,7 +8,7 @@ use syntax::SmolStr;\n \n use crate::{\n     context::{CompletionContext, PathCompletionCtx, PathKind},\n-    item::{Builder, CompletionItem, CompletionItemKind, CompletionRelevance, ImportEdit},\n+    item::{Builder, CompletionItem, CompletionItemKind, CompletionRelevance},\n     patterns::ImmediateLocation,\n     render::{compute_exact_name_match, compute_ref_match, compute_type_match, RenderContext},\n };\n@@ -20,31 +20,28 @@ enum FuncKind {\n \n pub(crate) fn render_fn(\n     ctx: RenderContext<'_>,\n-    import_to_add: Option<ImportEdit>,\n     local_name: Option<hir::Name>,\n     func: hir::Function,\n ) -> CompletionItem {\n     let _p = profile::span(\"render_fn\");\n-    render(ctx, local_name, func, FuncKind::Function, import_to_add)\n+    render(ctx, local_name, func, FuncKind::Function)\n }\n \n pub(crate) fn render_method(\n     ctx: RenderContext<'_>,\n-    import_to_add: Option<ImportEdit>,\n     receiver: Option<hir::Name>,\n     local_name: Option<hir::Name>,\n     func: hir::Function,\n ) -> CompletionItem {\n     let _p = profile::span(\"render_method\");\n-    render(ctx, local_name, func, FuncKind::Method(receiver), import_to_add)\n+    render(ctx, local_name, func, FuncKind::Method(receiver))\n }\n \n fn render(\n     ctx @ RenderContext { completion, .. }: RenderContext<'_>,\n     local_name: Option<hir::Name>,\n     func: hir::Function,\n     func_kind: FuncKind,\n-    import_to_add: Option<ImportEdit>,\n ) -> CompletionItem {\n     let db = completion.db;\n \n@@ -98,17 +95,18 @@ fn render(\n         _ => (),\n     }\n \n-    if import_to_add.is_none() {\n-        if let Some(actm) = func.as_assoc_item(db) {\n-            if let Some(trt) = actm.containing_trait_or_trait_impl(db) {\n-                item.trait_name(trt.name(db).to_smol_str());\n+    match ctx.import_to_add {\n+        Some(import_to_add) => {\n+            item.add_import(import_to_add);\n+        }\n+        None => {\n+            if let Some(actm) = func.as_assoc_item(db) {\n+                if let Some(trt) = actm.containing_trait_or_trait_impl(db) {\n+                    item.trait_name(trt.name(db).to_smol_str());\n+                }\n             }\n         }\n     }\n-\n-    if let Some(import_to_add) = import_to_add {\n-        item.add_import(import_to_add);\n-    }\n     item.build()\n }\n \n@@ -192,7 +190,7 @@ fn should_add_parens(ctx: &CompletionContext) -> bool {\n         Some(PathCompletionCtx { kind: Some(PathKind::Expr), has_call_parens: true, .. }) => {\n             return false\n         }\n-        Some(PathCompletionCtx { kind: Some(PathKind::Use), .. }) => {\n+        Some(PathCompletionCtx { kind: Some(PathKind::Use | PathKind::Type), .. }) => {\n             cov_mark::hit!(no_parens_in_use_item);\n             return false;\n         }"}, {"sha": "d91e80f90c007e94f3e9f8af18ddbb5947d42fe8", "filename": "crates/ide_completion/src/render/literal.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Frender%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Frender%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fliteral.rs?ref=641c6e5b324eeb6682823af1f9a70967ab53d076", "patch": "@@ -0,0 +1,174 @@\n+//! Renderer for `enum` variants.\n+\n+use hir::{db::HirDatabase, Documentation, HasAttrs, StructKind};\n+use ide_db::SymbolKind;\n+\n+use crate::{\n+    context::{CompletionContext, PathCompletionCtx},\n+    item::CompletionItem,\n+    render::{\n+        compute_ref_match, compute_type_match,\n+        variant::{\n+            format_literal_label, render_record_lit, render_tuple_lit, visible_fields,\n+            RenderedLiteral,\n+        },\n+        RenderContext,\n+    },\n+    CompletionItemKind, CompletionRelevance,\n+};\n+\n+pub(crate) fn render_variant_lit(\n+    ctx: RenderContext<'_>,\n+    local_name: Option<hir::Name>,\n+    variant: hir::Variant,\n+    path: Option<hir::ModPath>,\n+) -> Option<CompletionItem> {\n+    let _p = profile::span(\"render_enum_variant\");\n+    let db = ctx.db();\n+\n+    let name = local_name.unwrap_or_else(|| variant.name(db));\n+    render(ctx, Variant::EnumVariant(variant), name, path)\n+}\n+\n+pub(crate) fn render_struct_literal(\n+    ctx: RenderContext<'_>,\n+    strukt: hir::Struct,\n+    path: Option<hir::ModPath>,\n+    local_name: Option<hir::Name>,\n+) -> Option<CompletionItem> {\n+    let _p = profile::span(\"render_struct_literal\");\n+    let db = ctx.db();\n+\n+    let name = local_name.unwrap_or_else(|| strukt.name(db));\n+    render(ctx, Variant::Struct(strukt), name, path)\n+}\n+\n+fn render(\n+    ctx @ RenderContext { completion, .. }: RenderContext<'_>,\n+    thing: Variant,\n+    name: hir::Name,\n+    path: Option<hir::ModPath>,\n+) -> Option<CompletionItem> {\n+    if let Some(PathCompletionCtx { has_call_parens: true, .. }) = completion.path_context {\n+        return None;\n+    }\n+    let db = completion.db;\n+    let fields = thing.fields(completion)?;\n+\n+    let (qualified_name, short_qualified_name, qualified) = match path {\n+        Some(path) => {\n+            let short = hir::ModPath::from_segments(\n+                hir::PathKind::Plain,\n+                path.segments().iter().skip(path.segments().len().saturating_sub(2)).cloned(),\n+            );\n+            (path, short, true)\n+        }\n+        None => (name.clone().into(), name.into(), false),\n+    };\n+    let qualified_name = qualified_name.to_string();\n+    let snippet_cap = ctx.snippet_cap();\n+\n+    let kind = thing.kind(db);\n+    let mut rendered = match kind {\n+        StructKind::Tuple => render_tuple_lit(db, snippet_cap, &fields, &qualified_name),\n+        StructKind::Record => render_record_lit(db, snippet_cap, &fields, &qualified_name),\n+        StructKind::Unit => {\n+            RenderedLiteral { literal: qualified_name.clone(), detail: qualified_name.clone() }\n+        }\n+    };\n+\n+    if snippet_cap.is_some() {\n+        rendered.literal.push_str(\"$0\");\n+    }\n+\n+    let mut item = CompletionItem::new(\n+        CompletionItemKind::SymbolKind(thing.symbol_kind()),\n+        ctx.source_range(),\n+        format_literal_label(&qualified_name, kind),\n+    );\n+\n+    item.detail(rendered.detail);\n+\n+    match snippet_cap {\n+        Some(snippet_cap) => item.insert_snippet(snippet_cap, rendered.literal),\n+        None => item.insert_text(rendered.literal),\n+    };\n+\n+    if qualified {\n+        item.lookup_by(format_literal_label(&short_qualified_name.to_string(), kind));\n+    }\n+    item.set_documentation(thing.docs(db)).set_deprecated(thing.is_deprecated(&ctx));\n+\n+    let ty = thing.ty(db);\n+    item.set_relevance(CompletionRelevance {\n+        type_match: compute_type_match(ctx.completion, &ty),\n+        ..ctx.completion_relevance()\n+    });\n+    if let Some(ref_match) = compute_ref_match(completion, &ty) {\n+        item.ref_match(ref_match);\n+    }\n+\n+    if let Some(import_to_add) = ctx.import_to_add {\n+        item.add_import(import_to_add);\n+    }\n+    Some(item.build())\n+}\n+\n+#[derive(Clone, Copy)]\n+enum Variant {\n+    Struct(hir::Struct),\n+    EnumVariant(hir::Variant),\n+}\n+\n+impl Variant {\n+    fn fields(self, ctx: &CompletionContext) -> Option<Vec<hir::Field>> {\n+        let fields = match self {\n+            Variant::Struct(it) => it.fields(ctx.db),\n+            Variant::EnumVariant(it) => it.fields(ctx.db),\n+        };\n+        let (visible_fields, fields_omitted) = match self {\n+            Variant::Struct(it) => visible_fields(ctx, &fields, it)?,\n+            Variant::EnumVariant(it) => visible_fields(ctx, &fields, it)?,\n+        };\n+        if !fields_omitted {\n+            Some(visible_fields)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn kind(self, db: &dyn HirDatabase) -> StructKind {\n+        match self {\n+            Variant::Struct(it) => it.kind(db),\n+            Variant::EnumVariant(it) => it.kind(db),\n+        }\n+    }\n+\n+    fn symbol_kind(self) -> SymbolKind {\n+        match self {\n+            Variant::Struct(_) => SymbolKind::Struct,\n+            Variant::EnumVariant(_) => SymbolKind::Variant,\n+        }\n+    }\n+\n+    fn docs(self, db: &dyn HirDatabase) -> Option<Documentation> {\n+        match self {\n+            Variant::Struct(it) => it.docs(db),\n+            Variant::EnumVariant(it) => it.docs(db),\n+        }\n+    }\n+\n+    fn is_deprecated(self, ctx: &RenderContext<'_>) -> bool {\n+        match self {\n+            Variant::Struct(it) => ctx.is_deprecated(it),\n+            Variant::EnumVariant(it) => ctx.is_deprecated(it),\n+        }\n+    }\n+\n+    fn ty(self, db: &dyn HirDatabase) -> hir::Type {\n+        match self {\n+            Variant::Struct(it) => it.ty(db),\n+            Variant::EnumVariant(it) => it.parent_enum(db).ty(db),\n+        }\n+    }\n+}"}, {"sha": "9f848febeb3b656f0971e155613bc75bf899ee0e", "filename": "crates/ide_completion/src/render/macro_.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs?ref=641c6e5b324eeb6682823af1f9a70967ab53d076", "patch": "@@ -4,27 +4,21 @@ use hir::{Documentation, HirDisplay};\n use ide_db::SymbolKind;\n use syntax::SmolStr;\n \n-use crate::{\n-    context::PathKind,\n-    item::{CompletionItem, ImportEdit},\n-    render::RenderContext,\n-};\n+use crate::{context::PathKind, item::CompletionItem, render::RenderContext};\n \n pub(crate) fn render_macro(\n     ctx: RenderContext<'_>,\n-    import_to_add: Option<ImportEdit>,\n     name: hir::Name,\n     macro_: hir::Macro,\n ) -> CompletionItem {\n     let _p = profile::span(\"render_macro\");\n-    render(ctx, name, macro_, import_to_add)\n+    render(ctx, name, macro_)\n }\n \n fn render(\n     ctx @ RenderContext { completion, .. }: RenderContext<'_>,\n     name: hir::Name,\n     macro_: hir::Macro,\n-    import_to_add: Option<ImportEdit>,\n ) -> CompletionItem {\n     let source_range = if completion.is_immediately_after_macro_bang() {\n         cov_mark::hit!(completes_macro_call_if_cursor_at_bang_token);\n@@ -52,12 +46,7 @@ fn render(\n         .set_documentation(docs)\n         .set_relevance(ctx.completion_relevance());\n \n-    if let Some(import_to_add) = import_to_add {\n-        item.add_import(import_to_add);\n-    }\n-\n     let name = &*name;\n-\n     match ctx.snippet_cap() {\n         Some(cap) if needs_bang && !completion.path_is_call() => {\n             let snippet = format!(\"{}!{}$0{}\", name, bra, ket);\n@@ -73,6 +62,9 @@ fn render(\n             item.insert_text(name);\n         }\n     };\n+    if let Some(import_to_add) = ctx.import_to_add {\n+        item.add_import(import_to_add);\n+    }\n \n     item.build()\n }"}, {"sha": "efceb85718d655620129ce1ec0bafaa47eb4080a", "filename": "crates/ide_completion/src/render/pattern.rs", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fpattern.rs?ref=641c6e5b324eeb6682823af1f9a70967ab53d076", "patch": "@@ -1,13 +1,13 @@\n //! Renderer for patterns.\n \n-use hir::{db::HirDatabase, HasAttrs, HasVisibility, Name, StructKind};\n+use hir::{db::HirDatabase, HasAttrs, Name, StructKind};\n use ide_db::SnippetCap;\n use itertools::Itertools;\n use syntax::SmolStr;\n \n use crate::{\n     context::{ParamKind, PatternContext},\n-    render::RenderContext,\n+    render::{variant::visible_fields, RenderContext},\n     CompletionItem, CompletionItemKind,\n };\n \n@@ -19,7 +19,7 @@ pub(crate) fn render_struct_pat(\n     let _p = profile::span(\"render_struct_pat\");\n \n     let fields = strukt.fields(ctx.db());\n-    let (visible_fields, fields_omitted) = visible_fields(&ctx, &fields, strukt)?;\n+    let (visible_fields, fields_omitted) = visible_fields(ctx.completion, &fields, strukt)?;\n \n     if visible_fields.is_empty() {\n         // Matching a struct without matching its fields is pointless, unlike matching a Variant without its fields\n@@ -36,14 +36,14 @@ pub(crate) fn render_variant_pat(\n     ctx: RenderContext<'_>,\n     variant: hir::Variant,\n     local_name: Option<Name>,\n-    path: Option<hir::ModPath>,\n+    path: Option<&hir::ModPath>,\n ) -> Option<CompletionItem> {\n     let _p = profile::span(\"render_variant_pat\");\n \n     let fields = variant.fields(ctx.db());\n-    let (visible_fields, fields_omitted) = visible_fields(&ctx, &fields, variant)?;\n+    let (visible_fields, fields_omitted) = visible_fields(ctx.completion, &fields, variant)?;\n \n-    let name = match &path {\n+    let name = match path {\n         Some(path) => path.to_string().into(),\n         None => local_name.unwrap_or_else(|| variant.name(ctx.db())).to_smol_str(),\n     };\n@@ -78,9 +78,7 @@ fn render_pat(\n     fields_omitted: bool,\n ) -> Option<String> {\n     let mut pat = match kind {\n-        StructKind::Tuple if ctx.snippet_cap().is_some() => {\n-            render_tuple_as_pat(fields, name, fields_omitted)\n-        }\n+        StructKind::Tuple => render_tuple_as_pat(ctx.snippet_cap(), fields, name, fields_omitted),\n         StructKind::Record => {\n             render_record_as_pat(ctx.db(), ctx.snippet_cap(), fields, name, fields_omitted)\n         }\n@@ -113,49 +111,53 @@ fn render_record_as_pat(\n     fields_omitted: bool,\n ) -> String {\n     let fields = fields.iter();\n-    if snippet_cap.is_some() {\n-        format!(\n-            \"{name} {{ {}{} }}\",\n-            fields\n-                .enumerate()\n-                .map(|(idx, field)| format!(\"{}${}\", field.name(db), idx + 1))\n-                .format(\", \"),\n-            if fields_omitted { \", ..\" } else { \"\" },\n-            name = name\n-        )\n-    } else {\n-        format!(\n-            \"{name} {{ {}{} }}\",\n-            fields.map(|field| field.name(db)).format(\", \"),\n-            if fields_omitted { \", ..\" } else { \"\" },\n-            name = name\n-        )\n+    match snippet_cap {\n+        Some(_) => {\n+            format!(\n+                \"{name} {{ {}{} }}\",\n+                fields.enumerate().format_with(\", \", |(idx, field), f| {\n+                    f(&format_args!(\"{}${}\", field.name(db), idx + 1))\n+                }),\n+                if fields_omitted { \", ..\" } else { \"\" },\n+                name = name\n+            )\n+        }\n+        None => {\n+            format!(\n+                \"{name} {{ {}{} }}\",\n+                fields.map(|field| field.name(db)).format(\", \"),\n+                if fields_omitted { \", ..\" } else { \"\" },\n+                name = name\n+            )\n+        }\n     }\n }\n \n-fn render_tuple_as_pat(fields: &[hir::Field], name: &str, fields_omitted: bool) -> String {\n-    format!(\n-        \"{name}({}{})\",\n-        fields.iter().enumerate().map(|(idx, _)| format!(\"${}\", idx + 1)).format(\", \"),\n-        if fields_omitted { \", ..\" } else { \"\" },\n-        name = name\n-    )\n-}\n-\n-fn visible_fields(\n-    ctx: &RenderContext<'_>,\n+fn render_tuple_as_pat(\n+    snippet_cap: Option<SnippetCap>,\n     fields: &[hir::Field],\n-    item: impl HasAttrs,\n-) -> Option<(Vec<hir::Field>, bool)> {\n-    let module = ctx.completion.module?;\n-    let n_fields = fields.len();\n-    let fields = fields\n-        .iter()\n-        .filter(|field| field.is_visible_from(ctx.db(), module))\n-        .copied()\n-        .collect::<Vec<_>>();\n-\n-    let fields_omitted =\n-        n_fields - fields.len() > 0 || item.attrs(ctx.db()).by_key(\"non_exhaustive\").exists();\n-    Some((fields, fields_omitted))\n+    name: &str,\n+    fields_omitted: bool,\n+) -> String {\n+    let fields = fields.iter();\n+    match snippet_cap {\n+        Some(_) => {\n+            format!(\n+                \"{name}({}{})\",\n+                fields\n+                    .enumerate()\n+                    .format_with(\", \", |(idx, _), f| { f(&format_args!(\"${}\", idx + 1)) }),\n+                if fields_omitted { \", ..\" } else { \"\" },\n+                name = name\n+            )\n+        }\n+        None => {\n+            format!(\n+                \"{name}({}{})\",\n+                fields.enumerate().map(|(idx, _)| idx).format(\", \"),\n+                if fields_omitted { \", ..\" } else { \"\" },\n+                name = name\n+            )\n+        }\n+    }\n }"}, {"sha": "a686be669135dc257fc421ea0ea00ed4cd509052", "filename": "crates/ide_completion/src/render/struct_literal.rs", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c1cf2ef6f434975799d051d8d1ee71c975ac1df3/crates%2Fide_completion%2Fsrc%2Frender%2Fstruct_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cf2ef6f434975799d051d8d1ee71c975ac1df3/crates%2Fide_completion%2Fsrc%2Frender%2Fstruct_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fstruct_literal.rs?ref=c1cf2ef6f434975799d051d8d1ee71c975ac1df3", "patch": "@@ -1,91 +0,0 @@\n-//! Renderer for `struct` literal.\n-\n-use hir::{HasAttrs, Name, StructKind};\n-use syntax::SmolStr;\n-\n-use crate::{\n-    render::compound::{\n-        format_literal_label, render_record, render_tuple, visible_fields, RenderedCompound,\n-    },\n-    render::RenderContext,\n-    CompletionItem, CompletionItemKind,\n-};\n-\n-pub(crate) fn render_struct_literal(\n-    ctx: RenderContext<'_>,\n-    strukt: hir::Struct,\n-    path: Option<hir::ModPath>,\n-    local_name: Option<Name>,\n-) -> Option<CompletionItem> {\n-    let _p = profile::span(\"render_struct_literal\");\n-\n-    let fields = strukt.fields(ctx.db());\n-    let (visible_fields, fields_omitted) = visible_fields(&ctx, &fields, strukt)?;\n-\n-    if fields_omitted {\n-        // If some fields are private you can't make `struct` literal.\n-        return None;\n-    }\n-\n-    let name = local_name.unwrap_or_else(|| strukt.name(ctx.db())).to_smol_str();\n-\n-    let rendered = render_literal(&ctx, path, &name, strukt.kind(ctx.db()), &visible_fields)?;\n-\n-    Some(build_completion(&ctx, name, rendered, strukt.kind(ctx.db()), strukt))\n-}\n-\n-fn build_completion(\n-    ctx: &RenderContext<'_>,\n-    name: SmolStr,\n-    rendered: RenderedCompound,\n-    kind: StructKind,\n-    def: impl HasAttrs + Copy,\n-) -> CompletionItem {\n-    let mut item = CompletionItem::new(\n-        CompletionItemKind::Snippet,\n-        ctx.source_range(),\n-        format_literal_label(&name, kind),\n-    );\n-\n-    item.set_documentation(ctx.docs(def))\n-        .set_deprecated(ctx.is_deprecated(def))\n-        .detail(&rendered.detail)\n-        .set_relevance(ctx.completion_relevance());\n-    match ctx.snippet_cap() {\n-        Some(snippet_cap) => item.insert_snippet(snippet_cap, rendered.literal),\n-        None => item.insert_text(rendered.literal),\n-    };\n-    item.build()\n-}\n-\n-fn render_literal(\n-    ctx: &RenderContext<'_>,\n-    path: Option<hir::ModPath>,\n-    name: &str,\n-    kind: StructKind,\n-    fields: &[hir::Field],\n-) -> Option<RenderedCompound> {\n-    let path_string;\n-\n-    let qualified_name = if let Some(path) = path {\n-        path_string = path.to_string();\n-        &path_string\n-    } else {\n-        name\n-    };\n-\n-    let mut rendered = match kind {\n-        StructKind::Tuple if ctx.snippet_cap().is_some() => {\n-            render_tuple(ctx.db(), ctx.snippet_cap(), fields, Some(qualified_name))\n-        }\n-        StructKind::Record => {\n-            render_record(ctx.db(), ctx.snippet_cap(), fields, Some(qualified_name))\n-        }\n-        _ => return None,\n-    };\n-\n-    if ctx.snippet_cap().is_some() {\n-        rendered.literal.push_str(\"$0\");\n-    }\n-    Some(rendered)\n-}"}, {"sha": "aafedaf5aa7b580f62e01ade2af14eea145efb11", "filename": "crates/ide_completion/src/render/union_literal.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Frender%2Funion_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Frender%2Funion_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Funion_literal.rs?ref=641c6e5b324eeb6682823af1f9a70967ab53d076", "patch": "@@ -1,11 +1,12 @@\n //! Renderer for `union` literals.\n \n use hir::{HirDisplay, Name, StructKind};\n+use ide_db::SymbolKind;\n use itertools::Itertools;\n \n use crate::{\n     render::{\n-        compound::{format_literal_label, visible_fields},\n+        variant::{format_literal_label, visible_fields},\n         RenderContext,\n     },\n     CompletionItem, CompletionItemKind,\n@@ -25,13 +26,13 @@ pub(crate) fn render_union_literal(\n     };\n \n     let mut item = CompletionItem::new(\n-        CompletionItemKind::Snippet,\n+        CompletionItemKind::SymbolKind(SymbolKind::Union),\n         ctx.source_range(),\n         format_literal_label(&name, StructKind::Record),\n     );\n \n     let fields = un.fields(ctx.db());\n-    let (fields, fields_omitted) = visible_fields(&ctx, &fields, un)?;\n+    let (fields, fields_omitted) = visible_fields(ctx.completion, &fields, un)?;\n \n     if fields.is_empty() {\n         return None;"}, {"sha": "a37b4237c459677f20d27a67bb8d10875deb7ca8", "filename": "crates/ide_completion/src/render/variant.rs", "status": "renamed", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Frender%2Fvariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Frender%2Fvariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fvariant.rs?ref=641c6e5b324eeb6682823af1f9a70967ab53d076", "patch": "@@ -1,6 +1,6 @@\n //! Code common to structs, unions, and enum variants.\n \n-use crate::render::RenderContext;\n+use crate::context::CompletionContext;\n use hir::{db::HirDatabase, HasAttrs, HasVisibility, HirDisplay, StructKind};\n use ide_db::SnippetCap;\n use itertools::Itertools;\n@@ -9,19 +9,19 @@ use syntax::SmolStr;\n /// A rendered struct, union, or enum variant, split into fields for actual\n /// auto-completion (`literal`, using `field: ()`) and display in the\n /// completions menu (`detail`, using `field: type`).\n-pub(crate) struct RenderedCompound {\n+pub(crate) struct RenderedLiteral {\n     pub(crate) literal: String,\n     pub(crate) detail: String,\n }\n \n /// Render a record type (or sub-type) to a `RenderedCompound`. Use `None` for\n /// the `name` argument for an anonymous type.\n-pub(crate) fn render_record(\n+pub(crate) fn render_record_lit(\n     db: &dyn HirDatabase,\n     snippet_cap: Option<SnippetCap>,\n     fields: &[hir::Field],\n-    name: Option<&str>,\n-) -> RenderedCompound {\n+    path: &str,\n+) -> RenderedLiteral {\n     let completions = fields.iter().enumerate().format_with(\", \", |(idx, field), f| {\n         if snippet_cap.is_some() {\n             f(&format_args!(\"{}: ${{{}:()}}\", field.name(db), idx + 1))\n@@ -34,20 +34,20 @@ pub(crate) fn render_record(\n         f(&format_args!(\"{}: {}\", field.name(db), field.ty(db).display(db)))\n     });\n \n-    RenderedCompound {\n-        literal: format!(\"{} {{ {} }}\", name.unwrap_or(\"\"), completions),\n-        detail: format!(\"{} {{ {} }}\", name.unwrap_or(\"\"), types),\n+    RenderedLiteral {\n+        literal: format!(\"{} {{ {} }}\", path, completions),\n+        detail: format!(\"{} {{ {} }}\", path, types),\n     }\n }\n \n /// Render a tuple type (or sub-type) to a `RenderedCompound`. Use `None` for\n /// the `name` argument for an anonymous type.\n-pub(crate) fn render_tuple(\n+pub(crate) fn render_tuple_lit(\n     db: &dyn HirDatabase,\n     snippet_cap: Option<SnippetCap>,\n     fields: &[hir::Field],\n-    name: Option<&str>,\n-) -> RenderedCompound {\n+    path: &str,\n+) -> RenderedLiteral {\n     let completions = fields.iter().enumerate().format_with(\", \", |(idx, _), f| {\n         if snippet_cap.is_some() {\n             f(&format_args!(\"${{{}:()}}\", idx + 1))\n@@ -58,30 +58,30 @@ pub(crate) fn render_tuple(\n \n     let types = fields.iter().format_with(\", \", |field, f| f(&field.ty(db).display(db)));\n \n-    RenderedCompound {\n-        literal: format!(\"{}({})\", name.unwrap_or(\"\"), completions),\n-        detail: format!(\"{}({})\", name.unwrap_or(\"\"), types),\n+    RenderedLiteral {\n+        literal: format!(\"{}({})\", path, completions),\n+        detail: format!(\"{}({})\", path, types),\n     }\n }\n \n /// Find all the visible fields in a given list. Returns the list of visible\n /// fields, plus a boolean for whether the list is comprehensive (contains no\n /// private fields and its item is not marked `#[non_exhaustive]`).\n pub(crate) fn visible_fields(\n-    ctx: &RenderContext<'_>,\n+    ctx: &CompletionContext,\n     fields: &[hir::Field],\n     item: impl HasAttrs,\n ) -> Option<(Vec<hir::Field>, bool)> {\n-    let module = ctx.completion.module?;\n+    let module = ctx.module?;\n     let n_fields = fields.len();\n     let fields = fields\n         .iter()\n-        .filter(|field| field.is_visible_from(ctx.db(), module))\n+        .filter(|field| field.is_visible_from(ctx.db, module))\n         .copied()\n         .collect::<Vec<_>>();\n \n     let fields_omitted =\n-        n_fields - fields.len() > 0 || item.attrs(ctx.db()).by_key(\"non_exhaustive\").exists();\n+        n_fields - fields.len() > 0 || item.attrs(ctx.db).by_key(\"non_exhaustive\").exists();\n     Some((fields, fields_omitted))\n }\n ", "previous_filename": "crates/ide_completion/src/render/compound.rs"}, {"sha": "50d5e01979bd5a6f1423cfb1058d9b4761eba723", "filename": "crates/ide_completion/src/tests/pattern.rs", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs?ref=641c6e5b324eeb6682823af1f9a70967ab53d076", "patch": "@@ -150,6 +150,7 @@ fn foo() {\n             bn Tuple             Tuple($1)$0\n             st Tuple\n             ev Variant\n+            md module\n             en SingleVariantEnum\n             st Unit\n             ma makro!(\u2026)         macro_rules! makro\n@@ -171,6 +172,7 @@ fn foo(a$0) {\n             st Record\n             bn Tuple     Tuple($1): Tuple$0\n             st Tuple\n+            md module\n             st Unit\n             ma makro!(\u2026) macro_rules! makro\n         \"#]],\n@@ -187,6 +189,7 @@ fn foo(a$0: Tuple) {\n             st Record\n             bn Tuple     Tuple($1)$0\n             st Tuple\n+            md module\n             st Unit\n             ma makro!(\u2026) macro_rules! makro\n         \"#]],\n@@ -228,7 +231,6 @@ fn foo() {\n         expect![[r#\"\n             kw ref\n             kw mut\n-            ev E::X  E::X\n             en E\n             ma m!(\u2026) macro_rules! m\n         \"#]],\n@@ -378,3 +380,67 @@ fn foo() {\n         \"#]],\n     )\n }\n+\n+#[test]\n+fn completes_no_delims_if_existing() {\n+    check_empty(\n+        r#\"\n+struct Bar(u32);\n+fn foo() {\n+    match Bar(0) {\n+        B$0(b) => {}\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+struct Foo { bar: u32 }\n+fn foo() {\n+    match Foo { bar: 0 } {\n+        F$0 { bar } => {}\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            st Foo\n+            fn foo()  fn()\n+            bt u32\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+enum Enum {\n+    TupleVariant(u32)\n+}\n+fn foo() {\n+    match Enum::TupleVariant(0) {\n+        Enum::T$0(b) => {}\n+    }\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+    check_empty(\n+        r#\"\n+enum Enum {\n+    RecordVariant { field: u32 }\n+}\n+fn foo() {\n+    match (Enum::RecordVariant { field: 0 }) {\n+        Enum::RecordV$0 { field } => {}\n+    }\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+}"}, {"sha": "0322ecbe39fa4cc6f35d8d7d7bda88a2a41b0b8f", "filename": "crates/ide_completion/src/tests/record.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641c6e5b324eeb6682823af1f9a70967ab53d076/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs?ref=641c6e5b324eeb6682823af1f9a70967ab53d076", "patch": "@@ -166,7 +166,7 @@ fn main() {\n             kw true\n             kw false\n             kw return\n-            sn Foo {\u2026}              Foo { foo1: u32, foo2: u32 }\n+            st Foo {\u2026}              Foo { foo1: u32, foo2: u32 }\n             fd ..Default::default()\n             fd foo1                 u32\n             fd foo2                 u32"}]}