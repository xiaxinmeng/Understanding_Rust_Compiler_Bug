{"sha": "f9441ad687cd51d4400aab48a1d0a630c5b95738", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NDQxYWQ2ODdjZDUxZDQ0MDBhYWI0OGExZDBhNjMwYzViOTU3Mzg=", "commit": {"author": {"name": "Christoph Schmidler", "email": "c.schmidler@gmail.com", "date": "2019-12-09T08:07:09Z"}, "committer": {"name": "Christoph Schmidler", "email": "c.schmidler@gmail.com", "date": "2019-12-09T08:07:09Z"}, "message": "Merge branch 'master' of github.com:rust-lang/rust", "tree": {"sha": "81e84d68f9d8285cb5ddc2c60a548d9f2e642384", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81e84d68f9d8285cb5ddc2c60a548d9f2e642384"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9441ad687cd51d4400aab48a1d0a630c5b95738", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9441ad687cd51d4400aab48a1d0a630c5b95738", "html_url": "https://github.com/rust-lang/rust/commit/f9441ad687cd51d4400aab48a1d0a630c5b95738", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9441ad687cd51d4400aab48a1d0a630c5b95738/comments", "author": {"login": "TheSamsa", "id": 13667299, "node_id": "MDQ6VXNlcjEzNjY3Mjk5", "avatar_url": "https://avatars.githubusercontent.com/u/13667299?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TheSamsa", "html_url": "https://github.com/TheSamsa", "followers_url": "https://api.github.com/users/TheSamsa/followers", "following_url": "https://api.github.com/users/TheSamsa/following{/other_user}", "gists_url": "https://api.github.com/users/TheSamsa/gists{/gist_id}", "starred_url": "https://api.github.com/users/TheSamsa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TheSamsa/subscriptions", "organizations_url": "https://api.github.com/users/TheSamsa/orgs", "repos_url": "https://api.github.com/users/TheSamsa/repos", "events_url": "https://api.github.com/users/TheSamsa/events{/privacy}", "received_events_url": "https://api.github.com/users/TheSamsa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TheSamsa", "id": 13667299, "node_id": "MDQ6VXNlcjEzNjY3Mjk5", "avatar_url": "https://avatars.githubusercontent.com/u/13667299?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TheSamsa", "html_url": "https://github.com/TheSamsa", "followers_url": "https://api.github.com/users/TheSamsa/followers", "following_url": "https://api.github.com/users/TheSamsa/following{/other_user}", "gists_url": "https://api.github.com/users/TheSamsa/gists{/gist_id}", "starred_url": "https://api.github.com/users/TheSamsa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TheSamsa/subscriptions", "organizations_url": "https://api.github.com/users/TheSamsa/orgs", "repos_url": "https://api.github.com/users/TheSamsa/repos", "events_url": "https://api.github.com/users/TheSamsa/events{/privacy}", "received_events_url": "https://api.github.com/users/TheSamsa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abf053d238e051390d5a1cfb62269a5853e77437", "url": "https://api.github.com/repos/rust-lang/rust/commits/abf053d238e051390d5a1cfb62269a5853e77437", "html_url": "https://github.com/rust-lang/rust/commit/abf053d238e051390d5a1cfb62269a5853e77437"}, {"sha": "2b0e6d2643e60651ef4b8c83beaf86dc4e62f359", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b0e6d2643e60651ef4b8c83beaf86dc4e62f359", "html_url": "https://github.com/rust-lang/rust/commit/2b0e6d2643e60651ef4b8c83beaf86dc4e62f359"}], "stats": {"total": 3192, "additions": 1589, "deletions": 1603}, "files": [{"sha": "5484f24003133817e565b9e9cffa2fa219d30873", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9441ad687cd51d4400aab48a1d0a630c5b95738/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f9441ad687cd51d4400aab48a1d0a630c5b95738/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f9441ad687cd51d4400aab48a1d0a630c5b95738", "patch": "@@ -2055,12 +2055,13 @@ dependencies = [\n \n [[package]]\n name = \"measureme\"\n-version = \"0.4.0\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cd21b0e6e1af976b269ce062038fe5e1b9ca2f817ab7a3af09ec4210aebf0d30\"\n+checksum = \"c420bbc064623934620b5ab2dc0cf96451b34163329e82f95e7fa1b7b99a6ac8\"\n dependencies = [\n  \"byteorder\",\n  \"memmap\",\n+ \"parking_lot 0.9.0\",\n  \"rustc-hash\",\n ]\n \n@@ -2072,9 +2073,9 @@ checksum = \"2efc7bc57c883d4a4d6e3246905283d8dae951bb3bd32f49d6ef297f546e1c39\"\n \n [[package]]\n name = \"memmap\"\n-version = \"0.6.2\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e2ffa2c986de11a9df78620c01eeaaf27d94d3ff02bf81bfcca953102dd0c6ff\"\n+checksum = \"6585fd95e7bb50d6cc31e20d4cf9afb4e2ba16c5846fc76793f11218da9c475b\"\n dependencies = [\n  \"libc\",\n  \"winapi 0.3.8\",\n@@ -2213,6 +2214,7 @@ dependencies = [\n  \"rand 0.7.0\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n+ \"serde\",\n  \"shell-escape\",\n  \"vergen\",\n ]"}, {"sha": "854942dad3ded1c849a57ad568570df4aa406a5d", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 12, "deletions": 47, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=f9441ad687cd51d4400aab48a1d0a630c5b95738", "patch": "@@ -202,53 +202,18 @@ impl<T> TypedArena<T> {\n     #[inline]\n     pub fn alloc_from_iter<I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n         assert!(mem::size_of::<T>() != 0);\n-        let mut iter = iter.into_iter();\n-        let size_hint = iter.size_hint();\n-\n-        match size_hint {\n-            (min, Some(max)) if min == max => {\n-                // We know the exact number of elements the iterator will produce here\n-                let len = min;\n-\n-                if len == 0 {\n-                    return &mut [];\n-                }\n-\n-                self.ensure_capacity(len);\n-\n-                let slice = self.ptr.get();\n-\n-                unsafe {\n-                    let mut ptr = self.ptr.get();\n-                    for _ in 0..len {\n-                        // Write into uninitialized memory.\n-                        ptr::write(ptr, iter.next().unwrap());\n-                        // Advance the pointer.\n-                        ptr = ptr.offset(1);\n-                        // Update the pointer per iteration so if `iter.next()` panics\n-                        // we destroy the correct amount\n-                        self.ptr.set(ptr);\n-                    }\n-                    slice::from_raw_parts_mut(slice, len)\n-                }\n-            }\n-            _ => {\n-                cold_path(move || -> &mut [T] {\n-                    let mut vec: SmallVec<[_; 8]> = iter.collect();\n-                    if vec.is_empty() {\n-                        return &mut [];\n-                    }\n-                    // Move the content to the arena by copying it and then forgetting\n-                    // the content of the SmallVec\n-                    unsafe {\n-                        let len = vec.len();\n-                        let start_ptr = self.alloc_raw_slice(len);\n-                        vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n-                        vec.set_len(0);\n-                        slice::from_raw_parts_mut(start_ptr, len)\n-                    }\n-                })\n-            }\n+        let mut vec: SmallVec<[_; 8]> = iter.into_iter().collect();\n+        if vec.is_empty() {\n+            return &mut [];\n+        }\n+        // Move the content to the arena by copying it and then forgetting\n+        // the content of the SmallVec\n+        unsafe {\n+            let len = vec.len();\n+            let start_ptr = self.alloc_raw_slice(len);\n+            vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+            vec.set_len(0);\n+            slice::from_raw_parts_mut(start_ptr, len)\n         }\n     }\n "}, {"sha": "791d72d6b77a77521e236ad9f0508419cbe09c23", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=f9441ad687cd51d4400aab48a1d0a630c5b95738", "patch": "@@ -37,6 +37,6 @@ byteorder = { version = \"1.3\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n-measureme = \"0.4\"\n+measureme = \"0.5\"\n rustc_error_codes = { path = \"../librustc_error_codes\" }\n rustc_session = { path = \"../librustc_session\" }"}, {"sha": "d489852a1a43dc674e42fee11b63eb7ec7b4b1a5", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=f9441ad687cd51d4400aab48a1d0a630c5b95738", "patch": "@@ -13,7 +13,7 @@ test = false\n bitflags = \"1.2.1\"\n cc = \"1.0.1\"\n num_cpus = \"1.0\"\n-memmap = \"0.6\"\n+memmap = \"0.7\"\n log = \"0.4.5\"\n libc = \"0.2.44\"\n jobserver = \"0.1.11\""}, {"sha": "7fa40b8a869058670ebf03669d40930b75c0c081", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=f9441ad687cd51d4400aab48a1d0a630c5b95738", "patch": "@@ -26,7 +26,7 @@ rustc-hash = \"1.0.1\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_index = { path = \"../librustc_index\", package = \"rustc_index\" }\n bitflags = \"1.2.1\"\n-measureme = \"0.4\"\n+measureme = \"0.5\"\n \n [dependencies.parking_lot]\n version = \"0.9\""}, {"sha": "f9bfe5a1652ae82d09490f8830dd5721458641f8", "filename": "src/librustc_data_structures/profiling.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibrustc_data_structures%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibrustc_data_structures%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fprofiling.rs?ref=f9441ad687cd51d4400aab48a1d0a630c5b95738", "patch": "@@ -7,7 +7,7 @@ use std::sync::Arc;\n use std::thread::ThreadId;\n use std::u32;\n \n-use measureme::{StringId, TimestampKind};\n+use measureme::{StringId};\n \n /// MmapSerializatioSink is faster on macOS and Linux\n /// but FileSerializationSink is faster on Windows\n@@ -63,8 +63,8 @@ const EVENT_FILTERS_BY_NAME: &[(&str, EventFilter)] = &[\n     (\"incr-cache-load\", EventFilter::INCR_CACHE_LOADS),\n ];\n \n-fn thread_id_to_u64(tid: ThreadId) -> u64 {\n-    unsafe { mem::transmute::<ThreadId, u64>(tid) }\n+fn thread_id_to_u32(tid: ThreadId) -> u32 {\n+    unsafe { mem::transmute::<ThreadId, u64>(tid) as u32 }\n }\n \n \n@@ -149,11 +149,10 @@ impl SelfProfilerRef {\n     /// Record a query in-memory cache hit.\n     #[inline(always)]\n     pub fn query_cache_hit(&self, query_name: impl QueryName) {\n-        self.non_guard_query_event(\n+        self.instant_query_event(\n             |profiler| profiler.query_cache_hit_event_kind,\n             query_name,\n             EventFilter::QUERY_CACHE_HITS,\n-            TimestampKind::Instant,\n         );\n     }\n \n@@ -184,22 +183,20 @@ impl SelfProfilerRef {\n     }\n \n     #[inline(always)]\n-    fn non_guard_query_event(\n+    fn instant_query_event(\n         &self,\n         event_kind: fn(&SelfProfiler) -> StringId,\n         query_name: impl QueryName,\n         event_filter: EventFilter,\n-        timestamp_kind: TimestampKind\n     ) {\n         drop(self.exec(event_filter, |profiler| {\n             let event_id = SelfProfiler::get_query_name_string_id(query_name);\n-            let thread_id = thread_id_to_u64(std::thread::current().id());\n+            let thread_id = thread_id_to_u32(std::thread::current().id());\n \n-            profiler.profiler.record_event(\n+            profiler.profiler.record_instant_event(\n                 event_kind(profiler),\n                 event_id,\n                 thread_id,\n-                timestamp_kind,\n             );\n \n             TimingGuard::none()\n@@ -306,7 +303,7 @@ impl<'a> TimingGuard<'a> {\n         event_kind: StringId,\n         event_id: StringId,\n     ) -> TimingGuard<'a> {\n-        let thread_id = thread_id_to_u64(std::thread::current().id());\n+        let thread_id = thread_id_to_u32(std::thread::current().id());\n         let raw_profiler = &profiler.profiler;\n         let timing_guard = raw_profiler.start_recording_interval_event(event_kind,\n                                                                        event_id,"}, {"sha": "88d1c501bae5c99c49589ac59c9ce6362ba19f1c", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=f9441ad687cd51d4400aab48a1d0a630c5b95738", "patch": "@@ -12,7 +12,7 @@ doctest = false\n [dependencies]\n flate2 = \"1.0\"\n log = \"0.4\"\n-memmap = \"0.6\"\n+memmap = \"0.7\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "327be40a58f2f5dd3d854b3500529f1eacf924ad", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 13, "deletions": 1534, "changes": 1547, "blob_url": "https://github.com/rust-lang/rust/blob/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f9441ad687cd51d4400aab48a1d0a630c5b95738", "patch": "@@ -5,12 +5,12 @@\n \n pub mod inline;\n pub mod cfg;\n-mod simplify;\n mod auto_trait;\n mod blanket_impl;\n+mod simplify;\n+pub mod types;\n \n use rustc_index::vec::{IndexVec, Idx};\n-use rustc_target::spec::abi::Abi;\n use rustc_typeck::hir_ty_to_ty;\n use rustc::infer::region_constraints::{RegionConstraintData, Constraint};\n use rustc::middle::resolve_lifetime as rl;\n@@ -24,46 +24,33 @@ use rustc::hir::ptr::P;\n use rustc::ty::subst::{InternalSubsts, SubstsRef, GenericArgKind};\n use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::ty::fold::TypeFolder;\n-use rustc::ty::layout::VariantIdx;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use syntax::ast::{self, Attribute, AttrStyle, AttrKind, Ident};\n+use syntax::ast::{self, Ident};\n use syntax::attr;\n-use syntax::util::comments;\n-use syntax::source_map::DUMMY_SP;\n use syntax_pos::symbol::{Symbol, kw, sym};\n use syntax_pos::hygiene::MacroKind;\n-use syntax_pos::{self, Pos, FileName};\n+use syntax_pos::{self, Pos};\n \n use std::collections::hash_map::Entry;\n-use std::fmt;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n use std::default::Default;\n-use std::{mem, slice, vec};\n-use std::num::NonZeroU32;\n-use std::iter::FromIterator;\n+use std::{mem, vec};\n use std::rc::Rc;\n-use std::cell::RefCell;\n-use std::sync::Arc;\n use std::u32;\n \n use crate::core::{self, DocContext, ImplTraitParam};\n use crate::doctree;\n-use crate::html::render::{cache, ExternalLocation};\n-use crate::html::item_type::ItemType;\n \n-\n-use self::cfg::Cfg;\n use self::auto_trait::AutoTraitFinder;\n use self::blanket_impl::BlanketImplFinder;\n \n-pub use self::Type::*;\n-pub use self::Mutability::*;\n-pub use self::ItemEnum::*;\n-pub use self::SelfTy::*;\n-pub use self::FunctionRetTy::*;\n-pub use self::Visibility::{Public, Inherited};\n-\n-thread_local!(pub static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> = Default::default());\n+pub use self::types::*;\n+pub use self::types::Type::*;\n+pub use self::types::Mutability::*;\n+pub use self::types::ItemEnum::*;\n+pub use self::types::SelfTy::*;\n+pub use self::types::FunctionRetTy::*;\n+pub use self::types::Visibility::{Public, Inherited};\n \n const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n@@ -122,21 +109,6 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for P<[T]> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Crate {\n-    pub name: String,\n-    pub version: Option<String>,\n-    pub src: FileName,\n-    pub module: Option<Item>,\n-    pub externs: Vec<(CrateNum, ExternalCrate)>,\n-    pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n-    // These are later on moved into `CACHEKEY`, leaving the map empty.\n-    // Only here so that they can be filtered through the rustdoc passes.\n-    pub external_traits: Rc<RefCell<FxHashMap<DefId, Trait>>>,\n-    pub masked_crates: FxHashSet<CrateNum>,\n-    pub collapsed: bool,\n-}\n-\n pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n     use crate::visit_lib::LibEmbargoVisitor;\n \n@@ -222,15 +194,6 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct ExternalCrate {\n-    pub name: String,\n-    pub src: FileName,\n-    pub attrs: Attributes,\n-    pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n-    pub keywords: Vec<(DefId, String, Attributes)>,\n-}\n-\n impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext<'_>) -> ExternalCrate {\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n@@ -351,237 +314,6 @@ impl Clean<ExternalCrate> for CrateNum {\n     }\n }\n \n-/// Anything with a source location and set of attributes and, optionally, a\n-/// name. That is, anything that can be documented. This doesn't correspond\n-/// directly to the AST's concept of an item; it's a strict superset.\n-#[derive(Clone)]\n-pub struct Item {\n-    /// Stringified span\n-    pub source: Span,\n-    /// Not everything has a name. E.g., impls\n-    pub name: Option<String>,\n-    pub attrs: Attributes,\n-    pub inner: ItemEnum,\n-    pub visibility: Visibility,\n-    pub def_id: DefId,\n-    pub stability: Option<Stability>,\n-    pub deprecation: Option<Deprecation>,\n-}\n-\n-impl fmt::Debug for Item {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-\n-        let fake = MAX_DEF_ID.with(|m| m.borrow().get(&self.def_id.krate)\n-                                   .map(|id| self.def_id >= *id).unwrap_or(false));\n-        let def_id: &dyn fmt::Debug = if fake { &\"**FAKE**\" } else { &self.def_id };\n-\n-        fmt.debug_struct(\"Item\")\n-            .field(\"source\", &self.source)\n-            .field(\"name\", &self.name)\n-            .field(\"attrs\", &self.attrs)\n-            .field(\"inner\", &self.inner)\n-            .field(\"visibility\", &self.visibility)\n-            .field(\"def_id\", def_id)\n-            .field(\"stability\", &self.stability)\n-            .field(\"deprecation\", &self.deprecation)\n-            .finish()\n-    }\n-}\n-\n-impl Item {\n-    /// Finds the `doc` attribute as a NameValue and returns the corresponding\n-    /// value found.\n-    pub fn doc_value(&self) -> Option<&str> {\n-        self.attrs.doc_value()\n-    }\n-    /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n-    /// with newlines.\n-    pub fn collapsed_doc_value(&self) -> Option<String> {\n-        self.attrs.collapsed_doc_value()\n-    }\n-\n-    pub fn links(&self) -> Vec<(String, String)> {\n-        self.attrs.links(&self.def_id.krate)\n-    }\n-\n-    pub fn is_crate(&self) -> bool {\n-        match self.inner {\n-            StrippedItem(box ModuleItem(Module { is_crate: true, ..})) |\n-            ModuleItem(Module { is_crate: true, ..}) => true,\n-            _ => false,\n-        }\n-    }\n-    pub fn is_mod(&self) -> bool {\n-        self.type_() == ItemType::Module\n-    }\n-    pub fn is_trait(&self) -> bool {\n-        self.type_() == ItemType::Trait\n-    }\n-    pub fn is_struct(&self) -> bool {\n-        self.type_() == ItemType::Struct\n-    }\n-    pub fn is_enum(&self) -> bool {\n-        self.type_() == ItemType::Enum\n-    }\n-    pub fn is_variant(&self) -> bool {\n-        self.type_() == ItemType::Variant\n-    }\n-    pub fn is_associated_type(&self) -> bool {\n-        self.type_() == ItemType::AssocType\n-    }\n-    pub fn is_associated_const(&self) -> bool {\n-        self.type_() == ItemType::AssocConst\n-    }\n-    pub fn is_method(&self) -> bool {\n-        self.type_() == ItemType::Method\n-    }\n-    pub fn is_ty_method(&self) -> bool {\n-        self.type_() == ItemType::TyMethod\n-    }\n-    pub fn is_typedef(&self) -> bool {\n-        self.type_() == ItemType::Typedef\n-    }\n-    pub fn is_primitive(&self) -> bool {\n-        self.type_() == ItemType::Primitive\n-    }\n-    pub fn is_union(&self) -> bool {\n-        self.type_() == ItemType::Union\n-    }\n-    pub fn is_import(&self) -> bool {\n-        self.type_() == ItemType::Import\n-    }\n-    pub fn is_extern_crate(&self) -> bool {\n-        self.type_() == ItemType::ExternCrate\n-    }\n-    pub fn is_keyword(&self) -> bool {\n-        self.type_() == ItemType::Keyword\n-    }\n-\n-    pub fn is_stripped(&self) -> bool {\n-        match self.inner { StrippedItem(..) => true, _ => false }\n-    }\n-    pub fn has_stripped_fields(&self) -> Option<bool> {\n-        match self.inner {\n-            StructItem(ref _struct) => Some(_struct.fields_stripped),\n-            UnionItem(ref union) => Some(union.fields_stripped),\n-            VariantItem(Variant { kind: VariantKind::Struct(ref vstruct)} ) => {\n-                Some(vstruct.fields_stripped)\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn stability_class(&self) -> Option<String> {\n-        self.stability.as_ref().and_then(|ref s| {\n-            let mut classes = Vec::with_capacity(2);\n-\n-            if s.level == stability::Unstable {\n-                classes.push(\"unstable\");\n-            }\n-\n-            if s.deprecation.is_some() {\n-                classes.push(\"deprecated\");\n-            }\n-\n-            if classes.len() != 0 {\n-                Some(classes.join(\" \"))\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    pub fn stable_since(&self) -> Option<&str> {\n-        self.stability.as_ref().map(|s| &s.since[..])\n-    }\n-\n-    pub fn is_non_exhaustive(&self) -> bool {\n-        self.attrs.other_attrs.iter()\n-            .any(|a| a.check_name(sym::non_exhaustive))\n-    }\n-\n-    /// Returns a documentation-level item type from the item.\n-    pub fn type_(&self) -> ItemType {\n-        ItemType::from(self)\n-    }\n-\n-    /// Returns the info in the item's `#[deprecated]` or `#[rustc_deprecated]` attributes.\n-    ///\n-    /// If the item is not deprecated, returns `None`.\n-    pub fn deprecation(&self) -> Option<&Deprecation> {\n-        self.deprecation\n-            .as_ref()\n-            .or_else(|| self.stability.as_ref().and_then(|s| s.deprecation.as_ref()))\n-    }\n-    pub fn is_default(&self) -> bool {\n-        match self.inner {\n-            ItemEnum::MethodItem(ref meth) => {\n-                if let Some(defaultness) = meth.defaultness {\n-                    defaultness.has_value() && !defaultness.is_final()\n-                } else {\n-                    false\n-                }\n-            }\n-            _ => false,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub enum ItemEnum {\n-    ExternCrateItem(String, Option<String>),\n-    ImportItem(Import),\n-    StructItem(Struct),\n-    UnionItem(Union),\n-    EnumItem(Enum),\n-    FunctionItem(Function),\n-    ModuleItem(Module),\n-    TypedefItem(Typedef, bool /* is associated type */),\n-    OpaqueTyItem(OpaqueTy, bool /* is associated type */),\n-    StaticItem(Static),\n-    ConstantItem(Constant),\n-    TraitItem(Trait),\n-    TraitAliasItem(TraitAlias),\n-    ImplItem(Impl),\n-    /// A method signature only. Used for required methods in traits (ie,\n-    /// non-default-methods).\n-    TyMethodItem(TyMethod),\n-    /// A method with a body.\n-    MethodItem(Method),\n-    StructFieldItem(Type),\n-    VariantItem(Variant),\n-    /// `fn`s from an extern block\n-    ForeignFunctionItem(Function),\n-    /// `static`s from an extern block\n-    ForeignStaticItem(Static),\n-    /// `type`s from an extern block\n-    ForeignTypeItem,\n-    MacroItem(Macro),\n-    ProcMacroItem(ProcMacro),\n-    PrimitiveItem(PrimitiveType),\n-    AssocConstItem(Type, Option<String>),\n-    AssocTypeItem(Vec<GenericBound>, Option<Type>),\n-    /// An item that has been stripped by a rustdoc pass\n-    StrippedItem(Box<ItemEnum>),\n-    KeywordItem(String),\n-}\n-\n-impl ItemEnum {\n-    pub fn is_associated(&self) -> bool {\n-        match *self {\n-            ItemEnum::TypedefItem(_, _) |\n-            ItemEnum::AssocTypeItem(_, _) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct Module {\n-    pub items: Vec<Item>,\n-    pub is_crate: bool,\n-}\n-\n impl Clean<Item> for doctree::Module<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let name = if self.name.is_some() {\n@@ -645,465 +377,12 @@ impl Clean<Item> for doctree::Module<'_> {\n     }\n }\n \n-pub struct ListAttributesIter<'a> {\n-    attrs: slice::Iter<'a, ast::Attribute>,\n-    current_list: vec::IntoIter<ast::NestedMetaItem>,\n-    name: Symbol,\n-}\n-\n-impl<'a> Iterator for ListAttributesIter<'a> {\n-    type Item = ast::NestedMetaItem;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if let Some(nested) = self.current_list.next() {\n-            return Some(nested);\n-        }\n-\n-        for attr in &mut self.attrs {\n-            if let Some(list) = attr.meta_item_list() {\n-                if attr.check_name(self.name) {\n-                    self.current_list = list.into_iter();\n-                    if let Some(nested) = self.current_list.next() {\n-                        return Some(nested);\n-                    }\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let lower = self.current_list.len();\n-        (lower, None)\n-    }\n-}\n-\n-pub trait AttributesExt {\n-    /// Finds an attribute as List and returns the list of attributes nested inside.\n-    fn lists(&self, name: Symbol) -> ListAttributesIter<'_>;\n-}\n-\n-impl AttributesExt for [ast::Attribute] {\n-    fn lists(&self, name: Symbol) -> ListAttributesIter<'_> {\n-        ListAttributesIter {\n-            attrs: self.iter(),\n-            current_list: Vec::new().into_iter(),\n-            name,\n-        }\n-    }\n-}\n-\n-pub trait NestedAttributesExt {\n-    /// Returns `true` if the attribute list contains a specific `Word`\n-    fn has_word(self, word: Symbol) -> bool;\n-}\n-\n-impl<I: IntoIterator<Item=ast::NestedMetaItem>> NestedAttributesExt for I {\n-    fn has_word(self, word: Symbol) -> bool {\n-        self.into_iter().any(|attr| attr.is_word() && attr.check_name(word))\n-    }\n-}\n-\n-/// A portion of documentation, extracted from a `#[doc]` attribute.\n-///\n-/// Each variant contains the line number within the complete doc-comment where the fragment\n-/// starts, as well as the Span where the corresponding doc comment or attribute is located.\n-///\n-/// Included files are kept separate from inline doc comments so that proper line-number\n-/// information can be given when a doctest fails. Sugared doc comments and \"raw\" doc comments are\n-/// kept separate because of issue #42760.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum DocFragment {\n-    /// A doc fragment created from a `///` or `//!` doc comment.\n-    SugaredDoc(usize, syntax_pos::Span, String),\n-    /// A doc fragment created from a \"raw\" `#[doc=\"\"]` attribute.\n-    RawDoc(usize, syntax_pos::Span, String),\n-    /// A doc fragment created from a `#[doc(include=\"filename\")]` attribute. Contains both the\n-    /// given filename and the file contents.\n-    Include(usize, syntax_pos::Span, String, String),\n-}\n-\n-impl DocFragment {\n-    pub fn as_str(&self) -> &str {\n-        match *self {\n-            DocFragment::SugaredDoc(_, _, ref s) => &s[..],\n-            DocFragment::RawDoc(_, _, ref s) => &s[..],\n-            DocFragment::Include(_, _, _, ref s) => &s[..],\n-        }\n-    }\n-\n-    pub fn span(&self) -> syntax_pos::Span {\n-        match *self {\n-            DocFragment::SugaredDoc(_, span, _) |\n-                DocFragment::RawDoc(_, span, _) |\n-                DocFragment::Include(_, span, _, _) => span,\n-        }\n-    }\n-}\n-\n-impl<'a> FromIterator<&'a DocFragment> for String {\n-    fn from_iter<T>(iter: T) -> Self\n-    where\n-        T: IntoIterator<Item = &'a DocFragment>\n-    {\n-        iter.into_iter().fold(String::new(), |mut acc, frag| {\n-            if !acc.is_empty() {\n-                acc.push('\\n');\n-            }\n-            match *frag {\n-                DocFragment::SugaredDoc(_, _, ref docs)\n-                    | DocFragment::RawDoc(_, _, ref docs)\n-                    | DocFragment::Include(_, _, _, ref docs) =>\n-                    acc.push_str(docs),\n-            }\n-\n-            acc\n-        })\n-    }\n-}\n-\n-#[derive(Clone, Debug, Default)]\n-pub struct Attributes {\n-    pub doc_strings: Vec<DocFragment>,\n-    pub other_attrs: Vec<ast::Attribute>,\n-    pub cfg: Option<Arc<Cfg>>,\n-    pub span: Option<syntax_pos::Span>,\n-    /// map from Rust paths to resolved defs and potential URL fragments\n-    pub links: Vec<(String, Option<DefId>, Option<String>)>,\n-    pub inner_docs: bool,\n-}\n-\n-impl Attributes {\n-    /// Extracts the content from an attribute `#[doc(cfg(content))]`.\n-    fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n-        use syntax::ast::NestedMetaItem::MetaItem;\n-\n-        if let ast::MetaItemKind::List(ref nmis) = mi.kind {\n-            if nmis.len() == 1 {\n-                if let MetaItem(ref cfg_mi) = nmis[0] {\n-                    if cfg_mi.check_name(sym::cfg) {\n-                        if let ast::MetaItemKind::List(ref cfg_nmis) = cfg_mi.kind {\n-                            if cfg_nmis.len() == 1 {\n-                                if let MetaItem(ref content_mi) = cfg_nmis[0] {\n-                                    return Some(content_mi);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    /// Reads a `MetaItem` from within an attribute, looks for whether it is a\n-    /// `#[doc(include=\"file\")]`, and returns the filename and contents of the file as loaded from\n-    /// its expansion.\n-    fn extract_include(mi: &ast::MetaItem)\n-        -> Option<(String, String)>\n-    {\n-        mi.meta_item_list().and_then(|list| {\n-            for meta in list {\n-                if meta.check_name(sym::include) {\n-                    // the actual compiled `#[doc(include=\"filename\")]` gets expanded to\n-                    // `#[doc(include(file=\"filename\", contents=\"file contents\")]` so we need to\n-                    // look for that instead\n-                    return meta.meta_item_list().and_then(|list| {\n-                        let mut filename: Option<String> = None;\n-                        let mut contents: Option<String> = None;\n-\n-                        for it in list {\n-                            if it.check_name(sym::file) {\n-                                if let Some(name) = it.value_str() {\n-                                    filename = Some(name.to_string());\n-                                }\n-                            } else if it.check_name(sym::contents) {\n-                                if let Some(docs) = it.value_str() {\n-                                    contents = Some(docs.to_string());\n-                                }\n-                            }\n-                        }\n-\n-                        if let (Some(filename), Some(contents)) = (filename, contents) {\n-                            Some((filename, contents))\n-                        } else {\n-                            None\n-                        }\n-                    });\n-                }\n-            }\n-\n-            None\n-        })\n-    }\n-\n-    pub fn has_doc_flag(&self, flag: Symbol) -> bool {\n-        for attr in &self.other_attrs {\n-            if !attr.check_name(sym::doc) { continue; }\n-\n-            if let Some(items) = attr.meta_item_list() {\n-                if items.iter().filter_map(|i| i.meta_item()).any(|it| it.check_name(flag)) {\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        false\n-    }\n-\n-    pub fn from_ast(diagnostic: &::errors::Handler,\n-                    attrs: &[ast::Attribute]) -> Attributes {\n-        let mut doc_strings = vec![];\n-        let mut sp = None;\n-        let mut cfg = Cfg::True;\n-        let mut doc_line = 0;\n-\n-        /// If `attr` is a doc comment, strips the leading and (if present)\n-        /// trailing comments symbols, e.g. `///`, `/**`, and `*/`. Otherwise,\n-        /// returns `attr` unchanged.\n-        pub fn with_doc_comment_markers_stripped<T>(\n-            attr: &Attribute,\n-            f: impl FnOnce(&Attribute) -> T\n-        ) -> T {\n-            match attr.kind {\n-                AttrKind::Normal(_) => {\n-                    f(attr)\n-                }\n-                AttrKind::DocComment(comment) => {\n-                    let comment =\n-                        Symbol::intern(&comments::strip_doc_comment_decoration(&comment.as_str()));\n-                    f(&Attribute {\n-                        kind: AttrKind::DocComment(comment),\n-                        id: attr.id,\n-                        style: attr.style,\n-                        span: attr.span,\n-                    })\n-                }\n-            }\n-        }\n-\n-        let other_attrs = attrs.iter().filter_map(|attr| {\n-            with_doc_comment_markers_stripped(attr, |attr| {\n-                if attr.check_name(sym::doc) {\n-                    if let Some(mi) = attr.meta() {\n-                        if let Some(value) = mi.value_str() {\n-                            // Extracted #[doc = \"...\"]\n-                            let value = value.to_string();\n-                            let line = doc_line;\n-                            doc_line += value.lines().count();\n-\n-                            if attr.is_doc_comment() {\n-                                doc_strings.push(DocFragment::SugaredDoc(line, attr.span, value));\n-                            } else {\n-                                doc_strings.push(DocFragment::RawDoc(line, attr.span, value));\n-                            }\n-\n-                            if sp.is_none() {\n-                                sp = Some(attr.span);\n-                            }\n-                            return None;\n-                        } else if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n-                            // Extracted #[doc(cfg(...))]\n-                            match Cfg::parse(cfg_mi) {\n-                                Ok(new_cfg) => cfg &= new_cfg,\n-                                Err(e) => diagnostic.span_err(e.span, e.msg),\n-                            }\n-                            return None;\n-                        } else if let Some((filename, contents)) = Attributes::extract_include(&mi)\n-                        {\n-                            let line = doc_line;\n-                            doc_line += contents.lines().count();\n-                            doc_strings.push(DocFragment::Include(line,\n-                                                                  attr.span,\n-                                                                  filename,\n-                                                                  contents));\n-                        }\n-                    }\n-                }\n-                Some(attr.clone())\n-            })\n-        }).collect();\n-\n-        // treat #[target_feature(enable = \"feat\")] attributes as if they were\n-        // #[doc(cfg(target_feature = \"feat\"))] attributes as well\n-        for attr in attrs.lists(sym::target_feature) {\n-            if attr.check_name(sym::enable) {\n-                if let Some(feat) = attr.value_str() {\n-                    let meta = attr::mk_name_value_item_str(\n-                        Ident::with_dummy_span(sym::target_feature), feat, DUMMY_SP\n-                    );\n-                    if let Ok(feat_cfg) = Cfg::parse(&meta) {\n-                        cfg &= feat_cfg;\n-                    }\n-                }\n-            }\n-        }\n-\n-        let inner_docs = attrs.iter()\n-                              .filter(|a| a.check_name(sym::doc))\n-                              .next()\n-                              .map_or(true, |a| a.style == AttrStyle::Inner);\n-\n-        Attributes {\n-            doc_strings,\n-            other_attrs,\n-            cfg: if cfg == Cfg::True { None } else { Some(Arc::new(cfg)) },\n-            span: sp,\n-            links: vec![],\n-            inner_docs,\n-        }\n-    }\n-\n-    /// Finds the `doc` attribute as a NameValue and returns the corresponding\n-    /// value found.\n-    pub fn doc_value(&self) -> Option<&str> {\n-        self.doc_strings.first().map(|s| s.as_str())\n-    }\n-\n-    /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n-    /// with newlines.\n-    pub fn collapsed_doc_value(&self) -> Option<String> {\n-        if !self.doc_strings.is_empty() {\n-            Some(self.doc_strings.iter().collect())\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Gets links as a vector\n-    ///\n-    /// Cache must be populated before call\n-    pub fn links(&self, krate: &CrateNum) -> Vec<(String, String)> {\n-        use crate::html::format::href;\n-\n-        self.links.iter().filter_map(|&(ref s, did, ref fragment)| {\n-            match did {\n-                Some(did) => {\n-                    if let Some((mut href, ..)) = href(did) {\n-                        if let Some(ref fragment) = *fragment {\n-                            href.push_str(\"#\");\n-                            href.push_str(fragment);\n-                        }\n-                        Some((s.clone(), href))\n-                    } else {\n-                        None\n-                    }\n-                }\n-                None => {\n-                    if let Some(ref fragment) = *fragment {\n-                        let cache = cache();\n-                        let url = match cache.extern_locations.get(krate) {\n-                            Some(&(_, ref src, ExternalLocation::Local)) =>\n-                                src.to_str().expect(\"invalid file path\"),\n-                            Some(&(_, _, ExternalLocation::Remote(ref s))) => s,\n-                            Some(&(_, _, ExternalLocation::Unknown)) | None =>\n-                                \"https://doc.rust-lang.org/nightly\",\n-                        };\n-                        // This is a primitive so the url is done \"by hand\".\n-                        let tail = fragment.find('#').unwrap_or_else(|| fragment.len());\n-                        Some((s.clone(),\n-                              format!(\"{}{}std/primitive.{}.html{}\",\n-                                      url,\n-                                      if !url.ends_with('/') { \"/\" } else { \"\" },\n-                                      &fragment[..tail],\n-                                      &fragment[tail..])))\n-                    } else {\n-                        panic!(\"This isn't a primitive?!\");\n-                    }\n-                }\n-            }\n-        }).collect()\n-    }\n-}\n-\n-impl PartialEq for Attributes {\n-    fn eq(&self, rhs: &Self) -> bool {\n-        self.doc_strings == rhs.doc_strings &&\n-        self.cfg == rhs.cfg &&\n-        self.span == rhs.span &&\n-        self.links == rhs.links &&\n-        self.other_attrs.iter().map(|attr| attr.id).eq(rhs.other_attrs.iter().map(|attr| attr.id))\n-    }\n-}\n-\n-impl Eq for Attributes {}\n-\n-impl Hash for Attributes {\n-    fn hash<H: Hasher>(&self, hasher: &mut H) {\n-        self.doc_strings.hash(hasher);\n-        self.cfg.hash(hasher);\n-        self.span.hash(hasher);\n-        self.links.hash(hasher);\n-        for attr in &self.other_attrs {\n-            attr.id.hash(hasher);\n-        }\n-    }\n-}\n-\n-impl AttributesExt for Attributes {\n-    fn lists(&self, name: Symbol) -> ListAttributesIter<'_> {\n-        self.other_attrs.lists(name)\n-    }\n-}\n-\n impl Clean<Attributes> for [ast::Attribute] {\n     fn clean(&self, cx: &DocContext<'_>) -> Attributes {\n         Attributes::from_ast(cx.sess().diagnostic(), self)\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericBound {\n-    TraitBound(PolyTrait, hir::TraitBoundModifier),\n-    Outlives(Lifetime),\n-}\n-\n-impl GenericBound {\n-    fn maybe_sized(cx: &DocContext<'_>) -> GenericBound {\n-        let did = cx.tcx.require_lang_item(lang_items::SizedTraitLangItem, None);\n-        let empty = cx.tcx.intern_substs(&[]);\n-        let path = external_path(cx, cx.tcx.item_name(did),\n-            Some(did), false, vec![], empty);\n-        inline::record_extern_fqn(cx, did, TypeKind::Trait);\n-        GenericBound::TraitBound(PolyTrait {\n-            trait_: ResolvedPath {\n-                path,\n-                param_names: None,\n-                did,\n-                is_generic: false,\n-            },\n-            generic_params: Vec::new(),\n-        }, hir::TraitBoundModifier::Maybe)\n-    }\n-\n-    fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n-        use rustc::hir::TraitBoundModifier as TBM;\n-        if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n-            if trait_.def_id() == cx.tcx.lang_items().sized_trait() {\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n-    fn get_poly_trait(&self) -> Option<PolyTrait> {\n-        if let GenericBound::TraitBound(ref p, _) = *self {\n-            return Some(p.clone())\n-        }\n-        None\n-    }\n-\n-    fn get_trait_type(&self) -> Option<Type> {\n-        if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, _) = *self {\n-            Some(trait_.clone())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n impl Clean<GenericBound> for hir::GenericBound {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n         match *self {\n@@ -1237,21 +516,6 @@ impl<'tcx> Clean<Option<Vec<GenericBound>>> for InternalSubsts<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Lifetime(String);\n-\n-impl Lifetime {\n-    pub fn get_ref<'a>(&'a self) -> &'a str {\n-        let Lifetime(ref s) = *self;\n-        let s: &'a str = s;\n-        s\n-    }\n-\n-    pub fn statik() -> Lifetime {\n-        Lifetime(\"'static\".to_string())\n-    }\n-}\n-\n impl Clean<Lifetime> for hir::Lifetime {\n     fn clean(&self, cx: &DocContext<'_>) -> Lifetime {\n         if self.hir_id != hir::DUMMY_HIR_ID {\n@@ -1332,23 +596,6 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub enum WherePredicate {\n-    BoundPredicate { ty: Type, bounds: Vec<GenericBound> },\n-    RegionPredicate { lifetime: Lifetime, bounds: Vec<GenericBound> },\n-    EqPredicate { lhs: Type, rhs: Type },\n-}\n-\n-impl WherePredicate {\n-    pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n-        match *self {\n-            WherePredicate::BoundPredicate { ref bounds, .. } => Some(bounds),\n-            WherePredicate::RegionPredicate { ref bounds, .. } => Some(bounds),\n-            _ => None,\n-        }\n-    }\n-}\n-\n impl Clean<WherePredicate> for hir::WherePredicate {\n     fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n         match *self {\n@@ -1470,73 +717,6 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericParamDefKind {\n-    Lifetime,\n-    Type {\n-        did: DefId,\n-        bounds: Vec<GenericBound>,\n-        default: Option<Type>,\n-        synthetic: Option<hir::SyntheticTyParamKind>,\n-    },\n-    Const {\n-        did: DefId,\n-        ty: Type,\n-    },\n-}\n-\n-impl GenericParamDefKind {\n-    pub fn is_type(&self) -> bool {\n-        match *self {\n-            GenericParamDefKind::Type { .. } => true,\n-            _ => false,\n-        }\n-    }\n-\n-    // FIXME(eddyb) this either returns the default of a type parameter, or the\n-    // type of a `const` parameter. It seems that the intention is to *visit*\n-    // any embedded types, but `get_type` seems to be the wrong name for that.\n-    pub fn get_type(&self) -> Option<Type> {\n-        match self {\n-            GenericParamDefKind::Type { default, .. } => default.clone(),\n-            GenericParamDefKind::Const { ty, .. } => Some(ty.clone()),\n-            GenericParamDefKind::Lifetime => None,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct GenericParamDef {\n-    pub name: String,\n-\n-    pub kind: GenericParamDefKind,\n-}\n-\n-impl GenericParamDef {\n-    pub fn is_synthetic_type_param(&self) -> bool {\n-        match self.kind {\n-            GenericParamDefKind::Lifetime |\n-            GenericParamDefKind::Const { .. } => false,\n-            GenericParamDefKind::Type { ref synthetic, .. } => synthetic.is_some(),\n-        }\n-    }\n-\n-    pub fn is_type(&self) -> bool {\n-        self.kind.is_type()\n-    }\n-\n-    pub fn get_type(&self) -> Option<Type> {\n-        self.kind.get_type()\n-    }\n-\n-    pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n-        match self.kind {\n-            GenericParamDefKind::Type { ref bounds, .. } => Some(bounds),\n-            _ => None,\n-        }\n-    }\n-}\n-\n impl Clean<GenericParamDef> for ty::GenericParamDef {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n@@ -1614,13 +794,6 @@ impl Clean<GenericParamDef> for hir::GenericParam {\n     }\n }\n \n-// maybe use a Generic enum and use Vec<Generic>?\n-#[derive(Clone, Debug, Default)]\n-pub struct Generics {\n-    pub params: Vec<GenericParamDef>,\n-    pub where_predicates: Vec<WherePredicate>,\n-}\n-\n impl Clean<Generics> for hir::Generics {\n     fn clean(&self, cx: &DocContext<'_>) -> Generics {\n         // Synthetic type-parameters are inserted after normal ones.\n@@ -1975,16 +1148,6 @@ pub fn get_all_types(\n     (all_types.into_iter().collect(), ret_types)\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Method {\n-    pub generics: Generics,\n-    pub decl: FnDecl,\n-    pub header: hir::FnHeader,\n-    pub defaultness: Option<hir::Defaultness>,\n-    pub all_types: Vec<Type>,\n-    pub ret_types: Vec<Type>,\n-}\n-\n impl<'a> Clean<Method> for (&'a hir::FnSig, &'a hir::Generics, hir::BodyId,\n                             Option<hir::Defaultness>) {\n     fn clean(&self, cx: &DocContext<'_>) -> Method {\n@@ -2003,24 +1166,6 @@ impl<'a> Clean<Method> for (&'a hir::FnSig, &'a hir::Generics, hir::BodyId,\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct TyMethod {\n-    pub header: hir::FnHeader,\n-    pub decl: FnDecl,\n-    pub generics: Generics,\n-    pub all_types: Vec<Type>,\n-    pub ret_types: Vec<Type>,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct Function {\n-    pub decl: FnDecl,\n-    pub generics: Generics,\n-    pub header: hir::FnHeader,\n-    pub all_types: Vec<Type>,\n-    pub ret_types: Vec<Type>,\n-}\n-\n impl Clean<Item> for doctree::Function<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let (generics, decl) = enter_impl_trait(cx, || {\n@@ -2053,49 +1198,6 @@ impl Clean<Item> for doctree::Function<'_> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct FnDecl {\n-    pub inputs: Arguments,\n-    pub output: FunctionRetTy,\n-    pub c_variadic: bool,\n-    pub attrs: Attributes,\n-}\n-\n-impl FnDecl {\n-    pub fn self_type(&self) -> Option<SelfTy> {\n-        self.inputs.values.get(0).and_then(|v| v.to_self())\n-    }\n-\n-    /// Returns the sugared return type for an async function.\n-    ///\n-    /// For example, if the return type is `impl std::future::Future<Output = i32>`, this function\n-    /// will return `i32`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the return type does not match the expected sugaring for async\n-    /// functions.\n-    pub fn sugared_async_return_type(&self) -> FunctionRetTy {\n-        match &self.output {\n-            FunctionRetTy::Return(Type::ImplTrait(bounds)) => {\n-                match &bounds[0] {\n-                    GenericBound::TraitBound(PolyTrait { trait_, .. }, ..) => {\n-                        let bindings = trait_.bindings().unwrap();\n-                        FunctionRetTy::Return(bindings[0].ty().clone())\n-                    }\n-                    _ => panic!(\"unexpected desugaring of async function\"),\n-                }\n-            }\n-            _ => panic!(\"unexpected desugaring of async function\"),\n-        }\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Arguments {\n-    pub values: Vec<Argument>,\n-}\n-\n impl<'a> Clean<Arguments> for (&'a [hir::Ty], &'a [ast::Ident]) {\n     fn clean(&self, cx: &DocContext<'_>) -> Arguments {\n         Arguments {\n@@ -2167,42 +1269,6 @@ impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Argument {\n-    pub type_: Type,\n-    pub name: String,\n-}\n-\n-#[derive(Clone, PartialEq, Debug)]\n-pub enum SelfTy {\n-    SelfValue,\n-    SelfBorrowed(Option<Lifetime>, Mutability),\n-    SelfExplicit(Type),\n-}\n-\n-impl Argument {\n-    pub fn to_self(&self) -> Option<SelfTy> {\n-        if self.name != \"self\" {\n-            return None;\n-        }\n-        if self.type_.is_self_type() {\n-            return Some(SelfValue);\n-        }\n-        match self.type_ {\n-            BorrowedRef{ref lifetime, mutability, ref type_} if type_.is_self_type() => {\n-                Some(SelfBorrowed(lifetime.clone(), mutability))\n-            }\n-            _ => Some(SelfExplicit(self.type_.clone()))\n-        }\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum FunctionRetTy {\n-    Return(Type),\n-    DefaultReturn,\n-}\n-\n impl Clean<FunctionRetTy> for hir::FunctionRetTy {\n     fn clean(&self, cx: &DocContext<'_>) -> FunctionRetTy {\n         match *self {\n@@ -2212,26 +1278,6 @@ impl Clean<FunctionRetTy> for hir::FunctionRetTy {\n     }\n }\n \n-impl GetDefId for FunctionRetTy {\n-    fn def_id(&self) -> Option<DefId> {\n-        match *self {\n-            Return(ref ty) => ty.def_id(),\n-            DefaultReturn => None,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct Trait {\n-    pub auto: bool,\n-    pub unsafety: hir::Unsafety,\n-    pub items: Vec<Item>,\n-    pub generics: Generics,\n-    pub bounds: Vec<GenericBound>,\n-    pub is_spotlight: bool,\n-    pub is_auto: bool,\n-}\n-\n impl Clean<Item> for doctree::Trait<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n@@ -2257,12 +1303,6 @@ impl Clean<Item> for doctree::Trait<'_> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct TraitAlias {\n-    pub generics: Generics,\n-    pub bounds: Vec<GenericBound>,\n-}\n-\n impl Clean<Item> for doctree::TraitAlias<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n@@ -2541,321 +1581,6 @@ impl Clean<Item> for ty::AssocItem {\n     }\n }\n \n-/// A trait reference, which may have higher ranked lifetimes.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct PolyTrait {\n-    pub trait_: Type,\n-    pub generic_params: Vec<GenericParamDef>,\n-}\n-\n-/// A representation of a type suitable for hyperlinking purposes. Ideally, one can get the original\n-/// type out of the AST/`TyCtxt` given one of these, if more information is needed. Most\n-/// importantly, it does not preserve mutability or boxes.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum Type {\n-    /// Structs/enums/traits (most that would be an `hir::TyKind::Path`).\n-    ResolvedPath {\n-        path: Path,\n-        param_names: Option<Vec<GenericBound>>,\n-        did: DefId,\n-        /// `true` if is a `T::Name` path for associated types.\n-        is_generic: bool,\n-    },\n-    /// For parameterized types, so the consumer of the JSON don't go\n-    /// looking for types which don't exist anywhere.\n-    Generic(String),\n-    /// Primitives are the fixed-size numeric types (plus int/usize/float), char,\n-    /// arrays, slices, and tuples.\n-    Primitive(PrimitiveType),\n-    /// `extern \"ABI\" fn`\n-    BareFunction(Box<BareFunctionDecl>),\n-    Tuple(Vec<Type>),\n-    Slice(Box<Type>),\n-    Array(Box<Type>, String),\n-    Never,\n-    RawPointer(Mutability, Box<Type>),\n-    BorrowedRef {\n-        lifetime: Option<Lifetime>,\n-        mutability: Mutability,\n-        type_: Box<Type>,\n-    },\n-\n-    // `<Type as Trait>::Name`\n-    QPath {\n-        name: String,\n-        self_type: Box<Type>,\n-        trait_: Box<Type>\n-    },\n-\n-    // `_`\n-    Infer,\n-\n-    // `impl TraitA + TraitB + ...`\n-    ImplTrait(Vec<GenericBound>),\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Hash, Copy, Debug)]\n-pub enum PrimitiveType {\n-    Isize, I8, I16, I32, I64, I128,\n-    Usize, U8, U16, U32, U64, U128,\n-    F32, F64,\n-    Char,\n-    Bool,\n-    Str,\n-    Slice,\n-    Array,\n-    Tuple,\n-    Unit,\n-    RawPointer,\n-    Reference,\n-    Fn,\n-    Never,\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-pub enum TypeKind {\n-    Enum,\n-    Function,\n-    Module,\n-    Const,\n-    Static,\n-    Struct,\n-    Union,\n-    Trait,\n-    Typedef,\n-    Foreign,\n-    Macro,\n-    Attr,\n-    Derive,\n-    TraitAlias,\n-}\n-\n-pub trait GetDefId {\n-    fn def_id(&self) -> Option<DefId>;\n-}\n-\n-impl<T: GetDefId> GetDefId for Option<T> {\n-    fn def_id(&self) -> Option<DefId> {\n-        self.as_ref().and_then(|d| d.def_id())\n-    }\n-}\n-\n-impl Type {\n-    pub fn primitive_type(&self) -> Option<PrimitiveType> {\n-        match *self {\n-            Primitive(p) | BorrowedRef { type_: box Primitive(p), ..} => Some(p),\n-            Slice(..) | BorrowedRef { type_: box Slice(..), .. } => Some(PrimitiveType::Slice),\n-            Array(..) | BorrowedRef { type_: box Array(..), .. } => Some(PrimitiveType::Array),\n-            Tuple(ref tys) => if tys.is_empty() {\n-                Some(PrimitiveType::Unit)\n-            } else {\n-                Some(PrimitiveType::Tuple)\n-            },\n-            RawPointer(..) => Some(PrimitiveType::RawPointer),\n-            BorrowedRef { type_: box Generic(..), .. } => Some(PrimitiveType::Reference),\n-            BareFunction(..) => Some(PrimitiveType::Fn),\n-            Never => Some(PrimitiveType::Never),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn is_generic(&self) -> bool {\n-        match *self {\n-            ResolvedPath { is_generic, .. } => is_generic,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_self_type(&self) -> bool {\n-        match *self {\n-            Generic(ref name) => name == \"Self\",\n-            _ => false\n-        }\n-    }\n-\n-    pub fn generics(&self) -> Option<Vec<Type>> {\n-        match *self {\n-            ResolvedPath { ref path, .. } => {\n-                path.segments.last().and_then(|seg| {\n-                    if let GenericArgs::AngleBracketed { ref args, .. } = seg.args {\n-                        Some(args.iter().filter_map(|arg| match arg {\n-                            GenericArg::Type(ty) => Some(ty.clone()),\n-                            _ => None,\n-                        }).collect())\n-                    } else {\n-                        None\n-                    }\n-                })\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn bindings(&self) -> Option<&[TypeBinding]> {\n-        match *self {\n-            ResolvedPath { ref path, .. } => {\n-                path.segments.last().and_then(|seg| {\n-                    if let GenericArgs::AngleBracketed { ref bindings, .. } = seg.args {\n-                        Some(&**bindings)\n-                    } else {\n-                        None\n-                    }\n-                })\n-            }\n-            _ => None\n-        }\n-    }\n-\n-    pub fn is_full_generic(&self) -> bool {\n-        match *self {\n-            Type::Generic(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn projection(&self) -> Option<(&Type, DefId, &str)> {\n-        let (self_, trait_, name) = match self {\n-            QPath { ref self_type, ref trait_, ref name } => {\n-                (self_type, trait_, name)\n-            }\n-            _ => return None,\n-        };\n-        let trait_did = match **trait_ {\n-            ResolvedPath { did, .. } => did,\n-            _ => return None,\n-        };\n-        Some((&self_, trait_did, name))\n-    }\n-\n-}\n-\n-impl GetDefId for Type {\n-    fn def_id(&self) -> Option<DefId> {\n-        match *self {\n-            ResolvedPath { did, .. } => Some(did),\n-            Primitive(p) => crate::html::render::cache().primitive_locations.get(&p).cloned(),\n-            BorrowedRef { type_: box Generic(..), .. } =>\n-                Primitive(PrimitiveType::Reference).def_id(),\n-            BorrowedRef { ref type_, .. } => type_.def_id(),\n-            Tuple(ref tys) => if tys.is_empty() {\n-                Primitive(PrimitiveType::Unit).def_id()\n-            } else {\n-                Primitive(PrimitiveType::Tuple).def_id()\n-            },\n-            BareFunction(..) => Primitive(PrimitiveType::Fn).def_id(),\n-            Never => Primitive(PrimitiveType::Never).def_id(),\n-            Slice(..) => Primitive(PrimitiveType::Slice).def_id(),\n-            Array(..) => Primitive(PrimitiveType::Array).def_id(),\n-            RawPointer(..) => Primitive(PrimitiveType::RawPointer).def_id(),\n-            QPath { ref self_type, .. } => self_type.def_id(),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-impl PrimitiveType {\n-    fn from_str(s: &str) -> Option<PrimitiveType> {\n-        match s {\n-            \"isize\" => Some(PrimitiveType::Isize),\n-            \"i8\" => Some(PrimitiveType::I8),\n-            \"i16\" => Some(PrimitiveType::I16),\n-            \"i32\" => Some(PrimitiveType::I32),\n-            \"i64\" => Some(PrimitiveType::I64),\n-            \"i128\" => Some(PrimitiveType::I128),\n-            \"usize\" => Some(PrimitiveType::Usize),\n-            \"u8\" => Some(PrimitiveType::U8),\n-            \"u16\" => Some(PrimitiveType::U16),\n-            \"u32\" => Some(PrimitiveType::U32),\n-            \"u64\" => Some(PrimitiveType::U64),\n-            \"u128\" => Some(PrimitiveType::U128),\n-            \"bool\" => Some(PrimitiveType::Bool),\n-            \"char\" => Some(PrimitiveType::Char),\n-            \"str\" => Some(PrimitiveType::Str),\n-            \"f32\" => Some(PrimitiveType::F32),\n-            \"f64\" => Some(PrimitiveType::F64),\n-            \"array\" => Some(PrimitiveType::Array),\n-            \"slice\" => Some(PrimitiveType::Slice),\n-            \"tuple\" => Some(PrimitiveType::Tuple),\n-            \"unit\" => Some(PrimitiveType::Unit),\n-            \"pointer\" => Some(PrimitiveType::RawPointer),\n-            \"reference\" => Some(PrimitiveType::Reference),\n-            \"fn\" => Some(PrimitiveType::Fn),\n-            \"never\" => Some(PrimitiveType::Never),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn as_str(&self) -> &'static str {\n-        use self::PrimitiveType::*;\n-        match *self {\n-            Isize => \"isize\",\n-            I8 => \"i8\",\n-            I16 => \"i16\",\n-            I32 => \"i32\",\n-            I64 => \"i64\",\n-            I128 => \"i128\",\n-            Usize => \"usize\",\n-            U8 => \"u8\",\n-            U16 => \"u16\",\n-            U32 => \"u32\",\n-            U64 => \"u64\",\n-            U128 => \"u128\",\n-            F32 => \"f32\",\n-            F64 => \"f64\",\n-            Str => \"str\",\n-            Bool => \"bool\",\n-            Char => \"char\",\n-            Array => \"array\",\n-            Slice => \"slice\",\n-            Tuple => \"tuple\",\n-            Unit => \"unit\",\n-            RawPointer => \"pointer\",\n-            Reference => \"reference\",\n-            Fn => \"fn\",\n-            Never => \"never\",\n-        }\n-    }\n-\n-    pub fn to_url_str(&self) -> &'static str {\n-        self.as_str()\n-    }\n-}\n-\n-impl From<ast::IntTy> for PrimitiveType {\n-    fn from(int_ty: ast::IntTy) -> PrimitiveType {\n-        match int_ty {\n-            ast::IntTy::Isize => PrimitiveType::Isize,\n-            ast::IntTy::I8 => PrimitiveType::I8,\n-            ast::IntTy::I16 => PrimitiveType::I16,\n-            ast::IntTy::I32 => PrimitiveType::I32,\n-            ast::IntTy::I64 => PrimitiveType::I64,\n-            ast::IntTy::I128 => PrimitiveType::I128,\n-        }\n-    }\n-}\n-\n-impl From<ast::UintTy> for PrimitiveType {\n-    fn from(uint_ty: ast::UintTy) -> PrimitiveType {\n-        match uint_ty {\n-            ast::UintTy::Usize => PrimitiveType::Usize,\n-            ast::UintTy::U8 => PrimitiveType::U8,\n-            ast::UintTy::U16 => PrimitiveType::U16,\n-            ast::UintTy::U32 => PrimitiveType::U32,\n-            ast::UintTy::U64 => PrimitiveType::U64,\n-            ast::UintTy::U128 => PrimitiveType::U128,\n-        }\n-    }\n-}\n-\n-impl From<ast::FloatTy> for PrimitiveType {\n-    fn from(float_ty: ast::FloatTy) -> PrimitiveType {\n-        match float_ty {\n-            ast::FloatTy::F32 => PrimitiveType::F32,\n-            ast::FloatTy::F64 => PrimitiveType::F64,\n-        }\n-    }\n-}\n-\n impl Clean<Type> for hir::Ty {\n     fn clean(&self, cx: &DocContext<'_>) -> Type {\n         use rustc::hir::*;\n@@ -3310,14 +2035,6 @@ impl Clean<Item> for ty::FieldDef {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum Visibility {\n-    Public,\n-    Inherited,\n-    Crate,\n-    Restricted(DefId, Path),\n-}\n-\n impl Clean<Visibility> for hir::Visibility {\n     fn clean(&self, cx: &DocContext<'_>) -> Visibility {\n         match self.node {\n@@ -3339,22 +2056,6 @@ impl Clean<Visibility> for ty::Visibility {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Struct {\n-    pub struct_type: doctree::StructType,\n-    pub generics: Generics,\n-    pub fields: Vec<Item>,\n-    pub fields_stripped: bool,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct Union {\n-    pub struct_type: doctree::StructType,\n-    pub generics: Generics,\n-    pub fields: Vec<Item>,\n-    pub fields_stripped: bool,\n-}\n-\n impl Clean<Item> for doctree::Struct<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n@@ -3395,16 +2096,6 @@ impl Clean<Item> for doctree::Union<'_> {\n     }\n }\n \n-/// This is a more limited form of the standard Struct, different in that\n-/// it lacks the things most items have (name, id, parameterization). Found\n-/// only as a variant in an enum.\n-#[derive(Clone, Debug)]\n-pub struct VariantStruct {\n-    pub struct_type: doctree::StructType,\n-    pub fields: Vec<Item>,\n-    pub fields_stripped: bool,\n-}\n-\n impl Clean<VariantStruct> for ::rustc::hir::VariantData {\n     fn clean(&self, cx: &DocContext<'_>) -> VariantStruct {\n         VariantStruct {\n@@ -3415,13 +2106,6 @@ impl Clean<VariantStruct> for ::rustc::hir::VariantData {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Enum {\n-    pub variants: IndexVec<VariantIdx, Item>,\n-    pub generics: Generics,\n-    pub variants_stripped: bool,\n-}\n-\n impl Clean<Item> for doctree::Enum<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n@@ -3441,11 +2125,6 @@ impl Clean<Item> for doctree::Enum<'_> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Variant {\n-    pub kind: VariantKind,\n-}\n-\n impl Clean<Item> for doctree::Variant<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n@@ -3504,13 +2183,6 @@ impl Clean<Item> for ty::VariantDef {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub enum VariantKind {\n-    CLike,\n-    Tuple(Vec<Type>),\n-    Struct(VariantStruct),\n-}\n-\n impl Clean<VariantKind> for hir::VariantData {\n     fn clean(&self, cx: &DocContext<'_>) -> VariantKind {\n         match self {\n@@ -3522,31 +2194,6 @@ impl Clean<VariantKind> for hir::VariantData {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Span {\n-    pub filename: FileName,\n-    pub loline: usize,\n-    pub locol: usize,\n-    pub hiline: usize,\n-    pub hicol: usize,\n-    pub original: syntax_pos::Span,\n-}\n-\n-impl Span {\n-    pub fn empty() -> Span {\n-        Span {\n-            filename: FileName::Anon(0),\n-            loline: 0, locol: 0,\n-            hiline: 0, hicol: 0,\n-            original: syntax_pos::DUMMY_SP,\n-        }\n-    }\n-\n-    pub fn span(&self) -> syntax_pos::Span {\n-        self.original\n-    }\n-}\n-\n impl Clean<Span> for syntax_pos::Span {\n     fn clean(&self, cx: &DocContext<'_>) -> Span {\n         if self.is_dummy() {\n@@ -3568,19 +2215,6 @@ impl Clean<Span> for syntax_pos::Span {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Path {\n-    pub global: bool,\n-    pub res: Res,\n-    pub segments: Vec<PathSegment>,\n-}\n-\n-impl Path {\n-    pub fn last_name(&self) -> &str {\n-        self.segments.last().expect(\"segments were empty\").name.as_str()\n-    }\n-}\n-\n impl Clean<Path> for hir::Path {\n     fn clean(&self, cx: &DocContext<'_>) -> Path {\n         Path {\n@@ -3591,25 +2225,6 @@ impl Clean<Path> for hir::Path {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericArg {\n-    Lifetime(Lifetime),\n-    Type(Type),\n-    Const(Constant),\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericArgs {\n-    AngleBracketed {\n-        args: Vec<GenericArg>,\n-        bindings: Vec<TypeBinding>,\n-    },\n-    Parenthesized {\n-        inputs: Vec<Type>,\n-        output: Option<Type>,\n-    }\n-}\n-\n impl Clean<GenericArgs> for hir::GenericArgs {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericArgs {\n         if self.parenthesized {\n@@ -3638,12 +2253,6 @@ impl Clean<GenericArgs> for hir::GenericArgs {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct PathSegment {\n-    pub name: String,\n-    pub args: GenericArgs,\n-}\n-\n impl Clean<PathSegment> for hir::PathSegment {\n     fn clean(&self, cx: &DocContext<'_>) -> PathSegment {\n         PathSegment {\n@@ -3727,12 +2336,6 @@ impl Clean<String> for ast::Name {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Typedef {\n-    pub type_: Type,\n-    pub generics: Generics,\n-}\n-\n impl Clean<Item> for doctree::Typedef<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n@@ -3751,12 +2354,6 @@ impl Clean<Item> for doctree::Typedef<'_> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct OpaqueTy {\n-    pub bounds: Vec<GenericBound>,\n-    pub generics: Generics,\n-}\n-\n impl Clean<Item> for doctree::OpaqueTy<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n@@ -3775,14 +2372,6 @@ impl Clean<Item> for doctree::OpaqueTy<'_> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct BareFunctionDecl {\n-    pub unsafety: hir::Unsafety,\n-    pub generic_params: Vec<GenericParamDef>,\n-    pub decl: FnDecl,\n-    pub abi: Abi,\n-}\n-\n impl Clean<BareFunctionDecl> for hir::BareFnTy {\n     fn clean(&self, cx: &DocContext<'_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, || {\n@@ -3797,16 +2386,6 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Static {\n-    pub type_: Type,\n-    pub mutability: Mutability,\n-    /// It's useful to have the value of a static documented, but I have no\n-    /// desire to represent expressions (that'd basically be all of the AST,\n-    /// which is huge!). So, have a string.\n-    pub expr: String,\n-}\n-\n impl Clean<Item> for doctree::Static<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         debug!(\"cleaning static {}: {:?}\", self.name.clean(cx), self);\n@@ -3827,12 +2406,6 @@ impl Clean<Item> for doctree::Static<'_> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct Constant {\n-    pub type_: Type,\n-    pub expr: String,\n-}\n-\n impl Clean<Item> for doctree::Constant<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n@@ -3851,12 +2424,6 @@ impl Clean<Item> for doctree::Constant<'_> {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Copy, Hash)]\n-pub enum Mutability {\n-    Mutable,\n-    Immutable,\n-}\n-\n impl Clean<Mutability> for hir::Mutability {\n     fn clean(&self, _: &DocContext<'_>) -> Mutability {\n         match self {\n@@ -3866,12 +2433,6 @@ impl Clean<Mutability> for hir::Mutability {\n     }\n }\n \n-#[derive(Clone, PartialEq, Debug)]\n-pub enum ImplPolarity {\n-    Positive,\n-    Negative,\n-}\n-\n impl Clean<ImplPolarity> for ty::ImplPolarity {\n     fn clean(&self, _: &DocContext<'_>) -> ImplPolarity {\n         match self {\n@@ -3883,19 +2444,6 @@ impl Clean<ImplPolarity> for ty::ImplPolarity {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Impl {\n-    pub unsafety: hir::Unsafety,\n-    pub generics: Generics,\n-    pub provided_trait_methods: FxHashSet<String>,\n-    pub trait_: Option<Type>,\n-    pub for_: Type,\n-    pub items: Vec<Item>,\n-    pub polarity: Option<ImplPolarity>,\n-    pub synthetic: bool,\n-    pub blanket_impl: Option<Type>,\n-}\n-\n pub fn get_auto_trait_and_blanket_impls(\n     cx: &DocContext<'tcx>,\n     ty: Ty<'tcx>,\n@@ -4115,20 +2663,6 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub enum Import {\n-    // use source as str;\n-    Simple(String, ImportSource),\n-    // use source::*;\n-    Glob(ImportSource)\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct ImportSource {\n-    pub path: Path,\n-    pub did: Option<DefId>,\n-}\n-\n impl Clean<Item> for doctree::ForeignItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let inner = match self.kind {\n@@ -4340,12 +2874,6 @@ fn resolve_use_source(cx: &DocContext<'_>, path: Path) -> ImportSource {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Macro {\n-    pub source: String,\n-    pub imported_from: Option<String>,\n-}\n-\n impl Clean<Item> for doctree::Macro<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let name = self.name.clean(cx);\n@@ -4369,12 +2897,6 @@ impl Clean<Item> for doctree::Macro<'_> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct ProcMacro {\n-    pub kind: MacroKind,\n-    pub helpers: Vec<String>,\n-}\n-\n impl Clean<Item> for doctree::ProcMacro<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n@@ -4393,22 +2915,6 @@ impl Clean<Item> for doctree::ProcMacro<'_> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Stability {\n-    pub level: stability::StabilityLevel,\n-    pub feature: Option<String>,\n-    pub since: String,\n-    pub deprecation: Option<Deprecation>,\n-    pub unstable_reason: Option<String>,\n-    pub issue: Option<NonZeroU32>,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct Deprecation {\n-    pub since: Option<String>,\n-    pub note: Option<String>,\n-}\n-\n impl Clean<Stability> for attr::Stability {\n     fn clean(&self, _: &DocContext<'_>) -> Stability {\n         Stability {\n@@ -4451,33 +2957,6 @@ impl Clean<Deprecation> for attr::Deprecation {\n     }\n }\n \n-/// An type binding on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n-/// `A: Send + Sync` in `Foo<A: Send + Sync>`).\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct TypeBinding {\n-    pub name: String,\n-    pub kind: TypeBindingKind,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum TypeBindingKind {\n-    Equality {\n-        ty: Type,\n-    },\n-    Constraint {\n-        bounds: Vec<GenericBound>,\n-    },\n-}\n-\n-impl TypeBinding {\n-    pub fn ty(&self) -> &Type {\n-        match self.kind {\n-            TypeBindingKind::Equality { ref ty } => ty,\n-            _ => panic!(\"expected equality type binding for parenthesized generic args\"),\n-        }\n-    }\n-}\n-\n impl Clean<TypeBinding> for hir::TypeBinding {\n     fn clean(&self, cx: &DocContext<'_>) -> TypeBinding {\n         TypeBinding {"}, {"sha": "bd3f2a3690a27b6b7d33454f13b1edd672c44dd7", "filename": "src/librustdoc/clean/types.rs", "status": "added", "additions": 1545, "deletions": 0, "changes": 1545, "blob_url": "https://github.com/rust-lang/rust/blob/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=f9441ad687cd51d4400aab48a1d0a630c5b95738", "patch": "@@ -0,0 +1,1545 @@\n+use std::fmt;\n+use std::hash::{Hash, Hasher};\n+use std::default::Default;\n+use std::{slice, vec};\n+use std::num::NonZeroU32;\n+use std::iter::FromIterator;\n+use std::rc::Rc;\n+use std::cell::RefCell;\n+use std::sync::Arc;\n+\n+use rustc::middle::lang_items;\n+use rustc::middle::stability;\n+use rustc::hir;\n+use rustc::hir::def::Res;\n+use rustc::hir::def_id::{CrateNum, DefId};\n+use rustc::ty::layout::VariantIdx;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use rustc_index::vec::IndexVec;\n+use rustc_target::spec::abi::Abi;\n+use syntax::ast::{self, Attribute, AttrStyle, AttrKind, Ident};\n+use syntax::attr;\n+use syntax::util::comments;\n+use syntax::source_map::DUMMY_SP;\n+use syntax_pos::hygiene::MacroKind;\n+use syntax_pos::symbol::{Symbol, sym};\n+use syntax_pos::{self, FileName};\n+\n+use crate::core::DocContext;\n+use crate::clean::cfg::Cfg;\n+use crate::clean::inline;\n+use crate::clean::external_path;\n+use crate::clean::types::Type::{QPath, ResolvedPath};\n+use crate::doctree;\n+use crate::html::item_type::ItemType;\n+use crate::html::render::{cache, ExternalLocation};\n+\n+use self::Type::*;\n+use self::ItemEnum::*;\n+use self::SelfTy::*;\n+use self::FunctionRetTy::*;\n+\n+thread_local!(pub static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> = Default::default());\n+\n+#[derive(Clone, Debug)]\n+pub struct Crate {\n+    pub name: String,\n+    pub version: Option<String>,\n+    pub src: FileName,\n+    pub module: Option<Item>,\n+    pub externs: Vec<(CrateNum, ExternalCrate)>,\n+    pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n+    // These are later on moved into `CACHEKEY`, leaving the map empty.\n+    // Only here so that they can be filtered through the rustdoc passes.\n+    pub external_traits: Rc<RefCell<FxHashMap<DefId, Trait>>>,\n+    pub masked_crates: FxHashSet<CrateNum>,\n+    pub collapsed: bool,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct ExternalCrate {\n+    pub name: String,\n+    pub src: FileName,\n+    pub attrs: Attributes,\n+    pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n+    pub keywords: Vec<(DefId, String, Attributes)>,\n+}\n+\n+/// Anything with a source location and set of attributes and, optionally, a\n+/// name. That is, anything that can be documented. This doesn't correspond\n+/// directly to the AST's concept of an item; it's a strict superset.\n+#[derive(Clone)]\n+pub struct Item {\n+    /// Stringified span\n+    pub source: Span,\n+    /// Not everything has a name. E.g., impls\n+    pub name: Option<String>,\n+    pub attrs: Attributes,\n+    pub inner: ItemEnum,\n+    pub visibility: Visibility,\n+    pub def_id: DefId,\n+    pub stability: Option<Stability>,\n+    pub deprecation: Option<Deprecation>,\n+}\n+\n+impl fmt::Debug for Item {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let fake = MAX_DEF_ID.with(|m| m.borrow().get(&self.def_id.krate)\n+                                   .map(|id| self.def_id >= *id).unwrap_or(false));\n+        let def_id: &dyn fmt::Debug = if fake { &\"**FAKE**\" } else { &self.def_id };\n+\n+        fmt.debug_struct(\"Item\")\n+            .field(\"source\", &self.source)\n+            .field(\"name\", &self.name)\n+            .field(\"attrs\", &self.attrs)\n+            .field(\"inner\", &self.inner)\n+            .field(\"visibility\", &self.visibility)\n+            .field(\"def_id\", def_id)\n+            .field(\"stability\", &self.stability)\n+            .field(\"deprecation\", &self.deprecation)\n+            .finish()\n+    }\n+}\n+\n+impl Item {\n+    /// Finds the `doc` attribute as a NameValue and returns the corresponding\n+    /// value found.\n+    pub fn doc_value(&self) -> Option<&str> {\n+        self.attrs.doc_value()\n+    }\n+\n+    /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n+    /// with newlines.\n+    pub fn collapsed_doc_value(&self) -> Option<String> {\n+        self.attrs.collapsed_doc_value()\n+    }\n+\n+    pub fn links(&self) -> Vec<(String, String)> {\n+        self.attrs.links(&self.def_id.krate)\n+    }\n+\n+    pub fn is_crate(&self) -> bool {\n+        match self.inner {\n+            StrippedItem(box ModuleItem(Module { is_crate: true, ..})) |\n+            ModuleItem(Module { is_crate: true, ..}) => true,\n+            _ => false,\n+        }\n+    }\n+    pub fn is_mod(&self) -> bool {\n+        self.type_() == ItemType::Module\n+    }\n+    pub fn is_trait(&self) -> bool {\n+        self.type_() == ItemType::Trait\n+    }\n+    pub fn is_struct(&self) -> bool {\n+        self.type_() == ItemType::Struct\n+    }\n+    pub fn is_enum(&self) -> bool {\n+        self.type_() == ItemType::Enum\n+    }\n+    pub fn is_variant(&self) -> bool {\n+        self.type_() == ItemType::Variant\n+    }\n+    pub fn is_associated_type(&self) -> bool {\n+        self.type_() == ItemType::AssocType\n+    }\n+    pub fn is_associated_const(&self) -> bool {\n+        self.type_() == ItemType::AssocConst\n+    }\n+    pub fn is_method(&self) -> bool {\n+        self.type_() == ItemType::Method\n+    }\n+    pub fn is_ty_method(&self) -> bool {\n+        self.type_() == ItemType::TyMethod\n+    }\n+    pub fn is_typedef(&self) -> bool {\n+        self.type_() == ItemType::Typedef\n+    }\n+    pub fn is_primitive(&self) -> bool {\n+        self.type_() == ItemType::Primitive\n+    }\n+    pub fn is_union(&self) -> bool {\n+        self.type_() == ItemType::Union\n+    }\n+    pub fn is_import(&self) -> bool {\n+        self.type_() == ItemType::Import\n+    }\n+    pub fn is_extern_crate(&self) -> bool {\n+        self.type_() == ItemType::ExternCrate\n+    }\n+    pub fn is_keyword(&self) -> bool {\n+        self.type_() == ItemType::Keyword\n+    }\n+    pub fn is_stripped(&self) -> bool {\n+        match self.inner { StrippedItem(..) => true, _ => false }\n+    }\n+    pub fn has_stripped_fields(&self) -> Option<bool> {\n+        match self.inner {\n+            StructItem(ref _struct) => Some(_struct.fields_stripped),\n+            UnionItem(ref union) => Some(union.fields_stripped),\n+            VariantItem(Variant { kind: VariantKind::Struct(ref vstruct)} ) => {\n+                Some(vstruct.fields_stripped)\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn stability_class(&self) -> Option<String> {\n+        self.stability.as_ref().and_then(|ref s| {\n+            let mut classes = Vec::with_capacity(2);\n+\n+            if s.level == stability::Unstable {\n+                classes.push(\"unstable\");\n+            }\n+\n+            if s.deprecation.is_some() {\n+                classes.push(\"deprecated\");\n+            }\n+\n+            if classes.len() != 0 {\n+                Some(classes.join(\" \"))\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    pub fn stable_since(&self) -> Option<&str> {\n+        self.stability.as_ref().map(|s| &s.since[..])\n+    }\n+\n+    pub fn is_non_exhaustive(&self) -> bool {\n+        self.attrs.other_attrs.iter()\n+            .any(|a| a.check_name(sym::non_exhaustive))\n+    }\n+\n+    /// Returns a documentation-level item type from the item.\n+    pub fn type_(&self) -> ItemType {\n+        ItemType::from(self)\n+    }\n+\n+    /// Returns the info in the item's `#[deprecated]` or `#[rustc_deprecated]` attributes.\n+    ///\n+    /// If the item is not deprecated, returns `None`.\n+    pub fn deprecation(&self) -> Option<&Deprecation> {\n+        self.deprecation\n+            .as_ref()\n+            .or_else(|| self.stability.as_ref().and_then(|s| s.deprecation.as_ref()))\n+    }\n+    pub fn is_default(&self) -> bool {\n+        match self.inner {\n+            ItemEnum::MethodItem(ref meth) => {\n+                if let Some(defaultness) = meth.defaultness {\n+                    defaultness.has_value() && !defaultness.is_final()\n+                } else {\n+                    false\n+                }\n+            }\n+            _ => false,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum ItemEnum {\n+    ExternCrateItem(String, Option<String>),\n+    ImportItem(Import),\n+    StructItem(Struct),\n+    UnionItem(Union),\n+    EnumItem(Enum),\n+    FunctionItem(Function),\n+    ModuleItem(Module),\n+    TypedefItem(Typedef, bool /* is associated type */),\n+    OpaqueTyItem(OpaqueTy, bool /* is associated type */),\n+    StaticItem(Static),\n+    ConstantItem(Constant),\n+    TraitItem(Trait),\n+    TraitAliasItem(TraitAlias),\n+    ImplItem(Impl),\n+    /// A method signature only. Used for required methods in traits (ie,\n+    /// non-default-methods).\n+    TyMethodItem(TyMethod),\n+    /// A method with a body.\n+    MethodItem(Method),\n+    StructFieldItem(Type),\n+    VariantItem(Variant),\n+    /// `fn`s from an extern block\n+    ForeignFunctionItem(Function),\n+    /// `static`s from an extern block\n+    ForeignStaticItem(Static),\n+    /// `type`s from an extern block\n+    ForeignTypeItem,\n+    MacroItem(Macro),\n+    ProcMacroItem(ProcMacro),\n+    PrimitiveItem(PrimitiveType),\n+    AssocConstItem(Type, Option<String>),\n+    AssocTypeItem(Vec<GenericBound>, Option<Type>),\n+    /// An item that has been stripped by a rustdoc pass\n+    StrippedItem(Box<ItemEnum>),\n+    KeywordItem(String),\n+}\n+\n+impl ItemEnum {\n+    pub fn is_associated(&self) -> bool {\n+        match *self {\n+            ItemEnum::TypedefItem(_, _) |\n+            ItemEnum::AssocTypeItem(_, _) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Module {\n+    pub items: Vec<Item>,\n+    pub is_crate: bool,\n+}\n+\n+pub struct ListAttributesIter<'a> {\n+    attrs: slice::Iter<'a, ast::Attribute>,\n+    current_list: vec::IntoIter<ast::NestedMetaItem>,\n+    name: Symbol,\n+}\n+\n+impl<'a> Iterator for ListAttributesIter<'a> {\n+    type Item = ast::NestedMetaItem;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let Some(nested) = self.current_list.next() {\n+            return Some(nested);\n+        }\n+\n+        for attr in &mut self.attrs {\n+            if let Some(list) = attr.meta_item_list() {\n+                if attr.check_name(self.name) {\n+                    self.current_list = list.into_iter();\n+                    if let Some(nested) = self.current_list.next() {\n+                        return Some(nested);\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let lower = self.current_list.len();\n+        (lower, None)\n+    }\n+}\n+\n+pub trait AttributesExt {\n+    /// Finds an attribute as List and returns the list of attributes nested inside.\n+    fn lists(&self, name: Symbol) -> ListAttributesIter<'_>;\n+}\n+\n+impl AttributesExt for [ast::Attribute] {\n+    fn lists(&self, name: Symbol) -> ListAttributesIter<'_> {\n+        ListAttributesIter {\n+            attrs: self.iter(),\n+            current_list: Vec::new().into_iter(),\n+            name,\n+        }\n+    }\n+}\n+\n+pub trait NestedAttributesExt {\n+    /// Returns `true` if the attribute list contains a specific `Word`\n+    fn has_word(self, word: Symbol) -> bool;\n+}\n+\n+impl<I: IntoIterator<Item=ast::NestedMetaItem>> NestedAttributesExt for I {\n+    fn has_word(self, word: Symbol) -> bool {\n+        self.into_iter().any(|attr| attr.is_word() && attr.check_name(word))\n+    }\n+}\n+\n+/// A portion of documentation, extracted from a `#[doc]` attribute.\n+///\n+/// Each variant contains the line number within the complete doc-comment where the fragment\n+/// starts, as well as the Span where the corresponding doc comment or attribute is located.\n+///\n+/// Included files are kept separate from inline doc comments so that proper line-number\n+/// information can be given when a doctest fails. Sugared doc comments and \"raw\" doc comments are\n+/// kept separate because of issue #42760.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum DocFragment {\n+    /// A doc fragment created from a `///` or `//!` doc comment.\n+    SugaredDoc(usize, syntax_pos::Span, String),\n+    /// A doc fragment created from a \"raw\" `#[doc=\"\"]` attribute.\n+    RawDoc(usize, syntax_pos::Span, String),\n+    /// A doc fragment created from a `#[doc(include=\"filename\")]` attribute. Contains both the\n+    /// given filename and the file contents.\n+    Include(usize, syntax_pos::Span, String, String),\n+}\n+\n+impl DocFragment {\n+    pub fn as_str(&self) -> &str {\n+        match *self {\n+            DocFragment::SugaredDoc(_, _, ref s) => &s[..],\n+            DocFragment::RawDoc(_, _, ref s) => &s[..],\n+            DocFragment::Include(_, _, _, ref s) => &s[..],\n+        }\n+    }\n+\n+    pub fn span(&self) -> syntax_pos::Span {\n+        match *self {\n+            DocFragment::SugaredDoc(_, span, _) |\n+                DocFragment::RawDoc(_, span, _) |\n+                DocFragment::Include(_, span, _, _) => span,\n+        }\n+    }\n+}\n+\n+impl<'a> FromIterator<&'a DocFragment> for String {\n+    fn from_iter<T>(iter: T) -> Self\n+    where\n+        T: IntoIterator<Item = &'a DocFragment>\n+    {\n+        iter.into_iter().fold(String::new(), |mut acc, frag| {\n+            if !acc.is_empty() {\n+                acc.push('\\n');\n+            }\n+            match *frag {\n+                DocFragment::SugaredDoc(_, _, ref docs)\n+                    | DocFragment::RawDoc(_, _, ref docs)\n+                    | DocFragment::Include(_, _, _, ref docs) =>\n+                    acc.push_str(docs),\n+            }\n+\n+            acc\n+        })\n+    }\n+}\n+\n+#[derive(Clone, Debug, Default)]\n+pub struct Attributes {\n+    pub doc_strings: Vec<DocFragment>,\n+    pub other_attrs: Vec<ast::Attribute>,\n+    pub cfg: Option<Arc<Cfg>>,\n+    pub span: Option<syntax_pos::Span>,\n+    /// map from Rust paths to resolved defs and potential URL fragments\n+    pub links: Vec<(String, Option<DefId>, Option<String>)>,\n+    pub inner_docs: bool,\n+}\n+\n+impl Attributes {\n+    /// Extracts the content from an attribute `#[doc(cfg(content))]`.\n+    pub fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n+        use syntax::ast::NestedMetaItem::MetaItem;\n+\n+        if let ast::MetaItemKind::List(ref nmis) = mi.kind {\n+            if nmis.len() == 1 {\n+                if let MetaItem(ref cfg_mi) = nmis[0] {\n+                    if cfg_mi.check_name(sym::cfg) {\n+                        if let ast::MetaItemKind::List(ref cfg_nmis) = cfg_mi.kind {\n+                            if cfg_nmis.len() == 1 {\n+                                if let MetaItem(ref content_mi) = cfg_nmis[0] {\n+                                    return Some(content_mi);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// Reads a `MetaItem` from within an attribute, looks for whether it is a\n+    /// `#[doc(include=\"file\")]`, and returns the filename and contents of the file as loaded from\n+    /// its expansion.\n+    pub fn extract_include(mi: &ast::MetaItem) -> Option<(String, String)> {\n+        mi.meta_item_list().and_then(|list| {\n+            for meta in list {\n+                if meta.check_name(sym::include) {\n+                    // the actual compiled `#[doc(include=\"filename\")]` gets expanded to\n+                    // `#[doc(include(file=\"filename\", contents=\"file contents\")]` so we need to\n+                    // look for that instead\n+                    return meta.meta_item_list().and_then(|list| {\n+                        let mut filename: Option<String> = None;\n+                        let mut contents: Option<String> = None;\n+\n+                        for it in list {\n+                            if it.check_name(sym::file) {\n+                                if let Some(name) = it.value_str() {\n+                                    filename = Some(name.to_string());\n+                                }\n+                            } else if it.check_name(sym::contents) {\n+                                if let Some(docs) = it.value_str() {\n+                                    contents = Some(docs.to_string());\n+                                }\n+                            }\n+                        }\n+\n+                        if let (Some(filename), Some(contents)) = (filename, contents) {\n+                            Some((filename, contents))\n+                        } else {\n+                            None\n+                        }\n+                    });\n+                }\n+            }\n+\n+            None\n+        })\n+    }\n+\n+    pub fn has_doc_flag(&self, flag: Symbol) -> bool {\n+        for attr in &self.other_attrs {\n+            if !attr.check_name(sym::doc) { continue; }\n+\n+            if let Some(items) = attr.meta_item_list() {\n+                if items.iter().filter_map(|i| i.meta_item()).any(|it| it.check_name(flag)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    pub fn from_ast(diagnostic: &::errors::Handler, attrs: &[ast::Attribute]) -> Attributes {\n+        let mut doc_strings = vec![];\n+        let mut sp = None;\n+        let mut cfg = Cfg::True;\n+        let mut doc_line = 0;\n+\n+        /// If `attr` is a doc comment, strips the leading and (if present)\n+        /// trailing comments symbols, e.g. `///`, `/**`, and `*/`. Otherwise,\n+        /// returns `attr` unchanged.\n+        pub fn with_doc_comment_markers_stripped<T>(\n+            attr: &Attribute,\n+            f: impl FnOnce(&Attribute) -> T,\n+        ) -> T {\n+            match attr.kind {\n+                AttrKind::Normal(_) => {\n+                    f(attr)\n+                }\n+                AttrKind::DocComment(comment) => {\n+                    let comment =\n+                        Symbol::intern(&comments::strip_doc_comment_decoration(&comment.as_str()));\n+                    f(&Attribute {\n+                        kind: AttrKind::DocComment(comment),\n+                        id: attr.id,\n+                        style: attr.style,\n+                        span: attr.span,\n+                    })\n+                }\n+            }\n+        }\n+\n+        let other_attrs = attrs.iter().filter_map(|attr| {\n+            with_doc_comment_markers_stripped(attr, |attr| {\n+                if attr.check_name(sym::doc) {\n+                    if let Some(mi) = attr.meta() {\n+                        if let Some(value) = mi.value_str() {\n+                            // Extracted #[doc = \"...\"]\n+                            let value = value.to_string();\n+                            let line = doc_line;\n+                            doc_line += value.lines().count();\n+\n+                            if attr.is_doc_comment() {\n+                                doc_strings.push(DocFragment::SugaredDoc(line, attr.span, value));\n+                            } else {\n+                                doc_strings.push(DocFragment::RawDoc(line, attr.span, value));\n+                            }\n+\n+                            if sp.is_none() {\n+                                sp = Some(attr.span);\n+                            }\n+                            return None;\n+                        } else if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n+                            // Extracted #[doc(cfg(...))]\n+                            match Cfg::parse(cfg_mi) {\n+                                Ok(new_cfg) => cfg &= new_cfg,\n+                                Err(e) => diagnostic.span_err(e.span, e.msg),\n+                            }\n+                            return None;\n+                        } else if let Some((filename, contents)) = Attributes::extract_include(&mi)\n+                        {\n+                            let line = doc_line;\n+                            doc_line += contents.lines().count();\n+                            doc_strings.push(DocFragment::Include(line,\n+                                                                  attr.span,\n+                                                                  filename,\n+                                                                  contents));\n+                        }\n+                    }\n+                }\n+                Some(attr.clone())\n+            })\n+        }).collect();\n+\n+        // treat #[target_feature(enable = \"feat\")] attributes as if they were\n+        // #[doc(cfg(target_feature = \"feat\"))] attributes as well\n+        for attr in attrs.lists(sym::target_feature) {\n+            if attr.check_name(sym::enable) {\n+                if let Some(feat) = attr.value_str() {\n+                    let meta = attr::mk_name_value_item_str(\n+                        Ident::with_dummy_span(sym::target_feature), feat, DUMMY_SP\n+                    );\n+                    if let Ok(feat_cfg) = Cfg::parse(&meta) {\n+                        cfg &= feat_cfg;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let inner_docs = attrs.iter()\n+                              .filter(|a| a.check_name(sym::doc))\n+                              .next()\n+                              .map_or(true, |a| a.style == AttrStyle::Inner);\n+\n+        Attributes {\n+            doc_strings,\n+            other_attrs,\n+            cfg: if cfg == Cfg::True { None } else { Some(Arc::new(cfg)) },\n+            span: sp,\n+            links: vec![],\n+            inner_docs,\n+        }\n+    }\n+\n+    /// Finds the `doc` attribute as a NameValue and returns the corresponding\n+    /// value found.\n+    pub fn doc_value(&self) -> Option<&str> {\n+        self.doc_strings.first().map(|s| s.as_str())\n+    }\n+\n+    /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n+    /// with newlines.\n+    pub fn collapsed_doc_value(&self) -> Option<String> {\n+        if !self.doc_strings.is_empty() {\n+            Some(self.doc_strings.iter().collect())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Gets links as a vector\n+    ///\n+    /// Cache must be populated before call\n+    pub fn links(&self, krate: &CrateNum) -> Vec<(String, String)> {\n+        use crate::html::format::href;\n+\n+        self.links.iter().filter_map(|&(ref s, did, ref fragment)| {\n+            match did {\n+                Some(did) => {\n+                    if let Some((mut href, ..)) = href(did) {\n+                        if let Some(ref fragment) = *fragment {\n+                            href.push_str(\"#\");\n+                            href.push_str(fragment);\n+                        }\n+                        Some((s.clone(), href))\n+                    } else {\n+                        None\n+                    }\n+                }\n+                None => {\n+                    if let Some(ref fragment) = *fragment {\n+                        let cache = cache();\n+                        let url = match cache.extern_locations.get(krate) {\n+                            Some(&(_, ref src, ExternalLocation::Local)) =>\n+                                src.to_str().expect(\"invalid file path\"),\n+                            Some(&(_, _, ExternalLocation::Remote(ref s))) => s,\n+                            Some(&(_, _, ExternalLocation::Unknown)) | None =>\n+                                \"https://doc.rust-lang.org/nightly\",\n+                        };\n+                        // This is a primitive so the url is done \"by hand\".\n+                        let tail = fragment.find('#').unwrap_or_else(|| fragment.len());\n+                        Some((s.clone(),\n+                              format!(\"{}{}std/primitive.{}.html{}\",\n+                                      url,\n+                                      if !url.ends_with('/') { \"/\" } else { \"\" },\n+                                      &fragment[..tail],\n+                                      &fragment[tail..])))\n+                    } else {\n+                        panic!(\"This isn't a primitive?!\");\n+                    }\n+                }\n+            }\n+        }).collect()\n+    }\n+}\n+\n+impl PartialEq for Attributes {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        self.doc_strings == rhs.doc_strings &&\n+        self.cfg == rhs.cfg &&\n+        self.span == rhs.span &&\n+        self.links == rhs.links &&\n+        self.other_attrs.iter().map(|attr| attr.id).eq(rhs.other_attrs.iter().map(|attr| attr.id))\n+    }\n+}\n+\n+impl Eq for Attributes {}\n+\n+impl Hash for Attributes {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        self.doc_strings.hash(hasher);\n+        self.cfg.hash(hasher);\n+        self.span.hash(hasher);\n+        self.links.hash(hasher);\n+        for attr in &self.other_attrs {\n+            attr.id.hash(hasher);\n+        }\n+    }\n+}\n+\n+impl AttributesExt for Attributes {\n+    fn lists(&self, name: Symbol) -> ListAttributesIter<'_> {\n+        self.other_attrs.lists(name)\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum GenericBound {\n+    TraitBound(PolyTrait, hir::TraitBoundModifier),\n+    Outlives(Lifetime),\n+}\n+\n+impl GenericBound {\n+    pub fn maybe_sized(cx: &DocContext<'_>) -> GenericBound {\n+        let did = cx.tcx.require_lang_item(lang_items::SizedTraitLangItem, None);\n+        let empty = cx.tcx.intern_substs(&[]);\n+        let path = external_path(cx, cx.tcx.item_name(did),\n+            Some(did), false, vec![], empty);\n+        inline::record_extern_fqn(cx, did, TypeKind::Trait);\n+        GenericBound::TraitBound(PolyTrait {\n+            trait_: ResolvedPath {\n+                path,\n+                param_names: None,\n+                did,\n+                is_generic: false,\n+            },\n+            generic_params: Vec::new(),\n+        }, hir::TraitBoundModifier::Maybe)\n+    }\n+\n+    pub fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n+        use rustc::hir::TraitBoundModifier as TBM;\n+        if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n+            if trait_.def_id() == cx.tcx.lang_items().sized_trait() {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    pub fn get_poly_trait(&self) -> Option<PolyTrait> {\n+        if let GenericBound::TraitBound(ref p, _) = *self {\n+            return Some(p.clone())\n+        }\n+        None\n+    }\n+\n+    pub fn get_trait_type(&self) -> Option<Type> {\n+        if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, _) = *self {\n+            Some(trait_.clone())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct Lifetime(pub String);\n+\n+impl Lifetime {\n+    pub fn get_ref<'a>(&'a self) -> &'a str {\n+        let Lifetime(ref s) = *self;\n+        let s: &'a str = s;\n+        s\n+    }\n+\n+    pub fn statik() -> Lifetime {\n+        Lifetime(\"'static\".to_string())\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum WherePredicate {\n+    BoundPredicate { ty: Type, bounds: Vec<GenericBound> },\n+    RegionPredicate { lifetime: Lifetime, bounds: Vec<GenericBound> },\n+    EqPredicate { lhs: Type, rhs: Type },\n+}\n+\n+impl WherePredicate {\n+    pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n+        match *self {\n+            WherePredicate::BoundPredicate { ref bounds, .. } => Some(bounds),\n+            WherePredicate::RegionPredicate { ref bounds, .. } => Some(bounds),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum GenericParamDefKind {\n+    Lifetime,\n+    Type {\n+        did: DefId,\n+        bounds: Vec<GenericBound>,\n+        default: Option<Type>,\n+        synthetic: Option<hir::SyntheticTyParamKind>,\n+    },\n+    Const {\n+        did: DefId,\n+        ty: Type,\n+    },\n+}\n+\n+impl GenericParamDefKind {\n+    pub fn is_type(&self) -> bool {\n+        match *self {\n+            GenericParamDefKind::Type { .. } => true,\n+            _ => false,\n+        }\n+    }\n+\n+    // FIXME(eddyb) this either returns the default of a type parameter, or the\n+    // type of a `const` parameter. It seems that the intention is to *visit*\n+    // any embedded types, but `get_type` seems to be the wrong name for that.\n+    pub fn get_type(&self) -> Option<Type> {\n+        match self {\n+            GenericParamDefKind::Type { default, .. } => default.clone(),\n+            GenericParamDefKind::Const { ty, .. } => Some(ty.clone()),\n+            GenericParamDefKind::Lifetime => None,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct GenericParamDef {\n+    pub name: String,\n+    pub kind: GenericParamDefKind,\n+}\n+\n+impl GenericParamDef {\n+    pub fn is_synthetic_type_param(&self) -> bool {\n+        match self.kind {\n+            GenericParamDefKind::Lifetime |\n+            GenericParamDefKind::Const { .. } => false,\n+            GenericParamDefKind::Type { ref synthetic, .. } => synthetic.is_some(),\n+        }\n+    }\n+\n+    pub fn is_type(&self) -> bool {\n+        self.kind.is_type()\n+    }\n+\n+    pub fn get_type(&self) -> Option<Type> {\n+        self.kind.get_type()\n+    }\n+\n+    pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n+        match self.kind {\n+            GenericParamDefKind::Type { ref bounds, .. } => Some(bounds),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+// maybe use a Generic enum and use Vec<Generic>?\n+#[derive(Clone, Debug, Default)]\n+pub struct Generics {\n+    pub params: Vec<GenericParamDef>,\n+    pub where_predicates: Vec<WherePredicate>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Method {\n+    pub generics: Generics,\n+    pub decl: FnDecl,\n+    pub header: hir::FnHeader,\n+    pub defaultness: Option<hir::Defaultness>,\n+    pub all_types: Vec<Type>,\n+    pub ret_types: Vec<Type>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct TyMethod {\n+    pub header: hir::FnHeader,\n+    pub decl: FnDecl,\n+    pub generics: Generics,\n+    pub all_types: Vec<Type>,\n+    pub ret_types: Vec<Type>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Function {\n+    pub decl: FnDecl,\n+    pub generics: Generics,\n+    pub header: hir::FnHeader,\n+    pub all_types: Vec<Type>,\n+    pub ret_types: Vec<Type>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct FnDecl {\n+    pub inputs: Arguments,\n+    pub output: FunctionRetTy,\n+    pub c_variadic: bool,\n+    pub attrs: Attributes,\n+}\n+\n+impl FnDecl {\n+    pub fn self_type(&self) -> Option<SelfTy> {\n+        self.inputs.values.get(0).and_then(|v| v.to_self())\n+    }\n+\n+    /// Returns the sugared return type for an async function.\n+    ///\n+    /// For example, if the return type is `impl std::future::Future<Output = i32>`, this function\n+    /// will return `i32`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the return type does not match the expected sugaring for async\n+    /// functions.\n+    pub fn sugared_async_return_type(&self) -> FunctionRetTy {\n+        match &self.output {\n+            FunctionRetTy::Return(Type::ImplTrait(bounds)) => {\n+                match &bounds[0] {\n+                    GenericBound::TraitBound(PolyTrait { trait_, .. }, ..) => {\n+                        let bindings = trait_.bindings().unwrap();\n+                        FunctionRetTy::Return(bindings[0].ty().clone())\n+                    }\n+                    _ => panic!(\"unexpected desugaring of async function\"),\n+                }\n+            }\n+            _ => panic!(\"unexpected desugaring of async function\"),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct Arguments {\n+    pub values: Vec<Argument>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct Argument {\n+    pub type_: Type,\n+    pub name: String,\n+}\n+\n+#[derive(Clone, PartialEq, Debug)]\n+pub enum SelfTy {\n+    SelfValue,\n+    SelfBorrowed(Option<Lifetime>, Mutability),\n+    SelfExplicit(Type),\n+}\n+\n+impl Argument {\n+    pub fn to_self(&self) -> Option<SelfTy> {\n+        if self.name != \"self\" {\n+            return None;\n+        }\n+        if self.type_.is_self_type() {\n+            return Some(SelfValue);\n+        }\n+        match self.type_ {\n+            BorrowedRef{ref lifetime, mutability, ref type_} if type_.is_self_type() => {\n+                Some(SelfBorrowed(lifetime.clone(), mutability))\n+            }\n+            _ => Some(SelfExplicit(self.type_.clone()))\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum FunctionRetTy {\n+    Return(Type),\n+    DefaultReturn,\n+}\n+\n+impl GetDefId for FunctionRetTy {\n+    fn def_id(&self) -> Option<DefId> {\n+        match *self {\n+            Return(ref ty) => ty.def_id(),\n+            DefaultReturn => None,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Trait {\n+    pub auto: bool,\n+    pub unsafety: hir::Unsafety,\n+    pub items: Vec<Item>,\n+    pub generics: Generics,\n+    pub bounds: Vec<GenericBound>,\n+    pub is_spotlight: bool,\n+    pub is_auto: bool,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct TraitAlias {\n+    pub generics: Generics,\n+    pub bounds: Vec<GenericBound>,\n+}\n+\n+/// A trait reference, which may have higher ranked lifetimes.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct PolyTrait {\n+    pub trait_: Type,\n+    pub generic_params: Vec<GenericParamDef>,\n+}\n+\n+/// A representation of a type suitable for hyperlinking purposes. Ideally, one can get the original\n+/// type out of the AST/`TyCtxt` given one of these, if more information is needed. Most\n+/// importantly, it does not preserve mutability or boxes.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum Type {\n+    /// Structs/enums/traits (most that would be an `hir::TyKind::Path`).\n+    ResolvedPath {\n+        path: Path,\n+        param_names: Option<Vec<GenericBound>>,\n+        did: DefId,\n+        /// `true` if is a `T::Name` path for associated types.\n+        is_generic: bool,\n+    },\n+    /// For parameterized types, so the consumer of the JSON don't go\n+    /// looking for types which don't exist anywhere.\n+    Generic(String),\n+    /// Primitives are the fixed-size numeric types (plus int/usize/float), char,\n+    /// arrays, slices, and tuples.\n+    Primitive(PrimitiveType),\n+    /// `extern \"ABI\" fn`\n+    BareFunction(Box<BareFunctionDecl>),\n+    Tuple(Vec<Type>),\n+    Slice(Box<Type>),\n+    Array(Box<Type>, String),\n+    Never,\n+    RawPointer(Mutability, Box<Type>),\n+    BorrowedRef {\n+        lifetime: Option<Lifetime>,\n+        mutability: Mutability,\n+        type_: Box<Type>,\n+    },\n+\n+    // `<Type as Trait>::Name`\n+    QPath {\n+        name: String,\n+        self_type: Box<Type>,\n+        trait_: Box<Type>\n+    },\n+\n+    // `_`\n+    Infer,\n+\n+    // `impl TraitA + TraitB + ...`\n+    ImplTrait(Vec<GenericBound>),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Copy, Debug)]\n+pub enum PrimitiveType {\n+    Isize, I8, I16, I32, I64, I128,\n+    Usize, U8, U16, U32, U64, U128,\n+    F32, F64,\n+    Char,\n+    Bool,\n+    Str,\n+    Slice,\n+    Array,\n+    Tuple,\n+    Unit,\n+    RawPointer,\n+    Reference,\n+    Fn,\n+    Never,\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+pub enum TypeKind {\n+    Enum,\n+    Function,\n+    Module,\n+    Const,\n+    Static,\n+    Struct,\n+    Union,\n+    Trait,\n+    Typedef,\n+    Foreign,\n+    Macro,\n+    Attr,\n+    Derive,\n+    TraitAlias,\n+}\n+\n+pub trait GetDefId {\n+    fn def_id(&self) -> Option<DefId>;\n+}\n+\n+impl<T: GetDefId> GetDefId for Option<T> {\n+    fn def_id(&self) -> Option<DefId> {\n+        self.as_ref().and_then(|d| d.def_id())\n+    }\n+}\n+\n+impl Type {\n+    pub fn primitive_type(&self) -> Option<PrimitiveType> {\n+        match *self {\n+            Primitive(p) | BorrowedRef { type_: box Primitive(p), ..} => Some(p),\n+            Slice(..) | BorrowedRef { type_: box Slice(..), .. } => Some(PrimitiveType::Slice),\n+            Array(..) | BorrowedRef { type_: box Array(..), .. } => Some(PrimitiveType::Array),\n+            Tuple(ref tys) => if tys.is_empty() {\n+                Some(PrimitiveType::Unit)\n+            } else {\n+                Some(PrimitiveType::Tuple)\n+            },\n+            RawPointer(..) => Some(PrimitiveType::RawPointer),\n+            BorrowedRef { type_: box Generic(..), .. } => Some(PrimitiveType::Reference),\n+            BareFunction(..) => Some(PrimitiveType::Fn),\n+            Never => Some(PrimitiveType::Never),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn is_generic(&self) -> bool {\n+        match *self {\n+            ResolvedPath { is_generic, .. } => is_generic,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_self_type(&self) -> bool {\n+        match *self {\n+            Generic(ref name) => name == \"Self\",\n+            _ => false\n+        }\n+    }\n+\n+    pub fn generics(&self) -> Option<Vec<Type>> {\n+        match *self {\n+            ResolvedPath { ref path, .. } => {\n+                path.segments.last().and_then(|seg| {\n+                    if let GenericArgs::AngleBracketed { ref args, .. } = seg.args {\n+                        Some(args.iter().filter_map(|arg| match arg {\n+                            GenericArg::Type(ty) => Some(ty.clone()),\n+                            _ => None,\n+                        }).collect())\n+                    } else {\n+                        None\n+                    }\n+                })\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn bindings(&self) -> Option<&[TypeBinding]> {\n+        match *self {\n+            ResolvedPath { ref path, .. } => {\n+                path.segments.last().and_then(|seg| {\n+                    if let GenericArgs::AngleBracketed { ref bindings, .. } = seg.args {\n+                        Some(&**bindings)\n+                    } else {\n+                        None\n+                    }\n+                })\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    pub fn is_full_generic(&self) -> bool {\n+        match *self {\n+            Type::Generic(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn projection(&self) -> Option<(&Type, DefId, &str)> {\n+        let (self_, trait_, name) = match self {\n+            QPath { ref self_type, ref trait_, ref name } => {\n+                (self_type, trait_, name)\n+            }\n+            _ => return None,\n+        };\n+        let trait_did = match **trait_ {\n+            ResolvedPath { did, .. } => did,\n+            _ => return None,\n+        };\n+        Some((&self_, trait_did, name))\n+    }\n+\n+}\n+\n+impl GetDefId for Type {\n+    fn def_id(&self) -> Option<DefId> {\n+        match *self {\n+            ResolvedPath { did, .. } => Some(did),\n+            Primitive(p) => crate::html::render::cache().primitive_locations.get(&p).cloned(),\n+            BorrowedRef { type_: box Generic(..), .. } =>\n+                Primitive(PrimitiveType::Reference).def_id(),\n+            BorrowedRef { ref type_, .. } => type_.def_id(),\n+            Tuple(ref tys) => if tys.is_empty() {\n+                Primitive(PrimitiveType::Unit).def_id()\n+            } else {\n+                Primitive(PrimitiveType::Tuple).def_id()\n+            },\n+            BareFunction(..) => Primitive(PrimitiveType::Fn).def_id(),\n+            Never => Primitive(PrimitiveType::Never).def_id(),\n+            Slice(..) => Primitive(PrimitiveType::Slice).def_id(),\n+            Array(..) => Primitive(PrimitiveType::Array).def_id(),\n+            RawPointer(..) => Primitive(PrimitiveType::RawPointer).def_id(),\n+            QPath { ref self_type, .. } => self_type.def_id(),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl PrimitiveType {\n+    pub fn from_str(s: &str) -> Option<PrimitiveType> {\n+        match s {\n+            \"isize\" => Some(PrimitiveType::Isize),\n+            \"i8\" => Some(PrimitiveType::I8),\n+            \"i16\" => Some(PrimitiveType::I16),\n+            \"i32\" => Some(PrimitiveType::I32),\n+            \"i64\" => Some(PrimitiveType::I64),\n+            \"i128\" => Some(PrimitiveType::I128),\n+            \"usize\" => Some(PrimitiveType::Usize),\n+            \"u8\" => Some(PrimitiveType::U8),\n+            \"u16\" => Some(PrimitiveType::U16),\n+            \"u32\" => Some(PrimitiveType::U32),\n+            \"u64\" => Some(PrimitiveType::U64),\n+            \"u128\" => Some(PrimitiveType::U128),\n+            \"bool\" => Some(PrimitiveType::Bool),\n+            \"char\" => Some(PrimitiveType::Char),\n+            \"str\" => Some(PrimitiveType::Str),\n+            \"f32\" => Some(PrimitiveType::F32),\n+            \"f64\" => Some(PrimitiveType::F64),\n+            \"array\" => Some(PrimitiveType::Array),\n+            \"slice\" => Some(PrimitiveType::Slice),\n+            \"tuple\" => Some(PrimitiveType::Tuple),\n+            \"unit\" => Some(PrimitiveType::Unit),\n+            \"pointer\" => Some(PrimitiveType::RawPointer),\n+            \"reference\" => Some(PrimitiveType::Reference),\n+            \"fn\" => Some(PrimitiveType::Fn),\n+            \"never\" => Some(PrimitiveType::Never),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_str(&self) -> &'static str {\n+        use self::PrimitiveType::*;\n+        match *self {\n+            Isize => \"isize\",\n+            I8 => \"i8\",\n+            I16 => \"i16\",\n+            I32 => \"i32\",\n+            I64 => \"i64\",\n+            I128 => \"i128\",\n+            Usize => \"usize\",\n+            U8 => \"u8\",\n+            U16 => \"u16\",\n+            U32 => \"u32\",\n+            U64 => \"u64\",\n+            U128 => \"u128\",\n+            F32 => \"f32\",\n+            F64 => \"f64\",\n+            Str => \"str\",\n+            Bool => \"bool\",\n+            Char => \"char\",\n+            Array => \"array\",\n+            Slice => \"slice\",\n+            Tuple => \"tuple\",\n+            Unit => \"unit\",\n+            RawPointer => \"pointer\",\n+            Reference => \"reference\",\n+            Fn => \"fn\",\n+            Never => \"never\",\n+        }\n+    }\n+\n+    pub fn to_url_str(&self) -> &'static str {\n+        self.as_str()\n+    }\n+}\n+\n+impl From<ast::IntTy> for PrimitiveType {\n+    fn from(int_ty: ast::IntTy) -> PrimitiveType {\n+        match int_ty {\n+            ast::IntTy::Isize => PrimitiveType::Isize,\n+            ast::IntTy::I8 => PrimitiveType::I8,\n+            ast::IntTy::I16 => PrimitiveType::I16,\n+            ast::IntTy::I32 => PrimitiveType::I32,\n+            ast::IntTy::I64 => PrimitiveType::I64,\n+            ast::IntTy::I128 => PrimitiveType::I128,\n+        }\n+    }\n+}\n+\n+impl From<ast::UintTy> for PrimitiveType {\n+    fn from(uint_ty: ast::UintTy) -> PrimitiveType {\n+        match uint_ty {\n+            ast::UintTy::Usize => PrimitiveType::Usize,\n+            ast::UintTy::U8 => PrimitiveType::U8,\n+            ast::UintTy::U16 => PrimitiveType::U16,\n+            ast::UintTy::U32 => PrimitiveType::U32,\n+            ast::UintTy::U64 => PrimitiveType::U64,\n+            ast::UintTy::U128 => PrimitiveType::U128,\n+        }\n+    }\n+}\n+\n+impl From<ast::FloatTy> for PrimitiveType {\n+    fn from(float_ty: ast::FloatTy) -> PrimitiveType {\n+        match float_ty {\n+            ast::FloatTy::F32 => PrimitiveType::F32,\n+            ast::FloatTy::F64 => PrimitiveType::F64,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum Visibility {\n+    Public,\n+    Inherited,\n+    Crate,\n+    Restricted(DefId, Path),\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Struct {\n+    pub struct_type: doctree::StructType,\n+    pub generics: Generics,\n+    pub fields: Vec<Item>,\n+    pub fields_stripped: bool,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Union {\n+    pub struct_type: doctree::StructType,\n+    pub generics: Generics,\n+    pub fields: Vec<Item>,\n+    pub fields_stripped: bool,\n+}\n+\n+/// This is a more limited form of the standard Struct, different in that\n+/// it lacks the things most items have (name, id, parameterization). Found\n+/// only as a variant in an enum.\n+#[derive(Clone, Debug)]\n+pub struct VariantStruct {\n+    pub struct_type: doctree::StructType,\n+    pub fields: Vec<Item>,\n+    pub fields_stripped: bool,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Enum {\n+    pub variants: IndexVec<VariantIdx, Item>,\n+    pub generics: Generics,\n+    pub variants_stripped: bool,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Variant {\n+    pub kind: VariantKind,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum VariantKind {\n+    CLike,\n+    Tuple(Vec<Type>),\n+    Struct(VariantStruct),\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Span {\n+    pub filename: FileName,\n+    pub loline: usize,\n+    pub locol: usize,\n+    pub hiline: usize,\n+    pub hicol: usize,\n+    pub original: syntax_pos::Span,\n+}\n+\n+impl Span {\n+    pub fn empty() -> Span {\n+        Span {\n+            filename: FileName::Anon(0),\n+            loline: 0, locol: 0,\n+            hiline: 0, hicol: 0,\n+            original: syntax_pos::DUMMY_SP,\n+        }\n+    }\n+\n+    pub fn span(&self) -> syntax_pos::Span {\n+        self.original\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct Path {\n+    pub global: bool,\n+    pub res: Res,\n+    pub segments: Vec<PathSegment>,\n+}\n+\n+impl Path {\n+    pub fn last_name(&self) -> &str {\n+        self.segments.last().expect(\"segments were empty\").name.as_str()\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum GenericArg {\n+    Lifetime(Lifetime),\n+    Type(Type),\n+    Const(Constant),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum GenericArgs {\n+    AngleBracketed {\n+        args: Vec<GenericArg>,\n+        bindings: Vec<TypeBinding>,\n+    },\n+    Parenthesized {\n+        inputs: Vec<Type>,\n+        output: Option<Type>,\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct PathSegment {\n+    pub name: String,\n+    pub args: GenericArgs,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Typedef {\n+    pub type_: Type,\n+    pub generics: Generics,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct OpaqueTy {\n+    pub bounds: Vec<GenericBound>,\n+    pub generics: Generics,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct BareFunctionDecl {\n+    pub unsafety: hir::Unsafety,\n+    pub generic_params: Vec<GenericParamDef>,\n+    pub decl: FnDecl,\n+    pub abi: Abi,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Static {\n+    pub type_: Type,\n+    pub mutability: Mutability,\n+    /// It's useful to have the value of a static documented, but I have no\n+    /// desire to represent expressions (that'd basically be all of the AST,\n+    /// which is huge!). So, have a string.\n+    pub expr: String,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct Constant {\n+    pub type_: Type,\n+    pub expr: String,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Copy, Hash)]\n+pub enum Mutability {\n+    Mutable,\n+    Immutable,\n+}\n+\n+#[derive(Clone, PartialEq, Debug)]\n+pub enum ImplPolarity {\n+    Positive,\n+    Negative,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Impl {\n+    pub unsafety: hir::Unsafety,\n+    pub generics: Generics,\n+    pub provided_trait_methods: FxHashSet<String>,\n+    pub trait_: Option<Type>,\n+    pub for_: Type,\n+    pub items: Vec<Item>,\n+    pub polarity: Option<ImplPolarity>,\n+    pub synthetic: bool,\n+    pub blanket_impl: Option<Type>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum Import {\n+    // use source as str;\n+    Simple(String, ImportSource),\n+    // use source::*;\n+    Glob(ImportSource)\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct ImportSource {\n+    pub path: Path,\n+    pub did: Option<DefId>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Macro {\n+    pub source: String,\n+    pub imported_from: Option<String>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct ProcMacro {\n+    pub kind: MacroKind,\n+    pub helpers: Vec<String>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Stability {\n+    pub level: stability::StabilityLevel,\n+    pub feature: Option<String>,\n+    pub since: String,\n+    pub deprecation: Option<Deprecation>,\n+    pub unstable_reason: Option<String>,\n+    pub issue: Option<NonZeroU32>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Deprecation {\n+    pub since: Option<String>,\n+    pub note: Option<String>,\n+}\n+\n+/// An type binding on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n+/// `A: Send + Sync` in `Foo<A: Send + Sync>`).\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct TypeBinding {\n+    pub name: String,\n+    pub kind: TypeBindingKind,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum TypeBindingKind {\n+    Equality {\n+        ty: Type,\n+    },\n+    Constraint {\n+        bounds: Vec<GenericBound>,\n+    },\n+}\n+\n+impl TypeBinding {\n+    pub fn ty(&self) -> &Type {\n+        match self.kind {\n+            TypeBindingKind::Equality { ref ty } => ty,\n+            _ => panic!(\"expected equality type binding for parenthesized generic args\"),\n+        }\n+    }\n+}"}, {"sha": "8db7bc12cd3088e0266be92c537670c2762cd532", "filename": "src/libstd/build.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9441ad687cd51d4400aab48a1d0a630c5b95738/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=f9441ad687cd51d4400aab48a1d0a630c5b95738", "patch": "@@ -54,7 +54,5 @@ fn main() {\n         }\n         println!(\"cargo:rustc-link-lib=c\");\n         println!(\"cargo:rustc-link-lib=compiler_rt\");\n-    } else if target.contains(\"hermit\") {\n-        println!(\"cargo:rustc-link-lib=hermit\");\n     }\n }"}, {"sha": "048af409232fc2d7f8fbe5469080dc8bb702c498", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=f9441ad687cd51d4400aab48a1d0a630c5b95738", "patch": "@@ -1 +1 @@\n-Subproject commit a0ba079b6af0f8c07c33dd8af72a51c997e58967\n+Subproject commit 048af409232fc2d7f8fbe5469080dc8bb702c498"}]}