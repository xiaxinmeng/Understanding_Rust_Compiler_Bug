{"sha": "dad39b6613645aefd6671f1378cafa1c8f2d5f65", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZDM5YjY2MTM2NDVhZWZkNjY3MWYxMzc4Y2FmYTFjOGYyZDVmNjU=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-18T07:34:22Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-26T11:18:37Z"}, "message": "Move implicit_hasher to its own module", "tree": {"sha": "df3fcd799c5109027f71c7e7a1d4550102f4fb36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df3fcd799c5109027f71c7e7a1d4550102f4fb36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dad39b6613645aefd6671f1378cafa1c8f2d5f65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dad39b6613645aefd6671f1378cafa1c8f2d5f65", "html_url": "https://github.com/rust-lang/rust/commit/dad39b6613645aefd6671f1378cafa1c8f2d5f65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dad39b6613645aefd6671f1378cafa1c8f2d5f65/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f231b59b9e3fc1ea074a269b006421295d5402d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f231b59b9e3fc1ea074a269b006421295d5402d0", "html_url": "https://github.com/rust-lang/rust/commit/f231b59b9e3fc1ea074a269b006421295d5402d0"}], "stats": {"total": 764, "additions": 387, "deletions": 377}, "files": [{"sha": "0b748b4d72decba4aec455833bf03b2e33bfe8b4", "filename": "clippy_lints/src/implicit_hasher.rs", "status": "added", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/dad39b6613645aefd6671f1378cafa1c8f2d5f65/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad39b6613645aefd6671f1378cafa1c8f2d5f65/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=dad39b6613645aefd6671f1378cafa1c8f2d5f65", "patch": "@@ -0,0 +1,377 @@\n+#![allow(rustc::default_hash_types)]\n+\n+use std::borrow::Cow;\n+use std::collections::BTreeMap;\n+\n+use rustc_errors::DiagnosticBuilder;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, NestedVisitorMap, Visitor};\n+use rustc_hir::{Body, Expr, ExprKind, GenericArg, Item, ItemKind, QPath, TyKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::{Ty, TyS, TypeckResults};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::sym;\n+use rustc_typeck::hir_ty_to_ty;\n+\n+use if_chain::if_chain;\n+\n+use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n+use clippy_utils::paths;\n+use clippy_utils::source::{snippet, snippet_opt};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{differing_macro_contexts, match_path};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for public `impl` or `fn` missing generalization\n+    /// over different hashers and implicitly defaulting to the default hashing\n+    /// algorithm (`SipHash`).\n+    ///\n+    /// **Why is this bad?** `HashMap` or `HashSet` with custom hashers cannot be\n+    /// used with them.\n+    ///\n+    /// **Known problems:** Suggestions for replacing constructors can contain\n+    /// false-positives. Also applying suggestions can require modification of other\n+    /// pieces of code, possibly including external crates.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// # use std::hash::{Hash, BuildHasher};\n+    /// # trait Serialize {};\n+    /// impl<K: Hash + Eq, V> Serialize for HashMap<K, V> { }\n+    ///\n+    /// pub fn foo(map: &mut HashMap<i32, i32>) { }\n+    /// ```\n+    /// could be rewritten as\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// # use std::hash::{Hash, BuildHasher};\n+    /// # trait Serialize {};\n+    /// impl<K: Hash + Eq, V, S: BuildHasher> Serialize for HashMap<K, V, S> { }\n+    ///\n+    /// pub fn foo<S: BuildHasher>(map: &mut HashMap<i32, i32, S>) { }\n+    /// ```\n+    pub IMPLICIT_HASHER,\n+    pedantic,\n+    \"missing generalization over different hashers\"\n+}\n+\n+declare_lint_pass!(ImplicitHasher => [IMPLICIT_HASHER]);\n+\n+impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n+    #[allow(clippy::cast_possible_truncation, clippy::too_many_lines)]\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        use rustc_span::BytePos;\n+\n+        fn suggestion<'tcx>(\n+            cx: &LateContext<'tcx>,\n+            diag: &mut DiagnosticBuilder<'_>,\n+            generics_span: Span,\n+            generics_suggestion_span: Span,\n+            target: &ImplicitHasherType<'_>,\n+            vis: ImplicitHasherConstructorVisitor<'_, '_, '_>,\n+        ) {\n+            let generics_snip = snippet(cx, generics_span, \"\");\n+            // trim `<` `>`\n+            let generics_snip = if generics_snip.is_empty() {\n+                \"\"\n+            } else {\n+                &generics_snip[1..generics_snip.len() - 1]\n+            };\n+\n+            multispan_sugg(\n+                diag,\n+                \"consider adding a type parameter\",\n+                vec![\n+                    (\n+                        generics_suggestion_span,\n+                        format!(\n+                            \"<{}{}S: ::std::hash::BuildHasher{}>\",\n+                            generics_snip,\n+                            if generics_snip.is_empty() { \"\" } else { \", \" },\n+                            if vis.suggestions.is_empty() {\n+                                \"\"\n+                            } else {\n+                                // request users to add `Default` bound so that generic constructors can be used\n+                                \" + Default\"\n+                            },\n+                        ),\n+                    ),\n+                    (\n+                        target.span(),\n+                        format!(\"{}<{}, S>\", target.type_name(), target.type_arguments(),),\n+                    ),\n+                ],\n+            );\n+\n+            if !vis.suggestions.is_empty() {\n+                multispan_sugg(diag, \"...and use generic constructor\", vis.suggestions);\n+            }\n+        }\n+\n+        if !cx.access_levels.is_exported(item.hir_id()) {\n+            return;\n+        }\n+\n+        match item.kind {\n+            ItemKind::Impl(ref impl_) => {\n+                let mut vis = ImplicitHasherTypeVisitor::new(cx);\n+                vis.visit_ty(impl_.self_ty);\n+\n+                for target in &vis.found {\n+                    if differing_macro_contexts(item.span, target.span()) {\n+                        return;\n+                    }\n+\n+                    let generics_suggestion_span = impl_.generics.span.substitute_dummy({\n+                        let pos = snippet_opt(cx, item.span.until(target.span()))\n+                            .and_then(|snip| Some(item.span.lo() + BytePos(snip.find(\"impl\")? as u32 + 4)));\n+                        if let Some(pos) = pos {\n+                            Span::new(pos, pos, item.span.data().ctxt)\n+                        } else {\n+                            return;\n+                        }\n+                    });\n+\n+                    let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n+                    for item in impl_.items.iter().map(|item| cx.tcx.hir().impl_item(item.id)) {\n+                        ctr_vis.visit_impl_item(item);\n+                    }\n+\n+                    span_lint_and_then(\n+                        cx,\n+                        IMPLICIT_HASHER,\n+                        target.span(),\n+                        &format!(\n+                            \"impl for `{}` should be generalized over different hashers\",\n+                            target.type_name()\n+                        ),\n+                        move |diag| {\n+                            suggestion(cx, diag, impl_.generics.span, generics_suggestion_span, target, ctr_vis);\n+                        },\n+                    );\n+                }\n+            },\n+            ItemKind::Fn(ref sig, ref generics, body_id) => {\n+                let body = cx.tcx.hir().body(body_id);\n+\n+                for ty in sig.decl.inputs {\n+                    let mut vis = ImplicitHasherTypeVisitor::new(cx);\n+                    vis.visit_ty(ty);\n+\n+                    for target in &vis.found {\n+                        if in_external_macro(cx.sess(), generics.span) {\n+                            continue;\n+                        }\n+                        let generics_suggestion_span = generics.span.substitute_dummy({\n+                            let pos = snippet_opt(cx, item.span.until(body.params[0].pat.span))\n+                                .and_then(|snip| {\n+                                    let i = snip.find(\"fn\")?;\n+                                    Some(item.span.lo() + BytePos((i + (&snip[i..]).find('(')?) as u32))\n+                                })\n+                                .expect(\"failed to create span for type parameters\");\n+                            Span::new(pos, pos, item.span.data().ctxt)\n+                        });\n+\n+                        let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n+                        ctr_vis.visit_body(body);\n+\n+                        span_lint_and_then(\n+                            cx,\n+                            IMPLICIT_HASHER,\n+                            target.span(),\n+                            &format!(\n+                                \"parameter of type `{}` should be generalized over different hashers\",\n+                                target.type_name()\n+                            ),\n+                            move |diag| {\n+                                suggestion(cx, diag, generics.span, generics_suggestion_span, target, ctr_vis);\n+                            },\n+                        );\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+enum ImplicitHasherType<'tcx> {\n+    HashMap(Span, Ty<'tcx>, Cow<'static, str>, Cow<'static, str>),\n+    HashSet(Span, Ty<'tcx>, Cow<'static, str>),\n+}\n+\n+impl<'tcx> ImplicitHasherType<'tcx> {\n+    /// Checks that `ty` is a target type without a `BuildHasher`.\n+    fn new(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'_>) -> Option<Self> {\n+        if let TyKind::Path(QPath::Resolved(None, ref path)) = hir_ty.kind {\n+            let params: Vec<_> = path\n+                .segments\n+                .last()\n+                .as_ref()?\n+                .args\n+                .as_ref()?\n+                .args\n+                .iter()\n+                .filter_map(|arg| match arg {\n+                    GenericArg::Type(ty) => Some(ty),\n+                    _ => None,\n+                })\n+                .collect();\n+            let params_len = params.len();\n+\n+            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+\n+            if is_type_diagnostic_item(cx, ty, sym::hashmap_type) && params_len == 2 {\n+                Some(ImplicitHasherType::HashMap(\n+                    hir_ty.span,\n+                    ty,\n+                    snippet(cx, params[0].span, \"K\"),\n+                    snippet(cx, params[1].span, \"V\"),\n+                ))\n+            } else if is_type_diagnostic_item(cx, ty, sym::hashset_type) && params_len == 1 {\n+                Some(ImplicitHasherType::HashSet(\n+                    hir_ty.span,\n+                    ty,\n+                    snippet(cx, params[0].span, \"T\"),\n+                ))\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn type_name(&self) -> &'static str {\n+        match *self {\n+            ImplicitHasherType::HashMap(..) => \"HashMap\",\n+            ImplicitHasherType::HashSet(..) => \"HashSet\",\n+        }\n+    }\n+\n+    fn type_arguments(&self) -> String {\n+        match *self {\n+            ImplicitHasherType::HashMap(.., ref k, ref v) => format!(\"{}, {}\", k, v),\n+            ImplicitHasherType::HashSet(.., ref t) => format!(\"{}\", t),\n+        }\n+    }\n+\n+    fn ty(&self) -> Ty<'tcx> {\n+        match *self {\n+            ImplicitHasherType::HashMap(_, ty, ..) | ImplicitHasherType::HashSet(_, ty, ..) => ty,\n+        }\n+    }\n+\n+    fn span(&self) -> Span {\n+        match *self {\n+            ImplicitHasherType::HashMap(span, ..) | ImplicitHasherType::HashSet(span, ..) => span,\n+        }\n+    }\n+}\n+\n+struct ImplicitHasherTypeVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    found: Vec<ImplicitHasherType<'tcx>>,\n+}\n+\n+impl<'a, 'tcx> ImplicitHasherTypeVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n+        Self { cx, found: vec![] }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ImplicitHasherTypeVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty<'_>) {\n+        if let Some(target) = ImplicitHasherType::new(self.cx, t) {\n+            self.found.push(target);\n+        }\n+\n+        walk_ty(self, t);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Looks for default-hasher-dependent constructors like `HashMap::new`.\n+struct ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n+    target: &'b ImplicitHasherType<'tcx>,\n+    suggestions: BTreeMap<Span, String>,\n+}\n+\n+impl<'a, 'b, 'tcx> ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>, target: &'b ImplicitHasherType<'tcx>) -> Self {\n+        Self {\n+            cx,\n+            maybe_typeck_results: cx.maybe_typeck_results(),\n+            target,\n+            suggestions: BTreeMap::new(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_body(&mut self, body: &'tcx Body<'_>) {\n+        let old_maybe_typeck_results = self.maybe_typeck_results.replace(self.cx.tcx.typeck_body(body.id()));\n+        walk_body(self, body);\n+        self.maybe_typeck_results = old_maybe_typeck_results;\n+    }\n+\n+    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Call(ref fun, ref args) = e.kind;\n+            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.kind;\n+            if let TyKind::Path(QPath::Resolved(None, ty_path)) = ty.kind;\n+            then {\n+                if !TyS::same_type(self.target.ty(), self.maybe_typeck_results.unwrap().expr_ty(e)) {\n+                    return;\n+                }\n+\n+                if match_path(ty_path, &paths::HASHMAP) {\n+                    if method.ident.name == sym::new {\n+                        self.suggestions\n+                            .insert(e.span, \"HashMap::default()\".to_string());\n+                    } else if method.ident.name == sym!(with_capacity) {\n+                        self.suggestions.insert(\n+                            e.span,\n+                            format!(\n+                                \"HashMap::with_capacity_and_hasher({}, Default::default())\",\n+                                snippet(self.cx, args[0].span, \"capacity\"),\n+                            ),\n+                        );\n+                    }\n+                } else if match_path(ty_path, &paths::HASHSET) {\n+                    if method.ident.name == sym::new {\n+                        self.suggestions\n+                            .insert(e.span, \"HashSet::default()\".to_string());\n+                    } else if method.ident.name == sym!(with_capacity) {\n+                        self.suggestions.insert(\n+                            e.span,\n+                            format!(\n+                                \"HashSet::with_capacity_and_hasher({}, Default::default())\",\n+                                snippet(self.cx, args[0].span, \"capacity\"),\n+                            ),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        walk_expr(self, e);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+}"}, {"sha": "05165ec9d66d8522b04a2f54bcb7d66c02952c21", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dad39b6613645aefd6671f1378cafa1c8f2d5f65/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad39b6613645aefd6671f1378cafa1c8f2d5f65/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=dad39b6613645aefd6671f1378cafa1c8f2d5f65", "patch": "@@ -232,6 +232,7 @@ mod if_let_mutex;\n mod if_let_some_result;\n mod if_not_else;\n mod if_then_some_else_none;\n+mod implicit_hasher;\n mod implicit_return;\n mod implicit_saturating_sub;\n mod inconsistent_struct_constructor;\n@@ -685,6 +686,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &if_let_some_result::IF_LET_SOME_RESULT,\n         &if_not_else::IF_NOT_ELSE,\n         &if_then_some_else_none::IF_THEN_SOME_ELSE_NONE,\n+        &implicit_hasher::IMPLICIT_HASHER,\n         &implicit_return::IMPLICIT_RETURN,\n         &implicit_saturating_sub::IMPLICIT_SATURATING_SUB,\n         &inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR,\n@@ -961,7 +963,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &try_err::TRY_ERR,\n         &types::BORROWED_BOX,\n         &types::BOX_VEC,\n-        &types::IMPLICIT_HASHER,\n         &types::LINKEDLIST,\n         &types::OPTION_OPTION,\n         &types::RC_BUFFER,\n@@ -1159,7 +1160,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box infinite_iter::InfiniteIter);\n     store.register_late_pass(|| box inline_fn_without_body::InlineFnWithoutBody);\n     store.register_late_pass(|| box useless_conversion::UselessConversion::default());\n-    store.register_late_pass(|| box types::ImplicitHasher);\n+    store.register_late_pass(|| box implicit_hasher::ImplicitHasher);\n     store.register_late_pass(|| box fallible_impl_from::FallibleImplFrom);\n     store.register_late_pass(|| box double_comparison::DoubleComparisons);\n     store.register_late_pass(|| box question_mark::QuestionMark);\n@@ -1373,6 +1374,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&functions::MUST_USE_CANDIDATE),\n         LintId::of(&functions::TOO_MANY_LINES),\n         LintId::of(&if_not_else::IF_NOT_ELSE),\n+        LintId::of(&implicit_hasher::IMPLICIT_HASHER),\n         LintId::of(&implicit_saturating_sub::IMPLICIT_SATURATING_SUB),\n         LintId::of(&infinite_iter::MAYBE_INFINITE_ITER),\n         LintId::of(&invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS),\n@@ -1414,7 +1416,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&strings::STRING_ADD_ASSIGN),\n         LintId::of(&trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n         LintId::of(&trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n-        LintId::of(&types::IMPLICIT_HASHER),\n         LintId::of(&types::LINKEDLIST),\n         LintId::of(&types::OPTION_OPTION),\n         LintId::of(&unicode::NON_ASCII_LITERAL),"}, {"sha": "d5f2b3d013edc3b78bbd7750c6fe33288174591c", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 6, "deletions": 374, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/dad39b6613645aefd6671f1378cafa1c8f2d5f65/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad39b6613645aefd6671f1378cafa1c8f2d5f65/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=dad39b6613645aefd6671f1378cafa1c8f2d5f65", "patch": "@@ -1,5 +1,3 @@\n-#![allow(rustc::default_hash_types)]\n-\n mod borrowed_box;\n mod box_vec;\n mod linked_list;\n@@ -9,32 +7,18 @@ mod redundant_allocation;\n mod utils;\n mod vec_box;\n \n-use std::borrow::Cow;\n-use std::collections::BTreeMap;\n-\n-use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_then};\n-use clippy_utils::source::{snippet, snippet_opt};\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use if_chain::if_chain;\n-use rustc_errors::DiagnosticBuilder;\n+use clippy_utils::diagnostics::span_lint;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::{walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem, ImplItemKind, Item,\n-    ItemKind, Local, MutTy, QPath, TraitFn, TraitItem, TraitItemKind, TyKind,\n+    Body, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem, ImplItemKind, Item, ItemKind, Local,\n+    MutTy, QPath, TraitFn, TraitItem, TraitItemKind, TyKind,\n };\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{Ty, TyS, TypeckResults};\n-use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::sym;\n use rustc_target::spec::abi::Abi;\n-use rustc_typeck::hir_ty_to_ty;\n-\n-use clippy_utils::paths;\n-use clippy_utils::{differing_macro_contexts, match_path};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for use of `Box<Vec<_>>` anywhere in the code.\n@@ -548,355 +532,3 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n         NestedVisitorMap::None\n     }\n }\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for public `impl` or `fn` missing generalization\n-    /// over different hashers and implicitly defaulting to the default hashing\n-    /// algorithm (`SipHash`).\n-    ///\n-    /// **Why is this bad?** `HashMap` or `HashSet` with custom hashers cannot be\n-    /// used with them.\n-    ///\n-    /// **Known problems:** Suggestions for replacing constructors can contain\n-    /// false-positives. Also applying suggestions can require modification of other\n-    /// pieces of code, possibly including external crates.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # use std::collections::HashMap;\n-    /// # use std::hash::{Hash, BuildHasher};\n-    /// # trait Serialize {};\n-    /// impl<K: Hash + Eq, V> Serialize for HashMap<K, V> { }\n-    ///\n-    /// pub fn foo(map: &mut HashMap<i32, i32>) { }\n-    /// ```\n-    /// could be rewritten as\n-    /// ```rust\n-    /// # use std::collections::HashMap;\n-    /// # use std::hash::{Hash, BuildHasher};\n-    /// # trait Serialize {};\n-    /// impl<K: Hash + Eq, V, S: BuildHasher> Serialize for HashMap<K, V, S> { }\n-    ///\n-    /// pub fn foo<S: BuildHasher>(map: &mut HashMap<i32, i32, S>) { }\n-    /// ```\n-    pub IMPLICIT_HASHER,\n-    pedantic,\n-    \"missing generalization over different hashers\"\n-}\n-\n-declare_lint_pass!(ImplicitHasher => [IMPLICIT_HASHER]);\n-\n-impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n-    #[allow(clippy::cast_possible_truncation, clippy::too_many_lines)]\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        use rustc_span::BytePos;\n-\n-        fn suggestion<'tcx>(\n-            cx: &LateContext<'tcx>,\n-            diag: &mut DiagnosticBuilder<'_>,\n-            generics_span: Span,\n-            generics_suggestion_span: Span,\n-            target: &ImplicitHasherType<'_>,\n-            vis: ImplicitHasherConstructorVisitor<'_, '_, '_>,\n-        ) {\n-            let generics_snip = snippet(cx, generics_span, \"\");\n-            // trim `<` `>`\n-            let generics_snip = if generics_snip.is_empty() {\n-                \"\"\n-            } else {\n-                &generics_snip[1..generics_snip.len() - 1]\n-            };\n-\n-            multispan_sugg(\n-                diag,\n-                \"consider adding a type parameter\",\n-                vec![\n-                    (\n-                        generics_suggestion_span,\n-                        format!(\n-                            \"<{}{}S: ::std::hash::BuildHasher{}>\",\n-                            generics_snip,\n-                            if generics_snip.is_empty() { \"\" } else { \", \" },\n-                            if vis.suggestions.is_empty() {\n-                                \"\"\n-                            } else {\n-                                // request users to add `Default` bound so that generic constructors can be used\n-                                \" + Default\"\n-                            },\n-                        ),\n-                    ),\n-                    (\n-                        target.span(),\n-                        format!(\"{}<{}, S>\", target.type_name(), target.type_arguments(),),\n-                    ),\n-                ],\n-            );\n-\n-            if !vis.suggestions.is_empty() {\n-                multispan_sugg(diag, \"...and use generic constructor\", vis.suggestions);\n-            }\n-        }\n-\n-        if !cx.access_levels.is_exported(item.hir_id()) {\n-            return;\n-        }\n-\n-        match item.kind {\n-            ItemKind::Impl(ref impl_) => {\n-                let mut vis = ImplicitHasherTypeVisitor::new(cx);\n-                vis.visit_ty(impl_.self_ty);\n-\n-                for target in &vis.found {\n-                    if differing_macro_contexts(item.span, target.span()) {\n-                        return;\n-                    }\n-\n-                    let generics_suggestion_span = impl_.generics.span.substitute_dummy({\n-                        let pos = snippet_opt(cx, item.span.until(target.span()))\n-                            .and_then(|snip| Some(item.span.lo() + BytePos(snip.find(\"impl\")? as u32 + 4)));\n-                        if let Some(pos) = pos {\n-                            Span::new(pos, pos, item.span.data().ctxt)\n-                        } else {\n-                            return;\n-                        }\n-                    });\n-\n-                    let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n-                    for item in impl_.items.iter().map(|item| cx.tcx.hir().impl_item(item.id)) {\n-                        ctr_vis.visit_impl_item(item);\n-                    }\n-\n-                    span_lint_and_then(\n-                        cx,\n-                        IMPLICIT_HASHER,\n-                        target.span(),\n-                        &format!(\n-                            \"impl for `{}` should be generalized over different hashers\",\n-                            target.type_name()\n-                        ),\n-                        move |diag| {\n-                            suggestion(cx, diag, impl_.generics.span, generics_suggestion_span, target, ctr_vis);\n-                        },\n-                    );\n-                }\n-            },\n-            ItemKind::Fn(ref sig, ref generics, body_id) => {\n-                let body = cx.tcx.hir().body(body_id);\n-\n-                for ty in sig.decl.inputs {\n-                    let mut vis = ImplicitHasherTypeVisitor::new(cx);\n-                    vis.visit_ty(ty);\n-\n-                    for target in &vis.found {\n-                        if in_external_macro(cx.sess(), generics.span) {\n-                            continue;\n-                        }\n-                        let generics_suggestion_span = generics.span.substitute_dummy({\n-                            let pos = snippet_opt(cx, item.span.until(body.params[0].pat.span))\n-                                .and_then(|snip| {\n-                                    let i = snip.find(\"fn\")?;\n-                                    Some(item.span.lo() + BytePos((i + (&snip[i..]).find('(')?) as u32))\n-                                })\n-                                .expect(\"failed to create span for type parameters\");\n-                            Span::new(pos, pos, item.span.data().ctxt)\n-                        });\n-\n-                        let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n-                        ctr_vis.visit_body(body);\n-\n-                        span_lint_and_then(\n-                            cx,\n-                            IMPLICIT_HASHER,\n-                            target.span(),\n-                            &format!(\n-                                \"parameter of type `{}` should be generalized over different hashers\",\n-                                target.type_name()\n-                            ),\n-                            move |diag| {\n-                                suggestion(cx, diag, generics.span, generics_suggestion_span, target, ctr_vis);\n-                            },\n-                        );\n-                    }\n-                }\n-            },\n-            _ => {},\n-        }\n-    }\n-}\n-\n-enum ImplicitHasherType<'tcx> {\n-    HashMap(Span, Ty<'tcx>, Cow<'static, str>, Cow<'static, str>),\n-    HashSet(Span, Ty<'tcx>, Cow<'static, str>),\n-}\n-\n-impl<'tcx> ImplicitHasherType<'tcx> {\n-    /// Checks that `ty` is a target type without a `BuildHasher`.\n-    fn new(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'_>) -> Option<Self> {\n-        if let TyKind::Path(QPath::Resolved(None, ref path)) = hir_ty.kind {\n-            let params: Vec<_> = path\n-                .segments\n-                .last()\n-                .as_ref()?\n-                .args\n-                .as_ref()?\n-                .args\n-                .iter()\n-                .filter_map(|arg| match arg {\n-                    GenericArg::Type(ty) => Some(ty),\n-                    _ => None,\n-                })\n-                .collect();\n-            let params_len = params.len();\n-\n-            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-\n-            if is_type_diagnostic_item(cx, ty, sym::hashmap_type) && params_len == 2 {\n-                Some(ImplicitHasherType::HashMap(\n-                    hir_ty.span,\n-                    ty,\n-                    snippet(cx, params[0].span, \"K\"),\n-                    snippet(cx, params[1].span, \"V\"),\n-                ))\n-            } else if is_type_diagnostic_item(cx, ty, sym::hashset_type) && params_len == 1 {\n-                Some(ImplicitHasherType::HashSet(\n-                    hir_ty.span,\n-                    ty,\n-                    snippet(cx, params[0].span, \"T\"),\n-                ))\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn type_name(&self) -> &'static str {\n-        match *self {\n-            ImplicitHasherType::HashMap(..) => \"HashMap\",\n-            ImplicitHasherType::HashSet(..) => \"HashSet\",\n-        }\n-    }\n-\n-    fn type_arguments(&self) -> String {\n-        match *self {\n-            ImplicitHasherType::HashMap(.., ref k, ref v) => format!(\"{}, {}\", k, v),\n-            ImplicitHasherType::HashSet(.., ref t) => format!(\"{}\", t),\n-        }\n-    }\n-\n-    fn ty(&self) -> Ty<'tcx> {\n-        match *self {\n-            ImplicitHasherType::HashMap(_, ty, ..) | ImplicitHasherType::HashSet(_, ty, ..) => ty,\n-        }\n-    }\n-\n-    fn span(&self) -> Span {\n-        match *self {\n-            ImplicitHasherType::HashMap(span, ..) | ImplicitHasherType::HashSet(span, ..) => span,\n-        }\n-    }\n-}\n-\n-struct ImplicitHasherTypeVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    found: Vec<ImplicitHasherType<'tcx>>,\n-}\n-\n-impl<'a, 'tcx> ImplicitHasherTypeVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>) -> Self {\n-        Self { cx, found: vec![] }\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ImplicitHasherTypeVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_ty(&mut self, t: &'tcx hir::Ty<'_>) {\n-        if let Some(target) = ImplicitHasherType::new(self.cx, t) {\n-            self.found.push(target);\n-        }\n-\n-        walk_ty(self, t);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-/// Looks for default-hasher-dependent constructors like `HashMap::new`.\n-struct ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n-    target: &'b ImplicitHasherType<'tcx>,\n-    suggestions: BTreeMap<Span, String>,\n-}\n-\n-impl<'a, 'b, 'tcx> ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>, target: &'b ImplicitHasherType<'tcx>) -> Self {\n-        Self {\n-            cx,\n-            maybe_typeck_results: cx.maybe_typeck_results(),\n-            target,\n-            suggestions: BTreeMap::new(),\n-        }\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_body(&mut self, body: &'tcx Body<'_>) {\n-        let old_maybe_typeck_results = self.maybe_typeck_results.replace(self.cx.tcx.typeck_body(body.id()));\n-        walk_body(self, body);\n-        self.maybe_typeck_results = old_maybe_typeck_results;\n-    }\n-\n-    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Call(ref fun, ref args) = e.kind;\n-            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.kind;\n-            if let TyKind::Path(QPath::Resolved(None, ty_path)) = ty.kind;\n-            then {\n-                if !TyS::same_type(self.target.ty(), self.maybe_typeck_results.unwrap().expr_ty(e)) {\n-                    return;\n-                }\n-\n-                if match_path(ty_path, &paths::HASHMAP) {\n-                    if method.ident.name == sym::new {\n-                        self.suggestions\n-                            .insert(e.span, \"HashMap::default()\".to_string());\n-                    } else if method.ident.name == sym!(with_capacity) {\n-                        self.suggestions.insert(\n-                            e.span,\n-                            format!(\n-                                \"HashMap::with_capacity_and_hasher({}, Default::default())\",\n-                                snippet(self.cx, args[0].span, \"capacity\"),\n-                            ),\n-                        );\n-                    }\n-                } else if match_path(ty_path, &paths::HASHSET) {\n-                    if method.ident.name == sym::new {\n-                        self.suggestions\n-                            .insert(e.span, \"HashSet::default()\".to_string());\n-                    } else if method.ident.name == sym!(with_capacity) {\n-                        self.suggestions.insert(\n-                            e.span,\n-                            format!(\n-                                \"HashSet::with_capacity_and_hasher({}, Default::default())\",\n-                                snippet(self.cx, args[0].span, \"capacity\"),\n-                            ),\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-\n-        walk_expr(self, e);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n-    }\n-}"}]}