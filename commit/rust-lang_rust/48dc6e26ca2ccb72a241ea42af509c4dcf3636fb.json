{"sha": "48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZGM2ZTI2Y2EyY2NiNzJhMjQxZWE0MmFmNTA5YzRkY2YzNjM2ZmI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-24T22:09:46Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-15T21:12:41Z"}, "message": "register `infer-ok` obligations properly\n\nOr at least, more properly. I think I left one or two FIXMEs still in\nthere.\n\ncc #32730", "tree": {"sha": "c1a736d5f540c0360248c85ffee208bd48c2df92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1a736d5f540c0360248c85ffee208bd48c2df92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "html_url": "https://github.com/rust-lang/rust/commit/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19c1a47713bfba32ded7d8c32ceb36423fe44e35", "url": "https://api.github.com/repos/rust-lang/rust/commits/19c1a47713bfba32ded7d8c32ceb36423fe44e35", "html_url": "https://github.com/rust-lang/rust/commit/19c1a47713bfba32ded7d8c32ceb36423fe44e35"}], "stats": {"total": 208, "additions": 89, "deletions": 119}, "files": [{"sha": "dae30ea97c80d5169e57498f7706f2c6144f35c4", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::CombineFields;\n use super::SubregionOrigin;\n+use super::combine::CombineFields;\n use super::type_variable::{SubtypeOf, SupertypeOf};\n \n use ty::{self, Ty, TyCtxt};\n@@ -117,6 +117,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         // error messages.\n         let origin = SubregionOrigin::Subtype(self.fields.trace.clone());\n         self.fields.infcx.region_vars.make_subregion(origin, a, b);\n+\n         Ok(a)\n     }\n "}, {"sha": "f406580286da9a5c7555d9c2709c69589c6cf77b", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "patch": "@@ -520,10 +520,8 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n \n         ty::Predicate::Equate(ref binder) => {\n             match selcx.infcx().equality_predicate(&obligation.cause, binder) {\n-                Ok(InferOk { obligations, .. }) => {\n-                    // FIXME(#32730) propagate obligations\n-                    assert!(obligations.is_empty());\n-                    Ok(Some(Vec::new()))\n+                Ok(InferOk { obligations, value: () }) => {\n+                    Ok(Some(obligations))\n                 },\n                 Err(_) => Err(CodeSelectionError(Unimplemented)),\n             }"}, {"sha": "986e4192f889ed04d164a8d005c97afa18c6d305", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "patch": "@@ -210,9 +210,7 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n \n     let infcx = selcx.infcx();\n     match infcx.eq_types(true, &obligation.cause, normalized_ty, obligation.predicate.ty) {\n-        Ok(InferOk { obligations: inferred_obligations, .. }) => {\n-            // FIXME(#32730) once obligations are generated in inference, drop this assertion\n-            assert!(inferred_obligations.is_empty());\n+        Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n             obligations.extend(inferred_obligations);\n             Ok(Some(obligations))\n         },\n@@ -847,9 +845,10 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n                                               obligation.cause.clone(),\n                                               data_poly_trait_ref,\n                                               obligation_poly_trait_ref)\n-                        // FIXME(#32730) once obligations are propagated from unification in\n-                        // inference, drop this assertion\n-                        .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+                        .map(|InferOk { obligations: _, value: () }| {\n+                            // FIXME(#32730) -- do we need to take obligations\n+                            // into account in any way? At the moment, no.\n+                        })\n                         .is_ok()\n                 });\n \n@@ -1184,12 +1183,10 @@ fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n     fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>)\n     -> Progress<'tcx>\n {\n-    // FIXME(#32730) drop this assertion once obligations are propagated from inference (fn pointer\n-    // vtable nested obligations ONLY come from unification in inference)\n-    assert!(fn_pointer_vtable.nested.is_empty());\n     let fn_type = selcx.infcx().shallow_resolve(fn_pointer_vtable.fn_ty);\n     let sig = fn_type.fn_sig();\n     confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n+        .with_addl_obligations(fn_pointer_vtable.nested)\n }\n \n fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n@@ -1266,8 +1263,6 @@ fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n     let trait_ref = obligation.predicate.trait_ref;\n     match infcx.match_poly_projection_predicate(cause, poly_projection, trait_ref) {\n         Ok(InferOk { value: ty_match, obligations }) => {\n-            // FIXME(#32730) once obligations are generated in inference, drop this assertion\n-            assert!(obligations.is_empty());\n             Progress {\n                 ty: ty_match.value,\n                 obligations: obligations,"}, {"sha": "c25e7ee344f6eb38cebcf3d24a173f9f6d47e89c", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "patch": "@@ -418,9 +418,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             None => Ok(None),\n             Some(candidate) => {\n                 let mut candidate = self.confirm_candidate(obligation, candidate)?;\n-                // FIXME(#32730) remove this assertion once inferred obligations are propagated\n-                // from inference\n-                assert!(self.inferred_obligations.len() == 0);\n                 let inferred_obligations = (*self.inferred_obligations).into_iter().cloned();\n                 candidate.nested_obligations_mut().extend(inferred_obligations);\n                 Ok(Some(candidate))"}, {"sha": "0ceed274b6da656f089e6c3d1d357acfbdf62f73", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "patch": "@@ -324,20 +324,25 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         traits::ObligationCause::misc(span, self.body_id)\n     }\n \n-    fn sub_types(&self, span: Span, sup: Ty<'tcx>, sub: Ty<'tcx>)\n+    pub fn register_infer_ok_obligations<T>(&mut self, infer_ok: InferOk<'tcx, T>) -> T {\n+        for obligation in infer_ok.obligations {\n+            self.fulfillment_cx.register_predicate_obligation(self.infcx, obligation);\n+        }\n+        infer_ok.value\n+    }\n+\n+    fn sub_types(&mut self, sup: Ty<'tcx>, sub: Ty<'tcx>)\n                  -> infer::UnitResult<'tcx>\n     {\n-        self.infcx.sub_types(false, &self.misc(span), sup, sub)\n-            // FIXME(#32730) propagate obligations\n-            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+        self.infcx.sub_types(false, &self.misc(self.last_span), sup, sub)\n+            .map(|ok| self.register_infer_ok_obligations(ok))\n     }\n \n-    fn eq_types(&self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n+    fn eq_types(&mut self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n                 -> infer::UnitResult<'tcx>\n     {\n         self.infcx.eq_types(false, &self.misc(span), a, b)\n-            // FIXME(#32730) propagate obligations\n-            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+            .map(|ok| self.register_infer_ok_obligations(ok))\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -352,7 +357,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n                 if let Some(rv_ty) = rv_ty {\n-                    if let Err(terr) = self.sub_types(self.last_span, rv_ty, lv_ty) {\n+                    if let Err(terr) = self.sub_types(rv_ty, lv_ty) {\n                         span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n                                      lv_ty, rv_ty, terr);\n                     }\n@@ -413,7 +418,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             } => {\n                 let lv_ty = location.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = value.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(self.last_span, rv_ty, lv_ty) {\n+                if let Err(terr) = self.sub_types(rv_ty, lv_ty) {\n                     span_mirbug!(self, term, \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n                                  lv_ty, rv_ty, terr);\n                 }\n@@ -430,7 +435,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n             TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n                 let discr_ty = discr.ty(mir, tcx).to_ty(tcx);\n-                if let Err(terr) = self.sub_types(self.last_span, discr_ty, switch_ty) {\n+                if let Err(terr) = self.sub_types(discr_ty, switch_ty) {\n                     span_mirbug!(self, term, \"bad SwitchInt ({:?} on {:?}): {:?}\",\n                                  switch_ty, discr_ty, terr);\n                 }\n@@ -492,7 +497,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_call_dest(&self,\n+    fn check_call_dest(&mut self,\n                        mir: &Mir<'tcx>,\n                        term: &Terminator<'tcx>,\n                        sig: &ty::FnSig<'tcx>,\n@@ -501,7 +506,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         match *destination {\n             Some((ref dest, _)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                if let Err(terr) = self.sub_types(self.last_span, sig.output, dest_ty) {\n+                if let Err(terr) = self.sub_types(sig.output, dest_ty) {\n                     span_mirbug!(self, term,\n                                  \"call dest mismatch ({:?} <- {:?}): {:?}\",\n                                  dest_ty, sig.output, terr);\n@@ -516,7 +521,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_call_inputs(&self,\n+    fn check_call_inputs(&mut self,\n                          mir: &Mir<'tcx>,\n                          term: &Terminator<'tcx>,\n                          sig: &ty::FnSig<'tcx>,\n@@ -529,7 +534,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs.iter().zip(args).enumerate() {\n             let op_arg_ty = op_arg.ty(mir, self.tcx());\n-            if let Err(terr) = self.sub_types(self.last_span, op_arg_ty, fn_arg) {\n+            if let Err(terr) = self.sub_types(op_arg_ty, fn_arg) {\n                 span_mirbug!(self, term, \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n                              n, fn_arg, op_arg_ty, terr);\n             }\n@@ -547,7 +552,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_box_free_inputs(&self,\n+    fn check_box_free_inputs(&mut self,\n                              mir: &Mir<'tcx>,\n                              term: &Terminator<'tcx>,\n                              sig: &ty::FnSig<'tcx>,\n@@ -584,7 +589,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        if let Err(terr) = self.sub_types(self.last_span, arg_ty, pointee_ty) {\n+        if let Err(terr) = self.sub_types(arg_ty, pointee_ty) {\n             span_mirbug!(self, term, \"bad box_free arg ({:?} <- {:?}): {:?}\",\n                          pointee_ty, arg_ty, terr);\n         }"}, {"sha": "556d1f84fccdc2ff5276139d1c12c3b3d2ef9718", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "patch": "@@ -11,7 +11,7 @@\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::infer::{self, InferOk};\n+use rustc::infer;\n use rustc::traits::ObligationCauseCode;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{FnCtxt, Expectation, Diverges};\n@@ -462,9 +462,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             let result = if is_if_let_fallback {\n                 self.eq_types(true, &cause, arm_ty, result_ty)\n-                    .map(|InferOk { obligations, .. }| {\n-                        // FIXME(#32730) propagate obligations\n-                        assert!(obligations.is_empty());\n+                    .map(|infer_ok| {\n+                        self.register_infer_ok_obligations(infer_ok);\n                         arm_ty\n                     })\n             } else if i == 0 {"}, {"sha": "718c273785ae91f84c94d7e1a035d5a25db9cec8", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "patch": "@@ -118,16 +118,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             let trace = TypeTrace::types(&self.cause, false, a, b);\n             if self.use_lub {\n                 self.lub(false, trace, &a, &b)\n-                    .map(|InferOk { value, obligations }| {\n-                        // FIXME(#32730) propagate obligations\n-                        assert!(obligations.is_empty());\n-                        value\n-                    })\n+                    .map(|ok| self.register_infer_ok_obligations(ok))\n             } else {\n                 self.sub(false, trace, &a, &b)\n                     .map(|InferOk { value, obligations }| {\n-                        // FIXME(#32730) propagate obligations\n-                        assert!(obligations.is_empty());\n+                        self.fcx.register_predicates(obligations);\n                         value\n                     })\n             }\n@@ -678,21 +673,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (&ty::TyFnDef(a_def_id, a_substs, a_fty), &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n                 // The signature must always match.\n                 let fty = self.lub(true, trace.clone(), &a_fty, &b_fty)\n-                    .map(|InferOk { value, obligations }| {\n-                        // FIXME(#32730) propagate obligations\n-                        assert!(obligations.is_empty());\n-                        value\n-                    })?;\n+                              .map(|ok| self.register_infer_ok_obligations(ok))?;\n \n                 if a_def_id == b_def_id {\n                     // Same function, maybe the parameters match.\n                     let substs = self.commit_if_ok(|_| {\n                         self.lub(true, trace.clone(), &a_substs, &b_substs)\n-                            .map(|InferOk { value, obligations }| {\n-                                // FIXME(#32730) propagate obligations\n-                                assert!(obligations.is_empty());\n-                                value\n-                            })\n+                            .map(|ok| self.register_infer_ok_obligations(ok))\n                     });\n \n                     if let Ok(substs) = substs {\n@@ -761,11 +748,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if !noop {\n                 return self.commit_if_ok(|_| {\n                     self.lub(true, trace.clone(), &prev_ty, &new_ty)\n-                        .map(|InferOk { value, obligations }| {\n-                            // FIXME(#32730) propagate obligations\n-                            assert!(obligations.is_empty());\n-                            value\n-                        })\n+                        .map(|ok| self.register_infer_ok_obligations(ok))\n                 });\n             }\n         }\n@@ -778,11 +761,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 } else {\n                     self.commit_if_ok(|_| {\n                         self.lub(true, trace, &prev_ty, &new_ty)\n-                            .map(|InferOk { value, obligations }| {\n-                                // FIXME(#32730) propagate obligations\n-                                assert!(obligations.is_empty());\n-                                value\n-                            })\n+                            .map(|ok| self.register_infer_ok_obligations(ok))\n                     })\n                 }\n             }"}, {"sha": "2602ff05badd44e0a4d6bcc5389e6245235ae21e", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "patch": "@@ -810,10 +810,11 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n             infcx.sub_types(false, &cause, impl_ty, trait_ty)\n-                .map(|InferOk { obligations, .. }| {\n-                    // FIXME(#32730) propagate obligations\n-                    assert!(obligations.is_empty())\n-                })\n+                 .map(|InferOk { obligations, value: () }| {\n+                     for obligation in obligations {\n+                         fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+                     }\n+                 })\n         });\n \n         if let Err(terr) = err {"}, {"sha": "ef1c08bdab549e3b82a7c02237249c6ce4717b80", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "patch": "@@ -23,9 +23,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n         let cause = self.misc(sp);\n         match self.sub_types(false, &cause, actual, expected) {\n-            Ok(InferOk { obligations, .. }) => {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+            Ok(InferOk { obligations, value: () }) => {\n+                self.register_predicates(obligations);\n             },\n             Err(e) => {\n                 self.report_mismatched_types(&cause, expected, actual, e);\n@@ -43,9 +42,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                      actual: Ty<'tcx>)\n     {\n         match self.eq_types(false, cause, actual, expected) {\n-            Ok(InferOk { obligations, .. }) => {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+            Ok(InferOk { obligations, value: () }) => {\n+                self.register_predicates(obligations);\n             },\n             Err(e) => {\n                 self.report_mismatched_types(cause, expected, actual, e);"}, {"sha": "54e93978b798d9885e59890965047da326f8ab9c", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "patch": "@@ -331,9 +331,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n     fn unify_receivers(&mut self, self_ty: Ty<'tcx>, method_self_ty: Ty<'tcx>) {\n         match self.sub_types(false, &self.misc(self.span), self_ty, method_self_ty) {\n-            Ok(InferOk { obligations, .. }) => {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+            Ok(InferOk { obligations, value: () }) => {\n+                self.register_predicates(obligations);\n             }\n             Err(_) => {\n                 span_bug!(self.span,"}, {"sha": "545d4e788524f6317a07daae465436ca5fb74328", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "patch": "@@ -16,10 +16,10 @@ use super::suggest;\n use check::FnCtxt;\n use hir::def_id::DefId;\n use hir::def::Def;\n+use rustc::infer::InferOk;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, ObligationCause};\n use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n-use rustc::infer::InferOk;\n use rustc::util::nodemap::FxHashSet;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -1035,7 +1035,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                  &ObligationCause::dummy(),\n                                  self_ty,\n                                  probe.xform_self_ty) {\n-                Ok(InferOk { obligations, .. }) => {\n+                Ok(InferOk { obligations, value: () }) => {\n                     // FIXME(#32730) propagate obligations\n                     assert!(obligations.is_empty())\n                 }"}, {"sha": "8e9dfe54f01312c86c7e0fe4b354d3173d3f9a46", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "patch": "@@ -1797,6 +1797,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .register_predicate_obligation(self, obligation);\n     }\n \n+    pub fn register_predicates(&self,\n+                               obligations: Vec<traits::PredicateObligation<'tcx>>)\n+    {\n+        for obligation in obligations {\n+            self.register_predicate(obligation);\n+        }\n+    }\n+\n+    pub fn register_infer_ok_obligations<T>(&self, infer_ok: InferOk<'tcx, T>) -> T {\n+        self.register_predicates(infer_ok.obligations);\n+        infer_ok.value\n+    }\n+\n     pub fn to_ty(&self, ast_t: &hir::Ty) -> Ty<'tcx> {\n         let t = AstConv::ast_ty_to_ty(self, self, ast_t);\n         self.register_wf_obligation(t, ast_t.span, traits::MiscObligation);\n@@ -2110,13 +2123,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                         &self.misc(default.origin_span),\n                                                         ty,\n                                                         default.ty) {\n-                                        Ok(InferOk { obligations, .. }) => {\n-                                            // FIXME(#32730) propagate obligations\n-                                            assert!(obligations.is_empty())\n-                                        },\n-                                        Err(_) => {\n-                                            conflicts.push((*ty, default));\n-                                        }\n+                                        Ok(ok) => self.register_infer_ok_obligations(ok),\n+                                        Err(_) => conflicts.push((*ty, default)),\n                                     }\n                                 }\n                             }\n@@ -2210,8 +2218,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                 &self.misc(default.origin_span),\n                                                 ty,\n                                                 default.ty) {\n-                                // FIXME(#32730) propagate obligations\n-                                Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n+                                Ok(ok) => self.register_infer_ok_obligations(ok),\n                                 Err(_) => {\n                                     result = Some(default);\n                                 }\n@@ -2784,8 +2791,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // FIXME(#15760) can't use try! here, FromError doesn't default\n                 // to identity so the resulting type is not constrained.\n                 match ures {\n-                    // FIXME(#32730) propagate obligations\n-                    Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n+                    Ok(ok) => self.register_infer_ok_obligations(ok),\n                     Err(e) => return Err(e),\n                 }\n \n@@ -2894,11 +2900,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.commit_if_ok(|_| {\n                     let trace = TypeTrace::types(&cause, true, then_ty, else_ty);\n                     self.lub(true, trace, &then_ty, &else_ty)\n-                        .map(|InferOk { value, obligations }| {\n-                            // FIXME(#32730) propagate obligations\n-                            assert!(obligations.is_empty());\n-                            value\n-                        })\n+                        .map(|ok| self.register_infer_ok_obligations(ok))\n                 })\n             };\n \n@@ -2912,9 +2914,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             expected_ty = unit;\n             found_ty = then_ty;\n             result = self.eq_types(true, &cause, unit, then_ty)\n-                         .map(|InferOk { obligations, .. }| {\n-                             // FIXME(#32730) propagate obligations\n-                             assert!(obligations.is_empty());\n+                         .map(|ok| {\n+                             self.register_infer_ok_obligations(ok);\n                              unit\n                          });\n         }\n@@ -3579,17 +3580,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if let Some(ref e) = *expr_opt {\n                 self.check_expr_coercable_to_type(&e, self.ret_ty);\n             } else {\n-                let eq_result = self.eq_types(false,\n-                                              &self.misc(expr.span),\n-                                              self.ret_ty,\n-                                              tcx.mk_nil())\n-                    // FIXME(#32730) propagate obligations\n-                    .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()));\n-                if eq_result.is_err() {\n-                    struct_span_err!(tcx.sess, expr.span, E0069,\n-                             \"`return;` in a function whose return type is not `()`\")\n-                        .span_label(expr.span, &format!(\"return type is not ()\"))\n-                        .emit();\n+                match self.eq_types(false,\n+                                    &self.misc(expr.span),\n+                                    self.ret_ty,\n+                                    tcx.mk_nil())\n+                {\n+                    Ok(ok) => self.register_infer_ok_obligations(ok),\n+                    Err(_) => {\n+                        struct_span_err!(tcx.sess, expr.span, E0069,\n+                                         \"`return;` in a function whose return type is not `()`\")\n+                            .span_label(expr.span, &format!(\"return type is not ()\"))\n+                            .emit();\n+                    }\n                 }\n             }\n             tcx.types.never\n@@ -4383,10 +4385,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             let impl_ty = self.instantiate_type_scheme(span, &substs, &ty);\n             match self.sub_types(false, &self.misc(span), self_ty, impl_ty) {\n-                Ok(InferOk { obligations, .. }) => {\n-                    // FIXME(#32730) propagate obligations\n-                    assert!(obligations.is_empty());\n-                }\n+                Ok(ok) => self.register_infer_ok_obligations(ok),\n                 Err(_) => {\n                     span_bug!(span,\n                         \"instantiate_value_path: (UFCS) {:?} was a subtype of {:?} but now is not?\","}, {"sha": "a280001d5e99d24f511781532dfb8948bf5293e4", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dc6e26ca2ccb72a241ea42af509c4dcf3636fb/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=48dc6e26ca2ccb72a241ea42af509c4dcf3636fb", "patch": "@@ -91,7 +91,7 @@ use middle::region::{self, CodeExtent};\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, MethodCall, TypeFoldable};\n-use rustc::infer::{self, GenericKind, InferOk, SubregionOrigin, VerifyBound};\n+use rustc::infer::{self, GenericKind, SubregionOrigin, VerifyBound};\n use hir::pat_util;\n use rustc::ty::adjustment;\n use rustc::ty::wf::ImpliedBound;\n@@ -1764,9 +1764,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     // check whether this predicate applies to our current projection\n                     let cause = self.fcx.misc(span);\n                     match self.eq_types(false, &cause, ty, outlives.0) {\n-                        Ok(InferOk { obligations, .. }) => {\n-                            // FIXME(#32730) propagate obligations\n-                            assert!(obligations.is_empty());\n+                        Ok(ok) => {\n+                            self.register_infer_ok_obligations(ok);\n                             Ok(outlives.1)\n                         }\n                         Err(_) => { Err(()) }"}]}