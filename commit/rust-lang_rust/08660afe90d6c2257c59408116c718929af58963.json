{"sha": "08660afe90d6c2257c59408116c718929af58963", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4NjYwYWZlOTBkNmMyMjU3YzU5NDA4MTE2YzcxODkyOWFmNTg5NjM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-05-16T15:31:18Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-05-16T15:31:18Z"}, "message": "Remove unreachable branches in traits::project", "tree": {"sha": "27da15be3fa4e8b29d7db1e59f66bba8b4ecdc01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27da15be3fa4e8b29d7db1e59f66bba8b4ecdc01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08660afe90d6c2257c59408116c718929af58963", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08660afe90d6c2257c59408116c718929af58963", "html_url": "https://github.com/rust-lang/rust/commit/08660afe90d6c2257c59408116c718929af58963", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08660afe90d6c2257c59408116c718929af58963/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42051ceb162b8e69bcc9df580974ccff8f22f3c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/42051ceb162b8e69bcc9df580974ccff8f22f3c8", "html_url": "https://github.com/rust-lang/rust/commit/42051ceb162b8e69bcc9df580974ccff8f22f3c8"}], "stats": {"total": 188, "additions": 72, "deletions": 116}, "files": [{"sha": "d7911870f391a541dfd36297c3437999350603b1", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 72, "deletions": 116, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/08660afe90d6c2257c59408116c718929af58963/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08660afe90d6c2257c59408116c718929af58963/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=08660afe90d6c2257c59408116c718929af58963", "patch": "@@ -900,96 +900,50 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                 // In either case, we handle this by not adding a\n                 // candidate for an impl if it contains a `default`\n                 // type.\n-                let opt_node_item = assoc_ty_def(selcx,\n-                                                 impl_data.impl_def_id,\n-                                                 obligation.predicate.item_name);\n-                let new_candidate = if let Some(node_item) = opt_node_item {\n-                    let is_default = if node_item.node.is_from_trait() {\n-                        // If true, the impl inherited a `type Foo = Bar`\n-                        // given in the trait, which is implicitly default.\n-                        // Otherwise, the impl did not specify `type` and\n-                        // neither did the trait:\n-                        //\n-                        // ```rust\n-                        // trait Foo { type T; }\n-                        // impl Foo for Bar { }\n-                        // ```\n-                        //\n-                        // This is an error, but it will be\n-                        // reported in `check_impl_items_against_trait`.\n-                        // We accept it here but will flag it as\n-                        // an error when we confirm the candidate\n-                        // (which will ultimately lead to `normalize_to_error`\n-                        // being invoked).\n-                        node_item.item.defaultness.has_value()\n-                    } else {\n-                        node_item.item.defaultness.is_default() ||\n-                        selcx.tcx().impl_is_default(node_item.node.def_id())\n-                    };\n-\n-                    // Only reveal a specializable default if we're past type-checking\n-                    // and the obligations is monomorphic, otherwise passes such as\n-                    // transmute checking and polymorphic MIR optimizations could\n-                    // get a result which isn't correct for all monomorphizations.\n-                    if !is_default {\n+                let node_item = assoc_ty_def(selcx,\n+                                             impl_data.impl_def_id,\n+                                             obligation.predicate.item_name);\n+\n+                let is_default = if node_item.node.is_from_trait() {\n+                    // If true, the impl inherited a `type Foo = Bar`\n+                    // given in the trait, which is implicitly default.\n+                    // Otherwise, the impl did not specify `type` and\n+                    // neither did the trait:\n+                    //\n+                    // ```rust\n+                    // trait Foo { type T; }\n+                    // impl Foo for Bar { }\n+                    // ```\n+                    //\n+                    // This is an error, but it will be\n+                    // reported in `check_impl_items_against_trait`.\n+                    // We accept it here but will flag it as\n+                    // an error when we confirm the candidate\n+                    // (which will ultimately lead to `normalize_to_error`\n+                    // being invoked).\n+                    node_item.item.defaultness.has_value()\n+                } else {\n+                    node_item.item.defaultness.is_default() ||\n+                    selcx.tcx().impl_is_default(node_item.node.def_id())\n+                };\n+\n+                // Only reveal a specializable default if we're past type-checking\n+                // and the obligations is monomorphic, otherwise passes such as\n+                // transmute checking and polymorphic MIR optimizations could\n+                // get a result which isn't correct for all monomorphizations.\n+                let new_candidate = if !is_default {\n+                    Some(ProjectionTyCandidate::Select)\n+                } else if selcx.projection_mode() == Reveal::All {\n+                    assert!(!poly_trait_ref.needs_infer());\n+                    if !poly_trait_ref.needs_subst() {\n                         Some(ProjectionTyCandidate::Select)\n-                    } else if selcx.projection_mode() == Reveal::All {\n-                        assert!(!poly_trait_ref.needs_infer());\n-                        if !poly_trait_ref.needs_subst() {\n-                            Some(ProjectionTyCandidate::Select)\n-                        } else {\n-                            None\n-                        }\n                     } else {\n                         None\n                     }\n                 } else {\n-                    // This is saying that neither the trait nor\n-                    // the impl contain a definition for this\n-                    // associated type.  Normally this situation\n-                    // could only arise through a compiler bug --\n-                    // if the user wrote a bad item name, it\n-                    // should have failed in astconv. **However**,\n-                    // at coherence-checking time, we only look at\n-                    // the topmost impl (we don't even consider\n-                    // the trait itself) for the definition -- and\n-                    // so in that case it may be that the trait\n-                    // *DOES* have a declaration, but we don't see\n-                    // it, and we end up in this branch.\n-                    //\n-                    // This is kind of tricky to handle actually.\n-                    // For now, we just unconditionally ICE,\n-                    // because otherwise, examples like the\n-                    // following will succeed:\n-                    //\n-                    // ```\n-                    // trait Assoc {\n-                    //     type Output;\n-                    // }\n-                    //\n-                    // impl<T> Assoc for T {\n-                    //     default type Output = bool;\n-                    // }\n-                    //\n-                    // impl Assoc for u8 {}\n-                    // impl Assoc for u16 {}\n-                    //\n-                    // trait Foo {}\n-                    // impl Foo for <u8 as Assoc>::Output {}\n-                    // impl Foo for <u16 as Assoc>::Output {}\n-                    //     return None;\n-                    // }\n-                    // ```\n-                    //\n-                    // The essential problem here is that the\n-                    // projection fails, leaving two unnormalized\n-                    // types, which appear not to unify -- so the\n-                    // overlap check succeeds, when it should\n-                    // fail.\n-                    span_bug!(obligation.cause.span,\n-                              \"Tried to project an inherited associated type during \\\n-                               coherence checking, which is currently not supported.\");\n+                    None\n                 };\n+\n                 candidate_set.vec.extend(new_candidate);\n             }\n             super::VtableParam(..) => {\n@@ -1274,35 +1228,25 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n     let VtableImplData { substs, nested, impl_def_id } = impl_vtable;\n \n     let tcx = selcx.tcx();\n-    let trait_ref = obligation.predicate.trait_ref;\n     let assoc_ty = assoc_ty_def(selcx, impl_def_id, obligation.predicate.item_name);\n \n-    match assoc_ty {\n-        Some(node_item) => {\n-            let ty = if !node_item.item.defaultness.has_value() {\n-                // This means that the impl is missing a definition for the\n-                // associated type. This error will be reported by the type\n-                // checker method `check_impl_items_against_trait`, so here we\n-                // just return TyError.\n-                debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n-                       node_item.item.name,\n-                       obligation.predicate.trait_ref);\n-                tcx.types.err\n-            } else {\n-                tcx.type_of(node_item.item.def_id)\n-            };\n-            let substs = translate_substs(selcx.infcx(), impl_def_id, substs, node_item.node);\n-            Progress {\n-                ty: ty.subst(tcx, substs),\n-                obligations: nested,\n-                cacheable: true\n-            }\n-        }\n-        None => {\n-            span_bug!(obligation.cause.span,\n-                      \"No associated type for {:?}\",\n-                      trait_ref);\n-        }\n+    let ty = if !assoc_ty.item.defaultness.has_value() {\n+        // This means that the impl is missing a definition for the\n+        // associated type. This error will be reported by the type\n+        // checker method `check_impl_items_against_trait`, so here we\n+        // just return TyError.\n+        debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n+               assoc_ty.item.name,\n+               obligation.predicate.trait_ref);\n+        tcx.types.err\n+    } else {\n+        tcx.type_of(assoc_ty.item.def_id)\n+    };\n+    let substs = translate_substs(selcx.infcx(), impl_def_id, substs, assoc_ty.node);\n+    Progress {\n+        ty: ty.subst(tcx, substs),\n+        obligations: nested,\n+        cacheable: true\n     }\n }\n \n@@ -1315,7 +1259,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     selcx: &SelectionContext<'cx, 'gcx, 'tcx>,\n     impl_def_id: DefId,\n     assoc_ty_name: ast::Name)\n-    -> Option<specialization_graph::NodeItem<ty::AssociatedItem>>\n+    -> specialization_graph::NodeItem<ty::AssociatedItem>\n {\n     let tcx = selcx.tcx();\n     let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n@@ -1330,17 +1274,29 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     let impl_node = specialization_graph::Node::Impl(impl_def_id);\n     for item in impl_node.items(tcx) {\n         if item.kind == ty::AssociatedKind::Type && item.name == assoc_ty_name {\n-            return Some(specialization_graph::NodeItem {\n+            return specialization_graph::NodeItem {\n                 node: specialization_graph::Node::Impl(impl_def_id),\n                 item: item,\n-            });\n+            };\n         }\n     }\n \n-    trait_def\n+    if let Some(assoc_item) = trait_def\n         .ancestors(tcx, impl_def_id)\n         .defs(tcx, assoc_ty_name, ty::AssociatedKind::Type)\n-        .next()\n+        .next() {\n+        assoc_item\n+    } else {\n+        // This is saying that neither the trait nor\n+        // the impl contain a definition for this\n+        // associated type.  Normally this situation\n+        // could only arise through a compiler bug --\n+        // if the user wrote a bad item name, it\n+        // should have failed in astconv.\n+        bug!(\"No associated type `{}` for {}\",\n+             assoc_ty_name,\n+             tcx.item_path_str(impl_def_id))\n+    }\n }\n \n // # Cache"}]}