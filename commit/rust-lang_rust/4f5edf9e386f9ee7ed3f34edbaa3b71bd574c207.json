{"sha": "4f5edf9e386f9ee7ed3f34edbaa3b71bd574c207", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNWVkZjllMzg2ZjllZTdlZDNmMzRlZGJhYTNiNzFiZDU3NGMyMDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-14T12:02:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-14T12:02:20Z"}, "message": "Auto merge of #29827 - Manishearth:diag-fn-field, r=eddyb\n\nFixes #29043", "tree": {"sha": "1644b1421011655e14bd5ba3563fd64278ea03c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1644b1421011655e14bd5ba3563fd64278ea03c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f5edf9e386f9ee7ed3f34edbaa3b71bd574c207", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f5edf9e386f9ee7ed3f34edbaa3b71bd574c207", "html_url": "https://github.com/rust-lang/rust/commit/4f5edf9e386f9ee7ed3f34edbaa3b71bd574c207", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f5edf9e386f9ee7ed3f34edbaa3b71bd574c207/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "968e8bf2136138020932958f4f0a4c3990616f54", "url": "https://api.github.com/repos/rust-lang/rust/commits/968e8bf2136138020932958f4f0a4c3990616f54", "html_url": "https://github.com/rust-lang/rust/commit/968e8bf2136138020932958f4f0a4c3990616f54"}, {"sha": "2b3117cabfa85a5d799c14ae56aac02b774c5320", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b3117cabfa85a5d799c14ae56aac02b774c5320", "html_url": "https://github.com/rust-lang/rust/commit/2b3117cabfa85a5d799c14ae56aac02b774c5320"}], "stats": {"total": 77, "additions": 54, "deletions": 23}, "files": [{"sha": "5c0b35e46b13e7b359b27ee0bfdf5cafb59f035b", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4f5edf9e386f9ee7ed3f34edbaa3b71bd574c207/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f5edf9e386f9ee7ed3f34edbaa3b71bd574c207/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=4f5edf9e386f9ee7ed3f34edbaa3b71bd574c207", "patch": "@@ -92,31 +92,39 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n                     // Determine if the field can be used as a function in some way\n                     let field_ty = field.ty(cx, substs);\n-                    if let Ok(fn_once_trait_did) = cx.lang_items.require(FnOnceTraitLangItem) {\n-                        let infcx = fcx.infcx();\n-                        infcx.probe(|_| {\n-                            let fn_once_substs = Substs::new_trait(vec![infcx.next_ty_var()],\n-                                                                   Vec::new(),\n-                                                                   field_ty);\n-                            let trait_ref = ty::TraitRef::new(fn_once_trait_did,\n-                                                              cx.mk_substs(fn_once_substs));\n-                            let poly_trait_ref = trait_ref.to_poly_trait_ref();\n-                            let obligation = Obligation::misc(span,\n-                                                              fcx.body_id,\n-                                                              poly_trait_ref.to_predicate());\n-                            let mut selcx = SelectionContext::new(infcx);\n-\n-                            if selcx.evaluate_obligation(&obligation) {\n-                                span_stored_function();\n+\n+                    match field_ty.sty {\n+                        // Not all of these (e.g. unsafe fns) implement FnOnce\n+                        // so we look for these beforehand\n+                        ty::TyClosure(..) | ty::TyBareFn(..) => span_stored_function(),\n+                        // If it's not a simple function, look for things which implement FnOnce\n+                        _ => {\n+                            if let Ok(fn_once_trait_did) =\n+                                    cx.lang_items.require(FnOnceTraitLangItem) {\n+                                let infcx = fcx.infcx();\n+                                infcx.probe(|_| {\n+                                    let fn_once_substs = Substs::new_trait(vec![\n+                                                                            infcx.next_ty_var()],\n+                                                                           Vec::new(),\n+                                                                           field_ty);\n+                                    let trait_ref = ty::TraitRef::new(fn_once_trait_did,\n+                                                                      cx.mk_substs(fn_once_substs));\n+                                    let poly_trait_ref = trait_ref.to_poly_trait_ref();\n+                                    let obligation = Obligation::misc(span,\n+                                                                      fcx.body_id,\n+                                                                      poly_trait_ref\n+                                                                         .to_predicate());\n+                                    let mut selcx = SelectionContext::new(infcx);\n+\n+                                    if selcx.evaluate_obligation(&obligation) {\n+                                        span_stored_function();\n+                                    } else {\n+                                        span_did_you_mean();\n+                                    }\n+                                });\n                             } else {\n-                                span_did_you_mean();\n+                                span_did_you_mean()\n                             }\n-                        });\n-                    } else {\n-                        match field_ty.sty {\n-                            // fallback to matching a closure or function pointer\n-                            ty::TyClosure(..) | ty::TyBareFn(..) => span_stored_function(),\n-                            _ => span_did_you_mean(),\n                         }\n                     }\n                 }"}, {"sha": "47d50eb9d5379b577d461380eaa7dc0b191d4adb", "filename": "src/test/compile-fail/issue-2392.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4f5edf9e386f9ee7ed3f34edbaa3b71bd574c207/src%2Ftest%2Fcompile-fail%2Fissue-2392.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f5edf9e386f9ee7ed3f34edbaa3b71bd574c207/src%2Ftest%2Fcompile-fail%2Fissue-2392.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2392.rs?ref=4f5edf9e386f9ee7ed3f34edbaa3b71bd574c207", "patch": "@@ -11,6 +11,16 @@\n #![feature(core)]\n use std::boxed::FnBox;\n \n+struct FuncContainer {\n+    f1: fn(data: u8),\n+    f2: extern \"C\" fn(data: u8),\n+    f3: unsafe fn(data: u8),\n+}\n+\n+struct FuncContainerOuter {\n+    container: Box<FuncContainer>\n+}\n+\n struct Obj<F> where F: FnOnce() -> u32 {\n     closure: F,\n     not_closure: usize,\n@@ -66,3 +76,16 @@ fn main() {\n     check_expression().closure();//~ ERROR no method named `closure` found\n     //~^ NOTE use `(check_expression().closure)(...)` if you meant to call the function stored\n }\n+\n+impl FuncContainerOuter {\n+    fn run(&self) {\n+        unsafe {\n+            (*self.container).f1(1); //~ ERROR no method named `f1` found\n+            //~^ NOTE use `(*self.container.f1)(...)`\n+            (*self.container).f2(1); //~ ERROR no method named `f2` found\n+            //~^ NOTE use `(*self.container.f2)(...)`\n+            (*self.container).f3(1); //~ ERROR no method named `f3` found\n+            //~^ NOTE use `(*self.container.f3)(...)`\n+        }\n+    }\n+}"}]}