{"sha": "49cdf36d2b993e08833bfdda2563b0c22ee42de7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5Y2RmMzZkMmI5OTNlMDg4MzNiZmRkYTI1NjNiMGMyMmVlNDJkZTc=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-07T15:26:51Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-08T06:35:39Z"}, "message": "libcore: from_str_common: correctly signal failure on repeating base 2^n numbers.\n\nA number like 0b1_1111_1111 == 511 would be parsed to Some(255u8) rather than None\nby from_str_common, since 255 * 2 + 1 == 255 (mod 256) so the overflow wasn't detected.\n\nOnly applied to conversions where the radix was a power of 2, and where all digits\nrepeated.\n\nCloses #5770.", "tree": {"sha": "dbb074de8dcc1ce5ab5e3b45879290f878a3aaac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbb074de8dcc1ce5ab5e3b45879290f878a3aaac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49cdf36d2b993e08833bfdda2563b0c22ee42de7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49cdf36d2b993e08833bfdda2563b0c22ee42de7", "html_url": "https://github.com/rust-lang/rust/commit/49cdf36d2b993e08833bfdda2563b0c22ee42de7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49cdf36d2b993e08833bfdda2563b0c22ee42de7/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44d4d6de762f3f9aae1fedcf454c66b79b3ad58d", "url": "https://api.github.com/repos/rust-lang/rust/commits/44d4d6de762f3f9aae1fedcf454c66b79b3ad58d", "html_url": "https://github.com/rust-lang/rust/commit/44d4d6de762f3f9aae1fedcf454c66b79b3ad58d"}], "stats": {"total": 29, "additions": 24, "deletions": 5}, "files": [{"sha": "687b6344b39b21b277edea0cba645bff659d1d2f", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/49cdf36d2b993e08833bfdda2563b0c22ee42de7/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49cdf36d2b993e08833bfdda2563b0c22ee42de7/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=49cdf36d2b993e08833bfdda2563b0c22ee42de7", "patch": "@@ -448,7 +448,7 @@ priv static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  * - Could accept option to allow ignoring underscores, allowing for numbers\n  *   formated like `FF_AE_FF_FF`.\n  */\n-pub fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n+pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n                                     Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>+\n                                     NumStrConv>(\n         buf: &[u8], radix: uint, negative: bool, fractional: bool,\n@@ -531,9 +531,12 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n                     accum -= cast(digit as int);\n                 }\n \n-                // Detect overflow by comparing to last value\n-                if accum_positive && accum < last_accum { return None; }\n-                if !accum_positive && accum > last_accum { return None; }\n+                // Detect overflow by comparing to last value, except\n+                // if we've not seen any non-zero digits.\n+                if last_accum != _0 {\n+                    if accum_positive && accum <= last_accum { return None; }\n+                    if !accum_positive && accum >= last_accum { return None; }\n+                }\n                 last_accum = accum;\n             }\n             None => match c {\n@@ -637,11 +640,27 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n  * `from_str_bytes_common()`, for details see there.\n  */\n #[inline(always)]\n-pub fn from_str_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+Mul<T,T>+\n+pub fn from_str_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+Mul<T,T>+\n                               Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv>(\n         buf: &str, radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool\n         ) -> Option<T> {\n     from_str_bytes_common(str::to_bytes(buf), radix, negative,\n                             fractional, special, exponent, empty_zero)\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use option::*;\n+\n+    #[test]\n+    fn from_str_issue5770() {\n+        // try to parse 0b1_1111_1111 = 511 as a u8. Caused problems\n+        // since 255*2+1 == 255 (mod 256) so the overflow wasn't\n+        // detected.\n+        let n : Option<u8> = from_str_common(\"111111111\", 2, false, false, false,\n+                                             ExpNone, false);\n+        assert_eq!(n, None);\n+    }\n+}"}]}