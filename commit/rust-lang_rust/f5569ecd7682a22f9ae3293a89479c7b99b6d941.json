{"sha": "f5569ecd7682a22f9ae3293a89479c7b99b6d941", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1NTY5ZWNkNzY4MmEyMmY5YWUzMjkzYTg5NDc5YzdiOTliNmQ5NDE=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-09-17T05:29:26Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-09-19T02:36:40Z"}, "message": "address Niko's comments", "tree": {"sha": "7de1636c495f18ac6b1ccdd9d096551de91a124d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7de1636c495f18ac6b1ccdd9d096551de91a124d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5569ecd7682a22f9ae3293a89479c7b99b6d941", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5569ecd7682a22f9ae3293a89479c7b99b6d941", "html_url": "https://github.com/rust-lang/rust/commit/f5569ecd7682a22f9ae3293a89479c7b99b6d941", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5569ecd7682a22f9ae3293a89479c7b99b6d941/comments", "author": null, "committer": null, "parents": [{"sha": "3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "html_url": "https://github.com/rust-lang/rust/commit/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf"}], "stats": {"total": 134, "additions": 82, "deletions": 52}, "files": [{"sha": "297084940486e38db86137103c43c095500873bb", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f5569ecd7682a22f9ae3293a89479c7b99b6d941/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5569ecd7682a22f9ae3293a89479c7b99b6d941/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=f5569ecd7682a22f9ae3293a89479c7b99b6d941", "patch": "@@ -526,13 +526,10 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             }\n \n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-                let pass_args = if ::rustc_front::util::is_by_value_binop(op.node) {\n-                    PassArgs::ByValue\n-                } else {\n-                    PassArgs::ByRef\n-                };\n+                // NB All our assignment operations take the RHS by value\n+                assert!(::rustc_front::util::is_by_value_binop(op.node));\n \n-                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs], pass_args) {\n+                if !self.walk_overloaded_operator(expr, lhs, vec![rhs], PassArgs::ByValue) {\n                     self.mutate_expr(expr, &**lhs, WriteAndRead);\n                     self.consume_expr(&**rhs);\n                 }"}, {"sha": "7be61327f81ffbc5ed52a4c7b473cf70be4d859b", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f5569ecd7682a22f9ae3293a89479c7b99b6d941/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5569ecd7682a22f9ae3293a89479c7b99b6d941/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=f5569ecd7682a22f9ae3293a89479c7b99b6d941", "patch": "@@ -36,7 +36,7 @@ pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n \n     let lhs_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(lhs_expr));\n     let (rhs_ty, return_ty) =\n-        check_overloaded_binop(fcx, expr, lhs_expr, lhs_ty, rhs_expr, op, true);\n+        check_overloaded_binop(fcx, expr, lhs_expr, lhs_ty, rhs_expr, op, IsAssign::Yes);\n     let rhs_ty = fcx.resolve_type_vars_if_possible(rhs_ty);\n \n     if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() && is_builtin_binop(lhs_ty, rhs_ty, op) {\n@@ -83,7 +83,7 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // overloaded. This is the way to be most flexible w/r/t\n             // types that get inferred.\n             let (rhs_ty, return_ty) =\n-                check_overloaded_binop(fcx, expr, lhs_expr, lhs_ty, rhs_expr, op, false);\n+                check_overloaded_binop(fcx, expr, lhs_expr, lhs_ty, rhs_expr, op, IsAssign::No);\n \n             // Supply type inference hints if relevant. Probably these\n             // hints should be enforced during select as part of the\n@@ -156,15 +156,15 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                     lhs_ty: Ty<'tcx>,\n                                     rhs_expr: &'tcx hir::Expr,\n                                     op: hir::BinOp,\n-                                    assign: bool)\n+                                    is_assign: IsAssign)\n                                     -> (Ty<'tcx>, Ty<'tcx>)\n {\n-    debug!(\"check_overloaded_binop(expr.id={}, lhs_ty={:?}, assign={})\",\n+    debug!(\"check_overloaded_binop(expr.id={}, lhs_ty={:?}, is_assign={:?})\",\n            expr.id,\n            lhs_ty,\n-           assign);\n+           is_assign);\n \n-    let (name, trait_def_id) = name_and_trait_def_id(fcx, op, assign);\n+    let (name, trait_def_id) = name_and_trait_def_id(fcx, op, is_assign);\n \n     // NB: As we have not yet type-checked the RHS, we don't have the\n     // type at hand. Make a variable to represent it. The whole reason\n@@ -181,7 +181,7 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Err(()) => {\n             // error types are considered \"builtin\"\n             if !lhs_ty.references_error() {\n-                if assign {\n+                if let IsAssign::Yes = is_assign {\n                     span_err!(fcx.tcx().sess, lhs_expr.span, E0368,\n                               \"binary assignment operation `{}=` cannot be applied to type `{}`\",\n                               hir_util::binop_to_string(op.node),\n@@ -230,11 +230,11 @@ pub fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n fn name_and_trait_def_id(fcx: &FnCtxt,\n                          op: hir::BinOp,\n-                         assign: bool)\n+                         is_assign: IsAssign)\n                          -> (&'static str, Option<DefId>) {\n     let lang = &fcx.tcx().lang_items;\n \n-    if assign {\n+    if let IsAssign::Yes = is_assign {\n         match op.node {\n             hir::BiAdd => (\"add_assign\", lang.add_assign_trait()),\n             hir::BiSub => (\"sub_assign\", lang.sub_assign_trait()),\n@@ -383,6 +383,13 @@ impl BinOpCategory {\n     }\n }\n \n+/// Whether the binary operation is an assignment (`a += b`), or not (`a + b`)\n+#[derive(Clone, Copy, Debug)]\n+enum IsAssign {\n+    No,\n+    Yes,\n+}\n+\n /// Returns true if this is a built-in arithmetic operation (e.g. u32\n /// + u32, i16x4 == i16x4) and false if these types would have to be\n /// overloaded to be legal. There are two reasons that we distinguish"}, {"sha": "22edd7e2c537fff31d73437f58209f40464d8add", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f5569ecd7682a22f9ae3293a89479c7b99b6d941/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5569ecd7682a22f9ae3293a89479c7b99b6d941/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=f5569ecd7682a22f9ae3293a89479c7b99b6d941", "patch": "@@ -93,48 +93,50 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn fix_scalar_binary_expr(&mut self, e: &hir::Expr) {\n         match e.node {\n             hir::ExprBinary(ref op, ref lhs, ref rhs) |\n-                hir::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n-                    let lhs_ty = self.fcx.node_ty(lhs.id);\n-                    let lhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&lhs_ty);\n-\n-                    let rhs_ty = self.fcx.node_ty(rhs.id);\n-                    let rhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n-\n-                    if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n-                        self.fcx.inh.tables.borrow_mut().method_map.remove(&MethodCall::expr(e.id));\n-\n-                        // weird but true: the by-ref binops put an\n-                        // adjustment on the lhs but not the rhs; the\n-                        // adjustment for rhs is kind of baked into the\n-                        // system.\n-                        match e.node {\n-                            hir::ExprBinary(..) => {\n-                                if !hir_util::is_by_value_binop(op.node) {\n-                                    self.fcx.inh.tables.borrow_mut().adjustments.remove(&lhs.id);\n-                                }\n-                            },\n-                            hir::ExprAssignOp(..) => {\n+            hir::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n+                let lhs_ty = self.fcx.node_ty(lhs.id);\n+                let lhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&lhs_ty);\n+\n+                let rhs_ty = self.fcx.node_ty(rhs.id);\n+                let rhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n+\n+                if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n+                    self.fcx.inh.tables.borrow_mut().method_map.remove(&MethodCall::expr(e.id));\n+\n+                    // weird but true: the by-ref binops put an\n+                    // adjustment on the lhs but not the rhs; the\n+                    // adjustment for rhs is kind of baked into the\n+                    // system.\n+                    match e.node {\n+                        hir::ExprBinary(..) => {\n+                            if !hir_util::is_by_value_binop(op.node) {\n                                 self.fcx.inh.tables.borrow_mut().adjustments.remove(&lhs.id);\n-                            },\n-                            _ => {},\n-                        }\n-                    } else {\n-                        let tcx = self.tcx();\n-\n-                        if let hir::ExprAssignOp(..) = e.node {\n-                            if !tcx.sess.features.borrow().augmented_assignments &&\n-                                !self.fcx.expr_ty(e).references_error() {\n-                                tcx.sess.span_err(\n-                                    e.span,\n-                                    \"overloaded augmented assignments are not stable\");\n-                                fileline_help!(\n-                                    tcx.sess, e.span,\n-                                    \"add #![feature(augmented_assignments)] to the crate features \\\n-                                     to enable\");\n                             }\n+                        },\n+                        hir::ExprAssignOp(..) => {\n+                            self.fcx.inh.tables.borrow_mut().adjustments.remove(&lhs.id);\n+                        },\n+                        _ => {},\n+                    }\n+                } else {\n+                    let tcx = self.tcx();\n+\n+                    if let hir::ExprAssignOp(..) = e.node {\n+                        if\n+                            !tcx.sess.features.borrow().augmented_assignments &&\n+                            !self.fcx.expr_ty(e).references_error()\n+                        {\n+                            tcx.sess.span_err(\n+                                e.span,\n+                                \"overloaded augmented assignments are not stable\");\n+                            fileline_help!(\n+                                tcx.sess, e.span,\n+                                \"add #![feature(augmented_assignments)] to the crate features \\\n+                                 to enable\");\n                         }\n                     }\n                 }\n+            }\n             _ => {},\n         }\n     }"}, {"sha": "83e8d1f3b3870526eb2833cd84ec34af6382dbf9", "filename": "src/test/compile-fail/augmented-assignments-trait.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f5569ecd7682a22f9ae3293a89479c7b99b6d941/src%2Ftest%2Fcompile-fail%2Faugmented-assignments-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5569ecd7682a22f9ae3293a89479c7b99b6d941/src%2Ftest%2Fcompile-fail%2Faugmented-assignments-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Faugmented-assignments-trait.rs?ref=f5569ecd7682a22f9ae3293a89479c7b99b6d941", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::AddAssign;\n+//~^ error: use of unstable library feature 'op_assign_traits'\n+\n+struct Int(i32);\n+\n+impl AddAssign for Int {\n+    //~^ error: use of unstable library feature 'op_assign_traits'\n+    fn add_assign(&mut self, _: Int) {\n+        //~^ error: use of unstable library feature 'op_assign_traits'\n+        unimplemented!()\n+    }\n+}\n+\n+fn main() {}"}]}