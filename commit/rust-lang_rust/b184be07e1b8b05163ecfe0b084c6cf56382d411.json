{"sha": "b184be07e1b8b05163ecfe0b084c6cf56382d411", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxODRiZTA3ZTFiOGIwNTE2M2VjZmUwYjA4NGM2Y2Y1NjM4MmQ0MTE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-07T23:42:48Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-07T23:42:48Z"}, "message": "Revise folds to be much-less-polymorphic after some discussion; flesh out stmt and expr fold drivers.", "tree": {"sha": "9ee7345c15a4b65bfb40075c9fa0e9a79ae4739c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ee7345c15a4b65bfb40075c9fa0e9a79ae4739c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b184be07e1b8b05163ecfe0b084c6cf56382d411", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b184be07e1b8b05163ecfe0b084c6cf56382d411", "html_url": "https://github.com/rust-lang/rust/commit/b184be07e1b8b05163ecfe0b084c6cf56382d411", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b184be07e1b8b05163ecfe0b084c6cf56382d411/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e553ab9fc05dcaef7d92d801f1ab20bd58fe5d87", "url": "https://api.github.com/repos/rust-lang/rust/commits/e553ab9fc05dcaef7d92d801f1ab20bd58fe5d87", "html_url": "https://github.com/rust-lang/rust/commit/e553ab9fc05dcaef7d92d801f1ab20bd58fe5d87"}], "stats": {"total": 481, "additions": 309, "deletions": 172}, "files": [{"sha": "cef40d1a9a2d4edaef18193ce1c9efeb59a0c1cb", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 309, "deletions": 172, "changes": 481, "blob_url": "https://github.com/rust-lang/rust/blob/b184be07e1b8b05163ecfe0b084c6cf56382d411/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b184be07e1b8b05163ecfe0b084c6cf56382d411/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=b184be07e1b8b05163ecfe0b084c6cf56382d411", "patch": "@@ -1,206 +1,366 @@\n import std.map.hashmap;\n-import front.ast;\n import util.common.new_str_hash;\n import util.common.spanned;\n import util.common.span;\n import util.common.option;\n import util.common.some;\n import util.common.none;\n import util.common.ty_mach;\n+\n+\n+import front.ast;\n+import front.ast.ident;\n+import front.ast.name;\n+import front.ast.ty;\n+import front.ast.expr;\n+import front.ast.stmt;\n+import front.ast.block;\n+import front.ast.item;\n+import front.ast.slot;\n+import front.ast.decl;\n+import front.ast.referent;\n+\n import std._vec;\n-import std.util.operator;\n \n-type slot[TY] = rec(TY ty, ast.mode mode, option[ast.slot_id] id);\n-type input[T] = rec(slot[T] slot, ast.ident ident);\n-type name[TY] = rec(ast.ident ident, vec[TY] types);\n+import std.util.operator;\n \n-type ast_fold[ENV,\n-              NAME,TY,EXPR,STMT,BLOCK,\n-              FN,MOD,DECL,ITEM,CRATE] =\n+type ast_fold[ENV] =\n     @rec\n     (\n      // Name fold.\n-     (fn(&ENV e, &span sp, &name[TY] name) -> NAME) fold_name,\n+     (fn(&ENV e, &span sp, ast.name_ n) -> name)  fold_name,\n \n      // Type folds.\n-     (fn(&ENV e, &span sp) -> TY)               fold_ty_nil,\n-     (fn(&ENV e, &span sp) -> TY)               fold_ty_bool,\n-     (fn(&ENV e, &span sp) -> TY)               fold_ty_int,\n-     (fn(&ENV e, &span sp) -> TY)               fold_ty_uint,\n-     (fn(&ENV e, &span sp, ty_mach tm) -> TY)   fold_ty_machine,\n-     (fn(&ENV e, &span sp) -> TY)               fold_ty_char,\n-     (fn(&ENV e, &span sp) -> TY)               fold_ty_str,\n-     (fn(&ENV e, &span sp, &TY t) -> TY)        fold_ty_box,\n-     (fn(&ENV e, &span sp, &ast.path p,\n-         &option[ast.referent] r) -> TY)        fold_ty_path,\n+     (fn(&ENV e, &span sp) -> @ty)                fold_ty_nil,\n+     (fn(&ENV e, &span sp) -> @ty)                fold_ty_bool,\n+     (fn(&ENV e, &span sp) -> @ty)                fold_ty_int,\n+     (fn(&ENV e, &span sp) -> @ty)                fold_ty_uint,\n+     (fn(&ENV e, &span sp, ty_mach tm) -> @ty)    fold_ty_machine,\n+     (fn(&ENV e, &span sp) -> @ty)                fold_ty_char,\n+     (fn(&ENV e, &span sp) -> @ty)                fold_ty_str,\n+     (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_box,\n+     (fn(&ENV e, &span sp, ast.path p,\n+         &option[referent] r) -> @ty)             fold_ty_path,\n \n      // Expr folds.\n      (fn(&ENV e, &span sp,\n-         &vec[EXPR] es) -> EXPR)                      fold_expr_vec,\n+         vec[@expr] es) -> @expr)                 fold_expr_vec,\n \n      (fn(&ENV e, &span sp,\n-         &vec[EXPR] es) -> EXPR)                      fold_expr_tup,\n+         vec[@expr] es) -> @expr)                 fold_expr_tup,\n \n      (fn(&ENV e, &span sp,\n-         &vec[tup(ast.ident,EXPR)] fields) -> EXPR)   fold_expr_rec,\n+         vec[tup(ident,@expr)] fields) -> @expr)  fold_expr_rec,\n \n      (fn(&ENV e, &span sp,\n-         &EXPR f, &vec[EXPR] args) -> EXPR)           fold_expr_call,\n+         @expr f, vec[@expr] args) -> @expr)      fold_expr_call,\n \n      (fn(&ENV e, &span sp,\n          ast.binop,\n-         &EXPR lhs, &EXPR rhs) -> EXPR)               fold_expr_binary,\n+         @expr lhs, @expr rhs) -> @expr)          fold_expr_binary,\n \n      (fn(&ENV e, &span sp,\n-         ast.unop, &EXPR e) -> EXPR)                  fold_expr_unary,\n+         ast.unop, @expr e) -> @expr)             fold_expr_unary,\n \n      (fn(&ENV e, &span sp,\n-         @ast.lit) -> EXPR)                           fold_expr_lit,\n+         @ast.lit) -> @expr)                      fold_expr_lit,\n \n      (fn(&ENV e, &span sp,\n-         &NAME name,\n-         &option[ast.referent] r) -> EXPR)            fold_expr_name,\n+         &name n,\n+         &option[referent] r) -> @expr)           fold_expr_name,\n \n      (fn(&ENV e, &span sp,\n-         &EXPR e, &ast.ident i) -> EXPR)              fold_expr_field,\n+         @expr e, ident i) -> @expr)              fold_expr_field,\n \n      (fn(&ENV e, &span sp,\n-         &EXPR e, &EXPR ix) -> EXPR)                  fold_expr_index,\n+         @expr e, @expr ix) -> @expr)             fold_expr_index,\n \n      (fn(&ENV e, &span sp,\n-         &EXPR cond, &BLOCK thn,\n-         &option[BLOCK] els) -> EXPR)                 fold_expr_if,\n+         @expr cond, block thn,\n+         &option[block] els) -> @expr)            fold_expr_if,\n \n      (fn(&ENV e, &span sp,\n-         &BLOCK blk) -> EXPR)                         fold_expr_block,\n+         block blk) -> @expr)                     fold_expr_block,\n \n \n      // Decl folds.\n      (fn(&ENV e, &span sp,\n-         &ast.ident ident, bool infer,\n-         &option[TY] ty) -> DECL)                 fold_decl_local,\n+         ident ident, bool infer,\n+         &option[@ty] ty) -> @decl)               fold_decl_local,\n \n      (fn(&ENV e, &span sp,\n-         &NAME name, ITEM item) -> DECL)          fold_decl_item,\n+         &name name, @item item) -> @decl)        fold_decl_item,\n \n \n      // Stmt folds.\n-     (fn(&ENV e, &span sp, &DECL decl) -> STMT) fold_stmt_decl,\n-     (fn(&ENV e, &span sp, &option[EXPR] rv) -> STMT) fold_stmt_ret,\n-     (fn(&ENV e, &span sp, &EXPR e) -> STMT) fold_stmt_log,\n-     (fn(&ENV e, &span sp, &EXPR e) -> STMT) fold_stmt_expr,\n+     (fn(&ENV e, &span sp,\n+         @decl decl) -> @stmt)                    fold_stmt_decl,\n+\n+     (fn(&ENV e, &span sp,\n+         &option[@expr] rv) -> @stmt)             fold_stmt_ret,\n+\n+     (fn(&ENV e, &span sp,\n+         @expr e) -> @stmt)                       fold_stmt_log,\n+\n+     (fn(&ENV e, &span sp,\n+         @expr e) -> @stmt)                       fold_stmt_expr,\n \n      // Item folds.\n-     (fn(&ENV e, &span sp, &FN f, ast.item_id id) -> ITEM) fold_item_fn,\n-     (fn(&ENV e, &span sp, &MOD m) -> ITEM) fold_item_mod,\n-     (fn(&ENV e, &span sp, &TY t, ast.item_id id) -> ITEM) fold_item_ty,\n+     (fn(&ENV e, &span sp,\n+         &ast._fn f, ast.item_id id) -> @item)    fold_item_fn,\n+\n+     (fn(&ENV e, &span sp,\n+         &ast._mod m) -> @item)                   fold_item_mod,\n+\n+     (fn(&ENV e, &span sp,\n+         @ty t, ast.item_id id) -> @item)         fold_item_ty,\n \n      // Additional nodes.\n-     (fn(&ENV e, &span sp, &vec[STMT] stmts) -> BLOCK) fold_block,\n-     (fn(&ENV e, &vec[rec(slot[TY] slot, ast.ident ident)] inputs,\n-         &slot[TY] output, &BLOCK body) -> FN) fold_fn,\n-     (fn(&ENV e, hashmap[ast.ident,ITEM] m) -> MOD) fold_mod,\n-     (fn(&ENV e, &span sp, &MOD m) -> CRATE) fold_crate,\n+     (fn(&ENV e, &span sp,\n+         vec[@stmt] stmts) -> block)              fold_block,\n+\n+     (fn(&ENV e, vec[ast.input] inputs,\n+         &slot output, block body) -> ast._fn)    fold_fn,\n+\n+     (fn(&ENV e, &ast._mod m) -> ast._mod)        fold_mod,\n+\n+     (fn(&ENV e, &span sp,\n+         &ast._mod m) -> @ast.crate)              fold_crate,\n \n      // Env updates.\n-     (fn(&ENV e, &ast.crate c) -> ENV) update_env_for_crate,\n-     (fn(&ENV e, &ast.item i) -> ENV) update_env_for_item,\n-     (fn(&ENV e, &ast.stmt s) -> ENV) update_env_for_stmt,\n-     (fn(&ENV e, &ast.expr x) -> ENV) update_env_for_expr,\n-     (fn(&ENV e, &ast.ty t) -> ENV) update_env_for_ty,\n+     (fn(&ENV e, @ast.crate c) -> ENV) update_env_for_crate,\n+     (fn(&ENV e, @item i) -> ENV) update_env_for_item,\n+     (fn(&ENV e, @stmt s) -> ENV) update_env_for_stmt,\n+     (fn(&ENV e, @expr x) -> ENV) update_env_for_expr,\n+     (fn(&ENV e, @ty t) -> ENV) update_env_for_ty,\n \n      // Traversal control.\n      (fn(&ENV v) -> bool) keep_going\n-      );\n+     );\n \n \n //// Fold drivers.\n \n // FIXME: Finish these.\n \n-// FIXME: Also, little more type-inference love would help here.\n+fn fold_name[ENV](&ENV env, ast_fold[ENV] fld, &name n,\n+                  &option[referent] r) -> tup(name,option[referent]) {\n+    ret tup(n,r);\n+}\n \n-fn fold_ty[E,N,T,X,S,B,F,M,D,I,C]\n-(&E env, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld, @ast.ty ty) -> T {\n-    fail;\n+fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n+    ret t;\n }\n \n-fn fold_block[E,N,T,X,S,B,F,M,D,I,C]\n-(&E env, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld, &ast.block blk) -> B {\n-    fail;\n+fn fold_decl[ENV](&ENV env, ast_fold[ENV] fld, @decl d) -> @decl {\n+    ret d;\n+}\n+\n+fn fold_exprs[ENV](&ENV env, ast_fold[ENV] fld, vec[@expr] e) -> vec[@expr] {\n+    let operator[@expr, @expr] fe = bind fold_expr[ENV](env, fld, _);\n+    ret _vec.map[@expr, @expr](fe, e);\n+}\n+\n+fn fold_rec_entry[ENV](&ENV env, ast_fold[ENV] fld, &tup(ident,@expr) e)\n+    -> tup(ident,@expr) {\n+    ret tup(e._0, fold_expr(env, fld, e._1));\n+}\n+\n+fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n+\n+    let ENV env_ = fld.update_env_for_expr(env, e);\n+\n+    if (!fld.keep_going(env_)) {\n+        ret e;\n+    }\n+\n+    alt (e.node) {\n+        case (ast.expr_vec(?es)) {\n+            auto ees = fold_exprs(env_, fld, es);\n+            ret fld.fold_expr_vec(env_, e.span, ees);\n+        }\n+\n+        case (ast.expr_tup(?es)) {\n+            auto ees = fold_exprs(env_, fld, es);\n+            ret fld.fold_expr_vec(env_, e.span, ees);\n+        }\n+\n+        case (ast.expr_rec(?es)) {\n+            let operator[tup(ident,@expr), tup(ident,@expr)] fe =\n+                bind fold_rec_entry[ENV](env, fld, _);\n+            auto ees = _vec.map[tup(ident,@expr), tup(ident,@expr)](fe, es);\n+            ret fld.fold_expr_rec(env_, e.span, ees);\n+        }\n+\n+        case (ast.expr_call(?f, ?args)) {\n+            auto ff = fold_expr(env_, fld, f);\n+            auto aargs = fold_exprs(env_, fld, args);\n+            ret fld.fold_expr_call(env_, e.span, ff, aargs);\n+        }\n+\n+        case (ast.expr_binary(?op, ?a, ?b)) {\n+            auto aa = fold_expr(env_, fld, a);\n+            auto bb = fold_expr(env_, fld, b);\n+            ret fld.fold_expr_binary(env_, e.span, op, aa, bb);\n+        }\n+\n+        case (ast.expr_unary(?op, ?a)) {\n+            auto aa = fold_expr(env_, fld, a);\n+            ret fld.fold_expr_unary(env_, e.span, op, a);\n+        }\n+\n+        case (ast.expr_lit(?lit)) {\n+            ret fld.fold_expr_lit(env_, e.span, lit);\n+        }\n+\n+        case (ast.expr_name(?n, ?r)) {\n+            auto nn = fold_name(env_, fld, n, r);\n+            ret fld.fold_expr_name(env_, e.span, nn._0, nn._1);\n+        }\n+\n+        case (ast.expr_field(?e, ?i)) {\n+            auto ee = fold_expr(env_, fld, e);\n+            ret fld.fold_expr_field(env_, e.span, ee, i);\n+        }\n+\n+        case (ast.expr_index(?e, ?i)) {\n+            auto ee = fold_expr(env_, fld, e);\n+            auto ii = fold_expr(env_, fld, i);\n+            ret fld.fold_expr_index(env_, e.span, ee, ii);\n+        }\n+\n+        case (ast.expr_if(?cnd, ?thn, ?els)) {\n+            auto ccnd = fold_expr(env_, fld, cnd);\n+            auto tthn = fold_block(env_, fld, thn);\n+            auto eels = none[block];\n+            alt (els) {\n+                case (some[block](?b)) {\n+                    eels = some(fold_block(env_, fld, b));\n+                }\n+            }\n+            ret fld.fold_expr_if(env_, e.span, ccnd, tthn, eels);\n+        }\n+\n+        case (ast.expr_block(?b)) {\n+            auto bb = fold_block(env_, fld, b);\n+            ret fld.fold_expr_block(env_, e.span, bb);\n+        }\n+    }\n+\n+    ret e;\n }\n \n-fn fold_slot[E,N,T,X,S,B,F,M,D,I,C]\n-(&E env, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld, &ast.slot s) -> slot[T] {\n-    auto ty = fold_ty[E,N,T,X,S,B,F,M,D,I,C](env, fld, s.ty);\n+\n+fn fold_stmt[ENV](&ENV env, ast_fold[ENV] fld, &@stmt s) -> @stmt {\n+\n+    let ENV env_ = fld.update_env_for_stmt(env, s);\n+\n+    if (!fld.keep_going(env_)) {\n+        ret s;\n+    }\n+\n+    alt (s.node) {\n+        case (ast.stmt_decl(?d)) {\n+            auto dd = fold_decl(env_, fld, d);\n+            ret fld.fold_stmt_decl(env_, s.span, d);\n+        }\n+\n+        case (ast.stmt_ret(?oe)) {\n+            auto oee = none[@expr];\n+            alt (oe) {\n+                case (some[@expr](?e)) {\n+                    oee = some(fold_expr(env_, fld, e));\n+                }\n+            }\n+            ret fld.fold_stmt_ret(env_, s.span, oee);\n+        }\n+\n+        case (ast.stmt_log(?e)) {\n+            auto ee = fold_expr(env_, fld, e);\n+            ret fld.fold_stmt_log(env_, s.span, e);\n+        }\n+\n+        case (ast.stmt_expr(?e)) {\n+            auto ee = fold_expr(env_, fld, e);\n+            ret fld.fold_stmt_expr(env_, s.span, e);\n+        }\n+    }\n+    ret s;\n+}\n+\n+fn fold_block[ENV](&ENV env, ast_fold[ENV] fld, &block blk) -> block {\n+    let operator[@stmt, @stmt] fs = bind fold_stmt[ENV](env, fld, _);\n+    auto stmts = _vec.map[@stmt, @stmt](fs, blk.node);\n+    ret respan(blk.span, stmts);\n+}\n+\n+fn fold_slot[ENV](&ENV env, ast_fold[ENV] fld, &slot s) -> slot {\n+    auto ty = fold_ty[ENV](env, fld, s.ty);\n     ret rec(ty=ty, mode=s.mode, id=s.id);\n }\n \n \n-fn fold_fn[E,N,T,X,S,B,F,M,D,I,C]\n-(&E env, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld, &ast._fn f) -> F {\n+fn fold_fn[ENV](&ENV env, ast_fold[ENV] fld, &ast._fn f) -> ast._fn {\n \n-    fn fold_input[E,N,T,X,S,B,F,M,D,I,C]\n-        (&E env, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld,\n-         &rec(ast.slot slot, ast.ident ident) i)\n-        -> input[T] {\n-        ret rec(slot=fold_slot[E,N,T,X,S,B,F,M,D,I,C](env, fld, i.slot),\n+    fn fold_input[ENV](&ENV env, ast_fold[ENV] fld, &ast.input i)\n+        -> ast.input {\n+        ret rec(slot=fold_slot[ENV](env, fld, i.slot),\n                 ident=i.ident);\n     }\n \n-    let operator[ast.input,input[T]] fi =\n-        bind fold_input[E,N,T,X,S,B,F,M,D,I,C](env, fld, _);\n-    auto inputs = _vec.map[ast.input, input[T]](fi, f.inputs);\n-    auto output = fold_slot[E,N,T,X,S,B,F,M,D,I,C](env, fld, f.output);\n-    auto body = fold_block[E,N,T,X,S,B,F,M,D,I,C](env, fld, f.body);\n+    let operator[ast.input,ast.input] fi = bind fold_input[ENV](env, fld, _);\n+    auto inputs = _vec.map[ast.input, ast.input](fi, f.inputs);\n+    auto output = fold_slot[ENV](env, fld, f.output);\n+    auto body = fold_block[ENV](env, fld, f.body);\n \n     ret fld.fold_fn(env, inputs, output, body);\n }\n \n-fn fold_item[E,N,T,X,S,B,F,M,D,I,C]\n-(&E env, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld, @ast.item item) -> I {\n+fn fold_item[ENV](&ENV env, ast_fold[ENV] fld, @item i) -> @item {\n+\n+    let ENV env_ = fld.update_env_for_item(env, i);\n \n-    let E env_ = fld.update_env_for_item(env, *item);\n+    if (!fld.keep_going(env_)) {\n+        ret i;\n+    }\n \n-    alt (item.node) {\n+    alt (i.node) {\n \n         case (ast.item_fn(?ff, ?id)) {\n-            let F ff_ = fold_fn[E,N,T,X,S,B,F,M,D,I,C](env_, fld, ff);\n-            ret fld.fold_item_fn(env_, item.span, ff_, id);\n+            let ast._fn ff_ = fold_fn[ENV](env_, fld, ff);\n+            ret fld.fold_item_fn(env_, i.span, ff_, id);\n         }\n \n         case (ast.item_mod(?mm)) {\n-            let M mm_ = fold_mod[E,N,T,X,S,B,F,M,D,I,C](env_, fld, mm);\n-            ret fld.fold_item_mod(env_, item.span, mm_);\n+            let ast._mod mm_ = fold_mod[ENV](env_, fld, mm);\n+            ret fld.fold_item_mod(env_, i.span, mm_);\n         }\n \n         case (ast.item_ty(?ty, ?id)) {\n-            let T ty_ = fold_ty[E,N,T,X,S,B,F,M,D,I,C](env_, fld, ty);\n-            ret fld.fold_item_ty(env_, item.span, ty_, id);\n+            let @ast.ty ty_ = fold_ty[ENV](env_, fld, ty);\n+            ret fld.fold_item_ty(env_, i.span, ty_, id);\n         }\n     }\n \n     fail;\n }\n \n \n-fn fold_mod[E,N,T,X,S,B,F,M,D,I,C]\n-(&E e, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld, &ast._mod m_in) -> M {\n+fn fold_mod[ENV](&ENV e, ast_fold[ENV] fld, &ast._mod m_in) -> ast._mod {\n \n-    auto m_out = new_str_hash[I]();\n+    auto m_out = new_str_hash[@item]();\n \n-    for each (tup(ast.ident, @ast.item) pairs in m_in.items()) {\n-        auto i = fold_item[E,N,T,X,S,B,F,M,D,I,C](e, fld, pairs._1);\n+    for each (tup(ident, @item) pairs in m_in.items()) {\n+        auto i = fold_item[ENV](e, fld, pairs._1);\n         m_out.insert(pairs._0, i);\n     }\n \n     ret fld.fold_mod(e, m_out);\n  }\n \n-fn fold_crate[E,N,T,X,S,B,F,M,D,I,C]\n-(&E env, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld, @ast.crate c) -> C {\n-    let E env_ = fld.update_env_for_crate(env, *c);\n-    let M m = fold_mod[E,N,T,X,S,B,F,M,D,I,C](env_, fld, c.node.module);\n+fn fold_crate[ENV](&ENV env, ast_fold[ENV] fld, @ast.crate c) -> @ast.crate {\n+    let ENV env_ = fld.update_env_for_crate(env, c);\n+    let ast._mod m = fold_mod[ENV](env_, fld, c.node.module);\n     ret fld.fold_crate(env_, c.span, m);\n }\n \n@@ -213,218 +373,205 @@ fn respan[T](&span sp, &T t) -> spanned[T] {\n \n // Name identity.\n \n-fn identity_fold_name[ENV](&ENV env, &span sp,\n-                           &ast.name_ n) -> ast.name {\n+fn identity_fold_name[ENV](&ENV env, &span sp, ast.name_ n) -> name {\n     ret respan(sp, n);\n }\n \n \n // Type identities.\n \n-fn identity_fold_ty_nil[ENV](&ENV env, &span sp) -> @ast.ty {\n+fn identity_fold_ty_nil[ENV](&ENV env, &span sp) -> @ty {\n     ret @respan(sp, ast.ty_nil);\n }\n \n-fn identity_fold_ty_bool[ENV](&ENV env, &span sp) -> @ast.ty {\n+fn identity_fold_ty_bool[ENV](&ENV env, &span sp) -> @ty {\n     ret @respan(sp, ast.ty_bool);\n }\n \n-fn identity_fold_ty_int[ENV](&ENV env, &span sp) -> @ast.ty {\n+fn identity_fold_ty_int[ENV](&ENV env, &span sp) -> @ty {\n     ret @respan(sp, ast.ty_int);\n }\n \n-fn identity_fold_ty_uint[ENV](&ENV env, &span sp) -> @ast.ty {\n+fn identity_fold_ty_uint[ENV](&ENV env, &span sp) -> @ty {\n     ret @respan(sp, ast.ty_uint);\n }\n \n fn identity_fold_ty_machine[ENV](&ENV env, &span sp,\n-                                 ty_mach tm) -> @ast.ty {\n+                                 ty_mach tm) -> @ty {\n     ret @respan(sp, ast.ty_machine(tm));\n }\n \n-fn identity_fold_ty_char[ENV](&ENV env, &span sp) -> @ast.ty {\n+fn identity_fold_ty_char[ENV](&ENV env, &span sp) -> @ty {\n     ret @respan(sp, ast.ty_char);\n }\n \n-fn identity_fold_ty_str[ENV](&ENV env, &span sp) -> @ast.ty {\n+fn identity_fold_ty_str[ENV](&ENV env, &span sp) -> @ty {\n     ret @respan(sp, ast.ty_str);\n }\n \n-fn identity_fold_ty_box[ENV](&ENV env, &span sp, &@ast.ty t) -> @ast.ty {\n+fn identity_fold_ty_box[ENV](&ENV env, &span sp, @ty t) -> @ty {\n     ret @respan(sp, ast.ty_box(t));\n }\n \n-fn identity_fold_ty_path[ENV](&ENV env, &span sp, &ast.path p,\n-                        &option[ast.referent] r) -> @ast.ty {\n+fn identity_fold_ty_path[ENV](&ENV env, &span sp, ast.path p,\n+                        &option[referent] r) -> @ty {\n     ret @respan(sp, ast.ty_path(p, r));\n }\n \n \n // Expr identities.\n \n-fn identity_fold_expr_vec[ENV](&ENV env, &span sp,\n-                               &vec[@ast.expr] es) -> @ast.expr {\n+fn identity_fold_expr_vec[ENV](&ENV env, &span sp, vec[@expr] es) -> @expr {\n     ret @respan(sp, ast.expr_vec(es));\n }\n \n-fn identity_fold_expr_tup[ENV](&ENV env, &span sp,\n-                               &vec[@ast.expr] es) -> @ast.expr {\n+fn identity_fold_expr_tup[ENV](&ENV env, &span sp, vec[@expr] es) -> @expr {\n     ret @respan(sp, ast.expr_tup(es));\n }\n \n fn identity_fold_expr_rec[ENV](&ENV env, &span sp,\n-                               &vec[tup(ast.ident,@ast.expr)] fields)\n-    -> @ast.expr {\n+                               vec[tup(ident,@expr)] fields)\n+    -> @expr {\n     ret @respan(sp, ast.expr_rec(fields));\n }\n \n-fn identity_fold_expr_call[ENV](&ENV env, &span sp, &@ast.expr f,\n-                                &vec[@ast.expr] args) -> @ast.expr {\n+fn identity_fold_expr_call[ENV](&ENV env, &span sp, @expr f,\n+                                vec[@expr] args) -> @expr {\n     ret @respan(sp, ast.expr_call(f, args));\n }\n \n fn identity_fold_expr_binary[ENV](&ENV env, &span sp, ast.binop b,\n-                                  &@ast.expr lhs,\n-                                  &@ast.expr rhs) -> @ast.expr {\n+                                  @expr lhs, @expr rhs) -> @expr {\n     ret @respan(sp, ast.expr_binary(b, lhs, rhs));\n }\n \n fn identity_fold_expr_unary[ENV](&ENV env, &span sp,\n-                                 ast.unop u, &@ast.expr e) -> @ast.expr {\n+                                 ast.unop u, @expr e) -> @expr {\n     ret @respan(sp, ast.expr_unary(u, e));\n }\n \n-fn identity_fold_expr_lit[ENV](&ENV env, &span sp,\n-                               @ast.lit lit) -> @ast.expr {\n+fn identity_fold_expr_lit[ENV](&ENV env, &span sp, @ast.lit lit) -> @expr {\n     ret @respan(sp, ast.expr_lit(lit));\n }\n \n-fn identity_fold_expr_name[ENV](&ENV env, &span sp, &ast.name name,\n-                          &option[ast.referent] r) -> @ast.expr {\n-    ret @respan(sp, ast.expr_name(name, r));\n+fn identity_fold_expr_name[ENV](&ENV env, &span sp, &name n,\n+                          &option[referent] r) -> @expr {\n+    ret @respan(sp, ast.expr_name(n, r));\n }\n \n fn identity_fold_expr_field[ENV](&ENV env, &span sp,\n-                                 &@ast.expr e, &ast.ident i)\n-    -> @ast.expr {\n+                                 @expr e, ident i) -> @expr {\n     ret @respan(sp, ast.expr_field(e, i));\n }\n \n fn identity_fold_expr_index[ENV](&ENV env, &span sp,\n-                                 &@ast.expr e, &@ast.expr ix)\n-    -> @ast.expr {\n+                                 @expr e, @expr ix) -> @expr {\n     ret @respan(sp, ast.expr_index(e, ix));\n }\n \n fn identity_fold_expr_if[ENV](&ENV env, &span sp,\n-                              &@ast.expr cond, &ast.block thn,\n-                              &option[ast.block] els) -> @ast.expr {\n+                              @expr cond, block thn,\n+                              &option[block] els) -> @expr {\n     ret @respan(sp, ast.expr_if(cond, thn, els));\n }\n \n-fn identity_fold_expr_block[ENV](&ENV env, &span sp,\n-                                 &ast.block blk) -> @ast.expr {\n+fn identity_fold_expr_block[ENV](&ENV env, &span sp, block blk) -> @expr {\n     ret @respan(sp, ast.expr_block(blk));\n }\n \n \n // Decl identities.\n \n fn identity_fold_decl_local[ENV](&ENV e, &span sp,\n-                                 &ast.ident ident, bool infer,\n-                                 &option[@ast.ty] ty) -> @ast.decl {\n-    ret @respan(sp, ast.decl_local(ident, infer, ty));\n+                                 ident i, bool infer,\n+                                 &option[@ty] t) -> @decl {\n+    ret @respan(sp, ast.decl_local(i, infer, t));\n }\n \n fn identity_fold_decl_item[ENV](&ENV e, &span sp,\n-                                &ast.name name,\n-                                @ast.item item) -> @ast.decl {\n-    ret @respan(sp, ast.decl_item(name, item));\n+                                &name n, @item i) -> @decl {\n+    ret @respan(sp, ast.decl_item(n, i));\n }\n \n \n // Stmt identities.\n \n-fn identity_fold_stmt_decl[ENV](&ENV env, &span sp,\n-                                &@ast.decl decl) -> @ast.stmt {\n-    ret @respan(sp, ast.stmt_decl(decl));\n+fn identity_fold_stmt_decl[ENV](&ENV env, &span sp, @decl d) -> @stmt {\n+    ret @respan(sp, ast.stmt_decl(d));\n }\n \n fn identity_fold_stmt_ret[ENV](&ENV env, &span sp,\n-                               &option[@ast.expr] rv) -> @ast.stmt {\n+                               &option[@expr] rv) -> @stmt {\n     ret @respan(sp, ast.stmt_ret(rv));\n }\n \n-fn identity_fold_stmt_log[ENV](&ENV e, &span sp, &@ast.expr x) -> @ast.stmt {\n+fn identity_fold_stmt_log[ENV](&ENV e, &span sp, @expr x) -> @stmt {\n     ret @respan(sp, ast.stmt_log(x));\n }\n \n-fn identity_fold_stmt_expr[ENV](&ENV e, &span sp, &@ast.expr x) -> @ast.stmt {\n+fn identity_fold_stmt_expr[ENV](&ENV e, &span sp, @expr x) -> @stmt {\n     ret @respan(sp, ast.stmt_expr(x));\n }\n \n \n // Item identities.\n \n fn identity_fold_item_fn[ENV](&ENV e, &span sp, &ast._fn f,\n-                              ast.item_id id) -> @ast.item {\n+                              ast.item_id id) -> @item {\n     ret @respan(sp, ast.item_fn(f, id));\n }\n \n-fn identity_fold_item_mod[ENV](&ENV e, &span sp, &ast._mod m) -> @ast.item {\n+fn identity_fold_item_mod[ENV](&ENV e, &span sp, &ast._mod m) -> @item {\n     ret @respan(sp, ast.item_mod(m));\n }\n \n-fn identity_fold_item_ty[ENV](&ENV e, &span sp, &@ast.ty t,\n-                              ast.item_id id) -> @ast.item {\n+fn identity_fold_item_ty[ENV](&ENV e, &span sp, @ty t,\n+                              ast.item_id id) -> @item {\n     ret @respan(sp, ast.item_ty(t, id));\n }\n \n \n // Additional identities.\n \n-fn identity_fold_block[ENV](&ENV e, &span sp,\n-                            &vec[@ast.stmt] stmts) -> ast.block {\n+fn identity_fold_block[ENV](&ENV e, &span sp, vec[@stmt] stmts) -> block {\n     ret respan(sp, stmts);\n }\n \n fn identity_fold_fn[ENV](&ENV e,\n-                         &vec[rec(ast.slot slot, ast.ident ident)] inputs,\n-                         &ast.slot output,\n-                         &ast.block body) -> ast._fn {\n+                         vec[ast.input] inputs,\n+                         &slot output,\n+                         block body) -> ast._fn {\n     ret rec(inputs=inputs, output=output, body=body);\n }\n \n-fn identity_fold_mod[ENV](&ENV e,\n-                          hashmap[ast.ident, @ast.item] m) -> ast._mod {\n+fn identity_fold_mod[ENV](&ENV e, &ast._mod m) -> ast._mod {\n     ret m;\n }\n \n-fn identity_fold_crate[ENV](&ENV e, &span sp,\n-                            &hashmap[ast.ident, @ast.item] m) -> @ast.crate {\n+fn identity_fold_crate[ENV](&ENV e, &span sp, &ast._mod m) -> @ast.crate {\n     ret @respan(sp, rec(module=m));\n }\n \n \n // Env update identities.\n \n-fn identity_update_env_for_crate[ENV](&ENV e, &ast.crate c) -> ENV {\n+fn identity_update_env_for_crate[ENV](&ENV e, @ast.crate c) -> ENV {\n     ret e;\n }\n \n-fn identity_update_env_for_item[ENV](&ENV e, &ast.item i) -> ENV {\n+fn identity_update_env_for_item[ENV](&ENV e, @item i) -> ENV {\n     ret e;\n }\n \n-fn identity_update_env_for_stmt[ENV](&ENV e, &ast.stmt s) -> ENV {\n+fn identity_update_env_for_stmt[ENV](&ENV e, @stmt s) -> ENV {\n     ret e;\n }\n \n-fn identity_update_env_for_expr[ENV](&ENV e, &ast.expr x) -> ENV {\n+fn identity_update_env_for_expr[ENV](&ENV e, @expr x) -> ENV {\n     ret e;\n }\n \n-fn identity_update_env_for_ty[ENV](&ENV e, &ast.ty t) -> ENV {\n+fn identity_update_env_for_ty[ENV](&ENV e, @ty t) -> ENV {\n     ret e;\n }\n \n@@ -436,17 +583,7 @@ fn always_keep_going[ENV](&ENV e) -> bool {\n }\n \n \n-type identity_fold[ENV] = ast_fold[ENV,\n-                                   ast.name, @ast.ty, @ast.expr,\n-                                   @ast.stmt, ast.block, ast._fn,\n-                                   ast._mod, @ast.decl, @ast.item,\n-                                   @ast.crate];\n-\n-type query_fold[ENV,T] = ast_fold[ENV,\n-                                  T,T,T,T,T,\n-                                  T,T,T,T,T];\n-\n-fn new_identity_fold[ENV]() -> identity_fold[ENV] {\n+fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n     ret @rec\n         (\n          fold_name       = bind identity_fold_name[ENV](_,_,_),"}]}