{"sha": "3bcfa070218e0cb8c76f69636605e8b6a9e2a907", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiY2ZhMDcwMjE4ZTBjYjhjNzZmNjk2MzY2MDVlOGI2YTllMmE5MDc=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-10-25T12:30:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-25T12:30:58Z"}, "message": "Rollup merge of #53931 - iirelu:keyword-docs, r=steveklabnik\n\nGradually expanding libstd's keyword documentation\n\nI'm working on adding new keywords to the documentation and refreshing the incomplete older ones, and I'm hoping that I can eventually add all the standalone-usable keywords after a bunch of incremental work. It would be cool to see the keywords section of std's docs be a definitive reference as to what each keyword means when you see it, and that's what I'm aiming towards with this work.\n\nI'm far from a Rust expert so there will inevitably be things to fix in this, also I'm not sure if this should be a bunch of quickly-merged PRs or one gradually-updated PR that gets merged once it's done.", "tree": {"sha": "c8858fd8fdc384d28c390d74d0ff99a63c7e1810", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8858fd8fdc384d28c390d74d0ff99a63c7e1810"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bcfa070218e0cb8c76f69636605e8b6a9e2a907", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb0beCCRBK7hj4Ov3rIwAAdHIIAIBvCkWLAnRDcjPL9omtfbnb\nIVP3vkoTyXDpBSetuPtD2HgPYJyriCtIivdkLB0U7mSSsplz4J0k0WG0DrOphm88\nxxAFu6za/RQRnzb5mtk40Lgveq17G1aLzaz6YQIinDintKNSExVU5mGVj1zVsfMi\n5dPKYZs3dJE0gkj/W+Ac1sU3QnV8sY1TYy9iqGd+EMBHgdu7CFs2QNdX7coARABk\nZfQcIzZoBndBKSXo4b3Velu5km54ipoSdopLbfMpp0To2/JAK4QKuyn/2JUHNl4K\n7pInBqD3gZxUu/uIFI9bLD98T5sJeImgzYDoMt/yj8uZfNv5fLH+tRbl6gZNgwo=\n=nWzk\n-----END PGP SIGNATURE-----\n", "payload": "tree c8858fd8fdc384d28c390d74d0ff99a63c7e1810\nparent 18f7d41a654307bb883fed660e53df78b00287d0\nparent 320ec8137e90bf6dd13b62df033372a33f261bb8\nauthor Pietro Albini <pietro@pietroalbini.org> 1540470658 +0200\ncommitter GitHub <noreply@github.com> 1540470658 +0200\n\nRollup merge of #53931 - iirelu:keyword-docs, r=steveklabnik\n\nGradually expanding libstd's keyword documentation\n\nI'm working on adding new keywords to the documentation and refreshing the incomplete older ones, and I'm hoping that I can eventually add all the standalone-usable keywords after a bunch of incremental work. It would be cool to see the keywords section of std's docs be a definitive reference as to what each keyword means when you see it, and that's what I'm aiming towards with this work.\n\nI'm far from a Rust expert so there will inevitably be things to fix in this, also I'm not sure if this should be a bunch of quickly-merged PRs or one gradually-updated PR that gets merged once it's done.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bcfa070218e0cb8c76f69636605e8b6a9e2a907", "html_url": "https://github.com/rust-lang/rust/commit/3bcfa070218e0cb8c76f69636605e8b6a9e2a907", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bcfa070218e0cb8c76f69636605e8b6a9e2a907/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18f7d41a654307bb883fed660e53df78b00287d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/18f7d41a654307bb883fed660e53df78b00287d0", "html_url": "https://github.com/rust-lang/rust/commit/18f7d41a654307bb883fed660e53df78b00287d0"}, {"sha": "320ec8137e90bf6dd13b62df033372a33f261bb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/320ec8137e90bf6dd13b62df033372a33f261bb8", "html_url": "https://github.com/rust-lang/rust/commit/320ec8137e90bf6dd13b62df033372a33f261bb8"}], "stats": {"total": 697, "additions": 669, "deletions": 28}, "files": [{"sha": "6c95854c66cbf096fa2b29daa7b5425f2e3ef92d", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 669, "deletions": 28, "changes": 697, "blob_url": "https://github.com/rust-lang/rust/blob/3bcfa070218e0cb8c76f69636605e8b6a9e2a907/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcfa070218e0cb8c76f69636605e8b6a9e2a907/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=3bcfa070218e0cb8c76f69636605e8b6a9e2a907", "patch": "@@ -8,72 +8,713 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[doc(keyword = \"as\")]\n+//\n+/// The keyword for casting a value to a type.\n+///\n+/// `as` is most commonly used to turn primitive types into other primitive types, but it has other\n+/// uses that include turning pointers into addresses, addresses into pointers, and pointers into\n+/// other pointers.\n+///\n+/// ```rust\n+/// let thing1: u8 = 89.0 as u8;\n+/// assert_eq!('B' as u32, 66);\n+/// assert_eq!(thing1 as char, 'Y');\n+/// let thing2: f32 = thing1 as f32 + 10.5;\n+/// assert_eq!(true as u8 + thing2 as u8, 100);\n+/// ```\n+///\n+/// In general, any cast that can be performed via ascribing the type can also be done using `as`,\n+/// so instead of writing `let x: u32 = 123`, you can write `let x = 123 as u32` (Note: `let x: u32\n+/// = 123` would be best in that situation). The same is not true in the other direction, however,\n+/// explicitly using `as` allows a few more coercions that aren't allowed implicitly, such as\n+/// changing the type of a raw pointer or turning closures into raw pointers.\n+///\n+/// Other places `as` is used include as extra syntax for [`crate`] and `use`, to change the name\n+/// something is imported as.\n+///\n+/// For more information on what `as` is capable of, see the [Reference]\n+///\n+/// [Reference]:\n+/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions\n+/// [`crate`]: keyword.crate.html\n+mod as_keyword { }\n+\n+#[doc(keyword = \"const\")]\n+//\n+/// The keyword for defining constants.\n+///\n+/// Sometimes a certain value is used many times throughout a program, and it can become\n+/// inconvenient to copy it over and over. What's more, it's not always possible or desirable to\n+/// make it a variable that gets carried around to each function that needs it. In these cases, the\n+/// `const` keyword provides a convenient alternative to code duplication.\n+///\n+/// ```rust\n+/// const THING: u32 = 0xABAD1DEA;\n+///\n+/// let foo = 123 + THING;\n+/// ```\n+///\n+/// Constants must be explicitly typed, unlike with `let` you can't ignore its type and let the\n+/// compiler figure it out. Any constant value can be defined in a const, which in practice happens\n+/// to be most things that would be reasonable to have a constant (barring `const fn`s, coming\n+/// soon). For example, you can't have a File as a `const`.\n+///\n+/// The only lifetime allowed in a constant is `'static`, which is the lifetime that encompasses\n+/// all others in a Rust program. For example, if you wanted to define a constant string, it would\n+/// look like this:\n+///\n+/// ```rust\n+/// const WORDS: &'static str = \"hello rust!\";\n+/// ```\n+///\n+/// Thanks to static lifetime elision, you usually don't have to explicitly use 'static:\n+///\n+/// ```rust\n+/// const WORDS: &str = \"hello convenience!\";\n+/// ```\n+///\n+/// `const` items looks remarkably similar to `static` items, which introduces some confusion as\n+/// to which one should be used at which times. To put it simply, constants are inlined wherever\n+/// they're used, making using them identical to simply replacing the name of the const with its\n+/// value. Static variables on the other hand point to a single location in memory, which all\n+/// accesses share. This means that, unlike with constants, they can't have destructors, and act as\n+/// a single value across the entire codebase.\n+///\n+/// Constants, as with statics, should always be in SCREAMING_SNAKE_CASE.\n+///\n+/// The `const` keyword is also used in raw pointers in combination with `mut`, as seen in `*const\n+/// T` and `*mut T`. More about that can be read at the [pointer] primitive part of the Rust docs.\n+///\n+/// For more detail on `const`, see the [Rust Book] or the [Reference]\n+///\n+/// [pointer]: primitive.pointer.html\n+/// [Rust Book]:\n+/// https://doc.rust-lang.org/stable/book/2018-edition/ch03-01-variables-and-mutability.html#differences-between-variables-and-constants\n+/// [Reference]: https://doc.rust-lang.org/reference/items/constant-items.html\n+mod const_keyword { }\n+\n+#[doc(keyword = \"crate\")]\n+//\n+/// The `crate` keyword.\n+///\n+/// The primary use of the `crate` keyword is as a part of `extern crate` declarations, which are\n+/// used to specify a dependency on a crate external to the one it's declared in. Crates are the\n+/// fundamental compilation unit of Rust code, and can be seen as libraries or projects. More can\n+/// be read about crates in the [Reference].\n+///\n+/// ```rust ignore\n+/// extern crate rand;\n+/// extern crate my_crate as thing;\n+/// extern crate std; // implicitly added to the root of every Rust project\n+/// ```\n+///\n+/// The `as` keyword can be used to change what the crate is referred to as in your project. If a\n+/// crate name includes a dash, it is implicitly imported with the dashes replaced by underscores.\n+///\n+/// `crate` is also used as in conjunction with `pub` to signify that the item it's attached to\n+/// is public only to other members of the same crate it's in.\n+///\n+/// ```rust\n+/// # #[allow(unused_imports)]\n+/// pub(crate) use std::io::Error as IoError;\n+/// pub(crate) enum CoolMarkerType { }\n+/// pub struct PublicThing {\n+///     pub(crate) semi_secret_thing: bool,\n+/// }\n+/// ```\n+///\n+/// [Reference]: https://doc.rust-lang.org/reference/items/extern-crates.html\n+mod crate_keyword { }\n+\n+#[doc(keyword = \"enum\")]\n+//\n+/// For defining enumerations.\n+///\n+/// Enums in Rust are similar to those of other compiled languages like C, but have important\n+/// differences that make them considerably more powerful. What Rust calls enums are more commonly\n+/// known as [Algebraic Data Types] if you're coming from a functional programming background. The\n+/// important detail is that each enum variant can have data to go along with it.\n+///\n+/// ```rust\n+/// # struct Coord;\n+/// enum SimpleEnum {\n+///     FirstVariant,\n+///     SecondVariant,\n+///     ThirdVariant,\n+/// }\n+///\n+/// enum Location {\n+///     Unknown,\n+///     Anonymous,\n+///     Known(Coord),\n+/// }\n+///\n+/// enum ComplexEnum {\n+///     Nothing,\n+///     Something(u32),\n+///     LotsOfThings {\n+///         usual_struct_stuff: bool,\n+///         blah: String,\n+///     }\n+/// }\n+///\n+/// enum EmptyEnum { }\n+/// ```\n+///\n+/// The first enum shown is the usual kind of enum you'd find in a C-style language. The second\n+/// shows off a hypothetical example of something storing location data, with `Coord` being any\n+/// other type that's needed, for example a struct. The third example demonstrates the kind of\n+/// data a variant can store, ranging from nothing, to a tuple, to an anonymous struct.\n+///\n+/// Instantiating enum variants involves explicitly using the enum's name as its namespace,\n+/// followed by one of its variants. `SimpleEnum::SecondVariant` would be an example from above.\n+/// When data follows along with a variant, such as with rust's built-in [`Option`] type, the data\n+/// is added as the type describes, for example `Option::Some(123)`. The same follows with\n+/// struct-like variants, with things looking like `ComplexEnum::LotsOfThings { usual_struct_stuff:\n+/// true, blah: \"hello!\".to_string(), }`. Empty Enums are similar to () in that they cannot be\n+/// instantiated at all, and are used mainly to mess with the type system in interesting ways.\n+///\n+/// For more information, take a look at the [Rust Book] or the [Reference]\n+///\n+/// [Algebraic Data Types]: https://en.wikipedia.org/wiki/Algebraic_data_type\n+/// [`Option`]: option/enum.Option.html\n+/// [Rust Book]: https://doc.rust-lang.org/book/second-edition/ch06-01-defining-an-enum.html\n+/// [Reference]: https://doc.rust-lang.org/reference/items/enumerations.html\n+mod enum_keyword { }\n+\n+#[doc(keyword = \"extern\")]\n+//\n+/// For external connections in Rust code.\n+///\n+/// The `extern` keyword is used in two places in Rust. One is in conjunction with the [`crate`]\n+/// keyword to make your Rust code aware of other Rust crates in your project, i.e. `extern crate\n+/// lazy_static;`. The other use is in foreign function interfaces (FFI).\n+///\n+/// `extern` is used in two different contexts within FFI. The first is in the form of external\n+/// blocks, for declaring function interfaces that Rust code can call foreign code by.\n+///\n+/// ```rust ignore\n+/// #[link(name = \"my_c_library\")]\n+/// extern \"C\" {\n+///     fn my_c_function(x: i32) -> bool;\n+/// }\n+/// ```\n+///\n+/// This code would attempt to link with `libmy_c_library.so` on unix-like systems and\n+/// `my_c_library.dll` on Windows at runtime, and panic if it can't find something to link to. Rust\n+/// code could then use `my_c_function` as if it were any other unsafe Rust function. Working with\n+/// non-Rust languages and FFI is inherently unsafe, so wrappers are usually built around C APIs.\n+///\n+/// The mirror use case of FFI is also done via the `extern` keyword:\n+///\n+/// ```rust\n+/// #[no_mangle]\n+/// pub extern fn callable_from_c(x: i32) -> bool {\n+///     x % 3 == 0\n+/// }\n+/// ```\n+///\n+/// If compiled as a dylib, the resulting .so could then be linked to from a C library, and the\n+/// function could be used as if it was from any other library.\n+///\n+/// For more information on FFI, check the [Rust book] or the [Reference].\n+///\n+/// [Rust book]:\n+/// https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code\n+/// [Reference]: https://doc.rust-lang.org/reference/items/external-blocks.html\n+mod extern_keyword { }\n+\n #[doc(keyword = \"fn\")]\n //\n-/// The `fn` keyword.\n+/// The keyword for defining functions.\n ///\n-/// The `fn` keyword is used to declare a function.\n+/// Functions are the primary way code is executed within Rust. Function blocks, usually just\n+/// called functions, can be defined in a variety of different places and be assigned many\n+/// different attributes and modifiers.\n ///\n-/// Example:\n+/// Standalone functions that just sit within a module not attached to anything else are common,\n+/// but most functions will end up being inside [`impl`] blocks, either on another type itself, or\n+/// as a trait impl for that type.\n ///\n /// ```rust\n-/// fn some_function() {\n-///     // code goes in here\n+/// fn standalone_function() {\n+///     // code\n+/// }\n+///\n+/// pub fn public_thing(argument: bool) -> String {\n+///     // code\n+///     # \"\".to_string()\n+/// }\n+///\n+/// struct Thing {\n+///     foo: i32,\n+/// }\n+///\n+/// impl Thing {\n+///     pub fn new() -> Self {\n+///         Self {\n+///             foo: 42,\n+///         }\n+///     }\n /// }\n /// ```\n ///\n-/// For more information about functions, take a look at the [Rust Book][book].\n+/// In addition to presenting fixed types in the form of `fn name(arg: type, ..) -> return_type`,\n+/// functions can also declare a list of type parameters along with trait bounds that they fall\n+/// into.\n ///\n-/// [book]: https://doc.rust-lang.org/book/second-edition/ch03-03-how-functions-work.html\n+/// ```rust\n+/// fn generic_function<T: Clone>(x: T) -> (T, T, T) {\n+///     (x.clone(), x.clone(), x.clone())\n+/// }\n+///\n+/// fn generic_where<T>(x: T) -> T\n+///     where T: std::ops::Add<Output=T> + Copy\n+/// {\n+///     x + x + x\n+/// }\n+/// ```\n+///\n+/// Declaring trait bounds in the angle brackets is functionally identical to using a `where`\n+/// clause. It's up to the programmer to decide which works better in each situation, but `where`\n+/// tends to be better when things get longer than one line.\n+///\n+/// Along with being made public via `pub`, `fn` can also have an [`extern`] added for use in\n+/// FFI.\n+///\n+/// For more information on the various types of functions and how they're used, consult the [Rust\n+/// book] or the [Reference].\n+///\n+/// [`impl`]: keyword.impl.html\n+/// [`extern`]: keyword.extern.html\n+/// [Rust book]: https://doc.rust-lang.org/book/second-edition/ch03-03-how-functions-work.html\n+/// [Reference]: https://doc.rust-lang.org/reference/items/functions.html\n mod fn_keyword { }\n \n-#[doc(keyword = \"let\")]\n+#[doc(keyword = \"for\")]\n //\n-/// The `let` keyword.\n+/// The `for` keyword.\n+///\n+/// `for` is primarily used in for-in-loops, but it has a few other pieces of syntactic uses such as\n+/// `impl Trait for Type` (see [`impl`] for more info on that). for-in-loops, or to be more\n+/// precise, iterator loops, are a simple syntactic sugar over an exceedingly common practice\n+/// within Rust, which is to loop over an iterator until that iterator returns None (or `break`\n+/// is called).\n+///\n+/// ```rust\n+/// for i in 0..5 {\n+///     println!(\"{}\", i * 2);\n+/// }\n ///\n-/// The `let` keyword is used to declare a variable.\n+/// for i in std::iter::repeat(5) {\n+///     println!(\"turns out {} never stops being 5\", i);\n+///     break; // would loop forever otherwise\n+/// }\n ///\n-/// Example:\n+/// 'outer: for x in 5..50 {\n+///     for y in 0..10 {\n+///         if x == y {\n+///             break 'outer;\n+///         }\n+///     }\n+/// }\n+/// ```\n+///\n+/// As shown in the example above, `for` loops (along with all other loops) can be tagged, using\n+/// similar syntax to lifetimes (only visually similar, entirely distinct in practice). Giving the\n+/// same tag to `break` breaks the tagged loop, which is useful for inner loops. It is definitely\n+/// not a goto.\n+///\n+/// A `for` loop expands as shown:\n ///\n /// ```rust\n-/// # #![allow(unused_assignments)]\n-/// let x = 3; // We create a variable named `x` with the value `3`.\n+/// # fn code() { }\n+/// # let iterator = 0..2;\n+/// for loop_variable in iterator {\n+///     code()\n+/// }\n+/// ```\n+///\n+/// ```rust\n+/// # fn code() { }\n+/// # let iterator = 0..2;\n+/// {\n+///     let mut _iter = std::iter::IntoIterator::into_iter(iterator);\n+///     loop {\n+///         match _iter.next() {\n+///             Some(loop_variable) => {\n+///                 code()\n+///             },\n+///             None => break,\n+///         }\n+///     }\n+/// }\n+/// ```\n+///\n+/// More details on the functionality shown can be seen at the [`IntoIterator`] docs.\n+///\n+/// For more information on for-loops, see the [Rust book] or the [Reference].\n+///\n+/// [`impl`]: keyword.impl.html\n+/// [`IntoIterator`]: iter/trait.IntoIterator.html\n+/// [Rust book]:\n+/// https://doc.rust-lang.org/book/2018-edition/ch03-05-control-flow.html#looping-through-a-collection-with-for\n+/// [Reference]: https://doc.rust-lang.org/reference/expressions/loop-expr.html#iterator-loops\n+mod for_keyword { }\n+\n+#[doc(keyword = \"if\")]\n+//\n+/// If statements and expressions.\n+///\n+/// `if` is a familiar construct to most programmers, and is the main way you'll often do logic in\n+/// your code. However, unlike in most languages, `if` blocks can also act as expressions.\n+///\n+/// ```rust\n+/// # let rude = true;\n+/// if 1 == 2 {\n+///     println!(\"whoops, mathematics broke\");\n+/// } else {\n+///     println!(\"everything's fine!\");\n+/// }\n+///\n+/// let greeting = if rude {\n+///     \"sup nerd.\"\n+/// } else {\n+///     \"hello, friend!\"\n+/// };\n+///\n+/// if let Ok(x) = \"123\".parse::<i32>() {\n+///     println!(\"{} double that and you get {}!\", greeting, x * 2);\n+/// }\n+/// ```\n+///\n+/// Shown above are the three typical forms an `if` block comes in. First is the usual kind of\n+/// thing you'd see in many languages, with an optional `else` block. Second uses `if` as an\n+/// expression, which is only possible if all branches return the same type. An `if` expression can\n+/// be used everywhere you'd expect. The third kind of `if` block is an `if let` block, which\n+/// behaves similarly to using a `match` expression:\n+///\n+/// ```rust\n+/// if let Some(x) = Some(123) {\n+///     // code\n+///     # let _ = x;\n+/// } else {\n+///     // something else\n+/// }\n+///\n+/// match Some(123) {\n+///     Some(x) => {\n+///         // code\n+///         # let _ = x;\n+///     },\n+///     _ => {\n+///         // something else\n+///     },\n+/// }\n+/// ```\n+///\n+/// Each kind of `if` expression can be mixed and matched as needed.\n+///\n+/// ```rust\n+/// if true == false {\n+///     println!(\"oh no\");\n+/// } else if \"something\" == \"other thing\" {\n+///     println!(\"oh dear\");\n+/// } else if let Some(200) = \"blarg\".parse::<i32>().ok() {\n+///     println!(\"uh oh\");\n+/// } else {\n+///     println!(\"phew, nothing's broken\");\n+/// }\n+/// ```\n+///\n+/// The `if` keyword is used in one other place in Rust, namely as a part of pattern matching\n+/// itself, allowing patterns such as `Some(x) if x > 200` to be used.\n+///\n+/// For more information on `if` expressions, see the [Rust book] or the [Reference].\n+///\n+/// [Rust book]:\n+/// https://doc.rust-lang.org/stable/book/2018-edition/ch03-05-control-flow.html#if-expressions\n+/// [Reference]: https://doc.rust-lang.org/reference/expressions/if-expr.html\n+mod if_keyword { }\n+\n+#[doc(keyword = \"impl\")]\n+//\n+/// The implementation-defining keyword.\n+///\n+/// The `impl` keyword is primarily used to define implementations on types. Inherent\n+/// implementations are standalone, while trait implementations are used to implement traits for\n+/// types, or other traits.\n+///\n+/// Functions and consts can both be defined in an implementation. A function defined in an\n+/// `impl` block can be standalone, meaning it would be called like `Foo::bar()`. If the function\n+/// takes `self`, `&self`, or `&mut self` as its first argument, it can also be called using\n+/// method-call syntax, a familiar feature to any object oriented programmer, like `foo.bar()`.\n+///\n+/// ```rust\n+/// struct Example {\n+///     number: i32,\n+/// }\n+///\n+/// impl Example {\n+///     fn boo() {\n+///         println!(\"boo! Example::boo() was called!\");\n+///     }\n+///\n+///     fn answer(&mut self) {\n+///         self.number += 42;\n+///     }\n+///\n+///     fn get_number(&self) -> i32 {\n+///         self.number\n+///     }\n+/// }\n+///\n+/// trait Thingy {\n+///     fn do_thingy(&self);\n+/// }\n+///\n+/// impl Thingy for Example {\n+///     fn do_thingy(&self) {\n+///         println!(\"doing a thing! also, number is {}!\", self.number);\n+///     }\n+/// }\n /// ```\n ///\n-/// By default, all variables are **not** mutable. If you want a mutable variable,\n-/// you'll have to use the `mut` keyword.\n+/// For more information on implementations, see the [Rust book][book1] or the [Reference].\n ///\n-/// Example:\n+/// The other use of the `impl` keyword is in `impl Trait` syntax, which can be seen as a shorthand\n+/// for \"a concrete type that implements this trait\". Its primary use is working with closures,\n+/// which have type definitions generated at compile time that can't be simply typed out.\n+///\n+/// ```rust\n+/// fn thing_returning_closure() -> impl Fn(i32) -> bool {\n+///     println!(\"here's a closure for you!\");\n+///     |x: i32| x % 3 == 0\n+/// }\n+/// ```\n+///\n+/// For more information on `impl Trait` syntax, see the [Rust book][book2].\n+///\n+/// [book1]: https://doc.rust-lang.org/stable/book/2018-edition/ch05-03-method-syntax.html\n+/// [Reference]: https://doc.rust-lang.org/reference/items/implementations.html\n+/// [book2]:\n+/// https://doc.rust-lang.org/stable/book/2018-edition/ch10-02-traits.html#returning-traits\n+mod impl_keyword { }\n+\n+#[doc(keyword = \"let\")]\n+//\n+/// The variable binding keyword.\n+///\n+/// The primary use for the `let` keyword is in `let` statements, which are used to introduce a new\n+/// set of variables into the current scope, as given by a pattern.\n ///\n /// ```rust\n /// # #![allow(unused_assignments)]\n-/// let mut x = 3; // We create a mutable variable named `x` with the value `3`.\n+/// let thing1: i32 = 100;\n+/// let thing2 = 200 + thing1;\n+///\n+/// let mut changing_thing = true;\n+/// changing_thing = false;\n ///\n-/// x += 4; // `x` is now equal to `7`.\n+/// let (part1, part2) = (\"first\", \"second\");\n+///\n+/// struct Example {\n+///     a: bool,\n+///     b: u64,\n+/// }\n+///\n+/// let Example { a, b: _ } = Example {\n+///     a: true,\n+///     b: 10004,\n+/// };\n+/// assert!(a);\n+/// ```\n+///\n+/// The pattern is most commonly a single variable, which means no pattern matching is done and\n+/// the expression given is bound to the variable. Apart from that, patterns used in `let` bindings\n+/// can be as complicated as needed, given that the pattern is exhaustive. See the [Rust\n+/// book][book1] for more information on pattern matching. The type of the pattern is optionally\n+/// given afterwards, but if left blank is automatically inferred by the compiler if possible.\n+///\n+/// Variables in Rust are immutable by default, and require the `mut` keyword to be made mutable.\n+///\n+/// Multiple variables can be defined with the same name, known as shadowing. This doesn't affect\n+/// the original variable in any way beyond being unable to directly access it beyond the point of\n+/// shadowing. It continues to remain in scope, getting dropped only when it falls out of scope.\n+/// Shadowed variables don't need to have the same type as the variables shadowing them.\n+///\n+/// ```rust\n+/// let shadowing_example = true;\n+/// let shadowing_example = 123.4;\n+/// let shadowing_example = shadowing_example as u32;\n+/// let mut shadowing_example = format!(\"cool! {}\", shadowing_example);\n+/// shadowing_example += \" something else!\"; // not shadowing\n /// ```\n ///\n-/// For more information about the `let` keyword, take a look at the [Rust Book][book].\n+/// Other places the `let` keyword is used include along with [`if`], in the form of `if let`\n+/// expressions. They're useful if the pattern being matched isn't exhaustive, such as with\n+/// enumerations. `while let` also exists, which runs a loop with a pattern matched value until\n+/// that pattern can't be matched.\n ///\n-/// [book]: https://doc.rust-lang.org/book/second-edition/ch03-01-variables-and-mutability.html\n+/// For more information on the `let` keyword, see the [Rust book] or the [Reference]\n+///\n+/// [book1]: https://doc.rust-lang.org/stable/book/2018-edition/ch06-02-match.html\n+/// [`if`]: keyword.if.html\n+/// [book2]:\n+/// https://doc.rust-lang.org/stable/book/2018-edition/ch18-01-all-the-places-for-patterns.html#let-statements\n+/// [Reference]: https://doc.rust-lang.org/reference/statements.html#let-statements\n mod let_keyword { }\n \n-#[doc(keyword = \"struct\")]\n+#[doc(keyword = \"loop\")]\n //\n-/// The `struct` keyword.\n+/// The loop-defining keyword.\n ///\n-/// The `struct` keyword is used to define a struct type.\n+/// `loop` is used to define the simplest kind of loop supported in Rust. It runs the code inside\n+/// it until the code uses `break` or the program exits.\n ///\n-/// Example:\n+/// ```rust\n+/// loop {\n+///     println!(\"hello world forever!\");\n+///     # break;\n+/// }\n ///\n+/// let mut i = 0;\n+/// loop {\n+///     println!(\"i is {}\", i);\n+///     if i > 10 {\n+///         break;\n+///     }\n+///     i += 1;\n+/// }\n /// ```\n-/// struct Foo {\n-///     field1: u32,\n+///\n+/// Unlike the other kinds of loops in Rust (`while`, `while let`, and `for`), loops can be used as\n+/// expressions that return values via `break`.\n+///\n+/// ```rust\n+/// let mut i = 1;\n+/// let something = loop {\n+///     i *= 2;\n+///     if i > 100 {\n+///         break i;\n+///     }\n+/// };\n+/// assert_eq!(something, 128);\n+/// ```\n+///\n+/// Every `break` in a loop has to have the same type. When it's not explicitly giving something,\n+/// `break;` returns `()`.\n+///\n+/// For more information on `loop` and loops in general, see the [Reference].\n+///\n+/// [Reference]: https://doc.rust-lang.org/reference/expressions/loop-expr.html\n+mod loop_keyword { }\n+\n+#[doc(keyword = \"struct\")]\n+//\n+/// The keyword used to define structs.\n+///\n+/// Structs in Rust come in three flavours: Structs with named fields, tuple structs, and unit\n+/// structs.\n+///\n+/// ```rust\n+/// struct Regular {\n+///     field1: f32,\n ///     field2: String,\n+///     pub field3: bool\n+/// }\n+///\n+/// struct Tuple(u32, String);\n+///\n+/// struct Unit;\n+/// ```\n+///\n+/// Regular structs are the most commonly used. Each field defined within them has a name and a\n+/// type, and once defined can be accessed using `example_struct.field` syntax. The fields of a\n+/// struct share its mutability, so `foo.bar = 2;` would only be valid if `foo` was mutable. Adding\n+/// `pub` to a field makes it visible to code in other modules, as well as allowing it to be\n+/// directly accessed and modified.\n+///\n+/// Tuple structs are similar to regular structs, but its fields have no names. They are used like\n+/// tuples, with deconstruction possible via `let TupleStruct(x, y) = foo;` syntax.  For accessing\n+/// individual variables, the same syntax is used as with regular tuples, namely `foo.0`, `foo.1`,\n+/// etc, starting at zero.\n+///\n+/// Unit structs are most commonly used as marker. They have a size of zero bytes, but unlike empty\n+/// enums they can be instantiated, making them isomorphic to the unit type `()`. Unit structs are\n+/// useful when you need to implement a trait on something, but don't need to store any data inside\n+/// it.\n+///\n+/// # Instantiation\n+///\n+/// Structs can be instantiated in different ways, all of which can be mixed and\n+/// matched as needed. The most common way to make a new struct is via a constructor method such as\n+/// `new()`, but when that isn't available (or you're writing the constructor itself), struct\n+/// literal syntax is used:\n+///\n+/// ```rust\n+/// # struct Foo { field1: f32, field2: String, etc: bool }\n+/// let example = Foo {\n+///     field1: 42.0,\n+///     field2: \"blah\".to_string(),\n+///     etc: true,\n+/// };\n+/// ```\n+///\n+/// It's only possible to directly instantiate a struct using struct literal syntax when all of its\n+/// fields are visible to you.\n+///\n+/// There are a handful of shortcuts provided to make writing constructors more convenient, most\n+/// common of which is the Field Init shorthand. When there is a variable and a field of the same\n+/// name, the assignment can be simplified from `field: field` into simply `field`. The following\n+/// example of a hypothetical constructor demonstrates this:\n+///\n+/// ```rust\n+/// struct User {\n+///     name: String,\n+///     admin: bool,\n+/// }\n+///\n+/// impl User {\n+///     pub fn new(name: String) -> Self {\n+///         Self {\n+///             name,\n+///             admin: false,\n+///         }\n+///     }\n /// }\n /// ```\n ///\n-/// There are different kinds of structs. For more information, take a look at the\n-/// [Rust Book][book].\n+/// Another shortcut for struct instantiation is available, used when you need to make a new\n+/// struct that has the same values as most of a previous struct of the same type, called struct\n+/// update syntax:\n+///\n+/// ```rust\n+/// # struct Foo { field1: String, field2: () }\n+/// # let thing = Foo { field1: \"\".to_string(), field2: () };\n+/// let updated_thing = Foo {\n+///     field1: \"a new value\".to_string(),\n+///     ..thing\n+/// };\n+/// ```\n+///\n+/// Tuple structs are instantiated in the same way as tuples themselves, except with the struct's\n+/// name as a prefix: `Foo(123, false, 0.1)`.\n+///\n+/// Empty structs are instantiated with just their name, and don't need anything else. `let thing =\n+/// EmptyStruct;`\n+///\n+/// # Style conventions\n+///\n+/// Structs are always written in CamelCase, with few exceptions. While the trailing comma on a\n+/// struct's list of fields can be omitted, it's usually kept for convenience in adding and\n+/// removing fields down the line.\n+///\n+/// For more information on structs, take a look at the [Rust Book][book] or the\n+/// [Reference][reference].\n ///\n+/// [`PhantomData`]: marker/struct.PhantomData.html\n /// [book]: https://doc.rust-lang.org/book/second-edition/ch05-01-defining-structs.html\n+/// [reference]: https://doc.rust-lang.org/reference/items/structs.html\n mod struct_keyword { }"}]}