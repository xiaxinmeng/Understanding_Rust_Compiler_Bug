{"sha": "7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMGVjODZjNGEzODJmM2Q5MzdjNGJmNWYxMmFiNjk0NjhkOTkxYzE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-27T19:03:21Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-27T19:03:21Z"}, "message": "Merge remote-tracking branch 'remotes/origin/incoming' into incoming", "tree": {"sha": "8a793aa83482c45a0aaae05f1bfac087ecee0b59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a793aa83482c45a0aaae05f1bfac087ecee0b59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "html_url": "https://github.com/rust-lang/rust/commit/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea36a0dee1630e24ba2889ca13550026b1af4f9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea36a0dee1630e24ba2889ca13550026b1af4f9d", "html_url": "https://github.com/rust-lang/rust/commit/ea36a0dee1630e24ba2889ca13550026b1af4f9d"}, {"sha": "a6d9689399d091c3265f00434a69c551a61c28dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6d9689399d091c3265f00434a69c551a61c28dc", "html_url": "https://github.com/rust-lang/rust/commit/a6d9689399d091c3265f00434a69c551a61c28dc"}], "stats": {"total": 4366, "additions": 2221, "deletions": 2145}, "files": [{"sha": "33ac21e6db9d89facc8e177c07b27cba8c39f151", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -93,6 +93,7 @@ Josh Matthews <josh@joshmatthews.net>\n Joshua Clark <joshua.clark@txstate.edu>\n Joshua Wise <joshua@joshuawise.com>\n Jyun-Yan You <jyyou@cs.nctu.edu.tw>\n+Kang Seonghoon <kang.seonghoon@mearie.org>\n Kelly Wilson <wilsonk@cpsc.ucalgary.ca>\n Kevin Atkinson <kevina@cs.utah.edu>\n Kevin Cantu <me@kevincantu.org>"}, {"sha": "3576e43468dd73ffe0721937b48149b4410d8677", "filename": "configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/configure", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -678,7 +678,7 @@ do\n         LLVM_BUILD_DIR=${CFG_BUILD_DIR}llvm/$t\n         if [ ! -z \"$CFG_DISABLE_OPTIMIZE_LLVM\" ]\n         then\n-            LLVM_DBG_OPTS=\"\"\n+            LLVM_DBG_OPTS=\"--enable-debug-symbols --disable-optimized\"\n             # Just use LLVM straight from its build directory to\n             # avoid 'make install' time\n             LLVM_INST_DIR=$LLVM_BUILD_DIR/Debug+Asserts"}, {"sha": "a4e4e4cdf24f4a8aea8b1577bc0b9e88840adb73", "filename": "doc/rust.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -1610,11 +1610,10 @@ The following are examples of structure expressions:\n ~~~~\n # struct Point { x: float, y: float }\n # struct TuplePoint(float, float);\n-# mod game { pub struct User { name: &str, age: uint, mut score: uint } }\n-# use game;\n+# mod game { pub struct User { name: &str, age: uint, score: uint } }\n Point {x: 10f, y: 20f};\n TuplePoint(10f, 20f);\n-let u = game::User {name: \"Joe\", age: 35u, mut score: 100_000};\n+let u = game::User {name: \"Joe\", age: 35u, score: 100_000};\n ~~~~\n \n A structure expression forms a new value of the named structure type."}, {"sha": "0c1624706bfeb4df708bba26e4a0e94ce5423f8c", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 4, "deletions": 157, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -348,12 +348,12 @@ mutations:\n ~~~ {.xfail-test}\n fn example3() -> int {\n     struct R { g: int }\n-    struct S { mut f: ~R }\n+    struct S { f: ~R }\n \n-    let mut x = ~S {mut f: ~R {g: 3}};\n+    let mut x = ~S {f: ~R {g: 3}};\n     let y = &x.f.g;\n-    x = ~S {mut f: ~R {g: 4}}; // Error reported here.\n-    x.f = ~R {g: 5};           // Error reported here.\n+    x = ~S {f: ~R {g: 4}};  // Error reported here.\n+    x.f = ~R {g: 5};        // Error reported here.\n     *y\n }\n ~~~\n@@ -362,91 +362,6 @@ In this case, two errors are reported, one when the variable `x` is\n modified and another when `x.f` is modified. Either modification would\n invalidate the pointer `y`.\n \n-Things get trickier when the unique box is not uniquely owned by the\n-stack frame, or when there is no way for the compiler to determine the\n-box's owner. Consider a program like this:\n-\n-~~~ {.xfail-test}\n-struct R { g: int }\n-struct S { mut f: ~R }\n-fn example5a(x: @S, callback: @fn()) -> int {\n-    let y = &x.f.g;   // Error reported here.\n-    ...\n-    callback();\n-    ...\n-#   return 0;\n-}\n-~~~\n-\n-Here the heap looks something like:\n-\n-~~~ {.notrust}\n-     Stack            Managed Heap       Exchange Heap\n-\n-  x +------+        +-------------+       +------+\n-    | @... | ---->  | mut f: ~... | --+-> | g: 3 |\n-  y +------+        +-------------+   |   +------+\n-    | &int | -------------------------+\n-    +------+\n-~~~\n-\n-In this case, the owning reference to the value being borrowed is\n-`x.f`. Moreover, `x.f` is both mutable and *aliasable*. Aliasable\n-means that there may be other pointers to that same managed box, so\n-even if the compiler were to prove an absence of mutations to `x.f`,\n-code could mutate `x.f` indirectly by changing an alias of\n-`x`. Therefore, to be safe, the compiler only accepts *pure* actions\n-during the lifetime of `y`. We define what \"pure\" means in the section\n-on [purity](#purity).\n-\n-Besides ensuring purity, the only way to borrow the interior of a\n-unique found in aliasable memory is to ensure that the borrowed field\n-itself is also unique, as in the following example:\n-\n-~~~\n-struct R { g: int }\n-struct S { f: ~R }\n-fn example5b(x: @S) -> int {\n-    let y = &x.f.g;\n-    ...\n-# return 0;\n-}\n-~~~\n-\n-Here, the field `f` is not declared as mutable. But that is enough for\n-the compiler to know that, even if aliases to `x` exist, the field `f`\n-cannot be changed and hence the unique box `g` will remain valid.\n-\n-If you do have a unique box in a mutable field, and you wish to borrow\n-it, one option is to use the swap operator to move that unique box\n-onto your stack:\n-\n-~~~\n-struct R { g: int }\n-struct S { mut f: ~R }\n-fn example5c(x: @S) -> int {\n-    let mut v = ~R {g: 0};\n-    v <-> x.f;         // Swap v and x.f\n-    { // Block constrains the scope of `y`:\n-        let y = &v.g;\n-        ...\n-    }\n-    x.f = v;          // Replace x.f\n-    ...\n-# return 0;\n-}\n-~~~\n-\n-Of course, this has the side effect of modifying your managed box for\n-the duration of the borrow, so it only works when you know that you\n-won't be accessing that same box for the duration of the loan. Also,\n-it is sometimes necessary to introduce additional blocks to constrain\n-the scope of the loan.  In this example, the borrowed pointer `y`\n-would still be in scope when you moved the value `v` back into `x.f`,\n-and hence moving `v` would be considered illegal.  You cannot move\n-values if they are the targets of valid outstanding loans. Introducing\n-the block restricts the scope of `y`, making the move legal.\n-\n # Borrowing and enums\n \n The previous example showed that the type system forbids any borrowing\n@@ -558,11 +473,6 @@ permit `ref` bindings into data owned by the stack frame even if the\n data are mutable, but otherwise it requires that the data reside in\n immutable memory.\n \n-> ***Note:*** Right now, pattern bindings not explicitly annotated\n-> with `ref` or `copy` use a special mode of \"implicit by reference\".\n-> This is changing as soon as we finish updating all the existing code\n-> in the compiler that relies on the current settings.\n-\n # Returning borrowed pointers\n \n So far, all of the examples we've looked at use borrowed pointers in a\n@@ -745,69 +655,6 @@ fn select<T>(shape: &Shape, threshold: float,\n \n This is equivalent to the previous definition.\n \n-# Purity\n-\n-As mentioned before, the Rust compiler offers a kind of escape hatch\n-that permits borrowing of any data, as long as the actions that occur\n-during the lifetime of the borrow are pure. Pure actions are those\n-that only modify data owned by the current stack frame. The compiler\n-can therefore permit arbitrary pointers into the heap, secure in the\n-knowledge that no pure action will ever cause them to become\n-invalidated (the compiler must still track data on the stack which is\n-borrowed and enforce those rules normally, of course). A pure function\n-in Rust is referentially transparent: it returns the same results\n-given the same (observably equivalent) inputs. That is because while\n-pure functions are allowed to modify data, they may only modify\n-*stack-local* data, which cannot be observed outside the scope of the\n-function itself. (Using an `unsafe` block invalidates this guarantee.)\n-\n-Let\u2019s revisit a previous example and show how purity can affect\n-typechecking. Here is `example5a()`, which borrows the interior of a\n-unique box found in an aliasable, mutable location, only now we\u2019ve\n-replaced the `...` with some specific code:\n-\n-~~~\n-struct R { g: int }\n-struct S { mut f: ~R }\n-fn example5a(x: @S ...) -> int {\n-    let y = &x.f.g;   // Unsafe\n-    *y + 1        \n-}\n-~~~\n-\n-The new code simply returns an incremented version of `y`. This code\n-clearly doesn't mutate the heap, so the compiler is satisfied.\n-\n-But suppose we wanted to pull the increment code into a helper, like\n-this:\n-\n-~~~\n-fn add_one(x: &int) -> int { *x + 1 }\n-~~~\n-\n-We can now update `example5a()` to use `add_one()`:\n-\n-~~~\n-# struct R { g: int }\n-# struct S { mut f: ~R }\n-# pure fn add_one(x: &int) -> int { *x + 1 }\n-fn example5a(x: @S ...) -> int {\n-    let y = &x.f.g;\n-    add_one(y)        // Error reported here\n-}\n-~~~\n-\n-But now the compiler will report an error again. The reason is that it\n-only considers one function at a time (like most typecheckers), and\n-so it does not know that `add_one()` consists of pure code. We can\n-help the compiler by labeling `add_one()` as pure:\n-\n-~~~\n-pure fn add_one(x: &int) -> int { *x + 1 }\n-~~~\n-\n-With this change, the modified version of `example5a()` will again compile.\n-\n # Conclusion\n \n So there you have it: a (relatively) brief tour of the borrowed pointer"}, {"sha": "b7659376ed65cddbf25bd8cc5dc007e8a456789f", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -220,21 +220,21 @@ extern mod std;\n use libc::c_ulonglong;\n \n struct timeval {\n-    mut tv_sec: c_ulonglong,\n-    mut tv_usec: c_ulonglong\n+    tv_sec: c_ulonglong,\n+    tv_usec: c_ulonglong\n }\n \n #[nolink]\n extern mod lib_c {\n-    fn gettimeofday(tv: *timeval, tz: *()) -> i32;\n+    fn gettimeofday(tv: *mut timeval, tz: *()) -> i32;\n }\n fn unix_time_in_microseconds() -> u64 {\n     unsafe {\n-        let x = timeval {\n-            mut tv_sec: 0 as c_ulonglong,\n-            mut tv_usec: 0 as c_ulonglong\n+        let mut x = timeval {\n+            tv_sec: 0 as c_ulonglong,\n+            tv_usec: 0 as c_ulonglong\n         };\n-        lib_c::gettimeofday(ptr::addr_of(&x), ptr::null());\n+        lib_c::gettimeofday(&mut x, ptr::null());\n         return (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n     }\n }"}, {"sha": "22d0ff8bf78a2bd41b5f60b3c59ad871715bf645", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -468,7 +468,6 @@ Here is the function that implements the child task:\n \n ~~~~\n # use std::comm::DuplexStream;\n-# use comm::{Port, Chan};\n fn stringifier(channel: &DuplexStream<~str, uint>) {\n     let mut value: uint;\n     loop {\n@@ -491,7 +490,6 @@ Here is the code for the parent task:\n \n ~~~~\n # use std::comm::DuplexStream;\n-# use comm::{Port, Chan};\n # use task::spawn;\n # fn stringifier(channel: &DuplexStream<~str, uint>) {\n #     let mut value: uint;"}, {"sha": "f94087618778835f8baa157ccdd37ffa74b9746e", "filename": "doc/tutorial.md", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -556,7 +556,7 @@ let mut x = 5;\n loop {\n     x += x - 3;\n     if x % 5 == 0 { break; }\n-    io::println(int::str(x));\n+    io::println(int::to_str(x));\n }\n ~~~~\n \n@@ -583,19 +583,16 @@ Inherited mutability means that any field of a struct may be mutable, if the\n struct is in a mutable slot (or a field of a struct in a mutable slot, and\n so forth).\n \n-A struct that is not mutable due to inherited mutability may declare some\n-of its fields nevertheless mutable, using the `mut` keyword.\n-\n ~~~~\n struct Stack {\n     content: ~[int],\n-    mut head: uint\n+    head: uint\n }\n ~~~~\n \n-With a value of such a type, you can do `mystack.head += 1`. If `mut` were\n-omitted from the type, such an assignment to a struct without inherited\n-mutability would result in a type error.\n+With a value (say, `mystack`) of such a type in a mutable location, you can do\n+`mystack.head += 1`. But in an immutable location, such an assignment to a\n+struct without inherited mutability would result in a type error.\n \n `match` patterns destructure structs. The basic syntax is\n `Name { fieldname: pattern, ... }`:\n@@ -938,19 +935,19 @@ type that contains managed boxes or other managed types.\n ~~~\n // A linked list node\n struct Node {\n-    mut next: MaybeNode,\n-    mut prev: MaybeNode,\n+    next: MaybeNode,\n+    prev: MaybeNode,\n     payload: int\n }\n \n enum MaybeNode {\n-    SomeNode(@Node),\n+    SomeNode(@mut Node),\n     NoNode\n }\n \n-let node1 = @Node { next: NoNode, prev: NoNode, payload: 1 };\n-let node2 = @Node { next: NoNode, prev: NoNode, payload: 2 };\n-let node3 = @Node { next: NoNode, prev: NoNode, payload: 3 };\n+let node1 = @mut Node { next: NoNode, prev: NoNode, payload: 1 };\n+let node2 = @mut Node { next: NoNode, prev: NoNode, payload: 2 };\n+let node3 = @mut Node { next: NoNode, prev: NoNode, payload: 3 };\n \n // Link the three list nodes together\n node1.next = SomeNode(node2);\n@@ -1129,7 +1126,7 @@ points to.\n \n ~~~\n let managed = @mut 10;\n-let owned = ~mut 20;\n+let mut owned = ~20;\n \n let mut value = 30;\n let borrowed = &mut value;\n@@ -2273,7 +2270,9 @@ fn chicken_farmer() {\n     // The same, but name it `my_chicken`\n     use my_chicken = farm::chicken;\n     ...\n+# my_chicken();\n }\n+# chicken();\n # }\n ~~~\n \n@@ -2300,8 +2299,8 @@ mod farm {\n # impl Human { fn rest(&self) { } }\n # pub fn make_me_a_farm() -> farm::Farm { farm::Farm { chickens: ~[], cows: ~[], farmer: Human(0) } }\n     pub struct Farm {\n-        priv mut chickens: ~[Chicken],\n-        priv mut cows: ~[Cow],\n+        priv chickens: ~[Chicken],\n+        priv cows: ~[Cow],\n         farmer: Human\n     }\n "}, {"sha": "5a6acbaddda0a7ac0462b4956e8969adc166d7db", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -66,22 +66,17 @@\n                     \"trait\" \"struct\" \"fn\" \"enum\"\n                     \"impl\"))\n       (puthash word 'def table))\n-    (dolist (word '(\"again\" \"assert\"\n-                    \"break\"\n-                    \"copy\"\n-                    \"do\" \"drop\"\n-                    \"else\" \"export\" \"extern\"\n-                    \"fail\" \"for\"\n-                    \"if\" \"use\"\n-                    \"let\" \"log\" \"loop\"\n-                    \"move\" \"new\"\n-                    \"pure\" \"pub\" \"priv\"\n-                    \"ref\" \"return\" \"static\"\n-                    \"unchecked\" \"unsafe\"\n-                    \"while\"))\n+    (dolist (word '(\"as\" \"break\"\n+                    \"copy\" \"do\" \"drop\" \"else\"\n+                    \"extern\" \"for\" \"if\" \"let\" \"log\"\n+                    \"loop\" \"once\" \"priv\" \"pub\" \"pure\"\n+                    \"ref\" \"return\" \"static\" \"unsafe\" \"use\"\n+                    \"while\" \"while\"\n+                    \"assert\"\n+                    \"mut\"))\n       (puthash word t table))\n     (puthash \"match\" 'alt table)\n-    (dolist (word '(\"true\" \"false\")) (puthash word 'atom table))\n+    (dolist (word '(\"self\" \"true\" \"false\")) (puthash word 'atom table))\n     table))\n ;; FIXME type-context keywords\n "}, {"sha": "6b4937af2d3d354c132e6dabcc36faf0e3921a7b", "filename": "src/etc/x86.supp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Fetc%2Fx86.supp", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Fetc%2Fx86.supp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fx86.supp?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -422,6 +422,13 @@\n    ...\n }\n \n+{\n+   enum-instruction-scheduling-9\n+   Memcheck:Cond\n+   fun:*get_authority*\n+   ...\n+}\n+\n {  \n    llvm-user-new-leak\n    Memcheck:Leak"}, {"sha": "ab604d1f0b6fe3cf44ca4e1dd78fa96bc45d63e6", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -168,7 +168,7 @@ pub mod traits {\n     use kinds::Copy;\n     use ops::Add;\n \n-    pub impl<T:Copy> Add<&[const T],@[T]> for @[T] {\n+    impl<T:Copy> Add<&[const T],@[T]> for @[T] {\n         #[inline(always)]\n         pure fn add(&self, rhs: & &self/[const T]) -> @[T] {\n             append(*self, (*rhs))"}, {"sha": "5887df6802f57502ecb705fe08a2d9e64c7d498c", "filename": "src/libcore/cell.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::option;\n-use core::prelude::*;\n+use option;\n+use prelude::*;\n \n /// A dynamic, mutable location.\n ///", "previous_filename": "src/libstd/cell.rs"}, {"sha": "ed18388f5783b48633179280ff6da8721d21a5ff", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -51,6 +51,7 @@ Implicitly, all crates behave as if they included the following prologue:\n #[warn(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n #[allow(deprecated_self)];\n+#[allow(deprecated_mutable_fields)];\n \n /* The Prelude. */\n \n@@ -142,6 +143,7 @@ pub mod dlist;\n #[path=\"iter-trait.rs\"] #[merge = \"iter-trait/dlist.rs\"]\n pub mod dlist_iter;\n pub mod hashmap;\n+pub mod cell;\n \n \n /* Tasks and communication */"}, {"sha": "9f2036c5f41a6b4b949c538c7b26966d1cff812c", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -133,18 +133,6 @@ impl<A> DVec<A> {\n         self.check_out(|v| self.give_back(f(v)))\n     }\n \n-    /**\n-     * Swaps out the current vector and hands it off to a user-provided\n-     * function `f`.  The function should transform it however is desired\n-     * and return a new vector to replace it with.\n-     */\n-    #[inline(always)]\n-    fn swap_mut(f: &fn(v: ~[mut A]) -> ~[mut A]) {\n-        do self.swap |v| {\n-            vec::cast_from_mut(f(vec::cast_to_mut(v)))\n-        }\n-    }\n-\n     /// Returns the number of elements currently in the dvec\n     #[inline(always)]\n     pure fn len() -> uint {\n@@ -217,7 +205,7 @@ impl<A> DVec<A> {\n     }\n \n     /// Gives access to the vector as a slice with mutable contents\n-    fn borrow_mut<R>(op: fn(x: &[mut A]) -> R) -> R {\n+    fn borrow_mut<R>(op: &fn(x: &mut [A]) -> R) -> R {\n         do self.check_out |v| {\n             let mut v = v;\n             let result = op(v);"}, {"sha": "4a1a1952907c6f65a800041478ca7e63127601fc", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -186,42 +186,46 @@ fn SipState(key0: u64, key1: u64) -> SipState {\n     state\n }\n \n+// sadly, these macro definitions can't appear later,\n+// because they're needed in the following defs;\n+// this design could be improved.\n+\n+macro_rules! u8to64_le (\n+    ($buf:expr, $i:expr) =>\n+    ($buf[0+$i] as u64 |\n+     $buf[1+$i] as u64 << 8 |\n+     $buf[2+$i] as u64 << 16 |\n+     $buf[3+$i] as u64 << 24 |\n+     $buf[4+$i] as u64 << 32 |\n+     $buf[5+$i] as u64 << 40 |\n+     $buf[6+$i] as u64 << 48 |\n+     $buf[7+$i] as u64 << 56)\n+)\n+\n+macro_rules! rotl (\n+    ($x:expr, $b:expr) =>\n+    (($x << $b) | ($x >> (64 - $b)))\n+)\n+\n+macro_rules! compress (\n+    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n+    ({\n+        $v0 += $v1; $v1 = rotl!($v1, 13); $v1 ^= $v0;\n+        $v0 = rotl!($v0, 32);\n+        $v2 += $v3; $v3 = rotl!($v3, 16); $v3 ^= $v2;\n+        $v0 += $v3; $v3 = rotl!($v3, 21); $v3 ^= $v0;\n+        $v2 += $v1; $v1 = rotl!($v1, 17); $v1 ^= $v2;\n+        $v2 = rotl!($v2, 32);\n+    })\n+)\n+\n \n impl io::Writer for SipState {\n \n     // Methods for io::writer\n     #[inline(always)]\n     fn write(&self, msg: &[const u8]) {\n \n-        macro_rules! u8to64_le (\n-            ($buf:expr, $i:expr) =>\n-            ($buf[0+$i] as u64 |\n-             $buf[1+$i] as u64 << 8 |\n-             $buf[2+$i] as u64 << 16 |\n-             $buf[3+$i] as u64 << 24 |\n-             $buf[4+$i] as u64 << 32 |\n-             $buf[5+$i] as u64 << 40 |\n-             $buf[6+$i] as u64 << 48 |\n-             $buf[7+$i] as u64 << 56)\n-        );\n-\n-        macro_rules! rotl (\n-            ($x:expr, $b:expr) =>\n-            (($x << $b) | ($x >> (64 - $b)))\n-        );\n-\n-        macro_rules! compress (\n-            ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n-            ({\n-                $v0 += $v1; $v1 = rotl!($v1, 13); $v1 ^= $v0;\n-                $v0 = rotl!($v0, 32);\n-                $v2 += $v3; $v3 = rotl!($v3, 16); $v3 ^= $v2;\n-                $v0 += $v3; $v3 = rotl!($v3, 21); $v3 ^= $v0;\n-                $v2 += $v1; $v1 = rotl!($v1, 17); $v1 ^= $v2;\n-                $v2 = rotl!($v2, 32);\n-            })\n-        );\n-\n         let length = msg.len();\n         self.length += length;\n "}, {"sha": "c4f2704ab9f6efe1c750e567e009d7ae510ce788", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -284,7 +284,7 @@ impl num::One for f32 {\n     static pure fn one() -> f32 { 1.0 }\n }\n \n-pub impl NumCast for f32 {\n+impl NumCast for f32 {\n     /**\n      * Cast `n` to an `f32`\n      */"}, {"sha": "8f3771312e4d6ae530ce84e1a814fa02b0c80a9c", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -299,7 +299,7 @@ impl cmp::Ord for f64 {\n     pure fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n }\n \n-pub impl NumCast for f64 {\n+impl NumCast for f64 {\n     /**\n      * Cast `n` to an `f64`\n      */"}, {"sha": "1b79ec614d49b2e523fad3cbf9d09b6f3d4cb0d5", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -420,7 +420,7 @@ impl num::One for float {\n     static pure fn one() -> float { 1.0 }\n }\n \n-pub impl NumCast for float {\n+impl NumCast for float {\n     /**\n      * Cast `n` to a `float`\n      */"}, {"sha": "ef661d2160b641ccf3cb4d99470a6b6e9ba2d595", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -265,11 +265,6 @@ pub pure fn to_str_radix(num: T, radix: uint) -> ~str {\n     buf\n }\n \n-/// Convert to a string.\n-/// *Deprecated*, use to_str() instead.\n-#[inline(always)]\n-pub pure fn str(i: T) -> ~str { to_str(i) }\n-\n impl ToStr for T {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str {"}, {"sha": "a3def10bda8a55494f5fe81ea2923b3ed5457e25", "filename": "src/libcore/num/int-template/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -17,7 +17,7 @@ mod inst {\n     pub const bits: uint = ::u16::bits;\n }\n \n-pub impl NumCast for i16 {\n+impl NumCast for i16 {\n     /**\n      * Cast `n` to a `i16`\n      */"}, {"sha": "eccd1f6ce3c8a4797e4aabd990c3326899227481", "filename": "src/libcore/num/int-template/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -17,7 +17,7 @@ mod inst {\n     pub const bits: uint = ::u32::bits;\n }\n \n-pub impl NumCast for i32 {\n+impl NumCast for i32 {\n     /**\n      * Cast `n` to a `i32`\n      */"}, {"sha": "05d529cbcf46a56287218023ce0c2c814197f2f0", "filename": "src/libcore/num/int-template/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -17,7 +17,7 @@ mod inst {\n     pub const bits: uint = ::u64::bits;\n }\n \n-pub impl NumCast for i64 {\n+impl NumCast for i64 {\n     /**\n      * Cast `n` to a `i64`\n      */"}, {"sha": "d8819d4fed0f9c661fca4dac3dc3e7d7dfcdeebf", "filename": "src/libcore/num/int-template/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -17,7 +17,7 @@ mod inst {\n     pub const bits: uint = ::u8::bits;\n }\n \n-pub impl NumCast for i8 {\n+impl NumCast for i8 {\n     /**\n      * Cast `n` to a `i8`\n      */"}, {"sha": "7e376a47b8966dc3a9d2887a9a8c3a04a57e1126", "filename": "src/libcore/num/int-template/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -58,7 +58,7 @@ mod inst {\n     }\n }\n \n-pub impl NumCast for int {\n+impl NumCast for int {\n     /**\n      * Cast `n` to a `int`\n      */"}, {"sha": "8d5726b867920340bf7ba4f5693b02acea5b04fb", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -229,11 +229,6 @@ pub pure fn to_str_radix(num: T, radix: uint) -> ~str {\n     buf\n }\n \n-/// Convert to a string.\n-/// *Deprecated*, use to_str() instead.\n-#[inline(always)]\n-pub pure fn str(i: T) -> ~str { to_str(i) }\n-\n impl ToStr for T {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str {"}, {"sha": "01ec0cc77bf9188dad203e648fff9cb172c94964", "filename": "src/libcore/num/uint-template/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -19,7 +19,7 @@ mod inst {\n     pub const bits: uint = 16;\n }\n \n-pub impl NumCast for u16 {\n+impl NumCast for u16 {\n     /**\n      * Cast `n` to a `u16`\n      */"}, {"sha": "772ef51d30d4ad48ece2480c4d6ccd90c82c499f", "filename": "src/libcore/num/uint-template/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -19,7 +19,7 @@ mod inst {\n     pub const bits: uint = 32;\n }\n \n-pub impl NumCast for u32 {\n+impl NumCast for u32 {\n     /**\n      * Cast `n` to a `u32`\n      */"}, {"sha": "ec7301a01e486b9369c2cf07ef940bb829cff140", "filename": "src/libcore/num/uint-template/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -19,7 +19,7 @@ mod inst {\n     pub const bits: uint = 64;\n }\n \n-pub impl NumCast for u64 {\n+impl NumCast for u64 {\n     /**\n      * Cast `n` to a `u64`\n      */"}, {"sha": "53e4be70727bf0d452f33936494cb3b8449cf894", "filename": "src/libcore/num/uint-template/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -26,7 +26,7 @@ mod inst {\n     pub pure fn is_ascii(x: T) -> bool { return 0 as T == x & 128 as T; }\n }\n \n-pub impl NumCast for u8 {\n+impl NumCast for u8 {\n     /**\n      * Cast `n` to a `u8`\n      */"}, {"sha": "e2a75b25eaeb69b3660f2b5860ea5bb77b6adcf5", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -110,7 +110,7 @@ pub mod inst {\n         return true;\n     }\n \n-    pub impl iter::Times for uint {\n+    impl iter::Times for uint {\n         #[inline(always)]\n         /**\n         * A convenience form for basic iteration. Given a uint `x`,\n@@ -209,7 +209,7 @@ pub mod inst {\n     }\n }\n \n-pub impl NumCast for uint {\n+impl NumCast for uint {\n     /**\n      * Cast `n` to a `uint`\n      */"}, {"sha": "1c2df949a2e9c7061eba22c597db41c211041a84", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -56,7 +56,7 @@ pub enum Option<T> {\n     Some(T),\n }\n \n-pub impl<T:Ord> Ord for Option<T> {\n+impl<T:Ord> Ord for Option<T> {\n     pure fn lt(&self, other: &Option<T>) -> bool {\n         match (self, other) {\n             (&None, &None) => false,"}, {"sha": "2522e9c2cda5ab4846fa77ac5093ed80fa705765", "filename": "src/libcore/os.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -109,7 +109,7 @@ pub mod win32 {\n             let mut done = false;\n             while !done {\n                 let mut k: DWORD = 0;\n-                let buf = vec::cast_to_mut(vec::from_elem(n as uint, 0u16));\n+                let mut buf = vec::from_elem(n as uint, 0u16);\n                 do vec::as_mut_buf(buf) |b, _sz| {\n                     k = f(b, TMPBUF_SZ as DWORD);\n                     if k == (0 as DWORD) {\n@@ -566,17 +566,13 @@ pub fn path_exists(p: &Path) -> bool {\n  *\n  * If the given path is relative, return it prepended with the current working\n  * directory. If the given path is already an absolute path, return it\n- * as is.\n+ * as is.  This is a shortcut for calling os::getcwd().unsafe_join(p)\n  */\n // NB: this is here rather than in path because it is a form of environment\n // querying; what it does depends on the process working directory, not just\n // the input paths.\n pub fn make_absolute(p: &Path) -> Path {\n-    if p.is_absolute {\n-        copy *p\n-    } else {\n-        getcwd().push_many(p.components)\n-    }\n+    getcwd().unsafe_join(p)\n }\n \n "}, {"sha": "3b839e5a9e008008dc8fb476c2085bebb0061d5f", "filename": "src/libcore/owned.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fowned.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -13,22 +13,22 @@\n use cmp::{Eq, Ord};\n \n #[cfg(notest)]\n-impl<T:Eq> Eq for ~const T {\n+impl<T:Eq> Eq for ~T {\n     #[inline(always)]\n-    pure fn eq(&self, other: &~const T) -> bool { *(*self) == *(*other) }\n+    pure fn eq(&self, other: &~T) -> bool { *(*self) == *(*other) }\n     #[inline(always)]\n-    pure fn ne(&self, other: &~const T) -> bool { *(*self) != *(*other) }\n+    pure fn ne(&self, other: &~T) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(notest)]\n-impl<T:Ord> Ord for ~const T {\n+impl<T:Ord> Ord for ~T {\n     #[inline(always)]\n-    pure fn lt(&self, other: &~const T) -> bool { *(*self) < *(*other) }\n+    pure fn lt(&self, other: &~T) -> bool { *(*self) < *(*other) }\n     #[inline(always)]\n-    pure fn le(&self, other: &~const T) -> bool { *(*self) <= *(*other) }\n+    pure fn le(&self, other: &~T) -> bool { *(*self) <= *(*other) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &~const T) -> bool { *(*self) >= *(*other) }\n+    pure fn ge(&self, other: &~T) -> bool { *(*self) >= *(*other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &~const T) -> bool { *(*self) > *(*other) }\n+    pure fn gt(&self, other: &~T) -> bool { *(*self) > *(*other) }\n }\n "}, {"sha": "1753862649f57387072e06a6b25a9353e1597608", "filename": "src/libcore/path.rs", "status": "modified", "additions": 143, "deletions": 5, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -64,6 +64,9 @@ pub trait GenericPath {\n     pure fn push_many((&[~str])) -> Self;\n     pure fn pop() -> Self;\n \n+    pure fn unsafe_join((&Self)) -> Self;\n+    pure fn is_restricted() -> bool;\n+\n     pure fn normalize() -> Self;\n }\n \n@@ -485,6 +488,19 @@ impl GenericPath for PosixPath {\n         self.push_many(other.components)\n     }\n \n+    pure fn unsafe_join(other: &PosixPath) -> PosixPath {\n+        if other.is_absolute {\n+            PosixPath { is_absolute: true,\n+                        components: copy other.components }\n+        } else {\n+            self.push_rel(other)\n+        }\n+    }\n+\n+    pure fn is_restricted() -> bool {\n+        false\n+    }\n+\n     pure fn push_many(cs: &[~str]) -> PosixPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n@@ -685,6 +701,61 @@ impl GenericPath for WindowsPath {\n         self.push_many(other.components)\n     }\n \n+    pure fn unsafe_join(other: &WindowsPath) -> WindowsPath {\n+        /* rhs not absolute is simple push */\n+        if !other.is_absolute {\n+            return self.push_many(other.components);\n+        }\n+\n+        /* if rhs has a host set, then the whole thing wins */\n+        match other.host {\n+            Some(copy host) => {\n+                return WindowsPath {\n+                    host: Some(host),\n+                    device: copy other.device,\n+                    is_absolute: true,\n+                    components: copy other.components\n+                };\n+            }\n+            _ => {}\n+        }\n+\n+        /* if rhs has a device set, then a part wins */\n+        match other.device {\n+            Some(copy device) => {\n+                return WindowsPath {\n+                    host: None,\n+                    device: Some(device),\n+                    is_absolute: true,\n+                    components: copy other.components\n+                };\n+            }\n+            _ => {}\n+        }\n+\n+        /* fallback: host and device of lhs win, but the\n+           whole path of the right */\n+        WindowsPath {\n+            host: copy self.host,\n+            device: copy self.device,\n+            is_absolute: self.is_absolute || other.is_absolute,\n+            components: copy other.components\n+        }\n+    }\n+\n+    pure fn is_restricted() -> bool {\n+        match self.filestem() {\n+            Some(stem) => {\n+                match stem.to_lower() {\n+                    ~\"con\" | ~\"aux\" | ~\"com1\" | ~\"com2\" | ~\"com3\" | ~\"com4\" |\n+                    ~\"lpt1\" | ~\"lpt2\" | ~\"lpt3\" | ~\"prn\" | ~\"nul\" => true,\n+                    _ => false\n+                }\n+            },\n+            None => false\n+        }\n+    }\n+\n     pure fn push_many(cs: &[~str]) -> WindowsPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n@@ -725,7 +796,10 @@ impl GenericPath for WindowsPath {\n     pure fn normalize() -> WindowsPath {\n         return WindowsPath {\n             host: copy self.host,\n-            device: copy self.device,\n+            device: match self.device {\n+                None => None,\n+                Some(ref device) => Some(device.to_upper())\n+            },\n             is_absolute: self.is_absolute,\n             components: normalize(self.components)\n         }\n@@ -764,13 +838,13 @@ pub mod windows {\n \n     pub pure fn extract_unc_prefix(s: &str) -> Option<(~str,~str)> {\n         if (s.len() > 1 &&\n-            s[0] == '\\\\' as u8 &&\n-            s[1] == '\\\\' as u8) {\n+            (s[0] == '\\\\' as u8 || s[0] == '/' as u8) &&\n+            s[0] == s[1]) {\n             let mut i = 2;\n             while i < s.len() {\n-                if s[i] == '\\\\' as u8 {\n+                if is_sep(s[i]) {\n                     let pre = s.slice(2, i);\n-                    let rest = s.slice(i, s.len());\n+                    let mut rest = s.slice(i, s.len());\n                     return Some((pre, rest));\n                 }\n                 i += 1;\n@@ -916,13 +990,21 @@ mod tests {\n     #[test]\n     fn test_extract_unc_prefixes() {\n         assert windows::extract_unc_prefix(\"\\\\\\\\\").is_none();\n+        assert windows::extract_unc_prefix(\"//\").is_none();\n         assert windows::extract_unc_prefix(\"\\\\\\\\hi\").is_none();\n+        assert windows::extract_unc_prefix(\"//hi\").is_none();\n         assert windows::extract_unc_prefix(\"\\\\\\\\hi\\\\\") ==\n             Some((~\"hi\", ~\"\\\\\"));\n+        assert windows::extract_unc_prefix(\"//hi\\\\\") ==\n+            Some((~\"hi\", ~\"\\\\\"));\n         assert windows::extract_unc_prefix(\"\\\\\\\\hi\\\\there\") ==\n             Some((~\"hi\", ~\"\\\\there\"));\n+        assert windows::extract_unc_prefix(\"//hi/there\") ==\n+            Some((~\"hi\", ~\"/there\"));\n         assert windows::extract_unc_prefix(\"\\\\\\\\hi\\\\there\\\\friends.txt\") ==\n             Some((~\"hi\", ~\"\\\\there\\\\friends.txt\"));\n+        assert windows::extract_unc_prefix(\"//hi\\\\there\\\\friends.txt\") ==\n+            Some((~\"hi\", ~\"\\\\there\\\\friends.txt\"));\n     }\n \n     #[test]\n@@ -981,5 +1063,61 @@ mod tests {\n             .push_many([~\"lib\", ~\"thingy.dll\"])\n             .with_filename(\"librustc.dll\")),\n           \"c:\\\\program files (x86)\\\\rust\\\\lib\\\\librustc.dll\");\n+\n+        t(&(WindowsPath(\"\\\\\\\\computer\\\\share\")\n+            .unsafe_join(&WindowsPath(\"\\\\a\"))),\n+          \"\\\\\\\\computer\\\\a\");\n+\n+        t(&(WindowsPath(\"//computer/share\")\n+            .unsafe_join(&WindowsPath(\"\\\\a\"))),\n+          \"\\\\\\\\computer\\\\a\");\n+\n+        t(&(WindowsPath(\"//computer/share\")\n+            .unsafe_join(&WindowsPath(\"\\\\\\\\computer\\\\share\"))),\n+          \"\\\\\\\\computer\\\\share\");\n+\n+        t(&(WindowsPath(\"C:/whatever\")\n+            .unsafe_join(&WindowsPath(\"//computer/share/a/b\"))),\n+          \"\\\\\\\\computer\\\\share\\\\a\\\\b\");\n+\n+        t(&(WindowsPath(\"C:\")\n+            .unsafe_join(&WindowsPath(\"D:/foo\"))),\n+          \"D:\\\\foo\");\n+\n+        t(&(WindowsPath(\"C:\")\n+            .unsafe_join(&WindowsPath(\"B\"))),\n+          \"C:B\");\n+\n+        t(&(WindowsPath(\"C:\")\n+            .unsafe_join(&WindowsPath(\"/foo\"))),\n+          \"C:\\\\foo\");\n+\n+        t(&(WindowsPath(\"C:\\\\\")\n+            .unsafe_join(&WindowsPath(\"\\\\bar\"))),\n+          \"C:\\\\bar\");\n+\n+        t(&(WindowsPath(\"\")\n+            .unsafe_join(&WindowsPath(\"\"))),\n+          \"\");\n+\n+        t(&(WindowsPath(\"\")\n+            .unsafe_join(&WindowsPath(\"a\"))),\n+          \"a\");\n+\n+        t(&(WindowsPath(\"\")\n+            .unsafe_join(&WindowsPath(\"C:\\\\a\"))),\n+          \"C:\\\\a\");\n+\n+        t(&(WindowsPath(\"c:\\\\foo\")\n+            .normalize()),\n+          \"C:\\\\foo\");\n+    }\n+\n+    #[test]\n+    fn test_windows_path_restrictions() {\n+        assert WindowsPath(\"hi\").is_restricted() == false;\n+        assert WindowsPath(\"C:\\\\NUL\").is_restricted() == true;\n+        assert WindowsPath(\"C:\\\\COM1.TXT\").is_restricted() == true;\n+        assert WindowsPath(\"c:\\\\prn.exe\").is_restricted() == true;\n     }\n }"}, {"sha": "15a6e700ffd841a2479c1d124cfb47e1496e01f8", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -86,6 +86,7 @@ bounded and unbounded protocols allows for less code duplication.\n \n use cmp::Eq;\n use cast::{forget, reinterpret_cast, transmute};\n+use cell::Cell;\n use either::{Either, Left, Right};\n use kinds::Owned;\n use libc;\n@@ -917,11 +918,9 @@ pub fn spawn_service<T:Owned,Tb:Owned>(\n \n     // This is some nasty gymnastics required to safely move the pipe\n     // into a new task.\n-    let server = ~mut Some(server);\n-    do task::spawn || {\n-        let mut server_ = None;\n-        server_ <-> *server;\n-        service(option::unwrap(server_))\n+    let server = Cell(server);\n+    do task::spawn {\n+        service(server.take());\n     }\n \n     client\n@@ -941,11 +940,9 @@ pub fn spawn_service_recv<T:Owned,Tb:Owned>(\n \n     // This is some nasty gymnastics required to safely move the pipe\n     // into a new task.\n-    let server = ~mut Some(server);\n-    do task::spawn || {\n-        let mut server_ = None;\n-        server_ <-> *server;\n-        service(option::unwrap(server_))\n+    let server = Cell(server);\n+    do task::spawn {\n+        service(server.take())\n     }\n \n     client"}, {"sha": "2580efe6d09687dceff3e587cd4553b2dab2bc4e", "filename": "src/libcore/private.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -107,10 +107,14 @@ fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n  * Shared state & exclusive ARC\n  ****************************************************************************/\n \n+struct UnwrapProtoInner {\n+    contents: Option<(comm::ChanOne<()>,  comm::PortOne<bool>)>,\n+}\n+\n // An unwrapper uses this protocol to communicate with the \"other\" task that\n // drops the last refcount on an arc. Unfortunately this can't be a proper\n // pipe protocol because the unwrapper has to access both stages at once.\n-type UnwrapProto = ~mut Option<(comm::ChanOne<()>,  comm::PortOne<bool>)>;\n+type UnwrapProto = ~UnwrapProtoInner;\n \n struct ArcData<T> {\n     mut count:     libc::intptr_t,\n@@ -139,9 +143,10 @@ struct ArcDestruct<T> {\n                     // reference. In effect, being here means we're the only\n                     // *awake* task with the data.\n                     if data.unwrapper != 0 {\n-                        let p: UnwrapProto =\n+                        let mut p: UnwrapProto =\n                             cast::reinterpret_cast(&data.unwrapper);\n-                        let (message, response) = option::swap_unwrap(p);\n+                        let (message, response) =\n+                            option::swap_unwrap(&mut p.contents);\n                         // Send 'ready' and wait for a response.\n                         comm::send_one(message, ());\n                         // Unkillable wait. Message guaranteed to come.\n@@ -196,7 +201,9 @@ pub unsafe fn unwrap_shared_mutable_state<T:Owned>(rc: SharedMutableState<T>)\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&rc.data);\n         let (p1,c1) = comm::oneshot(); // ()\n         let (p2,c2) = comm::oneshot(); // bool\n-        let server: UnwrapProto = ~mut Some((c1,p2));\n+        let mut server: UnwrapProto = ~UnwrapProtoInner {\n+            contents: Some((c1,p2))\n+        };\n         let serverp: int = cast::transmute(server);\n         // Try to put our server end in the unwrapper slot.\n         if compare_and_swap(&mut ptr.unwrapper, 0, serverp) {\n@@ -409,8 +416,9 @@ pub fn unwrap_exclusive<T:Owned>(arc: Exclusive<T>) -> T {\n pub mod tests {\n     use core::option::{None, Some};\n \n-    use option;\n+    use cell::Cell;\n     use comm;\n+    use option;\n     use private::{exclusive, unwrap_exclusive};\n     use result;\n     use task;\n@@ -423,7 +431,7 @@ pub mod tests {\n         let num_tasks = 10;\n         let count = 10;\n \n-        let total = exclusive(~mut 0);\n+        let total = exclusive(~0);\n \n         for uint::range(0, num_tasks) |_i| {\n             let total = total.clone();\n@@ -472,21 +480,20 @@ pub mod tests {\n     #[test]\n     pub fn exclusive_unwrap_contended() {\n         let x = exclusive(~~\"hello\");\n-        let x2 = ~mut Some(x.clone());\n-        do task::spawn || {\n-            let x2 = option::swap_unwrap(x2);\n+        let x2 = Cell(x.clone());\n+        do task::spawn {\n+            let x2 = x2.take();\n             do x2.with |_hello| { }\n             task::yield();\n         }\n         assert unwrap_exclusive(x) == ~~\"hello\";\n \n         // Now try the same thing, but with the child task blocking.\n         let x = exclusive(~~\"hello\");\n-        let x2 = ~mut Some(x.clone());\n+        let x2 = Cell(x.clone());\n         let mut res = None;\n-        do task::task().future_result(|+r| res = Some(r)).spawn\n-              || {\n-            let x2 = option::swap_unwrap(x2);\n+        do task::task().future_result(|+r| res = Some(r)).spawn {\n+            let x2 = x2.take();\n             assert unwrap_exclusive(x2) == ~~\"hello\";\n         }\n         // Have to get rid of our reference before blocking.\n@@ -498,11 +505,10 @@ pub mod tests {\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     pub fn exclusive_unwrap_conflict() {\n         let x = exclusive(~~\"hello\");\n-        let x2 = ~mut Some(x.clone());\n+        let x2 = Cell(x.clone());\n         let mut res = None;\n-        do task::task().future_result(|+r| res = Some(r)).spawn\n-           || {\n-            let x2 = option::swap_unwrap(x2);\n+        do task::task().future_result(|+r| res = Some(r)).spawn {\n+            let x2 = x2.take();\n             assert unwrap_exclusive(x2) == ~~\"hello\";\n         }\n         assert unwrap_exclusive(x) == ~~\"hello\";"}, {"sha": "8445638850cd06bdc64a45fed087798757837b5a", "filename": "src/libcore/private/weak_task.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fprivate%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fprivate%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fweak_task.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -18,16 +18,17 @@ it is running, sending a notification to the task that the runtime\n is trying to shut down.\n */\n \n+use cell::Cell;\n+use comm::{GenericSmartChan, stream};\n+use comm::{Port, Chan, SharedChan, GenericChan, GenericPort};\n+use hashmap::linear::LinearMap;\n+use ops::Drop;\n use option::{Some, None, swap_unwrap};\n use private::at_exit::at_exit;\n-use private::global::global_data_clone_create;\n use private::finally::Finally;\n-use comm::{Port, Chan, SharedChan, GenericChan,\n-           GenericPort, GenericSmartChan, stream};\n-use task::{Task, task, spawn};\n+use private::global::global_data_clone_create;\n use task::rt::{task_id, get_task_id};\n-use hashmap::linear::LinearMap;\n-use ops::Drop;\n+use task::{Task, task, spawn};\n \n type ShutdownMsg = ();\n \n@@ -37,14 +38,13 @@ pub unsafe fn weaken_task(f: &fn(Port<ShutdownMsg>)) {\n     let service = global_data_clone_create(global_data_key,\n                                            create_global_service);\n     let (shutdown_port, shutdown_chan) = stream::<ShutdownMsg>();\n-    let shutdown_port = ~mut Some(shutdown_port);\n+    let shutdown_port = Cell(shutdown_port);\n     let task = get_task_id();\n     // Expect the weak task service to be alive\n     assert service.try_send(RegisterWeakTask(task, shutdown_chan));\n     unsafe { rust_dec_kernel_live_count(); }\n     do fn&() {\n-        let shutdown_port = swap_unwrap(&mut *shutdown_port);\n-        f(shutdown_port)\n+        f(shutdown_port.take())\n     }.finally || {\n         unsafe { rust_inc_kernel_live_count(); }\n         // Service my have already exited\n@@ -67,16 +67,15 @@ fn create_global_service() -> ~WeakTaskService {\n \n     debug!(\"creating global weak task service\");\n     let (port, chan) = stream::<ServiceMsg>();\n-    let port = ~mut Some(port);\n+    let port = Cell(port);\n     let chan = SharedChan(chan);\n     let chan_clone = chan.clone();\n \n     do task().unlinked().spawn {\n         debug!(\"running global weak task service\");\n-        let port = swap_unwrap(&mut *port);\n-        let port = ~mut Some(port);\n+        let port = Cell(port.take());\n         do fn&() {\n-            let port = swap_unwrap(&mut *port);\n+            let port = port.take();\n             // The weak task service is itself a weak task\n             debug!(\"weakening the weak service task\");\n             unsafe { rust_dec_kernel_live_count(); }"}, {"sha": "4c3abb09756e99b05d625e8afb1ba0a6f85335b4", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -602,7 +602,6 @@ fn test_repr() {\n     exact_test(&(@10), \"@10\");\n     exact_test(&(@mut 10), \"@10\");\n     exact_test(&(~10), \"~10\");\n-    exact_test(&(~mut 10), \"~mut 10\");\n     exact_test(&(&10), \"&10\");\n     let mut x = 10;\n     exact_test(&(&mut x), \"&mut 10\");"}, {"sha": "c3e4f925c4014180b827427be2b3a20c5b8404e3", "filename": "src/libcore/rt.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -11,7 +11,7 @@\n //! Runtime calls emitted by the compiler.\n \n use cast::transmute;\n-use libc::{c_char, c_uchar, c_void, size_t, uintptr_t};\n+use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int};\n use managed::raw::BoxRepr;\n use str;\n use sys;\n@@ -121,6 +121,21 @@ pub unsafe fn strdup_uniq(ptr: *c_uchar, len: uint) -> ~str {\n     str::raw::from_buf_len(ptr, len)\n }\n \n+#[lang=\"start\"]\n+pub fn start(main: *u8, argc: int, argv: *c_char,\n+             crate_map: *u8) -> int {\n+\n+    extern {\n+        fn rust_start(main: *c_void, argc: c_int, argv: *c_char,\n+                      crate_map: *c_void) -> c_int;\n+    }\n+\n+    unsafe {\n+        return rust_start(main as *c_void, argc as c_int, argv,\n+                          crate_map as *c_void) as int;\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "66be548181956ded778f015f082d702cf19026ef", "filename": "src/libcore/str.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -590,6 +590,40 @@ pub pure fn split_str_nonempty(s: &a/str, sep: &b/str) -> ~[~str] {\n     result\n }\n \n+/// Levenshtein Distance between two strings\n+pub fn levdistance(s: &str, t: &str) -> uint {\n+\n+    let slen = str::len(s);\n+    let tlen = str::len(t);\n+\n+    if slen == 0 { return tlen; }\n+    if tlen == 0 { return slen; }\n+\n+    let mut dcol = vec::from_fn(tlen + 1, |x| x);\n+\n+    for str::each_chari(s) |i, sc| {\n+\n+        let mut current = i;\n+        dcol[0] = current + 1;\n+\n+        for str::each_chari(t) |j, tc| {\n+\n+            let mut next = dcol[j + 1];\n+\n+            if sc == tc {\n+                dcol[j + 1] = current;\n+            } else {\n+                dcol[j + 1] = ::cmp::min(current, next);\n+                dcol[j + 1] = ::cmp::min(dcol[j + 1], dcol[j]) + 1;\n+            }\n+\n+            current = next;\n+        }\n+    }\n+\n+    return dcol[tlen];\n+}\n+\n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n')\n  */\n@@ -2328,7 +2362,7 @@ pub trait OwnedStr {\n     fn push_char(&mut self, c: char);\n }\n \n-pub impl OwnedStr for ~str {\n+impl OwnedStr for ~str {\n     fn push_str(&mut self, v: &str) {\n         push_str(self, v);\n     }"}, {"sha": "2a640e4bf8cf731de5d4909e6caf99a41ac89044", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -34,6 +34,7 @@\n  */\n \n use cast;\n+use cell::Cell;\n use cmp;\n use cmp::Eq;\n use iter;\n@@ -397,9 +398,9 @@ impl TaskBuilder {\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n     fn spawn_with<A:Owned>(arg: A, f: fn~(v: A)) {\n-        let arg = ~mut Some(arg);\n-        do self.spawn || {\n-            f(option::swap_unwrap(arg))\n+        let arg = Cell(arg);\n+        do self.spawn {\n+            f(arg.take());\n         }\n     }\n "}, {"sha": "5110f70ff11be9762f8616625e520b71cdc6b064", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -73,6 +73,7 @@\n #[doc(hidden)]; // FIXME #3538\n \n use cast;\n+use cell::Cell;\n use container::Map;\n use option;\n use comm::{Chan, GenericChan, GenericPort, Port, stream};\n@@ -530,11 +531,11 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n         gen_child_taskgroup(opts.linked, opts.supervised);\n \n     unsafe {\n-        let child_data = ~mut Some((child_tg, ancestors, f));\n+        let child_data = Cell((child_tg, ancestors, f));\n         // Being killed with the unsafe task/closure pointers would leak them.\n         do unkillable {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n-            let (child_tg, ancestors, f) = option::swap_unwrap(child_data);\n+            let (child_tg, ancestors, f) = child_data.take();\n             // Create child task.\n             let new_task = match opts.sched.mode {\n                 DefaultScheduler => rt::new_task(),\n@@ -571,10 +572,10 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n                           ancestors: AncestorList, is_main: bool,\n                           notify_chan: Option<Chan<TaskResult>>,\n                           f: fn~()) -> fn~() {\n-        let child_data = ~mut Some((child_arc, ancestors));\n+        let child_data = Cell((child_arc, ancestors));\n         return fn~() {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n-            let mut (child_arc, ancestors) = option::swap_unwrap(child_data);\n+            let mut (child_arc, ancestors) = child_data.take();\n             // Child task runs this code.\n \n             // Even if the below code fails to kick the child off, we must"}, {"sha": "1f0f3b0779cbe3450f2b8ab1e3f6fe2ffcf5a960", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -170,7 +170,7 @@ impl IterBytes for char {\n pub mod x32 {\n     use to_bytes::{Cb, IterBytes};\n \n-    pub impl IterBytes for uint {\n+    impl IterBytes for uint {\n         #[inline(always)]\n         pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n             (*self as u32).iter_bytes(lsb0, f)\n@@ -182,7 +182,7 @@ pub mod x32 {\n pub mod x64 {\n     use to_bytes::{Cb, IterBytes};\n \n-    pub impl IterBytes for uint {\n+    impl IterBytes for uint {\n         #[inline(always)]\n         pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n             (*self as u64).iter_bytes(lsb0, f)"}, {"sha": "687ad2f79387d67356ac9eeb6924da583dc3d098", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 8, "deletions": 37, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -209,16 +209,6 @@ pub pure fn build_sized_opt<A>(size: Option<uint>,\n     build_sized(size.get_or_default(4), builder)\n }\n \n-/// Produces a mut vector from an immutable vector.\n-pub pure fn cast_to_mut<T>(v: ~[T]) -> ~[mut T] {\n-    unsafe { ::cast::transmute(v) }\n-}\n-\n-/// Produces an immutable vector from a mut vector.\n-pub pure fn cast_from_mut<T>(v: ~[mut T]) -> ~[T] {\n-    unsafe { ::cast::transmute(v) }\n-}\n-\n // Accessors\n \n /// Returns the first element of a vector\n@@ -274,9 +264,10 @@ pub pure fn slice<T>(v: &r/[T], start: uint, end: uint) -> &r/[T] {\n \n /// Return a slice that points into another slice.\n #[inline(always)]\n-pub pure fn mut_slice<T>(v: &r/[mut T], start: uint,\n-                         end: uint) -> &r/[mut T] {\n-\n+pub pure fn mut_slice<T>(v: &r/mut [T],\n+                         start: uint,\n+                         end: uint)\n+                      -> &r/mut [T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     do as_mut_buf(v) |p, _len| {\n@@ -290,8 +281,10 @@ pub pure fn mut_slice<T>(v: &r/[mut T], start: uint,\n \n /// Return a slice that points into another slice.\n #[inline(always)]\n-pub pure fn const_slice<T>(v: &r/[const T], start: uint,\n-                      end: uint) -> &r/[const T] {\n+pub pure fn const_slice<T>(v: &r/[const T],\n+                           start: uint,\n+                           end: uint)\n+                        -> &r/[const T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     do as_const_buf(v) |p, _len| {\n@@ -3337,28 +3330,6 @@ mod tests {\n         let _x = windowed (0u, ~[1u,2u,3u,4u,5u,6u]);\n     }\n \n-    #[test]\n-    fn cast_to_mut_no_copy() {\n-        unsafe {\n-            let x = ~[1, 2, 3];\n-            let addr = raw::to_ptr(x);\n-            let x_mut = cast_to_mut(x);\n-            let addr_mut = raw::to_ptr(x_mut);\n-            assert addr == addr_mut;\n-        }\n-    }\n-\n-    #[test]\n-    fn cast_from_mut_no_copy() {\n-        unsafe {\n-            let x = ~[mut 1, 2, 3];\n-            let addr = raw::to_ptr(x);\n-            let x_imm = cast_from_mut(x);\n-            let addr_imm = raw::to_ptr(x_imm);\n-            assert addr == addr_imm;\n-        }\n-    }\n-\n     #[test]\n     fn test_unshift() {\n         let mut x = ~[1, 2, 3];"}, {"sha": "97ac8cf2d507d6b836333273d4987591e06e5c1f", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -290,7 +290,7 @@ pub fn check_variants_T<T: Copy>(\n \n     if L < 100 {\n         do under(uint::min(L, 20)) |i| {\n-            log(error, ~\"Replacing... #\" + uint::str(i));\n+            log(error, ~\"Replacing... #\" + uint::to_str(i));\n             let fname = str::from_slice(filename.to_str());\n             do under(uint::min(L, 30)) |j| {\n                 log(error, ~\"With... \" + stringifier(@things[j], intr));\n@@ -415,7 +415,7 @@ pub fn check_running(exe_filename: &Path) -> happiness {\n             }\n             rc => {\n               failed(~\"Rust program ran but exited with status \" +\n-                     int::str(rc))\n+                     int::to_str(rc))\n             }\n         }\n     }"}, {"sha": "8db27bd675d6eb13c2aa90b3befb0b325bb58531", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -838,9 +838,6 @@ pub fn link_binary(sess: Session,\n         }\n     }\n \n-    // Always want the runtime linked in\n-    cc_args.push(~\"-lrustrt\");\n-\n     // On linux librt and libdl are an indirect dependencies via rustrt,\n     // and binutils 2.22+ won't add them automatically\n     if sess.targ_cfg.os == session::os_linux {\n@@ -880,6 +877,9 @@ pub fn link_binary(sess: Session,\n     cc_args.push(~\"-lmorestack\");\n     }\n \n+    // Always want the runtime linked in\n+    cc_args.push(~\"-lrustrt\");\n+\n     // FIXME (#2397): At some point we want to rpath our guesses as to where\n     // extern libraries might live, based on the addl_lib_search_paths\n     cc_args.push_all(rpath::get_rpath_flags(sess, &output));"}, {"sha": "d2bb7c75a27f6225d2b688f972b5a12ddb75ced8", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -1379,12 +1379,7 @@ pub fn type_to_str_inner(names: @TypeNames, +outer0: &[TypeRef], ty: TypeRef)\n                         type_to_str_inner(names, outer, out_ty)).to_managed();\n           }\n           Struct => {\n-            let n_elts = llvm::LLVMCountStructElementTypes(ty) as uint;\n-            let mut elts = vec::from_elem(n_elts, 0 as TypeRef);\n-            if !elts.is_empty() {\n-                llvm::LLVMGetStructElementTypes(\n-                    ty, ptr::to_mut_unsafe_ptr(&mut elts[0]));\n-            }\n+            let elts = struct_tys(ty);\n             // See [Note at-str]\n             return fmt!(\"{%s}\", tys_str(names, outer, elts)).to_managed();\n           }\n@@ -1445,17 +1440,16 @@ pub fn fn_ty_param_tys(fn_ty: TypeRef) -> ~[TypeRef] {\n     }\n }\n \n-pub fn struct_element_types(struct_ty: TypeRef) -> ~[TypeRef] {\n+pub fn struct_tys(struct_ty: TypeRef) -> ~[TypeRef] {\n     unsafe {\n-        let count = llvm::LLVMCountStructElementTypes(struct_ty);\n-        let mut buf: ~[TypeRef] =\n-            vec::from_elem(count as uint,\n-                           cast::transmute::<uint,TypeRef>(0));\n-        if buf.len() > 0 {\n-            llvm::LLVMGetStructElementTypes(\n-                struct_ty, ptr::to_mut_unsafe_ptr(&mut buf[0]));\n+        let n_elts = llvm::LLVMCountStructElementTypes(struct_ty) as uint;\n+        if n_elts == 0 {\n+            return ~[];\n         }\n-        return buf;\n+        let mut elts = vec::from_elem(n_elts, ptr::null());\n+        llvm::LLVMGetStructElementTypes(\n+            struct_ty, ptr::to_mut_unsafe_ptr(&mut elts[0]));\n+        return elts;\n     }\n }\n "}, {"sha": "dccbf7c778eb954c0b1c92a4526249d3f59d1ab0", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -307,7 +307,7 @@ fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n         w.write_char('p');\n         w.write_str((cx.ds)(did));\n         w.write_char('|');\n-        w.write_str(uint::str(id));\n+        w.write_str(uint::to_str(id));\n       }\n       ty::ty_self => {\n         w.write_char('s');"}, {"sha": "bdba5c4e79d127b87be3bc02ef9f18d190688121", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -860,7 +860,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n             }\n         }\n     }\n-    do option::iter(&(*tcx.node_types).find(id as uint)) |ty| {\n+    do option::iter(&tcx.node_types.find(&(id as uint))) |&ty| {\n         do ebml_w.tag(c::tag_table_node_type) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -1135,7 +1135,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                 let ty = val_dsr.read_ty(xcx);\n                 debug!(\"inserting ty for node %?: %s\",\n                        id, ty_to_str(dcx.tcx, ty));\n-                (*dcx.tcx.node_types).insert(id as uint, ty);\n+                dcx.tcx.node_types.insert(id as uint, ty);\n             } else if tag == (c::tag_table_node_type_subst as uint) {\n                 let tys = val_dsr.read_tys(xcx);\n                 dcx.tcx.node_type_substs.insert(id, tys);"}, {"sha": "eb2a93d86f9a465e9473941af66576657f22307b", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -451,7 +451,7 @@ impl LoanKind {\n \n /// Creates and returns a new root_map\n \n-pub impl to_bytes::IterBytes for root_map_key {\n+impl to_bytes::IterBytes for root_map_key {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n     }"}, {"sha": "f736c403cfccdb687777cdcffb50a46e932fc433", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -101,7 +101,11 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n           _ => { /* We assume only enum types can be uninhabited */ }\n        }\n        let arms = vec::concat(arms.filter_mapped(unguarded_pat));\n-       check_exhaustive(cx, ex.span, arms);\n+       if arms.is_empty() {\n+           cx.tcx.sess.span_err(ex.span, ~\"non-exhaustive patterns\");\n+       } else {\n+           check_exhaustive(cx, ex.span, arms);\n+       }\n      }\n      _ => ()\n     }"}, {"sha": "7d2ab1700ddb1ff57d48bf77c692c59a4b7b2608", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -117,7 +117,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n \n pub fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n     match tcx.freevars.find(&fid) {\n-      None => fail!(~\"get_freevars: \" + int::str(fid) + ~\" has no freevars\"),\n+      None => fail!(~\"get_freevars: \"+int::to_str(fid)+~\" has no freevars\"),\n       Some(d) => return d\n     }\n }"}, {"sha": "c2c623e36d67441051fc4f8cd8c4298f010e6053", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -75,16 +75,18 @@ pub enum LangItem {\n     ReturnToMutFnLangItem,      // 31\n     CheckNotBorrowedFnLangItem, // 32\n     StrDupUniqFnLangItem,       // 33\n+\n+    StartFnLangItem,            // 34\n }\n \n pub struct LanguageItems {\n-    items: [ Option<def_id> * 34 ]\n+    items: [ Option<def_id> * 35 ]\n }\n \n pub impl LanguageItems {\n     static pub fn new(&self) -> LanguageItems {\n         LanguageItems {\n-            items: [ None, ..34 ]\n+            items: [ None, ..35 ]\n         }\n     }\n \n@@ -136,6 +138,8 @@ pub impl LanguageItems {\n             32 => \"check_not_borrowed\",\n             33 => \"strdup_uniq\",\n \n+            34 => \"start\",\n+\n             _ => \"???\"\n         }\n     }\n@@ -248,6 +252,9 @@ pub impl LanguageItems {\n     pub fn strdup_uniq_fn(&const self) -> def_id {\n         self.items[StrDupUniqFnLangItem as uint].get()\n     }\n+    pub fn start_fn(&const self) -> def_id {\n+        self.items[StartFnLangItem as uint].get()\n+    }\n }\n \n fn LanguageItemCollector(crate: @crate,\n@@ -296,6 +303,7 @@ fn LanguageItemCollector(crate: @crate,\n     item_refs.insert(@~\"check_not_borrowed\",\n                      CheckNotBorrowedFnLangItem as uint);\n     item_refs.insert(@~\"strdup_uniq\", StrDupUniqFnLangItem as uint);\n+    item_refs.insert(@~\"start\", StartFnLangItem as uint);\n \n     LanguageItemCollector {\n         crate: crate,"}, {"sha": "3571f343d0d2ded49826d378747639be236785eb", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -34,8 +34,7 @@ use core::uint;\n use core::vec;\n use std::oldmap::{Map, HashMap};\n use std::oldmap;\n-use std::oldsmallintmap::{Map, SmallIntMap};\n-use std::oldsmallintmap;\n+use std::smallintmap::SmallIntMap;\n use syntax::ast_util::{path_to_ident};\n use syntax::attr;\n use syntax::codemap::span;\n@@ -81,6 +80,7 @@ pub enum lint {\n     type_limits,\n     default_methods,\n     deprecated_self,\n+    deprecated_mutable_fields,\n \n     managed_heap_memory,\n     owned_heap_memory,\n@@ -255,6 +255,13 @@ pub fn get_lint_dict() -> LintDict {\n             default: warn\n          }),\n \n+        (@~\"deprecated_mutable_fields\",\n+         @LintSpec {\n+            lint: deprecated_mutable_fields,\n+            desc: \"deprecated mutable fields in structures\",\n+            default: deny\n+        }),\n+\n         /* FIXME(#3266)--make liveness warnings lintable\n         (@~\"unused_variable\",\n          @LintSpec {\n@@ -275,7 +282,7 @@ pub fn get_lint_dict() -> LintDict {\n }\n \n // This is a highly not-optimal set of data structure decisions.\n-type LintModes = SmallIntMap<level>;\n+type LintModes = @mut SmallIntMap<level>;\n type LintModeMap = HashMap<ast::node_id, LintModes>;\n \n // settings_map maps node ids of items with non-default lint settings\n@@ -288,14 +295,14 @@ pub struct LintSettings {\n \n pub fn mk_lint_settings() -> LintSettings {\n     LintSettings {\n-        default_settings: oldsmallintmap::mk(),\n+        default_settings: @mut SmallIntMap::new(),\n         settings_map: HashMap()\n     }\n }\n \n pub fn get_lint_level(modes: LintModes, lint: lint) -> level {\n-    match modes.find(lint as uint) {\n-      Some(c) => c,\n+    match modes.find(&(lint as uint)) {\n+      Some(&c) => c,\n       None => allow\n     }\n }\n@@ -314,8 +321,7 @@ pub fn get_lint_settings_level(settings: LintSettings,\n // This is kind of unfortunate. It should be somewhere else, or we should use\n // a persistent data structure...\n fn clone_lint_modes(modes: LintModes) -> LintModes {\n-    oldsmallintmap::SmallIntMap_(@oldsmallintmap::SmallIntMap_\n-    {v: copy modes.v})\n+    @mut (copy *modes)\n }\n \n struct Context {\n@@ -332,7 +338,7 @@ impl Context {\n \n     fn set_level(&self, lint: lint, level: level) {\n         if level == allow {\n-            self.curr.remove(lint as uint);\n+            self.curr.remove(&(lint as uint));\n         } else {\n             self.curr.insert(lint as uint, level);\n         }\n@@ -440,7 +446,7 @@ fn build_settings_item(i: @ast::item, &&cx: Context, v: visit::vt<Context>) {\n pub fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n     let cx = Context {\n         dict: get_lint_dict(),\n-        curr: oldsmallintmap::mk(),\n+        curr: @mut SmallIntMap::new(),\n         is_default: true,\n         sess: sess\n     };\n@@ -458,7 +464,7 @@ pub fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n \n     do cx.with_lint_attrs(/*bad*/copy crate.node.attrs) |cx| {\n         // Copy out the default settings\n-        for cx.curr.each |k, v| {\n+        for cx.curr.each |&(k, &v)| {\n             sess.lint_settings.default_settings.insert(k, v);\n         }\n \n@@ -488,6 +494,7 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n     check_item_type_limits(cx, i);\n     check_item_default_methods(cx, i);\n     check_item_deprecated_self(cx, i);\n+    check_item_deprecated_mutable_fields(cx, i);\n }\n \n // Take a visitor, and modify it so that it will not proceed past subitems.\n@@ -705,6 +712,26 @@ fn check_item_deprecated_self(cx: ty::ctxt, item: @ast::item) {\n     }\n }\n \n+fn check_item_deprecated_mutable_fields(cx: ty::ctxt, item: @ast::item) {\n+    match item.node {\n+        ast::item_struct(struct_def, _) => {\n+            for struct_def.fields.each |field| {\n+                match field.node.kind {\n+                    ast::named_field(_, ast::struct_mutable, _) => {\n+                        cx.sess.span_lint(deprecated_mutable_fields,\n+                                          item.id,\n+                                          item.id,\n+                                          field.span,\n+                                          ~\"mutable fields are deprecated\");\n+                    }\n+                    ast::named_field(*) | ast::unnamed_field => {}\n+                }\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n fn check_item_structural_records(cx: ty::ctxt, it: @ast::item) {\n     let visit = item_stopping_visitor(\n         visit::mk_simple_visitor(@visit::SimpleVisitor {"}, {"sha": "86398dac6d8f9d4c94987f6e13a7e17437c2ab71", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -667,8 +667,8 @@ struct Liveness {\n     tcx: ty::ctxt,\n     ir: @mut IrMaps,\n     s: Specials,\n-    successors: ~[mut LiveNode],\n-    users: ~[mut Users],\n+    successors: @mut ~[LiveNode],\n+    users: @mut ~[Users],\n     // The list of node IDs for the nested loop scopes\n     // we're in.\n     loop_scope: DVec<node_id>,\n@@ -684,14 +684,9 @@ fn Liveness(ir: @mut IrMaps, specials: Specials) -> Liveness {\n         ir: ir,\n         tcx: ir.tcx,\n         s: specials,\n-        successors:\n-            vec::cast_to_mut(\n-                vec::from_elem(ir.num_live_nodes,\n-                               invalid_node())),\n-        users:\n-            vec::cast_to_mut(\n-                vec::from_elem(ir.num_live_nodes * ir.num_vars,\n-                               invalid_users())),\n+        successors: @mut vec::from_elem(ir.num_live_nodes, invalid_node()),\n+        users: @mut vec::from_elem(ir.num_live_nodes * ir.num_vars,\n+                                   invalid_users()),\n         loop_scope: DVec(),\n         break_ln: HashMap(),\n         cont_ln: HashMap()\n@@ -916,12 +911,13 @@ impl Liveness {\n \n         let mut changed = false;\n         do self.indices2(ln, succ_ln) |idx, succ_idx| {\n-            changed |= copy_if_invalid(copy self.users[succ_idx].reader,\n-                                       &mut self.users[idx].reader);\n-            changed |= copy_if_invalid(copy self.users[succ_idx].writer,\n-                                       &mut self.users[idx].writer);\n-            if self.users[succ_idx].used && !self.users[idx].used {\n-                self.users[idx].used = true;\n+            let users = &mut *self.users;\n+            changed |= copy_if_invalid(copy users[succ_idx].reader,\n+                                       &mut users[idx].reader);\n+            changed |= copy_if_invalid(copy users[succ_idx].writer,\n+                                       &mut users[idx].writer);\n+            if users[succ_idx].used && !users[idx].used {\n+                users[idx].used = true;\n                 changed = true;\n             }\n         }\n@@ -956,7 +952,8 @@ impl Liveness {\n     // Either read, write, or both depending on the acc bitset\n     fn acc(&self, ln: LiveNode, var: Variable, acc: uint) {\n         let idx = self.idx(ln, var);\n-        let user = &mut self.users[idx];\n+        let users = &mut *self.users;\n+        let user = &mut users[idx];\n \n         if (acc & ACC_WRITE) != 0 {\n             user.reader = invalid_node();\n@@ -970,7 +967,7 @@ impl Liveness {\n         }\n \n         if (acc & ACC_USE) != 0 {\n-            self.users[idx].used = true;\n+            user.used = true;\n         }\n \n         debug!(\"%s accesses[%x] %s: %s\","}, {"sha": "3f8ee61e8412dea9ab487a6a0ae18eb0527eb205", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -281,12 +281,12 @@ pub trait ast_node {\n     fn span(&self) -> span;\n }\n \n-pub impl ast_node for @ast::expr {\n+impl ast_node for @ast::expr {\n     fn id(&self) -> ast::node_id { self.id }\n     fn span(&self) -> span { self.span }\n }\n \n-pub impl ast_node for @ast::pat {\n+impl ast_node for @ast::pat {\n     fn id(&self) -> ast::node_id { self.id }\n     fn span(&self) -> span { self.span }\n }\n@@ -295,7 +295,7 @@ pub trait get_type_for_node {\n     fn ty<N:ast_node>(&self, node: N) -> ty::t;\n }\n \n-pub impl get_type_for_node for ty::ctxt {\n+impl get_type_for_node for ty::ctxt {\n     fn ty<N:ast_node>(&self, node: N) -> ty::t {\n         ty::node_id_to_type(*self, node.id())\n     }"}, {"sha": "bebf95727e22f686a667b0bb7f1ff2f63b61a252", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 67, "deletions": 25, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -19,6 +19,7 @@ use metadata::cstore::find_extern_mod_stmt_cnum;\n use metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n use middle::lang_items::LanguageItems;\n use middle::lint::{deny, allow, forbid, level, unused_imports, warn};\n+use middle::lint::{get_lint_level, get_lint_settings_level};\n use middle::pat_util::{pat_bindings};\n \n use core::cmp;\n@@ -508,16 +509,6 @@ pub impl Module {\n     }\n }\n \n-pub fn unused_import_lint_level(session: Session) -> level {\n-    for session.opts.lint_opts.each |lint_option_pair| {\n-        let (lint_type, lint_level) = *lint_option_pair;\n-        if lint_type == unused_imports {\n-            return lint_level;\n-        }\n-    }\n-    return allow;\n-}\n-\n // Records a possibly-private type definition.\n pub struct TypeNsDef {\n     privacy: Privacy,\n@@ -770,8 +761,6 @@ pub fn Resolver(session: Session,\n \n         graph_root: graph_root,\n \n-        unused_import_lint_level: unused_import_lint_level(session),\n-\n         trait_info: @HashMap(),\n         structs: @HashMap(),\n \n@@ -816,8 +805,6 @@ pub struct Resolver {\n \n     graph_root: @mut NameBindings,\n \n-    unused_import_lint_level: level,\n-\n     trait_info: @HashMap<def_id,@HashMap<ident,()>>,\n     structs: @HashMap<def_id,()>,\n \n@@ -4829,6 +4816,42 @@ pub impl Resolver {\n         }\n     }\n \n+    fn find_best_match_for_name(@mut self, name: &str) -> Option<~str> {\n+        let mut maybes: ~[~str] = ~[];\n+        let mut values: ~[uint] = ~[];\n+\n+        let mut j = self.value_ribs.len();\n+        while j != 0 {\n+            j -= 1;\n+            let rib = self.value_ribs.get_elt(j);\n+            for rib.bindings.each_entry |e| {\n+                vec::push(&mut maybes, copy *self.session.str_of(e.key));\n+                vec::push(&mut values, uint::max_value);\n+            }\n+        }\n+\n+        let mut smallest = 0;\n+        for vec::eachi(maybes) |i, &other| {\n+\n+            values[i] = str::levdistance(name, other);\n+\n+            if values[i] <= values[smallest] {\n+                smallest = i;\n+            }\n+        }\n+\n+        if vec::len(values) > 0 &&\n+            values[smallest] != uint::max_value &&\n+            values[smallest] < str::len(name) + 2 &&\n+            maybes[smallest] != name.to_owned() {\n+\n+            Some(vec::swap_remove(&mut maybes, smallest))\n+\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn name_exists_in_scope_struct(@mut self, name: &str) -> bool {\n         let mut i = self.type_ribs.len();\n         while i != 0 {\n@@ -4895,9 +4918,20 @@ pub impl Resolver {\n                                         wrong_name));\n                         }\n                         else {\n-                            self.session.span_err(expr.span,\n-                                                fmt!(\"unresolved name: %s\",\n+                            match self.find_best_match_for_name(wrong_name) {\n+\n+                                Some(m) => {\n+                                    self.session.span_err(expr.span,\n+                                            fmt!(\"unresolved name: `%s`. \\\n+                                                Did you mean: `%s`?\",\n+                                                wrong_name, m));\n+                                }\n+                                None => {\n+                                    self.session.span_err(expr.span,\n+                                            fmt!(\"unresolved name: `%s`.\",\n                                                 wrong_name));\n+                                }\n+                            }\n                         }\n                     }\n                 }\n@@ -5232,8 +5266,17 @@ pub impl Resolver {\n     // resolve data structures.\n     //\n \n+    fn unused_import_lint_level(@mut self, m: @mut Module) -> level {\n+        let settings = self.session.lint_settings;\n+        match m.def_id {\n+            Some(def) => get_lint_settings_level(settings, unused_imports,\n+                                                 def.node, def.node),\n+            None => get_lint_level(settings.default_settings, unused_imports)\n+        }\n+    }\n+\n     fn check_for_unused_imports_if_necessary(@mut self) {\n-        if self.unused_import_lint_level == allow {\n+        if self.unused_import_lint_level(self.current_module) == allow {\n             return;\n         }\n \n@@ -5285,12 +5328,15 @@ pub impl Resolver {\n         for module_.import_resolutions.each_value |&import_resolution| {\n             // Ignore dummy spans for things like automatically injected\n             // imports for the prelude, and also don't warn about the same\n-            // import statement being unused more than once.\n+            // import statement being unused more than once. Furthermore, if\n+            // the import is public, then we can't be sure whether it's unused\n+            // or not so don't warn about it.\n             if !import_resolution.state.used &&\n                     !import_resolution.state.warned &&\n-                    import_resolution.span != dummy_sp() {\n+                    import_resolution.span != dummy_sp() &&\n+                    import_resolution.privacy != Public {\n                 import_resolution.state.warned = true;\n-                match self.unused_import_lint_level {\n+                match self.unused_import_lint_level(module_) {\n                     warn => {\n                         self.session.span_warn(copy import_resolution.span,\n                                                ~\"unused import\");\n@@ -5299,11 +5345,7 @@ pub impl Resolver {\n                       self.session.span_err(copy import_resolution.span,\n                                             ~\"unused import\");\n                     }\n-                    allow => {\n-                      self.session.span_bug(copy import_resolution.span,\n-                                            ~\"shouldn't be here if lint \\\n-                                              is allowed\");\n-                    }\n+                    allow => ()\n                 }\n             }\n         }"}, {"sha": "3686c31ea6e648d165604c8fa24cc04ba19bab0e", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -172,11 +172,6 @@ use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::print::pprust::pat_to_str;\n \n-pub fn macros() {\n-    // FIXME(#3114): Macro import/export.\n-    include!(\"macros.rs\");\n-}\n-\n // An option identifying a literal: either a unit-like struct or an\n // expression.\n pub enum Lit {"}, {"sha": "afdc85ef04fca35fe89ccaa76634f2c4dea4b05a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -76,7 +76,6 @@ use core::option::{is_none, is_some};\n use core::option;\n use core::uint;\n use std::oldmap::HashMap;\n-use std::oldsmallintmap;\n use std::{oldmap, time, list};\n use syntax::ast_map::{path, path_elt_to_str, path_mod, path_name};\n use syntax::ast_util::{def_id_of_def, local_def, path_to_ident};\n@@ -108,7 +107,7 @@ pub trait get_insn_ctxt {\n     fn insn_ctxt(&self, s: &str) -> icx_popper;\n }\n \n-pub impl get_insn_ctxt for @CrateContext {\n+impl get_insn_ctxt for @CrateContext {\n     fn insn_ctxt(&self, s: &str) -> icx_popper {\n         debug!(\"new insn_ctxt: %s\", s);\n         if self.sess.count_llvm_insns() {\n@@ -118,13 +117,13 @@ pub impl get_insn_ctxt for @CrateContext {\n     }\n }\n \n-pub impl get_insn_ctxt for block {\n+impl get_insn_ctxt for block {\n     fn insn_ctxt(&self, s: &str) -> icx_popper {\n         self.ccx().insn_ctxt(s)\n     }\n }\n \n-pub impl get_insn_ctxt for fn_ctxt {\n+impl get_insn_ctxt for fn_ctxt {\n     fn insn_ctxt(&self, s: &str) -> icx_popper {\n         self.ccx.insn_ctxt(s)\n     }\n@@ -2171,11 +2170,6 @@ pub fn trans_mod(ccx: @CrateContext, m: &ast::_mod) {\n     }\n }\n \n-pub fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n-    // Bit of a kludge: pick the fn typeref out of the pair.\n-    return struct_elt(llpairty, 0u);\n-}\n-\n pub fn register_fn(ccx: @CrateContext,\n                    sp: span,\n                    +path: path,\n@@ -2272,7 +2266,7 @@ pub fn create_main_wrapper(ccx: @CrateContext,\n         fn main_name() -> ~str { return ~\"WinMain@16\"; }\n         #[cfg(unix)]\n         fn main_name() -> ~str { return ~\"main\"; }\n-        let llfty = T_fn(~[ccx.int_type, ccx.int_type], ccx.int_type);\n+        let llfty = T_fn(~[ccx.int_type, T_ptr(T_i8())], ccx.int_type);\n \n         // FIXME #4404 android JNI hacks\n         let llfn = if *ccx.sess.building_library {\n@@ -2290,33 +2284,50 @@ pub fn create_main_wrapper(ccx: @CrateContext,\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n         }\n         let crate_map = ccx.crate_map;\n-        let start_ty = T_fn(~[val_ty(rust_main), ccx.int_type, ccx.int_type,\n-                             val_ty(crate_map)], ccx.int_type);\n-        let start = decl_cdecl_fn(ccx.llmod, ~\"rust_start\", start_ty);\n+        let start_def_id = ccx.tcx.lang_items.start_fn();\n+        let start_fn = if start_def_id.crate == ast::local_crate {\n+            ccx.sess.bug(~\"start lang item is never in the local crate\")\n+        } else {\n+            let start_fn_type = csearch::get_type(ccx.tcx,\n+                                                  start_def_id).ty;\n+            trans_external_path(ccx, start_def_id, start_fn_type)\n+        };\n+\n+        let retptr = unsafe {\n+            llvm::LLVMBuildAlloca(bld, ccx.int_type, noname())\n+        };\n \n         let args = unsafe {\n+            let opaque_rust_main = llvm::LLVMBuildPointerCast(\n+                bld, rust_main, T_ptr(T_i8()), noname());\n+            let opaque_crate_map = llvm::LLVMBuildPointerCast(\n+                bld, crate_map, T_ptr(T_i8()), noname());\n+\n             if *ccx.sess.building_library {\n                 ~[\n-                    rust_main,\n+                    retptr,\n+                    C_null(T_opaque_box_ptr(ccx)),\n+                    opaque_rust_main,\n                     llvm::LLVMConstInt(T_i32(), 0u as c_ulonglong, False),\n                     llvm::LLVMConstInt(T_i32(), 0u as c_ulonglong, False),\n-                    crate_map\n+                    opaque_crate_map\n                 ]\n             } else {\n                 ~[\n-                    rust_main,\n+                    retptr,\n+                    C_null(T_opaque_box_ptr(ccx)),\n+                    opaque_rust_main,\n                     llvm::LLVMGetParam(llfn, 0 as c_uint),\n                     llvm::LLVMGetParam(llfn, 1 as c_uint),\n-                    crate_map\n+                    opaque_crate_map\n                 ]\n             }\n         };\n \n-        let result = unsafe {\n-            llvm::LLVMBuildCall(bld, start, vec::raw::to_ptr(args),\n-                                args.len() as c_uint, noname())\n-        };\n         unsafe {\n+            llvm::LLVMBuildCall(bld, start_fn, vec::raw::to_ptr(args),\n+                                args.len() as c_uint, noname());\n+            let result = llvm::LLVMBuildLoad(bld, retptr, noname());\n             llvm::LLVMBuildRet(bld, result);\n         }\n     }"}, {"sha": "259392bef40c8095460373cf7bd536fb2de8e142", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -0,0 +1,164 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n+use lib::llvm::struct_tys;\n+use lib::llvm::TypeRef;\n+use lib::llvm::{Attribute, StructRetAttribute};\n+use middle::trans::cabi::{ABIInfo, FnType, LLVMType};\n+use middle::trans::common::{T_i8, T_i16, T_i32, T_i64};\n+use middle::trans::common::{T_array, T_ptr, T_void};\n+\n+use core::option::{Option, None, Some};\n+use core::uint;\n+use core::vec;\n+\n+fn align_up_to(off: uint, a: uint) -> uint {\n+    return (off + a - 1u) / a * a;\n+}\n+\n+fn align(off: uint, ty: TypeRef) -> uint {\n+    let a = ty_align(ty);\n+    return align_up_to(off, a);\n+}\n+\n+fn ty_align(ty: TypeRef) -> uint {\n+    unsafe {\n+        return match llvm::LLVMGetTypeKind(ty) {\n+            Integer => {\n+                ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n+            }\n+            Pointer => 4,\n+            Float => 4,\n+            Double => 8,\n+            Struct => {\n+                do vec::foldl(1, struct_tys(ty)) |a, t| {\n+                    uint::max(a, ty_align(*t))\n+                }\n+            }\n+            Array => {\n+                let elt = llvm::LLVMGetElementType(ty);\n+                ty_align(elt)\n+            }\n+            _ => fail!(~\"ty_align: unhandled type\")\n+        };\n+    }\n+}\n+\n+fn ty_size(ty: TypeRef) -> uint {\n+    unsafe {\n+        return match llvm::LLVMGetTypeKind(ty) {\n+            Integer => {\n+                ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n+            }\n+            Pointer => 4,\n+            Float => 4,\n+            Double => 8,\n+            Struct => {\n+                let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n+                    align(s, *t) + ty_size(*t)\n+                };\n+                align(size, ty)\n+            }\n+            Array => {\n+                let len = llvm::LLVMGetArrayLength(ty) as uint;\n+                let elt = llvm::LLVMGetElementType(ty);\n+                let eltsz = ty_size(elt);\n+                len * eltsz\n+            }\n+            _ => fail!(~\"ty_size: unhandled type\")\n+        };\n+    }\n+}\n+\n+fn classify_ret_ty(ty: TypeRef) -> (LLVMType, Option<Attribute>) {\n+    if is_reg_ty(ty) {\n+        return (LLVMType { cast: false, ty: ty }, None);\n+    }\n+    let size = ty_size(ty);\n+    if size <= 4 {\n+        let llty = if size <= 1 {\n+            T_i8()\n+        } else if size <= 2 {\n+            T_i16()\n+        } else {\n+            T_i32()\n+        };\n+        return (LLVMType { cast: true, ty: llty }, None);\n+    }\n+    (LLVMType { cast: false, ty: T_ptr(ty) }, Some(StructRetAttribute))\n+}\n+\n+fn classify_arg_ty(ty: TypeRef) -> (LLVMType, Option<Attribute>) {\n+    if is_reg_ty(ty) {\n+        return (LLVMType { cast: false, ty: ty }, None);\n+    }\n+    let align = ty_align(ty);\n+    let size = ty_size(ty);\n+    let llty = if align <= 4 {\n+        T_array(T_i32(), (size + 3) / 4)\n+    } else {\n+        T_array(T_i64(), (size + 7) / 8)\n+    };\n+    (LLVMType { cast: true, ty: llty }, None)\n+}\n+\n+fn is_reg_ty(ty: TypeRef) -> bool {\n+    unsafe {\n+        return match llvm::LLVMGetTypeKind(ty) {\n+            Integer\n+            | Pointer\n+            | Float\n+            | Double => true,\n+            _ => false\n+        };\n+    }\n+}\n+\n+enum ARM_ABIInfo { ARM_ABIInfo }\n+\n+impl ABIInfo for ARM_ABIInfo {\n+    fn compute_info(&self,\n+                    atys: &[TypeRef],\n+                    rty: TypeRef,\n+                    ret_def: bool) -> FnType {\n+        let mut arg_tys = ~[];\n+        let mut attrs = ~[];\n+        for atys.each |&aty| {\n+            let (ty, attr) = classify_arg_ty(aty);\n+            arg_tys.push(ty);\n+            attrs.push(attr);\n+        }\n+\n+        let mut (ret_ty, ret_attr) = if ret_def {\n+            classify_ret_ty(rty)\n+        } else {\n+            (LLVMType { cast: false, ty: T_void() }, None)\n+        };\n+\n+        let sret = ret_attr.is_some();\n+        if sret {\n+            arg_tys.unshift(ret_ty);\n+            attrs.unshift(ret_attr);\n+            ret_ty = LLVMType { cast: false, ty: T_void() };\n+        }\n+\n+        return FnType {\n+            arg_tys: arg_tys,\n+            ret_ty: ret_ty,\n+            attrs: attrs,\n+            sret: sret\n+        };\n+    }\n+}\n+\n+pub fn abi_info() -> ABIInfo {\n+    return ARM_ABIInfo as ABIInfo;\n+}"}, {"sha": "df0f11eedae88743e492387b6333463015530127", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -14,6 +14,7 @@\n use lib::llvm::{llvm, TypeRef, ValueRef, Integer, Pointer, Float, Double};\n use lib::llvm::{Struct, Array, Attribute};\n use lib::llvm::{StructRetAttribute, ByValAttribute};\n+use lib::llvm::struct_tys;\n use middle::trans::common::*;\n use middle::trans::cabi::*;\n \n@@ -65,19 +66,6 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n         return (off + a - 1u) / a * a;\n     }\n \n-    fn struct_tys(ty: TypeRef) -> ~[TypeRef] {\n-        unsafe {\n-            let n = llvm::LLVMCountStructElementTypes(ty);\n-        if (n == 0) {\n-            return ~[];\n-        }\n-            let mut elts = vec::from_elem(n as uint, ptr::null());\n-            llvm::LLVMGetStructElementTypes(ty,\n-                ptr::to_mut_unsafe_ptr(&mut elts[0]));\n-            return elts;\n-        }\n-    }\n-\n     fn ty_align(ty: TypeRef) -> uint {\n         unsafe {\n             return match llvm::LLVMGetTypeKind(ty) {"}, {"sha": "e24f6503aef73e0e08fa3fcde8348878f08ef4d9", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -380,7 +380,7 @@ pub fn trans_rtcall_or_lang_call_with_type_params(bcx: block,\n                                                     fty);\n                     let mut llfnty = type_of::type_of(callee.bcx.ccx(),\n                                                       substituted);\n-                    llfnty = T_ptr(struct_elt(llfnty, 0));\n+                    llfnty = lib::llvm::struct_tys(llfnty)[0];\n                     new_llval = PointerCast(callee.bcx, fn_data.llfn, llfnty);\n                 }\n                 _ => fail!()"}, {"sha": "f8a7f4779764cc9fcfd85528e5327e73eebe7ec1", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -538,13 +538,13 @@ pub trait get_node_info {\n     fn info(&self) -> Option<NodeInfo>;\n }\n \n-pub impl get_node_info for @ast::expr {\n+impl get_node_info for @ast::expr {\n     fn info(&self) -> Option<NodeInfo> {\n         Some(NodeInfo { id: self.id, span: self.span })\n     }\n }\n \n-pub impl get_node_info for ast::blk {\n+impl get_node_info for ast::blk {\n     fn info(&self) -> Option<NodeInfo> {\n         Some(NodeInfo { id: self.node.id, span: self.span })\n     }\n@@ -553,7 +553,7 @@ pub impl get_node_info for ast::blk {\n // XXX: Work around a trait parsing bug. remove after snapshot\n pub type optional_boxed_ast_expr = Option<@ast::expr>;\n \n-pub impl get_node_info for optional_boxed_ast_expr {\n+impl get_node_info for optional_boxed_ast_expr {\n     fn info(&self) -> Option<NodeInfo> {\n         self.chain_ref(|s| s.info())\n     }\n@@ -647,19 +647,6 @@ pub fn val_str(tn: @TypeNames, v: ValueRef) -> @str {\n     return ty_str(tn, val_ty(v));\n }\n \n-// Returns the nth element of the given LLVM structure type.\n-pub fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef {\n-    unsafe {\n-        let elt_count = llvm::LLVMCountStructElementTypes(llstructty) as uint;\n-        assert (n < elt_count);\n-        let mut elt_tys = vec::from_elem(elt_count, T_nil());\n-        llvm::LLVMGetStructElementTypes(\n-            llstructty,\n-            ptr::to_mut_unsafe_ptr(&mut elt_tys[0]));\n-        return llvm::LLVMGetElementType(elt_tys[n]);\n-    }\n-}\n-\n pub fn in_scope_cx(cx: block, f: &fn(&mut scope_info)) {\n     let mut cur = cx;\n     loop {\n@@ -1288,7 +1275,7 @@ pub struct mono_id_ {\n \n pub type mono_id = @mono_id_;\n \n-pub impl to_bytes::IterBytes for mono_param_id {\n+impl to_bytes::IterBytes for mono_param_id {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match /*bad*/copy *self {\n           mono_precise(t, mids) =>\n@@ -1302,7 +1289,7 @@ pub impl to_bytes::IterBytes for mono_param_id {\n     }\n }\n \n-pub impl to_bytes::IterBytes for mono_id_ {\n+impl to_bytes::IterBytes for mono_id_ {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);\n     }"}, {"sha": "57cb1a937764cd47ebf2df2ef11e06a76bfa1b57", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -18,11 +18,6 @@ use middle::trans::datum::*;\n \n use core::str;\n \n-pub fn macros() {\n-    // FIXME(#3114): Macro import/export.\n-    include!(\"macros.rs\");\n-}\n-\n pub fn trans_block(bcx: block, b: &ast::blk, dest: expr::Dest) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_block\");\n     let mut bcx = bcx;"}, {"sha": "07499dac62e148e4fa418cea5c251521e259950b", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -151,14 +151,14 @@ pub impl DatumMode {\n     }\n }\n \n-pub impl cmp::Eq for DatumMode {\n+impl cmp::Eq for DatumMode {\n     pure fn eq(&self, other: &DatumMode) -> bool {\n         (*self) as uint == (*other as uint)\n     }\n     pure fn ne(&self, other: &DatumMode) -> bool { !(*self).eq(other) }\n }\n \n-pub impl to_bytes::IterBytes for DatumMode {\n+impl to_bytes::IterBytes for DatumMode {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }"}, {"sha": "6226e83d046b3eb85ec845dc2ab92808911aab7a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -149,8 +149,6 @@ use syntax::codemap::spanned;\n // These are passed around by the code generating functions to track the\n // destination of a computation's value.\n \n-fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n-\n pub enum Dest {\n     SaveIn(ValueRef),\n     Ignore,"}, {"sha": "ef0d61d49deda0b0a560a1e8eed348f9c9e7b565", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -21,6 +21,7 @@ use lib;\n use middle::trans::base::*;\n use middle::trans::cabi;\n use middle::trans::cabi_x86_64::*;\n+use middle::trans::cabi_arm;\n use middle::trans::build::*;\n use middle::trans::callee::*;\n use middle::trans::common::*;\n@@ -42,7 +43,8 @@ use syntax::parse::token::special_idents;\n \n fn abi_info(arch: session::arch) -> cabi::ABIInfo {\n     return match arch {\n-        arch_x86_64 | arch_arm => x86_64_abi_info(),\n+        arch_x86_64 => x86_64_abi_info(),\n+        arch_arm => cabi_arm::abi_info(),\n         _ => cabi::llvm_abi_info()\n     }\n }"}, {"sha": "14ed7692661d4dfd89d952264dbdcc2ba5602d4e", "filename": "src/librustc/middle/trans/macros.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmacros.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-{\n+#[macro_escape];\n \n macro_rules! unpack_datum(\n     ($bcx: ident, $inp: expr) => (\n@@ -18,7 +18,7 @@ macro_rules! unpack_datum(\n             db.datum\n         }\n     )\n-);\n+)\n \n macro_rules! unpack_result(\n     ($bcx: ident, $inp: expr) => (\n@@ -28,7 +28,7 @@ macro_rules! unpack_result(\n             db.val\n         }\n     )\n-);\n+)\n \n macro_rules! trace_span(\n     ($bcx: ident, $sp: expr, $str: expr) => (\n@@ -39,7 +39,7 @@ macro_rules! trace_span(\n             }\n         }\n     )\n-);\n+)\n \n macro_rules! trace(\n     ($bcx: ident, $str: expr) => (\n@@ -50,6 +50,5 @@ macro_rules! trace(\n             }\n         }\n     )\n-);\n+)\n \n-}"}, {"sha": "4c0e6d76d3a857205a058e40d809fdd0f36ccbea", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -39,11 +39,6 @@ use syntax::ast_util::local_def;\n use syntax::print::pprust::expr_to_str;\n use syntax::{ast, ast_map};\n \n-pub fn macros() {\n-    // FIXME(#3114): Macro import/export.\n-    include!(\"macros.rs\");\n-}\n-\n /**\n The main \"translation\" pass for methods.  Generates code\n for non-monomorphized methods only.  Other methods will"}, {"sha": "627042a6516845aaa1e88e3fd11dcaebe4f124b7", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -51,7 +51,7 @@ pub const use_tydesc: uint = 2u; /* Takes the tydesc, or compares */\n \n pub struct Context {\n     ccx: @CrateContext,\n-    uses: ~[mut type_uses]\n+    uses: @mut ~[type_uses]\n }\n \n pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n@@ -72,7 +72,7 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n \n     let cx = Context {\n         ccx: ccx,\n-        uses: vec::cast_to_mut(vec::from_elem(n_tps, 0u))\n+        uses: @mut vec::from_elem(n_tps, 0u)\n     };\n     match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).sty {\n         ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n@@ -90,7 +90,7 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n     }\n \n     if fn_id_loc.crate != local_crate {\n-        let uses = vec::cast_from_mut(copy cx.uses);\n+        let uses = copy *cx.uses;\n         ccx.type_use_cache.insert(fn_id, copy uses);\n         return uses;\n     }\n@@ -175,16 +175,16 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n                                 ccx.tcx.sess.parse_sess.interner)));\n       }\n     }\n-    let uses = vec::cast_from_mut(copy cx.uses);\n-    // XXX: Bad copy, use @vec instead?\n+    // XXX: Bad copies, use @vec instead?\n+    let uses = copy *cx.uses;\n     ccx.type_use_cache.insert(fn_id, copy uses);\n     uses\n }\n \n pub fn type_needs(cx: Context, use_: uint, ty: ty::t) {\n     // Optimization -- don't descend type if all params already have this use\n-    for vec::each_mut(cx.uses) |u| {\n-        if *u & use_ != use_ {\n+    for uint::range(0, cx.uses.len()) |i| {\n+        if cx.uses[i] & use_ != use_ {\n             type_needs_inner(cx, use_, ty, @Nil);\n             return;\n         }"}, {"sha": "230fd5ab5f868a93d3bdcd8a95a8e8da2c0fa440", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 49, "deletions": 105, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -42,7 +42,8 @@ use core::uint;\n use core::vec;\n use core::hashmap::linear::LinearMap;\n use std::oldmap::HashMap;\n-use std::{oldmap, oldsmallintmap};\n+use std::oldmap;\n+use std::smallintmap::SmallIntMap;\n use syntax::ast::*;\n use syntax::ast_util::{is_local, local_def};\n use syntax::ast_util;\n@@ -258,7 +259,6 @@ struct ctxt_ {\n     rcache: creader_cache,\n     ccache: constness_cache,\n     short_names_cache: HashMap<t, @~str>,\n-    needs_drop_cache: HashMap<t, bool>,\n     needs_unwind_cleanup_cache: HashMap<t, bool>,\n     tc_cache: @mut LinearMap<uint, TypeContents>,\n     ast_ty_to_ty_cache: HashMap<node_id, ast_ty_to_ty_cache_entry>,\n@@ -660,46 +660,46 @@ pub trait Vid {\n     pure fn to_uint(&self) -> uint;\n }\n \n-pub impl Vid for TyVid {\n+impl Vid for TyVid {\n     pure fn to_uint(&self) -> uint { **self }\n }\n \n-pub impl ToStr for TyVid {\n+impl ToStr for TyVid {\n     pure fn to_str(&self) -> ~str { fmt!(\"<V%u>\", self.to_uint()) }\n }\n \n-pub impl Vid for IntVid {\n+impl Vid for IntVid {\n     pure fn to_uint(&self) -> uint { **self }\n }\n \n-pub impl ToStr for IntVid {\n+impl ToStr for IntVid {\n     pure fn to_str(&self) -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n }\n \n-pub impl Vid for FloatVid {\n+impl Vid for FloatVid {\n     pure fn to_uint(&self) -> uint { **self }\n }\n \n-pub impl ToStr for FloatVid {\n+impl ToStr for FloatVid {\n     pure fn to_str(&self) -> ~str { fmt!(\"<VF%u>\", self.to_uint()) }\n }\n \n-pub impl Vid for RegionVid {\n+impl Vid for RegionVid {\n     pure fn to_uint(&self) -> uint { **self }\n }\n \n-pub impl ToStr for RegionVid {\n+impl ToStr for RegionVid {\n     pure fn to_str(&self) -> ~str { fmt!(\"%?\", self) }\n }\n \n-pub impl ToStr for FnSig {\n+impl ToStr for FnSig {\n     pure fn to_str(&self) -> ~str {\n         // grr, without tcx not much we can do.\n         return ~\"(...)\";\n     }\n }\n \n-pub impl ToStr for InferTy {\n+impl ToStr for InferTy {\n     pure fn to_str(&self) -> ~str {\n         match *self {\n             TyVar(ref v) => v.to_str(),\n@@ -709,7 +709,7 @@ pub impl ToStr for InferTy {\n     }\n }\n \n-pub impl ToStr for IntVarValue {\n+impl ToStr for IntVarValue {\n     pure fn to_str(&self) -> ~str {\n         match *self {\n             IntType(ref v) => v.to_str(),\n@@ -718,25 +718,25 @@ pub impl ToStr for IntVarValue {\n     }\n }\n \n-pub impl to_bytes::IterBytes for TyVid {\n+impl to_bytes::IterBytes for TyVid {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n-pub impl to_bytes::IterBytes for IntVid {\n+impl to_bytes::IterBytes for IntVid {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n-pub impl to_bytes::IterBytes for FloatVid {\n+impl to_bytes::IterBytes for FloatVid {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n-pub impl to_bytes::IterBytes for RegionVid {\n+impl to_bytes::IterBytes for RegionVid {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n@@ -767,7 +767,7 @@ type type_cache = HashMap<ast::def_id, ty_param_bounds_and_ty>;\n \n type constness_cache = HashMap<ast::def_id, const_eval::constness>;\n \n-pub type node_type_table = @oldsmallintmap::SmallIntMap<t>;\n+pub type node_type_table = @mut SmallIntMap<t>;\n \n fn mk_rcache() -> creader_cache {\n     type val = {cnum: int, pos: uint, len: uint};\n@@ -812,7 +812,7 @@ pub fn mk_ctxt(s: session::Session,\n         def_map: dm,\n         region_map: region_map,\n         region_paramd_items: region_paramd_items,\n-        node_types: @oldsmallintmap::mk(),\n+        node_types: @mut SmallIntMap::new(),\n         node_type_substs: oldmap::HashMap(),\n         items: amap,\n         intrinsic_defs: oldmap::HashMap(),\n@@ -821,7 +821,6 @@ pub fn mk_ctxt(s: session::Session,\n         rcache: mk_rcache(),\n         ccache: HashMap(),\n         short_names_cache: new_ty_hash(),\n-        needs_drop_cache: new_ty_hash(),\n         needs_unwind_cleanup_cache: new_ty_hash(),\n         tc_cache: @mut LinearMap::new(),\n         ast_ty_to_ty_cache: HashMap(),\n@@ -1599,79 +1598,7 @@ pub fn type_is_immediate(ty: t) -> bool {\n }\n \n pub fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n-    match cx.needs_drop_cache.find(&ty) {\n-      Some(result) => return result,\n-      None => {/* fall through */ }\n-    }\n-\n-    let mut accum = false;\n-    let result = match /*bad*/copy get(ty).sty {\n-      // scalar types\n-      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_type | ty_ptr(_) | ty_rptr(_, _) |\n-      ty_estr(vstore_fixed(_)) |\n-      ty_estr(vstore_slice(_)) |\n-      ty_evec(_, vstore_slice(_)) |\n-      ty_self => false,\n-\n-      ty_box(_) | ty_uniq(_) |\n-      ty_opaque_box | ty_opaque_closure_ptr(*) |\n-      ty_estr(vstore_uniq) |\n-      ty_estr(vstore_box) |\n-      ty_evec(_, vstore_uniq) |\n-      ty_evec(_, vstore_box) => true,\n-\n-      ty_trait(_, _, vstore_box) |\n-      ty_trait(_, _, vstore_uniq) => true,\n-      ty_trait(_, _, vstore_fixed(_)) |\n-      ty_trait(_, _, vstore_slice(_)) => false,\n-\n-      ty_param(*) | ty_infer(*) | ty_err => true,\n-\n-      ty_evec(mt, vstore_fixed(_)) => type_needs_drop(cx, mt.ty),\n-      ty_unboxed_vec(mt) => type_needs_drop(cx, mt.ty),\n-      ty_rec(flds) => {\n-        for flds.each |f| {\n-            if type_needs_drop(cx, f.mt.ty) { accum = true; }\n-        }\n-        accum\n-      }\n-      ty_struct(did, ref substs) => {\n-         // Any struct with a dtor needs a drop\n-         ty_dtor(cx, did).is_present() || {\n-             for vec::each(ty::struct_fields(cx, did, substs)) |f| {\n-                 if type_needs_drop(cx, f.mt.ty) { accum = true; }\n-             }\n-             accum\n-         }\n-      }\n-      ty_tup(elts) => {\n-          for elts.each |m| { if type_needs_drop(cx, *m) { accum = true; } }\n-        accum\n-      }\n-      ty_enum(did, ref substs) => {\n-        let variants = enum_variants(cx, did);\n-          for vec::each(*variants) |variant| {\n-              for variant.args.each |aty| {\n-                // Perform any type parameter substitutions.\n-                let arg_ty = subst(cx, substs, *aty);\n-                if type_needs_drop(cx, arg_ty) { accum = true; }\n-            }\n-            if accum { break; }\n-        }\n-        accum\n-      }\n-      ty_bare_fn(*) => false,\n-      ty_closure(ref fty) => {\n-        match fty.sigil {\n-          ast::BorrowedSigil => false,\n-          ast::ManagedSigil | ast::OwnedSigil => true,\n-        }\n-      }\n-    };\n-\n-    cx.needs_drop_cache.insert(ty, result);\n-    return result;\n+    type_contents(cx, ty).needs_drop(cx)\n }\n \n // Some things don't need cleanups during unwinding because the\n@@ -1818,7 +1745,7 @@ pub impl TypeContents {\n \n     static fn nonimplicitly_copyable(cx: ctxt) -> TypeContents {\n         let base = TypeContents::noncopyable(cx) + TC_OWNED_POINTER;\n-        if cx.vecs_implicitly_copyable {base} else {base + TC_OWNED_SLICE}\n+        if cx.vecs_implicitly_copyable {base} else {base + TC_OWNED_VEC}\n     }\n \n     fn is_safe_for_default_mode(&self, cx: ctxt) -> bool {\n@@ -1827,7 +1754,17 @@ pub impl TypeContents {\n \n     static fn nondefault_mode(cx: ctxt) -> TypeContents {\n         let tc = TypeContents::nonimplicitly_copyable(cx);\n-        tc + TC_BIG + TC_OWNED_SLICE // disregard cx.vecs_implicitly_copyable\n+        tc + TC_BIG + TC_OWNED_VEC // disregard cx.vecs_implicitly_copyable\n+    }\n+\n+    fn needs_drop(&self, cx: ctxt) -> bool {\n+        let tc = TC_MANAGED + TC_DTOR + TypeContents::owned(cx);\n+        self.intersects(tc)\n+    }\n+\n+    static fn owned(&self, _cx: ctxt) -> TypeContents {\n+        //! Any kind of owned contents.\n+        TC_OWNED_CLOSURE + TC_OWNED_POINTER + TC_OWNED_VEC\n     }\n }\n \n@@ -1858,8 +1795,8 @@ const TC_BORROWED_POINTER: TypeContents = TypeContents{bits:0b0000_00000001};\n /// Contains an owned pointer (~T) but not slice of some kind\n const TC_OWNED_POINTER: TypeContents =    TypeContents{bits:0b000000000010};\n \n-/// Contains an owned slice\n-const TC_OWNED_SLICE: TypeContents =      TypeContents{bits:0b000000000100};\n+/// Contains an owned vector ~[] or owned string ~str\n+const TC_OWNED_VEC: TypeContents =        TypeContents{bits:0b000000000100};\n \n /// Contains a ~fn() or a ~Trait, which is non-copyable.\n const TC_OWNED_CLOSURE: TypeContents =    TypeContents{bits:0b000000001000};\n@@ -1962,7 +1899,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             }\n \n             ty_estr(vstore_uniq) => {\n-                TC_OWNED_SLICE\n+                TC_OWNED_VEC\n             }\n \n             ty_closure(ref c) => {\n@@ -1995,7 +1932,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             }\n \n             ty_evec(mt, vstore_uniq) => {\n-                TC_OWNED_SLICE + tc_mt(cx, mt, cache)\n+                TC_OWNED_VEC + tc_mt(cx, mt, cache)\n             }\n \n             ty_evec(mt, vstore_box) => {\n@@ -2787,8 +2724,8 @@ pub fn br_hashmap<V:Copy>() -> HashMap<bound_region, V> {\n \n pub fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n     //io::println(fmt!(\"%?/%?\", id, cx.node_types.len()));\n-    match oldsmallintmap::find(*cx.node_types, id as uint) {\n-       Some(t) => t,\n+    match cx.node_types.find(&(id as uint)) {\n+       Some(&t) => t,\n        None => cx.sess.bug(\n            fmt!(\"node_id_to_type: no type for node `%s`\",\n                 ast_map::node_id_to_str(cx.items, id,\n@@ -3179,8 +3116,8 @@ pub fn expr_kind(tcx: ctxt,\n         }\n \n         ast::expr_cast(*) => {\n-            match oldsmallintmap::find(*tcx.node_types, expr.id as uint) {\n-                Some(t) => {\n+            match tcx.node_types.find(&(expr.id as uint)) {\n+                Some(&t) => {\n                     if ty::type_is_immediate(t) {\n                         RvalueDatumExpr\n                     } else {\n@@ -4289,7 +4226,8 @@ pub fn eval_repeat_count(tcx: ctxt,\n                          count_expr: @ast::expr,\n                          span: span)\n                       -> uint {\n-    match const_eval::eval_const_expr(tcx, count_expr) {\n+    match const_eval::eval_const_expr_partial(tcx, count_expr) {\n+      Ok(ref const_val) => match *const_val {\n         const_eval::const_int(count) => return count as uint,\n         const_eval::const_uint(count) => return count as uint,\n         const_eval::const_float(count) => {\n@@ -4310,7 +4248,13 @@ pub fn eval_repeat_count(tcx: ctxt,\n                                 repeat count but found boolean\");\n             return 0;\n         }\n-\n+      },\n+      Err(*) => {\n+        tcx.sess.span_err(span,\n+                          ~\"expected constant integer for repeat count \\\n+                            but found variable\");\n+        return 0;\n+      }\n     }\n }\n "}, {"sha": "5c05723bb3f0471df766fb0ff7e47079676b7b30", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -216,7 +216,8 @@ pub fn ast_ty_to_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n         match a_seq_ty.ty.node {\n             ast::ty_vec(mt) => {\n                 let mut mt = ast_mt_to_mt(self, rscope, mt);\n-                if a_seq_ty.mutbl == ast::m_mutbl {\n+                if a_seq_ty.mutbl == ast::m_mutbl ||\n+                        a_seq_ty.mutbl == ast::m_const {\n                     mt = ty::mt { ty: mt.ty, mutbl: ast::m_mutbl };\n                 }\n                 return ty::mk_evec(tcx, mt, vst);"}, {"sha": "e908fd2ac225d027874a62749f90b532a9182570", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -635,7 +635,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n     }\n }\n \n-pub impl AstConv for FnCtxt {\n+impl AstConv for FnCtxt {\n     fn tcx(@mut self) -> ty::ctxt { self.ccx.tcx }\n     fn ccx(@mut self) -> @mut CrateCtxt { self.ccx }\n \n@@ -669,7 +669,7 @@ pub impl FnCtxt {\n     }\n }\n \n-pub impl region_scope for @mut FnCtxt {\n+impl region_scope for @mut FnCtxt {\n     pure fn anon_region(&self, span: span) -> Result<ty::Region, ~str> {\n         // XXX: Unsafe to work around purity\n         unsafe {"}, {"sha": "a565e313237112f9dfbd90be2d439cda8e878d14", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -121,7 +121,7 @@ pub impl @mut CrateCtxt {\n     }\n }\n \n-pub impl AstConv for CrateCtxt {\n+impl AstConv for CrateCtxt {\n     fn tcx(@mut self) -> ty::ctxt { self.tcx }\n     fn ccx(@mut self) -> @mut CrateCtxt { self }\n "}, {"sha": "f63dac4c5ae55b8b4b5938a9df9f0bc19f1355c1", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -72,11 +72,6 @@ use syntax::ast::{Onceness, purity, ret_style};\n use syntax::ast;\n use syntax::codemap::span;\n \n-pub fn macros() {\n-    // FIXME(#3114): Macro import/export.\n-    include!(\"macros.rs\");\n-}\n-\n pub trait Combine {\n     fn infcx(&self) -> @mut InferCtxt;\n     fn tag(&self) -> ~str;"}, {"sha": "936ca1e829775aba5c2e73e403fa10acf22c5868", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -27,7 +27,7 @@ use std::list;\n \n pub enum Glb = CombineFields;  // \"greatest lower bound\" (common subtype)\n \n-pub impl Combine for Glb {\n+impl Combine for Glb {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"glb\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }"}, {"sha": "8fa887fca0badde4e9ce1cc4e6381d51864cdc43", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -59,7 +59,7 @@ pub trait LatticeValue {\n \n pub type LatticeOp<T> = &fn(cf: &CombineFields, a: &T, b: &T) -> cres<T>;\n \n-pub impl LatticeValue for ty::t {\n+impl LatticeValue for ty::t {\n     static fn sub(&self, cf: &CombineFields, a: &ty::t, b: &ty::t) -> ures {\n         Sub(*cf).tys(*a, *b).to_ures()\n     }\n@@ -305,29 +305,29 @@ pub trait TyLatticeDir {\n     fn ty_bot(&self, t: ty::t) -> cres<ty::t>;\n }\n \n-pub impl LatticeDir for Lub {\n+impl LatticeDir for Lub {\n     fn combine_fields(&self) -> CombineFields { **self }\n     fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { b.ub }\n     fn with_bnd<T:Copy>(&self, b: &Bounds<T>, +t: T) -> Bounds<T> {\n         Bounds { ub: Some(t), ..*b }\n     }\n }\n \n-pub impl TyLatticeDir for Lub {\n+impl TyLatticeDir for Lub {\n     fn ty_bot(&self, t: ty::t) -> cres<ty::t> {\n         Ok(t)\n     }\n }\n \n-pub impl LatticeDir for Glb {\n+impl LatticeDir for Glb {\n     fn combine_fields(&self) -> CombineFields { **self }\n     fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { b.lb }\n     fn with_bnd<T:Copy>(&self, b: &Bounds<T>, +t: T) -> Bounds<T> {\n         Bounds { lb: Some(t), ..*b }\n     }\n }\n \n-pub impl TyLatticeDir for Glb {\n+impl TyLatticeDir for Glb {\n     fn ty_bot(&self, _t: ty::t) -> cres<ty::t> {\n         Ok(ty::mk_bot(self.infcx.tcx))\n     }"}, {"sha": "2c4fd9f01eea534ce939e240944f54c4f954bd7f", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -24,11 +24,6 @@ use std::list;\n use syntax::ast::{Many, Once, extern_fn, m_const, impure_fn, noreturn};\n use syntax::ast::{pure_fn, ret_style, return_val, unsafe_fn};\n \n-pub fn macros() {\n-    // FIXME(#3114): Macro import/export.\n-    include!(\"macros.rs\");\n-}\n-\n pub enum Lub = CombineFields;  // least-upper-bound: common supertype\n \n pub impl Lub {\n@@ -37,7 +32,7 @@ pub impl Lub {\n              -> cres<ty::t> { self.bot_ty(b) } // commutative\n }\n \n-pub impl Combine for Lub {\n+impl Combine for Lub {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"lub\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }"}, {"sha": "e02772d951c556895a3602db073a731fd7372e30", "filename": "src/librustc/middle/typeck/infer/macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-{\n+#[macro_escape];\n \n macro_rules! if_ok(\n     ($inp: expr) => (\n@@ -17,6 +17,5 @@ macro_rules! if_ok(\n             Err(e) => { return Err(e); }\n         }\n     )\n-);\n+)\n \n-}"}, {"sha": "8bb1f2f47e5e4820a037a97690f16e80254e374d", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -277,7 +277,7 @@ use core::result;\n use core::vec;\n use std::list::Nil;\n use std::oldmap::HashMap;\n-use std::oldsmallintmap;\n+use std::smallintmap::SmallIntMap;\n use syntax::ast::{ret_style, purity};\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast::{unsafe_fn, impure_fn, pure_fn, extern_fn};\n@@ -287,6 +287,7 @@ use syntax::codemap;\n use syntax::ast_util;\n use syntax::codemap::span;\n \n+pub mod macros;\n pub mod combine;\n pub mod glb;\n pub mod lattice;\n@@ -353,7 +354,7 @@ pub fn fixup_err_to_str(f: fixup_err) -> ~str {\n \n fn new_ValsAndBindings<V:Copy,T:Copy>() -> ValsAndBindings<V, T> {\n     ValsAndBindings {\n-        vals: oldsmallintmap::mk(),\n+        vals: @mut SmallIntMap::new(),\n         bindings: ~[]\n     }\n }\n@@ -734,10 +735,10 @@ impl @mut InferCtxt {\n \n     fn report_mismatched_types(&self, sp: span, e: ty::t, a: ty::t,\n                                err: &ty::type_err) {\n-        // Don't report an error if expected is ty_err\n         let resolved_expected =\n             self.resolve_type_vars_if_possible(e);\n         let mk_msg = match ty::get(resolved_expected).sty {\n+            // Don't report an error if expected is ty_err\n             ty::ty_err => return,\n             _ => {\n                 // if I leave out : ~str, it infers &str and complains\n@@ -780,4 +781,3 @@ impl @mut InferCtxt {\n     }\n \n }\n-"}, {"sha": "ee598686652522f070565cb2ece010de590fbd4f", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -549,6 +549,7 @@ use syntax::codemap;\n use util::common::indenter;\n use util::ppaux::note_and_explain_region;\n \n+use core::cell::{Cell, empty_cell};\n use core::cmp;\n use core::dvec::DVec;\n use core::to_bytes;\n@@ -557,7 +558,6 @@ use core::vec;\n use result::Result;\n use result::{Ok, Err};\n use std::oldmap::HashMap;\n-use std::cell::{Cell, empty_cell};\n use std::list::{List, Nil, Cons};\n use syntax::codemap::span;\n use syntax::codemap;"}, {"sha": "5552b71d0d771d6bfada7fd8084b77118fa53d59", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -25,14 +25,10 @@ use std::list::Nil;\n use std::list;\n use syntax::ast::{m_const, purity, ret_style};\n \n-pub fn macros() {\n-    // FIXME(#3114): Macro import/export.\n-    include!(\"macros.rs\");\n-}\n \n pub enum Sub = CombineFields;  // \"subtype\", \"subregion\" etc\n \n-pub impl Combine for Sub {\n+impl Combine for Sub {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"sub\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }"}, {"sha": "9b74ac8535148b45738e6ebec74f3ee15f0f9955", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -28,33 +28,33 @@ pub trait InferStr {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str;\n }\n \n-pub impl InferStr for ty::t {\n+impl InferStr for ty::t {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         ty_to_str(cx.tcx, *self)\n     }\n }\n \n-pub impl InferStr for FnSig {\n+impl InferStr for FnSig {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         fmt!(\"(%s) -> %s\",\n              str::connect(self.inputs.map(|a| a.ty.inf_str(cx)), \", \"),\n              self.output.inf_str(cx))\n     }\n }\n \n-pub impl InferStr for ty::mt {\n+impl InferStr for ty::mt {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         mt_to_str(cx.tcx, *self)\n     }\n }\n \n-pub impl InferStr for ty::Region {\n+impl InferStr for ty::Region {\n     fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n         fmt!(\"%?\", *self)\n     }\n }\n \n-pub impl<V:InferStr> InferStr for Bound<V> {\n+impl<V:InferStr> InferStr for Bound<V> {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         match *self {\n           Some(ref v) => v.inf_str(cx),\n@@ -63,15 +63,15 @@ pub impl<V:InferStr> InferStr for Bound<V> {\n     }\n }\n \n-pub impl<T:InferStr> InferStr for Bounds<T> {\n+impl<T:InferStr> InferStr for Bounds<T> {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         fmt!(\"{%s <: %s}\",\n              self.lb.inf_str(cx),\n              self.ub.inf_str(cx))\n     }\n }\n \n-pub impl<V:Vid + ToStr,T:InferStr> InferStr for VarValue<V, T> {\n+impl<V:Vid + ToStr,T:InferStr> InferStr for VarValue<V, T> {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         match *self {\n           Redirect(ref vid) => fmt!(\"Redirect(%s)\", vid.to_str()),\n@@ -81,13 +81,13 @@ pub impl<V:Vid + ToStr,T:InferStr> InferStr for VarValue<V, T> {\n     }\n }\n \n-pub impl InferStr for IntVarValue {\n+impl InferStr for IntVarValue {\n     fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n         self.to_str()\n     }\n }\n \n-pub impl InferStr for ast::float_ty {\n+impl InferStr for ast::float_ty {\n     fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n         self.to_str()\n     }"}, {"sha": "fec3f3d97796239dc7a5a02976cadec7e4f9fc3b", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -10,7 +10,7 @@\n \n use core::prelude::*;\n use core::result;\n-use std::oldsmallintmap::SmallIntMap;\n+use std::smallintmap::SmallIntMap;\n \n use middle::ty::{Vid, expected_found, IntVarValue};\n use middle::ty;\n@@ -27,7 +27,7 @@ pub enum VarValue<V, T> {\n }\n \n pub struct ValsAndBindings<V, T> {\n-    vals: SmallIntMap<VarValue<V, T>>,\n+    vals: @mut SmallIntMap<VarValue<V, T>>,\n     bindings: ~[(V, VarValue<V, T>)],\n }\n \n@@ -64,12 +64,12 @@ pub impl InferCtxt {\n             vid: V) -> Node<V, T>\n         {\n             let vid_u = vid.to_uint();\n-            match vb.vals.find(vid_u) {\n+            match vb.vals.find(&vid_u) {\n                 None => {\n                     tcx.sess.bug(fmt!(\n                         \"failed lookup of vid `%u`\", vid_u));\n                 }\n-                Some(ref var_val) => {\n+                Some(var_val) => {\n                     match *var_val {\n                         Redirect(vid) => {\n                             let node: Node<V,T> = helper(tcx, vb, vid);\n@@ -103,8 +103,8 @@ pub impl InferCtxt {\n \n         { // FIXME(#4903)---borrow checker is not flow sensitive\n             let vb = UnifyVid::appropriate_vals_and_bindings(self);\n-            let old_v = vb.vals.get(vid.to_uint());\n-            vb.bindings.push((vid, old_v));\n+            let old_v = vb.vals.get(&vid.to_uint());\n+            vb.bindings.push((vid, *old_v));\n             vb.vals.insert(vid.to_uint(), new_v);\n         }\n     }\n@@ -237,35 +237,35 @@ pub impl InferCtxt {\n \n // ______________________________________________________________________\n \n-pub impl UnifyVid<Bounds<ty::t>> for ty::TyVid {\n+impl UnifyVid<Bounds<ty::t>> for ty::TyVid {\n     static fn appropriate_vals_and_bindings(&self, infcx: &v/mut InferCtxt)\n         -> &v/mut ValsAndBindings<ty::TyVid, Bounds<ty::t>> {\n         return &mut infcx.ty_var_bindings;\n     }\n }\n \n-pub impl UnifyVid<Option<IntVarValue>> for ty::IntVid {\n+impl UnifyVid<Option<IntVarValue>> for ty::IntVid {\n     static fn appropriate_vals_and_bindings(&self, infcx: &v/mut InferCtxt)\n         -> &v/mut ValsAndBindings<ty::IntVid, Option<IntVarValue>> {\n         return &mut infcx.int_var_bindings;\n     }\n }\n \n-pub impl SimplyUnifiable for IntVarValue {\n+impl SimplyUnifiable for IntVarValue {\n     static fn to_type_err(&self, err: expected_found<IntVarValue>)\n         -> ty::type_err {\n         return ty::terr_int_mismatch(err);\n     }\n }\n \n-pub impl UnifyVid<Option<ast::float_ty>> for ty::FloatVid {\n+impl UnifyVid<Option<ast::float_ty>> for ty::FloatVid {\n     static fn appropriate_vals_and_bindings(&self, infcx: &v/mut InferCtxt)\n         -> &v/mut ValsAndBindings<ty::FloatVid, Option<ast::float_ty>> {\n         return &mut infcx.float_var_bindings;\n     }\n }\n \n-pub impl SimplyUnifiable for ast::float_ty {\n+impl SimplyUnifiable for ast::float_ty {\n     static fn to_type_err(&self, err: expected_found<ast::float_ty>)\n         -> ty::type_err {\n         return ty::terr_float_mismatch(err);"}, {"sha": "de3df62d62cafe4b2d850f49023f70b4ca1f00f8", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -69,7 +69,6 @@ use std::list::{List, Nil, Cons};\n use std::list;\n use std::oldmap::HashMap;\n use std::oldmap;\n-use std::oldsmallintmap;\n use syntax::ast::{provided, required};\n use syntax::ast_map::node_id_to_str;\n use syntax::ast_util::{local_def, split_trait_methods};"}, {"sha": "628cccfa9a22fbdcf5a356d84f2b6ca094c13336", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -26,7 +26,8 @@ pub trait region_scope {\n }\n \n pub enum empty_rscope { empty_rscope }\n-pub impl region_scope for empty_rscope {\n+\n+impl region_scope for empty_rscope {\n     pure fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n         result::Ok(ty::re_static)\n     }\n@@ -40,7 +41,8 @@ pub impl region_scope for empty_rscope {\n }\n \n pub enum type_rscope = Option<ty::region_variance>;\n-pub impl region_scope for type_rscope {\n+\n+impl region_scope for type_rscope {\n     pure fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n         match **self {\n           Some(_) => result::Ok(ty::re_bound(ty::br_self)),\n@@ -74,7 +76,8 @@ pub fn in_anon_rscope<RS:region_scope + Copy + Durable>(self: RS,\n                                                      -> @anon_rscope {\n     @anon_rscope {anon: r, base: self as region_scope}\n }\n-pub impl region_scope for @anon_rscope {\n+\n+impl region_scope for @anon_rscope {\n     pure fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n         result::Ok(self.anon)\n     }\n@@ -97,7 +100,8 @@ pub fn in_binding_rscope<RS:region_scope + Copy + Durable>(self: RS)\n     let base = self as region_scope;\n     @mut binding_rscope { base: base, anon_bindings: 0 }\n }\n-pub impl region_scope for @mut binding_rscope {\n+\n+impl region_scope for @mut binding_rscope {\n     pure fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n         // XXX: Unsafe to work around purity\n         unsafe {"}, {"sha": "5df7ae493baacf4f2961444582b918ebc1ef19c4", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -49,6 +49,7 @@ use back_ = back;\n \n pub mod middle {\n     pub mod trans {\n+        pub mod macros;\n         pub mod inline;\n         pub mod monomorphize;\n         pub mod controlflow;\n@@ -68,6 +69,7 @@ pub mod middle {\n         pub mod meth;\n         pub mod cabi;\n         pub mod cabi_x86_64;\n+        pub mod cabi_arm;\n         pub mod foreign;\n         pub mod reflect;\n         pub mod shape;\n@@ -314,8 +316,8 @@ fails without recording a fatal error then we've encountered a compiler\n bug and need to present an error.\n */\n pub fn monitor(+f: fn~(diagnostic::Emitter)) {\n+    use core::cell::Cell;\n     use core::comm::*;\n-    use std::cell::Cell;\n     let (p, ch) = stream();\n     let ch = SharedChan(ch);\n     let ch_capture = ch.clone();"}, {"sha": "995fdba35cbd75aa4830529746da648fe75fb517", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -238,19 +238,19 @@ pub fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n       ty::vstore_fixed(n) => fmt!(\"%u\", n),\n       ty::vstore_uniq => ~\"~\",\n       ty::vstore_box => ~\"@\",\n-      ty::vstore_slice(r) => region_to_str(cx, r)\n+      ty::vstore_slice(r) => region_to_str_adorned(cx, \"&\", r, \"/\")\n     }\n }\n \n pub fn vstore_ty_to_str(cx: ctxt, ty: ~str, vs: ty::vstore) -> ~str {\n     match vs {\n       ty::vstore_fixed(_) => {\n-        fmt!(\"%s/%s\", ty, vstore_to_str(cx, vs))\n+        fmt!(\"[%s * %s]\", ty, vstore_to_str(cx, vs))\n       }\n       ty::vstore_slice(_) => {\n         fmt!(\"%s/%s\", vstore_to_str(cx, vs), ty)\n       }\n-      _ => fmt!(\"%s%s\", vstore_to_str(cx, vs), ty)\n+      _ => fmt!(\"%s[%s]\", vstore_to_str(cx, vs), ty)\n     }\n }\n \n@@ -453,13 +453,13 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_trait(did, ref substs, vs) => {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path, cx.sess.intr());\n-        let result = parameterized(cx, base, substs.self_r, substs.tps);\n-        vstore_ty_to_str(cx, result, vs)\n+        let ty = parameterized(cx, base, substs.self_r, substs.tps);\n+        fmt!(\"%s%s\", vstore_to_str(cx, vs), ty)\n       }\n       ty_evec(mt, vs) => {\n-        vstore_ty_to_str(cx, fmt!(\"[%s]\", mt_to_str(cx, mt)), vs)\n+        vstore_ty_to_str(cx, fmt!(\"%s\", mt_to_str(cx, mt)), vs)\n       }\n-      ty_estr(vs) => vstore_ty_to_str(cx, ~\"str\", vs),\n+      ty_estr(vs) => fmt!(\"%s%s\", vstore_to_str(cx, vs), ~\"str\"),\n       ty_opaque_box => ~\"@?\",\n       ty_opaque_closure_ptr(ast::BorrowedSigil) => ~\"closure&\",\n       ty_opaque_closure_ptr(ast::ManagedSigil) => ~\"closure@\","}, {"sha": "1c45fdafa189c0757f5fd886e8d4e8c7749f05b9", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -21,8 +21,8 @@ use core::prelude::*;\n \n use parse;\n use util;\n-use std::cell::Cell;\n \n+use core::cell::Cell;\n use core::comm::{stream, Chan, SharedChan, Port};\n use core::vec;\n use core::ops::Drop;"}, {"sha": "0add79266302794cf2b79e2593bf6330e9c1939a", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use core::cell::Cell;\n use core::cmp;\n use core::os;\n use core::result;\n@@ -18,7 +19,6 @@ use core::run::ProgramOutput;\n use core::vec;\n use core::result::Result;\n use std::getopts;\n-use std::cell::Cell;\n \n /// The type of document to output\n pub enum OutputFormat {\n@@ -59,7 +59,7 @@ pub struct Config {\n     pandoc_cmd: Option<~str>\n }\n \n-pub impl Clone for Config {\n+impl Clone for Config {\n     fn clone(&self) -> Config { copy *self }\n }\n "}, {"sha": "f129df3f300c1c09cbc115255371d7d4c30dbd96", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -161,7 +161,7 @@ fn nmoddoc_from_mod(\n           ast::foreign_item_const(*) => {} // XXX: Not implemented.\n         }\n     }\n-    doc:: NmodDoc {\n+    doc::NmodDoc {\n         item: itemdoc,\n         fns: fns,\n         index: None"}, {"sha": "f64f365496d838d935718d041f44c7f1232d7791", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -34,11 +34,11 @@ use sort_pass;\n use trim_pass;\n use unindent_pass;\n \n+use core::cell::Cell;\n use core::iter;\n use core::str;\n use core::vec;\n use std::par;\n-use std::cell::Cell;\n use syntax;\n \n pub fn mk_pass(writer_factory: WriterFactory) -> Pass {"}, {"sha": "83f35418b0b1f062e8dc72e55d91edb51069ef57", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -20,8 +20,8 @@ use fold;\n use pass::Pass;\n use util::NominalOp;\n \n+use core::cell::Cell;\n use std::par;\n-use std::cell::Cell;\n \n pub fn mk_pass(name: ~str, op: @fn(&str) -> ~str) -> Pass {\n     let op = Cell(op);"}, {"sha": "f258e649122bdb17a8d778b3d5e9432bee1a9c73", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -17,6 +17,7 @@ use sync;\n use sync::{Mutex, mutex_with_condvars, RWlock, rwlock_with_condvars};\n \n use core::cast;\n+use core::cell::Cell;\n use core::pipes;\n use core::prelude::*;\n use core::private::{SharedMutableState, shared_mutable_state};\n@@ -532,17 +533,17 @@ mod tests {\n         let arc = ~MutexARC(false);\n         let arc2 = ~arc.clone();\n         let (p,c) = comm::oneshot();\n-        let (c,p) = (~mut Some(c), ~mut Some(p));\n+        let (c,p) = (Cell(c), Cell(p));\n         do task::spawn || {\n             // wait until parent gets in\n-            comm::recv_one(option::swap_unwrap(p));\n+            comm::recv_one(p.take());\n             do arc2.access_cond |state, cond| {\n                 *state = true;\n                 cond.signal();\n             }\n         }\n         do arc.access_cond |state, cond| {\n-            comm::send_one(option::swap_unwrap(c), ());\n+            comm::send_one(c.take(), ());\n             assert !*state;\n             while !*state {\n                 cond.wait();"}, {"sha": "2ee994bdf32b4a27637e8792470626bc5d5b4c0b", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -258,7 +258,7 @@ pub trait ByteChan {\n \n const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\n \n-pub impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n+impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n     fn recv() -> T {\n         match self.try_recv() {\n             Some(val) => val,\n@@ -358,7 +358,7 @@ pub mod flatteners {\n         bogus: ()\n     }\n \n-    pub impl<T:Copy + Owned> Unflattener<T> for PodUnflattener<T> {\n+    impl<T:Copy + Owned> Unflattener<T> for PodUnflattener<T> {\n         fn unflatten(&self, buf: ~[u8]) -> T {\n             assert size_of::<T>() != 0;\n             assert size_of::<T>() == buf.len();\n@@ -368,7 +368,7 @@ pub mod flatteners {\n         }\n     }\n \n-    pub impl<T:Copy + Owned> Flattener<T> for PodFlattener<T> {\n+    impl<T:Copy + Owned> Flattener<T> for PodFlattener<T> {\n         fn flatten(&self, val: T) -> ~[u8] {\n             assert size_of::<T>() != 0;\n             let val: *T = ptr::to_unsafe_ptr(&val);\n@@ -406,14 +406,14 @@ pub mod flatteners {\n         serialize_value: SerializeValue<T>\n     }\n \n-    pub impl<D:Decoder,T:Decodable<D>> Unflattener<T>\n+    impl<D:Decoder,T:Decodable<D>> Unflattener<T>\n             for DeserializingUnflattener<D, T> {\n         fn unflatten(&self, buf: ~[u8]) -> T {\n             (self.deserialize_buffer)(buf)\n         }\n     }\n \n-    pub impl<S:Encoder,T:Encodable<S>> Flattener<T>\n+    impl<S:Encoder,T:Encodable<S>> Flattener<T>\n             for SerializingFlattener<S, T> {\n         fn flatten(&self, val: T) -> ~[u8] {\n             (self.serialize_value)(&val)\n@@ -519,7 +519,7 @@ pub mod bytepipes {\n         writer: W\n     }\n \n-    pub impl<R:Reader> BytePort for ReaderBytePort<R> {\n+    impl<R:Reader> BytePort for ReaderBytePort<R> {\n         fn try_recv(&self, count: uint) -> Option<~[u8]> {\n             let mut left = count;\n             let mut bytes = ~[];\n@@ -541,7 +541,7 @@ pub mod bytepipes {\n         }\n     }\n \n-    pub impl<W:Writer> ByteChan for WriterByteChan<W> {\n+    impl<W:Writer> ByteChan for WriterByteChan<W> {\n         fn send(&self, val: ~[u8]) {\n             self.writer.write(val);\n         }\n@@ -572,7 +572,7 @@ pub mod bytepipes {\n         chan: comm::Chan<~[u8]>\n     }\n \n-    pub impl BytePort for PipeBytePort {\n+    impl BytePort for PipeBytePort {\n         fn try_recv(&self, count: uint) -> Option<~[u8]> {\n             if self.buf.len() >= count {\n                 let mut bytes = ::core::util::replace(&mut self.buf, ~[]);\n@@ -604,7 +604,7 @@ pub mod bytepipes {\n         }\n     }\n \n-    pub impl ByteChan for PipeByteChan {\n+    impl ByteChan for PipeByteChan {\n         fn send(&self, val: ~[u8]) {\n             self.chan.send(val)\n         }"}, {"sha": "7f48466ed0a87a556f36db459aee11a2c868baef", "filename": "src/libstd/future.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -23,6 +23,7 @@\n \n use core::cast::copy_lifetime;\n use core::cast;\n+use core::cell::Cell;\n use core::either::Either;\n use core::option;\n use core::comm::{oneshot, ChanOne, PortOne, send_one, recv_one};\n@@ -103,11 +104,9 @@ pub fn from_port<A:Owned>(port: PortOne<A>) ->\n      * waiting for the result to be received on the port.\n      */\n \n-    let port = ~mut Some(port);\n+    let port = Cell(port);\n     do from_fn || {\n-        let mut port_ = None;\n-        port_ <-> *port;\n-        let port = option::unwrap(port_);\n+        let port = port.take();\n         match recv(port) {\n             oneshot::send(data) => data\n         }\n@@ -136,9 +135,9 @@ pub fn spawn<A:Owned>(blk: fn~() -> A) -> Future<A> {\n \n     let (chan, port) = oneshot::init();\n \n-    let chan = ~mut Some(chan);\n+    let chan = Cell(chan);\n     do task::spawn || {\n-        let chan = option::swap_unwrap(&mut *chan);\n+        let chan = chan.take();\n         send_one(chan, blk());\n     }\n "}, {"sha": "c6e76aa1a688ceaa7cba9d70e0ebc13007df2908", "filename": "src/libstd/json.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -82,7 +82,7 @@ pub fn Encoder(wr: io::Writer) -> Encoder {\n     Encoder { wr: wr }\n }\n \n-pub impl serialize::Encoder for Encoder {\n+impl serialize::Encoder for Encoder {\n     fn emit_nil(&self) { self.wr.write_str(\"null\") }\n \n     fn emit_uint(&self, v: uint) { self.emit_float(v as float); }\n@@ -217,7 +217,7 @@ pub fn PrettyEncoder(wr: io::Writer) -> PrettyEncoder {\n     PrettyEncoder { wr: wr, indent: 0 }\n }\n \n-pub impl serialize::Encoder for PrettyEncoder {\n+impl serialize::Encoder for PrettyEncoder {\n     fn emit_nil(&self) { self.wr.write_str(\"null\") }\n \n     fn emit_uint(&self, v: uint) { self.emit_float(v as float); }\n@@ -323,7 +323,7 @@ pub impl serialize::Encoder for PrettyEncoder {\n     }\n }\n \n-pub impl<S:serialize::Encoder> serialize::Encodable<S> for Json {\n+impl<S:serialize::Encoder> serialize::Encodable<S> for Json {\n     fn encode(&self, s: &S) {\n         match *self {\n             Number(v) => v.encode(s),\n@@ -768,7 +768,7 @@ priv impl Decoder {\n     }\n }\n \n-pub impl serialize::Decoder for Decoder {\n+impl serialize::Decoder for Decoder {\n     fn read_nil(&self) -> () {\n         debug!(\"read_nil\");\n         match *self.pop() {"}, {"sha": "a31309d7980dcde46e70257a1e70eccbcbc80956", "filename": "src/libstd/oldsmallintmap.rs", "status": "removed", "additions": 0, "deletions": 237, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Flibstd%2Foldsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Flibstd%2Foldsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldsmallintmap.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -1,237 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * A simple map based on a vector for small integer keys. Space requirements\n- * are O(highest integer key).\n- */\n-#[forbid(deprecated_mode)];\n-\n-use core::container::{Container, Mutable, Map, Set};\n-use core::dvec::DVec;\n-use core::ops;\n-use core::option::{Some, None};\n-use core::option;\n-use core::prelude::*;\n-\n-// FIXME (#2347): Should not be @; there's a bug somewhere in rustc that\n-// requires this to be.\n-struct SmallIntMap_<T> {\n-    v: DVec<Option<T>>,\n-}\n-\n-pub enum SmallIntMap<T> {\n-    SmallIntMap_(@SmallIntMap_<T>)\n-}\n-\n-/// Create a smallintmap\n-pub fn mk<T:Copy>() -> SmallIntMap<T> {\n-    let v = DVec();\n-    SmallIntMap_(@SmallIntMap_ { v: v } )\n-}\n-\n-/**\n- * Add a value to the map. If the map already contains a value for\n- * the specified key then the original value is replaced.\n- */\n-#[inline(always)]\n-pub fn insert<T:Copy>(self: SmallIntMap<T>, key: uint, val: T) {\n-    //io::println(fmt!(\"%?\", key));\n-    self.v.grow_set_elt(key, &None, Some(val));\n-}\n-\n-/**\n- * Get the value for the specified key. If the key does not exist\n- * in the map then returns none\n- */\n-pub pure fn find<T:Copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n-    if key < self.v.len() { return self.v.get_elt(key); }\n-    return None::<T>;\n-}\n-\n-/**\n- * Get the value for the specified key\n- *\n- * # Failure\n- *\n- * If the key does not exist in the map\n- */\n-pub pure fn get<T:Copy>(self: SmallIntMap<T>, key: uint) -> T {\n-    match find(self, key) {\n-      None => {\n-        error!(\"smallintmap::get(): key not present\");\n-        fail!();\n-      }\n-      Some(v) => return v\n-    }\n-}\n-\n-/// Returns true if the map contains a value for the specified key\n-pub pure fn contains_key<T:Copy>(self: SmallIntMap<T>, key: uint) -> bool {\n-    return !find(self, key).is_none();\n-}\n-\n-impl<V> Container for SmallIntMap<V> {\n-    /// Return the number of elements in the map\n-    pure fn len(&self) -> uint {\n-        let mut sz = 0u;\n-        for self.v.each |item| {\n-            match *item {\n-              Some(_) => sz += 1u,\n-              _ => ()\n-            }\n-        }\n-        sz\n-    }\n-\n-    /// Return true if the map contains no elements\n-    pure fn is_empty(&self) -> bool { self.len() == 0 }\n-}\n-\n-impl<V> Mutable for SmallIntMap<V> {\n-    fn clear(&mut self) { self.v.set(~[]) }\n-}\n-\n-/// Implements the map::map interface for smallintmap\n-impl<V:Copy> SmallIntMap<V> {\n-    #[inline(always)]\n-    fn insert(key: uint, value: V) -> bool {\n-        let exists = contains_key(self, key);\n-        insert(self, key, value);\n-        return !exists;\n-    }\n-    fn remove(key: uint) -> bool {\n-        if key >= self.v.len() {\n-            return false;\n-        }\n-        let old = self.v.get_elt(key);\n-        self.v.set_elt(key, None);\n-        old.is_some()\n-    }\n-    pure fn contains_key(key: uint) -> bool {\n-        contains_key(self, key)\n-    }\n-    pure fn contains_key_ref(key: &uint) -> bool {\n-        contains_key(self, *key)\n-    }\n-    pure fn get(key: uint) -> V { get(self, key) }\n-    pure fn find(key: uint) -> Option<V> { find(self, key) }\n-\n-    fn update_with_key(key: uint, val: V, ff: fn(uint, V, V) -> V) -> bool {\n-        match self.find(key) {\n-            None            => return self.insert(key, val),\n-            Some(copy orig) => return self.insert(key, ff(key, orig, val)),\n-        }\n-    }\n-\n-    fn update(key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n-        return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n-    }\n-\n-    pure fn each(it: fn(key: uint, value: V) -> bool) {\n-        self.each_ref(|k, v| it(*k, *v))\n-    }\n-    pure fn each_key(it: fn(key: uint) -> bool) {\n-        self.each_ref(|k, _v| it(*k))\n-    }\n-    pure fn each_value(it: fn(value: V) -> bool) {\n-        self.each_ref(|_k, v| it(*v))\n-    }\n-    pure fn each_ref(it: fn(key: &uint, value: &V) -> bool) {\n-        let mut idx = 0u, l = self.v.len();\n-        while idx < l {\n-            match self.v.get_elt(idx) {\n-              Some(ref elt) => if !it(&idx, elt) { break },\n-              None => ()\n-            }\n-            idx += 1u;\n-        }\n-    }\n-    pure fn each_key_ref(blk: fn(key: &uint) -> bool) {\n-        self.each_ref(|k, _v| blk(k))\n-    }\n-    pure fn each_value_ref(blk: fn(value: &V) -> bool) {\n-        self.each_ref(|_k, v| blk(v))\n-    }\n-}\n-\n-impl<V:Copy> ops::Index<uint, V> for SmallIntMap<V> {\n-    pure fn index(&self, key: uint) -> V {\n-        unsafe {\n-            get(*self, key)\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::{mk, SmallIntMap};\n-\n-    use core::option::None;\n-\n-    #[test]\n-    fn test_len() {\n-        let mut map = mk();\n-        assert map.len() == 0;\n-        assert map.is_empty();\n-        map.insert(5, 20);\n-        assert map.len() == 1;\n-        assert !map.is_empty();\n-        map.insert(11, 12);\n-        assert map.len() == 2;\n-        assert !map.is_empty();\n-        map.insert(14, 22);\n-        assert map.len() == 3;\n-        assert !map.is_empty();\n-    }\n-\n-    #[test]\n-    fn test_clear() {\n-        let mut map = mk();\n-        map.insert(5, 20);\n-        map.insert(11, 12);\n-        map.insert(14, 22);\n-        map.clear();\n-        assert map.is_empty();\n-        assert map.find(5).is_none();\n-        assert map.find(11).is_none();\n-        assert map.find(14).is_none();\n-    }\n-\n-    #[test]\n-    fn test_insert_with_key() {\n-        let map: SmallIntMap<uint> = mk();\n-\n-        // given a new key, initialize it with this new count, given\n-        // given an existing key, add more to its count\n-        fn addMoreToCount(_k: uint, v0: uint, v1: uint) -> uint {\n-            v0 + v1\n-        }\n-\n-        fn addMoreToCount_simple(v0: uint, v1: uint) -> uint {\n-            v0 + v1\n-        }\n-\n-        // count integers\n-        map.update(3, 1, addMoreToCount_simple);\n-        map.update_with_key(9, 1, addMoreToCount);\n-        map.update(3, 7, addMoreToCount_simple);\n-        map.update_with_key(5, 3, addMoreToCount);\n-        map.update_with_key(3, 2, addMoreToCount);\n-\n-        // check the total counts\n-        assert map.find(3).get() == 10;\n-        assert map.find(5).get() == 3;\n-        assert map.find(9).get() == 1;\n-\n-        // sadly, no sevens were counted\n-        assert None == map.find(7);\n-    }\n-}"}, {"sha": "dd873650b662ee257f6e9f8745962c968e5c5364", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -22,7 +22,7 @@ pub fn Serializer(wr: io::Writer) -> Serializer {\n     Serializer { wr: wr }\n }\n \n-pub impl serialize::Encoder for Serializer {\n+impl serialize::Encoder for Serializer {\n     fn emit_nil(&self) {\n         self.wr.write_str(~\"()\")\n     }"}, {"sha": "66db951e12bde0fda37db39c60582d65897978eb", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 57, "deletions": 59, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -113,210 +113,210 @@ pub trait Decodable<D:Decoder> {\n     static fn decode(&self, d: &D) -> Self;\n }\n \n-pub impl<S:Encoder> Encodable<S> for uint {\n+impl<S:Encoder> Encodable<S> for uint {\n     fn encode(&self, s: &S) { s.emit_uint(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for uint {\n+impl<D:Decoder> Decodable<D> for uint {\n     static fn decode(&self, d: &D) -> uint {\n         d.read_uint()\n     }\n }\n \n-pub impl<S:Encoder> Encodable<S> for u8 {\n+impl<S:Encoder> Encodable<S> for u8 {\n     fn encode(&self, s: &S) { s.emit_u8(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for u8 {\n+impl<D:Decoder> Decodable<D> for u8 {\n     static fn decode(&self, d: &D) -> u8 {\n         d.read_u8()\n     }\n }\n \n-pub impl<S:Encoder> Encodable<S> for u16 {\n+impl<S:Encoder> Encodable<S> for u16 {\n     fn encode(&self, s: &S) { s.emit_u16(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for u16 {\n+impl<D:Decoder> Decodable<D> for u16 {\n     static fn decode(&self, d: &D) -> u16 {\n         d.read_u16()\n     }\n }\n \n-pub impl<S:Encoder> Encodable<S> for u32 {\n+impl<S:Encoder> Encodable<S> for u32 {\n     fn encode(&self, s: &S) { s.emit_u32(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for u32 {\n+impl<D:Decoder> Decodable<D> for u32 {\n     static fn decode(&self, d: &D) -> u32 {\n         d.read_u32()\n     }\n }\n \n-pub impl<S:Encoder> Encodable<S> for u64 {\n+impl<S:Encoder> Encodable<S> for u64 {\n     fn encode(&self, s: &S) { s.emit_u64(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for u64 {\n+impl<D:Decoder> Decodable<D> for u64 {\n     static fn decode(&self, d: &D) -> u64 {\n         d.read_u64()\n     }\n }\n \n-pub impl<S:Encoder> Encodable<S> for int {\n+impl<S:Encoder> Encodable<S> for int {\n     fn encode(&self, s: &S) { s.emit_int(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for int {\n+impl<D:Decoder> Decodable<D> for int {\n     static fn decode(&self, d: &D) -> int {\n         d.read_int()\n     }\n }\n \n-pub impl<S:Encoder> Encodable<S> for i8 {\n+impl<S:Encoder> Encodable<S> for i8 {\n     fn encode(&self, s: &S) { s.emit_i8(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for i8 {\n+impl<D:Decoder> Decodable<D> for i8 {\n     static fn decode(&self, d: &D) -> i8 {\n         d.read_i8()\n     }\n }\n \n-pub impl<S:Encoder> Encodable<S> for i16 {\n+impl<S:Encoder> Encodable<S> for i16 {\n     fn encode(&self, s: &S) { s.emit_i16(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for i16 {\n+impl<D:Decoder> Decodable<D> for i16 {\n     static fn decode(&self, d: &D) -> i16 {\n         d.read_i16()\n     }\n }\n \n-pub impl<S:Encoder> Encodable<S> for i32 {\n+impl<S:Encoder> Encodable<S> for i32 {\n     fn encode(&self, s: &S) { s.emit_i32(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for i32 {\n+impl<D:Decoder> Decodable<D> for i32 {\n     static fn decode(&self, d: &D) -> i32 {\n         d.read_i32()\n     }\n }\n \n-pub impl<S:Encoder> Encodable<S> for i64 {\n+impl<S:Encoder> Encodable<S> for i64 {\n     fn encode(&self, s: &S) { s.emit_i64(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for i64 {\n+impl<D:Decoder> Decodable<D> for i64 {\n     static fn decode(&self, d: &D) -> i64 {\n         d.read_i64()\n     }\n }\n \n-pub impl<S:Encoder> Encodable<S> for &str {\n+impl<S:Encoder> Encodable<S> for &str {\n     fn encode(&self, s: &S) { s.emit_borrowed_str(*self) }\n }\n \n-pub impl<S:Encoder> Encodable<S> for ~str {\n+impl<S:Encoder> Encodable<S> for ~str {\n     fn encode(&self, s: &S) { s.emit_owned_str(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for ~str {\n+impl<D:Decoder> Decodable<D> for ~str {\n     static fn decode(&self, d: &D) -> ~str {\n         d.read_owned_str()\n     }\n }\n \n-pub impl<S:Encoder> Encodable<S> for @str {\n+impl<S:Encoder> Encodable<S> for @str {\n     fn encode(&self, s: &S) { s.emit_managed_str(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for @str {\n+impl<D:Decoder> Decodable<D> for @str {\n     static fn decode(&self, d: &D) -> @str {\n         d.read_managed_str()\n     }\n }\n \n-pub impl<S:Encoder> Encodable<S> for float {\n+impl<S:Encoder> Encodable<S> for float {\n     fn encode(&self, s: &S) { s.emit_float(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for float {\n+impl<D:Decoder> Decodable<D> for float {\n     static fn decode(&self, d: &D) -> float {\n         d.read_float()\n     }\n }\n \n-pub impl<S:Encoder> Encodable<S> for f32 {\n+impl<S:Encoder> Encodable<S> for f32 {\n     fn encode(&self, s: &S) { s.emit_f32(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for f32 {\n+impl<D:Decoder> Decodable<D> for f32 {\n     static fn decode(&self, d: &D) -> f32 {\n         d.read_f32() }\n }\n \n-pub impl<S:Encoder> Encodable<S> for f64 {\n+impl<S:Encoder> Encodable<S> for f64 {\n     fn encode(&self, s: &S) { s.emit_f64(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for f64 {\n+impl<D:Decoder> Decodable<D> for f64 {\n     static fn decode(&self, d: &D) -> f64 {\n         d.read_f64()\n     }\n }\n \n-pub impl<S:Encoder> Encodable<S> for bool {\n+impl<S:Encoder> Encodable<S> for bool {\n     fn encode(&self, s: &S) { s.emit_bool(*self) }\n }\n \n-pub impl<D:Decoder> Decodable<D> for bool {\n+impl<D:Decoder> Decodable<D> for bool {\n     static fn decode(&self, d: &D) -> bool {\n         d.read_bool()\n     }\n }\n \n-pub impl<S:Encoder> Encodable<S> for () {\n+impl<S:Encoder> Encodable<S> for () {\n     fn encode(&self, s: &S) { s.emit_nil() }\n }\n \n-pub impl<D:Decoder> Decodable<D> for () {\n+impl<D:Decoder> Decodable<D> for () {\n     static fn decode(&self, d: &D) -> () {\n         d.read_nil()\n     }\n }\n \n-pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for &T {\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for &T {\n     fn encode(&self, s: &S) {\n         s.emit_borrowed(|| (**self).encode(s))\n     }\n }\n \n-pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~T {\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~T {\n     fn encode(&self, s: &S) {\n         s.emit_owned(|| (**self).encode(s))\n     }\n }\n \n-pub impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~T {\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~T {\n     static fn decode(&self, d: &D) -> ~T {\n         d.read_owned(|| ~Decodable::decode(d))\n     }\n }\n \n-pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for @T {\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for @T {\n     fn encode(&self, s: &S) {\n         s.emit_managed(|| (**self).encode(s))\n     }\n }\n \n-pub impl<D:Decoder,T:Decodable<D>> Decodable<D> for @T {\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for @T {\n     static fn decode(&self, d: &D) -> @T {\n         d.read_managed(|| @Decodable::decode(d))\n     }\n }\n \n-pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for &[T] {\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for &[T] {\n     fn encode(&self, s: &S) {\n         do s.emit_borrowed_vec(self.len()) {\n             for self.eachi |i, e| {\n@@ -326,7 +326,7 @@ pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for &[T] {\n     }\n }\n \n-pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n     fn encode(&self, s: &S) {\n         do s.emit_owned_vec(self.len()) {\n             for self.eachi |i, e| {\n@@ -336,7 +336,7 @@ pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n     }\n }\n \n-pub impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n     static fn decode(&self, d: &D) -> ~[T] {\n         do d.read_owned_vec |len| {\n             do vec::from_fn(len) |i| {\n@@ -346,7 +346,7 @@ pub impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n     }\n }\n \n-pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n     fn encode(&self, s: &S) {\n         do s.emit_managed_vec(self.len()) {\n             for self.eachi |i, e| {\n@@ -356,7 +356,7 @@ pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n     }\n }\n \n-pub impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n     static fn decode(&self, d: &D) -> @[T] {\n         do d.read_managed_vec |len| {\n             do at_vec::from_fn(len) |i| {\n@@ -366,7 +366,7 @@ pub impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n     }\n }\n \n-pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n     fn encode(&self, s: &S) {\n         do s.emit_enum(~\"option\") {\n             match *self {\n@@ -381,7 +381,7 @@ pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n     }\n }\n \n-pub impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n     static fn decode(&self, d: &D) -> Option<T> {\n         do d.read_enum(~\"option\") {\n             do d.read_enum_variant |i| {\n@@ -396,8 +396,7 @@ pub impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n     }\n }\n \n-pub impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S>\n-        for (T0, T1) {\n+impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n     fn encode(&self, s: &S) {\n         match *self {\n             (ref t0, ref t1) => {\n@@ -410,8 +409,7 @@ pub impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S>\n     }\n }\n \n-pub impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D>\n-        for (T0, T1) {\n+impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n     static fn decode(&self, d: &D) -> (T0, T1) {\n         do d.read_tup(2) {\n             (\n@@ -422,7 +420,7 @@ pub impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D>\n     }\n }\n \n-pub impl<\n+impl<\n     S: Encoder,\n     T0: Encodable<S>,\n     T1: Encodable<S>,\n@@ -441,7 +439,7 @@ pub impl<\n     }\n }\n \n-pub impl<\n+impl<\n     D: Decoder,\n     T0: Decodable<D>,\n     T1: Decodable<D>,\n@@ -458,7 +456,7 @@ pub impl<\n     }\n }\n \n-pub impl<\n+impl<\n     S: Encoder,\n     T0: Encodable<S>,\n     T1: Encodable<S>,\n@@ -479,7 +477,7 @@ pub impl<\n     }\n }\n \n-pub impl<\n+impl<\n     D: Decoder,\n     T0: Decodable<D>,\n     T1: Decodable<D>,\n@@ -498,7 +496,7 @@ pub impl<\n     }\n }\n \n-pub impl<\n+impl<\n     S: Encoder,\n     T0: Encodable<S>,\n     T1: Encodable<S>,\n@@ -521,7 +519,7 @@ pub impl<\n     }\n }\n \n-pub impl<\n+impl<\n     D: Decoder,\n     T0: Decodable<D>,\n     T1: Decodable<D>,\n@@ -552,7 +550,7 @@ pub trait EncoderHelpers {\n     fn emit_from_vec<T>(&self, v: &[T], f: fn(v: &T));\n }\n \n-pub impl<S:Encoder> EncoderHelpers for S {\n+impl<S:Encoder> EncoderHelpers for S {\n     fn emit_from_vec<T>(&self, v: &[T], f: fn(v: &T)) {\n         do self.emit_owned_vec(v.len()) {\n             for v.eachi |i, e| {\n@@ -568,7 +566,7 @@ pub trait DecoderHelpers {\n     fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n }\n \n-pub impl<D:Decoder> DecoderHelpers for D {\n+impl<D:Decoder> DecoderHelpers for D {\n     fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n         do self.read_owned_vec |len| {\n             do vec::from_fn(len) |i| {"}, {"sha": "75f38da5a19a1730f45e050eafa0afc05d7f6221", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -455,8 +455,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                 base2: uint, len2: uint) {\n         assert len1 != 0 && len2 != 0 && base1+len1 == base2;\n \n-        let tmp = vec::cast_to_mut(\n-            vec::slice(array, base1, base1+len1).to_vec());\n+        let mut tmp = vec::slice(array, base1, base1+len1).to_vec();\n \n         let mut c1 = 0;\n         let mut c2 = base2;\n@@ -559,8 +558,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                 base2: uint, len2: uint) {\n         assert len1 != 1 && len2 != 0 && base1 + len1 == base2;\n \n-        let tmp = vec::cast_to_mut(\n-            vec::slice(array, base2, base2+len2).to_vec());\n+        let mut tmp = vec::slice(array, base2, base2+len2).to_vec();\n \n         let mut c1 = base1 + len1 - 1;\n         let mut c2 = len2 - 1;"}, {"sha": "7dafdec95e07267fea0fa2d55f4dd22e1942867c", "filename": "src/libstd/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstats.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -52,7 +52,7 @@ impl Stats for &[f64] {\n \n     fn median(self) -> f64 {\n         assert self.len() != 0;\n-        let tmp = vec::cast_to_mut(vec::from_slice(self));\n+        let mut tmp = vec::from_slice(self);\n         sort::tim_sort(tmp);\n         if tmp.len() & 1 == 0 {\n             let m = tmp.len() / 2;"}, {"sha": "854abfdd112e67d99b4d1ffca0e0aab0cbfa2f52", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -29,6 +29,7 @@ not required in or otherwise suitable for the core library.\n #[allow(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n #[allow(deprecated_self)];\n+#[allow(deprecated_mutable_fields)];\n \n #[no_core];\n \n@@ -53,7 +54,6 @@ pub mod uv_global_loop;\n \n pub mod c_vec;\n pub mod timer;\n-pub mod cell;\n pub mod io_util;\n \n // Concurrency\n@@ -75,7 +75,6 @@ pub mod oldmap;\n pub mod priority_queue;\n pub mod rope;\n pub mod smallintmap;\n-pub mod oldsmallintmap;\n pub mod sort;\n pub mod treemap;\n "}, {"sha": "1ff51e8bff0307d09a9f5f94cf71467fa16e1dde", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -15,6 +15,7 @@\n  * in std.\n  */\n \n+use core::cell::Cell;\n use core::option;\n use core::pipes;\n use core::prelude::*;\n@@ -799,9 +800,9 @@ mod tests {\n             let s = ~semaphore(1);\n             let s2 = ~s.clone();\n             let (p,c) = comm::stream();\n-            let child_data = ~mut Some((s2, c));\n+            let child_data = Cell((s2, c));\n             do s.access {\n-                let (s2,c) = option::swap_unwrap(child_data);\n+                let (s2, c) = child_data.take();\n                 do task::spawn || {\n                     c.send(());\n                     do s2.access { }\n@@ -976,13 +977,13 @@ mod tests {\n             let mut sibling_convos = ~[];\n             for 2.times {\n                 let (p,c) = comm::stream();\n-                let c = ~mut Some(c);\n+                let c = Cell(c);\n                 sibling_convos.push(p);\n                 let mi = ~m2.clone();\n                 // spawn sibling task\n-                do task::spawn || { // linked\n+                do task::spawn { // linked\n                     do mi.lock_cond |cond| {\n-                        let c = option::swap_unwrap(c);\n+                        let c = c.take();\n                         c.send(()); // tell sibling to go ahead\n                         let _z = SendOnFailure(c);\n                         cond.wait(); // block forever"}, {"sha": "bfeaf8400bc4487908b8190916bc0b9c57ea491a", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -377,7 +377,7 @@ pub fn run_tests_console(opts: &TestOpts,\n \n fn print_failures(st: @ConsoleTestState) {\n     st.out.write_line(~\"\\nfailures:\");\n-    let failures = vec::cast_to_mut(st.failures.map(|t| t.name.to_str()));\n+    let mut failures = st.failures.map(|t| t.name.to_str());\n     sort::tim_sort(failures);\n     for vec::each(failures) |name| {\n         st.out.write_line(fmt!(\"    %s\", name.to_str()));"}, {"sha": "c8379d3ef4444fa95e4f4bfd8d1209ba31a1485f", "filename": "src/libstd/time.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -842,7 +842,7 @@ priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n           //'U' {}\n           'u' => {\n             let i = tm.tm_wday as int;\n-            int::str(if i == 0 { 7 } else { i })\n+            int::to_str(if i == 0 { 7 } else { i })\n           }\n           //'V' {}\n           'v' => {\n@@ -852,10 +852,10 @@ priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n                 parse_type('Y', tm))\n           }\n           //'W' {}\n-          'w' => int::str(tm.tm_wday as int),\n+          'w' => int::to_str(tm.tm_wday as int),\n           //'X' {}\n           //'x' {}\n-          'Y' => int::str(tm.tm_year as int + 1900),\n+          'Y' => int::to_str(tm.tm_year as int + 1900),\n           'y' => fmt!(\"%02d\", (tm.tm_year as int + 1900) % 100),\n           'Z' => copy tm.tm_zone,\n           'z' => {\n@@ -902,15 +902,15 @@ mod tests {\n         const some_future_date: i64 = 1577836800i64; // 2020-01-01T00:00:00Z\n \n         let tv1 = get_time();\n-        log(debug, ~\"tv1=\" + uint::str(tv1.sec as uint) + ~\" sec + \"\n-                   + uint::str(tv1.nsec as uint) + ~\" nsec\");\n+        log(debug, ~\"tv1=\" + uint::to_str(tv1.sec as uint) + ~\" sec + \"\n+                   + uint::to_str(tv1.nsec as uint) + ~\" nsec\");\n \n         assert tv1.sec > some_recent_date;\n         assert tv1.nsec < 1000000000i32;\n \n         let tv2 = get_time();\n-        log(debug, ~\"tv2=\" + uint::str(tv2.sec as uint) + ~\" sec + \"\n-                   + uint::str(tv2.nsec as uint) + ~\" nsec\");\n+        log(debug, ~\"tv2=\" + uint::to_str(tv2.sec as uint) + ~\" sec + \"\n+                   + uint::to_str(tv2.nsec as uint) + ~\" nsec\");\n \n         assert tv2.sec >= tv1.sec;\n         assert tv2.sec < some_future_date;\n@@ -927,13 +927,13 @@ mod tests {\n         log(debug, ~\"s0=\" + float::to_str_digits(s0, 9u) + ~\" sec\");\n         assert s0 > 0.;\n         let ns0 = (s0 * 1000000000.) as u64;\n-        log(debug, ~\"ns0=\" + u64::str(ns0) + ~\" ns\");\n+        log(debug, ~\"ns0=\" + u64::to_str(ns0) + ~\" ns\");\n \n-        log(debug, ~\"ns1=\" + u64::str(ns1) + ~\" ns\");\n+        log(debug, ~\"ns1=\" + u64::to_str(ns1) + ~\" ns\");\n         assert ns1 >= ns0;\n \n         let ns2 = precise_time_ns();\n-        log(debug, ~\"ns2=\" + u64::str(ns2) + ~\" ns\");\n+        log(debug, ~\"ns2=\" + u64::to_str(ns2) + ~\" ns\");\n         assert ns2 >= ns1;\n     }\n "}, {"sha": "0e593ba42d12951ac6ebe5f9f1facbf95ed4f725", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 93, "deletions": 113, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -48,13 +48,8 @@ impl<K:Eq + Ord,V:Eq> Eq for TreeMap<K, V> {\n             let mut y = other.iter();\n             for self.len().times {\n                 unsafe { // unsafe as a purity workaround\n-                    map_next(&mut x);\n-                    map_next(&mut y);\n-                    // FIXME: #4492 (ICE), x.get() == y.get()\n-                    let (x1, x2) = x.get().unwrap();\n-                    let (y1, y2) = y.get().unwrap();\n-\n-                    if x1 != y1 || x2 != y2 {\n+                    if map_next(&mut x).unwrap() !=\n+                       map_next(&mut y).unwrap() {\n                         return false\n                     }\n                 }\n@@ -73,10 +68,8 @@ pure fn lt<K:Ord,V>(a: &TreeMap<K, V>, b: &TreeMap<K, V>) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     for uint::min(a_len, b_len).times {\n         unsafe { // purity workaround\n-            map_next(&mut x);\n-            map_next(&mut y);\n-            let (key_a,_) = x.get().unwrap();\n-            let (key_b,_) = y.get().unwrap();\n+            let (key_a,_) = map_next(&mut x).unwrap();\n+            let (key_b,_) = map_next(&mut y).unwrap();\n             if *key_a < *key_b { return true; }\n             if *key_a > *key_b { return false; }\n         }\n@@ -201,30 +194,21 @@ impl <K:Ord,V> TreeMap<K, V> {\n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n     pure fn iter(&self) -> TreeMapIterator/&self<K, V> {\n-        TreeMapIterator{stack: ~[], node: &self.root, current: None}\n+        TreeMapIterator{stack: ~[], node: &self.root}\n     }\n }\n \n /// Lazy forward iterator over a map\n pub struct TreeMapIterator<K, V> {\n     priv stack: ~[&~TreeNode<K, V>],\n-    priv node: &Option<~TreeNode<K, V>>,\n-    priv current: Option<&~TreeNode<K, V>>\n+    priv node: &Option<~TreeNode<K, V>>\n }\n \n-impl <K:Ord,V> TreeMapIterator<K, V> {\n-    // Returns the current node, or None if this iterator is at the end.\n-    fn get(&const self) -> Option<(&self/K, &self/V)> {\n-        match self.current {\n-          Some(res) => Some((&res.key, &res.value)),\n-          None => None\n-        }\n-    }\n-}\n-\n-/// Advance the iterator to the next node (in order). If this iterator\n-/// is finished, does nothing.\n-pub fn map_next<K:Ord,V>(iter: &mut TreeMapIterator/&a<K, V>) {\n+/// Advance the iterator to the next node (in order) and return a\n+/// tuple with a reference to the key and value. If there are no\n+/// more nodes, return `None`.\n+fn map_next<K: Ord, V>(iter: &mut TreeMapIterator/&r<K, V>)\n+ -> Option<(&r/K, &r/V)> {\n     while !iter.stack.is_empty() || iter.node.is_some() {\n         match *iter.node {\n           Some(ref x) => {\n@@ -234,12 +218,24 @@ pub fn map_next<K:Ord,V>(iter: &mut TreeMapIterator/&a<K, V>) {\n           None => {\n             let res = iter.stack.pop();\n             iter.node = &res.right;\n-            iter.current = Some(res);\n-            return;\n+            return Some((&res.key, &res.value));\n           }\n         }\n     }\n-    iter.current = None;\n+    None\n+}\n+\n+/// Advance the iterator through the map\n+fn map_advance<K: Ord, V>(iter: &mut TreeMapIterator/&r<K, V>,\n+                          f: fn((&r/K, &r/V)) -> bool) {\n+    loop {\n+        match map_next(iter) {\n+          Some(x) => {\n+            if !f(x) { return }\n+          }\n+          None => return\n+        }\n+    }\n }\n \n pub struct TreeSet<T> {\n@@ -308,19 +304,15 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n-            set_next(&mut x);\n-            set_next(&mut y);\n-            let mut a = x.get();\n-            let mut b = y.get();\n+            let mut a = set_next(&mut x);\n+            let mut b = set_next(&mut y);\n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n                 if a1 < b1 {\n-                    set_next(&mut x);\n-                    a = x.get();\n+                    a = set_next(&mut x);\n                 } else if b1 < a1 {\n-                    set_next(&mut y);\n-                    b = y.get();\n+                    b = set_next(&mut y);\n                 } else {\n                     return false;\n                 }\n@@ -339,10 +331,8 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n-            set_next(&mut x);\n-            set_next(&mut y);\n-            let mut a = x.get();\n-            let mut b = y.get();\n+            let mut a = set_next(&mut x);\n+            let mut b = set_next(&mut y);\n             while b.is_some() {\n                 if a.is_none() {\n                     return false\n@@ -356,11 +346,9 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n                 }\n \n                 if !(a1 < b1) {\n-                    set_next(&mut y);\n-                    b = y.get();\n+                    b = set_next(&mut y);\n                 }\n-                set_next(&mut x);\n-                a = x.get();\n+                a = set_next(&mut x);\n             }\n         }\n         true\n@@ -372,15 +360,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            set_next(&mut x);\n-            set_next(&mut y);\n-            let mut a = x.get();\n-            let mut b = y.get();\n+            let mut a = set_next(&mut x);\n+            let mut b = set_next(&mut y);\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { set_next(&mut x); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x) } else { None }\n                     }\n                 }\n \n@@ -389,12 +375,10 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n-                    set_next(&mut x);\n-                    a = x.get();\n+                    a = set_next(&mut x);\n                 } else {\n-                    if !(b1 < a1) { set_next(&mut x); a = x.get() }\n-                    set_next(&mut y);\n-                    b = y.get();\n+                    if !(b1 < a1) { a = set_next(&mut x) }\n+                    b = set_next(&mut y);\n                 }\n             }\n         }\n@@ -407,15 +391,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            set_next(&mut x);\n-            set_next(&mut y);\n-            let mut a = x.get();\n-            let mut b = y.get();\n+            let mut a = set_next(&mut x);\n+            let mut b = set_next(&mut y);\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { set_next(&mut x); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x) } else { None }\n                     }\n                 }\n \n@@ -424,21 +406,18 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n-                    set_next(&mut x);\n-                    a = x.get();\n+                    a = set_next(&mut x);\n                 } else {\n                     if b1 < a1 {\n                         if !f(b1) { return }\n                     } else {\n-                        set_next(&mut x);\n-                        a = x.get();\n+                        a = set_next(&mut x);\n                     }\n-                    set_next(&mut y);\n-                    b = y.get();\n+                    b = set_next(&mut y);\n                 }\n             }\n             do b.while_some |b1| {\n-                if f(b1) { set_next(&mut y); y.get() } else { None }\n+                if f(b1) { set_next(&mut y) } else { None }\n             }\n         }\n     }\n@@ -449,23 +428,19 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            set_next(&mut x);\n-            set_next(&mut y);\n-            let mut a = x.get();\n-            let mut b = y.get();\n+            let mut a = set_next(&mut x);\n+            let mut b = set_next(&mut y);\n \n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n                 if a1 < b1 {\n-                    set_next(&mut x);\n-                    a = x.get();\n+                    a = set_next(&mut x);\n                 } else {\n                     if !(b1 < a1) {\n                         if !f(a1) { return }\n                     }\n-                    set_next(&mut y);\n-                    b = y.get();\n+                    b = set_next(&mut y);\n                 }\n             }\n         }\n@@ -477,15 +452,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            set_next(&mut x);\n-            set_next(&mut y);\n-            let mut a = x.get();\n-            let mut b = y.get();\n+            let mut a = set_next(&mut x);\n+            let mut b = set_next(&mut y);\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { set_next(&mut x); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x) } else { None }\n                     }\n                 }\n \n@@ -494,16 +467,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n \n                 if b1 < a1 {\n                     if !f(b1) { return }\n-                    set_next(&mut y);\n-                    b = y.get();\n+                    b = set_next(&mut y);\n                 } else {\n                     if !f(a1) { return }\n                     if !(a1 < b1) {\n-                        set_next(&mut y);\n-                        b = y.get()\n+                        b = set_next(&mut y);\n                     }\n-                    set_next(&mut x);\n-                    a = x.get();\n+                    a = set_next(&mut x);\n                 }\n             }\n         }\n@@ -526,20 +496,16 @@ pub struct TreeSetIterator<T> {\n     priv iter: TreeMapIterator<T, ()>\n }\n \n-impl <T:Ord> TreeSetIterator<T> {\n-    /// Returns the current node, or None if this iterator is at the end.\n-    fn get(&const self) -> Option<&self/T> {\n-        match self.iter.get() {\n-          None => None,\n-          Some((k, _)) => Some(k)\n-        }\n-    }\n-}\n-\n /// Advance the iterator to the next node (in order). If this iterator is\n /// finished, does nothing.\n-pub fn set_next<T:Ord>(iter: &mut TreeSetIterator/&a<T>) {\n-    map_next(&mut iter.iter);\n+pub fn set_next<T: Ord>(iter: &mut TreeSetIterator/&r<T>) -> Option<&r/T> {\n+    do map_next(&mut iter.iter).map |&(value, _)| { value }\n+}\n+\n+/// Advance the iterator through the set\n+fn set_advance<T: Ord>(iter: &mut TreeSetIterator/&r<T>,\n+                       f: fn(&r/T) -> bool) {\n+    do map_advance(&mut iter.iter) |(k, _)| { f(k) }\n }\n \n // Nodes keep track of their level in the tree, starting at 1 in the\n@@ -983,23 +949,37 @@ mod test_treemap {\n         assert m.insert(x5, y5);\n \n         let m = m;\n-        let mut iter = m.iter();\n+        let mut a = m.iter();\n \n         // FIXME: #4492 (ICE): iter.get() == Some((&x1, &y1))\n \n-        map_next(&mut iter);\n-        assert iter.get().unwrap() == (&x1, &y1);\n-        map_next(&mut iter);\n-        assert iter.get().unwrap() == (&x2, &y2);\n-        map_next(&mut iter);\n-        assert iter.get().unwrap() == (&x3, &y3);\n-        map_next(&mut iter);\n-        assert iter.get().unwrap() == (&x4, &y4);\n-        map_next(&mut iter);\n-        assert iter.get().unwrap() == (&x5, &y5);\n-\n-        map_next(&mut iter);\n-        assert iter.get().is_none();\n+        assert map_next(&mut a).unwrap() == (&x1, &y1);\n+        assert map_next(&mut a).unwrap() == (&x2, &y2);\n+        assert map_next(&mut a).unwrap() == (&x3, &y3);\n+        assert map_next(&mut a).unwrap() == (&x4, &y4);\n+        assert map_next(&mut a).unwrap() == (&x5, &y5);\n+\n+        assert map_next(&mut a).is_none();\n+\n+        let mut b = m.iter();\n+\n+        let expected = [(&x1, &y1), (&x2, &y2), (&x3, &y3), (&x4, &y4),\n+                        (&x5, &y5)];\n+        let mut i = 0;\n+\n+        for map_advance(&mut b) |x| {\n+            assert expected[i] == x;\n+            i += 1;\n+\n+            if i == 2 {\n+                break\n+            }\n+        }\n+\n+        for map_advance(&mut b) |x| {\n+            assert expected[i] == x;\n+            i += 1;\n+        }\n     }\n }\n "}, {"sha": "c85aa78d9834a9df6a3982b7439e4801b6f9d6fa", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -15,6 +15,7 @@ use sha1;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n use sort;\n \n+use core::cell::Cell;\n use core::cmp;\n use core::either::{Either, Left, Right};\n use core::io;\n@@ -139,7 +140,7 @@ impl WorkKey {\n \n type WorkMap = LinearMap<WorkKey, ~str>;\n \n-pub impl<S:Encoder> Encodable<S> for WorkMap {\n+impl<S:Encoder> Encodable<S> for WorkMap {\n     fn encode(&self, s: &S) {\n         let mut d = ~[];\n         for self.each |&(k, v)| {\n@@ -150,7 +151,7 @@ pub impl<S:Encoder> Encodable<S> for WorkMap {\n     }\n }\n \n-pub impl<D:Decoder> Decodable<D> for WorkMap {\n+impl<D:Decoder> Decodable<D> for WorkMap {\n     static fn decode(&self, d: &D) -> WorkMap {\n         let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n         let mut w = LinearMap::new();\n@@ -339,11 +340,11 @@ impl TPrep for @Mut<Prep> {\n                     let mut blk = None;\n                     blk <-> bo;\n                     let blk = blk.unwrap();\n-                    let chan = ~mut Some(chan);\n+                    let chan = Cell(chan);\n                     do task::spawn || {\n                         let exe = Exec{discovered_inputs: LinearMap::new(),\n                                        discovered_outputs: LinearMap::new()};\n-                        let chan = option::swap_unwrap(&mut *chan);\n+                        let chan = chan.take();\n                         let v = blk(&exe);\n                         send_one(chan, (exe, v));\n                     }"}, {"sha": "d99dcd53c39c20ee3becbd69062dfe244b5a65dc", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 55, "deletions": 25, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -29,10 +29,39 @@ macro_rules! interner_key (\n         (-3 as uint, 0u)))\n )\n \n+// an identifier contains an index into the interner\n+// table and a SyntaxContext to track renaming and\n+// macro expansion per Flatt et al., \"Macros\n+// That Work Together\"\n #[deriving_eq]\n-pub struct ident { repr: uint }\n+pub struct ident { repr: Name }\n \n-pub impl<S:Encoder> Encodable<S> for ident {\n+// a SyntaxContext represents a chain of macro-expandings\n+// and renamings. Each macro expansion corresponds to\n+// a fresh uint\n+#[deriving_eq]\n+pub enum SyntaxContext {\n+    MT,\n+    Mark (Mrk,~SyntaxContext),\n+    Rename (~ident,Name,~SyntaxContext)\n+}\n+\n+/*\n+// ** this is going to have to apply to paths, not to idents.\n+// Returns true if these two identifiers access the same\n+// local binding or top-level binding... that's what it\n+// should do. For now, it just compares the names.\n+pub fn free_ident_eq (a : ident, b: ident) -> bool{\n+    a.repr == b.repr\n+}\n+*/\n+// a name represents a string, interned\n+type Name = uint;\n+// a mark represents a unique id associated\n+// with a macro expansion\n+type Mrk = uint;\n+\n+impl<S:Encoder> Encodable<S> for ident {\n     fn encode(&self, s: &S) {\n         let intr = match unsafe {\n             task::local_data::local_data_get(interner_key!())\n@@ -45,7 +74,7 @@ pub impl<S:Encoder> Encodable<S> for ident {\n     }\n }\n \n-pub impl<D:Decoder> Decodable<D> for ident {\n+impl<D:Decoder> Decodable<D> for ident {\n     static fn decode(d: &D) -> ident {\n         let intr = match unsafe {\n             task::local_data::local_data_get(interner_key!())\n@@ -58,7 +87,7 @@ pub impl<D:Decoder> Decodable<D> for ident {\n     }\n }\n \n-pub impl to_bytes::IterBytes for ident {\n+impl to_bytes::IterBytes for ident {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.repr.iter_bytes(lsb0, f)\n     }\n@@ -217,7 +246,7 @@ pub enum binding_mode {\n     bind_infer\n }\n \n-pub impl to_bytes::IterBytes for binding_mode {\n+impl to_bytes::IterBytes for binding_mode {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           bind_by_copy => 0u8.iter_bytes(lsb0, f),\n@@ -262,7 +291,7 @@ pub enum pat_ {\n #[deriving_eq]\n pub enum mutability { m_mutbl, m_imm, m_const, }\n \n-pub impl to_bytes::IterBytes for mutability {\n+impl to_bytes::IterBytes for mutability {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n@@ -275,13 +304,13 @@ pub enum Abi {\n     RustAbi\n }\n \n-pub impl to_bytes::IterBytes for Abi {\n+impl to_bytes::IterBytes for Abi {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n \n-pub impl ToStr for Abi {\n+impl ToStr for Abi {\n     pure fn to_str(&self) -> ~str {\n         match *self {\n             RustAbi => ~\"\\\"rust\\\"\"\n@@ -298,13 +327,13 @@ pub enum Sigil {\n     ManagedSigil\n }\n \n-pub impl to_bytes::IterBytes for Sigil {\n+impl to_bytes::IterBytes for Sigil {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n \n-pub impl ToStr for Sigil {\n+impl ToStr for Sigil {\n     pure fn to_str(&self) -> ~str {\n         match *self {\n             BorrowedSigil => ~\"&\",\n@@ -383,7 +412,7 @@ pub enum inferable<T> {\n     infer(node_id)\n }\n \n-pub impl<T:to_bytes::IterBytes> to_bytes::IterBytes for inferable<T> {\n+impl<T:to_bytes::IterBytes> to_bytes::IterBytes for inferable<T> {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           expl(ref t) =>\n@@ -401,7 +430,7 @@ pub impl<T:to_bytes::IterBytes> to_bytes::IterBytes for inferable<T> {\n #[deriving_eq]\n pub enum rmode { by_ref, by_val, by_copy }\n \n-pub impl to_bytes::IterBytes for rmode {\n+impl to_bytes::IterBytes for rmode {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n@@ -742,13 +771,13 @@ pub enum trait_method {\n #[deriving_eq]\n pub enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n-pub impl ToStr for int_ty {\n+impl ToStr for int_ty {\n     pure fn to_str(&self) -> ~str {\n         ::ast_util::int_ty_to_str(*self)\n     }\n }\n \n-pub impl to_bytes::IterBytes for int_ty {\n+impl to_bytes::IterBytes for int_ty {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n@@ -759,13 +788,13 @@ pub impl to_bytes::IterBytes for int_ty {\n #[deriving_eq]\n pub enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n-pub impl ToStr for uint_ty {\n+impl ToStr for uint_ty {\n     pure fn to_str(&self) -> ~str {\n         ::ast_util::uint_ty_to_str(*self)\n     }\n }\n \n-pub impl to_bytes::IterBytes for uint_ty {\n+impl to_bytes::IterBytes for uint_ty {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n@@ -776,13 +805,13 @@ pub impl to_bytes::IterBytes for uint_ty {\n #[deriving_eq]\n pub enum float_ty { ty_f, ty_f32, ty_f64, }\n \n-pub impl ToStr for float_ty {\n+impl ToStr for float_ty {\n     pure fn to_str(&self) -> ~str {\n         ::ast_util::float_ty_to_str(*self)\n     }\n }\n \n-pub impl to_bytes::IterBytes for float_ty {\n+impl to_bytes::IterBytes for float_ty {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n@@ -836,7 +865,7 @@ pub enum Onceness {\n     Many\n }\n \n-pub impl ToStr for Onceness {\n+impl ToStr for Onceness {\n     pure fn to_str(&self) -> ~str {\n         match *self {\n             Once => ~\"once\",\n@@ -845,7 +874,7 @@ pub impl ToStr for Onceness {\n     }\n }\n \n-pub impl to_bytes::IterBytes for Onceness {\n+impl to_bytes::IterBytes for Onceness {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n@@ -895,7 +924,7 @@ pub enum ty_ {\n     ty_infer,\n }\n \n-pub impl to_bytes::IterBytes for Ty {\n+impl to_bytes::IterBytes for Ty {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n     }\n@@ -931,7 +960,7 @@ pub enum purity {\n     extern_fn, // declared with \"extern fn\"\n }\n \n-pub impl ToStr for purity {\n+impl ToStr for purity {\n     pure fn to_str(&self) -> ~str {\n         match *self {\n             impure_fn => ~\"impure\",\n@@ -942,7 +971,7 @@ pub impl ToStr for purity {\n     }\n }\n \n-pub impl to_bytes::IterBytes for purity {\n+impl to_bytes::IterBytes for purity {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n@@ -957,7 +986,7 @@ pub enum ret_style {\n     return_val, // everything else\n }\n \n-pub impl to_bytes::IterBytes for ret_style {\n+impl to_bytes::IterBytes for ret_style {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n@@ -1230,6 +1259,7 @@ pub enum item_ {\n               Option<@trait_ref>, // (optional) trait this impl implements\n               @Ty, // self\n               ~[@method]),\n+    // a macro invocation (which includes macro definition)\n     item_mac(mac),\n }\n \n@@ -1238,7 +1268,7 @@ pub enum item_ {\n #[deriving_eq]\n pub enum struct_mutability { struct_mutable, struct_immutable }\n \n-pub impl to_bytes::IterBytes for struct_mutability {\n+impl to_bytes::IterBytes for struct_mutability {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }"}, {"sha": "c1ca329335d5b88a1101f04b831bc0e25245424f", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -34,7 +34,7 @@ pub enum path_elt {\n     path_name(ident)\n }\n \n-pub impl cmp::Eq for path_elt {\n+impl cmp::Eq for path_elt {\n     pure fn eq(&self, other: &path_elt) -> bool {\n         match (*self) {\n             path_mod(e0a) => {"}, {"sha": "2eac626c2e6461007685f28b959a9aaa2aea3b02", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -198,7 +198,7 @@ pub pure fn is_call_expr(e: @expr) -> bool {\n }\n \n // This makes def_id hashable\n-pub impl to_bytes::IterBytes for def_id {\n+impl to_bytes::IterBytes for def_id {\n     #[inline(always)]\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f);\n@@ -303,7 +303,7 @@ pub trait inlined_item_utils {\n     fn accept<E>(&self, e: E, v: visit::vt<E>);\n }\n \n-pub impl inlined_item_utils for inlined_item {\n+impl inlined_item_utils for inlined_item {\n     fn ident(&self) -> ident {\n         match *self {\n             ii_item(i) => /* FIXME (#2543) */ copy i.ident,"}, {"sha": "65711d9894a73b576e04a9071aee883cc99ecb70", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -46,71 +46,71 @@ pub enum CharPos = uint;\n // XXX: Lots of boilerplate in these impls, but so far my attempts to fix\n // have been unsuccessful\n \n-pub impl Pos for BytePos {\n+impl Pos for BytePos {\n     static pure fn from_uint(n: uint) -> BytePos { BytePos(n) }\n     pure fn to_uint(&self) -> uint { **self }\n }\n \n-pub impl cmp::Eq for BytePos {\n+impl cmp::Eq for BytePos {\n     pure fn eq(&self, other: &BytePos) -> bool { **self == **other }\n     pure fn ne(&self, other: &BytePos) -> bool { !(*self).eq(other) }\n }\n \n-pub impl cmp::Ord for BytePos {\n+impl cmp::Ord for BytePos {\n     pure fn lt(&self, other: &BytePos) -> bool { **self < **other }\n     pure fn le(&self, other: &BytePos) -> bool { **self <= **other }\n     pure fn ge(&self, other: &BytePos) -> bool { **self >= **other }\n     pure fn gt(&self, other: &BytePos) -> bool { **self > **other }\n }\n \n-pub impl Add<BytePos, BytePos> for BytePos {\n+impl Add<BytePos, BytePos> for BytePos {\n     pure fn add(&self, rhs: &BytePos) -> BytePos {\n         BytePos(**self + **rhs)\n     }\n }\n \n-pub impl Sub<BytePos, BytePos> for BytePos {\n+impl Sub<BytePos, BytePos> for BytePos {\n     pure fn sub(&self, rhs: &BytePos) -> BytePos {\n         BytePos(**self - **rhs)\n     }\n }\n \n-pub impl to_bytes::IterBytes for BytePos {\n+impl to_bytes::IterBytes for BytePos {\n     pure fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n-pub impl Pos for CharPos {\n+impl Pos for CharPos {\n     static pure fn from_uint(n: uint) -> CharPos { CharPos(n) }\n     pure fn to_uint(&self) -> uint { **self }\n }\n \n-pub impl cmp::Eq for CharPos {\n+impl cmp::Eq for CharPos {\n     pure fn eq(&self, other: &CharPos) -> bool { **self == **other }\n     pure fn ne(&self, other: &CharPos) -> bool { !(*self).eq(other) }\n }\n \n-pub impl cmp::Ord for CharPos {\n+impl cmp::Ord for CharPos {\n     pure fn lt(&self, other: &CharPos) -> bool { **self < **other }\n     pure fn le(&self, other: &CharPos) -> bool { **self <= **other }\n     pure fn ge(&self, other: &CharPos) -> bool { **self >= **other }\n     pure fn gt(&self, other: &CharPos) -> bool { **self > **other }\n }\n \n-pub impl to_bytes::IterBytes for CharPos {\n+impl to_bytes::IterBytes for CharPos {\n     pure fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n-pub impl Add<CharPos,CharPos> for CharPos {\n+impl Add<CharPos,CharPos> for CharPos {\n     pure fn add(&self, rhs: &CharPos) -> CharPos {\n         CharPos(**self + **rhs)\n     }\n }\n \n-pub impl Sub<CharPos,CharPos> for CharPos {\n+impl Sub<CharPos,CharPos> for CharPos {\n     pure fn sub(&self, rhs: &CharPos) -> CharPos {\n         CharPos(**self - **rhs)\n     }\n@@ -133,19 +133,19 @@ pub struct span {\n #[deriving_eq]\n pub struct spanned<T> { node: T, span: span }\n \n-pub impl cmp::Eq for span {\n+impl cmp::Eq for span {\n     pure fn eq(&self, other: &span) -> bool {\n         return (*self).lo == (*other).lo && (*self).hi == (*other).hi;\n     }\n     pure fn ne(&self, other: &span) -> bool { !(*self).eq(other) }\n }\n \n-pub impl<S:Encoder> Encodable<S> for span {\n+impl<S:Encoder> Encodable<S> for span {\n     /* Note #1972 -- spans are encoded but not decoded */\n     fn encode(&self, _s: &S) { }\n }\n \n-pub impl<D:Decoder> Decodable<D> for span {\n+impl<D:Decoder> Decodable<D> for span {\n     static fn decode(_d: &D) -> span {\n         dummy_sp()\n     }"}, {"sha": "2addd365ff91e2c973711552b3517c85987025c8", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -1188,12 +1188,14 @@ mod test {\n         CallToEmitEnumVariantArg(uint),\n         CallToEmitUint(uint),\n         CallToEmitNil,\n+        CallToEmitStruct(~str,uint),\n+        CallToEmitField(~str,uint),\n         // all of the ones I was too lazy to handle:\n         CallToOther\n     }\n-    // using a mutable field rather than changing the\n+    // using `@mut` rather than changing the\n     // type of self in every method of every encoder everywhere.\n-    pub struct TestEncoder {mut call_log : ~[call]}\n+    pub struct TestEncoder {call_log : @mut ~[call]}\n \n     pub impl TestEncoder {\n         // these self's should be &mut self's, as well....\n@@ -1205,7 +1207,7 @@ mod test {\n         }\n     }\n \n-    pub impl Encoder for TestEncoder {\n+    impl Encoder for TestEncoder {\n         fn emit_nil(&self) { self.add_to_log(CallToEmitNil) }\n \n         fn emit_uint(&self, +v: uint) {self.add_to_log(CallToEmitUint(v)); }\n@@ -1266,11 +1268,11 @@ mod test {\n         fn emit_rec(&self, f: fn()) {\n             self.add_unknown_to_log(); f();\n         }\n-        fn emit_struct(&self, _name: &str, +_len: uint, f: fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_struct(&self, name: &str, +len: uint, f: fn()) {\n+            self.add_to_log(CallToEmitStruct (name.to_str(),len)); f();\n         }\n-        fn emit_field(&self, _name: &str, +_idx: uint, f: fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_field(&self, name: &str, +idx: uint, f: fn()) {\n+            self.add_to_log(CallToEmitField (name.to_str(),idx)); f();\n         }\n \n         fn emit_tup(&self, +_len: uint, f: fn()) {\n@@ -1282,23 +1284,12 @@ mod test {\n     }\n \n \n-    #[auto_decode]\n-    #[auto_encode]\n-    struct Node {id: uint}\n-\n     fn to_call_log (val: Encodable<TestEncoder>) -> ~[call] {\n-        let mut te = TestEncoder {call_log: ~[]};\n+        let mut te = TestEncoder {call_log: @mut ~[]};\n         val.encode(&te);\n-        te.call_log\n-    }\n-/*\n-    #[test] fn encode_test () {\n-        check_equal (to_call_log(Node{id:34}\n-                                 as Encodable::<std::json::Encoder>),\n-                     ~[CallToEnum (~\"Node\"),\n-                       CallToEnumVariant]);\n+        copy *te.call_log\n     }\n-*/\n+\n     #[auto_encode]\n     enum Written {\n         Book(uint,uint),\n@@ -1315,4 +1306,17 @@ mod test {\n                        CallToEmitEnumVariantArg (1),\n                        CallToEmitUint (44)]);\n         }\n+\n+    pub enum BPos = uint;\n+\n+    #[auto_encode]\n+    pub struct HasPos { pos : BPos }\n+\n+    #[test] fn encode_newtype_test () {\n+        check_equal (to_call_log (HasPos {pos:BPos(48)}\n+                                 as Encodable::<TestEncoder>),\n+                    ~[CallToEmitStruct(~\"HasPos\",1),\n+                      CallToEmitField(~\"pos\",0),\n+                      CallToEmitUint(48)]);\n+    }\n }"}, {"sha": "f5a7bbddf99b4495927606f8f4807bd2d0b37335", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 197, "deletions": 24, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -21,12 +21,12 @@ use parse::{parser, token};\n \n use core::io;\n use core::vec;\n-use std::oldmap::HashMap;\n+use core::hashmap::linear::LinearMap;\n \n // new-style macro! tt code:\n //\n //    SyntaxExpanderTT, SyntaxExpanderTTItem, MacResult,\n-//    NormalTT, ItemTT\n+//    NormalTT, IdentTT\n //\n // also note that ast::mac used to have a bunch of extraneous cases and\n // is now probably a redundant AST node, can be merged with\n@@ -71,36 +71,66 @@ pub enum SyntaxExtension {\n     // Token-tree expanders\n     NormalTT(SyntaxExpanderTT),\n \n+    // An IdentTT is a macro that has an\n+    // identifier in between the name of the\n+    // macro and the argument. Currently,\n+    // the only examples of this are\n+    // macro_rules! and proto!\n+\n     // perhaps macro_rules! will lose its odd special identifier argument,\n     // and this can go away also\n-    ItemTT(SyntaxExpanderTTItem),\n+    IdentTT(SyntaxExpanderTTItem),\n }\n \n-type SyntaxExtensions = HashMap<@~str, SyntaxExtension>;\n+type SyntaxEnv = @mut MapChain<Name, Transformer>;\n+\n+// Name : the domain of SyntaxEnvs\n+// want to change these to uints....\n+// note that we use certain strings that are not legal as identifiers\n+// to indicate, for instance, how blocks are supposed to behave.\n+type Name = @~str;\n+\n+// Transformer : the codomain of SyntaxEnvs\n+\n+// NB: it may seem crazy to lump both of these into one environment;\n+// what would it mean to bind \"foo\" to BlockLimit(true)? The idea\n+// is that this follows the lead of MTWT, and accommodates growth\n+// toward a more uniform syntax syntax (sorry) where blocks are just\n+// another kind of transformer.\n+\n+enum Transformer {\n+    // this identifier maps to a syntax extension or macro\n+    SE(SyntaxExtension),\n+    // should blocks occurring here limit macro scopes?\n+    ScopeMacros(bool)\n+}\n \n-// A temporary hard-coded map of methods for expanding syntax extension\n+// The base map of methods for expanding syntax extension\n // AST nodes into full ASTs\n-pub fn syntax_expander_table() -> SyntaxExtensions {\n+pub fn syntax_expander_table() -> SyntaxEnv {\n     // utility function to simplify creating NormalTT syntax extensions\n-    fn builtin_normal_tt(f: SyntaxExpanderTTFun) -> SyntaxExtension {\n-        NormalTT(SyntaxExpanderTT{expander: f, span: None})\n+    fn builtin_normal_tt(f: SyntaxExpanderTTFun) -> @Transformer {\n+        @SE(NormalTT(SyntaxExpanderTT{expander: f, span: None}))\n     }\n-    // utility function to simplify creating ItemTT syntax extensions\n-    fn builtin_item_tt(f: SyntaxExpanderTTItemFun) -> SyntaxExtension {\n-        ItemTT(SyntaxExpanderTTItem{expander: f, span: None})\n+    // utility function to simplify creating IdentTT syntax extensions\n+    fn builtin_item_tt(f: SyntaxExpanderTTItemFun) -> @Transformer {\n+        @SE(IdentTT(SyntaxExpanderTTItem{expander: f, span: None}))\n     }\n-    let syntax_expanders = HashMap();\n+    let mut syntax_expanders = LinearMap::new();\n+    // NB identifier starts with space, and can't conflict with legal idents\n+    syntax_expanders.insert(@~\" block\",\n+                            @ScopeMacros(true));\n     syntax_expanders.insert(@~\"macro_rules\",\n                             builtin_item_tt(\n                                 ext::tt::macro_rules::add_new_extension));\n     syntax_expanders.insert(@~\"fmt\",\n                             builtin_normal_tt(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(\n         @~\"auto_encode\",\n-        ItemDecorator(ext::auto_encode::expand_auto_encode));\n+        @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));\n     syntax_expanders.insert(\n         @~\"auto_decode\",\n-        ItemDecorator(ext::auto_encode::expand_auto_decode));\n+        @SE(ItemDecorator(ext::auto_encode::expand_auto_decode)));\n     syntax_expanders.insert(@~\"env\",\n                             builtin_normal_tt(ext::env::expand_syntax_ext));\n     syntax_expanders.insert(@~\"concat_idents\",\n@@ -110,25 +140,25 @@ pub fn syntax_expander_table() -> SyntaxExtensions {\n                             builtin_normal_tt(\n                                 ext::log_syntax::expand_syntax_ext));\n     syntax_expanders.insert(@~\"deriving_eq\",\n-                            ItemDecorator(\n-                                ext::deriving::expand_deriving_eq));\n+                            @SE(ItemDecorator(\n+                                ext::deriving::expand_deriving_eq)));\n     syntax_expanders.insert(@~\"deriving_iter_bytes\",\n-                            ItemDecorator(\n-                                ext::deriving::expand_deriving_iter_bytes));\n+                            @SE(ItemDecorator(\n+                                ext::deriving::expand_deriving_iter_bytes)));\n \n     // Quasi-quoting expanders\n     syntax_expanders.insert(@~\"quote_tokens\",\n                        builtin_normal_tt(ext::quote::expand_quote_tokens));\n     syntax_expanders.insert(@~\"quote_expr\",\n-                            builtin_normal_tt(ext::quote::expand_quote_expr));\n+                       builtin_normal_tt(ext::quote::expand_quote_expr));\n     syntax_expanders.insert(@~\"quote_ty\",\n-                            builtin_normal_tt(ext::quote::expand_quote_ty));\n+                       builtin_normal_tt(ext::quote::expand_quote_ty));\n     syntax_expanders.insert(@~\"quote_item\",\n-                            builtin_normal_tt(ext::quote::expand_quote_item));\n+                       builtin_normal_tt(ext::quote::expand_quote_item));\n     syntax_expanders.insert(@~\"quote_pat\",\n-                            builtin_normal_tt(ext::quote::expand_quote_pat));\n+                       builtin_normal_tt(ext::quote::expand_quote_pat));\n     syntax_expanders.insert(@~\"quote_stmt\",\n-                            builtin_normal_tt(ext::quote::expand_quote_stmt));\n+                       builtin_normal_tt(ext::quote::expand_quote_stmt));\n \n     syntax_expanders.insert(@~\"line\",\n                             builtin_normal_tt(\n@@ -159,7 +189,7 @@ pub fn syntax_expander_table() -> SyntaxExtensions {\n     syntax_expanders.insert(\n         @~\"trace_macros\",\n         builtin_normal_tt(ext::trace_macros::expand_trace_macros));\n-    return syntax_expanders;\n+    MapChain::new(~syntax_expanders)\n }\n \n // One of these is made during expansion and incrementally updated as we go;\n@@ -347,6 +377,149 @@ pub fn get_exprs_from_tts(cx: ext_ctxt, tts: &[ast::token_tree])\n     es\n }\n \n+// in order to have some notion of scoping for macros,\n+// we want to implement the notion of a transformation\n+// environment.\n+\n+// This environment maps Names to Transformers.\n+// Initially, this includes macro definitions and\n+// block directives.\n+\n+\n+\n+// Actually, the following implementation is parameterized\n+// by both key and value types.\n+\n+//impl question: how to implement it? Initially, the\n+// env will contain only macros, so it might be painful\n+// to add an empty frame for every context. Let's just\n+// get it working, first....\n+\n+// NB! the mutability of the underlying maps means that\n+// if expansion is out-of-order, a deeper scope may be\n+// able to refer to a macro that was added to an enclosing\n+// scope lexically later than the deeper scope.\n+\n+// Note on choice of representation: I've been pushed to\n+// use a top-level managed pointer by some difficulties\n+// with pushing and popping functionally, and the ownership\n+// issues.  As a result, the values returned by the table\n+// also need to be managed; the &self/... type that Maps\n+// return won't work for things that need to get outside\n+// of that managed pointer.  The easiest way to do this\n+// is just to insist that the values in the tables are\n+// managed to begin with.\n+\n+// a transformer env is either a base map or a map on top\n+// of another chain.\n+pub enum MapChain<K,V> {\n+    BaseMapChain(~LinearMap<K,@V>),\n+    ConsMapChain(~LinearMap<K,@V>,@mut MapChain<K,V>)\n+}\n+\n+\n+// get the map from an env frame\n+impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n+\n+    // Constructor. I don't think we need a zero-arg one.\n+    static fn new(+init: ~LinearMap<K,@V>) -> @mut MapChain<K,V> {\n+        @mut BaseMapChain(init)\n+    }\n+\n+    // add a new frame to the environment (functionally)\n+    fn push_frame (@mut self) -> @mut MapChain<K,V> {\n+        @mut ConsMapChain(~LinearMap::new() ,self)\n+    }\n+\n+// no need for pop, it'll just be functional.\n+\n+    // utility fn...\n+\n+    // ugh: can't get this to compile with mut because of the\n+    // lack of flow sensitivity.\n+    fn get_map(&self) -> &self/LinearMap<K,@V> {\n+        match *self {\n+            BaseMapChain (~ref map) => map,\n+            ConsMapChain (~ref map,_) => map\n+        }\n+    }\n+\n+// traits just don't work anywhere...?\n+//pub impl Map<Name,SyntaxExtension> for MapChain {\n+\n+    pure fn contains_key (&self, key: &K) -> bool {\n+        match *self {\n+            BaseMapChain (ref map) => map.contains_key(key),\n+            ConsMapChain (ref map,ref rest) =>\n+            (map.contains_key(key)\n+             || rest.contains_key(key))\n+        }\n+    }\n+    // should each_key and each_value operate on shadowed\n+    // names? I think not.\n+    // delaying implementing this....\n+    pure fn each_key (&self, _f: &fn (&K)->bool) {\n+        fail!(~\"unimplemented 2013-02-15T10:01\");\n+    }\n+\n+    pure fn each_value (&self, _f: &fn (&V) -> bool) {\n+        fail!(~\"unimplemented 2013-02-15T10:02\");\n+    }\n+\n+    // Returns a copy of the value that the name maps to.\n+    // Goes down the chain 'til it finds one (or bottom out).\n+    fn find (&self, key: &K) -> Option<@V> {\n+        match self.get_map().find (key) {\n+            Some(ref v) => Some(**v),\n+            None => match *self {\n+                BaseMapChain (_) => None,\n+                ConsMapChain (_,ref rest) => rest.find(key)\n+            }\n+        }\n+    }\n+\n+    // insert the binding into the top-level map\n+    fn insert (&mut self, +key: K, +ext: @V) -> bool {\n+        // can't abstract over get_map because of flow sensitivity...\n+        match *self {\n+            BaseMapChain (~ref mut map) => map.insert(key, ext),\n+            ConsMapChain (~ref mut map,_) => map.insert(key,ext)\n+        }\n+    }\n+\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use super::MapChain;\n+    use util::testing::check_equal;\n+\n+    #[test] fn testenv () {\n+        let mut a = LinearMap::new();\n+        a.insert (@~\"abc\",@15);\n+        let m = MapChain::new(~a);\n+        m.insert (@~\"def\",@16);\n+        // FIXME: #4492 (ICE)  check_equal(m.find(&@~\"abc\"),Some(@15));\n+        //  ....               check_equal(m.find(&@~\"def\"),Some(@16));\n+        check_equal(*(m.find(&@~\"abc\").get()),15);\n+        check_equal(*(m.find(&@~\"def\").get()),16);\n+        let n = m.push_frame();\n+        // old bindings are still present:\n+        check_equal(*(n.find(&@~\"abc\").get()),15);\n+        check_equal(*(n.find(&@~\"def\").get()),16);\n+        n.insert (@~\"def\",@17);\n+        // n shows the new binding\n+        check_equal(*(n.find(&@~\"abc\").get()),15);\n+        check_equal(*(n.find(&@~\"def\").get()),17);\n+        // ... but m still has the old ones\n+        // FIXME: #4492: check_equal(m.find(&@~\"abc\"),Some(@15));\n+        // FIXME: #4492: check_equal(m.find(&@~\"def\"),Some(@16));\n+        check_equal(*(m.find(&@~\"abc\").get()),15);\n+        check_equal(*(m.find(&@~\"def\").get()),16);\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "14f4cd5c19f9237045b3f0efbe74042500c0ff77", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 269, "deletions": 49, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -17,13 +17,13 @@ use attr;\n use codemap::{span, CallInfo, ExpandedFrom, NameAndSpan};\n use ext::base::*;\n use fold::*;\n-use parse::{parser, parse_expr_from_source_str, new_parser_from_tts};\n+use parse::{parser, parse_item_from_source_str, new_parser_from_tts};\n \n use core::option;\n use core::vec;\n-use std::oldmap::HashMap;\n+use core::hashmap::LinearMap;\n \n-pub fn expand_expr(exts: SyntaxExtensions, cx: ext_ctxt,\n+pub fn expand_expr(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n                    e: &expr_, s: span, fld: ast_fold,\n                    orig: fn@(&expr_, span, ast_fold) -> (expr_, span))\n                 -> (expr_, span) {\n@@ -39,16 +39,17 @@ pub fn expand_expr(exts: SyntaxExtensions, cx: ext_ctxt,\n                     /* using idents and token::special_idents would make the\n                     the macro names be hygienic */\n                     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-                    match exts.find(&extname) {\n+                    // leaving explicit deref here to highlight unbox op:\n+                    match (*extsbox).find(&extname) {\n                         None => {\n                             cx.span_fatal(\n                                 pth.span,\n                                 fmt!(\"macro undefined: '%s'\", *extname))\n                         }\n-                        Some(NormalTT(SyntaxExpanderTT{\n+                        Some(@SE(NormalTT(SyntaxExpanderTT{\n                             expander: exp,\n                             span: exp_sp\n-                        })) => {\n+                        }))) => {\n                             cx.bt_push(ExpandedFrom(CallInfo {\n                                 call_site: s,\n                                 callee: NameAndSpan {\n@@ -101,7 +102,7 @@ pub fn expand_expr(exts: SyntaxExtensions, cx: ext_ctxt,\n //\n // NB: there is some redundancy between this and expand_item, below, and\n // they might benefit from some amount of semantic and language-UI merger.\n-pub fn expand_mod_items(exts: SyntaxExtensions, cx: ext_ctxt,\n+pub fn expand_mod_items(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n                         module_: &ast::_mod, fld: ast_fold,\n                         orig: fn@(&ast::_mod, ast_fold) -> ast::_mod)\n                      -> ast::_mod {\n@@ -115,9 +116,8 @@ pub fn expand_mod_items(exts: SyntaxExtensions, cx: ext_ctxt,\n         do vec::foldr(item.attrs, ~[*item]) |attr, items| {\n             let mname = attr::get_attr_name(attr);\n \n-            match exts.find(&mname) {\n-              None | Some(NormalTT(_)) | Some(ItemTT(*)) => items,\n-              Some(ItemDecorator(dec_fn)) => {\n+            match (*extsbox).find(&mname) {\n+              Some(@SE(ItemDecorator(dec_fn))) => {\n                   cx.bt_push(ExpandedFrom(CallInfo {\n                       call_site: attr.span,\n                       callee: NameAndSpan {\n@@ -128,7 +128,8 @@ pub fn expand_mod_items(exts: SyntaxExtensions, cx: ext_ctxt,\n                   let r = dec_fn(cx, attr.span, attr.node.value, items);\n                   cx.bt_pop();\n                   r\n-              }\n+              },\n+              _ => items,\n             }\n         }\n     };\n@@ -137,34 +138,94 @@ pub fn expand_mod_items(exts: SyntaxExtensions, cx: ext_ctxt,\n }\n \n \n+// eval $e with a new exts frame:\n+macro_rules! with_exts_frame (\n+    ($extsboxexpr:expr,$e:expr) =>\n+    ({let extsbox = $extsboxexpr;\n+      let oldexts = *extsbox;\n+      *extsbox = oldexts.push_frame();\n+      let result = $e;\n+      *extsbox = oldexts;\n+      result\n+     })\n+)\n+\n // When we enter a module, record it, for the sake of `module!`\n-pub fn expand_item(exts: SyntaxExtensions,\n+pub fn expand_item(extsbox: @mut SyntaxEnv,\n                    cx: ext_ctxt, it: @ast::item, fld: ast_fold,\n                    orig: fn@(@ast::item, ast_fold) -> Option<@ast::item>)\n                 -> Option<@ast::item> {\n-    let is_mod = match it.node {\n-      ast::item_mod(_) | ast::item_foreign_mod(_) => true,\n-      _ => false\n-    };\n+    // need to do expansion first... it might turn out to be a module.\n     let maybe_it = match it.node {\n-      ast::item_mac(*) => expand_item_mac(exts, cx, it, fld),\n+      ast::item_mac(*) => expand_item_mac(extsbox, cx, it, fld),\n       _ => Some(it)\n     };\n-\n     match maybe_it {\n       Some(it) => {\n-        if is_mod { cx.mod_push(it.ident); }\n-        let ret_val = orig(it, fld);\n-        if is_mod { cx.mod_pop(); }\n-        return ret_val;\n+          match it.node {\n+              ast::item_mod(_) | ast::item_foreign_mod(_) => {\n+                  cx.mod_push(it.ident);\n+                  let result =\n+                      // don't push a macro scope for macro_escape:\n+                      if contains_macro_escape(it.attrs) {\n+                      orig(it,fld)\n+                  } else {\n+                      // otherwise, push a scope:\n+                      with_exts_frame!(extsbox,orig(it,fld))\n+                  };\n+                  cx.mod_pop();\n+                  result\n+              }\n+              _ => orig(it,fld)\n+          }\n       }\n-      None => return None\n+      None => None\n     }\n }\n \n+// does this attribute list contain \"macro_escape\" ?\n+fn contains_macro_escape (attrs: &[ast::attribute]) -> bool{\n+    let mut accum = false;\n+    do attrs.each |attr| {\n+        let mname = attr::get_attr_name(attr);\n+        if (mname == @~\"macro_escape\") {\n+            accum = true;\n+            false\n+        } else {\n+            true\n+        }\n+    }\n+    accum\n+}\n+\n+// this macro disables (one layer of) macro\n+// scoping, to allow a block to add macro bindings\n+// to its parent env\n+macro_rules! without_macro_scoping(\n+    ($extsexpr:expr,$exp:expr) =>\n+    ({\n+        // only evaluate this once:\n+        let exts = $extsexpr;\n+        // capture the existing binding:\n+        let existingBlockBinding =\n+            match exts.find(&@~\" block\"){\n+                Some(binding) => binding,\n+                None => cx.bug(\"expected to find \\\" block\\\" binding\")\n+            };\n+        // this prevents the block from limiting the macros' scope:\n+        exts.insert(@~\" block\",@ScopeMacros(false));\n+        let result = $exp;\n+        // reset the block binding. Note that since the original\n+        // one may have been inherited, this procedure may wind\n+        // up introducing a block binding where one didn't exist\n+        // before.\n+        exts.insert(@~\" block\",existingBlockBinding);\n+        result\n+    }))\n+\n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(exts: SyntaxExtensions,\n+pub fn expand_item_mac(+extsbox: @mut SyntaxEnv,\n                        cx: ext_ctxt, &&it: @ast::item,\n                        fld: ast_fold) -> Option<@ast::item> {\n \n@@ -176,11 +237,11 @@ pub fn expand_item_mac(exts: SyntaxExtensions,\n     };\n \n     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-    let expanded = match exts.find(&extname) {\n+    let expanded = match (*extsbox).find(&extname) {\n         None => cx.span_fatal(pth.span,\n                               fmt!(\"macro undefined: '%s!'\", *extname)),\n \n-        Some(NormalTT(ref expand)) => {\n+        Some(@SE(NormalTT(ref expand))) => {\n             if it.ident != parse::token::special_idents::invalid {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects no ident argument, \\\n@@ -196,7 +257,7 @@ pub fn expand_item_mac(exts: SyntaxExtensions,\n             }));\n             ((*expand).expander)(cx, it.span, tts)\n         }\n-        Some(ItemTT(ref expand)) => {\n+        Some(@SE(IdentTT(ref expand))) => {\n             if it.ident == parse::token::special_idents::invalid {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects an ident argument\",\n@@ -223,15 +284,16 @@ pub fn expand_item_mac(exts: SyntaxExtensions,\n         MRAny(_, item_maker, _) =>\n             option::chain(item_maker(), |i| {fld.fold_item(i)}),\n         MRDef(ref mdef) => {\n-            exts.insert(@/*bad*/ copy mdef.name, (*mdef).ext);\n+            extsbox.insert(@/*bad*/ copy mdef.name, @SE((*mdef).ext));\n             None\n         }\n     };\n     cx.bt_pop();\n     return maybe_it;\n }\n \n-pub fn expand_stmt(exts: SyntaxExtensions, cx: ext_ctxt,\n+// expand a stmt\n+pub fn expand_stmt(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n                    s: &stmt_, sp: span, fld: ast_fold,\n                    orig: fn@(s: &stmt_, span, ast_fold) -> (stmt_, span))\n                 -> (stmt_, span) {\n@@ -249,12 +311,12 @@ pub fn expand_stmt(exts: SyntaxExtensions, cx: ext_ctxt,\n \n     assert(vec::len(pth.idents) == 1u);\n     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-    let (fully_expanded, sp) = match exts.find(&extname) {\n+    let (fully_expanded, sp) = match (*extsbox).find(&extname) {\n         None =>\n             cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", *extname)),\n \n-        Some(NormalTT(\n-            SyntaxExpanderTT{expander: exp, span: exp_sp})) => {\n+        Some(@SE(NormalTT(\n+            SyntaxExpanderTT{expander: exp, span: exp_sp}))) => {\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: sp,\n                 callee: NameAndSpan { name: copy *extname, span: exp_sp }\n@@ -282,27 +344,47 @@ pub fn expand_stmt(exts: SyntaxExtensions, cx: ext_ctxt,\n         }\n     };\n \n-    return (match fully_expanded {\n+    (match fully_expanded {\n         stmt_expr(e, stmt_id) if semi => stmt_semi(e, stmt_id),\n         _ => { fully_expanded } /* might already have a semi */\n     }, sp)\n \n }\n \n \n+\n+pub fn expand_block(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n+                    blk: &blk_, sp: span, fld: ast_fold,\n+                    orig: fn@(&blk_, span, ast_fold) -> (blk_, span))\n+    -> (blk_, span) {\n+    match (*extsbox).find(&@~\" block\") {\n+        // no scope limit on macros in this block, no need\n+        // to push an exts frame:\n+        Some(@ScopeMacros(false)) => {\n+            orig (blk,sp,fld)\n+        },\n+        // this block should limit the scope of its macros:\n+        Some(@ScopeMacros(true)) => {\n+            // see note below about treatment of exts table\n+            with_exts_frame!(extsbox,orig(blk,sp,fld))\n+        },\n+        _ => cx.span_bug(sp,\n+                         ~\"expected ScopeMacros binding for \\\" block\\\"\")\n+    }\n+}\n+\n pub fn new_span(cx: ext_ctxt, sp: span) -> span {\n     /* this discards information in the case of macro-defining macros */\n     return span {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n }\n \n-// FIXME (#2247): this is a terrible kludge to inject some macros into\n-// the default compilation environment. When the macro-definition system\n-// is substantially more mature, these should move from here, into a\n-// compiled part of libcore at very least.\n+// FIXME (#2247): this is a moderately bad kludge to inject some macros into\n+// the default compilation environment. It would be much nicer to use\n+// a mechanism like syntax_quote to ensure hygiene.\n \n pub fn core_macros() -> ~str {\n     return\n-~\"{\n+~\"pub mod macros {\n     macro_rules! ignore (($($x:tt)*) => (()))\n \n     macro_rules! error ( ($( $arg:expr ),+) => (\n@@ -352,28 +434,166 @@ pub fn core_macros() -> ~str {\n \n pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n                     cfg: ast::crate_cfg, c: @crate) -> @crate {\n-    let exts = syntax_expander_table();\n+    // adding *another* layer of indirection here so that the block\n+    // visitor can swap out one exts table for another for the duration\n+    // of the block.  The cleaner alternative would be to thread the\n+    // exts table through the fold, but that would require updating\n+    // every method/element of AstFoldFns in fold.rs.\n+    let extsbox = @mut syntax_expander_table();\n     let afp = default_ast_fold();\n     let cx: ext_ctxt = mk_ctxt(parse_sess, copy cfg);\n     let f_pre = @AstFoldFns {\n-        fold_expr: |a,b,c| expand_expr(exts, cx, a, b, c, afp.fold_expr),\n-        fold_mod: |a,b| expand_mod_items(exts, cx, a, b, afp.fold_mod),\n-        fold_item: |a,b| expand_item(exts, cx, a, b, afp.fold_item),\n-        fold_stmt: |a,b,c| expand_stmt(exts, cx, a, b, c, afp.fold_stmt),\n+        fold_expr: |expr,span,recur|\n+            expand_expr(extsbox, cx, expr, span, recur, afp.fold_expr),\n+        fold_mod: |modd,recur|\n+            expand_mod_items(extsbox, cx, modd, recur, afp.fold_mod),\n+        fold_item: |item,recur|\n+            expand_item(extsbox, cx, item, recur, afp.fold_item),\n+        fold_stmt: |stmt,span,recur|\n+            expand_stmt(extsbox, cx, stmt, span, recur, afp.fold_stmt),\n+        fold_block: |blk,span,recur|\n+            expand_block(extsbox, cx, blk, span, recur, afp.fold_block),\n         new_span: |a| new_span(cx, a),\n         .. *afp};\n     let f = make_fold(f_pre);\n-    let cm = parse_expr_from_source_str(~\"<core-macros>\",\n-                                        @core_macros(),\n-                                        copy cfg,\n-                                        parse_sess);\n-\n+    // add a bunch of macros as though they were placed at the\n+    // head of the program (ick).\n+    let attrs = ~[\n+        spanned {\n+            span: codemap::dummy_sp(),\n+            node: attribute_ {\n+                style: attr_outer,\n+                value: @spanned {\n+                    node: meta_word(@~\"macro_escape\"),\n+                    span: codemap::dummy_sp(),\n+                },\n+                is_sugared_doc: false,\n+            }\n+        }\n+    ];\n+\n+    let cm = match parse_item_from_source_str(~\"<core-macros>\",\n+                                              @core_macros(),\n+                                              copy cfg,\n+                                              attrs,\n+                                              parse_sess) {\n+        Some(item) => item,\n+        None => cx.bug(~\"expected core macros to parse correctly\")\n+    };\n     // This is run for its side-effects on the expander env,\n     // as it registers all the core macros as expanders.\n-    f.fold_expr(cm);\n+    f.fold_item(cm);\n \n     @f.fold_crate(&*c)\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use util::testing::check_equal;\n+\n+    // make sure that fail! is present\n+    #[test] fn fail_exists_test () {\n+        let src = ~\"fn main() { fail!(~\\\"something appropriately gloomy\\\");}\";\n+        let sess = parse::new_parse_sess(None);\n+        let cfg = ~[];\n+        let crate_ast = parse::parse_crate_from_source_str(\n+            ~\"<test>\",\n+            @src,\n+            cfg,sess);\n+        expand_crate(sess,cfg,crate_ast);\n+    }\n+\n+    // these following tests are quite fragile, in that they don't test what\n+    // *kind* of failure occurs.\n+\n+    // make sure that macros can leave scope\n+    #[should_fail]\n+    #[test] fn macros_cant_escape_fns_test () {\n+        let src = ~\"fn bogus() {macro_rules! z (() => (3+4))}\\\n+                    fn inty() -> int { z!() }\";\n+        let sess = parse::new_parse_sess(None);\n+        let cfg = ~[];\n+        let crate_ast = parse::parse_crate_from_source_str(\n+            ~\"<test>\",\n+            @src,\n+            cfg,sess);\n+        // should fail:\n+        expand_crate(sess,cfg,crate_ast);\n+    }\n+\n+    // make sure that macros can leave scope for modules\n+    #[should_fail]\n+    #[test] fn macros_cant_escape_mods_test () {\n+        let src = ~\"mod foo {macro_rules! z (() => (3+4))}\\\n+                    fn inty() -> int { z!() }\";\n+        let sess = parse::new_parse_sess(None);\n+        let cfg = ~[];\n+        let crate_ast = parse::parse_crate_from_source_str(\n+            ~\"<test>\",\n+            @src,\n+            cfg,sess);\n+        // should fail:\n+        expand_crate(sess,cfg,crate_ast);\n+    }\n+\n+    // macro_escape modules shouldn't cause macros to leave scope\n+    #[test] fn macros_can_escape_flattened_mods_test () {\n+        let src = ~\"#[macro_escape] mod foo {macro_rules! z (() => (3+4))}\\\n+                    fn inty() -> int { z!() }\";\n+        let sess = parse::new_parse_sess(None);\n+        let cfg = ~[];\n+        let crate_ast = parse::parse_crate_from_source_str(\n+            ~\"<test>\",\n+            @src,\n+            cfg,sess);\n+        // should fail:\n+        expand_crate(sess,cfg,crate_ast);\n+    }\n+\n+    #[test] fn core_macros_must_parse () {\n+        let src = ~\"\n+  pub mod macros {\n+    macro_rules! ignore (($($x:tt)*) => (()))\n+\n+    macro_rules! error ( ($( $arg:expr ),+) => (\n+        log(::core::error, fmt!( $($arg),+ )) ))\n+}\";\n+        let sess = parse::new_parse_sess(None);\n+        let cfg = ~[];\n+        let item_ast = parse::parse_item_from_source_str(\n+            ~\"<test>\",\n+            @src,\n+            cfg,~[make_dummy_attr (@~\"macro_escape\")],sess);\n+        match item_ast {\n+            Some(_) => (), // success\n+            None => fail!(~\"expected this to parse\")\n+        }\n+    }\n+\n+    #[test] fn test_contains_flatten (){\n+        let attr1 = make_dummy_attr (@~\"foo\");\n+        let attr2 = make_dummy_attr (@~\"bar\");\n+        let escape_attr = make_dummy_attr (@~\"macro_escape\");\n+        let attrs1 = ~[attr1, escape_attr, attr2];\n+        check_equal (contains_macro_escape (attrs1),true);\n+        let attrs2 = ~[attr1,attr2];\n+        check_equal (contains_macro_escape (attrs2),false);\n+    }\n+\n+    // make a \"meta_word\" outer attribute with the given name\n+    fn make_dummy_attr(s: @~str) -> ast::attribute {\n+        spanned {span:codemap::dummy_sp(),\n+                 node: attribute_\n+                     {style:attr_outer,\n+                      value:spanned\n+                          {node:meta_word(s),\n+                           span:codemap::dummy_sp()},\n+                      is_sugared_doc:false}}\n+    }\n+\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "88b77ec7970a5571721f8575e8818c20bfcfef6e", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -54,7 +54,7 @@ pub trait append_types {\n     fn add_tys(&self, +tys: ~[@ast::Ty]) -> @ast::path;\n }\n \n-pub impl append_types for @ast::path {\n+impl append_types for @ast::path {\n     fn add_ty(&self, ty: @ast::Ty) -> @ast::path {\n         @ast::path {\n             types: vec::append_one(copy self.types, ty),\n@@ -127,7 +127,7 @@ pub trait ext_ctxt_ast_builder {\n     fn strip_bounds(&self, bounds: &[ast::ty_param]) -> ~[ast::ty_param];\n }\n \n-pub impl ext_ctxt_ast_builder for ext_ctxt {\n+impl ext_ctxt_ast_builder for ext_ctxt {\n     fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty {\n         self.ty_path_ast_builder(path_global(~[\n             self.ident_of(~\"core\"),"}, {"sha": "f456f7b81ae15c5295a1359cd1fe53cc1bdeed8c", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -37,7 +37,7 @@ use ext::base::ext_ctxt;\n use ext::pipes::proto::{state, protocol, next_state};\n use ext::pipes::proto;\n \n-pub impl proto::visitor<(), (), ()> for ext_ctxt {\n+impl proto::visitor<(), (), ()> for ext_ctxt {\n     fn visit_proto(&self, _proto: protocol,\n                    _states: &[()]) { }\n "}, {"sha": "12603200ef31fcc0d56bdeabb1588c7e88720e87", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -23,7 +23,7 @@ pub trait proto_parser {\n     fn parse_message(&self, state: state);\n }\n \n-pub impl proto_parser for parser::Parser {\n+impl proto_parser for parser::Parser {\n     fn parse_proto(&self, +id: ~str) -> protocol {\n         let proto = protocol(id, *self.span);\n "}, {"sha": "46804c3d075c58afb58bf81be58dbb80d9fd129e", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -46,7 +46,7 @@ pub trait gen_init {\n     fn gen_init_bounded(&self, ext_cx: ext_ctxt) -> @ast::expr;\n }\n \n-pub impl gen_send for message {\n+impl gen_send for message {\n     fn gen_send(&mut self, cx: ext_ctxt, try: bool) -> @ast::item {\n         debug!(\"pipec: gen_send\");\n         let name = self.name();\n@@ -195,7 +195,7 @@ pub impl gen_send for message {\n     }\n }\n \n-pub impl to_type_decls for state {\n+impl to_type_decls for state {\n     fn to_type_decls(&self, cx: ext_ctxt) -> ~[@ast::item] {\n         debug!(\"pipec: to_type_decls\");\n         // This compiles into two different type declarations. Say the\n@@ -306,7 +306,7 @@ pub impl to_type_decls for state {\n     }\n }\n \n-pub impl gen_init for protocol {\n+impl gen_init for protocol {\n     fn gen_init(&self, cx: ext_ctxt) -> @ast::item {\n         let ext_cx = cx;\n "}, {"sha": "48abd6f1d975fb8eaed115ebc7244597d8e43236", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -21,7 +21,7 @@ use core::to_str::ToStr;\n #[deriving_eq]\n pub enum direction { send, recv }\n \n-pub impl ToStr for direction {\n+impl ToStr for direction {\n     pure fn to_str(&self) -> ~str {\n         match *self {\n           send => ~\"Send\","}, {"sha": "a8a7ad4c7493096b80e8a7368260121c35eee50b", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -22,36 +22,9 @@ use core::result;\n use core::str;\n use core::vec;\n \n-fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n-    // FIXME(#3874): this would be better written as:\n-    // let @ExpandedFrom(CallInfo {\n-    //     call_site: ref call_site,\n-    //     _\n-    //  }) = expn_info;\n-    match *expn_info {\n-        ExpandedFrom(CallInfo { call_site: ref call_site, _}) => {\n-            match call_site.expn_info {\n-                Some(next_expn_info) => {\n-                    // Don't recurse into file using \"include!\"\n-                    match *next_expn_info {\n-                        ExpandedFrom(\n-                            CallInfo { callee: NameAndSpan {\n-                                name: ref name,\n-                                _\n-                            },\n-                            _\n-                        }) => {\n-                            if *name == ~\"include\" { return expn_info; }\n-                        }\n-                    }\n-\n-                    topmost_expn_info(next_expn_info)\n-                },\n-                None => expn_info\n-            }\n-        }\n-    }\n-}\n+// These macros all relate to the file system; they either return\n+// the column/row/filename of the expression, or they include\n+// a given file into the current one.\n \n /* line!(): expands to the current line number */\n pub fn expand_line(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n@@ -101,6 +74,9 @@ pub fn expand_mod(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n                                   |x| cx.str_of(*x)), ~\"::\")))\n }\n \n+// include! : parse the given file as an expr\n+// This is generally a bad idea because it's going to behave\n+// unhygienically.\n pub fn expand_include(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n@@ -110,6 +86,7 @@ pub fn expand_include(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     base::MRExpr(p.parse_expr())\n }\n \n+// include_str! : read the given file, insert it as a literal string expr\n pub fn expand_include_str(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n@@ -140,6 +117,26 @@ pub fn expand_include_bin(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     }\n }\n \n+// recur along an ExpnInfo chain to find the original expression\n+fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n+    let ExpandedFrom(CallInfo { call_site, _ }) = *expn_info;\n+    match call_site.expn_info {\n+        Some(next_expn_info) => {\n+            let ExpandedFrom(CallInfo {\n+                callee: NameAndSpan {name, _},\n+                _\n+            }) = *next_expn_info;\n+            // Don't recurse into file using \"include!\"\n+            if name == ~\"include\" { return expn_info; }\n+\n+            topmost_expn_info(next_expn_info)\n+        },\n+        None => expn_info\n+    }\n+}\n+\n+// resolve a file-system path to an absolute file-system path (if it\n+// isn't already)\n fn res_rel_file(cx: ext_ctxt, sp: codemap::span, arg: &Path) -> Path {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute {"}, {"sha": "c23ce1c14a2f7156bd587a580ccd1d86322c7629", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -780,7 +780,7 @@ pub fn default_ast_fold() -> ast_fold_fns {\n     }\n }\n \n-pub impl ast_fold for ast_fold_fns {\n+impl ast_fold for ast_fold_fns {\n     /* naturally, a macro to write these would be nice */\n     fn fold_crate(c: &crate) -> crate {\n         let (n, s) = (self.fold_crate)(&c.node, c.span, self as ast_fold);"}, {"sha": "2a40b700c11574db2acb3454ae6a59d5584a1bd7", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -133,7 +133,7 @@ impl reader for StringReader {\n     fn dup(@mut self) -> reader { dup_string_reader(self) as reader }\n }\n \n-pub impl reader for TtReader {\n+impl reader for TtReader {\n     fn is_eof(@mut self) -> bool { self.cur_tok == token::EOF }\n     fn next_token(@mut self) -> TokenAndSpan { tt_next_token(self) }\n     fn fatal(@mut self, m: ~str) -> ! {\n@@ -779,11 +779,13 @@ pub mod test {\n     use diagnostic;\n     use util::testing::{check_equal, check_equal_ptr};\n \n+    // represents a testing reader (incl. both reader and interner)\n     struct Env {\n         interner: @token::ident_interner,\n         string_reader: @mut StringReader\n     }\n \n+    // open a string reader for the given string\n     fn setup(teststr: ~str) -> Env {\n         let cm = CodeMap::new();\n         let fm = cm.new_filemap(~\"zebra.rs\", @teststr);\n@@ -818,6 +820,52 @@ pub mod test {\n         check_equal (string_reader.last_pos,BytePos(29))\n     }\n \n+    // check that the given reader produces the desired stream\n+    // of tokens (stop checking after exhausting the expected vec)\n+    fn check_tokenization (env: Env, expected: ~[token::Token]) {\n+        for expected.each |expected_tok| {\n+            let TokenAndSpan {tok:actual_tok, sp: _} =\n+                env.string_reader.next_token();\n+            check_equal(&actual_tok,expected_tok);\n+        }\n+    }\n+\n+    // make the identifier by looking up the string in the interner\n+    fn mk_ident (env: Env, id: ~str, is_mod_name: bool) -> token::Token {\n+        token::IDENT (env.interner.intern(@id),is_mod_name)\n+    }\n+\n+    #[test] fn doublecolonparsing () {\n+        let env = setup (~\"a b\");\n+        check_tokenization (env,\n+                           ~[mk_ident (env,~\"a\",false),\n+                             mk_ident (env,~\"b\",false)]);\n+    }\n+\n+    #[test] fn dcparsing_2 () {\n+        let env = setup (~\"a::b\");\n+        check_tokenization (env,\n+                           ~[mk_ident (env,~\"a\",true),\n+                             token::MOD_SEP,\n+                             mk_ident (env,~\"b\",false)]);\n+    }\n+\n+    #[test] fn dcparsing_3 () {\n+        let env = setup (~\"a ::b\");\n+        check_tokenization (env,\n+                           ~[mk_ident (env,~\"a\",false),\n+                             token::MOD_SEP,\n+                             mk_ident (env,~\"b\",false)]);\n+    }\n+\n+    #[test] fn dcparsing_4 () {\n+        let env = setup (~\"a:: b\");\n+        check_tokenization (env,\n+                           ~[mk_ident (env,~\"a\",true),\n+                             token::MOD_SEP,\n+                             mk_ident (env,~\"b\",false)]);\n+    }\n+\n     #[test] fn character_a() {\n         let env = setup(~\"'a'\");\n         let TokenAndSpan {tok, sp: _} ="}, {"sha": "816e4137126b792454666afb8cffa97b9029955a", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -104,9 +104,7 @@ pub fn parse_crate_from_source_str(\n         codemap::FssNone,\n         source\n     );\n-    let r = p.parse_crate_mod(/*bad*/ copy cfg);\n-    p.abort_if_errors();\n-    r\n+    maybe_aborted(p.parse_crate_mod(/*bad*/ copy cfg),p)\n }\n \n pub fn parse_expr_from_source_str(\n@@ -122,9 +120,7 @@ pub fn parse_expr_from_source_str(\n         codemap::FssNone,\n         source\n     );\n-    let r = p.parse_expr();\n-    p.abort_if_errors();\n-    r\n+    maybe_aborted(p.parse_expr(), p)\n }\n \n pub fn parse_item_from_source_str(\n@@ -141,9 +137,7 @@ pub fn parse_item_from_source_str(\n         codemap::FssNone,\n         source\n     );\n-    let r = p.parse_item(attrs);\n-    p.abort_if_errors();\n-    r\n+    maybe_aborted(p.parse_item(attrs),p)\n }\n \n pub fn parse_stmt_from_source_str(\n@@ -160,9 +154,7 @@ pub fn parse_stmt_from_source_str(\n         codemap::FssNone,\n         source\n     );\n-    let r = p.parse_stmt(attrs);\n-    p.abort_if_errors();\n-    r\n+    maybe_aborted(p.parse_stmt(attrs),p)\n }\n \n pub fn parse_tts_from_source_str(\n@@ -179,9 +171,7 @@ pub fn parse_tts_from_source_str(\n         source\n     );\n     *p.quote_depth += 1u;\n-    let r = p.parse_all_token_trees();\n-    p.abort_if_errors();\n-    r\n+    maybe_aborted(p.parse_all_token_trees(),p)\n }\n \n pub fn parse_from_source_str<T>(\n@@ -202,8 +192,7 @@ pub fn parse_from_source_str<T>(\n     if !p.reader.is_eof() {\n         p.reader.fatal(~\"expected end-of-string\");\n     }\n-    p.abort_if_errors();\n-    r\n+    maybe_aborted(r,p)\n }\n \n pub fn next_node_id(sess: @mut ParseSess) -> node_id {\n@@ -230,8 +219,8 @@ pub fn new_parser_from_source_str(\n     Parser(sess, cfg, srdr as reader)\n }\n \n-// Read the entire source file, return a parser\n-// that draws from that string\n+/// Read the entire source file, return a parser\n+/// that draws from that string\n pub fn new_parser_result_from_file(\n     sess: @mut ParseSess,\n     +cfg: ast::crate_cfg,\n@@ -252,7 +241,7 @@ pub fn new_parser_result_from_file(\n     }\n }\n \n-/// Create a new parser for an entire crate, handling errors as appropriate\n+/// Create a new parser, handling errors as appropriate\n /// if the file doesn't exist\n pub fn new_parser_from_file(\n     sess: @mut ParseSess,\n@@ -297,6 +286,13 @@ pub fn new_parser_from_tts(\n     Parser(sess, cfg, trdr as reader)\n }\n \n+// abort if necessary\n+pub fn maybe_aborted<T>(+result : T, p: Parser) -> T {\n+    p.abort_if_errors();\n+    result\n+}\n+\n+\n \n #[cfg(test)]\n mod test {"}, {"sha": "2b2f1f48034a295b7fa340a8e9c413a32f96aec4", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -48,9 +48,12 @@ pub enum ObsoleteSyntax {\n     ObsoleteUnenforcedBound,\n     ObsoleteImplSyntax,\n     ObsoleteTraitBoundSeparator,\n+    ObsoleteMutOwnedPointer,\n+    ObsoleteMutVector,\n+    ObsoleteTraitImplVisibility,\n }\n \n-pub impl to_bytes::IterBytes for ObsoleteSyntax {\n+impl to_bytes::IterBytes for ObsoleteSyntax {\n     #[inline(always)]\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n@@ -126,6 +129,24 @@ pub impl Parser {\n                 \"space-separated trait bounds\",\n                 \"write `+` between trait bounds\"\n             ),\n+            ObsoleteMutOwnedPointer => (\n+                \"const or mutable owned pointer\",\n+                \"mutability inherits through `~` pointers; place the `~` box\n+                 in a mutable location, like a mutable local variable or an \\\n+                 `@mut` box\"\n+            ),\n+            ObsoleteMutVector => (\n+                \"const or mutable vector\",\n+                \"mutability inherits through `~` pointers; place the vector \\\n+                 in a mutable location, like a mutable local variable or an \\\n+                 `@mut` box\"\n+            ),\n+            ObsoleteTraitImplVisibility => (\n+                \"visibility-qualified trait implementation\",\n+                \"`pub` or `priv` is meaningless for trait implementations, \\\n+                 because the `impl...for...` form defines overloads for \\\n+                 methods that already exist; remove the `pub` or `priv`\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "3d4e0f9020bdc22159b046b7f01648fbd2ce64a4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -75,7 +75,8 @@ use parse::obsolete::{ObsoleteMoveInit, ObsoleteBinaryMove};\n use parse::obsolete::{ObsoleteStructCtor, ObsoleteWith};\n use parse::obsolete::{ObsoleteSyntax, ObsoleteLowerCaseKindBounds};\n use parse::obsolete::{ObsoleteUnsafeBlock, ObsoleteImplSyntax};\n-use parse::obsolete::{ObsoleteTraitBoundSeparator};\n+use parse::obsolete::{ObsoleteTraitBoundSeparator, ObsoleteMutOwnedPointer};\n+use parse::obsolete::{ObsoleteMutVector, ObsoleteTraitImplVisibility};\n use parse::prec::{as_prec, token_to_binop};\n use parse::token::{can_begin_expr, is_ident, is_ident_or_path};\n use parse::token::{is_plain_ident, INTERPOLATED, special_idents};\n@@ -653,6 +654,9 @@ pub impl Parser {\n         } else if *self.token == token::LBRACKET {\n             self.expect(&token::LBRACKET);\n             let mt = self.parse_mt();\n+            if mt.mutbl == m_mutbl {    // `m_const` too after snapshot\n+                self.obsolete(*self.last_span, ObsoleteMutVector);\n+            }\n \n             // Parse the `* 3` in `[ int * 3 ]`\n             let t = match self.maybe_parse_fixed_vstore_with_star() {\n@@ -710,6 +714,11 @@ pub impl Parser {\n         // rather than boxed ptrs.  But the special casing of str/vec is not\n         // reflected in the AST type.\n         let mt = self.parse_mt();\n+\n+        if mt.mutbl != m_imm && sigil == OwnedSigil {\n+            self.obsolete(*self.last_span, ObsoleteMutOwnedPointer);\n+        }\n+\n         ctor(mt)\n     }\n \n@@ -781,18 +790,6 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_capture_item_or(parse_arg_fn: fn(&Parser) -> arg_or_capture_item)\n-        -> arg_or_capture_item\n-    {\n-        if self.eat_keyword(&~\"copy\") {\n-            // XXX outdated syntax now that moves-based-on-type has gone in\n-            self.parse_ident();\n-            either::Right(())\n-        } else {\n-            parse_arg_fn(&self)\n-        }\n-    }\n-\n     // This version of parse arg doesn't necessarily require\n     // identifier names.\n     fn parse_arg_general(require_name: bool) -> arg {\n@@ -821,32 +818,26 @@ pub impl Parser {\n         either::Left(self.parse_arg_general(true))\n     }\n \n-    fn parse_arg_or_capture_item() -> arg_or_capture_item {\n-        self.parse_capture_item_or(|p| p.parse_arg())\n-    }\n-\n     fn parse_fn_block_arg() -> arg_or_capture_item {\n-        do self.parse_capture_item_or |p| {\n-            let m = p.parse_arg_mode();\n-            let is_mutbl = self.eat_keyword(&~\"mut\");\n-            let pat = p.parse_pat(false);\n-            let t = if p.eat(&token::COLON) {\n-                p.parse_ty(false)\n-            } else {\n-                @Ty {\n-                    id: p.get_id(),\n-                    node: ty_infer,\n-                    span: mk_sp(p.span.lo, p.span.hi),\n-                }\n-            };\n-            either::Left(ast::arg {\n-                mode: m,\n-                is_mutbl: is_mutbl,\n-                ty: t,\n-                pat: pat,\n-                id: p.get_id()\n-            })\n-        }\n+        let m = self.parse_arg_mode();\n+        let is_mutbl = self.eat_keyword(&~\"mut\");\n+        let pat = self.parse_pat(false);\n+        let t = if self.eat(&token::COLON) {\n+            self.parse_ty(false)\n+        } else {\n+            @Ty {\n+                id: self.get_id(),\n+                node: ty_infer,\n+                span: mk_sp(self.span.lo, self.span.hi),\n+            }\n+        };\n+        either::Left(ast::arg {\n+            mode: m,\n+            is_mutbl: is_mutbl,\n+            ty: t,\n+            pat: pat,\n+            id: self.get_id()\n+        })\n     }\n \n     fn maybe_parse_fixed_vstore_with_star() -> Option<uint> {\n@@ -1184,6 +1175,10 @@ pub impl Parser {\n         } else if *self.token == token::LBRACKET {\n             self.bump();\n             let mutbl = self.parse_mutability();\n+            if mutbl == m_mutbl {   // `m_const` too after snapshot\n+                self.obsolete(*self.last_span, ObsoleteMutVector);\n+            }\n+\n             if *self.token == token::RBRACKET {\n                 // Empty vector.\n                 self.bump();\n@@ -1659,6 +1654,10 @@ pub impl Parser {\n           token::TILDE => {\n             self.bump();\n             let m = self.parse_mutability();\n+            if m != m_imm {\n+                self.obsolete(*self.last_span, ObsoleteMutOwnedPointer);\n+            }\n+\n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n             // HACK: turn ~[...] into a ~-evec\n@@ -1794,7 +1793,7 @@ pub impl Parser {\n \n         // if we want to allow fn expression argument types to be inferred in\n         // the future, just have to change parse_arg to parse_fn_block_arg.\n-        let decl = self.parse_fn_decl(|p| p.parse_arg_or_capture_item());\n+        let decl = self.parse_fn_decl(|p| p.parse_arg());\n \n         let body = self.parse_block();\n \n@@ -3044,9 +3043,9 @@ pub impl Parser {\n     }\n \n     // Parses two variants (with the region/type params always optional):\n-    //    impl<T> ~[T] : to_str { ... }\n-    //    impl<T> to_str for ~[T] { ... }\n-    fn parse_item_impl() -> item_info {\n+    //    impl<T> Foo { ... }\n+    //    impl<T> ToStr for ~[T] { ... }\n+    fn parse_item_impl(visibility: ast::visibility) -> item_info {\n         fn wrap_path(p: &Parser, pt: @path) -> @Ty {\n             @Ty {\n                 id: p.get_id(),\n@@ -3095,6 +3094,12 @@ pub impl Parser {\n             None\n         };\n \n+        // Do not allow visibility to be specified in `impl...for...`. It is\n+        // meaningless.\n+        if opt_trait.is_some() && visibility != ast::inherited {\n+            self.obsolete(*self.span, ObsoleteTraitImplVisibility);\n+        }\n+\n         let mut meths = ~[];\n         if !self.eat(&token::SEMI) {\n             self.expect(&token::LBRACE);\n@@ -3993,7 +3998,8 @@ pub impl Parser {\n                                           maybe_append(attrs, extra_attrs)));\n         } else if items_allowed && self.eat_keyword(&~\"impl\") {\n             // IMPL ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_impl();\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_impl(visibility);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));"}, {"sha": "6d0ca2c6657016827409b12b80265602a27662b3", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -87,7 +87,9 @@ pub enum Token {\n     LIT_STR(ast::ident),\n \n     /* Name components */\n-    // an identifier contains an \"is_mod_name\" boolean.\n+    // an identifier contains an \"is_mod_name\" boolean,\n+    // indicating whether :: follows this token with no\n+    // whitespace in between.\n     IDENT(ast::ident, bool),\n     UNDERSCORE,\n     LIFETIME(ast::ident),"}, {"sha": "e27fc68df9cc020559f8c4ca9bfbf3c4466df829", "filename": "src/test/auxiliary/cci_class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcci_class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcci_class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -10,7 +10,7 @@\n \n pub mod kitties {\n     pub struct cat {\n-      priv mut meows : uint,\n+      priv meows : uint,\n \n       how_hungry : int,\n     }"}, {"sha": "b955ed9c2a7f07cc49317ae202d6a5b041c2c271", "filename": "src/test/auxiliary/cci_class_2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -10,7 +10,7 @@\n \n pub mod kitties {\n     pub struct cat {\n-      priv mut meows : uint,\n+      priv meows : uint,\n \n       how_hungry : int,\n "}, {"sha": "a516f5398df624008b9972cae9f1d6ea0ad96ac0", "filename": "src/test/auxiliary/cci_class_3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcci_class_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcci_class_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_3.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -10,14 +10,14 @@\n \n pub mod kitties {\n     pub struct cat {\n-        priv mut meows : uint,\n+        priv meows : uint,\n \n         how_hungry : int,\n     }\n \n     pub impl cat {\n-        fn speak() { self.meows += 1u; }\n-        fn meow_count() -> uint { self.meows }\n+        fn speak(&mut self) { self.meows += 1u; }\n+        fn meow_count(&mut self) -> uint { self.meows }\n     }\n \n     pub fn cat(in_x : uint, in_y : int) -> cat {"}, {"sha": "68143b32741c8661c8486d348e3d599e1e282e94", "filename": "src/test/auxiliary/cci_class_4.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -10,30 +10,29 @@\n \n pub mod kitties {\n     pub struct cat {\n-        priv mut meows : uint,\n+        priv meows : uint,\n \n-        mut how_hungry : int,\n+        how_hungry : int,\n         name : ~str,\n     }\n \n     pub impl cat {\n-      fn speak() { self.meow(); }\n+        fn speak(&mut self) { self.meow(); }\n \n-      fn eat() -> bool {\n-        if self.how_hungry > 0 {\n-            error!(\"OM NOM NOM\");\n-            self.how_hungry -= 2;\n-            return true;\n-        }\n-        else {\n-            error!(\"Not hungry!\");\n-            return false;\n+        fn eat(&mut self) -> bool {\n+            if self.how_hungry > 0 {\n+                error!(\"OM NOM NOM\");\n+                self.how_hungry -= 2;\n+                return true;\n+            } else {\n+                error!(\"Not hungry!\");\n+                return false;\n+            }\n         }\n-      }\n     }\n \n     pub impl cat {\n-        fn meow() {\n+        fn meow(&mut self) {\n             error!(\"Meow\");\n             self.meows += 1u;\n             if self.meows % 5u == 0u {"}, {"sha": "ceccea409c44a800694be1c400cf5acc37901978", "filename": "src/test/auxiliary/cci_class_6.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -10,17 +10,17 @@\n \n pub mod kitties {\n     pub struct cat<U> {\n-        priv mut info : ~[U],\n-        priv mut meows : uint,\n+        priv info : ~[U],\n+        priv meows : uint,\n \n         how_hungry : int,\n     }\n \n     pub impl<U> cat<U> {\n-        fn speak<T>(stuff: ~[T]) {\n+        fn speak<T>(&mut self, stuff: ~[T]) {\n             self.meows += stuff.len();\n         }\n-        fn meow_count() -> uint { self.meows }\n+        fn meow_count(&mut self) -> uint { self.meows }\n     }\n \n     pub fn cat<U>(in_x : uint, in_y : int, -in_info: ~[U]) -> cat<U> {"}, {"sha": "5006c72ad156b17802945014cf1fc139725f1a48", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -12,17 +12,17 @@ use core::to_str::*;\n \n pub mod kitty {\n     pub struct cat {\n-      priv mut meows : uint,\n-      mut how_hungry : int,\n+      priv meows : uint,\n+      how_hungry : int,\n       name : ~str,\n     }\n \n-    pub impl ToStr for cat {\n+    impl ToStr for cat {\n        pure fn to_str(&self) -> ~str { copy self.name }\n     }\n \n     priv impl cat {\n-        fn meow() {\n+        fn meow(&mut self) {\n             error!(\"Meow\");\n             self.meows += 1u;\n             if self.meows % 5u == 0u {\n@@ -33,9 +33,9 @@ pub mod kitty {\n     }\n \n     pub impl cat {\n-        fn speak() { self.meow(); }\n+        fn speak(&mut self) { self.meow(); }\n \n-        fn eat() -> bool {\n+        fn eat(&mut self) -> bool {\n             if self.how_hungry > 0 {\n                 error!(\"OM NOM NOM\");\n                 self.how_hungry -= 2;"}, {"sha": "7ca3d7c4ac99042a25921536fb1ef64b48006106", "filename": "src/test/auxiliary/cci_class_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcci_class_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcci_class_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_trait.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -10,6 +10,6 @@\n \n pub mod animals {\n     pub trait noisy {\n-        fn speak();\n+        fn speak(&mut self);\n     }\n }"}, {"sha": "f578ad82d6d80ca62a106c95179b2e57d9f2722b", "filename": "src/test/auxiliary/crate-method-reexport-grrrrrrr2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -19,7 +19,7 @@ pub mod name_pool {\n         fn add(s: ~str);\n     }\n \n-    pub impl add for name_pool {\n+    impl add for name_pool {\n         fn add(s: ~str) {\n         }\n     }\n@@ -34,7 +34,7 @@ pub mod rust {\n         fn cx();\n     }\n \n-    pub impl cx for rt {\n+    impl cx for rt {\n         fn cx() {\n         }\n     }"}, {"sha": "36343d42b7589390871ceb8c4e4d3305f3d0f6d1", "filename": "src/test/auxiliary/issue-3012-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -16,7 +16,7 @@ pub mod socket {\n         sockfd: libc::c_int,\n     }\n \n-    pub impl Drop for socket_handle {\n+    impl Drop for socket_handle {\n         fn finalize(&self) {\n             /* c::close(self.sockfd); */\n         }"}, {"sha": "0690a017449474558689f591b5965337766bbfdb", "filename": "src/test/auxiliary/issue2170lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fissue2170lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Fissue2170lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue2170lib.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -15,7 +15,7 @@ pub struct rsrc {\n   x: i32,\n }\n \n-pub impl Drop for rsrc {\n+impl Drop for rsrc {\n     fn finalize(&self) {\n         foo(self.x);\n     }"}, {"sha": "67da2541ca212af8bc9f7553dfa6524032d3d541", "filename": "src/test/auxiliary/trait_inheritance_overloading_xc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -17,25 +17,25 @@ pub struct MyInt {\n     val: int\n }\n \n-pub impl Add<MyInt, MyInt> for MyInt {\n+impl Add<MyInt, MyInt> for MyInt {\n     pure fn add(&self, other: &MyInt) -> MyInt { mi(self.val + other.val) }\n }\n \n-pub impl Sub<MyInt, MyInt> for MyInt {\n+impl Sub<MyInt, MyInt> for MyInt {\n     pure fn sub(&self, other: &MyInt) -> MyInt { mi(self.val - other.val) }\n }\n \n-pub impl Mul<MyInt, MyInt> for MyInt {\n+impl Mul<MyInt, MyInt> for MyInt {\n     pure fn mul(&self, other: &MyInt) -> MyInt { mi(self.val * other.val) }\n }\n \n-pub impl Eq for MyInt {\n+impl Eq for MyInt {\n     pure fn eq(&self, other: &MyInt) -> bool { self.val == other.val }\n \n     pure fn ne(&self, other: &MyInt) -> bool { !self.eq(other) }\n }\n \n-pub impl MyNum for MyInt;\n+impl MyNum for MyInt;\n \n pure fn mi(v: int) -> MyInt { MyInt { val: v } }\n "}, {"sha": "12060a87850a0bbd3fbf0159cb2665bb6d9bdb60", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -19,6 +19,7 @@ extern mod std;\n use std::time;\n use std::arc;\n use std::future;\n+use core::cell::Cell;\n \n // A poor man's pipe.\n type pipe = arc::MutexARC<~[uint]>;\n@@ -77,7 +78,7 @@ fn main() {\n     let msg_per_task = uint::from_str(args[2]).get();\n \n     let (num_chan, num_port) = init();\n-    let mut num_chan = Some(num_chan);\n+    let mut num_chan = Cell(num_chan);\n \n     let start = time::precise_time_s();\n \n@@ -87,24 +88,19 @@ fn main() {\n     for uint::range(1u, num_tasks) |i| {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n-        let num_chan2 = ~mut None;\n-        *num_chan2 <-> num_chan;\n-        let num_port = ~mut Some(num_port);\n-        let new_future = do future::spawn() || {\n-            let mut num_chan = None;\n-            num_chan <-> *num_chan2;\n-            let mut num_port1 = None;\n-            num_port1 <-> *num_port;\n-            thread_ring(i, msg_per_task,\n-                        option::unwrap(num_chan),\n-                        option::unwrap(num_port1))\n+        let num_chan2 = Cell(num_chan.take());\n+        let num_port = Cell(num_port);\n+        let new_future = do future::spawn() {\n+            let num_chan = num_chan2.take();\n+            let num_port1 = num_port.take();\n+            thread_ring(i, msg_per_task, num_chan, num_port1)\n         };\n         futures.push(new_future);\n-        num_chan = Some(new_chan);\n+        num_chan.put_back(new_chan);\n     };\n \n     // do our iteration\n-    thread_ring(0, msg_per_task, option::unwrap(num_chan), num_port);\n+    thread_ring(0, msg_per_task, num_chan.take(), num_port);\n \n     // synchronize\n     for futures.each |f| { f.get() };"}, {"sha": "56a46d3e006cc2cdedc0df5948d61e4b50eec6ad", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -17,10 +17,11 @@\n // This version uses automatically compiled channel contracts.\n \n extern mod std;\n-use std::time;\n-use std::future;\n \n+use core::cell::Cell;\n use core::pipes::recv;\n+use std::time;\n+use std::future;\n \n proto! ring (\n     num:send {\n@@ -70,7 +71,7 @@ fn main() {\n     let msg_per_task = uint::from_str(args[2]).get();\n \n     let (num_chan, num_port) = ring::init();\n-    let mut num_chan = Some(num_chan);\n+    let mut num_chan = Cell(num_chan);\n \n     let start = time::precise_time_s();\n \n@@ -80,24 +81,19 @@ fn main() {\n     for uint::range(1u, num_tasks) |i| {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = ring::init();\n-        let num_chan2 = ~mut None;\n-        *num_chan2 <-> num_chan;\n-        let num_port = ~mut Some(num_port);\n+        let num_chan2 = Cell(num_chan.take());\n+        let num_port = Cell(num_port);\n         let new_future = do future::spawn || {\n-            let mut num_chan = None;\n-            num_chan <-> *num_chan2;\n-            let mut num_port1 = None;\n-            num_port1 <-> *num_port;\n-            thread_ring(i, msg_per_task,\n-                        option::unwrap(num_chan),\n-                        option::unwrap(num_port1))\n+            let num_chan = num_chan2.take();\n+            let num_port1 = num_port.take();\n+            thread_ring(i, msg_per_task, num_chan, num_port1)\n         };\n         futures.push(new_future);\n-        num_chan = Some(new_chan);\n+        num_chan.put_back(new_chan);\n     };\n \n     // do our iteration\n-    thread_ring(0, msg_per_task, option::unwrap(num_chan), num_port);\n+    thread_ring(0, msg_per_task, num_chan.take(), num_port);\n \n     // synchronize\n     for futures.each |f| { f.get() };"}, {"sha": "57d04abb414c135fb4fe47fd85267eb88a001521", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -16,6 +16,8 @@\n // This also serves as a pipes test, because ARCs are implemented with pipes.\n \n extern mod std;\n+\n+use core::cell::Cell;\n use std::time;\n use std::arc;\n use std::future;\n@@ -77,7 +79,7 @@ fn main() {\n     let msg_per_task = uint::from_str(args[2]).get();\n \n     let (num_chan, num_port) = init();\n-    let mut num_chan = Some(num_chan);\n+    let mut num_chan = Cell(num_chan);\n \n     let start = time::precise_time_s();\n \n@@ -87,24 +89,19 @@ fn main() {\n     for uint::range(1u, num_tasks) |i| {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n-        let num_chan2 = ~mut None;\n-        *num_chan2 <-> num_chan;\n-        let num_port = ~mut Some(num_port);\n-        let new_future = do future::spawn || {\n-            let mut num_chan = None;\n-            num_chan <-> *num_chan2;\n-            let mut num_port1 = None;\n-            num_port1 <-> *num_port;\n-            thread_ring(i, msg_per_task,\n-                        option::unwrap(num_chan),\n-                        option::unwrap(num_port1))\n+        let num_chan2 = Cell(num_chan.take());\n+        let num_port = Cell(num_port);\n+        let new_future = do future::spawn {\n+            let num_chan = num_chan2.take();\n+            let num_port1 = num_port.take();\n+            thread_ring(i, msg_per_task, num_chan, num_port1)\n         };\n         futures.push(new_future);\n-        num_chan = Some(new_chan);\n+        num_chan.put_back(new_chan);\n     };\n \n     // do our iteration\n-    thread_ring(0, msg_per_task, option::unwrap(num_chan), num_port);\n+    thread_ring(0, msg_per_task, num_chan.take(), num_port);\n \n     // synchronize\n     for futures.each |f| { f.get() };"}, {"sha": "111219974d0987b8d2fe8e7406ad0c0162d80566", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -14,7 +14,7 @@ extern mod std;\n use std::oldmap;\n use std::oldmap::HashMap;\n use std::sort;\n-use std::cell::Cell;\n+use core::cell::Cell;\n use core::comm::*;\n \n fn print_complements() {"}, {"sha": "2853382136546facc082839349f350d1659d9966", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -122,7 +122,7 @@ fn main() {\n                 let elapsed = stop - start;\n \n                 out.write_line(fmt!(\"%d\\t%d\\t%s\", n, fibn,\n-                                    u64::str(elapsed)));\n+                                    u64::to_str(elapsed)));\n             }\n         }\n     }"}, {"sha": "9bdc5aae3f2835fba69a917f01795e0ed54f95e6", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -17,13 +17,15 @@\n //\n // The filename is a song reference; google it in quotes.\n \n+use core::cell::Cell;\n+\n fn child_generation(gens_left: uint, -c: comm::Chan<()>) {\n     // This used to be O(n^2) in the number of generations that ever existed.\n     // With this code, only as many generations are alive at a time as tasks\n     // alive at a time,\n-    let c = ~mut Some(c);\n-    do task::spawn_supervised || {\n-        let c = option::swap_unwrap(c);\n+    let c = Cell(c);\n+    do task::spawn_supervised {\n+        let c = c.take();\n         if gens_left & 1 == 1 {\n             task::yield(); // shake things up a bit\n         }"}, {"sha": "94488fbb55213b5b9575382e0884bf97b04fde28", "filename": "src/test/compile-fail/alt-join.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-join.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -16,6 +16,6 @@ fn my_fail() -> ! { fail!(); }\n fn main() {\n     match true { false => { my_fail(); } true => { } }\n \n-    log(debug, x); //~ ERROR unresolved name: x\n+    log(debug, x); //~ ERROR unresolved name: `x`.\n     let x: int;\n }"}, {"sha": "17c7ff1bb6037bfc249e9db83cea547d4760c47b", "filename": "src/test/compile-fail/assign-super.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fassign-super.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fassign-super.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-super.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    let mut x: ~[mut int] = ~[mut 3];\n-    let y: ~[int] = ~[3];\n-    x = y; //~ ERROR values differ in mutability\n-}"}, {"sha": "30014817308f433d47e77fc3a240ca637f779d94", "filename": "src/test/compile-fail/bad-expr-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: unresolved name: m1::a\n+// error-pattern: unresolved name: `m1::a`. Did you mean: `args`?\n \n mod m1 {}\n "}, {"sha": "88239a4cc3fee9a31d1efae9c004e44ad4e60c83", "filename": "src/test/compile-fail/bad-expr-path2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: unresolved name: m1::a\n+// error-pattern: unresolved name: `m1::a`. Did you mean: `args`?\n \n mod m1 {\n     pub mod a {}"}, {"sha": "ded47fc9f7fe268c49fcd0f1a283cad887ab63c9", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -11,7 +11,7 @@\n type point = { x: int, y: int };\n \n fn a() {\n-    let mut p = ~[mut 1];\n+    let mut p = ~[1];\n \n     // Create an immutable pointer into p's contents:\n     let _q: &int = &p[0]; //~ NOTE loan of mutable vec content granted here\n@@ -25,7 +25,7 @@ fn b() {\n     // here we alias the mutable vector into an imm slice and try to\n     // modify the original:\n \n-    let mut p = ~[mut 1];\n+    let mut p = ~[1];\n \n     do borrow(p) { //~ NOTE loan of mutable vec content granted here\n         p[0] = 5; //~ ERROR assigning to mutable vec content prohibited due to outstanding loan\n@@ -35,7 +35,7 @@ fn b() {\n fn c() {\n     // Legal because the scope of the borrow does not include the\n     // modification:\n-    let mut p = ~[mut 1];\n+    let mut p = ~[1];\n     borrow(p, ||{});\n     p[0] = 5;\n }"}, {"sha": "8457fce255ea319bfcadae50c5fb06edd6276f66", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -17,13 +17,13 @@ fn takes_imm_elt(_v: &int, f: fn()) {\n }\n \n fn has_mut_vec_and_does_not_try_to_change_it() {\n-    let v = ~[mut 1, 2, 3];\n+    let mut v = ~[1, 2, 3];\n     do takes_imm_elt(&v[0]) {\n     }\n }\n \n fn has_mut_vec_but_tries_to_change_it() {\n-    let v = ~[mut 1, 2, 3];\n+    let mut v = ~[1, 2, 3];\n     do takes_imm_elt(&v[0]) { //~ NOTE loan of mutable vec content granted here\n         v[1] = 4; //~ ERROR assigning to mutable vec content prohibited due to outstanding loan\n     }\n@@ -34,7 +34,7 @@ fn takes_const_elt(_v: &const int, f: fn()) {\n }\n \n fn has_mut_vec_and_tries_to_change_it() {\n-    let v = ~[mut 1, 2, 3];\n+    let mut v = ~[1, 2, 3];\n     do takes_const_elt(&const v[0]) {\n         v[1] = 4;\n     }"}, {"sha": "bc0340983ae3491348db9d9806f51d1d5e50fbb6", "filename": "src/test/compile-fail/borrowck-mut-slice-of-imm-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn write(v: &[mut int]) {\n+fn write(v: &mut [int]) {\n     v[0] += 1;\n }\n "}, {"sha": "43feb65c8b96b9492e4ab595c0405033dc2d77f1", "filename": "src/test/compile-fail/borrowck-mut-vec-as-imm-slice-bad.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn want_slice(v: &[int]) -> int {\n-    let mut sum = 0;\n-    for vec::each(v) |i| { sum += *i; }\n-    return sum;\n-}\n-\n-fn has_mut_vec(+v: @~[mut int]) -> int {\n-    want_slice(*v) //~ ERROR illegal borrow unless pure\n-        //~^ NOTE impure due to access to impure function\n-}\n-\n-fn main() {\n-    assert has_mut_vec(@~[mut 1, 2, 3]) == 6;\n-}"}, {"sha": "16b48aedb0c7fedc3d4d9949ed4a26b7890563f4", "filename": "src/test/compile-fail/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    let a = [mut 1, 2, 3, 4];\n+    let mut a = [1, 2, 3, 4];\n     let _ = match a {\n         [1, 2, ..tail] => tail,\n         _ => core::util::unreachable()"}, {"sha": "a360d6579574fc3b2b8fa2488304c30d369ecb7a", "filename": "src/test/compile-fail/does-nothing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -1,3 +1,3 @@\n-// error-pattern: unresolved name: this_does_nothing_what_the\n+// error-pattern: unresolved name: `this_does_nothing_what_the`.\n fn main() { debug!(\"doing\"); this_does_nothing_what_the; debug!(\"boing\"); }\n "}, {"sha": "7a45ecc83b0c297fcbd247dd398e63b56d754f3a", "filename": "src/test/compile-fail/issue-1476.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-1476.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-1476.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1476.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    log(error, x); //~ ERROR unresolved name: x\n+    log(error, x); //~ ERROR unresolved name: `x`.\n }"}, {"sha": "0880cabb2abf9afa39f54e275bb7e911e23ea76e", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -22,6 +22,6 @@ impl<A> vec_monad<A> for ~[A] {\n }\n fn main() {\n     [\"hi\"].bind(|x| [x] );\n-    //~^ ERROR type `[&static/str]/1` does not implement any method in scope named `bind`\n+    //~^ ERROR type `[&static/str * 1]` does not implement any method in scope named `bind`\n     //~^^ ERROR Unconstrained region variable\n }"}, {"sha": "88c76fb31a1ff86add6c2cb20cda0b0f0b369b21", "filename": "src/test/compile-fail/issue-2969.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -12,7 +12,7 @@\n fn main()\n {\n // See #2969 -- error message should be improved\n-   let mut x = [mut 1, 2, 4];\n+   let mut x = [1, 2, 4];\n    let v : &int = &x[2];\n    x[2] = 6;\n    assert *v == 6;"}, {"sha": "1d4cd69c54ee0a23a6693b1778da31a6934e76ac", "filename": "src/test/compile-fail/issue-3021-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-3021-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-3021-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021-b.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -19,7 +19,7 @@ fn siphash(k0 : u64) {\n     impl siphash {\n         fn reset(&mut self) {\n            self.v0 = k0 ^ 0x736f6d6570736575; //~ ERROR attempted dynamic environment-capture\n-           //~^ ERROR unresolved name: k0\n+           //~^ ERROR unresolved name: `k0`.\n         }\n     }\n }"}, {"sha": "7381d36a223967823dc112a0fb581859e362b013", "filename": "src/test/compile-fail/issue-3021-d.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -31,9 +31,9 @@ fn siphash(k0 : u64, k1 : u64) -> siphash {\n    impl siphash for sipstate {\n         fn reset() {\n             self.v0 = k0 ^ 0x736f6d6570736575;  //~ ERROR attempted dynamic environment-capture\n-            //~^ ERROR unresolved name: k0\n+            //~^ ERROR unresolved name: `k0`.\n             self.v1 = k1 ^ 0x646f72616e646f6d;   //~ ERROR attempted dynamic environment-capture\n-            //~^ ERROR unresolved name: k1\n+            //~^ ERROR unresolved name: `k1`.\n         }\n         fn result() -> u64 { return mk_result(self); }\n     }"}, {"sha": "e5a7a7990e526184d1726b8380b67d5bca558a91", "filename": "src/test/compile-fail/issue-3021.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -23,7 +23,7 @@ fn siphash(k0 : u64) -> siphash {\n    impl siphash for sipstate {\n         fn reset() {\n            self.v0 = k0 ^ 0x736f6d6570736575; //~ ERROR attempted dynamic environment-capture\n-           //~^ ERROR unresolved name: k0\n+           //~^ ERROR unresolved name: `k0`.\n         }\n     }\n     fail!();"}, {"sha": "443fae619ba7b0186785fbd80edeadcc0c938d04", "filename": "src/test/compile-fail/issue-3243.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-3243.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-3243.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3243.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n // xfail-test\n-fn function() -> &[mut int] {\n-    let mut x: &static/[mut int] = &[mut 1,2,3];\n+fn function() -> &mut [int] {\n+    let mut x: &static/mut [int] = &[1,2,3];\n     x[0] = 12345;\n     x //~ ERROR bad\n }"}, {"sha": "90ca7c1797c3ac7e1ea217b17ac4b4d6e4c5797e", "filename": "src/test/compile-fail/issue-3953.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -19,7 +19,7 @@ trait Hahaha: Eq Eq Eq Eq Eq Eq Eq Eq Eq Eq Eq Eq Eq Eq Eq Eq //~ ERROR Duplicat\n \n enum Lol = int;\n \n-pub impl Hahaha for Lol { }\n+impl Hahaha for Lol { }\n \n impl Eq for Lol {\n     pure fn eq(&self, other: &Lol) -> bool { **self != **other }"}, {"sha": "e2bf708feabc7fb1e108dc0e2d63c796453cfd35", "filename": "src/test/compile-fail/issue-3969.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-3969.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-3969.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3969.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -16,7 +16,7 @@ trait BikeMethods {\n     fn woops(&const self) -> ~str;\n }\n \n-pub impl BikeMethods for Bike {\n+impl BikeMethods for Bike {\n     static fn woops(&const self) -> ~str { ~\"foo\" }\n     //~^ ERROR method `woops` is declared as static in its impl, but not in its trait\n }"}, {"sha": "18caaa697a17dffd705b7f0ccc3c89318eb53e5b", "filename": "src/test/compile-fail/issue-4517.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-4517.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fissue-4517.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4517.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -0,0 +1,6 @@\n+fn bar(int_param: int) {}\n+\n+fn main() {\n+     let foo: [u8 * 4] = [1u8, ..4u8];\n+     bar(foo); //~ ERROR mismatched types: expected `int` but found `[u8 * 4]` (expected int but found vector)\n+}"}, {"sha": "5c71ae38a64c019525e4f882a03001eff384dc80", "filename": "src/test/compile-fail/lub-in-args.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Flub-in-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Flub-in-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-in-args.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -11,8 +11,6 @@\n fn two_args<T>(x: T, y: T) { }\n \n fn main() {\n-    let x: ~[mut int] = ~[mut 3];\n-    let y: ~[int] = ~[3];\n     let a: @mut int = @mut 3;\n     let b: @int = @3;\n \n@@ -22,6 +20,5 @@ fn main() {\n     // shortcoming of the current inference algorithm.  These errors\n     // are *not* desirable.\n \n-    two_args(x, y); //~ ERROR (values differ in mutability)\n     two_args(a, b); //~ ERROR (values differ in mutability)\n }"}, {"sha": "a24d2ed4b7fba3da7eb6491bea94bc61d1c0431a", "filename": "src/test/compile-fail/match-non-exhaustive.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fmatch-non-exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fmatch-non-exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-non-exhaustive.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//error-pattern:mismatched types\n fn main() {\n-    let i: ~int = ~mut 0;\n+    match 0 { 1 => () } //~ ERROR non-exhaustive patterns\n+    match 0 { 0 if false => () } //~ ERROR non-exhaustive patterns\n }", "previous_filename": "src/test/compile-fail/unique-mut.rs"}, {"sha": "8b59879acd979a807deaa8b7317b514e9463de34", "filename": "src/test/compile-fail/mutable-huh-unique-assign.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-unique-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-unique-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-unique-assign.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    fn f(&&v: ~const int) {\n-        *v = 1 //~ ERROR assigning to dereference of const ~ pointer\n-    }\n-\n-    let v = ~0;\n-\n-    f(v);\n-}"}, {"sha": "4f0c6d7a4c87d7e59fe43e02593241c1b9ae0a4a", "filename": "src/test/compile-fail/mutable-huh-variance-deep.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-deep.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: mismatched types\n-\n-fn main() {\n-    let v = ~[mut @mut ~mut ~[0]];\n-\n-    fn f(&&v: ~[mut @mut ~mut ~[const int]]) {\n-    }\n-\n-    f(v);\n-}"}, {"sha": "dba6f9ae3fa0fb5df1db58067dc842f0e5086a7b", "filename": "src/test/compile-fail/mutable-huh-variance-ptr.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-ptr.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: mismatched types\n-\n-extern mod std;\n-\n-fn main() {\n-    let mut a = ~[0];\n-    let v: *mut ~[int] = &mut a;\n-\n-    fn f(&&v: *mut ~[const int]) {\n-        unsafe {\n-            *v = ~[mut 3]\n-        }\n-    }\n-\n-    f(v);\n-}"}, {"sha": "f2188911346e99fb825884cb4bf2e5bd394d87e8", "filename": "src/test/compile-fail/mutable-huh-variance-unique.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-unique.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: mismatched types\n-\n-fn main() {\n-    let v = ~mut ~[0];\n-\n-    fn f(&&v: ~mut ~[const int]) {\n-        *v = ~[mut 3]\n-    }\n-\n-    f(v);\n-}"}, {"sha": "c3f4636f898b19f892886a9184b4713db9c1ea44", "filename": "src/test/compile-fail/mutable-huh-variance-vec1.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec1.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    // Note: explicit type annot is required here\n-    // because otherwise the inference gets smart\n-    // and assigns a type of ~[mut ~[const int]].\n-    let v: ~[mut ~[int]] = ~[mut ~[0]];\n-\n-    fn f(&&v: ~[mut ~[const int]]) {\n-        v[0] = ~[mut 3]\n-    }\n-\n-    f(v); //~ ERROR (values differ in mutability)\n-}"}, {"sha": "aeb06324341f46eae6c6b7cfd7debb335bb0c12b", "filename": "src/test/compile-fail/mutable-huh-variance-vec2.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec2.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    // Note: explicit type annot is required here\n-    // because otherwise the inference gets smart\n-    // and assigns a type of ~[mut ~[const int]].\n-    let v: ~[mut ~[mut int]] = ~[mut ~[mut 0]];\n-\n-    fn f(&&v: ~[mut ~[const int]]) {\n-        v[0] = ~[3]\n-    }\n-\n-    f(v); //~ ERROR (values differ in mutability)\n-}"}, {"sha": "edc66536e9bac2f271b3701c55ff324fc6dd9ee5", "filename": "src/test/compile-fail/mutable-huh-variance-vec3.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec3.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    // Note: explicit type annot is required here\n-    // because otherwise the inference gets smart\n-    // and assigns a type of ~[mut ~[const int]].\n-    let v: ~[mut ~[mut ~[int]]] = ~[mut ~[mut ~[0]]];\n-\n-    fn f(&&v: ~[mut ~[mut ~[const int]]]) {\n-        v[0][1] = ~[mut 3]\n-    }\n-\n-    f(v); //~ ERROR (values differ in mutability)\n-}"}, {"sha": "e0980826a2a599f2057fa387559524c238354bf2", "filename": "src/test/compile-fail/mutable-huh-variance-vec4.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec4.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -1,56 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-\n-    // Note: here we do not have any type annotations\n-    // but we do express conflicting requirements:\n-\n-    let v = ~[mut ~[0]];\n-    let w = ~[mut ~[mut 0]];\n-    let x = ~[mut ~[mut 0]];\n-\n-    fn f(&&v: ~[mut ~[int]]) {\n-        v[0] = ~[3]\n-    }\n-\n-    fn g(&&v: ~[const ~[const int]]) {\n-    }\n-\n-    fn h(&&v: ~[mut ~[mut int]]) {\n-        v[0] = ~[mut 3]\n-    }\n-\n-    fn i(&&v: ~[mut ~[const int]]) {\n-        v[0] = ~[mut 3]\n-    }\n-\n-    fn j(&&v: ~[~[const int]]) {\n-    }\n-\n-    f(v);\n-    g(v);\n-    h(v); //~ ERROR (values differ in mutability)\n-    i(v); //~ ERROR (values differ in mutability)\n-    j(v); //~ ERROR (values differ in mutability)\n-\n-    f(w); //~ ERROR (values differ in mutability)\n-    g(w);\n-    h(w);\n-    i(w); //~ ERROR (values differ in mutability)\n-    j(w); //~ ERROR (values differ in mutability)\n-\n-    // Note that without adding f() or h() to the mix, it is valid for\n-    // x to have the type ~[mut ~[const int]], and thus we can safely\n-    // call g() and i() but not j():\n-    g(x);\n-    i(x);\n-    j(x); //~ ERROR (values differ in mutability)\n-}"}, {"sha": "0d7e2d2377c2057d01c5cd3888623f52ea2bcddd", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::cell::Cell;\n+\n struct Port<T>(@T);\n \n fn main() {\n@@ -25,11 +27,10 @@ fn main() {\n         }\n     }\n \n-    let x = ~mut Some(foo(Port(@())));\n+    let x = Cell(foo(Port(@())));\n \n     do task::spawn {\n-        let mut y = None;\n-        *x <-> y; //~ ERROR value has non-owned type\n+        let y = x.take();   //~ ERROR value has non-owned type\n         log(error, y);\n     }\n }"}, {"sha": "4b637b0195c31c7bc5eac21eef4f7c64aace4547", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-2.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct invariant {\n-    f: @[mut &int]\n+    f: @mut [&int]\n }\n \n fn to_same_lifetime(bi: invariant/&r) {"}, {"sha": "579575e2008f85ba93a92beadaf49c0dcaab9365", "filename": "src/test/compile-fail/repeat_count.rs", "status": "renamed", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,14 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: mismatched types\n+// Regression test for issue #3645\n \n fn main() {\n-    let v = @mut ~[0];\n-\n-    fn f(&&v: @mut ~[const int]) {\n-        *v = ~[mut 3]\n-    }\n-\n-    f(v);\n+    let n = 1;\n+    let a = ~[0, ..n]; //~ ERROR expected constant integer for repeat count but found variable\n }", "previous_filename": "src/test/compile-fail/mutable-huh-variance-box.rs"}, {"sha": "7756f96b4703a5668ea1b1b3b5ac0513c65a952f", "filename": "src/test/compile-fail/unused-imports-warn.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Funused-imports-warn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Funused-imports-warn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-imports-warn.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -D unused-imports\n+#[deny(unused_imports)];\n \n use cal = bar::c::cc;\n \n@@ -31,11 +31,19 @@ mod foo {\n }\n \n mod bar {\n+    // Don't ignore on 'pub use' because we're not sure if it's used or not\n+    pub use core::cmp::Eq;\n+\n     pub mod c {\n         use foo::Point;\n         use foo::Square; //~ ERROR unused import\n         pub fn cc(p: Point) -> int { return 2 * (p.x + p.y); }\n     }\n+\n+    #[allow(unused_imports)]\n+    mod foo {\n+        use core::cmp::Eq;\n+    }\n }\n \n fn main() {"}, {"sha": "0f51d34fc2ff2a284c2da3e8e95625b3be4243f2", "filename": "src/test/compile-fail/vec-add.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-add.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -14,7 +14,7 @@\n // the right hand side in all cases. We are getting compiler errors\n // about this now, so I'm xfailing the test for now. -eholk\n \n-fn add(i: ~[int], m: ~[mut int], c: ~[const int]) {\n+fn add(i: ~[int], mut m: ~[int], c: ~[const int]) {\n \n     // Check that:\n     //  (1) vectors of any two mutabilities can be added\n@@ -24,9 +24,9 @@ fn add(i: ~[int], m: ~[mut int], c: ~[const int]) {\n        m + ~[3],\n        ~[3]);\n \n-   add(i + ~[mut 3],\n-       m + ~[mut 3],\n-       ~[mut 3]);\n+   add(i + ~[3],\n+       m + ~[3],\n+       ~[3]);\n \n    add(i + i,\n        m + i,\n@@ -54,19 +54,19 @@ fn add(i: ~[int], m: ~[mut int], c: ~[const int]) {\n                 //~^ mismatched types\n        ~[3]);\n \n-   add(m + ~[mut 3], //~ ERROR mismatched types\n-       m + ~[mut 3],\n-       m + ~[mut 3]);\n+   add(m + ~[3], //~ ERROR mismatched types\n+       m + ~[3],\n+       m + ~[3]);\n \n-   add(i + ~[mut 3],\n-       i + ~[mut 3], //~ ERROR mismatched types\n-       i + ~[mut 3]);\n+   add(i + ~[3],\n+       i + ~[3], //~ ERROR mismatched types\n+       i + ~[3]);\n \n-   add(c + ~[mut 3], //~ ERROR binary operation + cannot be applied\n+   add(c + ~[3], //~ ERROR binary operation + cannot be applied\n                     //~^ mismatched types\n-       c + ~[mut 3], //~ ERROR binary operation + cannot be applied\n+       c + ~[3], //~ ERROR binary operation + cannot be applied\n                     //~^ mismatched types\n-       ~[mut 3]);\n+       ~[3]);\n \n    add(m + i, //~ ERROR mismatched types\n        m + i,"}, {"sha": "b11a5356f698cc7fef143bec8fd1f38502b12b04", "filename": "src/test/run-pass/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -20,7 +20,7 @@ fn borrow(x: &int, f: fn(x: &int)) {\n struct F { f: ~int }\n \n pub fn main() {\n-    let mut x = ~mut @F{f: ~3};\n+    let mut x = ~@F{f: ~3};\n     do borrow(x.f) |b_x| {\n         assert *b_x == 3;\n         assert ptr::addr_of(&(*x.f)) == ptr::addr_of(&(*b_x));"}, {"sha": "e26a8ae11fdb22f73474390bea60bb0562d75223", "filename": "src/test/run-pass/cap-clause-not-used.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Frun-pass%2Fcap-clause-not-used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Ftest%2Frun-pass%2Fcap-clause-not-used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcap-clause-not-used.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: warning: Captured variable 'y' not used in closure\n-pub fn main() {\n-    let x = 5;\n-    let _y = fn~(copy x) { };\n-}"}, {"sha": "157ea586c2c4e48b0e506c7109dcabcc39467517", "filename": "src/test/run-pass/class-cast-to-trait.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,21 +9,21 @@\n // except according to those terms.\n \n trait noisy {\n-  fn speak();\n+  fn speak(&mut self);\n }\n \n struct cat {\n-  priv mut meows : uint,\n-  mut how_hungry : int,\n-  name : ~str,\n+  priv meows: uint,\n+  how_hungry: int,\n+  name: ~str,\n }\n \n impl noisy for cat {\n-  fn speak() { self.meow(); }\n+  fn speak(&mut self) { self.meow(); }\n }\n \n impl cat {\n-  fn eat() -> bool {\n+  fn eat(&mut self) -> bool {\n     if self.how_hungry > 0 {\n         error!(\"OM NOM NOM\");\n         self.how_hungry -= 2;\n@@ -37,7 +37,7 @@ impl cat {\n }\n \n priv impl cat {\n-    fn meow() {\n+    fn meow(&mut self) {\n       error!(\"Meow\");\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n@@ -56,6 +56,6 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n \n \n pub fn main() {\n-  let nyan : noisy  = cat(0u, 2, ~\"nyan\") as noisy;\n+  let mut nyan: noisy = cat(0u, 2, ~\"nyan\") as noisy;\n   nyan.speak();\n }"}, {"sha": "40f728d40bfe3b3f74755bbc410450f165d1d8a8", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -28,9 +28,9 @@ impl cmp::Eq for cat_type {\n // ok: T should be in scope when resolving the trait ref for map\n struct cat<T> {\n     // Yes, you can have negative meows\n-    priv mut meows : int,\n+    priv meows : int,\n \n-    mut how_hungry : int,\n+    how_hungry : int,\n     name : T,\n }\n \n@@ -95,11 +95,10 @@ impl<T> Map<int, T> for cat<T> {\n     }\n \n     fn remove(&mut self, k: &int) -> bool {\n-        match self.find(k) {\n-          Some(_) => {\n-              self.meows -= *k; true\n-          }\n-          None => { false }\n+        if self.find(k).is_some() {\n+            self.meows -= *k; true\n+        } else {\n+            false\n         }\n     }\n }"}, {"sha": "aa7bb738bf54f31a5f42ce1c52b7df3e82acd29a", "filename": "src/test/run-pass/class-implement-trait-cross-crate.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -14,39 +14,37 @@ extern mod cci_class_trait;\n use cci_class_trait::animals::*;\n \n struct cat {\n-  priv mut meows : uint,\n+  priv meows: uint,\n \n-  mut how_hungry : int,\n+  how_hungry : int,\n   name : ~str,\n }\n \n impl cat {\n-  fn eat() -> bool {\n-    if self.how_hungry > 0 {\n-        error!(\"OM NOM NOM\");\n-        self.how_hungry -= 2;\n-        return true;\n+    fn eat(&mut self) -> bool {\n+        if self.how_hungry > 0 {\n+            error!(\"OM NOM NOM\");\n+            self.how_hungry -= 2;\n+            return true;\n+        }\n+        else {\n+            error!(\"Not hungry!\");\n+            return false;\n+        }\n     }\n-    else {\n-        error!(\"Not hungry!\");\n-        return false;\n-    }\n-  }\n }\n \n impl noisy for cat {\n-\n-  fn speak() { self.meow(); }\n-\n+    fn speak(&mut self) { self.meow(); }\n }\n \n priv impl cat {\n-    fn meow() {\n-      error!(\"Meow\");\n-      self.meows += 1u;\n-      if self.meows % 5u == 0u {\n-          self.how_hungry += 1;\n-      }\n+    fn meow(&mut self) {\n+        error!(\"Meow\");\n+        self.meows += 1u;\n+        if self.meows % 5u == 0u {\n+            self.how_hungry += 1;\n+        }\n     }\n }\n \n@@ -60,7 +58,7 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n \n \n pub fn main() {\n-  let nyan = cat(0u, 2, ~\"nyan\");\n+  let mut nyan = cat(0u, 2, ~\"nyan\");\n   nyan.eat();\n   assert(!nyan.eat());\n   for uint::range(1u, 10u) |_i| { nyan.speak(); };"}, {"sha": "bdc8f7568a165d8c3c03477793d24df41433d357", "filename": "src/test/run-pass/class-implement-traits.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -12,42 +12,41 @@\n #[legacy_modes];\n \n trait noisy {\n-  fn speak();\n+  fn speak(&mut self);\n }\n \n struct cat {\n-  priv mut meows : uint,\n+    priv meows : uint,\n \n-  mut how_hungry : int,\n-  name : ~str,\n+    how_hungry : int,\n+    name : ~str,\n }\n \n priv impl cat {\n-    fn meow() {\n-      error!(\"Meow\");\n-      self.meows += 1u;\n-      if self.meows % 5u == 0u {\n-          self.how_hungry += 1;\n-      }\n+    fn meow(&mut self) {\n+        error!(\"Meow\");\n+        self.meows += 1u;\n+        if self.meows % 5u == 0u {\n+            self.how_hungry += 1;\n+        }\n     }\n }\n \n impl cat {\n-  fn eat() -> bool {\n-    if self.how_hungry > 0 {\n-        error!(\"OM NOM NOM\");\n-        self.how_hungry -= 2;\n-        return true;\n+    fn eat(&mut self) -> bool {\n+        if self.how_hungry > 0 {\n+            error!(\"OM NOM NOM\");\n+            self.how_hungry -= 2;\n+            return true;\n+        } else {\n+            error!(\"Not hungry!\");\n+            return false;\n+        }\n     }\n-    else {\n-        error!(\"Not hungry!\");\n-        return false;\n-    }\n-  }\n }\n \n impl noisy for cat {\n-  fn speak() { self.meow(); }\n+  fn speak(&mut self) { self.meow(); }\n }\n \n fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n@@ -59,12 +58,12 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n }\n \n \n-fn make_speak<C:noisy>(c: C) {\n+fn make_speak<C:noisy>(mut c: C) {\n     c.speak();\n }\n \n pub fn main() {\n-  let nyan = cat(0u, 2, ~\"nyan\");\n+  let mut nyan = cat(0u, 2, ~\"nyan\");\n   nyan.eat();\n   assert(!nyan.eat());\n   for uint::range(1u, 10u) |_i| { make_speak(nyan); };"}, {"sha": "fc5191e522d7640e9213d9fabbf5bd11082267d0", "filename": "src/test/run-pass/class-methods-cross-crate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-methods-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-methods-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-methods-cross-crate.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -14,10 +14,10 @@ extern mod cci_class_3;\n use cci_class_3::kitties::*;\n \n pub fn main() {\n-  let nyan : cat = cat(52u, 99);\n-  let kitty = cat(1000u, 2);\n-  assert(nyan.how_hungry == 99);\n-  assert(kitty.how_hungry == 2);\n-  nyan.speak();\n-  assert(nyan.meow_count() == 53u);\n+    let mut nyan : cat = cat(52u, 99);\n+    let mut kitty = cat(1000u, 2);\n+    assert(nyan.how_hungry == 99);\n+    assert(kitty.how_hungry == 2);\n+    nyan.speak();\n+    assert(nyan.meow_count() == 53u);\n }"}, {"sha": "1e41b60a8223ec08f44993ebd430f4abfe19d4bd", "filename": "src/test/run-pass/class-methods.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-methods.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,27 +9,26 @@\n // except according to those terms.\n \n struct cat {\n-  priv mut meows : uint,\n+  priv meows : uint,\n \n   how_hungry : int,\n }\n \n impl cat {\n-\n-  fn speak() { self.meows += 1u; }\n-  fn meow_count() -> uint { self.meows }\n+    fn speak(&mut self) { self.meows += 1u; }\n+    fn meow_count(&mut self) -> uint { self.meows }\n }\n \n-fn cat(in_x : uint, in_y : int) -> cat {\n+fn cat(in_x: uint, in_y: int) -> cat {\n     cat {\n         meows: in_x,\n         how_hungry: in_y\n     }\n }\n \n pub fn main() {\n-  let nyan : cat = cat(52u, 99);\n-  let kitty = cat(1000u, 2);\n+  let mut nyan: cat = cat(52u, 99);\n+  let mut kitty = cat(1000u, 2);\n   assert(nyan.how_hungry == 99);\n   assert(kitty.how_hungry == 2);\n   nyan.speak();"}, {"sha": "a96a1920d9233d78de3d20752b333cc43b09c882", "filename": "src/test/run-pass/class-poly-methods-cross-crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -14,8 +14,8 @@ extern mod cci_class_6;\n use cci_class_6::kitties::*;\n \n pub fn main() {\n-  let nyan : cat<char> = cat::<char>(52u, 99, ~['p']);\n-  let kitty = cat(1000u, 2, ~[~\"tabby\"]);\n+  let mut nyan : cat<char> = cat::<char>(52u, 99, ~['p']);\n+  let mut kitty = cat(1000u, 2, ~[~\"tabby\"]);\n   assert(nyan.how_hungry == 99);\n   assert(kitty.how_hungry == 2);\n   nyan.speak(~[1u,2u,3u]);"}, {"sha": "e81d07a783b99b99636782ae296bfdaf75b8dc6f", "filename": "src/test/run-pass/class-poly-methods.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,17 +9,17 @@\n // except according to those terms.\n \n struct cat<U> {\n-  priv mut info : ~[U],\n-  priv mut meows : uint,\n+    priv info : ~[U],\n+    priv meows : uint,\n \n-  how_hungry : int,\n+    how_hungry : int,\n }\n \n impl<U> cat<U> {\n-  fn speak<T>(stuff: ~[T]) {\n-    self.meows += stuff.len();\n-  }\n-  fn meow_count() -> uint { self.meows }\n+    fn speak<T>(&mut self, stuff: ~[T]) {\n+        self.meows += stuff.len();\n+    }\n+    fn meow_count(&mut self) -> uint { self.meows }\n }\n \n fn cat<U>(in_x : uint, in_y : int, -in_info: ~[U]) -> cat<U> {\n@@ -31,8 +31,8 @@ fn cat<U>(in_x : uint, in_y : int, -in_info: ~[U]) -> cat<U> {\n }\n \n pub fn main() {\n-  let nyan : cat<int> = cat::<int>(52u, 99, ~[9]);\n-  let kitty = cat(1000u, 2, ~[~\"tabby\"]);\n+  let mut nyan : cat<int> = cat::<int>(52u, 99, ~[9]);\n+  let mut kitty = cat(1000u, 2, ~[~\"tabby\"]);\n   assert(nyan.how_hungry == 99);\n   assert(kitty.how_hungry == 2);\n   nyan.speak(~[1,2,3]);"}, {"sha": "9c7d9ce7415a433a8dd96d3968fbf1b687d6e52b", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -12,36 +12,35 @@\n use core::to_str::*;\n \n struct cat {\n-  priv mut meows : uint,\n+    priv meows : uint,\n \n-  mut how_hungry : int,\n-  name : ~str,\n+    how_hungry : int,\n+    name : ~str,\n }\n \n impl cat {\n+    fn speak(&mut self) { self.meow(); }\n \n-  fn speak() { self.meow(); }\n-\n-  fn eat() -> bool {\n-    if self.how_hungry > 0 {\n-        error!(\"OM NOM NOM\");\n-        self.how_hungry -= 2;\n-        return true;\n-    }\n-    else {\n-        error!(\"Not hungry!\");\n-        return false;\n+    fn eat(&mut self) -> bool {\n+        if self.how_hungry > 0 {\n+            error!(\"OM NOM NOM\");\n+            self.how_hungry -= 2;\n+            return true;\n+        }\n+        else {\n+            error!(\"Not hungry!\");\n+            return false;\n+        }\n     }\n-  }\n }\n \n priv impl cat {\n-    fn meow() {\n-      error!(\"Meow\");\n-      self.meows += 1u;\n-      if self.meows % 5u == 0u {\n-          self.how_hungry += 1;\n-      }\n+    fn meow(&mut self) {\n+        error!(\"Meow\");\n+        self.meows += 1u;\n+        if self.meows % 5u == 0u {\n+            self.how_hungry += 1;\n+        }\n     }\n }\n \n@@ -64,6 +63,6 @@ fn print_out<T:ToStr>(thing: T, expected: ~str) {\n }\n \n pub fn main() {\n-  let nyan : ToStr = cat(0u, 2, ~\"nyan\") as ToStr;\n+  let mut nyan : ToStr = cat(0u, 2, ~\"nyan\") as ToStr;\n   print_out(nyan, ~\"nyan\");\n }"}, {"sha": "cbc69719caa626823b77f67a47df9c329b771ce0", "filename": "src/test/run-pass/class-typarams.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-typarams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclass-typarams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-typarams.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,16 +9,14 @@\n // except according to those terms.\n \n struct cat<U> {\n-  priv mut meows : uint,\n+    priv meows : uint,\n \n-  how_hungry : int,\n+    how_hungry : int,\n }\n \n impl<U> cat<U> {\n-  fn speak() {\n-    self.meows += 1u;\n-  }\n-  fn meow_count() -> uint { self.meows }\n+    fn speak(&mut self) { self.meows += 1u; }\n+    fn meow_count(&mut self) -> uint { self.meows }\n }\n \n fn cat<U>(in_x : uint, in_y : int) -> cat<U> {\n@@ -30,6 +28,6 @@ fn cat<U>(in_x : uint, in_y : int) -> cat<U> {\n \n \n pub fn main() {\n-  let _nyan : cat<int> = cat::<int>(52u, 99);\n-  //  let kitty = cat(1000u, 2);\n+  let mut _nyan : cat<int> = cat::<int>(52u, 99);\n+  //  let mut kitty = cat(1000u, 2);\n }"}, {"sha": "2ab6ce01b2432df60c11e7de9d9940822d2c3385", "filename": "src/test/run-pass/classes-cross-crate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -14,9 +14,9 @@ extern mod cci_class_4;\n use cci_class_4::kitties::*;\n \n pub fn main() {\n-  let nyan = cat(0u, 2, ~\"nyan\");\n-  nyan.eat();\n-  assert(!nyan.eat());\n-  for uint::range(1u, 10u) |_i| { nyan.speak(); };\n-  assert(nyan.eat());\n+    let mut nyan = cat(0u, 2, ~\"nyan\");\n+    nyan.eat();\n+    assert(!nyan.eat());\n+    for uint::range(1u, 10u) |_i| { nyan.speak(); };\n+    assert(nyan.eat());\n }"}, {"sha": "ac80ca9b9e930f54dc5a538bc8a5c31793f2e83a", "filename": "src/test/run-pass/classes-simple-method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n struct cat {\n-  priv mut meows : uint,\n+    priv meows : uint,\n \n-  how_hungry : int,\n+    how_hungry : int,\n }\n \n impl cat {\n-  fn speak() {}\n+  fn speak(&mut self) {}\n }\n \n fn cat(in_x : uint, in_y : int) -> cat {\n@@ -26,8 +26,8 @@ fn cat(in_x : uint, in_y : int) -> cat {\n }\n \n pub fn main() {\n-  let nyan : cat = cat(52u, 99);\n-  let kitty = cat(1000u, 2);\n+  let mut nyan : cat = cat(52u, 99);\n+  let mut kitty = cat(1000u, 2);\n   assert(nyan.how_hungry == 99);\n   assert(kitty.how_hungry == 2);\n   nyan.speak();"}, {"sha": "b17e81160e510b12c0417e8fb74ef98eb550e868", "filename": "src/test/run-pass/classes-simple.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclasses-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclasses-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-simple.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,10 +9,9 @@\n // except according to those terms.\n \n struct cat {\n-  priv mut meows : uint,\n-\n-  how_hungry : int,\n+    priv meows : uint,\n \n+    how_hungry : int,\n }\n \n fn cat(in_x : uint, in_y : int) -> cat {\n@@ -23,8 +22,8 @@ fn cat(in_x : uint, in_y : int) -> cat {\n }\n \n pub fn main() {\n-  let nyan : cat = cat(52u, 99);\n-  let kitty = cat(1000u, 2);\n+  let mut nyan : cat = cat(52u, 99);\n+  let mut kitty = cat(1000u, 2);\n   assert(nyan.how_hungry == 99);\n   assert(kitty.how_hungry == 2);\n }"}, {"sha": "552715dccb445a90bd0f748d10105a0ab16d69da", "filename": "src/test/run-pass/classes.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fclasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,36 +9,34 @@\n // except according to those terms.\n \n struct cat {\n-  priv mut meows : uint,\n+    priv meows : uint,\n \n-  mut how_hungry : int,\n-  name : ~str,\n+    how_hungry : int,\n+    name : ~str,\n }\n \n impl cat {\n-\n-  fn speak() { self.meow(); }\n-\n-  fn eat() -> bool {\n-    if self.how_hungry > 0 {\n-        error!(\"OM NOM NOM\");\n-        self.how_hungry -= 2;\n-        return true;\n-    }\n-    else {\n-        error!(\"Not hungry!\");\n-        return false;\n+    fn speak(&mut self) { self.meow(); }\n+\n+    fn eat(&mut self) -> bool {\n+        if self.how_hungry > 0 {\n+            error!(\"OM NOM NOM\");\n+            self.how_hungry -= 2;\n+            return true;\n+        } else {\n+            error!(\"Not hungry!\");\n+            return false;\n+        }\n     }\n-  }\n }\n \n priv impl cat {\n-    fn meow() {\n-      error!(\"Meow\");\n-      self.meows += 1u;\n-      if self.meows % 5u == 0u {\n-          self.how_hungry += 1;\n-      }\n+    fn meow(&mut self) {\n+        error!(\"Meow\");\n+        self.meows += 1u;\n+        if self.meows % 5u == 0u {\n+            self.how_hungry += 1;\n+        }\n     }\n }\n \n@@ -51,7 +49,7 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n }\n \n pub fn main() {\n-  let nyan = cat(0u, 2, ~\"nyan\");\n+  let mut nyan = cat(0u, 2, ~\"nyan\");\n   nyan.eat();\n   assert(!nyan.eat());\n   for uint::range(1u, 10u) |_i| { nyan.speak(); };"}, {"sha": "8a3139157fdf602dc59e9ad40a60d73c82eb1fa2", "filename": "src/test/run-pass/cycle-collection4.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fcycle-collection4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fcycle-collection4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection4.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct foo { mut z : fn@() }\n+struct foo { z : fn@() }\n \n fn nop() { }\n-fn nop_foo(_y: ~[int], _x : @foo) { }\n+fn nop_foo(_y: ~[int], _x : @mut foo) { }\n \n pub fn main() {\n-    let w = @foo{ z: || nop() };\n+    let w = @mut foo{ z: || nop() };\n     let x : fn@() = || nop_foo(~[], w);\n     w.z = x;\n }"}, {"sha": "d40b2f72ae8bac67b76e4772bd6eccff70086369", "filename": "src/test/run-pass/explicit-self-closures.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -21,9 +21,6 @@ impl Box {\n     fn set_many2(@mut self, xs: &[uint]) {\n         for xs.each |x| { self.x = *x; }\n     }\n-    fn set_many3(~mut self, xs: &[uint]) {\n-        for xs.each |x| { self.x = *x; }\n-    }\n }\n \n pub fn main() {}"}, {"sha": "72f6d23cacce133e2e6f9ab0bf77a85c899e0adb", "filename": "src/test/run-pass/import-in-block.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fimport-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fimport-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-in-block.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,10 +9,8 @@\n // except according to those terms.\n \n pub fn main() {\n-    // Once cast_to_mut is removed, pick a better function to import\n-    // for this test!\n-    use vec::cast_to_mut;\n-    log(debug, vec::len(cast_to_mut(~[1, 2])));\n+    use vec::from_fn;\n+    log(debug, vec::len(from_fn(2, |i| i)));\n     {\n         use vec::*;\n         log(debug, len(~[2]));"}, {"sha": "7d5bf65dad7c168dc1e2db0dcc39b3f8521fb2c7", "filename": "src/test/run-pass/intrinsic-atomics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -29,7 +29,7 @@ extern mod rusti {\n \n pub fn main() {\n     unsafe {\n-        let x = ~mut 1;\n+        let mut x = ~1;\n \n         assert rusti::atomic_cxchg(x, 1, 2) == 1;\n         assert *x == 2;"}, {"sha": "95129851d5bcd979281e2ca0337db6b2d05b73cb", "filename": "src/test/run-pass/issue-1989.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fissue-1989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fissue-1989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1989.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -12,23 +12,22 @@\n \n enum maybe_pointy {\n     none,\n-    p(@Pointy)\n+    p(@mut Pointy)\n }\n \n struct Pointy {\n-    mut a : maybe_pointy,\n-    mut f : fn@()->(),\n+    a : maybe_pointy,\n+    f : fn@()->(),\n }\n \n-fn empty_pointy() -> @Pointy {\n-    return @Pointy{\n-        mut a : none,\n-        mut f : fn@()->(){},\n+fn empty_pointy() -> @mut Pointy {\n+    return @mut Pointy{\n+        a : none,\n+        f : fn@()->(){},\n     }\n }\n \n-pub fn main()\n-{\n+pub fn main() {\n     let v = ~[empty_pointy(), empty_pointy()];\n     v[0].a = p(v[0]);\n }"}, {"sha": "4a7263266b78f42539eafb794ae1fc7d6e7e3c28", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -155,7 +155,7 @@ pub mod pipes {\n         p: Option<*packet<T>>,\n     }\n \n-    pub impl<T:Owned> Drop for send_packet<T> {\n+    impl<T:Owned> Drop for send_packet<T> {\n         fn finalize(&self) {\n             unsafe {\n                 if self.p != None {\n@@ -187,7 +187,7 @@ pub mod pipes {\n         p: Option<*packet<T>>,\n     }\n \n-    pub impl<T:Owned> Drop for recv_packet<T> {\n+    impl<T:Owned> Drop for recv_packet<T> {\n         fn finalize(&self) {\n             unsafe {\n                 if self.p != None {\n@@ -318,18 +318,16 @@ pub fn main() {\n //    Commented out because of option::get error\n \n     let (client_, server_) = pingpong::init();\n-    let client_ = ~mut Some(client_);\n-    let server_ = ~mut Some(server_);\n+    let client_ = Cell(client_);\n+    let server_ = Cell(server_);\n \n     task::spawn {|client_|\n-        let mut client__ = none;\n-        *client_ <-> client__;\n-        client(option::unwrap(client__));\n+        let client__ = client_.take();\n+        client(client__);\n     };\n     task::spawn {|server_|\n-        let mut server_\u02ca = none;\n-        *server_ <-> server_\u02ca;\n-        server(option::unwrap(server_\u02ca));\n+        let server__ = server_.take();\n+        server(server_\u02ca);\n     };\n   */\n }"}, {"sha": "e2e5dfcc7d5195bb4193c1abfc97fa9a17ec8a8c", "filename": "src/test/run-pass/issue-980.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fissue-980.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fissue-980.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-980.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -10,14 +10,14 @@\n \n enum maybe_pointy {\n     no_pointy,\n-    yes_pointy(@Pointy),\n+    yes_pointy(@mut Pointy),\n }\n \n struct Pointy {\n-    mut x : maybe_pointy\n+    x : maybe_pointy\n }\n \n pub fn main() {\n-    let m = @Pointy { mut x : no_pointy };\n+    let m = @mut Pointy { x : no_pointy };\n     m.x = yes_pointy(m);\n }"}, {"sha": "1f803f28e7a25aea2066cf0b2e35d7dd1efcc9c4", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -36,7 +36,7 @@ impl<A> option_monad<A> for Option<A> {\n }\n \n fn transform(x: Option<int>) -> Option<~str> {\n-    x.bind(|n| Some(*n + 1) ).bind(|n| Some(int::str(*n)) )\n+    x.bind(|n| Some(*n + 1) ).bind(|n| Some(int::to_str(*n)) )\n }\n \n pub fn main() {"}, {"sha": "2b270a54d80a0128c0b0553af5d0ad6ff1e17c8a", "filename": "src/test/run-pass/pipe-pingpong-bounded.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -14,6 +14,7 @@\n // experiment with what code the compiler should generate for bounded\n // protocols.\n \n+use core::cell::Cell;\n \n // This was generated initially by the pipe compiler, but it's been\n // modified in hopefully straightforward ways.\n@@ -111,16 +112,14 @@ mod test {\n \n pub fn main() {\n     let (client_, server_) = ::pingpong::init();\n-    let client_ = ~mut Some(client_);\n-    let server_ = ~mut Some(server_);\n-    do task::spawn || {\n-        let mut client__ = None;\n-        *client_ <-> client__;\n-        test::client(option::unwrap(client__));\n+    let client_ = Cell(client_);\n+    let server_ = Cell(server_);\n+    do task::spawn {\n+        let client__ = client_.take();\n+        test::client(client__);\n     };\n-    do task::spawn || {\n-        let mut server_\u02ca = None;\n-        *server_ <-> server_\u02ca;\n-        test::server(option::unwrap(server_\u02ca));\n+    do task::spawn {\n+        let server__ = server_.take();\n+        test::server(server__);\n     };\n }"}, {"sha": "c51c0733622780b27c6f4b3ba71706bf3d75e925", "filename": "src/test/run-pass/pipe-pingpong-proto.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -12,6 +12,7 @@\n \n // An example to make sure the protocol parsing syntax extension works.\n \n+use core::cell::Cell;\n use core::option;\n \n proto! pingpong (\n@@ -49,17 +50,15 @@ mod test {\n \n pub fn main() {\n     let (client_, server_) = pingpong::init();\n-    let client_ = ~mut Some(client_);\n-    let server_ = ~mut Some(server_);\n+    let client_ = Cell(client_);\n+    let server_ = Cell(server_);\n \n-    do task::spawn || {\n-        let mut client__ = None;\n-        *client_ <-> client__;\n-        test::client(option::unwrap(client__));\n+    do task::spawn {\n+        let client__ = client_.take();\n+        test::client(client__);\n     };\n-    do task::spawn || {\n-        let mut server_\u02ca = None;\n-        *server_ <-> server_\u02ca;\n-        test::server(option::unwrap(server_\u02ca));\n+    do task::spawn {\n+        let server__ = server_.take();\n+        test::server(server__);\n     };\n }"}, {"sha": "8749c1cb1133bed0aa480ae3278e0eaf9a77cbe9", "filename": "src/test/run-pass/pipe-presentation-examples.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -79,7 +79,7 @@ pub struct Buffer {\n \n }\n \n-pub impl Drop for Buffer {\n+impl Drop for Buffer {\n     fn finalize(&self) {}\n }\n "}, {"sha": "9cb86ffe83707f8ab14d1b4ee3ac66f11eed6664", "filename": "src/test/run-pass/private-class-field.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fprivate-class-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fprivate-class-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivate-class-field.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n struct cat {\n-  priv mut meows : uint,\n+    priv meows : uint,\n \n-  how_hungry : int,\n+    how_hungry : int,\n }\n \n impl cat {\n-  fn meow_count() -> uint { self.meows }\n+  fn meow_count(&mut self) -> uint { self.meows }\n }\n \n fn cat(in_x : uint, in_y : int) -> cat {\n@@ -26,6 +26,6 @@ fn cat(in_x : uint, in_y : int) -> cat {\n }\n \n pub fn main() {\n-  let nyan : cat = cat(52u, 99);\n-  assert (nyan.meow_count() == 52u);\n+    let mut nyan : cat = cat(52u, 99);\n+    assert (nyan.meow_count() == 52u);\n }"}, {"sha": "432c189ae423c742537d60264217430fa6edc524", "filename": "src/test/run-pass/private-method.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivate-method.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,20 +9,20 @@\n // except according to those terms.\n \n struct cat {\n-  priv mut meows : uint,\n+    priv meows : uint,\n \n-  how_hungry : int,\n+    how_hungry : int,\n }\n \n impl cat {\n-  fn play() {\n-    self.meows += 1u;\n-    self.nap();\n-  }\n+    fn play(&mut self) {\n+        self.meows += 1u;\n+        self.nap();\n+    }\n }\n \n priv impl cat {\n-    fn nap() { for uint::range(1u, 10u) |_i| { }}\n+    fn nap(&mut self) { for uint::range(1u, 10u) |_i| { }}\n }\n \n fn cat(in_x : uint, in_y : int) -> cat {\n@@ -33,6 +33,6 @@ fn cat(in_x : uint, in_y : int) -> cat {\n }\n \n pub fn main() {\n-  let nyan : cat = cat(52u, 99);\n+  let mut nyan : cat = cat(52u, 99);\n   nyan.play();\n }"}, {"sha": "cac6b4ef349329941af62738891cb20242107adf", "filename": "src/test/run-pass/pure-sum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fpure-sum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fpure-sum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpure-sum.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -20,7 +20,7 @@ pure fn sums_to(v: ~[int], sum: int) -> bool {\n }\n \n pure fn sums_to_using_uniq(v: ~[int], sum: int) -> bool {\n-    let mut i = 0u, sum0 = ~mut 0;\n+    let mut i = 0u, sum0 = ~0;\n     while i < v.len() {\n         *sum0 += v[i];\n         i += 1u;\n@@ -40,7 +40,7 @@ pure fn sums_to_using_rec(v: ~[int], sum: int) -> bool {\n struct F<T> { f: T }\n \n pure fn sums_to_using_uniq_rec(v: ~[int], sum: int) -> bool {\n-    let mut i = 0u, sum0 = F {f: ~mut 0};\n+    let mut i = 0u, sum0 = F {f: ~0};\n     while i < v.len() {\n         *sum0.f += v[i];\n         i += 1u;"}, {"sha": "7011f5ba1add0a44ebfa64b9f444fc3207c38f7a", "filename": "src/test/run-pass/rcvr-borrowed-to-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -31,7 +31,7 @@ pub fn main() {\n     debug!(\"y=%d\", y);\n     assert y == 6;\n \n-    let x = ~mut 6;\n+    let mut x = ~6;\n     let y = x.get();\n     debug!(\"y=%d\", y);\n     assert y == 6;"}, {"sha": "d1b2870fef627043646bbb4f1484f60c64bebcf2", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -16,12 +16,12 @@ pub trait plus {\n \n mod a {\n     use plus;\n-    pub impl plus for uint { fn plus() -> int { self as int + 20 } }\n+    impl plus for uint { fn plus() -> int { self as int + 20 } }\n }\n \n mod b {\n     use plus;\n-    pub impl plus for ~str { fn plus() -> int { 200 } }\n+    impl plus for ~str { fn plus() -> int { 200 } }\n }\n \n trait uint_utils {\n@@ -30,7 +30,7 @@ trait uint_utils {\n }\n \n impl uint_utils for uint {\n-    fn str() -> ~str { uint::str(self) }\n+    fn str() -> ~str { uint::to_str(self) }\n     fn multi(f: fn(uint)) {\n         let mut c = 0u;\n         while c < self { f(c); c += 1u; }"}, {"sha": "20ab9014c700b156a327e659b317a597acde3c7d", "filename": "src/test/run-pass/static-methods-in-traits2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fstatic-methods-in-traits2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Fstatic-methods-in-traits2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-methods-in-traits2.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -2,15 +2,15 @@ pub trait Number: NumConv {\n     static pure fn from<T:Number>(n: T) -> Self;\n }\n \n-pub impl Number for float {\n+impl Number for float {\n     static pure fn from<T:Number>(n: T) -> float { n.to_float() }\n }\n \n pub trait NumConv {\n     pure fn to_float(&self) -> float;\n }\n \n-pub impl NumConv for float {\n+impl NumConv for float {\n     pure fn to_float(&self) -> float { *self }\n }\n "}, {"sha": "991025a1ad282cc4c396d6fc0853c9429a6b1ed4", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -13,6 +13,7 @@\n // A port of task-killjoin to use a class with a dtor to manage\n // the join.\n \n+use core::cell::Cell;\n use core::comm::*;\n \n struct notify {\n@@ -49,11 +50,9 @@ fn joinable(f: fn~()) -> Port<bool> {\n         *b = true;\n     }\n     let (p, c) = stream();\n-    let c = ~mut Some(c);\n+    let c = Cell(c);\n     do task::spawn_unlinked {\n-        let mut cc = None;\n-        *c <-> cc;\n-        let ccc = option::unwrap(cc);\n+        let ccc = c.take();\n         wrapper(ccc, f)\n     }\n     p"}, {"sha": "4a6651fe20555c91e1583480d5d1a310652531c1", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -14,7 +14,7 @@ trait to_str {\n     fn to_str() -> ~str;\n }\n impl to_str for int {\n-    fn to_str() -> ~str { int::str(self) }\n+    fn to_str() -> ~str { int::to_str(self) }\n }\n impl to_str for ~str {\n     fn to_str() -> ~str { copy self }"}, {"sha": "f20181d22d344d7b3f92464309ab16ce1c483d5e", "filename": "src/test/run-pass/trait-inheritance-num2.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -21,84 +21,84 @@ use std::cmp::FuzzyEq;\n pub trait TypeExt {}\n \n \n-pub impl TypeExt for u8 {}\n-pub impl TypeExt for u16 {}\n-pub impl TypeExt for u32 {}\n-pub impl TypeExt for u64 {}\n-pub impl TypeExt for uint {}\n+impl TypeExt for u8 {}\n+impl TypeExt for u16 {}\n+impl TypeExt for u32 {}\n+impl TypeExt for u64 {}\n+impl TypeExt for uint {}\n \n-pub impl TypeExt for i8 {}\n-pub impl TypeExt for i16 {}\n-pub impl TypeExt for i32 {}\n-pub impl TypeExt for i64 {}\n-pub impl TypeExt for int {}\n+impl TypeExt for i8 {}\n+impl TypeExt for i16 {}\n+impl TypeExt for i32 {}\n+impl TypeExt for i64 {}\n+impl TypeExt for int {}\n \n-pub impl TypeExt for f32 {}\n-pub impl TypeExt for f64 {}\n-pub impl TypeExt for float {}\n+impl TypeExt for f32 {}\n+impl TypeExt for f64 {}\n+impl TypeExt for float {}\n \n \n pub trait NumExt: TypeExt Eq Ord NumCast {}\n \n-pub impl NumExt for u8 {}\n-pub impl NumExt for u16 {}\n-pub impl NumExt for u32 {}\n-pub impl NumExt for u64 {}\n-pub impl NumExt for uint {}\n+impl NumExt for u8 {}\n+impl NumExt for u16 {}\n+impl NumExt for u32 {}\n+impl NumExt for u64 {}\n+impl NumExt for uint {}\n \n-pub impl NumExt for i8 {}\n-pub impl NumExt for i16 {}\n-pub impl NumExt for i32 {}\n-pub impl NumExt for i64 {}\n-pub impl NumExt for int {}\n+impl NumExt for i8 {}\n+impl NumExt for i16 {}\n+impl NumExt for i32 {}\n+impl NumExt for i64 {}\n+impl NumExt for int {}\n \n-pub impl NumExt for f32 {}\n-pub impl NumExt for f64 {}\n-pub impl NumExt for float {}\n+impl NumExt for f32 {}\n+impl NumExt for f64 {}\n+impl NumExt for float {}\n \n \n pub trait UnSignedExt: NumExt {}\n \n-pub impl UnSignedExt for u8 {}\n-pub impl UnSignedExt for u16 {}\n-pub impl UnSignedExt for u32 {}\n-pub impl UnSignedExt for u64 {}\n-pub impl UnSignedExt for uint {}\n+impl UnSignedExt for u8 {}\n+impl UnSignedExt for u16 {}\n+impl UnSignedExt for u32 {}\n+impl UnSignedExt for u64 {}\n+impl UnSignedExt for uint {}\n \n \n pub trait SignedExt: NumExt {}\n \n-pub impl SignedExt for i8 {}\n-pub impl SignedExt for i16 {}\n-pub impl SignedExt for i32 {}\n-pub impl SignedExt for i64 {}\n-pub impl SignedExt for int {}\n+impl SignedExt for i8 {}\n+impl SignedExt for i16 {}\n+impl SignedExt for i32 {}\n+impl SignedExt for i64 {}\n+impl SignedExt for int {}\n \n-pub impl SignedExt for f32 {}\n-pub impl SignedExt for f64 {}\n-pub impl SignedExt for float {}\n+impl SignedExt for f32 {}\n+impl SignedExt for f64 {}\n+impl SignedExt for float {}\n \n \n pub trait IntegerExt: NumExt {}\n \n-pub impl IntegerExt for u8 {}\n-pub impl IntegerExt for u16 {}\n-pub impl IntegerExt for u32 {}\n-pub impl IntegerExt for u64 {}\n-pub impl IntegerExt for uint {}\n+impl IntegerExt for u8 {}\n+impl IntegerExt for u16 {}\n+impl IntegerExt for u32 {}\n+impl IntegerExt for u64 {}\n+impl IntegerExt for uint {}\n \n-pub impl IntegerExt for i8 {}\n-pub impl IntegerExt for i16 {}\n-pub impl IntegerExt for i32 {}\n-pub impl IntegerExt for i64 {}\n-pub impl IntegerExt for int {}\n+impl IntegerExt for i8 {}\n+impl IntegerExt for i16 {}\n+impl IntegerExt for i32 {}\n+impl IntegerExt for i64 {}\n+impl IntegerExt for int {}\n \n \n pub trait FloatExt: NumExt FuzzyEq<Self> {}\n \n-pub impl FloatExt for f32 {}\n-pub impl FloatExt for f64 {}\n-pub impl FloatExt for float {}\n+impl FloatExt for f32 {}\n+impl FloatExt for f64 {}\n+impl FloatExt for float {}\n \n \n fn test_float_ext<T:FloatExt>(n: T) { io::println(fmt!(\"%?\", n < n)) }"}, {"sha": "adb9f01fff8a87ca3e865b98e954a05229bc65fa", "filename": "src/test/run-pass/trait-inheritance-num3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -13,7 +13,7 @@ use num::NumCast::from;\n \n pub trait NumExt: Eq Ord NumCast {}\n \n-pub impl NumExt for f32 {}\n+impl NumExt for f32 {}\n \n fn num_eq_one<T:NumExt>(n: T) { io::println(fmt!(\"%?\", n == from(1))) }\n "}, {"sha": "d10126dddb6ccd60abd291f4989a42547ab112fe", "filename": "src/test/run-pass/trait-inheritance-num5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -13,8 +13,8 @@ use num::NumCast::from;\n \n pub trait NumExt: Eq NumCast {}\n \n-pub impl NumExt for f32 {}\n-pub impl NumExt for int {}\n+impl NumExt for f32 {}\n+impl NumExt for int {}\n \n fn num_eq_one<T:NumExt>() -> T {\n     from(1)"}, {"sha": "9565919a5d8c7f5cc8b945007b9287cb2e26dac8", "filename": "src/test/run-pass/trait-static-method-overwriting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -19,7 +19,7 @@ mod base {\n         dummy: (),\n     }\n \n-    pub impl ::base::HasNew<Foo> for Foo {\n+    impl ::base::HasNew<Foo> for Foo {\n         static pure fn new() -> Foo {\n \t\t\tunsafe { io::println(\"Foo\"); }\n             Foo { dummy: () }\n@@ -30,7 +30,7 @@ mod base {\n         dummy: (),\n     }\n \n-    pub impl ::base::HasNew<Bar> for Bar {\n+    impl ::base::HasNew<Bar> for Bar {\n         static pure fn new() -> Bar {\n \t\t\tunsafe { io::println(\"Bar\"); }\n             Bar { dummy: () }"}, {"sha": "23d03ba217209472449d5f4c782d367c76791ae9", "filename": "src/test/run-pass/trait-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -21,7 +21,7 @@ trait to_str {\n }\n \n impl to_str for int {\n-    fn to_str() -> ~str { int::str(self) }\n+    fn to_str() -> ~str { int::to_str(self) }\n }\n \n impl<T:to_str> to_str for ~[T] {"}, {"sha": "1b602ab7d3009bb8560d20dfdeb607d20098a38e", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -10,27 +10,26 @@\n \n enum maybe_pointy {\n     none,\n-    p(@Pointy),\n+    p(@mut Pointy),\n }\n \n struct Pointy {\n-    mut a : maybe_pointy,\n+    a : maybe_pointy,\n     d : fn~() -> uint,\n }\n \n fn make_uniq_closure<A:Owned + Copy>(a: A) -> fn~() -> uint {\n     fn~() -> uint { ptr::addr_of(&a) as uint }\n }\n \n-fn empty_pointy() -> @Pointy {\n-    return @Pointy {\n+fn empty_pointy() -> @mut Pointy {\n+    return @mut Pointy {\n         mut a : none,\n         d : make_uniq_closure(~\"hi\")\n     }\n }\n \n-pub fn main()\n-{\n+pub fn main() {\n     let v = empty_pointy();\n     v.a = p(v);\n }"}, {"sha": "3d72a41182868076cf16446004d4c5c7331bbafa", "filename": "src/test/run-pass/uniq-cc.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Funiq-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Funiq-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -10,25 +10,24 @@\n \n enum maybe_pointy {\n     none,\n-    p(@Pointy),\n+    p(@mut Pointy),\n }\n \n struct Pointy {\n-    mut a : maybe_pointy,\n+    a : maybe_pointy,\n     c : ~int,\n     d : fn~()->(),\n }\n \n-fn empty_pointy() -> @Pointy {\n-    return @Pointy {\n-        mut a : none,\n+fn empty_pointy() -> @mut Pointy {\n+    return @mut Pointy {\n+        a : none,\n         c : ~22,\n         d : fn~()->(){},\n     }\n }\n \n-pub fn main()\n-{\n+pub fn main() {\n     let v = empty_pointy();\n     v.a = p(v);\n }"}, {"sha": "1bb04aef28687f4d5849decda0f39d8271b7ce88", "filename": "src/test/run-pass/unique-assign-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Funique-assign-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Funique-assign-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-assign-copy.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let i = ~mut 1;\n+    let mut i = ~1;\n     // Should be a copy\n     let mut j;\n     j = copy i;"}, {"sha": "67e59cb08e0c0b416ae9884760d87fe2676ae87c", "filename": "src/test/run-pass/unique-decl-init-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Funique-decl-init-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Funique-decl-init-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-decl-init-copy.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n pub fn main() {\n-    let i = ~mut 1;\n+    let mut i = ~1;\n     // Should be a copy\n-    let j = copy i;\n+    let mut j = copy i;\n     *i = 2;\n     *j = 3;\n     assert *i == 2;"}, {"sha": "ac8796674abb8213678407062b8da61f50a8d2ed", "filename": "src/test/run-pass/unique-in-vec-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let a = ~[~mut 10];\n+    let mut a = ~[~10];\n     let b = copy a;\n \n     assert *a[0] == 10;"}, {"sha": "8784dbeb0af404e85b238f801a046287bf98cb03", "filename": "src/test/run-pass/unique-mutable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Funique-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0ec86c4a382f3d937c4bf5f12ab69468d991c1/src%2Ftest%2Frun-pass%2Funique-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-mutable.rs?ref=7d0ec86c4a382f3d937c4bf5f12ab69468d991c1", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let i = ~mut 0;\n+    let mut i = ~0;\n     *i = 1;\n     assert *i == 1;\n }"}]}