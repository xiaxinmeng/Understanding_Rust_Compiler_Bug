{"sha": "875f50a8ee18297d7dc10e5fd7a200d902921f04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NWY1MGE4ZWUxODI5N2Q3ZGMxMGU1ZmQ3YTIwMGQ5MDI5MjFmMDQ=", "commit": {"author": {"name": "David Stygstra", "email": "david.stygstra@gmail.com", "date": "2015-06-09T21:45:45Z"}, "committer": {"name": "David Stygstra", "email": "david.stygstra@gmail.com", "date": "2015-06-20T01:38:28Z"}, "message": "Support checked Shl/Shr on SIMD types", "tree": {"sha": "9abdcb7ce8a138e1464d8eaed159b407fc1ef6b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9abdcb7ce8a138e1464d8eaed159b407fc1ef6b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/875f50a8ee18297d7dc10e5fd7a200d902921f04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/875f50a8ee18297d7dc10e5fd7a200d902921f04", "html_url": "https://github.com/rust-lang/rust/commit/875f50a8ee18297d7dc10e5fd7a200d902921f04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/875f50a8ee18297d7dc10e5fd7a200d902921f04/comments", "author": null, "committer": null, "parents": [{"sha": "4b42cbd5eb3e947875aa427dbda52121ef186586", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b42cbd5eb3e947875aa427dbda52121ef186586", "html_url": "https://github.com/rust-lang/rust/commit/4b42cbd5eb3e947875aa427dbda52121ef186586"}], "stats": {"total": 479, "additions": 468, "deletions": 11}, "files": [{"sha": "92b034e91186179af54b54e8f030d502a53e618f", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 52, "deletions": 11, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=875f50a8ee18297d7dc10e5fd7a200d902921f04", "patch": "@@ -52,7 +52,7 @@ pub use self::Dest::*;\n use self::lazy_binop_ty::*;\n \n use back::abi;\n-use llvm::{self, ValueRef};\n+use llvm::{self, ValueRef, TypeKind};\n use middle::check_const;\n use middle::def;\n use middle::lang_items::CoerceUnsizedTraitLangItem;\n@@ -2455,12 +2455,10 @@ impl OverflowOpViaInputCheck {\n         // (since that is where the 32/64 distinction is relevant) but\n         // the mask's type must match the RHS type (since they will\n         // both be fed into a and-binop)\n-        let invert_mask = !shift_mask_val(lhs_llty);\n-        let invert_mask = C_integral(rhs_llty, invert_mask, true);\n+        let invert_mask = shift_mask_val(bcx, lhs_llty, rhs_llty, true);\n \n         let outer_bits = And(bcx, rhs, invert_mask, binop_debug_loc);\n-        let cond = ICmp(bcx, llvm::IntNE, outer_bits,\n-                        C_integral(rhs_llty, 0, false), binop_debug_loc);\n+        let cond = build_nonzero_check(bcx, outer_bits, binop_debug_loc);\n         let result = match *self {\n             OverflowOpViaInputCheck::Shl =>\n                 build_unchecked_lshift(bcx, lhs, rhs, binop_debug_loc),\n@@ -2476,9 +2474,46 @@ impl OverflowOpViaInputCheck {\n     }\n }\n \n-fn shift_mask_val(llty: Type) -> u64 {\n-    // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n-    llty.int_width() - 1\n+fn shift_mask_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              llty: Type,\n+                              mask_llty: Type,\n+                              invert: bool) -> ValueRef {\n+    let kind = llty.kind();\n+    match kind {\n+        TypeKind::Integer => {\n+            // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n+            let val = llty.int_width() - 1;\n+            if invert {\n+                C_integral(mask_llty, !val, true)\n+            } else {\n+                C_integral(mask_llty, val, false)\n+            }\n+        },\n+        TypeKind::Vector => {\n+            let mask = shift_mask_val(bcx, llty.element_type(), mask_llty.element_type(), invert);\n+            VectorSplat(bcx, mask_llty.vector_length(), mask)\n+        },\n+        _ => panic!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n+    }\n+}\n+\n+// Check if an integer or vector contains a nonzero element.\n+fn build_nonzero_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   value: ValueRef,\n+                                   binop_debug_loc: DebugLoc) -> ValueRef {\n+    let llty = val_ty(value);\n+    let kind = llty.kind();\n+    match kind {\n+        TypeKind::Integer => ICmp(bcx, llvm::IntNE, value, C_null(llty), binop_debug_loc),\n+        TypeKind::Vector => {\n+            // Check if any elements of the vector are nonzero by treating\n+            // it as a wide integer and checking if the integer is nonzero.\n+            let width = llty.vector_length() as u64 * llty.element_type().int_width();\n+            let int_value = BitCast(bcx, value, Type::ix(bcx.ccx(), width));\n+            build_nonzero_check(bcx, int_value, binop_debug_loc)\n+        },\n+        _ => panic!(\"build_nonzero_check: expected Integer or Vector, found {:?}\", kind),\n+    }\n }\n \n // To avoid UB from LLVM, these two functions mask RHS with an\n@@ -2504,7 +2539,14 @@ fn build_unchecked_rshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let rhs = base::cast_shift_expr_rhs(bcx, ast::BinOp_::BiShr, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n-    let is_signed = ty::type_is_signed(lhs_t);\n+    let tcx = bcx.tcx();\n+    let is_simd = ty::type_is_simd(tcx, lhs_t);\n+    let intype = if is_simd {\n+        ty::simd_type(tcx, lhs_t)\n+    } else {\n+        lhs_t\n+    };\n+    let is_signed = ty::type_is_signed(intype);\n     if is_signed {\n         AShr(bcx, lhs, rhs, binop_debug_loc)\n     } else {\n@@ -2516,8 +2558,7 @@ fn shift_mask_rhs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               rhs: ValueRef,\n                               debug_loc: DebugLoc) -> ValueRef {\n     let rhs_llty = val_ty(rhs);\n-    let mask = shift_mask_val(rhs_llty);\n-    And(bcx, rhs, C_integral(rhs_llty, mask, false), debug_loc)\n+    And(bcx, rhs, shift_mask_val(bcx, rhs_llty, rhs_llty, false), debug_loc)\n }\n \n fn with_overflow_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, oop: OverflowOp, info: NodeIdAndSpan,"}, {"sha": "a3bce00ee07cc1f9c1b5287152c08ef6587b7500", "filename": "src/test/run-fail/overflowing-simd-lsh-1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-1.rs?ref=875f50a8ee18297d7dc10e5fd7a200d902921f04", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+#![feature(core_simd)]\n+\n+use std::simd::i32x4;\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    let _x = i32x4(1, 0, 0, 0) << id(i32x4(32, 0, 0, 0));\n+}"}, {"sha": "e119bd03c888419f1922dee450b40b1151c7a3a5", "filename": "src/test/run-fail/overflowing-simd-lsh-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-2.rs?ref=875f50a8ee18297d7dc10e5fd7a200d902921f04", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+#![feature(core_simd)]\n+\n+use std::simd::i32x4;\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    let _x = i32x4(1, 0, 0, 0) << id(i32x4(-1, 0, 0, 0));\n+}"}, {"sha": "4fb7fa958f041039355aa010d689dfc3331386c4", "filename": "src/test/run-fail/overflowing-simd-lsh-3.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-3.rs?ref=875f50a8ee18297d7dc10e5fd7a200d902921f04", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+#![feature(core_simd)]\n+\n+use std::simd::u64x2;\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    let _x = u64x2(1, 0) << id(u64x2(64, 0));\n+}"}, {"sha": "2fc177ced9ddb9ce08cca217e698fc2f1fd39df2", "filename": "src/test/run-fail/overflowing-simd-lsh-4.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-simd-lsh-4.rs?ref=875f50a8ee18297d7dc10e5fd7a200d902921f04", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+// This function is checking that our automatic truncation does not\n+// sidestep the overflow checking.\n+\n+#![feature(core_simd)]\n+\n+use std::simd::i8x16;\n+\n+fn eq_i8x16(i8x16(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15): i8x16,\n+            i8x16(y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15): i8x16)\n+            -> bool\n+{\n+    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n+        && (x4 == y4) && (x5 == y5) && (x6 == y6) && (x7 == y7)\n+        && (x8 == y8) && (x9 == y9) && (x10 == y10) && (x11 == y11)\n+        && (x12 == y12) && (x13 == y13) && (x14 == y14) && (x15 == y15)\n+}\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    // this signals overflow when checking is on\n+    let x = i8x16(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n+        << id(i8x16(17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0));\n+\n+    // ... but when checking is off, the fallback will truncate the\n+    // input to its lower three bits (= 1). Note that this is *not*\n+    // the behavior of the x86 processor for 8- and 16-bit types,\n+    // but it is necessary to avoid undefined behavior from LLVM.\n+    //\n+    // We check that here, by ensuring the result has only been\n+    // shifted by one place; if overflow checking is turned off, then\n+    // this assertion will pass (and the compiletest driver will\n+    // report that the test did not produce the error expected above).\n+    assert!(eq_i8x16(x, i8x16(2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)));\n+}"}, {"sha": "dffd627a0849f3f68019491eb48a947b722ab27b", "filename": "src/test/run-fail/overflowing-simd-rsh-1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-1.rs?ref=875f50a8ee18297d7dc10e5fd7a200d902921f04", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+#![feature(core_simd)]\n+\n+use std::simd::i32x4;\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    let _x = i32x4(-1, 0, 0, 0) >> id(i32x4(32, 0, 0, 0));\n+}"}, {"sha": "2852e147f837d5874e87823ece4627f4954e313c", "filename": "src/test/run-fail/overflowing-simd-rsh-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-2.rs?ref=875f50a8ee18297d7dc10e5fd7a200d902921f04", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+#![feature(core_simd)]\n+\n+use std::simd::i32x4;\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    let _x = i32x4(0, 0, 0, -1) >> id(i32x4(0, 0, 0, -1));\n+}"}, {"sha": "057eaa3f91aa0b19075f707c3ae7435478573d1f", "filename": "src/test/run-fail/overflowing-simd-rsh-3.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-3.rs?ref=875f50a8ee18297d7dc10e5fd7a200d902921f04", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+#![feature(core_simd)]\n+\n+use std::simd::i64x2;\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    let _x = i64x2(0, -1) >> id(i64x2(0, 64));\n+}"}, {"sha": "a850fff691917b9211bfa17b5ad63390a03a1ef1", "filename": "src/test/run-fail/overflowing-simd-rsh-4.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-simd-rsh-4.rs?ref=875f50a8ee18297d7dc10e5fd7a200d902921f04", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+// This function is checking that our (type-based) automatic\n+// truncation does not sidestep the overflow checking.\n+\n+#![feature(core_simd)]\n+\n+use std::simd::i8x16;\n+\n+fn eq_i8x16(i8x16(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15): i8x16,\n+            i8x16(y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15): i8x16)\n+            -> bool\n+{\n+    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n+        && (x4 == y4) && (x5 == y5) && (x6 == y6) && (x7 == y7)\n+        && (x8 == y8) && (x9 == y9) && (x10 == y10) && (x11 == y11)\n+        && (x12 == y12) && (x13 == y13) && (x14 == y14) && (x15 == y15)\n+}\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    // this signals overflow when checking is on\n+    let x = i8x16(2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n+        >> id(i8x16(17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0));\n+\n+    // ... but when checking is off, the fallback will truncate the\n+    // input to its lower three bits (= 1). Note that this is *not*\n+    // the behavior of the x86 processor for 8- and 16-bit types,\n+    // but it is necessary to avoid undefined behavior from LLVM.\n+    //\n+    // We check that here, by ensuring the result is not zero; if\n+    // overflow checking is turned off, then this assertion will pass\n+    // (and the compiletest driver will report that the test did not\n+    // produce the error expected above).\n+    assert!(eq_i8x16(x, i8x16(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)));\n+}"}, {"sha": "f56c3fefbe8f35078bcafbfcb6581db40451ec8c", "filename": "src/test/run-pass/issue-24258.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-pass%2Fissue-24258.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-pass%2Fissue-24258.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-24258.rs?ref=875f50a8ee18297d7dc10e5fd7a200d902921f04", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C debug-assertions\n+\n+#![feature(core_simd)]\n+\n+use std::simd::u32x4;\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn eq_u32x4(u32x4(x0, x1, x2, x3): u32x4, u32x4(y0, y1, y2, y3): u32x4) -> bool {\n+    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n+}\n+\n+fn main() {\n+    assert!(eq_u32x4(u32x4(1, 1, 1, 1) << id(u32x4(1, 1, 1, 1)), u32x4(2, 2, 2, 2)));\n+}"}, {"sha": "fee4637f07f2114f9ba2119ad60f5e48254b9d5f", "filename": "src/test/run-pass/simd-shift-near-oflo.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-pass%2Fsimd-shift-near-oflo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875f50a8ee18297d7dc10e5fd7a200d902921f04/src%2Ftest%2Frun-pass%2Fsimd-shift-near-oflo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-shift-near-oflo.rs?ref=875f50a8ee18297d7dc10e5fd7a200d902921f04", "patch": "@@ -0,0 +1,154 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C debug-assertions\n+\n+// Check that we do *not* overflow on a number of edge cases.\n+// (compare with test/run-fail/overflowing-{lsh,rsh}*.rs)\n+\n+#![feature(core_simd)]\n+\n+use std::simd::{i8x16, i16x8, i32x4, i64x2, u8x16, u16x8, u32x4, u64x2};\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn single_i8x16(x: i8) -> i8x16 { i8x16(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, x) }\n+fn single_u8x16(x: u8) -> u8x16 { u8x16(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, x) }\n+fn single_i16x8(x: i16) -> i16x8 { i16x8(0, 0, 0, 0, 0, 0, 0, x) }\n+fn single_u16x8(x: u16) -> u16x8 { u16x8(0, 0, 0, 0, 0, 0, 0, x) }\n+fn single_i32x4(x: i32) -> i32x4 { i32x4(0, 0, 0, x) }\n+fn single_u32x4(x: u32) -> u32x4 { u32x4(0, 0, 0, x) }\n+fn single_i64x2(x: i64) -> i64x2 { i64x2(0, x) }\n+fn single_u64x2(x: u64) -> u64x2 { u64x2(0, x) }\n+\n+fn eq_i8x16(i8x16(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15): i8x16,\n+            i8x16(y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15): i8x16)\n+            -> bool {\n+    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n+        && (x4 == y4) && (x5 == y5) && (x6 == y6) && (x7 == y7)\n+        && (x8 == y8) && (x9 == y9) && (x10 == y10) && (x11 == y11)\n+        && (x12 == y12) && (x13 == y13) && (x14 == y14) && (x15 == y15)\n+}\n+fn eq_u8x16(u8x16(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15): u8x16,\n+            u8x16(y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15): u8x16)\n+            -> bool {\n+    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n+        && (x4 == y4) && (x5 == y5) && (x6 == y6) && (x7 == y7)\n+        && (x8 == y8) && (x9 == y9) && (x10 == y10) && (x11 == y11)\n+        && (x12 == y12) && (x13 == y13) && (x14 == y14) && (x15 == y15)\n+}\n+fn eq_i16x8(i16x8(x0, x1, x2, x3, x4, x5, x6, x7): i16x8,\n+            i16x8(y0, y1, y2, y3, y4, y5, y6, y7): i16x8) -> bool {\n+    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n+        && (x4 == y4) && (x5 == y5) && (x6 == y6) && (x7 == y7)\n+}\n+fn eq_u16x8(u16x8(x0, x1, x2, x3, x4, x5, x6, x7): u16x8,\n+            u16x8(y0, y1, y2, y3, y4, y5, y6, y7): u16x8) -> bool {\n+    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n+        && (x4 == y4) && (x5 == y5) && (x6 == y6) && (x7 == y7)\n+}\n+fn eq_i32x4(i32x4(x0, x1, x2, x3): i32x4, i32x4(y0, y1, y2, y3): i32x4) -> bool {\n+    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n+}\n+fn eq_u32x4(u32x4(x0, x1, x2, x3): u32x4, u32x4(y0, y1, y2, y3): u32x4) -> bool {\n+    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n+}\n+fn eq_i64x2(i64x2(x0, x1): i64x2, i64x2(y0, y1): i64x2) -> bool {\n+    (x0 == y0) && (x1 == y1)\n+}\n+fn eq_u64x2(u64x2(x0, x1): u64x2, u64x2(y0, y1): u64x2) -> bool {\n+    (x0 == y0) && (x1 == y1)\n+}\n+\n+fn main() {\n+    test_left_shift();\n+    test_right_shift();\n+}\n+\n+fn test_left_shift() {\n+    // negative rhs can panic, but values in [0,N-1] are okay for iN\n+\n+    macro_rules! tests {\n+        ($single:ident, $eq:ident, $max_rhs:expr, $expect:expr) => { {\n+            let x = $single(1) << id($single(0));\n+            assert!($eq(x, $single(1)));\n+            let x = $single(1) << id($single($max_rhs));\n+            assert!($eq(x, $single($expect)));\n+            // high-order bits on LHS are silently discarded without panic.\n+            let x = $single(3) << id($single($max_rhs));\n+            assert!($eq(x, $single($expect)));\n+        } }\n+    }\n+\n+    let x = single_i8x16(1) << id(single_i8x16(0));\n+    assert!(eq_i8x16(x, single_i8x16(1)));\n+    let x = single_u8x16(1) << id(single_u8x16(0));\n+    assert!(eq_u8x16(x, single_u8x16(1)));\n+    let x = single_i8x16(1) << id(single_i8x16(7));\n+    assert!(eq_i8x16(x, single_i8x16(std::i8::MIN)));\n+    let x = single_u8x16(1) << id(single_u8x16(7));\n+    assert!(eq_u8x16(x, single_u8x16(0x80)));\n+    // high-order bits on LHS are silently discarded without panic.\n+    let x = single_i8x16(3) << id(single_i8x16(7));\n+    assert!(eq_i8x16(x, single_i8x16(std::i8::MIN)));\n+    let x = single_u8x16(3) << id(single_u8x16(7));\n+    assert!(eq_u8x16(x, single_u8x16(0x80)));\n+\n+    // above is (approximately) expanded from:\n+    tests!(single_i8x16, eq_i8x16, 7, std::i8::MIN);\n+    tests!(single_u8x16, eq_u8x16, 7, 0x80_u8);\n+\n+    tests!(single_i16x8, eq_i16x8, 15, std::i16::MIN);\n+    tests!(single_u16x8, eq_u16x8, 15, 0x8000_u16);\n+\n+    tests!(single_i32x4, eq_i32x4, 31, std::i32::MIN);\n+    tests!(single_u32x4, eq_u32x4, 31, 0x8000_0000_u32);\n+\n+    tests!(single_i64x2, eq_i64x2, 63, std::i64::MIN);\n+    tests!(single_u64x2, eq_u64x2, 63, 0x8000_0000_0000_0000_u64);\n+}\n+\n+fn test_right_shift() {\n+    // negative rhs can panic, but values in [0,N-1] are okay for iN\n+\n+    macro_rules! tests {\n+        ($single_i:ident, $eq_i:ident, $single_u:ident, $eq_u:ident,\n+         $max_rhs:expr, $signbit_i:expr, $highbit_i:expr, $highbit_u:expr) => { {\n+            let x = $single_i(1) >> id($single_i(0));\n+            assert!($eq_i(x, $single_i(1)));\n+            let x = $single_u(1) >> id($single_u(0));\n+            assert!($eq_u(x, $single_u(1)));\n+            let x = $single_u($highbit_i) >> id($single_u($max_rhs-1));\n+            assert!($eq_u(x, $single_u(1)));\n+            let x = $single_u($highbit_u) >> id($single_u($max_rhs));\n+            assert!($eq_u(x, $single_u(1)));\n+            // sign-bit is carried by arithmetic right shift\n+            let x = $single_i($signbit_i) >> id($single_i($max_rhs));\n+            assert!($eq_i(x, $single_i(-1)));\n+            // low-order bits on LHS are silently discarded without panic.\n+            let x = $single_u($highbit_i + 1) >> id($single_u($max_rhs-1));\n+            assert!($eq_u(x, $single_u(1)));\n+            let x = $single_u($highbit_u + 1) >> id($single_u($max_rhs));\n+            assert!($eq_u(x, $single_u(1)));\n+            let x = $single_i($signbit_i + 1) >> id($single_i($max_rhs));\n+            assert!($eq_i(x, $single_i(-1)));\n+        } }\n+    }\n+\n+    tests!(single_i8x16, eq_i8x16, single_u8x16, eq_u8x16,\n+           7, std::i8::MIN, 0x40_u8, 0x80_u8);\n+    tests!(single_i16x8, eq_i16x8, single_u16x8, eq_u16x8,\n+           15, std::i16::MIN, 0x4000_u16, 0x8000_u16);\n+    tests!(single_i32x4, eq_i32x4, single_u32x4, eq_u32x4,\n+           31, std::i32::MIN, 0x4000_0000_u32, 0x8000_0000_u32);\n+    tests!(single_i64x2, eq_i64x2, single_u64x2, eq_u64x2,\n+           63, std::i64::MIN, 0x4000_0000_0000_0000_u64, 0x8000_0000_0000_0000_u64);\n+}"}]}