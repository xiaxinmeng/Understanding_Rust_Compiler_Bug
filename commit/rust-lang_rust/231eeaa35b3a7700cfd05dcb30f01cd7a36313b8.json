{"sha": "231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzMWVlYWEzNWIzYTc3MDBjZmQwNWRjYjMwZjAxY2Q3YTM2MzEzYjg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T23:48:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T23:48:40Z"}, "message": "rollup merge of #22502: nikomatsakis/deprecate-bracket-bracket\n\nConflicts:\n\tsrc/libcollections/slice.rs\n\tsrc/libcollections/str.rs\n\tsrc/librustc/middle/lang_items.rs\n\tsrc/librustc_back/rpath.rs\n\tsrc/librustc_typeck/check/regionck.rs\n\tsrc/libstd/ffi/os_str.rs\n\tsrc/libsyntax/diagnostic.rs\n\tsrc/libsyntax/parse/parser.rs\n\tsrc/libsyntax/util/interner.rs\n\tsrc/test/run-pass/regions-refcell.rs", "tree": {"sha": "83644afe1c67870e2f015abfc834307aa532dec7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83644afe1c67870e2f015abfc834307aa532dec7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "html_url": "https://github.com/rust-lang/rust/commit/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cdbd288ac0606902885434e1ccd8d8bde68913d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cdbd288ac0606902885434e1ccd8d8bde68913d", "html_url": "https://github.com/rust-lang/rust/commit/2cdbd288ac0606902885434e1ccd8d8bde68913d"}, {"sha": "9ea84aeed4ed3006eddb6a7b24e9714f2844cd22", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ea84aeed4ed3006eddb6a7b24e9714f2844cd22", "html_url": "https://github.com/rust-lang/rust/commit/9ea84aeed4ed3006eddb6a7b24e9714f2844cd22"}], "stats": {"total": 1777, "additions": 895, "deletions": 882}, "files": [{"sha": "1cbb8742bbc5ae511b89c812ecd115d869501c5b", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -689,7 +689,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n                                                .unwrap()\n                                                .to_string();\n \n-    script_str.push_str(&format!(\"command script import {}\\n\", &rust_pp_module_abs_path[])[]);\n+    script_str.push_str(&format!(\"command script import {}\\n\", &rust_pp_module_abs_path[..])[]);\n     script_str.push_str(\"type summary add --no-value \");\n     script_str.push_str(\"--python-function lldb_rust_formatters.print_val \");\n     script_str.push_str(\"-x \\\".*\\\" --category Rust\\n\");"}, {"sha": "3bbe60a77c97407d35446ecc84e72d5806245f2c", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -3583,7 +3583,7 @@ An example of each kind:\n ```{rust}\n let vec: Vec<i32> = vec![1, 2, 3];\n let arr: [i32; 3] = [1, 2, 3];\n-let s: &[i32] = &vec[];\n+let s: &[i32] = &vec[..];\n ```\n \n As you can see, the `vec!` macro allows you to create a `Vec<T>` easily. The"}, {"sha": "9e82e48fd18b7f1fe829d33e7e1eb1b799226f3c", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -180,7 +180,7 @@ If you want to match against a slice or array, you can use `&`:\n fn main() {\n     let v = vec![\"match_this\", \"1\"];\n \n-    match &v[] {\n+    match &v[..] {\n         [\"match_this\", second] => println!(\"The second element is {}\", second),\n         _ => {},\n     }"}, {"sha": "0abe7f120eacab2f004f03dc79dae398f0045f81", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -1177,12 +1177,12 @@ impl ElementSwaps {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Borrow<[T]> for Vec<T> {\n-    fn borrow(&self) -> &[T] { &self[] }\n+    fn borrow(&self) -> &[T] { &self[..] }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> BorrowMut<[T]> for Vec<T> {\n-    fn borrow_mut(&mut self) -> &mut [T] { &mut self[] }\n+    fn borrow_mut(&mut self) -> &mut [T] { &mut self[..] }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1744,7 +1744,7 @@ mod tests {\n     #[test]\n     fn test_slice_from() {\n         let vec: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(&vec[], vec);\n+        assert_eq!(&vec[..], vec);\n         let b: &[_] = &[3, 4];\n         assert_eq!(&vec[2..], b);\n         let b: &[_] = &[];\n@@ -1997,9 +1997,9 @@ mod tests {\n \n     #[test]\n     fn test_lexicographic_permutations_empty_and_short() {\n-        let empty : &mut[i32] = &mut[];\n+        let empty : &mut[i32] = &mut[..];\n         assert!(empty.next_permutation() == false);\n-        let b: &mut[i32] = &mut[];\n+        let b: &mut[i32] = &mut[..];\n         assert!(empty == b);\n         assert!(empty.prev_permutation() == false);\n         assert!(empty == b);\n@@ -2265,15 +2265,15 @@ mod tests {\n     #[test]\n     fn test_total_ord() {\n         let c = &[1, 2, 3];\n-        [1, 2, 3, 4][].cmp(c) == Greater;\n+        [1, 2, 3, 4][..].cmp(c) == Greater;\n         let c = &[1, 2, 3, 4];\n-        [1, 2, 3][].cmp(c) == Less;\n+        [1, 2, 3][..].cmp(c) == Less;\n         let c = &[1, 2, 3, 6];\n-        [1, 2, 3, 4][].cmp(c) == Equal;\n+        [1, 2, 3, 4][..].cmp(c) == Equal;\n         let c = &[1, 2, 3, 4, 5, 6];\n-        [1, 2, 3, 4, 5, 5, 5, 5][].cmp(c) == Less;\n+        [1, 2, 3, 4, 5, 5, 5, 5][..].cmp(c) == Less;\n         let c = &[1, 2, 3, 4];\n-        [2, 2][].cmp(c) == Greater;\n+        [2, 2][..].cmp(c) == Greater;\n     }\n \n     #[test]"}, {"sha": "ec0a487acdc77c734c2ae207624c869e95708e25", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -388,7 +388,7 @@ macro_rules! utf8_acc_cont_byte {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Borrow<str> for String {\n-    fn borrow(&self) -> &str { &self[] }\n+    fn borrow(&self) -> &str { &self[..] }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -467,7 +467,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n                reason = \"this functionality may be moved to libunicode\")]\n     fn nfd_chars(&self) -> Decompositions {\n         Decompositions {\n-            iter: self[].chars(),\n+            iter: self[..].chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Canonical\n@@ -481,7 +481,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n                reason = \"this functionality may be moved to libunicode\")]\n     fn nfkd_chars(&self) -> Decompositions {\n         Decompositions {\n-            iter: self[].chars(),\n+            iter: self[..].chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Compatible\n@@ -531,7 +531,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn contains(&self, pat: &str) -> bool {\n-        core_str::StrExt::contains(&self[], pat)\n+        core_str::StrExt::contains(&self[..], pat)\n     }\n \n     /// Returns true if a string contains a char pattern.\n@@ -548,7 +548,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"might get removed in favour of a more generic contains()\")]\n     fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n-        core_str::StrExt::contains_char(&self[], pat)\n+        core_str::StrExt::contains_char(&self[..], pat)\n     }\n \n     /// An iterator over the characters of `self`. Note, this iterates\n@@ -562,7 +562,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chars(&self) -> Chars {\n-        core_str::StrExt::chars(&self[])\n+        core_str::StrExt::chars(&self[..])\n     }\n \n     /// An iterator over the bytes of `self`\n@@ -575,13 +575,13 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bytes(&self) -> Bytes {\n-        core_str::StrExt::bytes(&self[])\n+        core_str::StrExt::bytes(&self[..])\n     }\n \n     /// An iterator over the characters of `self` and their byte offsets.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn char_indices(&self) -> CharIndices {\n-        core_str::StrExt::char_indices(&self[])\n+        core_str::StrExt::char_indices(&self[..])\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -604,7 +604,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n-        core_str::StrExt::split(&self[], pat)\n+        core_str::StrExt::split(&self[..], pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -631,7 +631,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn<P: CharEq>(&self, count: usize, pat: P) -> SplitN<P> {\n-        core_str::StrExt::splitn(&self[], count, pat)\n+        core_str::StrExt::splitn(&self[..], count, pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -660,7 +660,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[unstable(feature = \"collections\", reason = \"might get removed\")]\n     fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n-        core_str::StrExt::split_terminator(&self[], pat)\n+        core_str::StrExt::split_terminator(&self[..], pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -681,7 +681,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn<P: CharEq>(&self, count: usize, pat: P) -> RSplitN<P> {\n-        core_str::StrExt::rsplitn(&self[], count, pat)\n+        core_str::StrExt::rsplitn(&self[..], count, pat)\n     }\n \n     /// An iterator over the start and end indices of the disjoint\n@@ -707,7 +707,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"might have its iterator type changed\")]\n     fn match_indices<'a>(&'a self, pat: &'a str) -> MatchIndices<'a> {\n-        core_str::StrExt::match_indices(&self[], pat)\n+        core_str::StrExt::match_indices(&self[..], pat)\n     }\n \n     /// An iterator over the substrings of `self` separated by the pattern `sep`.\n@@ -724,7 +724,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"might get removed in the future in favor of a more generic split()\")]\n     fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a> {\n-        core_str::StrExt::split_str(&self[], pat)\n+        core_str::StrExt::split_str(&self[..], pat)\n     }\n \n     /// An iterator over the lines of a string (subsequences separated\n@@ -740,7 +740,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(&self) -> Lines {\n-        core_str::StrExt::lines(&self[])\n+        core_str::StrExt::lines(&self[..])\n     }\n \n     /// An iterator over the lines of a string, separated by either\n@@ -756,7 +756,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines_any(&self) -> LinesAny {\n-        core_str::StrExt::lines_any(&self[])\n+        core_str::StrExt::lines_any(&self[..])\n     }\n \n     /// Deprecated: use `s[a .. b]` instead.\n@@ -803,7 +803,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"may have yet to prove its worth\")]\n     fn slice_chars(&self, begin: usize, end: usize) -> &str {\n-        core_str::StrExt::slice_chars(&self[], begin, end)\n+        core_str::StrExt::slice_chars(&self[..], begin, end)\n     }\n \n     /// Takes a bytewise (not UTF-8) slice from a string.\n@@ -814,7 +814,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// the entire slice as well.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        core_str::StrExt::slice_unchecked(&self[], begin, end)\n+        core_str::StrExt::slice_unchecked(&self[..], begin, end)\n     }\n \n     /// Returns true if the pattern `pat` is a prefix of the string.\n@@ -826,7 +826,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn starts_with(&self, pat: &str) -> bool {\n-        core_str::StrExt::starts_with(&self[], pat)\n+        core_str::StrExt::starts_with(&self[..], pat)\n     }\n \n     /// Returns true if the pattern `pat` is a suffix of the string.\n@@ -838,7 +838,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ends_with(&self, pat: &str) -> bool {\n-        core_str::StrExt::ends_with(&self[], pat)\n+        core_str::StrExt::ends_with(&self[..], pat)\n     }\n \n     /// Returns a string with all pre- and suffixes that match\n@@ -858,7 +858,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_matches(&self[], pat)\n+        core_str::StrExt::trim_matches(&self[..], pat)\n     }\n \n     /// Returns a string with all prefixes that match\n@@ -878,7 +878,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_left_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_left_matches(&self[], pat)\n+        core_str::StrExt::trim_left_matches(&self[..], pat)\n     }\n \n     /// Returns a string with all suffixes that match\n@@ -898,7 +898,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_right_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_right_matches(&self[], pat)\n+        core_str::StrExt::trim_right_matches(&self[..], pat)\n     }\n \n     /// Check that `index`-th byte lies at the start and/or end of a\n@@ -927,7 +927,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn is_char_boundary(&self, index: usize) -> bool {\n-        core_str::StrExt::is_char_boundary(&self[], index)\n+        core_str::StrExt::is_char_boundary(&self[..], index)\n     }\n \n     /// Pluck a character out of a string and return the index of the next\n@@ -986,7 +986,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at(&self, start: usize) -> CharRange {\n-        core_str::StrExt::char_range_at(&self[], start)\n+        core_str::StrExt::char_range_at(&self[..], start)\n     }\n \n     /// Given a byte position and a str, return the previous char and its position.\n@@ -1002,7 +1002,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at_reverse(&self, start: usize) -> CharRange {\n-        core_str::StrExt::char_range_at_reverse(&self[], start)\n+        core_str::StrExt::char_range_at_reverse(&self[..], start)\n     }\n \n     /// Plucks the character starting at the `i`th byte of a string.\n@@ -1023,7 +1023,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_at(&self, i: usize) -> char {\n-        core_str::StrExt::char_at(&self[], i)\n+        core_str::StrExt::char_at(&self[..], i)\n     }\n \n     /// Plucks the character ending at the `i`th byte of a string.\n@@ -1035,7 +1035,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_at_reverse(&self, i: usize) -> char {\n-        core_str::StrExt::char_at_reverse(&self[], i)\n+        core_str::StrExt::char_at_reverse(&self[..], i)\n     }\n \n     /// Work with the byte buffer of a string as a byte slice.\n@@ -1047,7 +1047,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_bytes(&self) -> &[u8] {\n-        core_str::StrExt::as_bytes(&self[])\n+        core_str::StrExt::as_bytes(&self[..])\n     }\n \n     /// Returns the byte index of the first character of `self` that\n@@ -1075,7 +1075,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn find<P: CharEq>(&self, pat: P) -> Option<usize> {\n-        core_str::StrExt::find(&self[], pat)\n+        core_str::StrExt::find(&self[..], pat)\n     }\n \n     /// Returns the byte index of the last character of `self` that\n@@ -1103,7 +1103,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rfind<P: CharEq>(&self, pat: P) -> Option<usize> {\n-        core_str::StrExt::rfind(&self[], pat)\n+        core_str::StrExt::rfind(&self[..], pat)\n     }\n \n     /// Returns the byte index of the first matching substring\n@@ -1128,7 +1128,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"might get removed in favor of a more generic find in the future\")]\n     fn find_str(&self, needle: &str) -> Option<usize> {\n-        core_str::StrExt::find_str(&self[], needle)\n+        core_str::StrExt::find_str(&self[..], needle)\n     }\n \n     /// Retrieves the first character from a string slice and returns\n@@ -1152,7 +1152,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"awaiting conventions about shifting and slices\")]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n-        core_str::StrExt::slice_shift_char(&self[])\n+        core_str::StrExt::slice_shift_char(&self[..])\n     }\n \n     /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n@@ -1172,7 +1172,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"awaiting convention about comparability of arbitrary slices\")]\n     fn subslice_offset(&self, inner: &str) -> usize {\n-        core_str::StrExt::subslice_offset(&self[], inner)\n+        core_str::StrExt::subslice_offset(&self[..], inner)\n     }\n \n     /// Return an unsafe pointer to the strings buffer.\n@@ -1183,14 +1183,14 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn as_ptr(&self) -> *const u8 {\n-        core_str::StrExt::as_ptr(&self[])\n+        core_str::StrExt::as_ptr(&self[..])\n     }\n \n     /// Return an iterator of `u16` over the string encoded as UTF-16.\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     fn utf16_units(&self) -> Utf16Units {\n-        Utf16Units { encoder: Utf16Encoder::new(self[].chars()) }\n+        Utf16Units { encoder: Utf16Encoder::new(self[..].chars()) }\n     }\n \n     /// Return the number of bytes in this string\n@@ -1204,7 +1204,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn len(&self) -> usize {\n-        core_str::StrExt::len(&self[])\n+        core_str::StrExt::len(&self[..])\n     }\n \n     /// Returns true if this slice contains no bytes\n@@ -1217,7 +1217,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_empty(&self) -> bool {\n-        core_str::StrExt::is_empty(&self[])\n+        core_str::StrExt::is_empty(&self[..])\n     }\n \n     /// Parse this string into the specified type.\n@@ -1231,7 +1231,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n-        core_str::StrExt::parse(&self[])\n+        core_str::StrExt::parse(&self[..])\n     }\n \n     /// Returns an iterator over the\n@@ -1256,7 +1256,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     fn graphemes(&self, is_extended: bool) -> Graphemes {\n-        UnicodeStr::graphemes(&self[], is_extended)\n+        UnicodeStr::graphemes(&self[..], is_extended)\n     }\n \n     /// Returns an iterator over the grapheme clusters of self and their byte offsets.\n@@ -1272,7 +1272,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n-        UnicodeStr::grapheme_indices(&self[], is_extended)\n+        UnicodeStr::grapheme_indices(&self[..], is_extended)\n     }\n \n     /// An iterator over the words of a string (subsequences separated\n@@ -1289,7 +1289,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"str_words\",\n                reason = \"the precise algorithm to use is unclear\")]\n     fn words(&self) -> Words {\n-        UnicodeStr::words(&self[])\n+        UnicodeStr::words(&self[..])\n     }\n \n     /// Returns a string's displayed width in columns, treating control\n@@ -1304,25 +1304,25 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     fn width(&self, is_cjk: bool) -> usize {\n-        UnicodeStr::width(&self[], is_cjk)\n+        UnicodeStr::width(&self[..], is_cjk)\n     }\n \n     /// Returns a string with leading and trailing whitespace removed.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim(&self) -> &str {\n-        UnicodeStr::trim(&self[])\n+        UnicodeStr::trim(&self[..])\n     }\n \n     /// Returns a string with leading whitespace removed.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_left(&self) -> &str {\n-        UnicodeStr::trim_left(&self[])\n+        UnicodeStr::trim_left(&self[..])\n     }\n \n     /// Returns a string with trailing whitespace removed.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_right(&self) -> &str {\n-        UnicodeStr::trim_right(&self[])\n+        UnicodeStr::trim_right(&self[..])\n     }\n }\n \n@@ -2705,7 +2705,7 @@ mod tests {\n             &[\"\\u{378}\\u{308}\\u{903}\"], &[\"\\u{378}\\u{308}\", \"\\u{903}\"]),\n         ];\n \n-        for &(s, g) in &test_same[] {\n+        for &(s, g) in &test_same[..] {\n             // test forward iterator\n             assert!(order::equals(s.graphemes(true), g.iter().cloned()));\n             assert!(order::equals(s.graphemes(false), g.iter().cloned()));"}, {"sha": "3b179d0b94c97cccddcdef0ddd6c7c070270cfc1", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -868,23 +868,23 @@ impl ops::Index<ops::Range<usize>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &str {\n-        &self[][*index]\n+        &self[..][*index]\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeTo<usize>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n-        &self[][*index]\n+        &self[..][*index]\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFrom<usize>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n-        &self[][*index]\n+        &self[..][*index]\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -902,7 +902,7 @@ impl ops::Deref for String {\n \n     #[inline]\n     fn deref(&self) -> &str {\n-        unsafe { mem::transmute(&self.vec[]) }\n+        unsafe { mem::transmute(&self.vec[..]) }\n     }\n }\n \n@@ -1301,7 +1301,7 @@ mod tests {\n     #[test]\n     fn test_slicing() {\n         let s = \"foobar\".to_string();\n-        assert_eq!(\"foobar\", &s[]);\n+        assert_eq!(\"foobar\", &s[..]);\n         assert_eq!(\"foo\", &s[..3]);\n         assert_eq!(\"bar\", &s[3..]);\n         assert_eq!(\"oob\", &s[1..4]);"}, {"sha": "1adcb77e0b6e92d3509888904b8a5b2c8794a502", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -2605,7 +2605,7 @@ mod tests {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let dst = src.clone()[].to_vec();\n+            let dst = src.clone()[..].to_vec();\n             assert_eq!(dst.len(), src_len);\n             assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         });"}, {"sha": "0c563f60c13bae6b2ad627643f7a1d5f964efbb7", "filename": "src/libcore/array.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -38,7 +38,7 @@ macro_rules! array_impls {\n             #[cfg(stage0)]\n             impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for [T; $N] {\n                 fn hash(&self, state: &mut S) {\n-                    Hash::hash(&self[], state)\n+                    Hash::hash(&self[..], state)\n                 }\n             }\n             #[cfg(not(stage0))]\n@@ -52,7 +52,7 @@ macro_rules! array_impls {\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T: fmt::Debug> fmt::Debug for [T; $N] {\n                 fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                    fmt::Debug::fmt(&&self[], f)\n+                    fmt::Debug::fmt(&&self[..], f)\n                 }\n             }\n \n@@ -80,11 +80,11 @@ macro_rules! array_impls {\n             impl<A, B> PartialEq<[B; $N]> for [A; $N] where A: PartialEq<B> {\n                 #[inline]\n                 fn eq(&self, other: &[B; $N]) -> bool {\n-                    &self[] == &other[]\n+                    &self[..] == &other[..]\n                 }\n                 #[inline]\n                 fn ne(&self, other: &[B; $N]) -> bool {\n-                    &self[] != &other[]\n+                    &self[..] != &other[..]\n                 }\n             }\n \n@@ -95,11 +95,11 @@ macro_rules! array_impls {\n             {\n                 #[inline(always)]\n                 fn eq(&self, other: &Rhs) -> bool {\n-                    PartialEq::eq(&self[], &**other)\n+                    PartialEq::eq(&self[..], &**other)\n                 }\n                 #[inline(always)]\n                 fn ne(&self, other: &Rhs) -> bool {\n-                    PartialEq::ne(&self[], &**other)\n+                    PartialEq::ne(&self[..], &**other)\n                 }\n             }\n \n@@ -110,11 +110,11 @@ macro_rules! array_impls {\n             {\n                 #[inline(always)]\n                 fn eq(&self, other: &[B; $N]) -> bool {\n-                    PartialEq::eq(&**self, &other[])\n+                    PartialEq::eq(&**self, &other[..])\n                 }\n                 #[inline(always)]\n                 fn ne(&self, other: &[B; $N]) -> bool {\n-                    PartialEq::ne(&**self, &other[])\n+                    PartialEq::ne(&**self, &other[..])\n                 }\n             }\n \n@@ -125,31 +125,31 @@ macro_rules! array_impls {\n             impl<T:PartialOrd> PartialOrd for [T; $N] {\n                 #[inline]\n                 fn partial_cmp(&self, other: &[T; $N]) -> Option<Ordering> {\n-                    PartialOrd::partial_cmp(&&self[], &&other[])\n+                    PartialOrd::partial_cmp(&&self[..], &&other[..])\n                 }\n                 #[inline]\n                 fn lt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::lt(&&self[], &&other[])\n+                    PartialOrd::lt(&&self[..], &&other[..])\n                 }\n                 #[inline]\n                 fn le(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::le(&&self[], &&other[])\n+                    PartialOrd::le(&&self[..], &&other[..])\n                 }\n                 #[inline]\n                 fn ge(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::ge(&&self[], &&other[])\n+                    PartialOrd::ge(&&self[..], &&other[..])\n                 }\n                 #[inline]\n                 fn gt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::gt(&&self[], &&other[])\n+                    PartialOrd::gt(&&self[..], &&other[..])\n                 }\n             }\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:Ord> Ord for [T; $N] {\n                 #[inline]\n                 fn cmp(&self, other: &[T; $N]) -> Ordering {\n-                    Ord::cmp(&&self[], &&other[])\n+                    Ord::cmp(&&self[..], &&other[..])\n                 }\n             }\n         )+"}, {"sha": "eec997b9f10fc76f3090ae58a4d59b5655c1f2b5", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -1280,7 +1280,7 @@ mod traits {\n /// Any string that can be represented as a slice\n #[unstable(feature = \"core\",\n            reason = \"Instead of taking this bound generically, this trait will be \\\n-                     replaced with one of slicing syntax (&foo[]), deref coercions, or \\\n+                     replaced with one of slicing syntax (&foo[..]), deref coercions, or \\\n                      a more generic conversion trait\")]\n pub trait Str {\n     /// Work with `self` as a slice."}, {"sha": "39a590c73074332d91a6de9319df3a52e2e70546", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -264,7 +264,7 @@ fn test_inspect() {\n                .collect::<Vec<uint>>();\n \n     assert_eq!(n, xs.len());\n-    assert_eq!(&xs[], &ys[]);\n+    assert_eq!(&xs[..], &ys[..]);\n }\n \n #[test]"}, {"sha": "46c7730cc6470aeb852892cb2f1cf3f31506dcb3", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -43,31 +43,31 @@ fn iterator_to_slice() {\n \n             {\n                 let mut iter = data.iter();\n-                assert_eq!(&iter[], &other_data[]);\n+                assert_eq!(&iter[..], &other_data[..]);\n \n                 iter.next();\n-                assert_eq!(&iter[], &other_data[1..]);\n+                assert_eq!(&iter[..], &other_data[1..]);\n \n                 iter.next_back();\n-                assert_eq!(&iter[], &other_data[1..2]);\n+                assert_eq!(&iter[..], &other_data[1..2]);\n \n                 let s = iter.as_slice();\n                 iter.next();\n                 assert_eq!(s, &other_data[1..2]);\n             }\n             {\n                 let mut iter = data.iter_mut();\n-                assert_eq!(&iter[], &other_data[]);\n+                assert_eq!(&iter[..], &other_data[..]);\n                 // mutability:\n                 assert!(&mut iter[] == other_data);\n \n                 iter.next();\n-                assert_eq!(&iter[], &other_data[1..]);\n+                assert_eq!(&iter[..], &other_data[1..]);\n                 assert!(&mut iter[] == &mut other_data[1..]);\n \n                 iter.next_back();\n \n-                assert_eq!(&iter[], &other_data[1..2]);\n+                assert_eq!(&iter[..], &other_data[1..2]);\n                 assert!(&mut iter[] == &mut other_data[1..2]);\n \n                 let s = iter.into_slice();"}, {"sha": "be77622ac1db7c52335525cefd8753423177258f", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -215,11 +215,11 @@ impl<'a> Parser<'a> {\n             }\n             Some((_, other)) => {\n                 self.err(&format!(\"expected `{:?}`, found `{:?}`\", c,\n-                                  other)[]);\n+                                  other));\n             }\n             None => {\n                 self.err(&format!(\"expected `{:?}` but string was terminated\",\n-                                  c)[]);\n+                                  c));\n             }\n         }\n     }"}, {"sha": "fdd7f7395c2b7af5955aa3f52f7cecd52e9cff74", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -287,7 +287,7 @@ impl OptGroup {\n \n impl Matches {\n     fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n-        match find_opt(&self.opts[], Name::from_str(nm)) {\n+        match find_opt(&self.opts[..], Name::from_str(nm)) {\n             Some(id) => self.vals[id].clone(),\n             None => panic!(\"No option '{}' defined\", nm)\n         }\n@@ -326,7 +326,7 @@ impl Matches {\n     /// Returns the string argument supplied to one of several matching options or `None`.\n     pub fn opts_str(&self, names: &[String]) -> Option<String> {\n         for nm in names {\n-            match self.opt_val(&nm[]) {\n+            match self.opt_val(&nm[..]) {\n                 Some(Val(ref s)) => return Some(s.clone()),\n                 _ => ()\n             }\n@@ -593,7 +593,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     while i < l {\n         let cur = args[i].clone();\n         let curlen = cur.len();\n-        if !is_arg(&cur[]) {\n+        if !is_arg(&cur[..]) {\n             free.push(cur);\n         } else if cur == \"--\" {\n             let mut j = i + 1;\n@@ -667,7 +667,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                         v.push(Val((i_arg.clone())\n                             .unwrap()));\n                     } else if name_pos < names.len() || i + 1 == l ||\n-                            is_arg(&args[i + 1][]) {\n+                            is_arg(&args[i + 1][..]) {\n                         let v = &mut vals[optid];\n                         v.push(Given);\n                     } else {\n@@ -730,7 +730,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             0 => {}\n             1 => {\n                 row.push('-');\n-                row.push_str(&short_name[]);\n+                row.push_str(&short_name[..]);\n                 row.push(' ');\n             }\n             _ => panic!(\"the short name should only be 1 ascii char long\"),\n@@ -741,18 +741,18 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             0 => {}\n             _ => {\n                 row.push_str(\"--\");\n-                row.push_str(&long_name[]);\n+                row.push_str(&long_name[..]);\n                 row.push(' ');\n             }\n         }\n \n         // arg\n         match hasarg {\n             No => {}\n-            Yes => row.push_str(&hint[]),\n+            Yes => row.push_str(&hint[..]),\n             Maybe => {\n                 row.push('[');\n-                row.push_str(&hint[]);\n+                row.push_str(&hint[..]);\n                 row.push(']');\n             }\n         }\n@@ -765,7 +765,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n                 row.push(' ');\n             }\n         } else {\n-            row.push_str(&desc_sep[]);\n+            row.push_str(&desc_sep[..]);\n         }\n \n         // Normalize desc to contain words separated by one space character\n@@ -777,14 +777,14 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // FIXME: #5516 should be graphemes not codepoints\n         let mut desc_rows = Vec::new();\n-        each_split_within(&desc_normalized_whitespace[], 54, |substr| {\n+        each_split_within(&desc_normalized_whitespace[..], 54, |substr| {\n             desc_rows.push(substr.to_string());\n             true\n         });\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // wrapped description\n-        row.push_str(&desc_rows.connect(&desc_sep[])[]);\n+        row.push_str(&desc_rows.connect(&desc_sep[..])[]);\n \n         row\n     });\n@@ -803,18 +803,18 @@ fn format_option(opt: &OptGroup) -> String {\n     // Use short_name is possible, but fallback to long_name.\n     if opt.short_name.len() > 0 {\n         line.push('-');\n-        line.push_str(&opt.short_name[]);\n+        line.push_str(&opt.short_name[..]);\n     } else {\n         line.push_str(\"--\");\n-        line.push_str(&opt.long_name[]);\n+        line.push_str(&opt.long_name[..]);\n     }\n \n     if opt.hasarg != No {\n         line.push(' ');\n         if opt.hasarg == Maybe {\n             line.push('[');\n         }\n-        line.push_str(&opt.hint[]);\n+        line.push_str(&opt.hint[..]);\n         if opt.hasarg == Maybe {\n             line.push(']');\n         }\n@@ -836,7 +836,7 @@ pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n     line.push_str(&opts.iter()\n                        .map(format_option)\n                        .collect::<Vec<String>>()\n-                       .connect(\" \")[]);\n+                       .connect(\" \")[..]);\n     line\n }\n "}, {"sha": "3d594378f558679680dc3df9d3a7fc93528f0526", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -455,7 +455,7 @@ impl<'a> LabelText<'a> {\n     pub fn escape(&self) -> String {\n         match self {\n             &LabelStr(ref s) => s.escape_default(),\n-            &EscStr(ref s) => LabelText::escape_str(&s[]),\n+            &EscStr(ref s) => LabelText::escape_str(&s[..]),\n         }\n     }\n \n@@ -484,7 +484,7 @@ impl<'a> LabelText<'a> {\n         let mut prefix = self.pre_escaped_content().into_owned();\n         let suffix = suffix.pre_escaped_content();\n         prefix.push_str(r\"\\n\\n\");\n-        prefix.push_str(&suffix[]);\n+        prefix.push_str(&suffix[..]);\n         EscStr(prefix.into_cow())\n     }\n }\n@@ -678,7 +678,7 @@ mod tests {\n \n     impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraph {\n         fn graph_id(&'a self) -> Id<'a> {\n-            Id::new(&self.name[]).unwrap()\n+            Id::new(&self.name[..]).unwrap()\n         }\n         fn node_id(&'a self, n: &Node) -> Id<'a> {\n             id_name(n)"}, {"sha": "c2c7f20ce9cdfcff7ead7cf1f79caaf23ff2962e", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -287,7 +287,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n     match unsafe { FILTER.as_ref() } {\n-        Some(filter) if !args.to_string().contains(&filter[]) => return,\n+        Some(filter) if !args.to_string().contains(&filter[..]) => return,\n         _ => {}\n     }\n \n@@ -382,7 +382,7 @@ fn enabled(level: u32,\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {\n         match directive.name {\n-            Some(ref name) if !module.starts_with(&name[]) => {},\n+            Some(ref name) if !module.starts_with(&name[..]) => {},\n             Some(..) | None => {\n                 return level <= directive.level\n             }\n@@ -397,7 +397,7 @@ fn enabled(level: u32,\n /// `Once` primitive (and this function is called from that primitive).\n fn init() {\n     let (mut directives, filter) = match env::var(\"RUST_LOG\") {\n-        Ok(spec) => directive::parse_logging_spec(&spec[]),\n+        Ok(spec) => directive::parse_logging_spec(&spec[..]),\n         Err(..) => (Vec::new(), None),\n     };\n "}, {"sha": "dc81e89902bb4c093b42d8c65386c7707777510f", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -508,7 +508,7 @@ impl BoxPointers {\n         if n_uniq > 0 {\n             let s = ty_to_string(cx.tcx, ty);\n             let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(BOX_POINTERS, span, &m[]);\n+            cx.span_lint(BOX_POINTERS, span, &m[..]);\n         }\n     }\n }\n@@ -736,7 +736,7 @@ impl LintPass for UnusedResults {\n                     }\n                 } else {\n                     let attrs = csearch::get_item_attrs(&cx.sess().cstore, did);\n-                    warned |= check_must_use(cx, &attrs[], s.span);\n+                    warned |= check_must_use(cx, &attrs[..], s.span);\n                 }\n             }\n             _ => {}\n@@ -803,7 +803,7 @@ impl NonCamelCaseTypes {\n             } else {\n                 format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n             };\n-            cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[]);\n+            cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[..]);\n         }\n     }\n }\n@@ -950,7 +950,7 @@ impl NonSnakeCase {\n \n         if !is_snake_case(ident) {\n             let sc = NonSnakeCase::to_snake_case(&s);\n-            if sc != &s[] {\n+            if sc != &s[..] {\n                 cx.span_lint(NON_SNAKE_CASE, span,\n                     &*format!(\"{} `{}` should have a snake case name such as `{}`\",\n                             sort, s, sc));\n@@ -1033,7 +1033,7 @@ impl NonUpperCaseGlobals {\n         if s.chars().any(|c| c.is_lowercase()) {\n             let uc: String = NonSnakeCase::to_snake_case(&s).chars()\n                                            .map(|c| c.to_uppercase()).collect();\n-            if uc != &s[] {\n+            if uc != &s[..] {\n                 cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n                     &format!(\"{} `{}` should have an upper case name such as `{}`\",\n                              sort, s, uc));\n@@ -1196,7 +1196,7 @@ impl LintPass for UnusedImportBraces {\n                                     let m = format!(\"braces around {} is unnecessary\",\n                                                     &token::get_ident(*name));\n                                     cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n-                                                 &m[]);\n+                                                 &m[..]);\n                                 },\n                                 _ => ()\n                             }\n@@ -1474,7 +1474,7 @@ impl LintPass for MissingDoc {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n-                Some(l) => attr::contains_name(&l[], \"hidden\"),\n+                Some(l) => attr::contains_name(&l[..], \"hidden\"),\n             }\n         });\n         self.doc_hidden_stack.push(doc_hidden);\n@@ -1702,7 +1702,7 @@ impl Stability {\n                 _ => format!(\"use of {} item\", label)\n             };\n \n-            cx.span_lint(lint, span, &msg[]);\n+            cx.span_lint(lint, span, &msg[..]);\n         }\n     }\n }"}, {"sha": "068c179d3431fe7c18087fd92dd1dc7a9a475f54", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -125,11 +125,11 @@ impl LintStore {\n                 match (sess, from_plugin) {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n                     // Use early_error when handling -W help with no crate.\n-                    (None, _) => early_error(&msg[]),\n-                    (Some(sess), false) => sess.bug(&msg[]),\n+                    (None, _) => early_error(&msg[..]),\n+                    (Some(sess), false) => sess.bug(&msg[..]),\n \n                     // A duplicate name from a plugin is a user error.\n-                    (Some(sess), true)  => sess.err(&msg[]),\n+                    (Some(sess), true)  => sess.err(&msg[..]),\n                 }\n             }\n \n@@ -150,11 +150,11 @@ impl LintStore {\n             match (sess, from_plugin) {\n                 // We load builtin lints first, so a duplicate is a compiler bug.\n                 // Use early_error when handling -W help with no crate.\n-                (None, _) => early_error(&msg[]),\n-                (Some(sess), false) => sess.bug(&msg[]),\n+                (None, _) => early_error(&msg[..]),\n+                (Some(sess), false) => sess.bug(&msg[..]),\n \n                 // A duplicate name from a plugin is a user error.\n-                (Some(sess), true)  => sess.err(&msg[]),\n+                (Some(sess), true)  => sess.err(&msg[..]),\n             }\n         }\n     }\n@@ -251,8 +251,8 @@ impl LintStore {\n                 let warning = format!(\"lint {} has been renamed to {}\",\n                                       lint_name, new_name);\n                 match span {\n-                    Some(span) => sess.span_warn(span, &warning[]),\n-                    None => sess.warn(&warning[]),\n+                    Some(span) => sess.span_warn(span, &warning[..]),\n+                    None => sess.warn(&warning[..]),\n                 };\n                 Some(lint_id)\n             }\n@@ -262,13 +262,13 @@ impl LintStore {\n \n     pub fn process_command_line(&mut self, sess: &Session) {\n         for &(ref lint_name, level) in &sess.opts.lint_opts {\n-            match self.find_lint(&lint_name[], sess, None) {\n+            match self.find_lint(&lint_name[..], sess, None) {\n                 Some(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n                 None => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n                                                  .collect::<FnvHashMap<&'static str,\n                                                                        Vec<LintId>>>()\n-                                                 .get(&lint_name[]) {\n+                                                 .get(&lint_name[..]) {\n                         Some(v) => {\n                             v.iter()\n                              .map(|lint_id: &LintId|\n@@ -411,15 +411,15 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n     if level == Forbid { level = Deny; }\n \n     match (level, span) {\n-        (Warn, Some(sp)) => sess.span_warn(sp, &msg[]),\n-        (Warn, None)     => sess.warn(&msg[]),\n-        (Deny, Some(sp)) => sess.span_err(sp, &msg[]),\n-        (Deny, None)     => sess.err(&msg[]),\n+        (Warn, Some(sp)) => sess.span_warn(sp, &msg[..]),\n+        (Warn, None)     => sess.warn(&msg[..]),\n+        (Deny, Some(sp)) => sess.span_err(sp, &msg[..]),\n+        (Deny, None)     => sess.err(&msg[..]),\n         _ => sess.bug(\"impossible level in raw_emit_lint\"),\n     }\n \n     if let Some(note) = note {\n-        sess.note(&note[]);\n+        sess.note(&note[..]);\n     }\n \n     if let Some(span) = def {\n@@ -503,7 +503,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                     match self.lints.find_lint(&lint_name, &self.tcx.sess, Some(span)) {\n                         Some(lint_id) => vec![(lint_id, level, span)],\n                         None => {\n-                            match self.lints.lint_groups.get(&lint_name[]) {\n+                            match self.lints.lint_groups.get(&lint_name[..]) {\n                                 Some(&(ref v, _)) => v.iter()\n                                                       .map(|lint_id: &LintId|\n                                                            (*lint_id, level, span))\n@@ -729,7 +729,7 @@ impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n             None => {}\n             Some(lints) => {\n                 for (lint_id, span, msg) in lints {\n-                    self.span_lint(lint_id.lint, span, &msg[])\n+                    self.span_lint(lint_id.lint, span, &msg[..])\n                 }\n             }\n         }"}, {"sha": "d48a404176ace37d2727925a3fd958ea309f32c4", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -183,7 +183,7 @@ impl<'a> CrateReader<'a> {\n                 let name = match *path_opt {\n                     Some((ref path_str, _)) => {\n                         let name = path_str.to_string();\n-                        validate_crate_name(Some(self.sess), &name[],\n+                        validate_crate_name(Some(self.sess), &name[..],\n                                             Some(i.span));\n                         name\n                     }\n@@ -321,7 +321,7 @@ impl<'a> CrateReader<'a> {\n             let source = self.sess.cstore.get_used_crate_source(cnum).unwrap();\n             if let Some(locs) = self.sess.opts.externs.get(name) {\n                 let found = locs.iter().any(|l| {\n-                    let l = fs::realpath(&Path::new(&l[])).ok();\n+                    let l = fs::realpath(&Path::new(&l[..])).ok();\n                     source.dylib.as_ref().map(|p| &p.0) == l.as_ref() ||\n                     source.rlib.as_ref().map(|p| &p.0) == l.as_ref()\n                 });\n@@ -459,8 +459,8 @@ impl<'a> CrateReader<'a> {\n         let mut load_ctxt = loader::Context {\n             sess: self.sess,\n             span: span,\n-            ident: &ident[],\n-            crate_name: &name[],\n+            ident: &ident[..],\n+            crate_name: &name[..],\n             hash: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             target: &self.sess.host,\n@@ -562,7 +562,7 @@ impl<'a> CrateReader<'a> {\n                                   name,\n                                   config::host_triple(),\n                                   self.sess.opts.target_triple);\n-            self.sess.span_err(span, &message[]);\n+            self.sess.span_err(span, &message[..]);\n             self.sess.abort_if_errors();\n         }\n \n@@ -575,7 +575,7 @@ impl<'a> CrateReader<'a> {\n                 let message = format!(\"plugin `{}` only found in rlib format, \\\n                                        but must be available in dylib format\",\n                                        name);\n-                self.sess.span_err(span, &message[]);\n+                self.sess.span_err(span, &message[..]);\n                 // No need to abort because the loading code will just ignore this\n                 // empty dylib.\n                 None"}, {"sha": "42a70cec5dfee08903c604b672a124e0e4aef4da", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -163,7 +163,7 @@ fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n     rbml_w.end_tag();\n \n     rbml_w.start_tag(tag_mod_child);\n-    rbml_w.wr_str(&s[]);\n+    rbml_w.wr_str(&s[..]);\n     rbml_w.end_tag();\n }\n \n@@ -353,9 +353,9 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n                 let idx = encode_info_for_struct(ecx,\n                                                  rbml_w,\n-                                                 &fields[],\n+                                                 &fields[..],\n                                                  index);\n-                encode_struct_fields(rbml_w, &fields[], def_id);\n+                encode_struct_fields(rbml_w, &fields[..], def_id);\n                 encode_index(rbml_w, idx, write_i64);\n             }\n         }\n@@ -1158,7 +1158,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            class itself */\n         let idx = encode_info_for_struct(ecx,\n                                          rbml_w,\n-                                         &fields[],\n+                                         &fields[..],\n                                          index);\n \n         /* Index the class*/\n@@ -1181,7 +1181,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(rbml_w, &fields[], def_id);\n+        encode_struct_fields(rbml_w, &fields[..], def_id);\n \n         encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n "}, {"sha": "01d1f4e7011f8586c7196884fc851e35ee039d1c", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -322,7 +322,7 @@ impl<'a> Context<'a> {\n             &Some(ref r) => format!(\"{} which `{}` depends on\",\n                                     message, r.ident)\n         };\n-        self.sess.span_err(self.span, &message[]);\n+        self.sess.span_err(self.span, &message[..]);\n \n         if self.rejected_via_triple.len() > 0 {\n             let mismatches = self.rejected_via_triple.iter();\n@@ -404,7 +404,7 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            let (hash, rlib) = if file.starts_with(&rlib_prefix[]) &&\n+            let (hash, rlib) = if file.starts_with(&rlib_prefix[..]) &&\n                                   file.ends_with(\".rlib\") {\n                 (&file[(rlib_prefix.len()) .. (file.len() - \".rlib\".len())],\n                  true)\n@@ -413,7 +413,7 @@ impl<'a> Context<'a> {\n                 (&file[(dylib_prefix.len()) .. (file.len() - dypair.1.len())],\n                  false)\n             } else {\n-                if file.starts_with(&staticlib_prefix[]) &&\n+                if file.starts_with(&staticlib_prefix[..]) &&\n                    file.ends_with(\".a\") {\n                     staticlibs.push(CrateMismatch {\n                         path: path.clone(),\n@@ -627,7 +627,7 @@ impl<'a> Context<'a> {\n         let mut rlibs = HashMap::new();\n         let mut dylibs = HashMap::new();\n         {\n-            let locs = locs.iter().map(|l| Path::new(&l[])).filter(|loc| {\n+            let locs = locs.iter().map(|l| Path::new(&l[..])).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n                                      self.crate_name, loc.display())[]);\n@@ -645,8 +645,8 @@ impl<'a> Context<'a> {\n                     return true\n                 } else {\n                     let (ref prefix, ref suffix) = dylibname;\n-                    if file.starts_with(&prefix[]) &&\n-                       file.ends_with(&suffix[]) {\n+                    if file.starts_with(&prefix[..]) &&\n+                       file.ends_with(&suffix[..]) {\n                         return true\n                     }\n                 }"}, {"sha": "5805725a8fc8b7cb6ad2f37651f437f33278182b", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -641,7 +641,7 @@ fn parse_abi_set(st: &mut PState) -> abi::Abi {\n     assert_eq!(next(st), '[');\n     scan(st, |c| c == ']', |bytes| {\n         let abi_str = str::from_utf8(bytes).unwrap();\n-        abi::lookup(&abi_str[]).expect(abi_str)\n+        abi::lookup(&abi_str[..]).expect(abi_str)\n     })\n }\n "}, {"sha": "ae10eb686b010244ed71bcdf07de52c2d93616e6", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -134,7 +134,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n             // Do an Option dance to use the path after it is moved below.\n             let s = ast_map::path_to_string(path.iter().cloned());\n             path_as_str = Some(s);\n-            path_as_str.as_ref().map(|x| &x[])\n+            path_as_str.as_ref().map(|x| &x[..])\n         });\n         let mut ast_dsr = reader::Decoder::new(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();"}, {"sha": "46b4a51c9d6fee7b00295727dbd71d600698cf47", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n             let s = replace_newline_with_backslash_l(s);\n             label.push_str(&format!(\"exiting scope_{} {}\",\n                                    i,\n-                                   &s[])[]);\n+                                   &s[..])[]);\n         }\n         dot::LabelText::EscStr(label.into_cow())\n     }"}, {"sha": "86c59b24e3e933663ed2100f3d5ede07fe3dc82a", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -200,7 +200,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n             }\n \n             // Fourth, check for unreachable arms.\n-            check_arms(cx, &inlined_arms[], source);\n+            check_arms(cx, &inlined_arms[..], source);\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n@@ -291,7 +291,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n         for pat in pats {\n             let v = vec![&**pat];\n \n-            match is_useful(cx, &seen, &v[], LeaveOutWitness) {\n+            match is_useful(cx, &seen, &v[..], LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n                         ast::MatchSource::IfLetDesugar { .. } => {\n@@ -351,7 +351,7 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: ast::MatchSource) {\n     match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n-            let witness = match &pats[] {\n+            let witness = match &pats[..] {\n                 [ref witness] => &**witness,\n                 [] => DUMMY_WILD_PAT,\n                 _ => unreachable!()\n@@ -360,7 +360,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: ast:\n                 ast::MatchSource::ForLoopDesugar => {\n                     // `witness` has the form `Some(<head>)`, peel off the `Some`\n                     let witness = match witness.node {\n-                        ast::PatEnum(_, Some(ref pats)) => match &pats[] {\n+                        ast::PatEnum(_, Some(ref pats)) => match &pats[..] {\n                             [ref pat] => &**pat,\n                             _ => unreachable!(),\n                         },\n@@ -664,7 +664,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n                         UsefulWithWitness(pats) => UsefulWithWitness({\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n-                                let pat_slice = &pats[];\n+                                let pat_slice = &pats[..];\n                                 let subpats: Vec<_> = (0..arity).map(|i| {\n                                     pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n                                 }).collect();\n@@ -711,10 +711,10 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n                          witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, &r[], &ctor, 0, arity)\n+        specialize(cx, &r[..], &ctor, 0, arity)\n     }).collect());\n     match specialize(cx, v, &ctor, 0, arity) {\n-        Some(v) => is_useful(cx, &matrix, &v[], witness),\n+        Some(v) => is_useful(cx, &matrix, &v[..], witness),\n         None => NotUseful\n     }\n }"}, {"sha": "5bf7422dbc0d41ce7051d5a801238c4d4a28b12f", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -62,7 +62,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n-                    variant_expr(&variants[], variant_def.node)\n+                    variant_expr(&variants[..], variant_def.node)\n                 }\n                 _ => None\n             },\n@@ -83,7 +83,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n                     // NOTE this doesn't do the right thing, it compares inlined\n                     // NodeId's to the original variant_def's NodeId, but they\n                     // come from different crates, so they will likely never match.\n-                    variant_expr(&variants[], variant_def.node).map(|e| e.id)\n+                    variant_expr(&variants[..], variant_def.node).map(|e| e.id)\n                 }\n                 _ => None\n             },\n@@ -209,7 +209,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n     match eval_const_expr_partial(tcx, e, None) {\n         Ok(r) => r,\n-        Err(s) => tcx.sess.span_fatal(e.span, &s[])\n+        Err(s) => tcx.sess.span_fatal(e.span, &s[..])\n     }\n }\n \n@@ -552,14 +552,14 @@ pub fn compare_lit_exprs<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let a = match eval_const_expr_partial(tcx, a, ty_hint) {\n         Ok(a) => a,\n         Err(s) => {\n-            tcx.sess.span_err(a.span, &s[]);\n+            tcx.sess.span_err(a.span, &s[..]);\n             return None;\n         }\n     };\n     let b = match eval_const_expr_partial(tcx, b, ty_hint) {\n         Ok(b) => b,\n         Err(s) => {\n-            tcx.sess.span_err(b.span, &s[]);\n+            tcx.sess.span_err(b.span, &s[..]);\n             return None;\n         }\n     };"}, {"sha": "085d5cbc347e5b015801586b7756c1f2acce7b67", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -312,7 +312,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let mut t = on_entry.to_vec();\n                 self.apply_gen_kill(cfgidx, &mut t);\n                 temp_bits = t;\n-                &temp_bits[]\n+                &temp_bits[..]\n             }\n         };\n         debug!(\"{} each_bit_for_node({:?}, cfgidx={:?}) bits={}\",\n@@ -421,7 +421,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let bits = &mut self.kills[start.. end];\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n-                bits.clone_from_slice(&orig_kills[]);\n+                bits.clone_from_slice(&orig_kills[..]);\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [after]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n             }"}, {"sha": "ff78deb8d12ea6ba945531b6c34f0762b38a2ee6", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -321,7 +321,7 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n     for attr in lint::gather_attrs(attrs) {\n         match attr {\n             Ok((ref name, lint::Allow, _))\n-                if &name[] == dead_code => return true,\n+                if &name[..] == dead_code => return true,\n             _ => (),\n         }\n     }"}, {"sha": "147fc5ea7f9d6ba03787fb7dd04de9d4327087b7", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -1166,7 +1166,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                 let msg = format!(\"Pattern has unexpected def: {:?} and type {}\",\n                                                   def,\n                                                   cmt_pat.ty.repr(tcx));\n-                                tcx.sess.span_bug(pat.span, &msg[])\n+                                tcx.sess.span_bug(pat.span, &msg[..])\n                             }\n                         }\n                     }"}, {"sha": "70b444d81d81faa407d10b503f7c5176bff1ff7d", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -142,7 +142,7 @@ pub trait Combine<'tcx> : Sized {\n                             for _ in a_regions {\n                                 invariance.push(ty::Invariant);\n                             }\n-                            &invariance[]\n+                            &invariance[..]\n                         }\n                     };\n "}, {"sha": "9aafa1f9fd2bd954f9cd66d4b3c5ae3e8b6824e7", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -200,9 +200,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                 ref trace_origins,\n                                 ref same_regions) => {\n                     if !same_regions.is_empty() {\n-                        self.report_processed_errors(&var_origins[],\n-                                                     &trace_origins[],\n-                                                     &same_regions[]);\n+                        self.report_processed_errors(&var_origins[..],\n+                                                     &trace_origins[..],\n+                                                     &same_regions[..]);\n                     }\n                 }\n             }\n@@ -824,7 +824,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         let parent = self.tcx.map.get_parent(scope_id);\n         let parent_node = self.tcx.map.find(parent);\n         let taken = lifetimes_in_scope(self.tcx, scope_id);\n-        let life_giver = LifeGiver::with_taken(&taken[]);\n+        let life_giver = LifeGiver::with_taken(&taken[..]);\n         let node_inner = match parent_node {\n             Some(ref node) => match *node {\n                 ast_map::NodeItem(ref item) => {\n@@ -942,7 +942,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             }\n             expl_self_opt = self.rebuild_expl_self(expl_self_opt, lifetime,\n                                                    &anon_nums, &region_names);\n-            inputs = self.rebuild_args_ty(&inputs[], lifetime,\n+            inputs = self.rebuild_args_ty(&inputs[..], lifetime,\n                                           &anon_nums, &region_names);\n             output = self.rebuild_output(&output, lifetime, &anon_nums, &region_names);\n             ty_params = self.rebuild_ty_params(ty_params, lifetime,\n@@ -1426,7 +1426,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                                               opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n-        self.tcx.sess.span_help(span, &msg[]);\n+        self.tcx.sess.span_help(span, &msg[..]);\n     }\n \n     fn report_inference_failure(&self,\n@@ -1771,7 +1771,7 @@ impl LifeGiver {\n             s.push_str(&num_to_string(self.counter.get())[]);\n             if !self.taken.contains(&s) {\n                 lifetime = name_to_dummy_lifetime(\n-                                    token::str_to_ident(&s[]).name);\n+                                    token::str_to_ident(&s[..]).name);\n                 self.generated.borrow_mut().push(lifetime);\n                 break;\n             }"}, {"sha": "b4fd34f206fa728d258a40241a13fafa32a84a80", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -977,7 +977,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.expansion(&mut var_data);\n         self.contraction(&mut var_data);\n         let values =\n-            self.extract_values_and_collect_conflicts(&var_data[],\n+            self.extract_values_and_collect_conflicts(&var_data[..],\n                                                       errors);\n         self.collect_concrete_region_errors(&values, errors);\n         values"}, {"sha": "fd641bd709d3f45ba105f4efe892b6a85a7ff499", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -148,7 +148,7 @@ struct LanguageItemCollector<'a> {\n impl<'a, 'v> Visitor<'v> for LanguageItemCollector<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         if let Some(value) = extract(&item.attrs) {\n-            let item_index = self.item_refs.get(&value[]).cloned();\n+            let item_index = self.item_refs.get(&value[..]).cloned();\n \n             if let Some(item_index) = item_index {\n                 self.collect_item(item_index, local_def(item.id), item.span)"}, {"sha": "e58136fb3f4e454e18c6269b16ebd57f0dea5642", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -1119,7 +1119,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           // Uninteresting cases: just propagate in rev exec order\n \n           ast::ExprVec(ref exprs) => {\n-            self.propagate_through_exprs(&exprs[], succ)\n+            self.propagate_through_exprs(&exprs[..], succ)\n           }\n \n           ast::ExprRepeat(ref element, ref count) => {\n@@ -1143,7 +1143,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            let succ = self.propagate_through_exprs(&args[], succ);\n+            let succ = self.propagate_through_exprs(&args[..], succ);\n             self.propagate_through_expr(&**f, succ)\n           }\n \n@@ -1156,11 +1156,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            self.propagate_through_exprs(&args[], succ)\n+            self.propagate_through_exprs(&args[..], succ)\n           }\n \n           ast::ExprTup(ref exprs) => {\n-            self.propagate_through_exprs(&exprs[], succ)\n+            self.propagate_through_exprs(&exprs[..], succ)\n           }\n \n           ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op.node) => {"}, {"sha": "496ce6be75c4dd2907b64995540574d92e09b47e", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -996,7 +996,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let all_bounds =\n             util::transitive_bounds(\n-                self.tcx(), &caller_trait_refs[]);\n+                self.tcx(), &caller_trait_refs[..]);\n \n         let matching_bounds =\n             all_bounds.filter("}, {"sha": "b1ea89c65740ab6e1879ac1dc3e28ef411f1a499", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -2380,7 +2380,7 @@ impl ClosureKind {\n         };\n         match result {\n             Ok(trait_did) => trait_did,\n-            Err(err) => cx.sess.fatal(&err[]),\n+            Err(err) => cx.sess.fatal(&err[..]),\n         }\n     }\n }\n@@ -2714,7 +2714,7 @@ impl FlagComputation {\n             }\n \n             &ty_tup(ref ts) => {\n-                self.add_tys(&ts[]);\n+                self.add_tys(&ts[..]);\n             }\n \n             &ty_bare_fn(_, ref f) => {\n@@ -3500,7 +3500,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             ty_struct(did, substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(&flds[],\n+                    TypeContents::union(&flds[..],\n                                         |f| tc_mt(cx, f.mt, cache));\n \n                 if !lookup_repr_hints(cx, did).contains(&attr::ReprExtern) {\n@@ -3523,14 +3523,14 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             ty_tup(ref tys) => {\n-                TypeContents::union(&tys[],\n+                TypeContents::union(&tys[..],\n                                     |ty| tc_ty(cx, *ty, cache))\n             }\n \n             ty_enum(did, substs) => {\n                 let variants = substd_enum_variants(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(&variants[], |variant| {\n+                    TypeContents::union(&variants[..], |variant| {\n                         TypeContents::union(&variant.args[],\n                                             |arg_ty| {\n                             tc_ty(cx, *arg_ty, cache)\n@@ -4993,7 +4993,7 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                 match item.node {\n                     ItemTrait(_, _, _, ref ms) => {\n                         let (_, p) =\n-                            ast_util::split_trait_methods(&ms[]);\n+                            ast_util::split_trait_methods(&ms[..]);\n                         p.iter()\n                          .map(|m| {\n                             match impl_or_trait_item(\n@@ -6674,7 +6674,7 @@ pub fn with_freevars<T, F>(tcx: &ty::ctxt, fid: ast::NodeId, f: F) -> T where\n {\n     match tcx.freevars.borrow().get(&fid) {\n         None => f(&[]),\n-        Some(d) => f(&d[])\n+        Some(d) => f(&d[..])\n     }\n }\n "}, {"sha": "60a9ffc7d2e13b80a6e1824a55efdb6e02315504", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -55,7 +55,7 @@ pub fn check_crate(krate: &ast::Crate,\n \n pub fn link_name(attrs: &[ast::Attribute]) -> Option<InternedString> {\n     lang_items::extract(attrs).and_then(|name| {\n-        $(if &name[] == stringify!($name) {\n+        $(if &name[..] == stringify!($name) {\n             Some(InternedString::new(stringify!($sym)))\n         } else)* {\n             None"}, {"sha": "b3bc898748fdc00ba3637c5efde0d0bc473255cd", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -111,19 +111,19 @@ impl<'a> PluginLoader<'a> {\n             // inside this crate, so continue would spew \"macro undefined\"\n             // errors\n             Err(err) => {\n-                self.sess.span_fatal(span, &err[])\n+                self.sess.span_fatal(span, &err[..])\n             }\n         };\n \n         unsafe {\n             let registrar =\n-                match lib.symbol(&symbol[]) {\n+                match lib.symbol(&symbol[..]) {\n                     Ok(registrar) => {\n                         mem::transmute::<*mut u8,PluginRegistrarFun>(registrar)\n                     }\n                     // again fatal if we can't register macros\n                     Err(err) => {\n-                        self.sess.span_fatal(span, &err[])\n+                        self.sess.span_fatal(span, &err[..])\n                     }\n                 };\n "}, {"sha": "93a25de0491fe018ab8fef7d7e11435c80c211e4", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -629,7 +629,7 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n         append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n     }\n     let mut v = user_cfg.into_iter().collect::<Vec<_>>();\n-    v.push_all(&default_cfg[]);\n+    v.push_all(&default_cfg[..]);\n     v\n }\n \n@@ -824,7 +824,7 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n     let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n-        .unwrap_or_else(|e| early_error(&e[]));\n+        .unwrap_or_else(|e| early_error(&e[..]));\n \n     let mut lint_opts = vec!();\n     let mut describe_lints = false;\n@@ -923,7 +923,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let mut search_paths = SearchPaths::new();\n     for s in &matches.opt_strs(\"L\") {\n-        search_paths.add_path(&s[]);\n+        search_paths.add_path(&s[..]);\n     }\n \n     let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n@@ -981,7 +981,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                     --debuginfo\");\n     }\n \n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[]) {\n+    let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n         Some(\"auto\")   => Auto,\n         Some(\"always\") => Always,\n         Some(\"never\")  => Never,\n@@ -1119,7 +1119,7 @@ mod test {\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None, registry);\n         let cfg = build_configuration(&sess);\n-        assert!((attr::contains_name(&cfg[], \"test\")));\n+        assert!((attr::contains_name(&cfg[..], \"test\")));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add"}, {"sha": "c1c5518887577d83462db5a07e032c48012f497e", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -75,13 +75,13 @@ impl Session {\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n         match split_msg_into_multilines(msg) {\n-            Some(msg) => self.diagnostic().span_err(sp, &msg[]),\n+            Some(msg) => self.diagnostic().span_err(sp, &msg[..]),\n             None => self.diagnostic().span_err(sp, msg)\n         }\n     }\n     pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n         match split_msg_into_multilines(msg) {\n-            Some(msg) => self.diagnostic().span_err_with_code(sp, &msg[], code),\n+            Some(msg) => self.diagnostic().span_err_with_code(sp, &msg[..], code),\n             None => self.diagnostic().span_err_with_code(sp, msg, code)\n         }\n     }"}, {"sha": "10a7b2abea80bb389e3213ec3895b27661ded2d8", "filename": "src/librustc/util/lev_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -48,7 +48,7 @@ fn test_lev_distance() {\n     for c in (0u32..MAX as u32)\n              .filter_map(|i| from_u32(i))\n              .map(|i| i.to_string()) {\n-        assert_eq!(lev_distance(&c[], &c[]), 0);\n+        assert_eq!(lev_distance(&c[..], &c[..]), 0);\n     }\n \n     let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";"}, {"sha": "1d46c011bb32e7298334fa4a1ea5318b1565feb4", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -293,7 +293,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             Some(def_id) => {\n                 s.push_str(\" {\");\n                 let path_str = ty::item_path_str(cx, def_id);\n-                s.push_str(&path_str[]);\n+                s.push_str(&path_str[..]);\n                 s.push_str(\"}\");\n             }\n             None => { }\n@@ -377,7 +377,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 .iter()\n                 .map(|elem| ty_to_string(cx, *elem))\n                 .collect::<Vec<_>>();\n-            match &strs[] {\n+            match &strs[..] {\n                 [ref string] => format!(\"({},)\", string),\n                 strs => format!(\"({})\", strs.connect(\", \"))\n             }\n@@ -639,15 +639,15 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for [T] {\n \n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for OwnedSlice<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, &self[])\n+        repr_vec(tcx, &self[..])\n     }\n }\n \n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Vec<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, &self[])\n+        repr_vec(tcx, &self[..])\n     }\n }\n \n@@ -687,7 +687,7 @@ impl<'tcx> UserString<'tcx> for TraitAndProjections<'tcx> {\n                       &base,\n                       trait_ref.substs,\n                       trait_ref.def_id,\n-                      &projection_bounds[],\n+                      &projection_bounds[..],\n                       || ty::lookup_trait_def(tcx, trait_ref.def_id).generics.clone())\n     }\n }\n@@ -1273,7 +1273,7 @@ impl<'tcx, T> UserString<'tcx> for ty::Binder<T>\n                 }\n             })\n         });\n-        let names: Vec<_> = names.iter().map(|s| &s[]).collect();\n+        let names: Vec<_> = names.iter().map(|s| &s[..]).collect();\n \n         let value_str = unbound_value.user_string(tcx);\n         if names.len() == 0 {"}, {"sha": "c45ee258342ec1be9c24a8f83d03f2bdae694488", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -53,7 +53,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n           args: &str, cwd: Option<&Path>,\n           paths: &[&Path]) -> ProcessOutput {\n     let ar = match *maybe_ar_prog {\n-        Some(ref ar) => &ar[],\n+        Some(ref ar) => &ar[..],\n         None => \"ar\"\n     };\n     let mut cmd = Command::new(ar);\n@@ -84,7 +84,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n             o\n         },\n         Err(e) => {\n-            handler.err(&format!(\"could not exec `{}`: {}\", &ar[],\n+            handler.err(&format!(\"could not exec `{}`: {}\", &ar[..],\n                              e)[]);\n             handler.abort_if_errors();\n             panic!(\"rustc::back::archive::run_ar() should not reach this point\");\n@@ -101,10 +101,10 @@ pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n \n     for path in search_paths {\n         debug!(\"looking for {} inside {:?}\", name, path.display());\n-        let test = path.join(&oslibname[]);\n+        let test = path.join(&oslibname[..]);\n         if test.exists() { return test }\n         if oslibname != unixlibname {\n-            let test = path.join(&unixlibname[]);\n+            let test = path.join(&unixlibname[..]);\n             if test.exists() { return test }\n         }\n     }\n@@ -192,12 +192,12 @@ impl<'a> ArchiveBuilder<'a> {\n         // as simple comparison is not enough - there\n         // might be also an extra name suffix\n         let obj_start = format!(\"{}\", name);\n-        let obj_start = &obj_start[];\n+        let obj_start = &obj_start[..];\n         // Ignoring all bytecode files, no matter of\n         // name\n         let bc_ext = \".bytecode.deflate\";\n \n-        self.add_archive(rlib, &name[], |fname: &str| {\n+        self.add_archive(rlib, &name[..], |fname: &str| {\n             let skip_obj = lto && fname.starts_with(obj_start)\n                 && fname.ends_with(\".o\");\n             skip_obj || fname.ends_with(bc_ext) || fname == METADATA_FILENAME\n@@ -234,7 +234,7 @@ impl<'a> ArchiveBuilder<'a> {\n             // allow running `ar s file.a` to update symbols only.\n             if self.should_update_symbols {\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"s\", Some(self.work_dir.path()), &args[]);\n+                       \"s\", Some(self.work_dir.path()), &args[..]);\n             }\n             return self.archive;\n         }\n@@ -254,7 +254,7 @@ impl<'a> ArchiveBuilder<'a> {\n                 // Add the archive members seen so far, without updating the\n                 // symbol table (`S`).\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"cruS\", Some(self.work_dir.path()), &args[]);\n+                       \"cruS\", Some(self.work_dir.path()), &args[..]);\n \n                 args.clear();\n                 args.push(&abs_dst);\n@@ -269,7 +269,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // necessary.\n         let flags = if self.should_update_symbols { \"crus\" } else { \"cruS\" };\n         run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-               flags, Some(self.work_dir.path()), &args[]);\n+               flags, Some(self.work_dir.path()), &args[..]);\n \n         self.archive\n     }\n@@ -312,7 +312,7 @@ impl<'a> ArchiveBuilder<'a> {\n             } else {\n                 filename\n             };\n-            let new_filename = self.work_dir.path().join(&filename[]);\n+            let new_filename = self.work_dir.path().join(&filename[..]);\n             try!(fs::rename(file, &new_filename));\n             self.members.push(Path::new(filename));\n         }"}, {"sha": "e7419d4bec30747717d0bf68c88a3a26db383d7b", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -41,8 +41,8 @@ pub fn get_rpath_flags<F, G>(config: RPathConfig<F, G>) -> Vec<String> where\n \n     let libs = config.used_crates.clone();\n     let libs = libs.into_iter().filter_map(|(_, l)| l).collect::<Vec<_>>();\n-    let rpaths = get_rpaths(config, &libs[]);\n-    flags.push_all(&rpaths_to_flags(&rpaths[])[]);\n+    let rpaths = get_rpaths(config, &libs[..]);\n+    flags.push_all(&rpaths_to_flags(&rpaths[..]));\n     flags\n }\n \n@@ -79,14 +79,14 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n         }\n     }\n \n-    log_rpaths(\"relative\", &rel_rpaths[]);\n-    log_rpaths(\"fallback\", &fallback_rpaths[]);\n+    log_rpaths(\"relative\", &rel_rpaths[..]);\n+    log_rpaths(\"fallback\", &fallback_rpaths[..]);\n \n     let mut rpaths = rel_rpaths;\n-    rpaths.push_all(&fallback_rpaths[]);\n+    rpaths.push_all(&fallback_rpaths[..]);\n \n     // Remove duplicates\n-    let rpaths = minimize_rpaths(&rpaths[]);\n+    let rpaths = minimize_rpaths(&rpaths[..]);\n     return rpaths;\n }\n \n@@ -136,7 +136,7 @@ fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n     let mut set = HashSet::new();\n     let mut minimized = Vec::new();\n     for rpath in rpaths {\n-        if set.insert(&rpath[]) {\n+        if set.insert(&rpath[..]) {\n             minimized.push(rpath.clone());\n         }\n     }"}, {"sha": "01a5f0d6e20f881c481ad0e62f8153fdc21d3ece", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -254,18 +254,18 @@ impl Target {\n         macro_rules! key {\n             ($key_name:ident) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[]).map(|o| o.as_string()\n+                obj.find(&name[..]).map(|o| o.as_string()\n                                     .map(|s| base.options.$key_name = s.to_string()));\n             } );\n             ($key_name:ident, bool) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[])\n+                obj.find(&name[..])\n                     .map(|o| o.as_boolean()\n                          .map(|s| base.options.$key_name = s));\n             } );\n             ($key_name:ident, list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[]).map(|o| o.as_array()\n+                obj.find(&name[..]).map(|o| o.as_array()\n                     .map(|v| base.options.$key_name = v.iter()\n                         .map(|a| a.as_string().unwrap().to_string()).collect()\n                         )"}, {"sha": "abe01d193b4929b308f04dc3051b7cff761ccec5", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -656,7 +656,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                 &self.bccx.loan_path_to_string(move_path)[])\n                 };\n \n-                self.bccx.span_err(span, &err_message[]);\n+                self.bccx.span_err(span, &err_message[..]);\n                 self.bccx.span_note(\n                     loan_span,\n                     &format!(\"borrow of `{}` occurs here\","}, {"sha": "c873831cb0f657b6faa3fb81a16641b55211ce5c", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -38,7 +38,7 @@ enum Fragment {\n     // This represents the collection of all but one of the elements\n     // from an array at the path described by the move path index.\n     // Note that attached MovePathIndex should have mem_categorization\n-    // of InteriorElement (i.e. array dereference `&foo[]`).\n+    // of InteriorElement (i.e. array dereference `&foo[..]`).\n     AllButOneFrom(MovePathIndex),\n }\n \n@@ -198,11 +198,11 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     // First, filter out duplicates\n     moved.sort();\n     moved.dedup();\n-    debug!(\"fragments 1 moved: {:?}\", path_lps(&moved[]));\n+    debug!(\"fragments 1 moved: {:?}\", path_lps(&moved[..]));\n \n     assigned.sort();\n     assigned.dedup();\n-    debug!(\"fragments 1 assigned: {:?}\", path_lps(&assigned[]));\n+    debug!(\"fragments 1 assigned: {:?}\", path_lps(&assigned[..]));\n \n     // Second, build parents from the moved and assigned.\n     for m in &moved {\n@@ -222,14 +222,14 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     parents.sort();\n     parents.dedup();\n-    debug!(\"fragments 2 parents: {:?}\", path_lps(&parents[]));\n+    debug!(\"fragments 2 parents: {:?}\", path_lps(&parents[..]));\n \n     // Third, filter the moved and assigned fragments down to just the non-parents\n-    moved.retain(|f| non_member(*f, &parents[]));\n-    debug!(\"fragments 3 moved: {:?}\", path_lps(&moved[]));\n+    moved.retain(|f| non_member(*f, &parents[..]));\n+    debug!(\"fragments 3 moved: {:?}\", path_lps(&moved[..]));\n \n-    assigned.retain(|f| non_member(*f, &parents[]));\n-    debug!(\"fragments 3 assigned: {:?}\", path_lps(&assigned[]));\n+    assigned.retain(|f| non_member(*f, &parents[..]));\n+    debug!(\"fragments 3 assigned: {:?}\", path_lps(&assigned[..]));\n \n     // Fourth, build the leftover from the moved, assigned, and parents.\n     for m in &moved {\n@@ -247,16 +247,16 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     unmoved.sort();\n     unmoved.dedup();\n-    debug!(\"fragments 4 unmoved: {:?}\", frag_lps(&unmoved[]));\n+    debug!(\"fragments 4 unmoved: {:?}\", frag_lps(&unmoved[..]));\n \n     // Fifth, filter the leftover fragments down to its core.\n     unmoved.retain(|f| match *f {\n         AllButOneFrom(_) => true,\n-        Just(mpi) => non_member(mpi, &parents[]) &&\n-            non_member(mpi, &moved[]) &&\n-            non_member(mpi, &assigned[])\n+        Just(mpi) => non_member(mpi, &parents[..]) &&\n+            non_member(mpi, &moved[..]) &&\n+            non_member(mpi, &assigned[..])\n     });\n-    debug!(\"fragments 5 unmoved: {:?}\", frag_lps(&unmoved[]));\n+    debug!(\"fragments 5 unmoved: {:?}\", frag_lps(&unmoved[..]));\n \n     // Swap contents back in.\n     fragments.unmoved_fragments = unmoved;\n@@ -437,7 +437,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             let msg = format!(\"type {} ({:?}) is not fragmentable\",\n                               parent_ty.repr(tcx), sty_and_variant_info);\n             let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n-            tcx.sess.opt_span_bug(opt_span, &msg[])\n+            tcx.sess.opt_span_bug(opt_span, &msg[..])\n         }\n     }\n }"}, {"sha": "518e4bc472ca4aa6c117c8db26f9e0796ad5ce93", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -137,7 +137,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     check_loans::check_loans(this,\n                              &loan_dfcx,\n                              flowed_moves,\n-                             &all_loans[],\n+                             &all_loans[..],\n                              id,\n                              decl,\n                              body);"}, {"sha": "39c9d9ba6ad24ae5f067b893c66627c6d4e209a8", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -89,7 +89,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n                 set.push_str(\", \");\n             }\n             let loan_str = self.borrowck_ctxt.loan_path_to_string(&*lp);\n-            set.push_str(&loan_str[]);\n+            set.push_str(&loan_str[..]);\n             saw_some = true;\n             true\n         });"}, {"sha": "a260997f605940da7ac8d8fd6b83c9e93232af1b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -85,7 +85,7 @@ pub fn compile_input(sess: Session,\n             let expanded_crate\n                 = match phase_2_configure_and_expand(&sess,\n                                                      krate,\n-                                                     &id[],\n+                                                     &id[..],\n                                                      addl_plugins) {\n                     None => return,\n                     Some(k) => k\n@@ -99,20 +99,20 @@ pub fn compile_input(sess: Session,\n                                                                  &sess,\n                                                                  outdir,\n                                                                  &expanded_crate,\n-                                                                 &id[]));\n+                                                                 &id[..]));\n \n         let mut forest = ast_map::Forest::new(expanded_crate);\n         let arenas = ty::CtxtArenas::new();\n         let ast_map = assign_node_ids_and_map(&sess, &mut forest);\n \n-        write_out_deps(&sess, input, &outputs, &id[]);\n+        write_out_deps(&sess, input, &outputs, &id[..]);\n \n         controller_entry_point!(after_write_deps,\n                                 CompileState::state_after_write_deps(input,\n                                                                      &sess,\n                                                                      outdir,\n                                                                      &ast_map,\n-                                                                     &id[]));\n+                                                                     &id[..]));\n \n         let analysis = phase_3_run_analysis_passes(sess,\n                                                    ast_map,"}, {"sha": "2550432c8101adde411a3828936cb1a031eecaa0", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -272,7 +272,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                       -> Compilation {\n         match matches.opt_str(\"explain\") {\n             Some(ref code) => {\n-                match descriptions.find_description(&code[]) {\n+                match descriptions.find_description(&code[..]) {\n                     Some(ref description) => {\n                         println!(\"{}\", description);\n                     }\n@@ -582,7 +582,7 @@ Available lint options:\n         for lint in lints {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n             println!(\"    {}  {:7.7}  {}\",\n-                     padded(&name[]), lint.default_level.as_str(), lint.desc);\n+                     padded(&name[..]), lint.default_level.as_str(), lint.desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -612,7 +612,7 @@ Available lint options:\n             let desc = to.into_iter().map(|x| x.as_str().replace(\"_\", \"-\"))\n                          .collect::<Vec<String>>().connect(\", \");\n             println!(\"    {}  {}\",\n-                     padded(&name[]), desc);\n+                     padded(&name[..]), desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -678,7 +678,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     }\n \n     let matches =\n-        match getopts::getopts(&args[], &config::optgroups()[]) {\n+        match getopts::getopts(&args[..], &config::optgroups()[]) {\n             Ok(m) => m,\n             Err(f_stable_attempt) => {\n                 // redo option parsing, including unstable options this time,\n@@ -803,7 +803,7 @@ pub fn monitor<F:FnOnce()+Send+'static>(f: F) {\n                     \"run with `RUST_BACKTRACE=1` for a backtrace\".to_string(),\n                 ];\n                 for note in &xs {\n-                    emitter.emit(None, &note[], None, diagnostic::Note)\n+                    emitter.emit(None, &note[..], None, diagnostic::Note)\n                 }\n \n                 match r.read_to_string() {"}, {"sha": "0fbfa5fd89dd7f3fdc1216ccb271332640b6fff2", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -383,7 +383,7 @@ impl UserIdentifiedItem {\n             ItemViaNode(node_id) =>\n                 NodesMatchingDirect(Some(node_id).into_iter()),\n             ItemViaPath(ref parts) =>\n-                NodesMatchingSuffix(map.nodes_matching_suffix(&parts[])),\n+                NodesMatchingSuffix(map.nodes_matching_suffix(&parts[..])),\n         }\n     }\n \n@@ -395,7 +395,7 @@ impl UserIdentifiedItem {\n                         user_option,\n                         self.reconstructed_input(),\n                         is_wrong_because);\n-            sess.fatal(&message[])\n+            sess.fatal(&message[..])\n         };\n \n         let mut saw_node = ast::DUMMY_NODE_ID;\n@@ -522,7 +522,7 @@ pub fn pretty_print_input(sess: Session,\n     let is_expanded = needs_expansion(&ppm);\n     let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n     let krate = if compute_ast_map {\n-        match driver::phase_2_configure_and_expand(&sess, krate, &id[], None) {\n+        match driver::phase_2_configure_and_expand(&sess, krate, &id[..], None) {\n             None => return,\n             Some(k) => k\n         }\n@@ -541,7 +541,7 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src_name = driver::source_name(input);\n-    let src = sess.codemap().get_filemap(&src_name[])\n+    let src = sess.codemap().get_filemap(&src_name[..])\n                             .src.as_bytes().to_vec();\n     let mut rdr = MemReader::new(src);\n \n@@ -632,8 +632,8 @@ pub fn pretty_print_input(sess: Session,\n                     // point to what was found, if there's an\n                     // accessible span.\n                     match ast_map.opt_span(nodeid) {\n-                        Some(sp) => sess.span_fatal(sp, &message[]),\n-                        None => sess.fatal(&message[])\n+                        Some(sp) => sess.span_fatal(sp, &message[..]),\n+                        None => sess.fatal(&message[..])\n                     }\n                 }\n             }"}, {"sha": "fbbd72e2c76be6efd75fe6182759d3d578997c0a", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -278,7 +278,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn t_param(&self, space: subst::ParamSpace, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        ty::mk_param(self.infcx.tcx, space, index, token::intern(&name[]))\n+        ty::mk_param(self.infcx.tcx, space, index, token::intern(&name[..]))\n     }\n \n     pub fn re_early_bound(&self,"}, {"sha": "5662a74a53d34d087f06eae47370427c8e01d1e0", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -585,10 +585,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         match result {\n             None => true,\n             Some((span, msg, note)) => {\n-                self.tcx.sess.span_err(span, &msg[]);\n+                self.tcx.sess.span_err(span, &msg[..]);\n                 match note {\n                     Some((span, msg)) => {\n-                        self.tcx.sess.span_note(span, &msg[])\n+                        self.tcx.sess.span_note(span, &msg[..])\n                     }\n                     None => {},\n                 }\n@@ -690,7 +690,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             UnnamedField(idx) => format!(\"field #{} of {} is private\",\n                                          idx + 1, struct_desc),\n         };\n-        self.tcx.sess.span_err(span, &msg[]);\n+        self.tcx.sess.span_err(span, &msg[..]);\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope."}, {"sha": "333d32d76b6d5fc85c8f63ea874eec047c5a46e5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -1071,7 +1071,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                           &import_directive.module_path[],\n                                           import_directive.subclass),\n                                       help);\n-                    self.resolve_error(span, &msg[]);\n+                    self.resolve_error(span, &msg[..]);\n                 }\n                 Indeterminate => break, // Bail out. We'll come around next time.\n                 Success(()) => () // Good. Continue.\n@@ -1101,7 +1101,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         .iter()\n                                         .map(|seg| seg.identifier.name)\n                                         .collect();\n-        self.names_to_string(&names[])\n+        self.names_to_string(&names[..])\n     }\n \n     fn import_directive_subclass_to_string(&mut self,\n@@ -1165,7 +1165,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let module_path = &import_directive.module_path;\n \n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               self.names_to_string(&module_path[]),\n+               self.names_to_string(&module_path[..]),\n                self.module_to_string(&*module_));\n \n         // First, resolve the module path for the directive, if necessary.\n@@ -1174,7 +1174,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some((self.graph_root.get_module(), LastMod(AllPublic)))\n         } else {\n             match self.resolve_module_path(module_.clone(),\n-                                           &module_path[],\n+                                           &module_path[..],\n                                            DontUseLexicalScope,\n                                            import_directive.span,\n                                            ImportSearch) {\n@@ -1767,7 +1767,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     ValueNS => \"value\",\n                                   },\n                                   &token::get_name(name));\n-                span_err!(self.session, import_span, E0252, \"{}\", &msg[]);\n+                span_err!(self.session, import_span, E0252, \"{}\", &msg[..]);\n             }\n             Some(_) | None => {}\n         }\n@@ -1782,7 +1782,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n                               token::get_name(name));\n-            span_err!(self.session, import_span, E0253, \"{}\", &msg[]);\n+            span_err!(self.session, import_span, E0253, \"{}\", &msg[..]);\n         }\n     }\n \n@@ -1803,7 +1803,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n                                       &token::get_name(name));\n-                    span_err!(self.session, import_span, E0254, \"{}\", &msg[]);\n+                    span_err!(self.session, import_span, E0254, \"{}\", &msg[..]);\n                 }\n                 Some(_) | None => {}\n             }\n@@ -1825,7 +1825,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let msg = format!(\"import `{}` conflicts with value \\\n                                        in this module\",\n                                       &token::get_name(name));\n-                    span_err!(self.session, import_span, E0255, \"{}\", &msg[]);\n+                    span_err!(self.session, import_span, E0255, \"{}\", &msg[..]);\n                     if let Some(span) = value.value_span {\n                         self.session.span_note(span,\n                                                \"conflicting value here\");\n@@ -1843,7 +1843,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             let msg = format!(\"import `{}` conflicts with type in \\\n                                                this module\",\n                                               &token::get_name(name));\n-                            span_err!(self.session, import_span, E0256, \"{}\", &msg[]);\n+                            span_err!(self.session, import_span, E0256, \"{}\", &msg[..]);\n                             if let Some(span) = ty.type_span {\n                                 self.session.span_note(span,\n                                                        \"note conflicting type here\")\n@@ -1856,7 +1856,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         let msg = format!(\"inherent implementations \\\n                                                            are only allowed on types \\\n                                                            defined in the current module\");\n-                                        span_err!(self.session, span, E0257, \"{}\", &msg[]);\n+                                        span_err!(self.session, span, E0257, \"{}\", &msg[..]);\n                                         self.session.span_note(import_span,\n                                                                \"import from other module here\")\n                                     }\n@@ -1865,7 +1865,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     let msg = format!(\"import `{}` conflicts with existing \\\n                                                        submodule\",\n                                                       &token::get_name(name));\n-                                    span_err!(self.session, import_span, E0258, \"{}\", &msg[]);\n+                                    span_err!(self.session, import_span, E0258, \"{}\", &msg[..]);\n                                     if let Some(span) = ty.type_span {\n                                         self.session.span_note(span,\n                                                                \"note conflicting module here\")\n@@ -1949,7 +1949,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let segment_name = token::get_name(name);\n                     let module_name = self.module_to_string(&*search_module);\n                     let mut span = span;\n-                    let msg = if \"???\" == &module_name[] {\n+                    let msg = if \"???\" == &module_name[..] {\n                         span.hi = span.lo + Pos::from_usize(segment_name.len());\n \n                         match search_parent_externals(name,\n@@ -2062,7 +2062,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match module_prefix_result {\n             Failed(None) => {\n                 let mpath = self.names_to_string(module_path);\n-                let mpath = &mpath[];\n+                let mpath = &mpath[..];\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n                         let msg = format!(\"Could not find `{}` in `{}`\",\n@@ -2365,11 +2365,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut containing_module;\n         let mut i;\n         let first_module_path_string = token::get_name(module_path[0]);\n-        if \"self\" == &first_module_path_string[] {\n+        if \"self\" == &first_module_path_string[..] {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 1;\n-        } else if \"super\" == &first_module_path_string[] {\n+        } else if \"super\" == &first_module_path_string[..] {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 0;  // We'll handle `super` below.\n@@ -2380,7 +2380,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Now loop through all the `super`s we find.\n         while i < module_path.len() {\n             let string = token::get_name(module_path[i]);\n-            if \"super\" != &string[] {\n+            if \"super\" != &string[..] {\n                 break\n             }\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n@@ -2511,7 +2511,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n                                   sn);\n-                self.resolve_error((*imports)[index].span, &err[]);\n+                self.resolve_error((*imports)[index].span, &err[..]);\n             }\n         }\n \n@@ -2849,7 +2849,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                             generics,\n                                             implemented_traits,\n                                             &**self_type,\n-                                            &impl_items[]);\n+                                            &impl_items[..]);\n             }\n \n             ItemTrait(_, ref generics, ref bounds, ref trait_items) => {\n@@ -3192,7 +3192,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n-                self.resolve_error(trait_reference.path.span, &msg[]);\n+                self.resolve_error(trait_reference.path.span, &msg[..]);\n             }\n             Some(def) => {\n                 match def {\n@@ -3620,7 +3620,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         let msg = format!(\"use of undeclared type name `{}`\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(ty.span, &msg[]);\n+                        self.resolve_error(ty.span, &msg[..]);\n                     }\n                 }\n             }\n@@ -3821,7 +3821,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     def: {:?}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n                                               self.path_names_to_string(path));\n-                            self.resolve_error(path.span, &msg[]);\n+                            self.resolve_error(path.span, &msg[..]);\n                         }\n                     }\n                 }\n@@ -4078,7 +4078,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let last_private;\n         let module = self.current_module.clone();\n         match self.resolve_module_path(module,\n-                                       &module_path[],\n+                                       &module_path[..],\n                                        UseLexicalScope,\n                                        path.span,\n                                        PathSearch) {\n@@ -4136,7 +4136,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let containing_module;\n         let last_private;\n         match self.resolve_module_path_from_root(root_module,\n-                                                 &module_path[],\n+                                                 &module_path[..],\n                                                  0,\n                                                  path.span,\n                                                  PathSearch,\n@@ -4146,7 +4146,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared module `::{}`\",\n-                                          self.names_to_string(&module_path[]));\n+                                          self.names_to_string(&module_path[..]));\n                         (path.span, msg)\n                     }\n                 };\n@@ -4305,7 +4305,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             } else {\n                 match this.resolve_module_path(root,\n-                                                &name_path[],\n+                                                &name_path[..],\n                                                 UseLexicalScope,\n                                                 span,\n                                                 PathSearch) {\n@@ -4343,7 +4343,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name_path = path.segments.iter().map(|seg| seg.identifier.name).collect::<Vec<_>>();\n \n         // Look for a method in the current self type's impl module.\n-        match get_module(self, path.span, &name_path[]) {\n+        match get_module(self, path.span, &name_path[..]) {\n             Some(module) => match module.children.borrow().get(&name) {\n                 Some(binding) => {\n                     let p_str = self.path_names_to_string(&path);\n@@ -4564,7 +4564,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 def: {:?}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(path.span, &msg[]);\n+                        self.resolve_error(path.span, &msg[..]);\n                     }\n                 }\n "}, {"sha": "ef849bb3dca056348147adbf6a0a154e5c9d2dd4", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -127,7 +127,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n     let validate = |s: String, span: Option<Span>| {\n-        creader::validate_crate_name(sess, &s[], span);\n+        creader::validate_crate_name(sess, &s[..], span);\n         s\n     };\n \n@@ -141,11 +141,11 @@ pub fn find_crate_name(sess: Option<&Session>,\n     if let Some(sess) = sess {\n         if let Some(ref s) = sess.opts.crate_name {\n             if let Some((attr, ref name)) = attr_crate_name {\n-                if *s != &name[] {\n+                if *s != &name[..] {\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);\n-                    sess.span_err(attr.span, &msg[]);\n+                    sess.span_err(attr.span, &msg[..]);\n                 }\n             }\n             return validate(s.clone(), None);\n@@ -195,7 +195,7 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(link_meta.crate_hash.as_str());\n     for meta in &*tcx.sess.crate_metadata.borrow() {\n-        symbol_hasher.input_str(&meta[]);\n+        symbol_hasher.input_str(&meta[..]);\n     }\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(&encoder::encoded_ty(tcx, t)[]);\n@@ -262,7 +262,7 @@ pub fn sanitize(s: &str) -> String {\n     if result.len() > 0 &&\n         result.as_bytes()[0] != '_' as u8 &&\n         ! (result.as_bytes()[0] as char).is_xid_start() {\n-        return format!(\"_{}\", &result[]);\n+        return format!(\"_{}\", &result[..]);\n     }\n \n     return result;\n@@ -331,17 +331,17 @@ pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathEl\n     hash.push(EXTRA_CHARS.as_bytes()[extra2] as char);\n     hash.push(EXTRA_CHARS.as_bytes()[extra3] as char);\n \n-    exported_name(path, &hash[])\n+    exported_name(path, &hash[..])\n }\n \n pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                       t: Ty<'tcx>,\n                                                       name: &str) -> String {\n     let s = ppaux::ty_to_string(ccx.tcx(), t);\n-    let path = [PathName(token::intern(&s[])),\n+    let path = [PathName(token::intern(&s[..])),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n-    mangle(path.iter().cloned(), Some(&hash[]))\n+    mangle(path.iter().cloned(), Some(&hash[..]))\n }\n \n pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> String {\n@@ -541,7 +541,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     for &(ref l, kind) in &*sess.cstore.get_used_libraries().borrow() {\n         match kind {\n             cstore::NativeStatic => {\n-                ab.add_native_library(&l[]).unwrap();\n+                ab.add_native_library(&l[..]).unwrap();\n             }\n             cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n@@ -619,7 +619,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                                                  e)[])\n                 };\n \n-                let bc_data_deflated = match flate::deflate_bytes(&bc_data[]) {\n+                let bc_data_deflated = match flate::deflate_bytes(&bc_data[..]) {\n                     Some(compressed) => compressed,\n                     None => sess.fatal(&format!(\"failed to compress bytecode from {}\",\n                                                bc_filename.display())[])\n@@ -678,7 +678,7 @@ fn write_rlib_bytecode_object_v1<T: Writer>(writer: &mut T,\n     try! { writer.write_all(RLIB_BYTECODE_OBJECT_MAGIC) };\n     try! { writer.write_le_u32(1) };\n     try! { writer.write_le_u64(bc_data_deflated_size) };\n-    try! { writer.write_all(&bc_data_deflated[]) };\n+    try! { writer.write_all(&bc_data_deflated[..]) };\n \n     let number_of_bytes_written_so_far =\n         RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id\n@@ -733,7 +733,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n                 continue\n             }\n         };\n-        ab.add_rlib(&p, &name[], sess.lto()).unwrap();\n+        ab.add_rlib(&p, &name[..], sess.lto()).unwrap();\n \n         let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         all_native_libs.extend(native_libs.into_iter());\n@@ -769,7 +769,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n \n     // The invocations of cc share some flags across platforms\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(&pname[]);\n+    let mut cmd = Command::new(&pname[..]);\n \n     cmd.args(&sess.target.target.options.pre_link_args[]);\n     link_args(&mut cmd, sess, dylib, tmpdir.path(),\n@@ -798,7 +798,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n                 sess.note(&format!(\"{:?}\", &cmd)[]);\n                 let mut output = prog.error.clone();\n                 output.push_all(&prog.output[]);\n-                sess.note(str::from_utf8(&output[]).unwrap());\n+                sess.note(str::from_utf8(&output[..]).unwrap());\n                 sess.abort_if_errors();\n             }\n             debug!(\"linker stderr:\\n{}\", String::from_utf8(prog.error).unwrap());\n@@ -868,7 +868,7 @@ fn link_args(cmd: &mut Command,\n \n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(morestack.as_vec());\n-            cmd.arg(&v[]);\n+            cmd.arg(&v[..]);\n         } else {\n             cmd.args(&[\"-Wl,--whole-archive\", \"-lmorestack\", \"-Wl,--no-whole-archive\"]);\n         }\n@@ -993,7 +993,7 @@ fn link_args(cmd: &mut Command,\n             if sess.opts.cg.rpath {\n                 let mut v = \"-Wl,-install_name,@rpath/\".as_bytes().to_vec();\n                 v.push_all(out_filename.filename().unwrap());\n-                cmd.arg(&v[]);\n+                cmd.arg(&v[..]);\n             }\n         } else {\n             cmd.arg(\"-shared\");\n@@ -1029,7 +1029,7 @@ fn link_args(cmd: &mut Command,\n     // with any #[link_args] attributes found inside the crate\n     let empty = Vec::new();\n     cmd.args(&sess.opts.cg.link_args.as_ref().unwrap_or(&empty)[]);\n-    cmd.args(&used_link_args[]);\n+    cmd.args(&used_link_args[..]);\n }\n \n // # Native library linking\n@@ -1086,14 +1086,14 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n         } else {\n             // -force_load is the OSX equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n-            let lib = archive::find_library(&l[],\n+            let lib = archive::find_library(&l[..],\n                                             &sess.target.target.options.staticlib_prefix,\n                                             &sess.target.target.options.staticlib_suffix,\n-                                            &search_path[],\n+                                            &search_path[..],\n                                             &sess.diagnostic().handler);\n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(lib.as_vec());\n-            cmd.arg(&v[]);\n+            cmd.arg(&v[..]);\n         }\n     }\n     if takes_hints {\n@@ -1106,7 +1106,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n                 cmd.arg(format!(\"-l{}\", l));\n             }\n             cstore::NativeFramework => {\n-                cmd.arg(\"-framework\").arg(&l[]);\n+                cmd.arg(\"-framework\").arg(&l[..]);\n             }\n             cstore::NativeStatic => unreachable!(),\n         }\n@@ -1248,7 +1248,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n \n         let mut v = \"-l\".as_bytes().to_vec();\n         v.push_all(unlib(&sess.target, cratepath.filestem().unwrap()));\n-        cmd.arg(&v[]);\n+        cmd.arg(&v[..]);\n     }\n }\n \n@@ -1290,7 +1290,7 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n                 }\n                 cstore::NativeFramework => {\n                     cmd.arg(\"-framework\");\n-                    cmd.arg(&lib[]);\n+                    cmd.arg(&lib[..]);\n                 }\n                 cstore::NativeStatic => {\n                     sess.bug(\"statics shouldn't be propagated\");"}, {"sha": "0a0f2a9c18627adeb821ca15e03c7f21b881119d", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -132,7 +132,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                                                         bc_decoded.len() as libc::size_t) {\n                     write::llvm_err(sess.diagnostic().handler(),\n                                     format!(\"failed to load bc of `{}`\",\n-                                            &name[]));\n+                                            &name[..]));\n                 }\n             });\n         }"}, {"sha": "86b720d3fc171191f451bb9bc31a32e4eedef4ef", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -47,14 +47,14 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n-            handler.fatal(&msg[]);\n+            handler.fatal(&msg[..]);\n         } else {\n             let err = CStr::from_ptr(cstr).to_bytes();\n             let err = String::from_utf8_lossy(err).to_string();\n             libc::free(cstr as *mut _);\n             handler.fatal(&format!(\"{}: {}\",\n-                                  &msg[],\n-                                  &err[])[]);\n+                                  &msg[..],\n+                                  &err[..])[]);\n         }\n     }\n }\n@@ -105,7 +105,7 @@ impl SharedEmitter {\n                 Some(ref code) => {\n                     handler.emit_with_code(None,\n                                            &diag.msg[],\n-                                           &code[],\n+                                           &code[..],\n                                            diag.lvl);\n                 },\n                 None => {\n@@ -165,7 +165,7 @@ fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n \n fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let reloc_model_arg = match sess.opts.cg.relocation_model {\n-        Some(ref s) => &s[],\n+        Some(ref s) => &s[..],\n         None => &sess.target.target.options.relocation_model[]\n     };\n     let reloc_model = match reloc_model_arg {\n@@ -198,7 +198,7 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let fdata_sections = ffunction_sections;\n \n     let code_model_arg = match sess.opts.cg.code_model {\n-        Some(ref s) => &s[],\n+        Some(ref s) => &s[..],\n         None => &sess.target.target.options.code_model[]\n     };\n \n@@ -365,7 +365,7 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n     let msg = llvm::build_string(|s| llvm::LLVMWriteSMDiagnosticToString(diag, s))\n         .expect(\"non-UTF8 SMDiagnostic\");\n \n-    report_inline_asm(cgcx, &msg[], cookie);\n+    report_inline_asm(cgcx, &msg[..], cookie);\n }\n \n unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_void) {\n@@ -711,7 +711,7 @@ pub fn run_passes(sess: &Session,\n             };\n \n         let pname = get_cc_prog(sess);\n-        let mut cmd = Command::new(&pname[]);\n+        let mut cmd = Command::new(&pname[..]);\n \n         cmd.args(&sess.target.target.options.pre_link_args[]);\n         cmd.arg(\"-nostdlib\");\n@@ -829,12 +829,12 @@ pub fn run_passes(sess: &Session,\n         for i in 0..trans.modules.len() {\n             if modules_config.emit_obj {\n                 let ext = format!(\"{}.o\", i);\n-                remove(sess, &crate_output.with_extension(&ext[]));\n+                remove(sess, &crate_output.with_extension(&ext[..]));\n             }\n \n             if modules_config.emit_bc && !keep_numbered_bitcode {\n                 let ext = format!(\"{}.bc\", i);\n-                remove(sess, &crate_output.with_extension(&ext[]));\n+                remove(sess, &crate_output.with_extension(&ext[..]));\n             }\n         }\n \n@@ -960,7 +960,7 @@ fn run_work_multithreaded(sess: &Session,\n \n pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(&pname[]);\n+    let mut cmd = Command::new(&pname[..]);\n \n     cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(config::OutputTypeObject))\n                            .arg(outputs.temp_path(config::OutputTypeAssembly));\n@@ -975,7 +975,7 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n                 sess.note(&format!(\"{:?}\", &cmd)[]);\n                 let mut note = prog.error.clone();\n                 note.push_all(&prog.output[]);\n-                sess.note(str::from_utf8(&note[]).unwrap());\n+                sess.note(str::from_utf8(&note[..]).unwrap());\n                 sess.abort_if_errors();\n             }\n         },"}, {"sha": "8d2a2d51ee42366b6f78d8262abf701d8966481a", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -155,7 +155,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             };\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     &qualname[],\n+                                     &qualname[..],\n                                      self.cur_scope);\n         }\n     }\n@@ -178,7 +178,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             };\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     &qualname[],\n+                                     &qualname[..],\n                                      self.cur_scope);\n         }\n     }\n@@ -197,7 +197,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let (ref span, ref qualname) = sub_paths[len-2];\n         self.fmt.sub_type_ref_str(path.span,\n                                   *span,\n-                                  &qualname[]);\n+                                  &qualname[..]);\n \n         // write the other sub-paths\n         if len <= 2 {\n@@ -207,7 +207,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     &qualname[],\n+                                     &qualname[..],\n                                      self.cur_scope);\n         }\n     }\n@@ -280,7 +280,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                     id,\n                                     qualname,\n                                     &path_to_string(p)[],\n-                                    &typ[]);\n+                                    &typ[..]);\n             }\n             self.collected_paths.clear();\n         }\n@@ -356,7 +356,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         };\n \n         let qualname = format!(\"{}::{}\", qualname, &get_ident(method.pe_ident()));\n-        let qualname = &qualname[];\n+        let qualname = &qualname[..];\n \n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n@@ -436,9 +436,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n                                                          field.node.id,\n-                                                         &name[],\n-                                                         &qualname[],\n-                                                         &typ[],\n+                                                         &name[..],\n+                                                         &qualname[..],\n+                                                         &typ[..],\n                                                          scope_id),\n                     None => self.sess.span_bug(field.span,\n                                                &format!(\"Could not find sub-span for field {}\",\n@@ -470,7 +470,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.fmt.typedef_str(full_span,\n                                  Some(*param_ss),\n                                  param.id,\n-                                 &name[],\n+                                 &name[..],\n                                  \"\");\n         }\n         self.visit_generics(generics);\n@@ -487,10 +487,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.fn_str(item.span,\n                         sub_span,\n                         item.id,\n-                        &qualname[],\n+                        &qualname[..],\n                         self.cur_scope);\n \n-        self.process_formals(&decl.inputs, &qualname[]);\n+        self.process_formals(&decl.inputs, &qualname[..]);\n \n         // walk arg and return types\n         for arg in &decl.inputs {\n@@ -504,7 +504,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // walk the body\n         self.nest(item.id, |v| v.visit_block(&*body));\n \n-        self.process_generic_params(ty_params, item.span, &qualname[], item.id);\n+        self.process_generic_params(ty_params, item.span, &qualname[..], item.id);\n     }\n \n     fn process_static(&mut self,\n@@ -526,8 +526,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             &get_ident(item.ident),\n-                            &qualname[],\n-                            &value[],\n+                            &qualname[..],\n+                            &value[..],\n                             &ty_to_string(&*typ)[],\n                             self.cur_scope);\n \n@@ -549,7 +549,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             &get_ident(item.ident),\n-                            &qualname[],\n+                            &qualname[..],\n                             \"\",\n                             &ty_to_string(&*typ)[],\n                             self.cur_scope);\n@@ -575,17 +575,17 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             ctor_id,\n-                            &qualname[],\n+                            &qualname[..],\n                             self.cur_scope,\n-                            &val[]);\n+                            &val[..]);\n \n         // fields\n         for field in &def.fields {\n-            self.process_struct_field_def(field, &qualname[], item.id);\n+            self.process_struct_field_def(field, &qualname[..], item.id);\n             self.visit_ty(&*field.node.ty);\n         }\n \n-        self.process_generic_params(ty_params, item.span, &qualname[], item.id);\n+        self.process_generic_params(ty_params, item.span, &qualname[..], item.id);\n     }\n \n     fn process_enum(&mut self,\n@@ -598,9 +598,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             Some(sub_span) => self.fmt.enum_str(item.span,\n                                                 Some(sub_span),\n                                                 item.id,\n-                                                &enum_name[],\n+                                                &enum_name[..],\n                                                 self.cur_scope,\n-                                                &val[]),\n+                                                &val[..]),\n             None => self.sess.span_bug(item.span,\n                                        &format!(\"Could not find subspan for enum {}\",\n                                                enum_name)[]),\n@@ -619,9 +619,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                self.span.span_for_first_ident(variant.span),\n                                                variant.node.id,\n                                                name,\n-                                               &qualname[],\n-                                               &enum_name[],\n-                                               &val[],\n+                                               &qualname[..],\n+                                               &enum_name[..],\n+                                               &val[..],\n                                                item.id);\n                     for arg in args {\n                         self.visit_ty(&*arg.ty);\n@@ -637,9 +637,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         self.span.span_for_first_ident(variant.span),\n                         variant.node.id,\n                         ctor_id,\n-                        &qualname[],\n-                        &enum_name[],\n-                        &val[],\n+                        &qualname[..],\n+                        &enum_name[..],\n+                        &val[..],\n                         item.id);\n \n                     for field in &struct_def.fields {\n@@ -650,7 +650,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             }\n         }\n \n-        self.process_generic_params(ty_params, item.span, &enum_name[], item.id);\n+        self.process_generic_params(ty_params, item.span, &enum_name[..], item.id);\n     }\n \n     fn process_impl(&mut self,\n@@ -724,9 +724,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.trait_str(item.span,\n                            sub_span,\n                            item.id,\n-                           &qualname[],\n+                           &qualname[..],\n                            self.cur_scope,\n-                           &val[]);\n+                           &val[..]);\n \n         // super-traits\n         for super_bound in &**trait_refs {\n@@ -758,7 +758,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n \n         // walk generics and methods\n-        self.process_generic_params(generics, item.span, &qualname[], item.id);\n+        self.process_generic_params(generics, item.span, &qualname[..], item.id);\n         for method in methods {\n             self.visit_trait_item(method)\n         }\n@@ -776,9 +776,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.mod_str(item.span,\n                          sub_span,\n                          item.id,\n-                         &qualname[],\n+                         &qualname[..],\n                          self.cur_scope,\n-                         &filename[]);\n+                         &filename[..]);\n \n         self.nest(item.id, |v| visit::walk_mod(v, m));\n     }\n@@ -990,7 +990,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                self.cur_scope);\n \n         // walk receiver and args\n-        visit::walk_exprs(self, &args[]);\n+        visit::walk_exprs(self, &args[..]);\n     }\n \n     fn process_pat(&mut self, p:&ast::Pat) {\n@@ -1164,7 +1164,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                           item.id,\n                                           cnum,\n                                           name,\n-                                          &location[],\n+                                          &location[..],\n                                           self.cur_scope);\n             }\n             ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n@@ -1196,8 +1196,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.fmt.typedef_str(item.span,\n                                      sub_span,\n                                      item.id,\n-                                     &qualname[],\n-                                     &value[]);\n+                                     &qualname[..],\n+                                     &value[..]);\n \n                 self.visit_ty(&**ty);\n                 self.process_generic_params(ty_params, item.span, &qualname, item.id);\n@@ -1260,7 +1260,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 };\n \n                 qualname.push_str(&get_ident(method_type.ident));\n-                let qualname = &qualname[];\n+                let qualname = &qualname[..];\n \n                 let sub_span = self.span.sub_span_after_keyword(method_type.span, keywords::Fn);\n                 self.fmt.method_decl_str(method_type.span,\n@@ -1401,7 +1401,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n                 let mut id = String::from_str(\"$\");\n                 id.push_str(&ex.id.to_string()[]);\n-                self.process_formals(&decl.inputs, &id[]);\n+                self.process_formals(&decl.inputs, &id[..]);\n \n                 // walk arg and return types\n                 for arg in &decl.inputs {\n@@ -1464,7 +1464,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                           Some(p.span),\n                                           id,\n                                           &path_to_string(p)[],\n-                                          &value[],\n+                                          &value[..],\n                                           \"\")\n                 }\n                 def::DefVariant(..) | def::DefTy(..) | def::DefStruct(..) => {\n@@ -1520,8 +1520,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                   sub_span,\n                                   id,\n                                   &path_to_string(p)[],\n-                                  &value[],\n-                                  &typ[]);\n+                                  &value[..],\n+                                  &typ[..]);\n         }\n         self.collected_paths.clear();\n \n@@ -1603,7 +1603,7 @@ pub fn process_crate(sess: &Session,\n         cur_scope: 0\n     };\n \n-    visitor.dump_crate_info(&cratename[], krate);\n+    visitor.dump_crate_info(&cratename[..], krate);\n \n     visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "08e36bb1d85bb3eefc504b5c81b7244c7fff5ba5", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -43,7 +43,7 @@ impl Recorder {\n         assert!(self.dump_spans);\n         let result = format!(\"span,kind,{},{},text,\\\"{}\\\"\\n\",\n                              kind, su.extent_str(span), escape(su.snippet(span)));\n-        self.record(&result[]);\n+        self.record(&result[..]);\n     }\n }\n \n@@ -170,14 +170,14 @@ impl<'a> FmtStrs<'a> {\n             if s.len() > 1020 {\n                 &s[..1020]\n             } else {\n-                &s[]\n+                &s[..]\n             }\n         });\n \n         let pairs = fields.iter().zip(values);\n         let strs = pairs.map(|(f, v)| format!(\",{},\\\"{}\\\"\", f, escape(String::from_str(v))));\n         Some(strs.fold(String::new(), |mut s, ss| {\n-            s.push_str(&ss[]);\n+            s.push_str(&ss[..]);\n             s\n         }))\n     }\n@@ -205,9 +205,9 @@ impl<'a> FmtStrs<'a> {\n         };\n \n         let mut result = String::from_str(label);\n-        result.push_str(&values_str[]);\n+        result.push_str(&values_str[..]);\n         result.push_str(\"\\n\");\n-        self.recorder.record(&result[]);\n+        self.recorder.record(&result[..]);\n     }\n \n     pub fn record_with_span(&mut self,\n@@ -238,7 +238,7 @@ impl<'a> FmtStrs<'a> {\n             None => return,\n         };\n         let result = format!(\"{},{}{}\\n\", label, self.span.extent_str(sub_span), values_str);\n-        self.recorder.record(&result[]);\n+        self.recorder.record(&result[..]);\n     }\n \n     pub fn check_and_record(&mut self,"}, {"sha": "2826afb71a2c23cfcc945a66c908b6c806a7a3c3", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -566,7 +566,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n         param_env: param_env,\n     };\n     enter_match(bcx, dm, m, col, val, |pats|\n-        check_match::specialize(&mcx, &pats[], &ctor, col, variant_size)\n+        check_match::specialize(&mcx, &pats[..], &ctor, col, variant_size)\n     )\n }\n \n@@ -987,7 +987,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if has_nested_bindings(m, col) {\n                 let expanded = expand_nested_bindings(bcx, m, col, val);\n                 compile_submatch_continue(bcx,\n-                                          &expanded[],\n+                                          &expanded[..],\n                                           vals,\n                                           chk,\n                                           col,\n@@ -1233,10 +1233,10 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n         let mut opt_vals = unpacked;\n-        opt_vals.push_all(&vals_left[]);\n+        opt_vals.push_all(&vals_left[..]);\n         compile_submatch(opt_cx,\n-                         &opt_ms[],\n-                         &opt_vals[],\n+                         &opt_ms[..],\n+                         &opt_vals[..],\n                          branch_chk.as_ref().unwrap_or(chk),\n                          has_genuine_default);\n     }\n@@ -1255,8 +1255,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n             _ => {\n                 compile_submatch(else_cx,\n-                                 &defaults[],\n-                                 &vals_left[],\n+                                 &defaults[..],\n+                                 &vals_left[..],\n                                  chk,\n                                  has_genuine_default);\n             }\n@@ -1468,7 +1468,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         && arm.pats.last().unwrap().node == ast::PatWild(ast::PatWildSingle)\n     });\n \n-    compile_submatch(bcx, &matches[], &[discr_datum.val], &chk, has_default);\n+    compile_submatch(bcx, &matches[..], &[discr_datum.val], &chk, has_default);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in &arm_datas {\n@@ -1482,7 +1482,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         arm_cxs.push(bcx);\n     }\n \n-    bcx = scope_cx.fcx.join_blocks(match_id, &arm_cxs[]);\n+    bcx = scope_cx.fcx.join_blocks(match_id, &arm_cxs[..]);\n     return bcx;\n }\n "}, {"sha": "eaf6eaa2f089d1273bec3b9f574fa24be70d68dc", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -155,7 +155,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      t: Ty<'tcx>) -> Repr<'tcx> {\n     match t.sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, &elems[], false, t), false)\n+            Univariant(mk_struct(cx, &elems[..], false, t), false)\n         }\n         ty::ty_struct(def_id, substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n@@ -167,13 +167,13 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n             if dtor { ftys.push(cx.tcx().types.bool); }\n \n-            Univariant(mk_struct(cx, &ftys[], packed, t), dtor)\n+            Univariant(mk_struct(cx, &ftys[..], packed, t), dtor)\n         }\n         ty::ty_closure(def_id, _, substs) => {\n             let typer = NormalizingClosureTyper::new(cx.tcx());\n             let upvars = typer.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            Univariant(mk_struct(cx, &upvar_types[], false, t), false)\n+            Univariant(mk_struct(cx, &upvar_types[..], false, t), false)\n         }\n         ty::ty_enum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n@@ -187,7 +187,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n                 let ftys = if dtor { vec!(cx.tcx().types.bool) } else { vec!() };\n-                return Univariant(mk_struct(cx, &ftys[], false, t),\n+                return Univariant(mk_struct(cx, &ftys[..], false, t),\n                                   dtor);\n             }\n \n@@ -219,7 +219,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 assert_eq!(hint, attr::ReprAny);\n                 let mut ftys = cases[0].tys.clone();\n                 if dtor { ftys.push(cx.tcx().types.bool); }\n-                return Univariant(mk_struct(cx, &ftys[], false, t),\n+                return Univariant(mk_struct(cx, &ftys[..], false, t),\n                                   dtor);\n             }\n \n@@ -320,10 +320,10 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n                 ftys.push_all(&c.tys[]);\n                 if dtor { ftys.push(cx.tcx().types.bool); }\n-                mk_struct(cx, &ftys[], false, t)\n+                mk_struct(cx, &ftys[..], false, t)\n             }).collect();\n \n-            ensure_enum_fits_in_address_space(cx, &fields[], t);\n+            ensure_enum_fits_in_address_space(cx, &fields[..], t);\n \n             General(ity, fields, dtor)\n         }\n@@ -453,9 +453,9 @@ fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     };\n \n-    ensure_struct_fits_in_address_space(cx, &lltys[], packed, scapegoat);\n+    ensure_struct_fits_in_address_space(cx, &lltys[..], packed, scapegoat);\n \n-    let llty_rec = Type::struct_(cx, &lltys[], packed);\n+    let llty_rec = Type::struct_(cx, &lltys[..], packed);\n     Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec),\n         align: machine::llalign_of_min(cx, llty_rec),\n@@ -659,7 +659,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // of the size.\n             //\n             // FIXME #10604: this breaks when vector types are present.\n-            let (size, align) = union_size_and_align(&sts[]);\n+            let (size, align) = union_size_and_align(&sts[..]);\n             let align_s = align as u64;\n             assert_eq!(size % align_s, 0);\n             let align_units = size / align_s - 1;\n@@ -682,10 +682,10 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                           Type::array(&discr_ty, align_s / discr_size - 1),\n                           fill_ty];\n             match name {\n-                None => Type::struct_(cx, &fields[], false),\n+                None => Type::struct_(cx, &fields[..], false),\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(&fields[], false);\n+                    llty.set_struct_body(&fields[..], false);\n                     llty\n                 }\n             }\n@@ -763,7 +763,7 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n \n fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, discrfield: &DiscrField,\n                                     scrutinee: ValueRef) -> ValueRef {\n-    let llptrptr = GEPi(bcx, scrutinee, &discrfield[]);\n+    let llptrptr = GEPi(bcx, scrutinee, &discrfield[..]);\n     let llptr = Load(bcx, llptrptr);\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)), DebugLoc::None)\n@@ -851,7 +851,7 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         }\n         StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n             if discr != nndiscr {\n-                let llptrptr = GEPi(bcx, val, &discrfield[]);\n+                let llptrptr = GEPi(bcx, val, &discrfield[..]);\n                 let llptrty = val_ty(llptrptr).element_type();\n                 Store(bcx, C_null(llptrty), llptrptr)\n             }\n@@ -933,7 +933,7 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n     let val = if needs_cast {\n         let ccx = bcx.ccx();\n         let fields = st.fields.iter().map(|&ty| type_of::type_of(ccx, ty)).collect::<Vec<_>>();\n-        let real_ty = Type::struct_(ccx, &fields[], st.packed);\n+        let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n         val\n@@ -972,7 +972,7 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n                 let fields = case.fields.iter().map(|&ty|\n                     type_of::type_of(bcx.ccx(), ty)).collect::<Vec<_>>();\n-                let real_ty = Type::struct_(ccx, &fields[], case.packed);\n+                let real_ty = Type::struct_(ccx, &fields[..], case.packed);\n                 let variant_value = PointerCast(variant_cx, value, real_ty.ptr_to());\n \n                 variant_cx = f(variant_cx, case, variant_value);\n@@ -1045,18 +1045,18 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n         }\n         General(ity, ref cases, _) => {\n             let case = &cases[discr as uint];\n-            let (max_sz, _) = union_size_and_align(&cases[]);\n+            let (max_sz, _) = union_size_and_align(&cases[..]);\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n             let mut f = vec![lldiscr];\n             f.push_all(vals);\n-            let mut contents = build_const_struct(ccx, case, &f[]);\n+            let mut contents = build_const_struct(ccx, case, &f[..]);\n             contents.push_all(&[padding(ccx, max_sz - case.size)]);\n-            C_struct(ccx, &contents[], false)\n+            C_struct(ccx, &contents[..], false)\n         }\n         Univariant(ref st, _dro) => {\n             assert!(discr == 0);\n             let contents = build_const_struct(ccx, st, vals);\n-            C_struct(ccx, &contents[], st.packed)\n+            C_struct(ccx, &contents[..], st.packed)\n         }\n         RawNullablePointer { nndiscr, nnty, .. } => {\n             if discr == nndiscr {\n@@ -1080,7 +1080,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n                 }).collect::<Vec<ValueRef>>();\n                 C_struct(ccx, &build_const_struct(ccx,\n                                                  nonnull,\n-                                                 &vals[])[],\n+                                                 &vals[..])[],\n                          false)\n             }\n         }"}, {"sha": "a3bd0cf6b1a623bac1cf719408aa45f7d1696859", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -71,7 +71,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                     callee::DontAutorefArg)\n         })\n     }).collect::<Vec<_>>();\n-    inputs.push_all(&ext_inputs[]);\n+    inputs.push_all(&ext_inputs[..]);\n \n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n@@ -91,18 +91,18 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         if !clobbers.is_empty() {\n             clobbers.push(',');\n         }\n-        clobbers.push_str(&more_clobbers[]);\n+        clobbers.push_str(&more_clobbers[..]);\n     }\n \n     // Add the clobbers to our constraints list\n     if clobbers.len() != 0 && constraints.len() != 0 {\n         constraints.push(',');\n-        constraints.push_str(&clobbers[]);\n+        constraints.push_str(&clobbers[..]);\n     } else {\n-        constraints.push_str(&clobbers[]);\n+        constraints.push_str(&clobbers[..]);\n     }\n \n-    debug!(\"Asm Constraints: {}\", &constraints[]);\n+    debug!(\"Asm Constraints: {}\", &constraints[..]);\n \n     let num_outputs = outputs.len();\n \n@@ -112,7 +112,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     } else if num_outputs == 1 {\n         output_types[0]\n     } else {\n-        Type::struct_(bcx.ccx(), &output_types[], false)\n+        Type::struct_(bcx.ccx(), &output_types[..], false)\n     };\n \n     let dialect = match ia.dialect {"}, {"sha": "3091c852f5587baa80a11f567d4cc31104f72f43", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -247,7 +247,7 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n     let f = decl_rust_fn(ccx, fn_ty, name);\n \n     let attrs = csearch::get_item_attrs(&ccx.sess().cstore, did);\n-    set_llvm_fn_attrs(ccx, &attrs[], f);\n+    set_llvm_fn_attrs(ccx, &attrs[..], f);\n \n     ccx.externs().borrow_mut().insert(name.to_string(), f);\n     f\n@@ -523,7 +523,7 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      ty::mk_nil(ccx.tcx()));\n         get_extern_fn(ccx,\n                       &mut *ccx.externs().borrow_mut(),\n-                      &name[],\n+                      &name[..],\n                       llvm::CCallConv,\n                       llty,\n                       dtor_ty)\n@@ -898,14 +898,14 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(_, ref fn_ty) => {\n             match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n                 Rust | RustCall => {\n-                    get_extern_rust_fn(ccx, t, &name[], did)\n+                    get_extern_rust_fn(ccx, t, &name[..], did)\n                 }\n                 RustIntrinsic => {\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n                 _ => {\n                     foreign::register_foreign_item_fn(ccx, fn_ty.abi, t,\n-                                                      &name[])\n+                                                      &name[..])\n                 }\n             }\n         }\n@@ -947,7 +947,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         let llresult = Invoke(bcx,\n                               llfn,\n-                              &llargs[],\n+                              &llargs[..],\n                               normal_bcx.llbb,\n                               landing_pad,\n                               Some(attributes),\n@@ -961,7 +961,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         let llresult = Call(bcx,\n                             llfn,\n-                            &llargs[],\n+                            &llargs[..],\n                             Some(attributes),\n                             debug_loc);\n         return (llresult, bcx);\n@@ -1633,7 +1633,7 @@ fn copy_closure_args_to_allocas<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                          \"argtuple\",\n                                                          arg_scope_id));\n     let untupled_arg_types = match monomorphized_arg_types[0].sty {\n-        ty::ty_tup(ref types) => &types[],\n+        ty::ty_tup(ref types) => &types[..],\n         _ => {\n             bcx.tcx().sess.span_bug(args[0].pat.span,\n                                     \"first arg to `rust-call` ABI function \\\n@@ -1821,12 +1821,12 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let arg_datums = if abi != RustCall {\n         create_datums_for_fn_args(&fcx,\n-                                  &monomorphized_arg_types[])\n+                                  &monomorphized_arg_types[..])\n     } else {\n         create_datums_for_fn_args_under_call_abi(\n             bcx,\n             arg_scope,\n-            &monomorphized_arg_types[])\n+            &monomorphized_arg_types[..])\n     };\n \n     bcx = match closure_env {\n@@ -1842,7 +1842,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 arg_scope,\n                 &decl.inputs[],\n                 arg_datums,\n-                &monomorphized_arg_types[])\n+                &monomorphized_arg_types[..])\n         }\n     };\n \n@@ -1987,7 +1987,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 bcx = expr::trans_adt(bcx,\n                                       result_ty,\n                                       disr,\n-                                      &fields[],\n+                                      &fields[..],\n                                       None,\n                                       expr::SaveIn(llresult),\n                                       debug_loc);\n@@ -2057,7 +2057,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         ty::erase_late_bound_regions(\n             ccx.tcx(), &ty::ty_fn_args(ctor_ty));\n \n-    let arg_datums = create_datums_for_fn_args(&fcx, &arg_tys[]);\n+    let arg_datums = create_datums_for_fn_args(&fcx, &arg_tys[..]);\n \n     if !type_is_zero_size(fcx.ccx, result_ty.unwrap()) {\n         let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n@@ -2302,7 +2302,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n       ast::ItemImpl(_, _, ref generics, _, _, ref impl_items) => {\n         meth::trans_impl(ccx,\n                          item.ident,\n-                         &impl_items[],\n+                         &impl_items[..],\n                          generics,\n                          item.id);\n       }\n@@ -2417,7 +2417,7 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => panic!(\"expected bare rust fn\")\n     };\n \n-    let llfn = decl_rust_fn(ccx, node_type, &sym[]);\n+    let llfn = decl_rust_fn(ccx, node_type, &sym[..]);\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -2462,7 +2462,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n \n             match fn_sig.inputs[1].sty {\n                 ty::ty_tup(ref t_in) => {\n-                    inputs.push_all(&t_in[]);\n+                    inputs.push_all(&t_in[..]);\n                     inputs\n                 }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n@@ -2598,7 +2598,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n     let llfn = decl_fn(ccx,\n-                       &sym[],\n+                       &sym[..],\n                        cc,\n                        llfty,\n                        ty::FnConverging(ty::mk_nil(ccx.tcx())));\n@@ -2654,7 +2654,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n-                    Err(s) => { ccx.sess().fatal(&s[]); }\n+                    Err(s) => { ccx.sess().fatal(&s[..]); }\n                 };\n                 let start_fn = if start_def_id.krate == ast::LOCAL_CRATE {\n                     get_item_val(ccx, start_def_id.node)\n@@ -2770,7 +2770,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         } else {\n                             llvm::LLVMTypeOf(v)\n                         };\n-                        if contains_null(&sym[]) {\n+                        if contains_null(&sym[..]) {\n                             ccx.sess().fatal(\n                                 &format!(\"Illegal null byte in export_name \\\n                                          value: `{}`\", sym)[]);\n@@ -2975,7 +2975,7 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n         Some(compressed) => compressed,\n         None => cx.sess().fatal(\"failed to compress metadata\"),\n     });\n-    let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed[]);\n+    let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed[..]);\n     let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\",\n                        cx.link_meta().crate_name,"}, {"sha": "8199e6189c93b495c926ac1d9715ee29b1ddb90f", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -567,7 +567,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         } else {\n             let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");\n-            self.inbounds_gep(base, &v[])\n+            self.inbounds_gep(base, &v[..])\n         }\n     }\n \n@@ -775,8 +775,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let s = format!(\"{} ({})\",\n                             text,\n                             self.ccx.sess().codemap().span_to_string(sp));\n-            debug!(\"{}\", &s[]);\n-            self.add_comment(&s[]);\n+            debug!(\"{}\", &s[..]);\n+            self.add_comment(&s[..]);\n         }\n     }\n \n@@ -813,7 +813,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {}\", self.ccx.tn().type_to_string(output));\n-        let fty = Type::func(&argtys[], &output);\n+        let fty = Type::func(&argtys[..], &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n                 fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);"}, {"sha": "3d3e35cd776f0fd311affbe03d9188f46312d44c", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -323,7 +323,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn =\n         decl_internal_rust_fn(ccx,\n                               tuple_fn_ty,\n-                              &function_name[]);\n+                              &function_name[..]);\n \n     //\n     let empty_substs = tcx.mk_substs(Substs::trans_empty());\n@@ -359,7 +359,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                            DebugLoc::None,\n                            bare_fn_ty,\n                            |bcx, _| Callee { bcx: bcx, data: Fn(llfnpointer) },\n-                           ArgVals(&llargs[]),\n+                           ArgVals(&llargs[..]),\n                            dest).bcx;\n \n     finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n@@ -792,7 +792,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         // Invoke the actual rust fn and update bcx/llresult.\n         let (llret, b) = base::invoke(bcx,\n                                       llfn,\n-                                      &llargs[],\n+                                      &llargs[..],\n                                       callee_ty,\n                                       debug_loc);\n         bcx = b;\n@@ -833,7 +833,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                          callee_ty,\n                                          llfn,\n                                          opt_llretslot.unwrap(),\n-                                         &llargs[],\n+                                         &llargs[..],\n                                          arg_tys,\n                                          debug_loc);\n     }"}, {"sha": "85e53618f6da9c7ed664b3a0e1643664d59eaab8", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -764,7 +764,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 let name = scope.block_name(\"clean\");\n                 debug!(\"generating cleanups for {}\", name);\n                 let bcx_in = self.new_block(label.is_unwind(),\n-                                            &name[],\n+                                            &name[..],\n                                             None);\n                 let mut bcx_out = bcx_in;\n                 for cleanup in scope.cleanups.iter().rev() {\n@@ -811,7 +811,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 Some(llbb) => { return llbb; }\n                 None => {\n                     let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.new_block(true, &name[], None);\n+                    pad_bcx = self.new_block(true, &name[..], None);\n                     last_scope.cached_landing_pad = Some(pad_bcx.llbb);\n                 }\n             }"}, {"sha": "1d4bbd79d71057baecdc624201e5d7a367355068", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -158,7 +158,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n \n-    let llfn = decl_internal_rust_fn(ccx, function_type, &symbol[]);\n+    let llfn = decl_internal_rust_fn(ccx, function_type, &symbol[..]);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -221,7 +221,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n                   &[],\n                   sig.output,\n                   function_type.abi,\n-                  ClosureEnv::Closure(&freevars[]));\n+                  ClosureEnv::Closure(&freevars[..]));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n     // to have a zero-size closure (in which case dest will be `Ignore`) and"}, {"sha": "a9cda94bebac52513d98848c30cf01ca6a7262d5", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -1162,8 +1162,8 @@ pub fn langcall(bcx: Block,\n         Err(s) => {\n             let msg = format!(\"{} {}\", msg, s);\n             match span {\n-                Some(span) => bcx.tcx().sess.span_fatal(span, &msg[]),\n-                None => bcx.tcx().sess.fatal(&msg[]),\n+                Some(span) => bcx.tcx().sess.span_fatal(span, &msg[..]),\n+                None => bcx.tcx().sess.fatal(&msg[..]),\n             }\n         }\n     }"}, {"sha": "7705b53ee38c69ad7a4c74254666fc3901776dbe", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -75,7 +75,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         ast::LitBool(b) => C_bool(cx, b),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n         ast::LitBinary(ref data) => {\n-            let g = addr_of(cx, C_bytes(cx, &data[]), \"binary\", e.id);\n+            let g = addr_of(cx, C_bytes(cx, &data[..]), \"binary\", e.id);\n             let base = ptrcast(g, Type::i8p(cx));\n             let prev_const = cx.const_unsized().borrow_mut()\n                                .insert(base, g);\n@@ -611,8 +611,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           }\n           ast::ExprTup(ref es) => {\n               let repr = adt::represent_type(cx, ety);\n-              let vals = map_list(&es[]);\n-              adt::trans_const(cx, &*repr, 0, &vals[])\n+              let vals = map_list(&es[..]);\n+              adt::trans_const(cx, &*repr, 0, &vals[..])\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n               let repr = adt::represent_type(cx, ety);\n@@ -642,9 +642,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       }\n                   }).collect::<Vec<_>>();\n                   if ty::type_is_simd(cx.tcx(), ety) {\n-                      C_vector(&cs[])\n+                      C_vector(&cs[..])\n                   } else {\n-                      adt::trans_const(cx, &*repr, discr, &cs[])\n+                      adt::trans_const(cx, &*repr, discr, &cs[..])\n                   }\n               })\n           }\n@@ -655,9 +655,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                               .collect::<Vec<_>>();\n             // If the vector contains enums, an LLVM array won't work.\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-                C_struct(cx, &vs[], false)\n+                C_struct(cx, &vs[..], false)\n             } else {\n-                C_array(llunitty, &vs[])\n+                C_array(llunitty, &vs[..])\n             }\n           }\n           ast::ExprRepeat(ref elem, ref count) => {\n@@ -671,9 +671,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let unit_val = const_expr(cx, &**elem, param_substs).0;\n             let vs: Vec<_> = repeat(unit_val).take(n).collect();\n             if val_ty(unit_val) != llunitty {\n-                C_struct(cx, &vs[], false)\n+                C_struct(cx, &vs[..], false)\n             } else {\n-                C_array(llunitty, &vs[])\n+                C_array(llunitty, &vs[..])\n             }\n           }\n           ast::ExprPath(_) | ast::ExprQPath(_) => {\n@@ -715,14 +715,14 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           }\n           ast::ExprCall(ref callee, ref args) => {\n               let opt_def = cx.tcx().def_map.borrow().get(&callee.id).cloned();\n-              let arg_vals = map_list(&args[]);\n+              let arg_vals = map_list(&args[..]);\n               match opt_def {\n                   Some(def::DefStruct(_)) => {\n                       if ty::type_is_simd(cx.tcx(), ety) {\n-                          C_vector(&arg_vals[])\n+                          C_vector(&arg_vals[..])\n                       } else {\n                           let repr = adt::represent_type(cx, ety);\n-                          adt::trans_const(cx, &*repr, 0, &arg_vals[])\n+                          adt::trans_const(cx, &*repr, 0, &arg_vals[..])\n                       }\n                   }\n                   Some(def::DefVariant(enum_did, variant_did, _)) => {\n@@ -733,7 +733,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       adt::trans_const(cx,\n                                        &*repr,\n                                        vinfo.disr_val,\n-                                       &arg_vals[])\n+                                       &arg_vals[..])\n                   }\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }"}, {"sha": "eb07bdb7ba11bb6a860a2c71a1b462f440d196e5", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -288,7 +288,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             // such as a function name in the module.\n             // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n             let llmod_id = format!(\"{}.{}.rs\", crate_name, i);\n-            let local_ccx = LocalCrateContext::new(&shared_ccx, &llmod_id[]);\n+            let local_ccx = LocalCrateContext::new(&shared_ccx, &llmod_id[..]);\n             shared_ccx.local_ccxs.push(local_ccx);\n         }\n "}, {"sha": "26e12a1af403dac45981d8bd2e4751c9f60fec69", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -177,7 +177,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     let name = format!(\"then-block-{}-\", thn.id);\n-    let then_bcx_in = bcx.fcx.new_id_block(&name[], thn.id);\n+    let then_bcx_in = bcx.fcx.new_id_block(&name[..], thn.id);\n     let then_bcx_out = trans_block(then_bcx_in, &*thn, dest);\n     trans::debuginfo::clear_source_location(bcx.fcx);\n \n@@ -378,7 +378,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n-                                      &args[],\n+                                      &args[..],\n                                       Some(expr::Ignore),\n                                       call_info.debug_loc()).bcx;\n     Unreachable(bcx);\n@@ -407,7 +407,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n-                                      &args[],\n+                                      &args[..],\n                                       Some(expr::Ignore),\n                                       call_info.debug_loc()).bcx;\n     Unreachable(bcx);"}, {"sha": "fc0129239aac7e9b316749ef013d818c528b7602", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -299,7 +299,7 @@ impl<'tcx> TypeMap<'tcx> {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n             let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n             cx.sess().bug(&format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n-                                  &unique_type_id_str[])[]);\n+                                  &unique_type_id_str[..])[]);\n         }\n     }\n \n@@ -380,14 +380,14 @@ impl<'tcx> TypeMap<'tcx> {\n                         self.get_unique_type_id_of_type(cx, component_type);\n                     let component_type_id =\n                         self.get_unique_type_id_as_string(component_type_id);\n-                    unique_type_id.push_str(&component_type_id[]);\n+                    unique_type_id.push_str(&component_type_id[..]);\n                 }\n             },\n             ty::ty_uniq(inner_type) => {\n                 unique_type_id.push('~');\n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[]);\n+                unique_type_id.push_str(&inner_type_id[..]);\n             },\n             ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n                 unique_type_id.push('*');\n@@ -397,7 +397,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[]);\n+                unique_type_id.push_str(&inner_type_id[..]);\n             },\n             ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n                 unique_type_id.push('&');\n@@ -407,7 +407,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[]);\n+                unique_type_id.push_str(&inner_type_id[..]);\n             },\n             ty::ty_vec(inner_type, optional_length) => {\n                 match optional_length {\n@@ -421,7 +421,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[]);\n+                unique_type_id.push_str(&inner_type_id[..]);\n             },\n             ty::ty_trait(ref trait_data) => {\n                 unique_type_id.push_str(\"trait \");\n@@ -452,7 +452,7 @@ impl<'tcx> TypeMap<'tcx> {\n                         self.get_unique_type_id_of_type(cx, parameter_type);\n                     let parameter_type_id =\n                         self.get_unique_type_id_as_string(parameter_type_id);\n-                    unique_type_id.push_str(&parameter_type_id[]);\n+                    unique_type_id.push_str(&parameter_type_id[..]);\n                     unique_type_id.push(',');\n                 }\n \n@@ -465,7 +465,7 @@ impl<'tcx> TypeMap<'tcx> {\n                     ty::FnConverging(ret_ty) => {\n                         let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                         let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                        unique_type_id.push_str(&return_type_id[]);\n+                        unique_type_id.push_str(&return_type_id[..]);\n                     }\n                     ty::FnDiverging => {\n                         unique_type_id.push_str(\"!\");\n@@ -538,7 +538,7 @@ impl<'tcx> TypeMap<'tcx> {\n                         type_map.get_unique_type_id_of_type(cx, type_parameter);\n                     let param_type_id =\n                         type_map.get_unique_type_id_as_string(param_type_id);\n-                    output.push_str(&param_type_id[]);\n+                    output.push_str(&param_type_id[..]);\n                     output.push(',');\n                 }\n \n@@ -568,7 +568,7 @@ impl<'tcx> TypeMap<'tcx> {\n                 self.get_unique_type_id_of_type(cx, parameter_type);\n             let parameter_type_id =\n                 self.get_unique_type_id_as_string(parameter_type_id);\n-            unique_type_id.push_str(&parameter_type_id[]);\n+            unique_type_id.push_str(&parameter_type_id[..]);\n             unique_type_id.push(',');\n         }\n \n@@ -582,7 +582,7 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::FnConverging(ret_ty) => {\n                 let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                 let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                unique_type_id.push_str(&return_type_id[]);\n+                unique_type_id.push_str(&return_type_id[..]);\n             }\n             ty::FnDiverging => {\n                 unique_type_id.push_str(\"!\");\n@@ -806,7 +806,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n     let var_name = token::get_ident(ident).to_string();\n     let linkage_name =\n-        namespace_node.mangled_name_of_contained_item(&var_name[]);\n+        namespace_node.mangled_name_of_contained_item(&var_name[..]);\n     let var_scope = namespace_node.scope;\n \n     let var_name = CString::new(var_name).unwrap();\n@@ -1287,7 +1287,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match expr.node {\n                 ast::ExprClosure(_, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n-                    let name = token::str_to_ident(&name[]);\n+                    let name = token::str_to_ident(&name[..]);\n                     (name, &**fn_decl,\n                         // This is not quite right. It should actually inherit\n                         // the generics of the enclosing function.\n@@ -1366,7 +1366,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (linkage_name, containing_scope) = if has_path {\n         let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id));\n         let linkage_name = namespace_node.mangled_name_of_contained_item(\n-            &function_name[]);\n+            &function_name[..]);\n         let containing_scope = namespace_node.scope;\n         (linkage_name, containing_scope)\n     } else {\n@@ -1451,7 +1451,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n         }\n \n-        return create_DIArray(DIB(cx), &signature[]);\n+        return create_DIArray(DIB(cx), &signature[..]);\n     }\n \n     fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -1486,7 +1486,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 actual_self_type,\n                 true);\n \n-            name_to_append_suffix_to.push_str(&actual_self_type_name[]);\n+            name_to_append_suffix_to.push_str(&actual_self_type_name[..]);\n \n             if generics.is_type_parameterized() {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1525,7 +1525,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,\n                                                                true);\n-            name_to_append_suffix_to.push_str(&actual_type_name[]);\n+            name_to_append_suffix_to.push_str(&actual_type_name[..]);\n \n             if index != generics.ty_params.len() - 1 {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1552,7 +1552,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         name_to_append_suffix_to.push('>');\n \n-        return create_DIArray(DIB(cx), &template_params[]);\n+        return create_DIArray(DIB(cx), &template_params[..]);\n     }\n }\n \n@@ -1646,7 +1646,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let cx: &CrateContext = bcx.ccx();\n \n     let filename = span_start(cx, span).file.name.clone();\n-    let file_metadata = file_metadata(cx, &filename[]);\n+    let file_metadata = file_metadata(cx, &filename[..]);\n \n     let name = token::get_ident(variable_ident);\n     let loc = span_start(cx, span);\n@@ -1959,7 +1959,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                 set_members_of_composite_type(cx,\n                                               metadata_stub,\n                                               llvm_type,\n-                                              &member_descriptions[]);\n+                                              &member_descriptions[..]);\n                 return MetadataCreationResult::new(metadata_stub, true);\n             }\n         }\n@@ -2031,7 +2031,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n-                                                  &struct_name[],\n+                                                  &struct_name[..],\n                                                   unique_type_id,\n                                                   containing_scope);\n \n@@ -2098,7 +2098,7 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         unique_type_id,\n         create_struct_stub(cx,\n                            tuple_llvm_type,\n-                           &tuple_name[],\n+                           &tuple_name[..],\n                            unique_type_id,\n                            UNKNOWN_SCOPE_METADATA),\n         tuple_llvm_type,\n@@ -2158,7 +2158,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         set_members_of_composite_type(cx,\n                                                       variant_type_metadata,\n                                                       variant_llvm_type,\n-                                                      &member_descriptions[]);\n+                                                      &member_descriptions[..]);\n                         MemberDescription {\n                             name: \"\".to_string(),\n                             llvm_type: variant_llvm_type,\n@@ -2191,7 +2191,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     set_members_of_composite_type(cx,\n                                                   variant_type_metadata,\n                                                   variant_llvm_type,\n-                                                  &member_descriptions[]);\n+                                                  &member_descriptions[..]);\n                     vec![\n                         MemberDescription {\n                             name: \"\".to_string(),\n@@ -2291,7 +2291,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 set_members_of_composite_type(cx,\n                                               variant_type_metadata,\n                                               variant_llvm_type,\n-                                              &variant_member_descriptions[]);\n+                                              &variant_member_descriptions[..]);\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n@@ -2663,7 +2663,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         .collect();\n \n     unsafe {\n-        let type_array = create_DIArray(DIB(cx), &member_metadata[]);\n+        let type_array = create_DIArray(DIB(cx), &member_metadata[..]);\n         llvm::LLVMDICompositeTypeSetTypeArray(DIB(cx), composite_type_metadata, type_array);\n     }\n }\n@@ -2764,7 +2764,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let member_llvm_types = slice_llvm_type.field_types();\n     assert!(slice_layout_is_correct(cx,\n-                                    &member_llvm_types[],\n+                                    &member_llvm_types[..],\n                                     element_type));\n     let member_descriptions = [\n         MemberDescription {\n@@ -2790,7 +2790,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let metadata = composite_type_metadata(cx,\n                                            slice_llvm_type,\n-                                           &slice_type_name[],\n+                                           &slice_type_name[..],\n                                            unique_type_id,\n                                            &member_descriptions,\n                                            UNKNOWN_SCOPE_METADATA,\n@@ -2839,7 +2839,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             llvm::LLVMDIBuilderCreateSubroutineType(\n                 DIB(cx),\n                 UNKNOWN_FILE_METADATA,\n-                create_DIArray(DIB(cx), &signature_metadata[]))\n+                create_DIArray(DIB(cx), &signature_metadata[..]))\n         },\n         false);\n }\n@@ -2865,7 +2865,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(&format!(\"debuginfo: Unexpected trait-object type in \\\n                                    trait_pointer_metadata(): {}\",\n-                                   &pp_type_name[])[]);\n+                                   &pp_type_name[..])[]);\n         }\n     };\n \n@@ -2879,7 +2879,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     composite_type_metadata(cx,\n                             trait_llvm_type,\n-                            &trait_type_name[],\n+                            &trait_type_name[..],\n                             unique_type_id,\n                             &[],\n                             containing_scope,\n@@ -2999,7 +2999,7 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_tup(ref elements) => {\n             prepare_tuple_metadata(cx,\n                                    t,\n-                                   &elements[],\n+                                   &elements[..],\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n@@ -3023,9 +3023,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                  type id '{}' to already be in \\\n                                                  the debuginfo::TypeMap but it \\\n                                                  was not. (Ty = {})\",\n-                                                &unique_type_id_str[],\n+                                                &unique_type_id_str[..],\n                                                 ppaux::ty_to_string(cx.tcx(), t));\n-                    cx.sess().span_bug(usage_site_span, &error_message[]);\n+                    cx.sess().span_bug(usage_site_span, &error_message[..]);\n                 }\n             };\n \n@@ -3038,9 +3038,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                      UniqueTypeId maps in \\\n                                                      debuginfo::TypeMap. \\\n                                                      UniqueTypeId={}, Ty={}\",\n-                            &unique_type_id_str[],\n+                            &unique_type_id_str[..],\n                             ppaux::ty_to_string(cx.tcx(), t));\n-                        cx.sess().span_bug(usage_site_span, &error_message[]);\n+                        cx.sess().span_bug(usage_site_span, &error_message[..]);\n                     }\n                 }\n                 None => {\n@@ -3129,7 +3129,7 @@ fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n     attributes.iter().any(|attr| {\n         let meta_item: &ast::MetaItem = &*attr.node.value;\n         match meta_item.node {\n-            ast::MetaWord(ref value) => &value[] == \"no_debug\",\n+            ast::MetaWord(ref value) => &value[..] == \"no_debug\",\n             _ => false\n         }\n     })"}, {"sha": "1af9fa87c6b7d2f6fd7bf31ce2877ebe46ecb36c", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -1046,14 +1046,14 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             controlflow::trans_if(bcx, expr.id, &**cond, &**thn, els.as_ref().map(|e| &**e), dest)\n         }\n         ast::ExprMatch(ref discr, ref arms, _) => {\n-            _match::trans_match(bcx, expr, &**discr, &arms[], dest)\n+            _match::trans_match(bcx, expr, &**discr, &arms[..], dest)\n         }\n         ast::ExprBlock(ref blk) => {\n             controlflow::trans_block(bcx, &**blk, dest)\n         }\n         ast::ExprStruct(_, ref fields, ref base) => {\n             trans_struct(bcx,\n-                         &fields[],\n+                         &fields[..],\n                          base.as_ref().map(|e| &**e),\n                          expr.span,\n                          expr.id,\n@@ -1118,7 +1118,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_adt(bcx,\n                       expr_ty(bcx, expr),\n                       0,\n-                      &numbered_fields[],\n+                      &numbered_fields[..],\n                       None,\n                       dest,\n                       expr.debug_loc())\n@@ -1153,21 +1153,21 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 trans_overloaded_call(bcx,\n                                       expr,\n                                       &**f,\n-                                      &args[],\n+                                      &args[..],\n                                       Some(dest))\n             } else {\n                 callee::trans_call(bcx,\n                                    expr,\n                                    &**f,\n-                                   callee::ArgExprs(&args[]),\n+                                   callee::ArgExprs(&args[..]),\n                                    dest)\n             }\n         }\n         ast::ExprMethodCall(_, _, ref args) => {\n             callee::trans_method_call(bcx,\n                                       expr,\n                                       &*args[0],\n-                                      callee::ArgExprs(&args[]),\n+                                      callee::ArgExprs(&args[..]),\n                                       dest)\n         }\n         ast::ExprBinary(op, ref lhs, ref rhs) => {\n@@ -1354,11 +1354,11 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n         ty::ty_struct(did, substs) => {\n             let fields = struct_fields(tcx, did, substs);\n             let fields = monomorphize::normalize_associated_type(tcx, &fields);\n-            op(0, &fields[])\n+            op(0, &fields[..])\n         }\n \n         ty::ty_tup(ref v) => {\n-            op(0, &tup_fields(&v[])[])\n+            op(0, &tup_fields(&v[..])[])\n         }\n \n         ty::ty_enum(_, substs) => {\n@@ -1378,7 +1378,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                                 tcx, enum_id, variant_id);\n                             let fields = struct_fields(tcx, variant_id, substs);\n                             let fields = monomorphize::normalize_associated_type(tcx, &fields);\n-                            op(variant_info.disr_val, &fields[])\n+                            op(variant_info.disr_val, &fields[..])\n                         }\n                         _ => {\n                             tcx.sess.bug(\"resolve didn't map this expr to a \\"}, {"sha": "4508fe21a65fadb90abcf37975190fd609b13139", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -238,7 +238,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n     let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n-    let llsig = foreign_signature(ccx, &fn_sig, &passed_arg_tys[]);\n+    let llsig = foreign_signature(ccx, &fn_sig, &passed_arg_tys[..]);\n     let fn_type = cabi::compute_abi_info(ccx,\n                                          &llsig.llarg_tys[],\n                                          llsig.llret_ty,\n@@ -370,7 +370,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let llforeign_retval = CallWithConv(bcx,\n                                         llfn,\n-                                        &llargs_foreign[],\n+                                        &llargs_foreign[..],\n                                         cc,\n                                         Some(attrs),\n                                         call_debug_loc);\n@@ -611,7 +611,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                ccx.tcx().map.path_to_string(id),\n                id, t.repr(tcx));\n \n-        let llfn = base::decl_internal_rust_fn(ccx, t, &ps[]);\n+        let llfn = base::decl_internal_rust_fn(ccx, t, &ps[..]);\n         base::set_llvm_fn_attrs(ccx, attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, param_substs, id, &[]);\n         llfn\n@@ -974,7 +974,7 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n     if tys.fn_sig.variadic {\n         Type::variadic_func(&llargument_tys, &llreturn_ty)\n     } else {\n-        Type::func(&llargument_tys[], &llreturn_ty)\n+        Type::func(&llargument_tys[..], &llreturn_ty)\n     }\n }\n "}, {"sha": "268b65c6ceb30c14f9af1889c890a870712e7fd8", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -170,7 +170,7 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n \n     let (glue, new_sym) = match ccx.available_drop_glues().borrow().get(&t) {\n         Some(old_sym) => {\n-            let glue = decl_cdecl_fn(ccx, &old_sym[], llfnty, ty::mk_nil(ccx.tcx()));\n+            let glue = decl_cdecl_fn(ccx, &old_sym[..], llfnty, ty::mk_nil(ccx.tcx()));\n             (glue, None)\n         },\n         None => {\n@@ -304,7 +304,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      class_did,\n                                      &[get_drop_glue_type(bcx.ccx(), t)],\n                                      ty::mk_nil(bcx.tcx()));\n-        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[], dtor_ty, DebugLoc::None);\n+        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[..], dtor_ty, DebugLoc::None);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n         variant_cx\n@@ -541,7 +541,7 @@ fn declare_generic_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n         ccx,\n         t,\n         &format!(\"glue_{}\", name)[]);\n-    let llfn = decl_cdecl_fn(ccx, &fn_nm[], llfnty, ty::mk_nil(ccx.tcx()));\n+    let llfn = decl_cdecl_fn(ccx, &fn_nm[..], llfnty, ty::mk_nil(ccx.tcx()));\n     note_unique_llvm_symbol(ccx, fn_nm.clone());\n     return (fn_nm, llfn);\n }"}, {"sha": "a1b66ed94f06bc8dfed134ea44cace4fd76e274d", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -166,7 +166,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let name = token::get_ident(foreign_item.ident);\n \n     // For `transmute` we can just trans the input expr directly into dest\n-    if &name[] == \"transmute\" {\n+    if &name[..] == \"transmute\" {\n         let llret_ty = type_of::type_of(ccx, ret_ty.unwrap());\n         match args {\n             callee::ArgExprs(arg_exprs) => {\n@@ -274,13 +274,13 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let call_debug_location = DebugLoc::At(call_info.id, call_info.span);\n \n     // These are the only intrinsic functions that diverge.\n-    if &name[] == \"abort\" {\n+    if &name[..] == \"abort\" {\n         let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n         Call(bcx, llfn, &[], None, call_debug_location);\n         fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         Unreachable(bcx);\n         return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n-    } else if &name[] == \"unreachable\" {\n+    } else if &name[..] == \"unreachable\" {\n         fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         Unreachable(bcx);\n         return Result::new(bcx, C_nil(ccx));\n@@ -307,7 +307,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     };\n \n     let simple = get_simple_intrinsic(ccx, &*foreign_item);\n-    let llval = match (simple, &name[]) {\n+    let llval = match (simple, &name[..]) {\n         (Some(llfn), _) => {\n             Call(bcx, llfn, &llargs, None, call_debug_location)\n         }"}, {"sha": "ec48ab0d34a06b60d84d5312084649225a4816bd", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -131,7 +131,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         hash = format!(\"h{}\", state.finish());\n         ccx.tcx().map.with_path(fn_id.node, |path| {\n-            exported_name(path, &hash[])\n+            exported_name(path, &hash[..])\n         })\n     };\n \n@@ -141,9 +141,9 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mut hash_id = Some(hash_id);\n     let mut mk_lldecl = |abi: abi::Abi| {\n         let lldecl = if abi != abi::Rust {\n-            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s[])\n+            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s[..])\n         } else {\n-            decl_internal_rust_fn(ccx, mono_ty, &s[])\n+            decl_internal_rust_fn(ccx, mono_ty, &s[..])\n         };\n \n         ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n@@ -182,7 +182,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                       if abi != abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n                               ccx, &**decl, &**body, &[], d, psubsts, fn_id.node,\n-                              Some(&hash[]));\n+                              Some(&hash[..]));\n                       } else {\n                           trans_fn(ccx, &**decl, &**body, d, psubsts, fn_id.node, &[]);\n                       }\n@@ -206,7 +206,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     trans_enum_variant(ccx,\n                                        parent,\n                                        &*v,\n-                                       &args[],\n+                                       &args[..],\n                                        this_tv.disr_val,\n                                        psubsts,\n                                        d);"}, {"sha": "489b56bbe6825f567968c2bc802549a21fcaf34b", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -144,7 +144,7 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let input_tys = inputs.iter().map(|&arg_ty| type_of_explicit_arg(cx, arg_ty));\n     atys.extend(input_tys);\n \n-    Type::func(&atys[], &lloutputtype)\n+    Type::func(&atys[..], &lloutputtype)\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n@@ -332,7 +332,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           let repr = adt::represent_type(cx, t);\n           let tps = substs.types.get_slice(subst::TypeSpace);\n           let name = llvm_type_name(cx, an_enum, did, tps);\n-          adt::incomplete_type_of(cx, &*repr, &name[])\n+          adt::incomplete_type_of(cx, &*repr, &name[..])\n       }\n       ty::ty_closure(did, _, ref substs) => {\n           // Only create the named struct, but don't fill it in. We\n@@ -343,7 +343,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           // contents of the VecPerParamSpace to to construct the llvm\n           // name\n           let name = llvm_type_name(cx, a_closure, did, substs.types.as_slice());\n-          adt::incomplete_type_of(cx, &*repr, &name[])\n+          adt::incomplete_type_of(cx, &*repr, &name[..])\n       }\n \n       ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n@@ -399,7 +399,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n               let repr = adt::represent_type(cx, t);\n               let tps = substs.types.get_slice(subst::TypeSpace);\n               let name = llvm_type_name(cx, a_struct, did, tps);\n-              adt::incomplete_type_of(cx, &*repr, &name[])\n+              adt::incomplete_type_of(cx, &*repr, &name[..])\n           }\n       }\n "}, {"sha": "e3c1c66f78c9c47774ee1740b52a42a538f45c37", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -1152,14 +1152,14 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n-                match ast_ty_to_trait_ref(this, rscope, &**ty, &bounds[]) {\n+                match ast_ty_to_trait_ref(this, rscope, &**ty, &bounds[..]) {\n                     Ok((trait_ref, projection_bounds)) => {\n                         trait_ref_to_object_type(this,\n                                                  rscope,\n                                                  ast_ty.span,\n                                                  trait_ref,\n                                                  projection_bounds,\n-                                                 &bounds[])\n+                                                 &bounds[..])\n                     }\n                     Err(ErrorReported) => {\n                         this.tcx().types.err\n@@ -1198,7 +1198,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(bare_fn))\n             }\n             ast::TyPolyTraitRef(ref bounds) => {\n-                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, &bounds[])\n+                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, &bounds[..])\n             }\n             ast::TyPath(ref path, id) => {\n                 let a_def = match tcx.def_map.borrow().get(&id) {\n@@ -1437,7 +1437,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n             // Skip the first argument if `self` is present.\n             &self_and_input_tys[1..]\n         } else {\n-            &self_and_input_tys[]\n+            &self_and_input_tys[..]\n         };\n \n         let (ior, lfp) = find_implied_output_region(input_tys, input_pats);\n@@ -1636,7 +1636,7 @@ fn conv_ty_poly_trait_ref<'tcx>(\n     ast_bounds: &[ast::TyParamBound])\n     -> Ty<'tcx>\n {\n-    let mut partitioned_bounds = partition_bounds(this.tcx(), span, &ast_bounds[]);\n+    let mut partitioned_bounds = partition_bounds(this.tcx(), span, &ast_bounds[..]);\n \n     let mut projection_bounds = Vec::new();\n     let main_trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {"}, {"sha": "34c52981b794dff838208073f38a0d048a9cb59f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -162,7 +162,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             check_pat_enum(pcx, pat, &path, Some(&[]), expected);\n         }\n         ast::PatEnum(ref path, ref subpats) => {\n-            let subpats = subpats.as_ref().map(|v| &v[]);\n+            let subpats = subpats.as_ref().map(|v| &v[..]);\n             check_pat_enum(pcx, pat, path, subpats, expected);\n         }\n         ast::PatStruct(ref path, ref fields, etc) => {"}, {"sha": "0ad15456df98f16daab554c59b289287426b0523", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -256,7 +256,7 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     check_argument_types(fcx,\n                          call_expr.span,\n                          &fn_sig.inputs,\n-                         &expected_arg_tys[],\n+                         &expected_arg_tys[..],\n                          arg_exprs,\n                          AutorefArgs::No,\n                          fn_sig.variadic,"}, {"sha": "978fbbbcffc33e7dfec2e527fb4bc9dff9e8a030", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -901,7 +901,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"applicable_candidates: {}\", applicable_candidates.repr(self.tcx()));\n \n         if applicable_candidates.len() > 1 {\n-            match self.collapse_candidates_to_trait_pick(&applicable_candidates[]) {\n+            match self.collapse_candidates_to_trait_pick(&applicable_candidates[..]) {\n                 Some(pick) => { return Some(Ok(pick)); }\n                 None => { }\n             }"}, {"sha": "0494e1f76865a57c3a8f3437b724fbbd33843add", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -172,7 +172,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             traits_are = if candidates.len() == 1 {\"trait is\"} else {\"traits are\"},\n             one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"});\n \n-        fcx.sess().fileline_help(span, &msg[]);\n+        fcx.sess().fileline_help(span, &msg[..]);\n \n         for (i, trait_did) in candidates.iter().enumerate() {\n             fcx.sess().fileline_help(span,\n@@ -218,7 +218,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"},\n             name = method_ustring);\n \n-        fcx.sess().fileline_help(span, &msg[]);\n+        fcx.sess().fileline_help(span, &msg[..]);\n \n         for (i, trait_info) in candidates.iter().enumerate() {\n             fcx.sess().fileline_help(span,"}, {"sha": "e443b4d0e606abd082e45a8fdd9f8b4e8efec526", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -2208,7 +2208,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         check_argument_types(fcx,\n                              sp,\n-                             &err_inputs[],\n+                             &err_inputs[..],\n                              &[],\n                              args_no_rcvr,\n                              autoref_args,\n@@ -2227,7 +2227,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 check_argument_types(fcx,\n                                      sp,\n                                      &fty.sig.0.inputs[1..],\n-                                     &expected_arg_tys[],\n+                                     &expected_arg_tys[..],\n                                      args_no_rcvr,\n                                      autoref_args,\n                                      fty.sig.0.variadic,\n@@ -3054,7 +3054,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::ty_struct(base_id, substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n-                        fcx.lookup_field_ty(expr.span, base_id, &fields[],\n+                        fcx.lookup_field_ty(expr.span, base_id, &fields[..],\n                                             field.node.name, &(*substs))\n                     }\n                     _ => None\n@@ -3154,7 +3154,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         if tuple_like {\n                             debug!(\"tuple struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                             let fields = ty::lookup_struct_fields(tcx, base_id);\n-                            fcx.lookup_tup_field_ty(expr.span, base_id, &fields[],\n+                            fcx.lookup_tup_field_ty(expr.span, base_id, &fields[..],\n                                                     idx.node, &(*substs))\n                         } else {\n                             None\n@@ -3327,7 +3327,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        class_id,\n                                        id,\n                                        fcx.ccx.tcx.mk_substs(struct_substs),\n-                                       &class_fields[],\n+                                       &class_fields[..],\n                                        fields,\n                                        base_expr.is_none(),\n                                        None);\n@@ -3370,7 +3370,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        variant_id,\n                                        id,\n                                        fcx.ccx.tcx.mk_substs(substitutions),\n-                                       &variant_fields[],\n+                                       &variant_fields[..],\n                                        fields,\n                                        true,\n                                        Some(enum_id));\n@@ -3731,10 +3731,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n       ast::ExprCall(ref callee, ref args) => {\n-          callee::check_call(fcx, expr, &**callee, &args[], expected);\n+          callee::check_call(fcx, expr, &**callee, &args[..], expected);\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n-        check_method_call(fcx, expr, ident, &args[], &tps[], expected, lvalue_pref);\n+        check_method_call(fcx, expr, ident, &args[..], &tps[..], expected, lvalue_pref);\n         let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n         let  args_err = arg_tys.fold(false,\n              |rest_err, a| {\n@@ -3821,7 +3821,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       ast::ExprTup(ref elts) => {\n         let flds = expected.only_has_type(fcx).and_then(|ty| {\n             match ty.sty {\n-                ty::ty_tup(ref flds) => Some(&flds[]),\n+                ty::ty_tup(ref flds) => Some(&flds[..]),\n                 _ => None\n             }\n         });\n@@ -3855,7 +3855,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let struct_id = match def {\n             Some(def::DefVariant(enum_id, variant_id, true)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n-                                          variant_id, &fields[]);\n+                                          variant_id, &fields[..]);\n                 enum_id\n             }\n             Some(def::DefTrait(def_id)) => {\n@@ -3864,7 +3864,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     pprust::path_to_string(path));\n                 check_struct_fields_on_error(fcx,\n                                              id,\n-                                             &fields[],\n+                                             &fields[..],\n                                              base_expr);\n                 def_id\n             },\n@@ -3877,7 +3877,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                  id,\n                                                  expr.span,\n                                                  struct_did,\n-                                                 &fields[],\n+                                                 &fields[..],\n                                                  base_expr.as_ref().map(|e| &**e));\n                     }\n                     _ => {\n@@ -3886,7 +3886,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             pprust::path_to_string(path));\n                         check_struct_fields_on_error(fcx,\n                                                      id,\n-                                                     &fields[],\n+                                                     &fields[..],\n                                                      base_expr);\n                     }\n                 }\n@@ -5231,10 +5231,10 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             }\n         };\n         (n_tps, inputs, ty::FnConverging(output))\n-    } else if &name[] == \"abort\" || &name[] == \"unreachable\" {\n+    } else if &name[..] == \"abort\" || &name[..] == \"unreachable\" {\n         (0, Vec::new(), ty::FnDiverging)\n     } else {\n-        let (n_tps, inputs, output) = match &name[] {\n+        let (n_tps, inputs, output) = match &name[..] {\n             \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n             \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.uint),\n@@ -5259,7 +5259,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n                   Ok(t) => t,\n-                  Err(s) => { span_fatal!(tcx.sess, it.span, E0240, \"{}\", &s[]); }\n+                  Err(s) => { span_fatal!(tcx.sess, it.span, E0240, \"{}\", &s[..]); }\n               };\n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n                   ty: tydesc_ty,"}, {"sha": "44a3b5167c7ea5d2b5bc348231d29fd0ad0ad8ac", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -294,8 +294,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n         let len = self.region_bound_pairs.len();\n         let old_body_id = self.set_body_id(body.id);\n-        self.relate_free_regions(&fn_sig[], body.id, span);\n-        link_fn_args(self, CodeExtent::from_node_id(body.id), &fn_decl.inputs[]);\n+        self.relate_free_regions(&fn_sig[..], body.id, span);\n+        link_fn_args(self, CodeExtent::from_node_id(body.id), &fn_decl.inputs[..]);\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n         self.region_bound_pairs.truncate(len);\n@@ -690,7 +690,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         }\n \n         ast::ExprMatch(ref discr, ref arms, _) => {\n-            link_match(rcx, &**discr, &arms[]);\n+            link_match(rcx, &**discr, &arms[..]);\n \n             visit::walk_expr(rcx, expr);\n         }"}, {"sha": "833daf083a7323c991781790377ec83b794755b0", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -268,7 +268,7 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n                 let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, &*va.ty)).collect();\n-                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys[], enum_scheme.ty)\n+                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys[..], enum_scheme.ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n@@ -313,7 +313,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     trait_id,\n                                     &trait_def.generics,\n                                     &trait_predicates,\n-                                    &trait_items[],\n+                                    &trait_items[..],\n                                     &m.id,\n                                     &m.ident.name,\n                                     &m.explicit_self,\n@@ -328,7 +328,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     trait_id,\n                                     &trait_def.generics,\n                                     &trait_predicates,\n-                                    &trait_items[],\n+                                    &trait_items[..],\n                                     &m.id,\n                                     &m.pe_ident().name,\n                                     m.pe_explicit_self(),\n@@ -871,7 +871,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                             local_def(field.node.id)].ty).collect();\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n                                                 local_def(ctor_id),\n-                                                &inputs[],\n+                                                &inputs[..],\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id),\n@@ -1358,7 +1358,7 @@ fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n     ty_generics(ccx,\n                 subst::FnSpace,\n-                &early_lifetimes[],\n+                &early_lifetimes[..],\n                 &generics.ty_params[],\n                 &generics.where_clause,\n                 base_generics)"}, {"sha": "bf29bcd5123f14973d73d8fa71b4c5d63ed4742f", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -1065,7 +1065,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             // attribute and report an error with various results if found.\n             if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n                 let found = item_variances.repr(tcx);\n-                span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{}\", &found[]);\n+                span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{}\", &found[..]);\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()"}, {"sha": "44c0acda66fba8e8c3c0384ae763d970b488fadd", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -34,7 +34,7 @@ pub fn highlight(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n          class,\n          id,\n          &mut out).unwrap();\n-    String::from_utf8_lossy(&out[]).into_owned()\n+    String::from_utf8_lossy(&out[..]).into_owned()\n }\n \n /// Exhausts the `lexer` writing the output into `out`."}, {"sha": "a0f42815b439611b61fd1e07a748b69adaa2cef4", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -1120,7 +1120,7 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_string<'a>(&'a self) -> Option<&'a str> {\n         match *self {\n-            Json::String(ref s) => Some(&s[]),\n+            Json::String(ref s) => Some(&s[..]),\n             _ => None\n         }\n     }\n@@ -2237,7 +2237,7 @@ impl ::Decoder for Decoder {\n                 return Err(ExpectedError(\"String or Object\".to_string(), format!(\"{}\", json)))\n             }\n         };\n-        let idx = match names.iter().position(|n| *n == &name[]) {\n+        let idx = match names.iter().position(|n| *n == &name[..]) {\n             Some(idx) => idx,\n             None => return Err(UnknownVariantError(name))\n         };\n@@ -3461,7 +3461,7 @@ mod tests {\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(&mem_buf[]).unwrap();\n+        let json_str = from_utf8(&mem_buf[..]).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -3477,7 +3477,7 @@ mod tests {\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(&mem_buf[]).unwrap();\n+        let json_str = from_utf8(&mem_buf[..]).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -3517,7 +3517,7 @@ mod tests {\n             write!(&mut writer, \"{}\",\n                    super::as_pretty_json(&json).indent(i)).unwrap();\n \n-            let printed = from_utf8(&writer[]).unwrap();\n+            let printed = from_utf8(&writer[..]).unwrap();\n \n             // Check for indents at each line\n             let lines: Vec<&str> = printed.lines().collect();\n@@ -3549,7 +3549,7 @@ mod tests {\n         let mut map = HashMap::new();\n         map.insert(Enum::Foo, 0);\n         let result = json::encode(&map).unwrap();\n-        assert_eq!(&result[], r#\"{\"Foo\":0}\"#);\n+        assert_eq!(&result[..], r#\"{\"Foo\":0}\"#);\n         let decoded: HashMap<Enum, _> = json::decode(&result).unwrap();\n         assert_eq!(map, decoded);\n     }"}, {"sha": "70f0ba4bb23af013d1429e4d5fcdb2e882a85bac", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -326,7 +326,7 @@ impl Encodable for str {\n \n impl Encodable for String {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self[])\n+        s.emit_str(&self[..])\n     }\n }\n "}, {"sha": "84149a2eb8e43353a1d9857c8a19cdecd65f379e", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -104,7 +104,7 @@ impl ops::Deref for OsString {\n \n     #[inline]\n     fn deref(&self) -> &OsStr {\n-        &self[]\n+        &self[..]\n     }\n }\n \n@@ -286,7 +286,7 @@ impl Debug for OsStr {\n }\n \n impl Borrow<OsStr> for OsString {\n-    fn borrow(&self) -> &OsStr { &self[] }\n+    fn borrow(&self) -> &OsStr { &self[..] }\n }\n \n impl ToOwned for OsStr {\n@@ -308,7 +308,7 @@ impl AsOsStr for OsStr {\n \n impl AsOsStr for OsString {\n     fn as_os_str(&self) -> &OsStr {\n-        &self[]\n+        &self[..]\n     }\n }\n \n@@ -320,7 +320,7 @@ impl AsOsStr for str {\n \n impl AsOsStr for String {\n     fn as_os_str(&self) -> &OsStr {\n-        OsStr::from_str(&self[])\n+        OsStr::from_str(&self[..])\n     }\n }\n "}, {"sha": "e9a8dbb4098afb3f15340725b35894ae409cf20b", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -618,14 +618,14 @@ mod tests {\n     #[test]\n     fn read_char_buffered() {\n         let buf = [195u8, 159u8];\n-        let mut reader = BufReader::with_capacity(1, &buf[]);\n+        let mut reader = BufReader::with_capacity(1, &buf[..]);\n         assert_eq!(reader.chars().next(), Some(Ok('\u00df')));\n     }\n \n     #[test]\n     fn test_chars() {\n         let buf = [195u8, 159u8, b'a'];\n-        let mut reader = BufReader::with_capacity(1, &buf[]);\n+        let mut reader = BufReader::with_capacity(1, &buf[..]);\n         let mut it = reader.chars();\n         assert_eq!(it.next(), Some(Ok('\u00df')));\n         assert_eq!(it.next(), Some(Ok('a')));"}, {"sha": "f6cb4a8c9f36988f3b834b55261f1394eda32e70", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -180,7 +180,7 @@ mod tests {\n     fn test_buf_writer() {\n         let mut buf = [0 as u8; 9];\n         {\n-            let mut writer = Cursor::new(&mut buf[]);\n+            let mut writer = Cursor::new(&mut buf[..]);\n             assert_eq!(writer.position(), 0);\n             assert_eq!(writer.write(&[0]), Ok(1));\n             assert_eq!(writer.position(), 1);\n@@ -201,7 +201,7 @@ mod tests {\n     fn test_buf_writer_seek() {\n         let mut buf = [0 as u8; 8];\n         {\n-            let mut writer = Cursor::new(&mut buf[]);\n+            let mut writer = Cursor::new(&mut buf[..]);\n             assert_eq!(writer.position(), 0);\n             assert_eq!(writer.write(&[1]), Ok(1));\n             assert_eq!(writer.position(), 1);\n@@ -229,7 +229,7 @@ mod tests {\n     #[test]\n     fn test_buf_writer_error() {\n         let mut buf = [0 as u8; 2];\n-        let mut writer = Cursor::new(&mut buf[]);\n+        let mut writer = Cursor::new(&mut buf[..]);\n         assert_eq!(writer.write(&[0]), Ok(1));\n         assert_eq!(writer.write(&[0, 0]), Ok(1));\n         assert_eq!(writer.write(&[0, 0]), Ok(0));\n@@ -331,7 +331,7 @@ mod tests {\n     #[test]\n     fn seek_past_end() {\n         let buf = [0xff];\n-        let mut r = Cursor::new(&buf[]);\n+        let mut r = Cursor::new(&buf[..]);\n         assert_eq!(r.seek(SeekFrom::Start(10)), Ok(10));\n         assert_eq!(r.read(&mut [0]), Ok(0));\n \n@@ -340,22 +340,22 @@ mod tests {\n         assert_eq!(r.read(&mut [0]), Ok(0));\n \n         let mut buf = [0];\n-        let mut r = Cursor::new(&mut buf[]);\n+        let mut r = Cursor::new(&mut buf[..]);\n         assert_eq!(r.seek(SeekFrom::Start(10)), Ok(10));\n         assert_eq!(r.write(&[3]), Ok(0));\n     }\n \n     #[test]\n     fn seek_before_0() {\n         let buf = [0xff_u8];\n-        let mut r = Cursor::new(&buf[]);\n+        let mut r = Cursor::new(&buf[..]);\n         assert!(r.seek(SeekFrom::End(-2)).is_err());\n \n         let mut r = Cursor::new(vec!(10u8));\n         assert!(r.seek(SeekFrom::End(-2)).is_err());\n \n         let mut buf = [0];\n-        let mut r = Cursor::new(&mut buf[]);\n+        let mut r = Cursor::new(&mut buf[..]);\n         assert!(r.seek(SeekFrom::End(-2)).is_err());\n     }\n "}, {"sha": "2d2d0d8b33a4c9e68ef0bf00e7f2511b878d7b22", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -546,7 +546,7 @@ mod test {\n         assert_eq!(a, &w.get_ref()[]);\n         let w = w.into_inner();\n         let a: &[_] = &[0, 1];\n-        assert_eq!(a, &w[]);\n+        assert_eq!(a, &w[..]);\n     }\n \n     // This is just here to make sure that we don't infinite loop in the\n@@ -643,14 +643,14 @@ mod test {\n     #[test]\n     fn read_char_buffered() {\n         let buf = [195u8, 159u8];\n-        let mut reader = BufferedReader::with_capacity(1, &buf[]);\n+        let mut reader = BufferedReader::with_capacity(1, &buf[..]);\n         assert_eq!(reader.read_char(), Ok('\u00df'));\n     }\n \n     #[test]\n     fn test_chars() {\n         let buf = [195u8, 159u8, b'a'];\n-        let mut reader = BufferedReader::with_capacity(1, &buf[]);\n+        let mut reader = BufferedReader::with_capacity(1, &buf[..]);\n         let mut it = reader.chars();\n         assert_eq!(it.next(), Some(Ok('\u00df')));\n         assert_eq!(it.next(), Some(Ok('a')));"}, {"sha": "e9005aa22bcfbebc37cbb051a1bcde0c412d3180", "filename": "src/libstd/old_path/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -877,7 +877,7 @@ impl BytesContainer for String {\n     }\n     #[inline]\n     fn container_as_str(&self) -> Option<&str> {\n-        Some(&self[])\n+        Some(&self[..])\n     }\n     #[inline]\n     fn is_str(_: Option<&String>) -> bool { true }\n@@ -893,7 +893,7 @@ impl BytesContainer for [u8] {\n impl BytesContainer for Vec<u8> {\n     #[inline]\n     fn container_as_bytes(&self) -> &[u8] {\n-        &self[]\n+        &self[..]\n     }\n }\n "}, {"sha": "887dc804c7af3da57949f4ea87c1fa249c46e751", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -198,7 +198,7 @@ impl GenericPathUnsafe for Path {\n                 s.push_str(\"..\");\n                 s.push(SEP);\n                 s.push_str(filename);\n-                self.update_normalized(&s[]);\n+                self.update_normalized(&s[..]);\n             }\n             None => {\n                 self.update_normalized(filename);\n@@ -208,20 +208,20 @@ impl GenericPathUnsafe for Path {\n                 s.push_str(&self.repr[..end]);\n                 s.push(SEP);\n                 s.push_str(filename);\n-                self.update_normalized(&s[]);\n+                self.update_normalized(&s[..]);\n             }\n             Some((idxb,idxa,_)) if self.prefix == Some(DiskPrefix) && idxa == self.prefix_len() => {\n                 let mut s = String::with_capacity(idxb + filename.len());\n                 s.push_str(&self.repr[..idxb]);\n                 s.push_str(filename);\n-                self.update_normalized(&s[]);\n+                self.update_normalized(&s[..]);\n             }\n             Some((idxb,_,_)) => {\n                 let mut s = String::with_capacity(idxb + 1 + filename.len());\n                 s.push_str(&self.repr[..idxb]);\n                 s.push(SEP);\n                 s.push_str(filename);\n-                self.update_normalized(&s[]);\n+                self.update_normalized(&s[..]);\n             }\n         }\n     }\n@@ -245,7 +245,7 @@ impl GenericPathUnsafe for Path {\n         }\n         fn shares_volume(me: &Path, path: &str) -> bool {\n             // path is assumed to have a prefix of Some(DiskPrefix)\n-            let repr = &me.repr[];\n+            let repr = &me.repr[..];\n             match me.prefix {\n                 Some(DiskPrefix) => {\n                     repr.as_bytes()[0] == path.as_bytes()[0].to_ascii_uppercase()\n@@ -277,7 +277,7 @@ impl GenericPathUnsafe for Path {\n                         else { None };\n             let pathlen = path_.as_ref().map_or(path.len(), |p| p.len());\n             let mut s = String::with_capacity(me.repr.len() + 1 + pathlen);\n-            s.push_str(&me.repr[]);\n+            s.push_str(&me.repr[..]);\n             let plen = me.prefix_len();\n             // if me is \"C:\" we don't want to add a path separator\n             match me.prefix {\n@@ -289,9 +289,9 @@ impl GenericPathUnsafe for Path {\n             }\n             match path_ {\n                 None => s.push_str(path),\n-                Some(p) => s.push_str(&p[]),\n+                Some(p) => s.push_str(&p[..]),\n             };\n-            me.update_normalized(&s[])\n+            me.update_normalized(&s[..])\n         }\n \n         if !path.is_empty() {\n@@ -345,7 +345,7 @@ impl GenericPath for Path {\n     /// Always returns a `Some` value.\n     #[inline]\n     fn as_str<'a>(&'a self) -> Option<&'a str> {\n-        Some(&self.repr[])\n+        Some(&self.repr[..])\n     }\n \n     #[inline]\n@@ -367,13 +367,13 @@ impl GenericPath for Path {\n     /// Always returns a `Some` value.\n     fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n         Some(match self.sepidx_or_prefix_len() {\n-            None if \"..\" == self.repr => &self.repr[],\n+            None if \"..\" == self.repr => &self.repr[..],\n             None => \".\",\n             Some((_,idxa,end)) if &self.repr[idxa..end] == \"..\" => {\n-                &self.repr[]\n+                &self.repr[..]\n             }\n             Some((idxb,_,end)) if &self.repr[idxb..end] == \"\\\\\" => {\n-                &self.repr[]\n+                &self.repr[..]\n             }\n             Some((0,idxa,_)) => &self.repr[..idxa],\n             Some((idxb,idxa,_)) => {\n@@ -395,7 +395,7 @@ impl GenericPath for Path {\n     /// See `GenericPath::filename_str` for info.\n     /// Always returns a `Some` value if `filename` returns a `Some` value.\n     fn filename_str<'a>(&'a self) -> Option<&'a str> {\n-        let repr = &self.repr[];\n+        let repr = &self.repr[..];\n         match self.sepidx_or_prefix_len() {\n             None if \".\" == repr || \"..\" == repr => None,\n             None => Some(repr),\n@@ -655,7 +655,7 @@ impl Path {\n     /// Does not distinguish between absolute and cwd-relative paths, e.g.\n     /// C:\\foo and C:foo.\n     pub fn str_components<'a>(&'a self) -> StrComponents<'a> {\n-        let repr = &self.repr[];\n+        let repr = &self.repr[..];\n         let s = match self.prefix {\n             Some(_) => {\n                 let plen = self.prefix_len();\n@@ -683,8 +683,8 @@ impl Path {\n     }\n \n     fn equiv_prefix(&self, other: &Path) -> bool {\n-        let s_repr = &self.repr[];\n-        let o_repr = &other.repr[];\n+        let s_repr = &self.repr[..];\n+        let o_repr = &other.repr[..];\n         match (self.prefix, other.prefix) {\n             (Some(DiskPrefix), Some(VerbatimDiskPrefix)) => {\n                 self.is_absolute() &&\n@@ -839,7 +839,7 @@ impl Path {\n     fn update_sepidx(&mut self) {\n         let s = if self.has_nonsemantic_trailing_slash() {\n                     &self.repr[..self.repr.len()-1]\n-                } else { &self.repr[] };\n+                } else { &self.repr[..] };\n         let sep_test: fn(char) -> bool = if !prefix_is_verbatim(self.prefix) {\n             is_sep\n         } else {\n@@ -918,7 +918,7 @@ pub fn is_verbatim(path: &Path) -> bool {\n /// non-verbatim, the non-verbatim version is returned.\n /// Otherwise, None is returned.\n pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n-    let repr = &path.repr[];\n+    let repr = &path.repr[..];\n     let new_path = match path.prefix {\n         Some(VerbatimPrefix(_)) | Some(DeviceNSPrefix(_)) => return None,\n         Some(UNCPrefix(_,_)) | Some(DiskPrefix) | None => return Some(path.clone()),"}, {"sha": "2e05f6d974e3ed9492917d5e8335413261e9c6bc", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -37,7 +37,7 @@ pub fn on_panic(obj: &(Any+Send), file: &'static str, line: uint) {\n     let msg = match obj.downcast_ref::<&'static str>() {\n         Some(s) => *s,\n         None => match obj.downcast_ref::<String>() {\n-            Some(s) => &s[],\n+            Some(s) => &s[..],\n             None => \"Box<Any>\",\n         }\n     };"}, {"sha": "49a5efec7c2e48095a9bdc282b5274d7b24a5410", "filename": "src/libstd/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -977,7 +977,7 @@ impl ops::Deref for PathBuf {\n     type Target = Path;\n \n     fn deref(&self) -> &Path {\n-        unsafe { mem::transmute(&self.inner[]) }\n+        unsafe { mem::transmute(&self.inner[..]) }\n     }\n }\n \n@@ -1014,7 +1014,7 @@ impl cmp::Ord for PathBuf {\n \n impl AsOsStr for PathBuf {\n     fn as_os_str(&self) -> &OsStr {\n-        &self.inner[]\n+        &self.inner[..]\n     }\n }\n "}, {"sha": "a756fb29f81aeb5f32c4d446efb633cf6220b2b9", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -265,12 +265,12 @@ fn fill_utf16_buf_base<F1, F2, T>(mut f1: F1, f2: F2) -> Result<T, ()>\n         let mut n = stack_buf.len();\n         loop {\n             let buf = if n <= stack_buf.len() {\n-                &mut stack_buf[]\n+                &mut stack_buf[..]\n             } else {\n                 let extra = n - heap_buf.len();\n                 heap_buf.reserve(extra);\n                 heap_buf.set_len(n);\n-                &mut heap_buf[]\n+                &mut heap_buf[..]\n             };\n \n             // This function is typically called on windows API functions which"}, {"sha": "6520d30487c76d978e6d5441370214c0332402c3", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -114,7 +114,7 @@ impl Iterator for Env {\n \n             let (k, v) = match s.iter().position(|&b| b == '=' as u16) {\n                 Some(n) => (&s[..n], &s[n+1..]),\n-                None => (s, &[][]),\n+                None => (s, &[][..]),\n             };\n             Some((OsStringExt::from_wide(k), OsStringExt::from_wide(v)))\n         }\n@@ -186,7 +186,7 @@ impl<'a> Iterator for SplitPaths<'a> {\n         if !must_yield && in_progress.is_empty() {\n             None\n         } else {\n-            Some(super::os2path(&in_progress[]))\n+            Some(super::os2path(&in_progress[..]))\n         }\n     }\n }\n@@ -208,14 +208,14 @@ pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n             return Err(JoinPathsError)\n         } else if v.contains(&sep) {\n             joined.push(b'\"' as u16);\n-            joined.push_all(&v[]);\n+            joined.push_all(&v[..]);\n             joined.push(b'\"' as u16);\n         } else {\n-            joined.push_all(&v[]);\n+            joined.push_all(&v[..]);\n         }\n     }\n \n-    Ok(OsStringExt::from_wide(&joined[]))\n+    Ok(OsStringExt::from_wide(&joined[..]))\n }\n \n impl fmt::Display for JoinPathsError {"}, {"sha": "4e36ed2f17f921fc08a2a911c1521f1eb0dd480d", "filename": "src/libstd/sys/windows/process2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -472,7 +472,7 @@ mod tests {\n             \"echo \\\"a b c\\\"\"\n         );\n         assert_eq!(\n-            test_wrapper(\"\\u{03c0}\\u{042f}\\u{97f3}\\u{00e6}\\u{221e}\", &[]),\n+            test_wrapper(\"\\u{03c0}\\u{042f}\\u{97f3}\\u{00e6}\\u{221e}\", &[..]),\n             \"\\u{03c0}\\u{042f}\\u{97f3}\\u{00e6}\\u{221e}\"\n         );\n     }"}, {"sha": "140e21b5d04b756cb0a1abcf4e838f74a56e3231", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -198,7 +198,7 @@ impl Encodable for Ident {\n \n impl Decodable for Ident {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n-        Ok(str_to_ident(&try!(d.read_str())[]))\n+        Ok(str_to_ident(&try!(d.read_str())[..]))\n     }\n }\n "}, {"sha": "ba08f61b5575ccef6c7817b9ddc712605b296a1e", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -86,7 +86,7 @@ pub fn path_to_string<PI: Iterator<Item=PathElem>>(path: PI) -> String {\n         if !s.is_empty() {\n             s.push_str(\"::\");\n         }\n-        s.push_str(&e[]);\n+        s.push_str(&e[..]);\n         s\n     })\n }\n@@ -463,20 +463,20 @@ impl<'ast> Map<'ast> {\n         F: FnOnce(Option<&[Attribute]>) -> T,\n     {\n         let attrs = match self.get(id) {\n-            NodeItem(i) => Some(&i.attrs[]),\n-            NodeForeignItem(fi) => Some(&fi.attrs[]),\n+            NodeItem(i) => Some(&i.attrs[..]),\n+            NodeForeignItem(fi) => Some(&fi.attrs[..]),\n             NodeTraitItem(ref tm) => match **tm {\n-                RequiredMethod(ref type_m) => Some(&type_m.attrs[]),\n-                ProvidedMethod(ref m) => Some(&m.attrs[]),\n-                TypeTraitItem(ref typ) => Some(&typ.attrs[]),\n+                RequiredMethod(ref type_m) => Some(&type_m.attrs[..]),\n+                ProvidedMethod(ref m) => Some(&m.attrs[..]),\n+                TypeTraitItem(ref typ) => Some(&typ.attrs[..]),\n             },\n             NodeImplItem(ref ii) => {\n                 match **ii {\n-                    MethodImplItem(ref m) => Some(&m.attrs[]),\n-                    TypeImplItem(ref t) => Some(&t.attrs[]),\n+                    MethodImplItem(ref m) => Some(&m.attrs[..]),\n+                    TypeImplItem(ref t) => Some(&t.attrs[..]),\n                 }\n             }\n-            NodeVariant(ref v) => Some(&v.node.attrs[]),\n+            NodeVariant(ref v) => Some(&v.node.attrs[..]),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n             // FIXME(eddyb) make this work again (requires access to the map).\n@@ -577,7 +577,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n                 None => return false,\n                 Some((node_id, name)) => (node_id, name),\n             };\n-            if &part[] != mod_name.as_str() {\n+            if &part[..] != mod_name.as_str() {\n                 return false;\n             }\n             cursor = self.map.get_parent(mod_id);\n@@ -615,7 +615,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n     // We are looking at some node `n` with a given name and parent\n     // id; do their names match what I am seeking?\n     fn matches_names(&self, parent_of_n: NodeId, name: Name) -> bool {\n-        name.as_str() == &self.item_name[] &&\n+        name.as_str() == &self.item_name[..] &&\n             self.suffix_matches(parent_of_n)\n     }\n }\n@@ -1026,7 +1026,7 @@ impl<'a> NodePrinter for pprust::State<'a> {\n \n fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n     let id_str = format!(\" (id={})\", id);\n-    let id_str = if include_id { &id_str[] } else { \"\" };\n+    let id_str = if include_id { &id_str[..] } else { \"\" };\n \n     match map.find(id) {\n         Some(NodeItem(item)) => {"}, {"sha": "f660296fcd7b6c72892ac064bf3c0963376256a0", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -257,11 +257,11 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     match *trait_ref {\n         Some(ref trait_ref) => {\n             pretty.push('.');\n-            pretty.push_str(&pprust::path_to_string(&trait_ref.path)[]);\n+            pretty.push_str(&pprust::path_to_string(&trait_ref.path));\n         }\n         None => {}\n     }\n-    token::gensym_ident(&pretty[])\n+    token::gensym_ident(&pretty[..])\n }\n \n pub fn trait_method_to_ty_method(method: &Method) -> TypeMethod {\n@@ -673,7 +673,7 @@ pub fn pat_is_ident(pat: P<ast::Pat>) -> bool {\n pub fn path_name_eq(a : &ast::Path, b : &ast::Path) -> bool {\n     (a.span == b.span)\n     && (a.global == b.global)\n-    && (segments_name_eq(&a.segments[], &b.segments[]))\n+    && (segments_name_eq(&a.segments[..], &b.segments[..]))\n }\n \n // are two arrays of segments equal when compared unhygienically?"}, {"sha": "62e676891a0e6c349fc6581cacf302c8de2484e5", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -44,7 +44,7 @@ pub fn is_used(attr: &Attribute) -> bool {\n \n pub trait AttrMetaMethods {\n     fn check_name(&self, name: &str) -> bool {\n-        name == &self.name()[]\n+        name == &self.name()[..]\n     }\n \n     /// Retrieve the name of the meta item, e.g. `foo` in `#[foo]`,\n@@ -62,7 +62,7 @@ pub trait AttrMetaMethods {\n \n impl AttrMetaMethods for Attribute {\n     fn check_name(&self, name: &str) -> bool {\n-        let matches = name == &self.name()[];\n+        let matches = name == &self.name()[..];\n         if matches {\n             mark_used(self);\n         }\n@@ -101,7 +101,7 @@ impl AttrMetaMethods for MetaItem {\n \n     fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n         match self.node {\n-            MetaList(_, ref l) => Some(&l[]),\n+            MetaList(_, ref l) => Some(&l[..]),\n             _ => None\n         }\n     }\n@@ -142,7 +142,7 @@ impl AttributeMethods for Attribute {\n             let meta = mk_name_value_item_str(\n                 InternedString::new(\"doc\"),\n                 token::intern_and_get_ident(&strip_doc_comment_decoration(\n-                        &comment)[]));\n+                        &comment)));\n             if self.node.style == ast::AttrOuter {\n                 f(&mk_attr_outer(self.node.id, meta))\n             } else {\n@@ -302,9 +302,9 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n             }\n             MetaList(ref n, ref items) if *n == \"inline\" => {\n                 mark_used(attr);\n-                if contains_name(&items[], \"always\") {\n+                if contains_name(&items[..], \"always\") {\n                     InlineAlways\n-                } else if contains_name(&items[], \"never\") {\n+                } else if contains_name(&items[..], \"never\") {\n                     InlineNever\n                 } else {\n                     InlineHint\n@@ -326,11 +326,11 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n /// Tests if a cfg-pattern matches the cfg set\n pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::MetaItem) -> bool {\n     match cfg.node {\n-        ast::MetaList(ref pred, ref mis) if &pred[] == \"any\" =>\n+        ast::MetaList(ref pred, ref mis) if &pred[..] == \"any\" =>\n             mis.iter().any(|mi| cfg_matches(diagnostic, cfgs, &**mi)),\n-        ast::MetaList(ref pred, ref mis) if &pred[] == \"all\" =>\n+        ast::MetaList(ref pred, ref mis) if &pred[..] == \"all\" =>\n             mis.iter().all(|mi| cfg_matches(diagnostic, cfgs, &**mi)),\n-        ast::MetaList(ref pred, ref mis) if &pred[] == \"not\" => {\n+        ast::MetaList(ref pred, ref mis) if &pred[..] == \"not\" => {\n             if mis.len() != 1 {\n                 diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n                 return false;\n@@ -382,7 +382,7 @@ fn find_stability_generic<'a,\n \n     'outer: for attr in attrs {\n         let tag = attr.name();\n-        let tag = &tag[];\n+        let tag = &tag[..];\n         if tag != \"deprecated\" && tag != \"unstable\" && tag != \"stable\" {\n             continue // not a stability level\n         }\n@@ -404,7 +404,7 @@ fn find_stability_generic<'a,\n                             }\n                         }\n                     }\n-                    if &meta.name()[] == \"since\" {\n+                    if &meta.name()[..] == \"since\" {\n                         match meta.value_str() {\n                             Some(v) => since = Some(v),\n                             None => {\n@@ -413,7 +413,7 @@ fn find_stability_generic<'a,\n                             }\n                         }\n                     }\n-                    if &meta.name()[] == \"reason\" {\n+                    if &meta.name()[..] == \"reason\" {\n                         match meta.value_str() {\n                             Some(v) => reason = Some(v),\n                             None => {\n@@ -501,7 +501,7 @@ pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n \n         if !set.insert(name.clone()) {\n             diagnostic.span_fatal(meta.span,\n-                                  &format!(\"duplicate meta item `{}`\", name)[]);\n+                                  &format!(\"duplicate meta item `{}`\", name));\n         }\n     }\n }\n@@ -521,7 +521,7 @@ pub fn find_repr_attrs(diagnostic: &SpanHandler, attr: &Attribute) -> Vec<ReprAt\n             for item in items {\n                 match item.node {\n                     ast::MetaWord(ref word) => {\n-                        let hint = match &word[] {\n+                        let hint = match &word[..] {\n                             // Can't use \"extern\" because it's not a lexical identifier.\n                             \"C\" => Some(ReprExtern),\n                             \"packed\" => Some(ReprPacked),"}, {"sha": "099f646294235d175dcdf47b59ac0daa419f7024", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -360,7 +360,7 @@ impl CodeMap {\n         let mut src = if src.starts_with(\"\\u{feff}\") {\n             String::from_str(&src[3..])\n         } else {\n-            String::from_str(&src[])\n+            String::from_str(&src[..])\n         };\n \n         // Append '\\n' in case it's not already there."}, {"sha": "dfe3477bddc3bba2eaafb7a92479e2c1e013a6d9", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -311,7 +311,7 @@ impl<'a> fold::Folder for CfgAttrFolder<'a> {\n             }\n         };\n \n-        if attr::cfg_matches(self.diag, &self.config[], &cfg) {\n+        if attr::cfg_matches(self.diag, &self.config[..], &cfg) {\n             Some(respan(mi.span, ast::Attribute_ {\n                 id: attr::mk_attr_id(),\n                 style: attr.node.style,"}, {"sha": "02643fae9a1673691443a214695be2aff9fbfad3", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -129,7 +129,7 @@ impl SpanHandler {\n         panic!(ExplicitBug);\n     }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n-        self.span_bug(sp, &format!(\"unimplemented {}\", msg)[]);\n+        self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n     }\n     pub fn handler<'a>(&'a self) -> &'a Handler {\n         &self.handler\n@@ -173,7 +173,7 @@ impl Handler {\n                         self.err_count.get());\n           }\n         }\n-        self.fatal(&s[]);\n+        self.fatal(&s[..]);\n     }\n     pub fn warn(&self, msg: &str) {\n         self.emit.borrow_mut().emit(None, msg, None, Warning);\n@@ -189,7 +189,7 @@ impl Handler {\n         panic!(ExplicitBug);\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n-        self.bug(&format!(\"unimplemented {}\", msg)[]);\n+        self.bug(&format!(\"unimplemented {}\", msg));\n     }\n     pub fn emit(&self,\n                 cmsp: Option<(&codemap::CodeMap, Span)>,\n@@ -419,12 +419,12 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         // the span)\n         let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n         let ses = cm.span_to_string(span_end);\n-        try!(print_diagnostic(dst, &ses[], lvl, msg, code));\n+        try!(print_diagnostic(dst, &ses[..], lvl, msg, code));\n         if rsp.is_full_span() {\n             try!(custom_highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n         }\n     } else {\n-        try!(print_diagnostic(dst, &ss[], lvl, msg, code));\n+        try!(print_diagnostic(dst, &ss[..], lvl, msg, code));\n         if rsp.is_full_span() {\n             try!(highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n         }\n@@ -436,7 +436,7 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         Some(code) =>\n             match dst.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n                 Some(_) => {\n-                    try!(print_diagnostic(dst, &ss[], Help,\n+                    try!(print_diagnostic(dst, &ss[..], Help,\n                                           &format!(\"pass `--explain {}` to see a detailed \\\n                                                    explanation\", code)[], None));\n                 }\n@@ -455,7 +455,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     let fm = &*lines.file;\n \n     let mut elided = false;\n-    let mut display_lines = &lines.lines[];\n+    let mut display_lines = &lines.lines[..];\n     if display_lines.len() > MAX_LINES {\n         display_lines = &display_lines[0..MAX_LINES];\n         elided = true;\n@@ -563,7 +563,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n                           -> old_io::IoResult<()> {\n     let fm = &*lines.file;\n \n-    let lines = &lines.lines[];\n+    let lines = &lines.lines[..];\n     if lines.len() > MAX_LINES {\n         if let Some(line) = fm.get_line(lines[0]) {\n             try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n@@ -610,7 +610,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n     s.push('^');\n     s.push('\\n');\n     print_maybe_styled(w,\n-                       &s[],\n+                       &s[..],\n                        term::attr::ForegroundColor(lvl.color()))\n }\n \n@@ -627,12 +627,12 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n                     codemap::MacroAttribute => (\"#[\", \"]\"),\n                     codemap::MacroBang => (\"\", \"!\")\n                 };\n-                try!(print_diagnostic(w, &ss[], Note,\n+                try!(print_diagnostic(w, &ss, Note,\n                                       &format!(\"in expansion of {}{}{}\", pre,\n                                               ei.callee.name,\n-                                              post)[], None));\n+                                              post), None));\n                 let ss = cm.span_to_string(ei.call_site);\n-                try!(print_diagnostic(w, &ss[], Note, \"expansion site\", None));\n+                try!(print_diagnostic(w, &ss, Note, \"expansion site\", None));\n                 Ok(Some(ei.call_site))\n             }\n             None => Ok(None)\n@@ -646,6 +646,6 @@ pub fn expect<T, M>(diag: &SpanHandler, opt: Option<T>, msg: M) -> T where\n {\n     match opt {\n         Some(t) => t,\n-        None => diag.handler().bug(&msg()[]),\n+        None => diag.handler().bug(&msg()),\n     }\n }"}, {"sha": "b3afc3fc4dd13399d7ff542496a0850279f22e22", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -59,7 +59,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n             Some(previous_span) => {\n                 ecx.span_warn(span, &format!(\n                     \"diagnostic code {} already used\", &token::get_ident(code)\n-                )[]);\n+                ));\n                 ecx.span_note(previous_span, \"previous invocation\");\n             },\n             None => ()\n@@ -70,7 +70,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n         if !diagnostics.contains_key(&code.name) {\n             ecx.span_err(span, &format!(\n                 \"used diagnostic code {} not registered\", &token::get_ident(code)\n-            )[]);\n+            ));\n         }\n     });\n     MacExpr::new(quote_expr!(ecx, ()))\n@@ -95,12 +95,12 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n         if diagnostics.insert(code.name, description).is_some() {\n             ecx.span_err(span, &format!(\n                 \"diagnostic code {} already registered\", &token::get_ident(*code)\n-            )[]);\n+            ));\n         }\n     });\n     let sym = Ident::new(token::gensym(&(\n         \"__register_diagnostic_\".to_string() + &token::get_ident(*code)\n-    )[]));\n+    )));\n     MacItems::new(vec![quote_item!(ecx, mod $sym {}).unwrap()].into_iter())\n }\n "}, {"sha": "38098e50dee83750ef905ce8309433f51f5c021e", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -62,5 +62,5 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n     }\n     base::MacExpr::new(cx.expr_str(\n             sp,\n-            token::intern_and_get_ident(&accumulator[])))\n+            token::intern_and_get_ident(&accumulator[..])))\n }"}, {"sha": "9410a51e7a5f660a368534d275fa651d7d5e13e1", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -49,7 +49,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n             }\n         }\n     }\n-    let res = str_to_ident(&res_str[]);\n+    let res = str_to_ident(&res_str[..]);\n \n     let e = P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,"}, {"sha": "93098484ae01343de6df460a61db1d43048e0916", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -24,7 +24,7 @@ pub fn expand_deriving_bound<F>(cx: &mut ExtCtxt,\n {\n     let name = match mitem.node {\n         MetaWord(ref tname) => {\n-            match &tname[] {\n+            match &tname[..] {\n                 \"Copy\" => \"Copy\",\n                 \"Send\" | \"Sync\" => {\n                     return cx.span_err(span,"}, {"sha": "b912ed34ae0ad19c780be51cbd640736a7020053", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -536,15 +536,15 @@ impl<'a> TraitDef<'a> {\n                     self,\n                     struct_def,\n                     type_ident,\n-                    &self_args[],\n-                    &nonself_args[])\n+                    &self_args[..],\n+                    &nonself_args[..])\n             } else {\n                 method_def.expand_struct_method_body(cx,\n                                                      self,\n                                                      struct_def,\n                                                      type_ident,\n-                                                     &self_args[],\n-                                                     &nonself_args[])\n+                                                     &self_args[..],\n+                                                     &nonself_args[..])\n             };\n \n             method_def.create_method(cx,\n@@ -576,15 +576,15 @@ impl<'a> TraitDef<'a> {\n                     self,\n                     enum_def,\n                     type_ident,\n-                    &self_args[],\n-                    &nonself_args[])\n+                    &self_args[..],\n+                    &nonself_args[..])\n             } else {\n                 method_def.expand_enum_method_body(cx,\n                                                    self,\n                                                    enum_def,\n                                                    type_ident,\n                                                    self_args,\n-                                                   &nonself_args[])\n+                                                   &nonself_args[..])\n             };\n \n             method_def.create_method(cx,\n@@ -934,22 +934,22 @@ impl<'a> MethodDef<'a> {\n             .collect::<Vec<String>>();\n \n         let self_arg_idents = self_arg_names.iter()\n-            .map(|name|cx.ident_of(&name[]))\n+            .map(|name|cx.ident_of(&name[..]))\n             .collect::<Vec<ast::Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n         // a series of let statements mapping each self_arg to a usize\n         // corresponding to its variant index.\n         let vi_idents: Vec<ast::Ident> = self_arg_names.iter()\n-            .map(|name| { let vi_suffix = format!(\"{}_vi\", &name[]);\n-                          cx.ident_of(&vi_suffix[]) })\n+            .map(|name| { let vi_suffix = format!(\"{}_vi\", &name[..]);\n+                          cx.ident_of(&vi_suffix[..]) })\n             .collect::<Vec<ast::Ident>>();\n \n         // Builds, via callback to call_substructure_method, the\n         // delegated expression that handles the catch-all case,\n         // using `__variants_tuple` to drive logic if necessary.\n         let catch_all_substructure = EnumNonMatchingCollapsed(\n-            self_arg_idents, &variants[], &vi_idents[]);\n+            self_arg_idents, &variants[..], &vi_idents[..]);\n \n         // These arms are of the form:\n         // (Variant1, Variant1, ...) => Body1\n@@ -976,7 +976,7 @@ impl<'a> MethodDef<'a> {\n                     idents\n                 };\n                 for self_arg_name in self_arg_names.tail() {\n-                    let (p, idents) = mk_self_pat(cx, &self_arg_name[]);\n+                    let (p, idents) = mk_self_pat(cx, &self_arg_name[..]);\n                     subpats.push(p);\n                     self_pats_idents.push(idents);\n                 }\n@@ -1032,7 +1032,7 @@ impl<'a> MethodDef<'a> {\n                                                 &**variant,\n                                                 field_tuples);\n                 let arm_expr = self.call_substructure_method(\n-                    cx, trait_, type_ident, &self_args[], nonself_args,\n+                    cx, trait_, type_ident, &self_args[..], nonself_args,\n                     &substructure);\n \n                 cx.arm(sp, vec![single_pat], arm_expr)\n@@ -1085,7 +1085,7 @@ impl<'a> MethodDef<'a> {\n             }\n \n             let arm_expr = self.call_substructure_method(\n-                cx, trait_, type_ident, &self_args[], nonself_args,\n+                cx, trait_, type_ident, &self_args[..], nonself_args,\n                 &catch_all_substructure);\n \n             // Builds the expression:\n@@ -1391,7 +1391,7 @@ pub fn cs_fold<F>(use_foldl: bool,\n             }\n         },\n         EnumNonMatchingCollapsed(ref all_args, _, tuple) =>\n-            enum_nonmatch_f(cx, trait_span, (&all_args[], tuple),\n+            enum_nonmatch_f(cx, trait_span, (&all_args[..], tuple),\n                             substructure.nonself_args),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `derive`\")\n@@ -1431,7 +1431,7 @@ pub fn cs_same_method<F>(f: F,\n             f(cx, trait_span, called)\n         },\n         EnumNonMatchingCollapsed(ref all_self_args, _, tuple) =>\n-            enum_nonmatch_f(cx, trait_span, (&all_self_args[], tuple),\n+            enum_nonmatch_f(cx, trait_span, (&all_self_args[..], tuple),\n                             substructure.nonself_args),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `derive`\")"}, {"sha": "f8bc331bfcfe7697a13bc4a0df84e03229f57075", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -102,7 +102,7 @@ pub fn expand_meta_derive(cx: &mut ExtCtxt,\n                                                    |i| push(i)))\n                         }\n \n-                        match &tname[] {\n+                        match &tname[..] {\n                             \"Clone\" => expand!(clone::expand_deriving_clone),\n \n                             \"Hash\" => expand!(hash::expand_deriving_hash),"}, {"sha": "281f23f9e61e8b232d2c083348bdaa90b873b790", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -128,7 +128,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     let formatter = substr.nonself_args[0].clone();\n \n     let meth = cx.ident_of(\"write_fmt\");\n-    let s = token::intern_and_get_ident(&format_string[]);\n+    let s = token::intern_and_get_ident(&format_string[..]);\n     let format_string = cx.expr_str(span, s);\n \n     // phew, not our responsibility any more!"}, {"sha": "9c04d1e928295d42c387eb8d3748b1e91d301c4d", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -30,7 +30,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n         Some(v) => v\n     };\n \n-    let e = match env::var(&var[]) {\n+    let e = match env::var(&var[..]) {\n       Err(..) => {\n           cx.expr_path(cx.path_all(sp,\n                                    true,\n@@ -56,7 +56,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n                                    cx.ident_of(\"Some\")),\n                               vec!(cx.expr_str(sp,\n                                                token::intern_and_get_ident(\n-                                          &s[]))))\n+                                          &s[..]))))\n       }\n     };\n     MacExpr::new(e)\n@@ -101,7 +101,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n     }\n \n-    let e = match env::var(&var[]) {\n+    let e = match env::var(&var[..]) {\n         Err(_) => {\n             cx.span_err(sp, &msg);\n             cx.expr_usize(sp, 0)"}, {"sha": "d4dda7390a52f7788dae1cc2e2d7fcf25de6ccf0", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -405,7 +405,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                                 },\n                             });\n                         let fm = fresh_mark();\n-                        let marked_before = mark_tts(&tts[], fm);\n+                        let marked_before = mark_tts(&tts[..], fm);\n \n                         // The span that we pass to the expanders we want to\n                         // be the root of the call stack. That's the most\n@@ -416,7 +416,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                         let opt_parsed = {\n                             let expanded = expandfun.expand(fld.cx,\n                                                             mac_span,\n-                                                            &marked_before[]);\n+                                                            &marked_before[..]);\n                             parse_thunk(expanded)\n                         };\n                         let parsed = match opt_parsed {\n@@ -425,7 +425,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                                 fld.cx.span_err(\n                                     pth.span,\n                                     &format!(\"non-expression macro in expression position: {}\",\n-                                            &extnamestr[]\n+                                            &extnamestr[..]\n                                             )[]);\n                                 return None;\n                             }\n@@ -633,8 +633,8 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                         }\n                     });\n                     // mark before expansion:\n-                    let marked_before = mark_tts(&tts[], fm);\n-                    expander.expand(fld.cx, it.span, &marked_before[])\n+                    let marked_before = mark_tts(&tts[..], fm);\n+                    expander.expand(fld.cx, it.span, &marked_before[..])\n                 }\n                 IdentTT(ref expander, span) => {\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n@@ -652,7 +652,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                         }\n                     });\n                     // mark before expansion:\n-                    let marked_tts = mark_tts(&tts[], fm);\n+                    let marked_tts = mark_tts(&tts[..], fm);\n                     expander.expand(fld.cx, it.span, it.ident, marked_tts)\n                 }\n                 MacroRulesTT => {\n@@ -971,11 +971,11 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                     });\n \n                     let fm = fresh_mark();\n-                    let marked_before = mark_tts(&tts[], fm);\n+                    let marked_before = mark_tts(&tts[..], fm);\n                     let mac_span = fld.cx.original_span();\n                     let expanded = match expander.expand(fld.cx,\n                                         mac_span,\n-                                        &marked_before[]).make_pat() {\n+                                        &marked_before[..]).make_pat() {\n                         Some(e) => e,\n                         None => {\n                             fld.cx.span_err(\n@@ -1128,7 +1128,7 @@ fn expand_annotatable(a: Annotatable,\n                 if valid_ident {\n                     fld.cx.mod_push(it.ident);\n                 }\n-                let macro_use = contains_macro_use(fld, &new_attrs[]);\n+                let macro_use = contains_macro_use(fld, &new_attrs[..]);\n                 let result = with_exts_frame!(fld.cx.syntax_env,\n                                               macro_use,\n                                               noop_fold_item(it, fld));\n@@ -1508,7 +1508,7 @@ impl Folder for Marker {\n             node: match node {\n                 MacInvocTT(path, tts, ctxt) => {\n                     MacInvocTT(self.fold_path(path),\n-                               self.fold_tts(&tts[]),\n+                               self.fold_tts(&tts[..]),\n                                mtwt::apply_mark(self.mark, ctxt))\n                 }\n             },\n@@ -1914,7 +1914,7 @@ mod test {\n                         .collect();\n                     println!(\"varref #{}: {:?}, resolves to {}\",idx, varref_idents, varref_name);\n                     let string = token::get_ident(final_varref_ident);\n-                    println!(\"varref's first segment's string: \\\"{}\\\"\", &string[]);\n+                    println!(\"varref's first segment's string: \\\"{}\\\"\", &string[..]);\n                     println!(\"binding #{}: {}, resolves to {}\",\n                              binding_idx, bindings[binding_idx], binding_name);\n                     mtwt::with_sctable(|x| mtwt::display_sctable(x));\n@@ -1967,10 +1967,10 @@ foo_module!();\n         let cxbinds: Vec<&ast::Ident> =\n             bindings.iter().filter(|b| {\n                 let ident = token::get_ident(**b);\n-                let string = &ident[];\n+                let string = &ident[..];\n                 \"xx\" == string\n             }).collect();\n-        let cxbinds: &[&ast::Ident] = &cxbinds[];\n+        let cxbinds: &[&ast::Ident] = &cxbinds[..];\n         let cxbind = match cxbinds {\n             [b] => b,\n             _ => panic!(\"expected just one binding for ext_cx\")"}, {"sha": "e17329d7d33002b96f85c9060a1962a82330b7fe", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -118,7 +118,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 }\n             };\n             let interned_name = token::get_ident(ident);\n-            let name = &interned_name[];\n+            let name = &interned_name[..];\n \n             p.expect(&token::Eq);\n             let e = p.parse_expr();\n@@ -218,7 +218,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     let msg = format!(\"invalid reference to argument `{}` ({})\",\n                                       arg, self.describe_num_args());\n \n-                    self.ecx.span_err(self.fmtsp, &msg[]);\n+                    self.ecx.span_err(self.fmtsp, &msg[..]);\n                     return;\n                 }\n                 {\n@@ -238,7 +238,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     Some(e) => e.span,\n                     None => {\n                         let msg = format!(\"there is no argument named `{}`\", name);\n-                        self.ecx.span_err(self.fmtsp, &msg[]);\n+                        self.ecx.span_err(self.fmtsp, &msg[..]);\n                         return;\n                     }\n                 };\n@@ -587,7 +587,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                   -> P<ast::Expr> {\n         let trait_ = match *ty {\n             Known(ref tyname) => {\n-                match &tyname[] {\n+                match &tyname[..] {\n                     \"\"  => \"Display\",\n                     \"?\" => \"Debug\",\n                     \"e\" => \"LowerExp\","}, {"sha": "2c7bf713aad85d67728d2abaddaa95906c5e9dac", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -668,7 +668,7 @@ fn mk_tt(cx: &ExtCtxt, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n             for i in 0..tt.len() {\n                 seq.push(tt.get_tt(i));\n             }\n-            mk_tts(cx, &seq[])\n+            mk_tts(cx, &seq[..])\n         }\n         ast::TtToken(sp, ref tok) => {\n             let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n@@ -757,7 +757,7 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let stmt_let_tt = cx.stmt_let(sp, true, id_ext(\"tt\"), cx.expr_vec_ng(sp));\n \n     let mut vector = vec!(stmt_let_sp, stmt_let_tt);\n-    vector.extend(mk_tts(cx, &tts[]).into_iter());\n+    vector.extend(mk_tts(cx, &tts[..]).into_iter());\n     let block = cx.expr_block(\n         cx.block_all(sp,\n                      vector,"}, {"sha": "22fac22c9cc5213717fee9ce30774a85a9355ff6", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -65,7 +65,7 @@ pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                         -> Box<base::MacResult+'static> {\n     let s = pprust::tts_to_string(tts);\n     base::MacExpr::new(cx.expr_str(sp,\n-                                   token::intern_and_get_ident(&s[])))\n+                                   token::intern_and_get_ident(&s[..])))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n@@ -78,7 +78,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                    .connect(\"::\");\n     base::MacExpr::new(cx.expr_str(\n             sp,\n-            token::intern_and_get_ident(&string[])))\n+            token::intern_and_get_ident(&string[..])))\n }\n \n /// include! : parse the given file as an expr\n@@ -151,7 +151,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             // Add this input file to the code map to make it available as\n             // dependency information\n             let filename = format!(\"{}\", file.display());\n-            let interned = token::intern_and_get_ident(&src[]);\n+            let interned = token::intern_and_get_ident(&src[..]);\n             cx.codemap().new_filemap(filename, src);\n \n             base::MacExpr::new(cx.expr_str(sp, interned))"}, {"sha": "dca734e1f5e8970c157446ad646ec67bbe113973", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -165,7 +165,7 @@ pub fn count_names(ms: &[TokenTree]) -> usize {\n \n pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: BytePos)\n                            -> Box<MatcherPos> {\n-    let match_idx_hi = count_names(&ms[]);\n+    let match_idx_hi = count_names(&ms[..]);\n     let matches: Vec<_> = (0..match_idx_hi).map(|_| Vec::new()).collect();\n     box MatcherPos {\n         stack: vec![],\n@@ -254,13 +254,13 @@ pub fn parse_or_else(sess: &ParseSess,\n                      rdr: TtReader,\n                      ms: Vec<TokenTree> )\n                      -> HashMap<Ident, Rc<NamedMatch>> {\n-    match parse(sess, cfg, rdr, &ms[]) {\n+    match parse(sess, cfg, rdr, &ms[..]) {\n         Success(m) => m,\n         Failure(sp, str) => {\n-            sess.span_diagnostic.span_fatal(sp, &str[])\n+            sess.span_diagnostic.span_fatal(sp, &str[..])\n         }\n         Error(sp, str) => {\n-            sess.span_diagnostic.span_fatal(sp, &str[])\n+            sess.span_diagnostic.span_fatal(sp, &str[..])\n         }\n     }\n }\n@@ -447,7 +447,7 @@ pub fn parse(sess: &ParseSess,\n                 for dv in &mut (&mut eof_eis[0]).matches {\n                     v.push(dv.pop().unwrap());\n                 }\n-                return Success(nameize(sess, ms, &v[]));\n+                return Success(nameize(sess, ms, &v[..]));\n             } else if eof_eis.len() > 1 {\n                 return Error(sp, \"ambiguity: multiple successful parses\".to_string());\n             } else {\n@@ -533,7 +533,7 @@ pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n         _ => {\n             let token_str = pprust::token_to_string(&p.token);\n             p.fatal(&format!(\"expected ident, found {}\",\n-                             &token_str[])[])\n+                             &token_str[..])[])\n         }\n       },\n       \"path\" => {"}, {"sha": "624cb9ddf4256f345931ce665b09caceaeb75147", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -50,7 +50,7 @@ impl<'a> ParserAnyMacro<'a> {\n                                following\",\n                               token_str);\n             let span = parser.span;\n-            parser.span_err(span, &msg[]);\n+            parser.span_err(span, &msg[..]);\n         }\n     }\n }\n@@ -192,13 +192,13 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 best_fail_spot = sp;\n                 best_fail_msg = (*msg).clone();\n               },\n-              Error(sp, ref msg) => cx.span_fatal(sp, &msg[])\n+              Error(sp, ref msg) => cx.span_fatal(sp, &msg[..])\n             }\n           }\n           _ => cx.bug(\"non-matcher found in parsed lhses\")\n         }\n     }\n-    cx.span_fatal(best_fail_spot, &best_fail_msg[]);\n+    cx.span_fatal(best_fail_spot, &best_fail_msg[..]);\n }\n \n // Note that macro-by-example's input is also matched against a token tree:"}, {"sha": "17016f3ac11794519cf240f60d929fc7a595b84b", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -255,7 +255,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                     }\n                     LisContradiction(ref msg) => {\n                         // FIXME #2887 blame macro invoker instead\n-                        r.sp_diag.span_fatal(sp.clone(), &msg[]);\n+                        r.sp_diag.span_fatal(sp.clone(), &msg[..]);\n                     }\n                     LisConstraint(len, _) => {\n                         if len == 0 {"}, {"sha": "071158fcebb5cf32da776b2e98394450dbf47108", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -356,15 +356,15 @@ pub fn emit_feature_err(diag: &SpanHandler, feature: &str, span: Span, explain:\n     diag.span_err(span, explain);\n     diag.span_help(span, &format!(\"add #![feature({})] to the \\\n                                    crate attributes to enable\",\n-                                  feature)[]);\n+                                  feature));\n }\n \n pub fn emit_feature_warn(diag: &SpanHandler, feature: &str, span: Span, explain: &str) {\n     diag.span_warn(span, explain);\n     if diag.handler.can_emit_warnings {\n         diag.span_help(span, &format!(\"add #![feature({})] to the \\\n                                        crate attributes to silence this warning\",\n-                                      feature)[]);\n+                                      feature));\n     }\n }\n \n@@ -438,15 +438,15 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     fn visit_item(&mut self, i: &ast::Item) {\n         match i.node {\n             ast::ItemExternCrate(_) => {\n-                if attr::contains_name(&i.attrs[], \"macro_reexport\") {\n+                if attr::contains_name(&i.attrs[..], \"macro_reexport\") {\n                     self.gate_feature(\"macro_reexport\", i.span,\n                                       \"macros reexports are experimental \\\n                                        and possibly buggy\");\n                 }\n             }\n \n             ast::ItemForeignMod(ref foreign_module) => {\n-                if attr::contains_name(&i.attrs[], \"link_args\") {\n+                if attr::contains_name(&i.attrs[..], \"link_args\") {\n                     self.gate_feature(\"link_args\", i.span,\n                                       \"the `link_args` attribute is not portable \\\n                                        across platforms, it is recommended to \\\n@@ -460,17 +460,17 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemFn(..) => {\n-                if attr::contains_name(&i.attrs[], \"plugin_registrar\") {\n+                if attr::contains_name(&i.attrs[..], \"plugin_registrar\") {\n                     self.gate_feature(\"plugin_registrar\", i.span,\n                                       \"compiler plugins are experimental and possibly buggy\");\n                 }\n-                if attr::contains_name(&i.attrs[], \"start\") {\n+                if attr::contains_name(&i.attrs[..], \"start\") {\n                     self.gate_feature(\"start\", i.span,\n                                       \"a #[start] function is an experimental \\\n                                        feature whose signature may change \\\n                                        over time\");\n                 }\n-                if attr::contains_name(&i.attrs[], \"main\") {\n+                if attr::contains_name(&i.attrs[..], \"main\") {\n                     self.gate_feature(\"main\", i.span,\n                                       \"declaration of a nonstandard #[main] \\\n                                        function may change over time, for now \\\n@@ -479,7 +479,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemStruct(..) => {\n-                if attr::contains_name(&i.attrs[], \"simd\") {\n+                if attr::contains_name(&i.attrs[..], \"simd\") {\n                     self.gate_feature(\"simd\", i.span,\n                                       \"SIMD types are experimental and possibly buggy\");\n                 }\n@@ -505,15 +505,15 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                        removed in the future\");\n                 }\n \n-                if attr::contains_name(&i.attrs[],\n+                if attr::contains_name(&i.attrs[..],\n                                        \"old_orphan_check\") {\n                     self.gate_feature(\n                         \"old_orphan_check\",\n                         i.span,\n                         \"the new orphan check rules will eventually be strictly enforced\");\n                 }\n \n-                if attr::contains_name(&i.attrs[],\n+                if attr::contains_name(&i.attrs[..],\n                                        \"old_impl_check\") {\n                     self.gate_feature(\"old_impl_check\",\n                                       i.span,\n@@ -528,7 +528,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n-        if attr::contains_name(&i.attrs[], \"linkage\") {\n+        if attr::contains_name(&i.attrs, \"linkage\") {\n             self.gate_feature(\"linkage\", i.span,\n                               \"the `linkage` attribute is experimental \\\n                                and not portable across platforms\")"}, {"sha": "1f06db600278b4162c807fcc83d8f36bae593d2d", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -187,7 +187,7 @@ fn read_line_comments(rdr: &mut StringReader, code_to_the_left: bool,\n         let line = rdr.read_one_line_comment();\n         debug!(\"{}\", line);\n         // Doc comments are not put in comments.\n-        if is_doc_comment(&line[]) {\n+        if is_doc_comment(&line[..]) {\n             break;\n         }\n         lines.push(line);\n@@ -224,7 +224,7 @@ fn all_whitespace(s: &str, col: CharPos) -> Option<usize> {\n fn trim_whitespace_prefix_and_push_line(lines: &mut Vec<String> ,\n                                         s: String, col: CharPos) {\n     let len = s.len();\n-    let s1 = match all_whitespace(&s[], col) {\n+    let s1 = match all_whitespace(&s[..], col) {\n         Some(col) => {\n             if col < len {\n                 (&s[col..len]).to_string()\n@@ -261,7 +261,7 @@ fn read_block_comment(rdr: &mut StringReader,\n             rdr.bump();\n             rdr.bump();\n         }\n-        if is_block_doc_comment(&curr_line[]) {\n+        if is_block_doc_comment(&curr_line[..]) {\n             return\n         }\n         assert!(!curr_line.contains_char('\\n'));"}, {"sha": "cca641a7852f45b84ace9f609fbe760563c2a840", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -196,7 +196,7 @@ impl<'a> StringReader<'a> {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n         for c in c.escape_default() { m.push(c) }\n-        self.fatal_span_(from_pos, to_pos, &m[]);\n+        self.fatal_span_(from_pos, to_pos, &m[..]);\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n@@ -205,7 +205,7 @@ impl<'a> StringReader<'a> {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n         for c in c.escape_default() { m.push(c) }\n-        self.err_span_(from_pos, to_pos, &m[]);\n+        self.err_span_(from_pos, to_pos, &m[..]);\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending the\n@@ -215,7 +215,7 @@ impl<'a> StringReader<'a> {\n         let from = self.byte_offset(from_pos).to_usize();\n         let to = self.byte_offset(to_pos).to_usize();\n         m.push_str(&self.filemap.src[from..to]);\n-        self.fatal_span_(from_pos, to_pos, &m[]);\n+        self.fatal_span_(from_pos, to_pos, &m[..]);\n     }\n \n     /// Advance peek_tok and peek_span to refer to the next token, and\n@@ -556,7 +556,7 @@ impl<'a> StringReader<'a> {\n                     self.translate_crlf(start_bpos, string,\n                                         \"bare CR not allowed in block doc-comment\")\n                 } else { string.into_cow() };\n-                token::DocComment(token::intern(&string[]))\n+                token::DocComment(token::intern(&string[..]))\n             } else {\n                 token::Comment\n             };"}, {"sha": "7ed48bdbb928dc9ace647ea772f902f3c1228e96", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -258,7 +258,7 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n             unreachable!()\n         }\n     };\n-    match str::from_utf8(&bytes[]).ok() {\n+    match str::from_utf8(&bytes[..]).ok() {\n         Some(s) => {\n             return string_to_filemap(sess, s.to_string(),\n                                      path.as_str().unwrap().to_string())\n@@ -398,7 +398,7 @@ pub fn char_lit(lit: &str) -> (char, isize) {\n     }\n \n     let msg = format!(\"lexer should have rejected a bad character escape {}\", lit);\n-    let msg2 = &msg[];\n+    let msg2 = &msg[..];\n \n     fn esc(len: usize, lit: &str) -> Option<(char, isize)> {\n         num::from_str_radix(&lit[2..len], 16).ok()\n@@ -662,7 +662,7 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     // s can only be ascii, byte indexing is fine\n \n     let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n-    let mut s = &s2[];\n+    let mut s = &s2[..];\n \n     debug!(\"integer_lit: {}, {:?}\", s, suffix);\n \n@@ -819,7 +819,7 @@ mod test {\n     #[test]\n     fn string_to_tts_macro () {\n         let tts = string_to_tts(\"macro_rules! zip (($a)=>($a))\".to_string());\n-        let tts: &[ast::TokenTree] = &tts[];\n+        let tts: &[ast::TokenTree] = &tts[..];\n         match tts {\n             [ast::TtToken(_, token::Ident(name_macro_rules, token::Plain)),\n              ast::TtToken(_, token::Not),\n@@ -1114,24 +1114,24 @@ mod test {\n         let use_s = \"use foo::bar::baz;\";\n         let vitem = string_to_item(use_s.to_string()).unwrap();\n         let vitem_s = item_to_string(&*vitem);\n-        assert_eq!(&vitem_s[], use_s);\n+        assert_eq!(&vitem_s[..], use_s);\n \n         let use_s = \"use foo::bar as baz;\";\n         let vitem = string_to_item(use_s.to_string()).unwrap();\n         let vitem_s = item_to_string(&*vitem);\n-        assert_eq!(&vitem_s[], use_s);\n+        assert_eq!(&vitem_s[..], use_s);\n     }\n \n     #[test] fn parse_extern_crate() {\n         let ex_s = \"extern crate foo;\";\n         let vitem = string_to_item(ex_s.to_string()).unwrap();\n         let vitem_s = item_to_string(&*vitem);\n-        assert_eq!(&vitem_s[], ex_s);\n+        assert_eq!(&vitem_s[..], ex_s);\n \n         let ex_s = \"extern crate \\\"foo\\\" as bar;\";\n         let vitem = string_to_item(ex_s.to_string()).unwrap();\n         let vitem_s = item_to_string(&*vitem);\n-        assert_eq!(&vitem_s[], ex_s);\n+        assert_eq!(&vitem_s[..], ex_s);\n     }\n \n     fn get_spans_of_pat_idents(src: &str) -> Vec<Span> {\n@@ -1203,19 +1203,19 @@ mod test {\n         let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess).unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n-        assert_eq!(&doc[], \"/// doc comment\");\n+        assert_eq!(&doc[..], \"/// doc comment\");\n \n         let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess).unwrap();\n         let docs = item.attrs.iter().filter(|a| &a.name()[] == \"doc\")\n                     .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n-        assert_eq!(&docs[], b);\n+        assert_eq!(&docs[..], b);\n \n         let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name, source, Vec::new(), &sess).unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n-        assert_eq!(&doc[], \"/** doc comment\\n *  with CRLF */\");\n+        assert_eq!(&doc[..], \"/** doc comment\\n *  with CRLF */\");\n     }\n \n     #[test]\n@@ -1235,7 +1235,7 @@ mod test {\n         let span = tts.iter().rev().next().unwrap().get_span();\n \n         match sess.span_diagnostic.cm.span_to_snippet(span) {\n-            Ok(s) => assert_eq!(&s[], \"{ body }\"),\n+            Ok(s) => assert_eq!(&s[..], \"{ body }\"),\n             Err(_) => panic!(\"could not get snippet\"),\n         }\n     }"}, {"sha": "8480772ce6c1ad1b7c1528031800a9bafb06327f", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -28,6 +28,7 @@ pub enum ObsoleteSyntax {\n     ProcExpr,\n     ClosureType,\n     ClosureKind,\n+    EmptyIndex,\n }\n \n pub trait ParserObsoleteMethods {\n@@ -40,43 +41,55 @@ pub trait ParserObsoleteMethods {\n               sp: Span,\n               kind: ObsoleteSyntax,\n               kind_str: &str,\n-              desc: &str);\n+              desc: &str,\n+              error: bool);\n     fn is_obsolete_ident(&mut self, ident: &str) -> bool;\n     fn eat_obsolete_ident(&mut self, ident: &str) -> bool;\n }\n \n impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n     /// Reports an obsolete syntax non-fatal error.\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax) {\n-        let (kind_str, desc) = match kind {\n+        let (kind_str, desc, error) = match kind {\n             ObsoleteSyntax::ForSized => (\n                 \"for Sized?\",\n                 \"no longer required. Traits (and their `Self` type) do not have the `Sized` bound \\\n                  by default\",\n+                true,\n             ),\n             ObsoleteSyntax::ProcType => (\n                 \"the `proc` type\",\n                 \"use unboxed closures instead\",\n+                true,\n             ),\n             ObsoleteSyntax::ProcExpr => (\n                 \"`proc` expression\",\n                 \"use a `move ||` expression instead\",\n+                true,\n             ),\n             ObsoleteSyntax::ClosureType => (\n                 \"`|usize| -> bool` closure type\",\n-                \"use unboxed closures instead, no type annotation needed\"\n+                \"use unboxed closures instead, no type annotation needed\",\n+                true,\n             ),\n             ObsoleteSyntax::ClosureKind => (\n                 \"`:`, `&mut:`, or `&:`\",\n-                \"rely on inference instead\"\n+                \"rely on inference instead\",\n+                true,\n             ),\n             ObsoleteSyntax::Sized => (\n                 \"`Sized? T` for removing the `Sized` bound\",\n-                \"write `T: ?Sized` instead\"\n+                \"write `T: ?Sized` instead\",\n+                true,\n+            ),\n+            ObsoleteSyntax::EmptyIndex => (\n+                \"[]\",\n+                \"write `[..]` instead\",\n+                false, // warning for now\n             ),\n         };\n \n-        self.report(sp, kind, kind_str, desc);\n+        self.report(sp, kind, kind_str, desc, error);\n     }\n \n     /// Reports an obsolete syntax non-fatal error, and returns\n@@ -90,9 +103,13 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n               sp: Span,\n               kind: ObsoleteSyntax,\n               kind_str: &str,\n-              desc: &str) {\n-        self.span_err(sp,\n-                      &format!(\"obsolete syntax: {}\", kind_str)[]);\n+              desc: &str,\n+              error: bool) {\n+        if error {\n+            self.span_err(sp, &format!(\"obsolete syntax: {}\", kind_str)[]);\n+        } else {\n+            self.span_warn(sp, &format!(\"obsolete syntax: {}\", kind_str)[]);\n+        }\n \n         if !self.obsolete_set.contains(&kind) {\n             self.sess"}, {"sha": "e272c770cb7a3ec6e156c42eba52099eb8c1d346", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -361,7 +361,7 @@ impl<'a> Parser<'a> {\n         let token_str = Parser::token_to_string(t);\n         let last_span = self.last_span;\n         self.span_fatal(last_span, &format!(\"unexpected token: `{}`\",\n-                                                token_str)[]);\n+                                                token_str));\n     }\n \n     pub fn unexpected(&mut self) -> ! {\n@@ -380,7 +380,7 @@ impl<'a> Parser<'a> {\n                 let this_token_str = self.this_token_to_string();\n                 self.fatal(&format!(\"expected `{}`, found `{}`\",\n                                    token_str,\n-                                   this_token_str)[])\n+                                   this_token_str))\n             }\n         } else {\n             self.expect_one_of(slice::ref_slice(t), &[]);\n@@ -421,7 +421,7 @@ impl<'a> Parser<'a> {\n             expected.push_all(&*self.expected_tokens);\n             expected.sort_by(|a, b| a.to_string().cmp(&b.to_string()));\n             expected.dedup();\n-            let expect = tokens_to_string(&expected[]);\n+            let expect = tokens_to_string(&expected[..]);\n             let actual = self.this_token_to_string();\n             self.fatal(\n                 &(if expected.len() > 1 {\n@@ -435,7 +435,7 @@ impl<'a> Parser<'a> {\n                     (format!(\"expected {}, found `{}`\",\n                              expect,\n                              actual))\n-                }[])\n+                })[..]\n             )\n         }\n     }\n@@ -468,7 +468,7 @@ impl<'a> Parser<'a> {\n             // might be unit-struct construction; check for recoverableinput error.\n             let mut expected = edible.iter().cloned().collect::<Vec<_>>();\n             expected.push_all(inedible);\n-            self.check_for_erroneous_unit_struct_expecting(&expected[]);\n+            self.check_for_erroneous_unit_struct_expecting(&expected[..]);\n         }\n         self.expect_one_of(edible, inedible)\n     }\n@@ -485,9 +485,8 @@ impl<'a> Parser<'a> {\n                .as_ref()\n                .map_or(false, |t| t.is_ident() || t.is_path()) {\n             let mut expected = edible.iter().cloned().collect::<Vec<_>>();\n-            expected.push_all(&inedible[]);\n-            self.check_for_erroneous_unit_struct_expecting(\n-                &expected[]);\n+            expected.push_all(&inedible);\n+            self.check_for_erroneous_unit_struct_expecting(&expected);\n         }\n         self.expect_one_of(edible, inedible)\n     }\n@@ -510,7 +509,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 let token_str = self.this_token_to_string();\n                 self.fatal(&format!(\"expected ident, found `{}`\",\n-                                    token_str)[])\n+                                    token_str))\n             }\n         }\n     }\n@@ -598,7 +597,7 @@ impl<'a> Parser<'a> {\n             let span = self.span;\n             self.span_err(span,\n                           &format!(\"expected identifier, found keyword `{}`\",\n-                                  token_str)[]);\n+                                  token_str));\n         }\n     }\n \n@@ -607,7 +606,7 @@ impl<'a> Parser<'a> {\n         if self.token.is_reserved_keyword() {\n             let token_str = self.this_token_to_string();\n             self.fatal(&format!(\"`{}` is a reserved keyword\",\n-                               token_str)[])\n+                               token_str))\n         }\n     }\n \n@@ -733,7 +732,7 @@ impl<'a> Parser<'a> {\n                 let this_token_str = self.this_token_to_string();\n                 self.fatal(&format!(\"expected `{}`, found `{}`\",\n                                    gt_str,\n-                                   this_token_str)[])\n+                                   this_token_str))\n             }\n         }\n     }\n@@ -1363,7 +1362,7 @@ impl<'a> Parser<'a> {\n                     let (inner_attrs, body) =\n                         p.parse_inner_attrs_and_block();\n                     let mut attrs = attrs;\n-                    attrs.push_all(&inner_attrs[]);\n+                    attrs.push_all(&inner_attrs[..]);\n                     ProvidedMethod(P(ast::Method {\n                         attrs: attrs,\n                         id: ast::DUMMY_NODE_ID,\n@@ -1382,7 +1381,7 @@ impl<'a> Parser<'a> {\n                   _ => {\n                       let token_str = p.this_token_to_string();\n                       p.fatal(&format!(\"expected `;` or `{{`, found `{}`\",\n-                                       token_str)[])\n+                                       token_str)[..])\n                   }\n                 }\n             }\n@@ -1550,7 +1549,7 @@ impl<'a> Parser<'a> {\n         } else {\n             let this_token_str = self.this_token_to_string();\n             let msg = format!(\"expected type, found `{}`\", this_token_str);\n-            self.fatal(&msg[]);\n+            self.fatal(&msg[..]);\n         };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n@@ -1698,7 +1697,7 @@ impl<'a> Parser<'a> {\n                     token::StrRaw(s, n) => {\n                         (true,\n                          LitStr(\n-                            token::intern_and_get_ident(&parse::raw_str_lit(s.as_str())[]),\n+                            token::intern_and_get_ident(&parse::raw_str_lit(s.as_str())),\n                             ast::RawStr(n)))\n                     }\n                     token::Binary(i) =>\n@@ -1943,7 +1942,7 @@ impl<'a> Parser<'a> {\n                 };\n             }\n             _ => {\n-                self.fatal(&format!(\"expected a lifetime name\")[]);\n+                self.fatal(&format!(\"expected a lifetime name\"));\n             }\n         }\n     }\n@@ -1981,7 +1980,7 @@ impl<'a> Parser<'a> {\n                     let msg = format!(\"expected `,` or `>` after lifetime \\\n                                       name, found `{}`\",\n                                       this_token_str);\n-                    self.fatal(&msg[]);\n+                    self.fatal(&msg[..]);\n                 }\n             }\n         }\n@@ -2496,7 +2495,7 @@ impl<'a> Parser<'a> {\n                     let last_span = self.last_span;\n                     let fstr = n.as_str();\n                     self.span_err(last_span,\n-                                  &format!(\"unexpected token: `{}`\", n.as_str())[]);\n+                                  &format!(\"unexpected token: `{}`\", n.as_str()));\n                     if fstr.chars().all(|x| \"0123456789.\".contains_char(x)) {\n                         let float = match fstr.parse::<f64>().ok() {\n                             Some(f) => f,\n@@ -2505,7 +2504,7 @@ impl<'a> Parser<'a> {\n                         self.span_help(last_span,\n                             &format!(\"try parenthesizing the first index; e.g., `(foo.{}){}`\",\n                                     float.trunc() as usize,\n-                                    &float.fract().to_string()[1..])[]);\n+                                    &float.fract().to_string()[1..]));\n                     }\n                     self.abort_if_errors();\n \n@@ -2551,8 +2550,9 @@ impl<'a> Parser<'a> {\n                             parameters: ast::PathParameters::none(),\n                         }\n                     }).collect();\n+                    let span = mk_sp(lo, hi);\n                     let path = ast::Path {\n-                        span: mk_sp(lo, hi),\n+                        span: span,\n                         global: true,\n                         segments: segments,\n                     };\n@@ -2561,10 +2561,8 @@ impl<'a> Parser<'a> {\n                     let ix = self.mk_expr(bracket_pos, hi, range);\n                     let index = self.mk_index(e, ix);\n                     e = self.mk_expr(lo, hi, index);\n-                    // Enable after snapshot.\n-                    // self.span_warn(e.span, \"deprecated slicing syntax: `[]`\");\n-                    // self.span_note(e.span,\n-                    //               \"use `&expr[..]` to construct a slice of the whole of expr\");\n+\n+                    self.obsolete(span, ObsoleteSyntax::EmptyIndex);\n                 } else {\n                     let ix = self.parse_expr();\n                     hi = self.span.hi;\n@@ -2638,7 +2636,7 @@ impl<'a> Parser<'a> {\n             match self.token {\n                 token::SubstNt(name, _) =>\n                     self.fatal(&format!(\"unknown macro variable `{}`\",\n-                                       token::get_ident(name))[]),\n+                                       token::get_ident(name))),\n                 _ => {}\n             }\n         }\n@@ -2700,7 +2698,7 @@ impl<'a> Parser<'a> {\n                     };\n                     let token_str = p.this_token_to_string();\n                     p.fatal(&format!(\"incorrect close delimiter: `{}`\",\n-                                    token_str)[])\n+                                    token_str))\n                 },\n                 /* we ought to allow different depths of unquotation */\n                 token::Dollar | token::SubstNt(..) if p.quote_depth > 0 => {\n@@ -2821,7 +2819,7 @@ impl<'a> Parser<'a> {\n                         let this_token_to_string = self.this_token_to_string();\n                         self.span_err(span,\n                                       &format!(\"expected expression, found `{}`\",\n-                                              this_token_to_string)[]);\n+                                              this_token_to_string));\n                         let box_span = mk_sp(lo, self.last_span.hi);\n                         self.span_help(box_span,\n                                        \"perhaps you meant `box() (foo)` instead?\");\n@@ -3274,7 +3272,7 @@ impl<'a> Parser<'a> {\n                 if self.token != token::CloseDelim(token::Brace) {\n                     let token_str = self.this_token_to_string();\n                     self.fatal(&format!(\"expected `{}`, found `{}`\", \"}\",\n-                                       token_str)[])\n+                                       token_str))\n                 }\n                 etc = true;\n                 break;\n@@ -3575,7 +3573,7 @@ impl<'a> Parser<'a> {\n             let span = self.span;\n             let tok_str = self.this_token_to_string();\n             self.span_fatal(span,\n-                            &format!(\"expected identifier, found `{}`\", tok_str)[]);\n+                            &format!(\"expected identifier, found `{}`\", tok_str));\n         }\n         let ident = self.parse_ident();\n         let last_span = self.last_span;\n@@ -3672,7 +3670,7 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n         if self.check_keyword(keywords::Let) {\n-            check_expected_item(self, &item_attrs[]);\n+            check_expected_item(self, &item_attrs[..]);\n             self.expect_keyword(keywords::Let);\n             let decl = self.parse_let();\n             P(spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID)))\n@@ -3681,7 +3679,7 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(1, |t| *t == token::Not) {\n             // it's a macro invocation:\n \n-            check_expected_item(self, &item_attrs[]);\n+            check_expected_item(self, &item_attrs[..]);\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n@@ -3709,7 +3707,7 @@ impl<'a> Parser<'a> {\n                     let tok_str = self.this_token_to_string();\n                     self.fatal(&format!(\"expected {}`(` or `{{`, found `{}`\",\n                                        ident_str,\n-                                       tok_str)[])\n+                                       tok_str))\n                 },\n             };\n \n@@ -3757,7 +3755,7 @@ impl<'a> Parser<'a> {\n             }\n         } else {\n             let found_attrs = !item_attrs.is_empty();\n-            let item_err = Parser::expected_item_err(&item_attrs[]);\n+            let item_err = Parser::expected_item_err(&item_attrs[..]);\n             match self.parse_item_(item_attrs, false) {\n                 Ok(i) => {\n                     let hi = i.span.hi;\n@@ -3794,7 +3792,7 @@ impl<'a> Parser<'a> {\n             let sp = self.span;\n             let tok = self.this_token_to_string();\n             self.span_fatal_help(sp,\n-                                 &format!(\"expected `{{`, found `{}`\", tok)[],\n+                                 &format!(\"expected `{{`, found `{}`\", tok),\n                                  \"place this code inside a block\");\n         }\n \n@@ -3829,13 +3827,13 @@ impl<'a> Parser<'a> {\n         while self.token != token::CloseDelim(token::Brace) {\n             // parsing items even when they're not allowed lets us give\n             // better error messages and recover more gracefully.\n-            attributes_box.push_all(&self.parse_outer_attributes()[]);\n+            attributes_box.push_all(&self.parse_outer_attributes());\n             match self.token {\n                 token::Semi => {\n                     if !attributes_box.is_empty() {\n                         let last_span = self.last_span;\n                         self.span_err(last_span,\n-                                      Parser::expected_item_err(&attributes_box[]));\n+                                      Parser::expected_item_err(&attributes_box[..]));\n                         attributes_box = Vec::new();\n                     }\n                     self.bump(); // empty\n@@ -3927,7 +3925,7 @@ impl<'a> Parser<'a> {\n         if !attributes_box.is_empty() {\n             let last_span = self.last_span;\n             self.span_err(last_span,\n-                          Parser::expected_item_err(&attributes_box[]));\n+                          Parser::expected_item_err(&attributes_box[..]));\n         }\n \n         let hi = self.span.hi;\n@@ -4382,7 +4380,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 let token_str = self.this_token_to_string();\n                 self.fatal(&format!(\"expected `self`, found `{}`\",\n-                                   token_str)[])\n+                                   token_str))\n             }\n         }\n     }\n@@ -4711,7 +4709,7 @@ impl<'a> Parser<'a> {\n                 let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n                 let body_span = body.span;\n                 let mut new_attrs = attrs;\n-                new_attrs.push_all(&inner_attrs[]);\n+                new_attrs.push_all(&inner_attrs[..]);\n                 (ast::MethDecl(ident,\n                                generics,\n                                abi,\n@@ -5123,7 +5121,7 @@ impl<'a> Parser<'a> {\n             // We parsed attributes for the first item but didn't find it\n             let last_span = self.last_span;\n             self.span_err(last_span,\n-                          Parser::expected_item_err(&attrs[]));\n+                          Parser::expected_item_err(&attrs[..]));\n         }\n \n         ast::Mod {\n@@ -5202,8 +5200,8 @@ impl<'a> Parser<'a> {\n                 let mod_name = mod_string.to_string();\n                 let default_path_str = format!(\"{}.rs\", mod_name);\n                 let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n-                let default_path = dir_path.join(&default_path_str[]);\n-                let secondary_path = dir_path.join(&secondary_path_str[]);\n+                let default_path = dir_path.join(&default_path_str[..]);\n+                let secondary_path = dir_path.join(&secondary_path_str[..]);\n                 let default_exists = default_path.exists();\n                 let secondary_exists = secondary_path.exists();\n \n@@ -5275,7 +5273,7 @@ impl<'a> Parser<'a> {\n                     err.push_str(\" -> \");\n                 }\n                 err.push_str(&path.display().as_cow()[]);\n-                self.span_fatal(id_sp, &err[]);\n+                self.span_fatal(id_sp, &err[..]);\n             }\n             None => ()\n         }\n@@ -5771,7 +5769,7 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Mod) {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) =\n-                self.parse_item_mod(&attrs[]);\n+                self.parse_item_mod(&attrs[..]);\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,\n@@ -6077,7 +6075,7 @@ impl<'a> Parser<'a> {\n         if !attrs.is_empty() {\n             let last_span = self.last_span;\n             self.span_err(last_span,\n-                          Parser::expected_item_err(&attrs[]));\n+                          Parser::expected_item_err(&attrs[..]));\n         }\n \n         foreign_items"}, {"sha": "433c013591c2d1557b84fcbb3c7a01d69b03d506", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -482,7 +482,7 @@ macro_rules! declare_special_idents_and_keywords {(\n         $(init_vec.push($si_str);)*\n         $(init_vec.push($sk_str);)*\n         $(init_vec.push($rk_str);)*\n-        interner::StrInterner::prefill(&init_vec[])\n+        interner::StrInterner::prefill(&init_vec[..])\n     }\n }}\n \n@@ -644,7 +644,7 @@ impl BytesContainer for InternedString {\n         // of `BytesContainer`, which is itself a workaround for the lack of\n         // DST.\n         unsafe {\n-            let this = &self[];\n+            let this = &self[..];\n             mem::transmute::<&[u8],&[u8]>(this.container_as_bytes())\n         }\n     }"}, {"sha": "360178ac7281b201f28b4aa0ebbcb53f18bbf769", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -607,7 +607,7 @@ impl Printer {\n             assert_eq!(l, len);\n             // assert!(l <= space);\n             self.space -= len;\n-            self.print_str(&s[])\n+            self.print_str(&s[..])\n           }\n           Token::Eof => {\n             // Eof should never get here."}, {"sha": "e2c7e992675dc1321083fe1f94503c430ac85310", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -602,7 +602,7 @@ impl<'a> State<'a> {\n     pub fn synth_comment(&mut self, text: String) -> IoResult<()> {\n         try!(word(&mut self.s, \"/*\"));\n         try!(space(&mut self.s));\n-        try!(word(&mut self.s, &text[]));\n+        try!(word(&mut self.s, &text[..]));\n         try!(space(&mut self.s));\n         word(&mut self.s, \"*/\")\n     }\n@@ -701,7 +701,7 @@ impl<'a> State<'a> {\n             }\n             ast::TyTup(ref elts) => {\n                 try!(self.popen());\n-                try!(self.commasep(Inconsistent, &elts[],\n+                try!(self.commasep(Inconsistent, &elts[..],\n                                    |s, ty| s.print_type(&**ty)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n@@ -734,10 +734,10 @@ impl<'a> State<'a> {\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n                 try!(self.print_type(&**ty));\n-                try!(self.print_bounds(\"+\", &bounds[]));\n+                try!(self.print_bounds(\"+\", &bounds[..]));\n             }\n             ast::TyPolyTraitRef(ref bounds) => {\n-                try!(self.print_bounds(\"\", &bounds[]));\n+                try!(self.print_bounds(\"\", &bounds[..]));\n             }\n             ast::TyQPath(ref qpath) => {\n                 try!(self.print_qpath(&**qpath, false))\n@@ -993,7 +993,7 @@ impl<'a> State<'a> {\n                         real_bounds.push(b.clone());\n                     }\n                 }\n-                try!(self.print_bounds(\":\", &real_bounds[]));\n+                try!(self.print_bounds(\":\", &real_bounds[..]));\n                 try!(self.print_where_clause(generics));\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.bopen());\n@@ -1011,7 +1011,7 @@ impl<'a> State<'a> {\n                 try!(self.print_ident(item.ident));\n                 try!(self.cbox(indent_unit));\n                 try!(self.popen());\n-                try!(self.print_tts(&tts[]));\n+                try!(self.print_tts(&tts[..]));\n                 try!(self.pclose());\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end());\n@@ -1209,7 +1209,7 @@ impl<'a> State<'a> {\n                 if !args.is_empty() {\n                     try!(self.popen());\n                     try!(self.commasep(Consistent,\n-                                       &args[],\n+                                       &args[..],\n                                        |s, arg| s.print_type(&*arg.ty)));\n                     try!(self.pclose());\n                 }\n@@ -1289,7 +1289,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.cbox(indent_unit));\n                 try!(self.popen());\n-                try!(self.print_tts(&tts[]));\n+                try!(self.print_tts(&tts[..]));\n                 try!(self.pclose());\n                 try!(word(&mut self.s, \";\"));\n                 self.end()\n@@ -1551,7 +1551,7 @@ impl<'a> State<'a> {\n     fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) -> IoResult<()> {\n         try!(self.ibox(indent_unit));\n         try!(word(&mut self.s, \"[\"));\n-        try!(self.commasep_exprs(Inconsistent, &exprs[]));\n+        try!(self.commasep_exprs(Inconsistent, &exprs[..]));\n         try!(word(&mut self.s, \"]\"));\n         self.end()\n     }\n@@ -1577,7 +1577,7 @@ impl<'a> State<'a> {\n             try!(word(&mut self.s, \"{\"));\n             try!(self.commasep_cmnt(\n                 Consistent,\n-                &fields[],\n+                &fields[..],\n                 |s, field| {\n                     try!(s.ibox(indent_unit));\n                     try!(s.print_ident(field.ident.node));\n@@ -1606,7 +1606,7 @@ impl<'a> State<'a> {\n \n     fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) -> IoResult<()> {\n         try!(self.popen());\n-        try!(self.commasep_exprs(Inconsistent, &exprs[]));\n+        try!(self.commasep_exprs(Inconsistent, &exprs[..]));\n         if exprs.len() == 1 {\n             try!(word(&mut self.s, \",\"));\n         }\n@@ -1671,22 +1671,22 @@ impl<'a> State<'a> {\n                 try!(self.print_expr_box(place, &**expr));\n             }\n             ast::ExprVec(ref exprs) => {\n-                try!(self.print_expr_vec(&exprs[]));\n+                try!(self.print_expr_vec(&exprs[..]));\n             }\n             ast::ExprRepeat(ref element, ref count) => {\n                 try!(self.print_expr_repeat(&**element, &**count));\n             }\n             ast::ExprStruct(ref path, ref fields, ref wth) => {\n-                try!(self.print_expr_struct(path, &fields[], wth));\n+                try!(self.print_expr_struct(path, &fields[..], wth));\n             }\n             ast::ExprTup(ref exprs) => {\n-                try!(self.print_expr_tup(&exprs[]));\n+                try!(self.print_expr_tup(&exprs[..]));\n             }\n             ast::ExprCall(ref func, ref args) => {\n-                try!(self.print_expr_call(&**func, &args[]));\n+                try!(self.print_expr_call(&**func, &args[..]));\n             }\n             ast::ExprMethodCall(ident, ref tys, ref args) => {\n-                try!(self.print_expr_method_call(ident, &tys[], &args[]));\n+                try!(self.print_expr_method_call(ident, &tys[..], &args[..]));\n             }\n             ast::ExprBinary(op, ref lhs, ref rhs) => {\n                 try!(self.print_expr_binary(op, &**lhs, &**rhs));\n@@ -1976,7 +1976,7 @@ impl<'a> State<'a> {\n     pub fn print_ident(&mut self, ident: ast::Ident) -> IoResult<()> {\n         if self.encode_idents_with_hygiene {\n             let encoded = ident.encode_with_hygiene();\n-            try!(word(&mut self.s, &encoded[]))\n+            try!(word(&mut self.s, &encoded[..]))\n         } else {\n             try!(word(&mut self.s, &token::get_ident(ident)))\n         }\n@@ -2150,7 +2150,7 @@ impl<'a> State<'a> {\n                     Some(ref args) => {\n                         if !args.is_empty() {\n                             try!(self.popen());\n-                            try!(self.commasep(Inconsistent, &args[],\n+                            try!(self.commasep(Inconsistent, &args[..],\n                                               |s, p| s.print_pat(&**p)));\n                             try!(self.pclose());\n                         }\n@@ -2162,7 +2162,7 @@ impl<'a> State<'a> {\n                 try!(self.nbsp());\n                 try!(self.word_space(\"{\"));\n                 try!(self.commasep_cmnt(\n-                    Consistent, &fields[],\n+                    Consistent, &fields[..],\n                     |s, f| {\n                         try!(s.cbox(indent_unit));\n                         if !f.node.is_shorthand {\n@@ -2183,7 +2183,7 @@ impl<'a> State<'a> {\n             ast::PatTup(ref elts) => {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent,\n-                                   &elts[],\n+                                   &elts[..],\n                                    |s, p| s.print_pat(&**p)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n@@ -2211,7 +2211,7 @@ impl<'a> State<'a> {\n             ast::PatVec(ref before, ref slice, ref after) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.commasep(Inconsistent,\n-                                   &before[],\n+                                   &before[..],\n                                    |s, p| s.print_pat(&**p)));\n                 if let Some(ref p) = *slice {\n                     if !before.is_empty() { try!(self.word_space(\",\")); }\n@@ -2225,7 +2225,7 @@ impl<'a> State<'a> {\n                     if !after.is_empty() { try!(self.word_space(\",\")); }\n                 }\n                 try!(self.commasep(Inconsistent,\n-                                   &after[],\n+                                   &after[..],\n                                    |s, p| s.print_pat(&**p)));\n                 try!(word(&mut self.s, \"]\"));\n             }\n@@ -2474,7 +2474,7 @@ impl<'a> State<'a> {\n             ints.push(i);\n         }\n \n-        try!(self.commasep(Inconsistent, &ints[], |s, &idx| {\n+        try!(self.commasep(Inconsistent, &ints[..], |s, &idx| {\n             if idx < generics.lifetimes.len() {\n                 let lifetime = &generics.lifetimes[idx];\n                 s.print_lifetime_def(lifetime)\n@@ -2561,15 +2561,15 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, &name));\n             }\n             ast::MetaNameValue(ref name, ref value) => {\n-                try!(self.word_space(&name[]));\n+                try!(self.word_space(&name[..]));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_literal(value));\n             }\n             ast::MetaList(ref name, ref items) => {\n                 try!(word(&mut self.s, &name));\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n-                                   &items[],\n+                                   &items[..],\n                                    |s, i| s.print_meta_item(&**i)));\n                 try!(self.pclose());\n             }\n@@ -2605,7 +2605,7 @@ impl<'a> State<'a> {\n                     try!(self.print_path(path, false));\n                     try!(word(&mut self.s, \"::{\"));\n                 }\n-                try!(self.commasep(Inconsistent, &idents[], |s, w| {\n+                try!(self.commasep(Inconsistent, &idents[..], |s, w| {\n                     match w.node {\n                         ast::PathListIdent { name, .. } => {\n                             s.print_ident(name)\n@@ -2762,13 +2762,13 @@ impl<'a> State<'a> {\n                 let mut res = String::from_str(\"b'\");\n                 res.extend(ascii::escape_default(byte).map(|c| c as char));\n                 res.push('\\'');\n-                word(&mut self.s, &res[])\n+                word(&mut self.s, &res[..])\n             }\n             ast::LitChar(ch) => {\n                 let mut res = String::from_str(\"'\");\n                 res.extend(ch.escape_default());\n                 res.push('\\'');\n-                word(&mut self.s, &res[])\n+                word(&mut self.s, &res[..])\n             }\n             ast::LitInt(i, t) => {\n                 match t {\n@@ -2799,7 +2799,7 @@ impl<'a> State<'a> {\n                          &f,\n                          &ast_util::float_ty_to_string(t)[])[])\n             }\n-            ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, &f[]),\n+            ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, &f[..]),\n             ast::LitBool(val) => {\n                 if val { word(&mut self.s, \"true\") } else { word(&mut self.s, \"false\") }\n             }\n@@ -2859,7 +2859,7 @@ impl<'a> State<'a> {\n                     // Don't print empty lines because they will end up as trailing\n                     // whitespace\n                     if !line.is_empty() {\n-                        try!(word(&mut self.s, &line[]));\n+                        try!(word(&mut self.s, &line[..]));\n                     }\n                     try!(hardbreak(&mut self.s));\n                 }\n@@ -2874,7 +2874,7 @@ impl<'a> State<'a> {\n                     try!(self.ibox(0));\n                     for line in &cmnt.lines {\n                         if !line.is_empty() {\n-                            try!(word(&mut self.s, &line[]));\n+                            try!(word(&mut self.s, &line[..]));\n                         }\n                         try!(hardbreak(&mut self.s));\n                     }\n@@ -2907,7 +2907,7 @@ impl<'a> State<'a> {\n                          string=st))\n             }\n         };\n-        word(&mut self.s, &st[])\n+        word(&mut self.s, &st[..])\n     }\n \n     pub fn next_comment(&mut self) -> Option<comments::Comment> {"}, {"sha": "8c2b9edfb22c78756844a43f7144490d062ce94c", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -54,7 +54,7 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n \n         // The name to use in `extern crate \"name\" as std;`\n         let actual_crate_name = match self.alt_std_name {\n-            Some(ref s) => token::intern_and_get_ident(&s[]),\n+            Some(ref s) => token::intern_and_get_ident(&s[..]),\n             None => token::intern_and_get_ident(\"std\"),\n         };\n "}, {"sha": "31b264eb76d67fe2a5cb8146dba0ffe79c4fe18a", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -274,8 +274,8 @@ fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n     config::strip_items(krate, |attrs| {\n-        !attr::contains_name(&attrs[], \"test\") &&\n-        !attr::contains_name(&attrs[], \"bench\")\n+        !attr::contains_name(&attrs[..], \"test\") &&\n+        !attr::contains_name(&attrs[..], \"bench\")\n     })\n }\n \n@@ -563,7 +563,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n     match attr::find_crate_name(&krate.attrs[]) {\n-        Some(ref s) if \"test\" == &s[] => true,\n+        Some(ref s) if \"test\" == &s[..] => true,\n         _ => false\n     }\n }\n@@ -603,11 +603,11 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     // creates $name: $expr\n     let field = |name, expr| ecx.field_imm(span, ecx.ident_of(name), expr);\n \n-    debug!(\"encoding {}\", ast_util::path_name_i(&path[]));\n+    debug!(\"encoding {}\", ast_util::path_name_i(&path[..]));\n \n     // path to the #[test] function: \"foo::bar::baz\"\n-    let path_string = ast_util::path_name_i(&path[]);\n-    let name_expr = ecx.expr_str(span, token::intern_and_get_ident(&path_string[]));\n+    let path_string = ast_util::path_name_i(&path[..]);\n+    let name_expr = ecx.expr_str(span, token::intern_and_get_ident(&path_string[..]));\n \n     // self::test::StaticTestName($name_expr)\n     let name_expr = ecx.expr_call(span,"}, {"sha": "bd9a6d7c4feaba01f84bbffc9abf4d5e3f501b08", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -175,34 +175,34 @@ impl Eq for RcStr {}\n \n impl Ord for RcStr {\n     fn cmp(&self, other: &RcStr) -> Ordering {\n-        self[].cmp(&other[])\n+        self[..].cmp(&other[..])\n     }\n }\n \n impl fmt::Debug for RcStr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use std::fmt::Debug;\n-        self[].fmt(f)\n+        self[..].fmt(f)\n     }\n }\n \n impl fmt::Display for RcStr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use std::fmt::Display;\n-        self[].fmt(f)\n+        self[..].fmt(f)\n     }\n }\n \n impl Borrow<str> for RcStr {\n     fn borrow(&self) -> &str {\n-        &self.string[]\n+        &self.string[..]\n     }\n }\n \n impl Deref for RcStr {\n     type Target = str;\n \n-    fn deref(&self) -> &str { &self.string[] }\n+    fn deref(&self) -> &str { &self.string[..] }\n }\n \n /// A StrInterner differs from Interner<String> in that it accepts"}, {"sha": "be1c623c8590512c1f699aed09e7bc496039bd57", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -180,7 +180,7 @@ impl<T: Writer+Send+'static> TerminfoTerminal<T> {\n             }\n         };\n \n-        let entry = open(&term[]);\n+        let entry = open(&term[..]);\n         if entry.is_err() {\n             if env::var(\"MSYSCON\").ok().map_or(false, |s| {\n                     \"mintty.exe\" == s"}, {"sha": "c40a5534efbbb4e8d3d6146c6c513a124a420c62", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -60,13 +60,13 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n     for p in &dirs_to_search {\n         if p.exists() {\n             let f = first_char.to_string();\n-            let newp = p.join_many(&[&f[], term]);\n+            let newp = p.join_many(&[&f[..], term]);\n             if newp.exists() {\n                 return Some(box newp);\n             }\n             // on some installations the dir is named after the hex of the char (e.g. OS X)\n             let f = format!(\"{:x}\", first_char as uint);\n-            let newp = p.join_many(&[&f[], term]);\n+            let newp = p.join_many(&[&f[..], term]);\n             if newp.exists() {\n                 return Some(box newp);\n             }"}, {"sha": "82c1a4b1195ce06ca1f948e39c13fe01f613991f", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -720,7 +720,7 @@ fn should_sort_failures_before_printing_them() {\n \n     st.write_failures().unwrap();\n     let s = match st.out {\n-        Raw(ref m) => String::from_utf8_lossy(&m[]),\n+        Raw(ref m) => String::from_utf8_lossy(&m[..]),\n         Pretty(_) => unreachable!()\n     };\n \n@@ -833,7 +833,7 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n         None => filtered,\n         Some(ref filter) => {\n             filtered.into_iter().filter(|test| {\n-                test.desc.name.as_slice().contains(&filter[])\n+                test.desc.name.as_slice().contains(&filter[..])\n             }).collect()\n         }\n     };"}, {"sha": "224f1ef1a8b9b6feaaa5e559b6bbfea5f2c953e5", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -92,7 +92,7 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n         {\n             let urls = markdown_data.replace(\".md)\", \".html)\");\n             try!(File::create(&preprocessed_path)\n-                      .write_str(&urls[]));\n+                      .write_str(&urls[..]));\n         }\n \n         // write the prelude to a temporary HTML file for rustdoc inclusion"}, {"sha": "43c882c7d5b8a69c1c660049f7abf6f969fe8764", "filename": "src/rustbook/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Frustbook%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Frustbook%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ferror.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -52,7 +52,7 @@ impl<'a> Error for &'a str {\n \n impl Error for String {\n     fn description<'a>(&'a self) -> &'a str {\n-        &self[]\n+        &self[..]\n     }\n }\n \n@@ -75,7 +75,7 @@ impl Error for IoError {\n         self.desc\n     }\n     fn detail(&self) -> Option<&str> {\n-        self.detail.as_ref().map(|s| &s[])\n+        self.detail.as_ref().map(|s| &s[..])\n     }\n }\n "}, {"sha": "c5d4875423ae1ee62893be77b7183018ff35ccf4", "filename": "src/rustbook/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Frustbook%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Frustbook%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ftest.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -65,7 +65,7 @@ impl Subcommand for Test {\n             }\n             Err(errors) => {\n                 for err in errors {\n-                    term.err(&err[]);\n+                    term.err(&err[..]);\n                 }\n                 return Err(box \"There was an error.\" as Box<Error>);\n             }"}, {"sha": "e9d98889ff854062f3434ea105b5b91f401fca81", "filename": "src/test/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -37,9 +37,9 @@ impl LintPass for Pass {\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         let name = token::get_ident(it.ident);\n-        if &name[] == \"lintme\" {\n+        if &name[..] == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n-        } else if &name[] == \"pleaselintme\" {\n+        } else if &name[..] == \"pleaselintme\" {\n             cx.span_lint(PLEASE_LINT, it.span, \"item is named 'pleaselintme'\");\n         }\n     }"}, {"sha": "ffb234f70c8e754ec7f4d86411101598ac100118", "filename": "src/test/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -35,7 +35,7 @@ impl LintPass for Pass {\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         let name = token::get_ident(it.ident);\n-        if &name[] == \"lintme\" {\n+        if &name[..] == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n     }"}, {"sha": "d0ab944813a0ac7c025de01bc2a3d0811825abac", "filename": "src/test/auxiliary/plugin_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Ftest%2Fauxiliary%2Fplugin_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Ftest%2Fauxiliary%2Fplugin_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_args.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -37,7 +37,7 @@ impl TTMacroExpander for Expander {\n                    _: &[ast::TokenTree]) -> Box<MacResult+'cx> {\n         let args = self.args.iter().map(|i| pprust::meta_item_to_string(&*i))\n             .collect::<Vec<_>>().connect(\", \");\n-        let interned = token::intern_and_get_ident(&args[]);\n+        let interned = token::intern_and_get_ident(&args[..]);\n         MacExpr::new(ecx.expr_str(sp, interned))\n     }\n }"}, {"sha": "3b992e3bcc321001aae1fd9e694717400c7685ea", "filename": "src/test/compile-fail/slice-1.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Ftest%2Fcompile-fail%2Fslice-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Ftest%2Fcompile-fail%2Fslice-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-1.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -9,14 +9,12 @@\n // except according to those terms.\n \n // Test slicing &expr[] is deprecated and gives a helpful error message.\n-//\n-// ignore-test\n \n struct Foo;\n \n fn main() {\n     let x = Foo;\n-    &x[]; //~ WARNING deprecated slicing syntax: `[]`\n-          //~^ NOTE use `&expr[..]` to construct a slice of the whole of expr\n-          //~^^ ERROR cannot index a value of type `Foo`\n+    &x[];\n+    //~^ WARN obsolete syntax\n+    //~| ERROR cannot index\n }"}, {"sha": "a224017780e2d936419b6ca4f6ec7e235b527b9c", "filename": "src/test/run-pass/regions-refcell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Ftest%2Frun-pass%2Fregions-refcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8/src%2Ftest%2Frun-pass%2Fregions-refcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-refcell.rs?ref=231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "patch": "@@ -19,7 +19,7 @@ use std::cell::RefCell;\n #[cfg(cannot_use_this_yet)]\n fn foo<'a>(map: RefCell<HashMap<&'static str, &'a [u8]>>) {\n     let one = [1_usize];\n-    assert_eq!(map.borrow().get(\"one\"), Some(&one[]));\n+    assert_eq!(map.borrow().get(\"one\"), Some(&one[..]));\n }\n \n #[cfg(cannot_use_this_yet_either)]\n@@ -45,9 +45,9 @@ fn main() {\n     let one = [1u8];\n     let two = [2u8];\n     let mut map = HashMap::new();\n-    map.insert(\"zero\", &zer[]);\n-    map.insert(\"one\",  &one[]);\n-    map.insert(\"two\",  &two[]);\n+    map.insert(\"zero\", &zer[..]);\n+    map.insert(\"one\",  &one[..]);\n+    map.insert(\"two\",  &two[..]);\n     let map = RefCell::new(map);\n     foo(map);\n }"}]}