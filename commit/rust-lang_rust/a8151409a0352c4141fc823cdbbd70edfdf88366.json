{"sha": "a8151409a0352c4141fc823cdbbd70edfdf88366", "node_id": "C_kwDOAAsO6NoAKGE4MTUxNDA5YTAzNTJjNDE0MWZjODIzY2RiYmQ3MGVkZmRmODgzNjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-13T09:57:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-13T09:57:36Z"}, "message": "Auto merge of #9698 - kraktus:xc_bool, r=xFrednet\n\n [`fn_params_excessive_bools`] Make it possible to allow the lint at the method level\n\nchangelog: FP: [`fn_params_excessive_bools`]: `#[allow]` now works on methods\n\nfix https://github.com/rust-lang/rust-clippy/issues/9687\n\nTested without committing but `#[allow]`ing now works. Also rewrote the lint to be a late lint while at it :)\nr? `@xFrednet`", "tree": {"sha": "f13f7adf02b21d4b259ff89d336e435e9e332ba2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f13f7adf02b21d4b259ff89d336e435e9e332ba2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8151409a0352c4141fc823cdbbd70edfdf88366", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8151409a0352c4141fc823cdbbd70edfdf88366", "html_url": "https://github.com/rust-lang/rust/commit/a8151409a0352c4141fc823cdbbd70edfdf88366", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8151409a0352c4141fc823cdbbd70edfdf88366/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f283c97e154a81f1407498c6d318d4f1cae94f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f283c97e154a81f1407498c6d318d4f1cae94f0", "html_url": "https://github.com/rust-lang/rust/commit/9f283c97e154a81f1407498c6d318d4f1cae94f0"}, {"sha": "3d4b73c26da1630318e76f43a7dedfc4dbc716cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d4b73c26da1630318e76f43a7dedfc4dbc716cd", "html_url": "https://github.com/rust-lang/rust/commit/3d4b73c26da1630318e76f43a7dedfc4dbc716cd"}], "stats": {"total": 198, "additions": 110, "deletions": 88}, "files": [{"sha": "fc2912f696e0384baa554564d683d4ba23f80fcd", "filename": "clippy_lints/src/excessive_bools.rs", "status": "modified", "additions": 68, "deletions": 61, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/a8151409a0352c4141fc823cdbbd70edfdf88366/clippy_lints%2Fsrc%2Fexcessive_bools.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8151409a0352c4141fc823cdbbd70edfdf88366/clippy_lints%2Fsrc%2Fexcessive_bools.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_bools.rs?ref=a8151409a0352c4141fc823cdbbd70edfdf88366", "patch": "@@ -1,8 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use rustc_ast::ast::{AssocItemKind, Extern, Fn, FnSig, Impl, Item, ItemKind, Trait, Ty, TyKind};\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use clippy_utils::{get_parent_as_impl, has_repr_attr, is_bool};\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{Body, FnDecl, HirId, Item, ItemKind, TraitFn, TraitItem, TraitItemKind, Ty};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{sym, Span};\n+use rustc_span::Span;\n+use rustc_target::spec::abi::Abi;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -83,6 +86,12 @@ pub struct ExcessiveBools {\n     max_fn_params_bools: u64,\n }\n \n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+enum Kind {\n+    Struct,\n+    Fn,\n+}\n+\n impl ExcessiveBools {\n     #[must_use]\n     pub fn new(max_struct_bools: u64, max_fn_params_bools: u64) -> Self {\n@@ -92,21 +101,20 @@ impl ExcessiveBools {\n         }\n     }\n \n-    fn check_fn_sig(&self, cx: &EarlyContext<'_>, fn_sig: &FnSig, span: Span) {\n-        match fn_sig.header.ext {\n-            Extern::Implicit(_) | Extern::Explicit(_, _) => return,\n-            Extern::None => (),\n+    fn too_many_bools<'tcx>(&self, tys: impl Iterator<Item = &'tcx Ty<'tcx>>, kind: Kind) -> bool {\n+        if let Ok(bools) = tys.filter(|ty| is_bool(ty)).count().try_into() {\n+            (if Kind::Fn == kind {\n+                self.max_fn_params_bools\n+            } else {\n+                self.max_struct_bools\n+            }) < bools\n+        } else {\n+            false\n         }\n+    }\n \n-        let fn_sig_bools = fn_sig\n-            .decl\n-            .inputs\n-            .iter()\n-            .filter(|param| is_bool_ty(&param.ty))\n-            .count()\n-            .try_into()\n-            .unwrap();\n-        if self.max_fn_params_bools < fn_sig_bools {\n+    fn check_fn_sig(&self, cx: &LateContext<'_>, fn_decl: &FnDecl<'_>, span: Span) {\n+        if !span.from_expansion() && self.too_many_bools(fn_decl.inputs.iter(), Kind::Fn) {\n             span_lint_and_help(\n                 cx,\n                 FN_PARAMS_EXCESSIVE_BOOLS,\n@@ -121,56 +129,55 @@ impl ExcessiveBools {\n \n impl_lint_pass!(ExcessiveBools => [STRUCT_EXCESSIVE_BOOLS, FN_PARAMS_EXCESSIVE_BOOLS]);\n \n-fn is_bool_ty(ty: &Ty) -> bool {\n-    if let TyKind::Path(None, path) = &ty.kind {\n-        if let [name] = path.segments.as_slice() {\n-            return name.ident.name == sym::bool;\n+impl<'tcx> LateLintPass<'tcx> for ExcessiveBools {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n+        if item.span.from_expansion() {\n+            return;\n+        }\n+        if let ItemKind::Struct(variant_data, _) = &item.kind {\n+            if has_repr_attr(cx, item.hir_id()) {\n+                return;\n+            }\n+\n+            if self.too_many_bools(variant_data.fields().iter().map(|field| field.ty), Kind::Struct) {\n+                span_lint_and_help(\n+                    cx,\n+                    STRUCT_EXCESSIVE_BOOLS,\n+                    item.span,\n+                    &format!(\"more than {} bools in a struct\", self.max_struct_bools),\n+                    None,\n+                    \"consider using a state machine or refactoring bools into two-variant enums\",\n+                );\n+            }\n         }\n     }\n-    false\n-}\n \n-impl EarlyLintPass for ExcessiveBools {\n-    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n-        if item.span.from_expansion() {\n-            return;\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx TraitItem<'tcx>) {\n+        // functions with a body are already checked by `check_fn`\n+        if let TraitItemKind::Fn(fn_sig, TraitFn::Required(_)) = &trait_item.kind\n+            && fn_sig.header.abi == Abi::Rust\n+            {\n+            self.check_fn_sig(cx, fn_sig.decl, fn_sig.span);\n         }\n-        match &item.kind {\n-            ItemKind::Struct(variant_data, _) => {\n-                if item.attrs.iter().any(|attr| attr.has_name(sym::repr)) {\n-                    return;\n-                }\n+    }\n \n-                let struct_bools = variant_data\n-                    .fields()\n-                    .iter()\n-                    .filter(|field| is_bool_ty(&field.ty))\n-                    .count()\n-                    .try_into()\n-                    .unwrap();\n-                if self.max_struct_bools < struct_bools {\n-                    span_lint_and_help(\n-                        cx,\n-                        STRUCT_EXCESSIVE_BOOLS,\n-                        item.span,\n-                        &format!(\"more than {} bools in a struct\", self.max_struct_bools),\n-                        None,\n-                        \"consider using a state machine or refactoring bools into two-variant enums\",\n-                    );\n-                }\n-            },\n-            ItemKind::Impl(box Impl {\n-                of_trait: None, items, ..\n-            })\n-            | ItemKind::Trait(box Trait { items, .. }) => {\n-                for item in items {\n-                    if let AssocItemKind::Fn(box Fn { sig, .. }) = &item.kind {\n-                        self.check_fn_sig(cx, sig, item.span);\n-                    }\n-                }\n-            },\n-            ItemKind::Fn(box Fn { sig, .. }) => self.check_fn_sig(cx, sig, item.span),\n-            _ => (),\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        fn_kind: FnKind<'tcx>,\n+        fn_decl: &'tcx FnDecl<'tcx>,\n+        _: &'tcx Body<'tcx>,\n+        span: Span,\n+        hir_id: HirId,\n+    ) {\n+        if let Some(fn_header) = fn_kind.header()\n+            && fn_header.abi == Abi::Rust\n+            && get_parent_as_impl(cx.tcx, hir_id)\n+                .map_or(true,\n+                    |impl_item| impl_item.of_trait.is_none()\n+                )\n+            {\n+            self.check_fn_sig(cx, fn_decl, span);\n         }\n     }\n }"}, {"sha": "f847490be27ffddd9a59d1bf3916b71476638921", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8151409a0352c4141fc823cdbbd70edfdf88366/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8151409a0352c4141fc823cdbbd70edfdf88366/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a8151409a0352c4141fc823cdbbd70edfdf88366", "patch": "@@ -795,7 +795,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| Box::new(single_component_path_imports::SingleComponentPathImports));\n     let max_fn_params_bools = conf.max_fn_params_bools;\n     let max_struct_bools = conf.max_struct_bools;\n-    store.register_early_pass(move || {\n+    store.register_late_pass(move |_| {\n         Box::new(excessive_bools::ExcessiveBools::new(\n             max_struct_bools,\n             max_fn_params_bools,"}, {"sha": "5c8add5f3022612433100379cc5006297e91e434", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a8151409a0352c4141fc823cdbbd70edfdf88366/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8151409a0352c4141fc823cdbbd70edfdf88366/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=a8151409a0352c4141fc823cdbbd70edfdf88366", "patch": "@@ -105,11 +105,10 @@ use bind_instead_of_map::BindInsteadOfMap;\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_ty_adt_constructor_opaque, implements_trait, is_copy, is_type_diagnostic_item};\n-use clippy_utils::{contains_return, is_trait_method, iter_input_pats, meets_msrv, msrvs, return_ty};\n+use clippy_utils::{contains_return, is_bool, is_trait_method, iter_input_pats, meets_msrv, msrvs, return_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n-use rustc_hir::{Expr, ExprKind, PrimTy, QPath, TraitItem, TraitItemKind};\n+use rustc_hir::{Expr, ExprKind, TraitItem, TraitItemKind};\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -3992,14 +3991,6 @@ impl OutType {\n     }\n }\n \n-fn is_bool(ty: &hir::Ty<'_>) -> bool {\n-    if let hir::TyKind::Path(QPath::Resolved(_, path)) = ty.kind {\n-        matches!(path.res, Res::PrimTy(PrimTy::Bool))\n-    } else {\n-        false\n-    }\n-}\n-\n fn fn_header_equals(expected: hir::FnHeader, actual: hir::FnHeader) -> bool {\n     expected.constness == actual.constness\n         && expected.unsafety == actual.unsafety"}, {"sha": "712a7a6601ac4a11c5a78bdc1996b9f4b0c48861", "filename": "clippy_lints/src/trailing_empty_array.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8151409a0352c4141fc823cdbbd70edfdf88366/clippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8151409a0352c4141fc823cdbbd70edfdf88366/clippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrailing_empty_array.rs?ref=a8151409a0352c4141fc823cdbbd70edfdf88366", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use rustc_hir::{HirId, Item, ItemKind};\n+use clippy_utils::has_repr_attr;\n+use rustc_hir::{Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::Const;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -72,7 +72,3 @@ fn is_struct_with_trailing_zero_sized_array(cx: &LateContext<'_>, item: &Item<'_\n         }\n     }\n }\n-\n-fn has_repr_attr(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n-    cx.tcx.hir().attrs(hir_id).iter().any(|attr| attr.has_name(sym::repr))\n-}"}, {"sha": "da8c976c952c9d7b258f4eb11c7efc918b0f4e8b", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8151409a0352c4141fc823cdbbd70edfdf88366/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8151409a0352c4141fc823cdbbd70edfdf88366/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=a8151409a0352c4141fc823cdbbd70edfdf88366", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::HirIdMap;\n use rustc_hir::{\n     ArrayLen, BinOpKind, BindingAnnotation, Block, BodyId, Closure, Expr, ExprField, ExprKind, FnRetTy, GenericArg,\n     GenericArgs, Guard, HirId, InlineAsmOperand, Let, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path,\n-    PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n+    PathSegment, PrimTy, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::LateContext;\n@@ -1030,6 +1030,14 @@ pub fn hash_stmt(cx: &LateContext<'_>, s: &Stmt<'_>) -> u64 {\n     h.finish()\n }\n \n+pub fn is_bool(ty: &Ty<'_>) -> bool {\n+    if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind {\n+        matches!(path.res, Res::PrimTy(PrimTy::Bool))\n+    } else {\n+        false\n+    }\n+}\n+\n pub fn hash_expr(cx: &LateContext<'_>, e: &Expr<'_>) -> u64 {\n     let mut h = SpanlessHash::new(cx);\n     h.hash_expr(e);"}, {"sha": "7458cc41ef79b893b559ac1d5c4634a8b389c243", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8151409a0352c4141fc823cdbbd70edfdf88366/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8151409a0352c4141fc823cdbbd70edfdf88366/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=a8151409a0352c4141fc823cdbbd70edfdf88366", "patch": "@@ -66,7 +66,7 @@ pub mod visitors;\n pub use self::attrs::*;\n pub use self::check_proc_macro::{is_from_proc_macro, is_span_if, is_span_match};\n pub use self::hir_utils::{\n-    both, count_eq, eq_expr_value, hash_expr, hash_stmt, over, HirEqInterExpr, SpanlessEq, SpanlessHash,\n+    both, count_eq, eq_expr_value, hash_expr, hash_stmt, is_bool, over, HirEqInterExpr, SpanlessEq, SpanlessHash,\n };\n \n use core::ops::ControlFlow;\n@@ -1780,6 +1780,10 @@ pub fn has_attr(attrs: &[ast::Attribute], symbol: Symbol) -> bool {\n     attrs.iter().any(|attr| attr.has_name(symbol))\n }\n \n+pub fn has_repr_attr(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n+    has_attr(cx.tcx.hir().attrs(hir_id), sym::repr)\n+}\n+\n pub fn any_parent_has_attr(tcx: TyCtxt<'_>, node: HirId, symbol: Symbol) -> bool {\n     let map = &tcx.hir();\n     let mut prev_enclosing_node = None;"}, {"sha": "f53e531629aaef67e74b66ae674e4015f78b7061", "filename": "tests/ui/fn_params_excessive_bools.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8151409a0352c4141fc823cdbbd70edfdf88366/tests%2Fui%2Ffn_params_excessive_bools.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8151409a0352c4141fc823cdbbd70edfdf88366/tests%2Fui%2Ffn_params_excessive_bools.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn_params_excessive_bools.rs?ref=a8151409a0352c4141fc823cdbbd70edfdf88366", "patch": "@@ -2,6 +2,7 @@\n #![allow(clippy::too_many_arguments)]\n \n extern \"C\" {\n+    // Should not lint, most of the time users have no control over extern function signatures\n     fn f(_: bool, _: bool, _: bool, _: bool);\n }\n \n@@ -22,8 +23,12 @@ fn t(_: S, _: S, _: Box<S>, _: Vec<u32>, _: bool, _: bool, _: bool, _: bool) {}\n \n struct S;\n trait Trait {\n+    // should warn for trait functions with and without body\n     fn f(_: bool, _: bool, _: bool, _: bool);\n     fn g(_: bool, _: bool, _: bool, _: Vec<u32>);\n+    #[allow(clippy::fn_params_excessive_bools)]\n+    fn h(_: bool, _: bool, _: bool, _: bool, _: bool, _: bool);\n+    fn i(_: bool, _: bool, _: bool, _: bool) {}\n }\n \n impl S {\n@@ -34,8 +39,11 @@ impl S {\n }\n \n impl Trait for S {\n+    // Should not lint because the trait might not be changeable by the user\n+    // We only lint in the trait definition\n     fn f(_: bool, _: bool, _: bool, _: bool) {}\n     fn g(_: bool, _: bool, _: bool, _: Vec<u32>) {}\n+    fn h(_: bool, _: bool, _: bool, _: bool, _: bool, _: bool) {}\n }\n \n fn main() {"}, {"sha": "43363b46972c345583c0929ab1638c61f36d2b78", "filename": "tests/ui/fn_params_excessive_bools.stderr", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a8151409a0352c4141fc823cdbbd70edfdf88366/tests%2Fui%2Ffn_params_excessive_bools.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8151409a0352c4141fc823cdbbd70edfdf88366/tests%2Fui%2Ffn_params_excessive_bools.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn_params_excessive_bools.stderr?ref=a8151409a0352c4141fc823cdbbd70edfdf88366", "patch": "@@ -1,5 +1,5 @@\n error: more than 3 bools in function parameters\n-  --> $DIR/fn_params_excessive_bools.rs:18:1\n+  --> $DIR/fn_params_excessive_bools.rs:19:1\n    |\n LL | fn g(_: bool, _: bool, _: bool, _: bool) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -8,31 +8,39 @@ LL | fn g(_: bool, _: bool, _: bool, _: bool) {}\n    = note: `-D clippy::fn-params-excessive-bools` implied by `-D warnings`\n \n error: more than 3 bools in function parameters\n-  --> $DIR/fn_params_excessive_bools.rs:21:1\n+  --> $DIR/fn_params_excessive_bools.rs:22:1\n    |\n LL | fn t(_: S, _: S, _: Box<S>, _: Vec<u32>, _: bool, _: bool, _: bool, _: bool) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider refactoring bools into two-variant enums\n \n error: more than 3 bools in function parameters\n-  --> $DIR/fn_params_excessive_bools.rs:25:5\n+  --> $DIR/fn_params_excessive_bools.rs:27:5\n    |\n LL |     fn f(_: bool, _: bool, _: bool, _: bool);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider refactoring bools into two-variant enums\n \n error: more than 3 bools in function parameters\n-  --> $DIR/fn_params_excessive_bools.rs:30:5\n+  --> $DIR/fn_params_excessive_bools.rs:31:5\n+   |\n+LL |     fn i(_: bool, _: bool, _: bool, _: bool) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider refactoring bools into two-variant enums\n+\n+error: more than 3 bools in function parameters\n+  --> $DIR/fn_params_excessive_bools.rs:35:5\n    |\n LL |     fn f(&self, _: bool, _: bool, _: bool, _: bool) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider refactoring bools into two-variant enums\n \n error: more than 3 bools in function parameters\n-  --> $DIR/fn_params_excessive_bools.rs:42:5\n+  --> $DIR/fn_params_excessive_bools.rs:50:5\n    |\n LL | /     fn n(_: bool, _: u32, _: bool, _: Box<u32>, _: bool, _: bool) {\n LL | |         fn nn(_: bool, _: bool, _: bool, _: bool) {}\n@@ -42,12 +50,12 @@ LL | |     }\n    = help: consider refactoring bools into two-variant enums\n \n error: more than 3 bools in function parameters\n-  --> $DIR/fn_params_excessive_bools.rs:43:9\n+  --> $DIR/fn_params_excessive_bools.rs:51:9\n    |\n LL |         fn nn(_: bool, _: bool, _: bool, _: bool) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider refactoring bools into two-variant enums\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 7 previous errors\n "}]}