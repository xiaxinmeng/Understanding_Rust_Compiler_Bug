{"sha": "585bb83e2aec9c79dae8c2e031e9165f40937003", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NWJiODNlMmFlYzljNzlkYWU4YzJlMDMxZTkxNjVmNDA5MzcwMDM=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-09T07:39:17Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-09T07:53:53Z"}, "message": "feat: add attributes support on struct fields and method #3870\n\nSigned-off-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "3dda062f3deb768b211e7e091dd5b29b9b6fae84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dda062f3deb768b211e7e091dd5b29b9b6fae84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/585bb83e2aec9c79dae8c2e031e9165f40937003", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/585bb83e2aec9c79dae8c2e031e9165f40937003", "html_url": "https://github.com/rust-lang/rust/commit/585bb83e2aec9c79dae8c2e031e9165f40937003", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/585bb83e2aec9c79dae8c2e031e9165f40937003/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f1dba6f9ae1d8d314dd9d007e4c582ed1403e8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f1dba6f9ae1d8d314dd9d007e4c582ed1403e8d", "html_url": "https://github.com/rust-lang/rust/commit/8f1dba6f9ae1d8d314dd9d007e4c582ed1403e8d"}, {"sha": "080c983498afcac3eb54028af5c9f8bfe7f2c826", "url": "https://api.github.com/repos/rust-lang/rust/commits/080c983498afcac3eb54028af5c9f8bfe7f2c826", "html_url": "https://github.com/rust-lang/rust/commit/080c983498afcac3eb54028af5c9f8bfe7f2c826"}], "stats": {"total": 858, "additions": 522, "deletions": 336}, "files": [{"sha": "2c1192f0728d7636cedbb77a666e9562889a3852", "filename": ".github/workflows/release.yaml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Frelease.yaml?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -50,11 +50,11 @@ jobs:\n \n     - name: Dist\n       if: matrix.os == 'ubuntu-latest' && github.ref == 'refs/heads/release'\n-      run: cargo xtask dist --client --version 0.2.$GITHUB_RUN_NUMBER         --tag $(date --iso --utc)\n+      run: cargo xtask dist --client 0.2.$GITHUB_RUN_NUMBER\n \n     - name: Dist\n       if: matrix.os == 'ubuntu-latest' && github.ref != 'refs/heads/release'\n-      run: cargo xtask dist --client --version 0.3.$GITHUB_RUN_NUMBER-nightly --tag nightly\n+      run: cargo xtask dist --nightly --client 0.3.$GITHUB_RUN_NUMBER-nightly\n \n     - name: Dist\n       if: matrix.os != 'ubuntu-latest'"}, {"sha": "9baebf64350c5eaa8ceaee3ee14c45a8d8b0c2a5", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -1027,8 +1027,16 @@ impl Type {\n         ty: Ty,\n     ) -> Option<Type> {\n         let krate = resolver.krate()?;\n+        Some(Type::new_with_resolver_inner(db, krate, resolver, ty))\n+    }\n+    pub(crate) fn new_with_resolver_inner(\n+        db: &dyn HirDatabase,\n+        krate: CrateId,\n+        resolver: &Resolver,\n+        ty: Ty,\n+    ) -> Type {\n         let environment = TraitEnvironment::lower(db, &resolver);\n-        Some(Type { krate, ty: InEnvironment { value: ty, environment } })\n+        Type { krate, ty: InEnvironment { value: ty, environment } }\n     }\n \n     fn new(db: &dyn HirDatabase, krate: CrateId, lexical_env: impl HasResolver, ty: Ty) -> Type {\n@@ -1152,27 +1160,6 @@ impl Type {\n         res\n     }\n \n-    pub fn variant_fields(\n-        &self,\n-        db: &dyn HirDatabase,\n-        def: VariantDef,\n-    ) -> Vec<(StructField, Type)> {\n-        // FIXME: check that ty and def match\n-        match &self.ty.value {\n-            Ty::Apply(a_ty) => {\n-                let field_types = db.field_types(def.into());\n-                def.fields(db)\n-                    .into_iter()\n-                    .map(|it| {\n-                        let ty = field_types[it.id].clone().subst(&a_ty.parameters);\n-                        (it, self.derived(ty))\n-                    })\n-                    .collect()\n-            }\n-            _ => Vec::new(),\n-        }\n-    }\n-\n     pub fn autoderef<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Type> + 'a {\n         // There should be no inference vars in types passed here\n         // FIXME check that?"}, {"sha": "2707e422d109477017e70cdf6b994666c4cd5a93", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -23,7 +23,7 @@ use crate::{\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, SourceAnalyzer},\n     AssocItem, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module, ModuleDef, Name,\n-    Origin, Path, ScopeDef, StructField, Trait, Type, TypeParam, VariantDef,\n+    Origin, Path, ScopeDef, StructField, Trait, Type, TypeParam,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -187,14 +187,6 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.analyze(field.syntax()).resolve_record_field(self.db, field)\n     }\n \n-    pub fn resolve_record_literal(&self, record_lit: &ast::RecordLit) -> Option<VariantDef> {\n-        self.analyze(record_lit.syntax()).resolve_record_literal(self.db, record_lit)\n-    }\n-\n-    pub fn resolve_record_pattern(&self, record_pat: &ast::RecordPat) -> Option<VariantDef> {\n-        self.analyze(record_pat.syntax()).resolve_record_pattern(record_pat)\n-    }\n-\n     pub fn resolve_macro_call(&self, macro_call: &ast::MacroCall) -> Option<MacroDef> {\n         let sa = self.analyze(macro_call.syntax());\n         let macro_call = self.find_file(macro_call.syntax().clone()).with_value(macro_call);\n@@ -212,6 +204,24 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     // FIXME: use this instead?\n     // pub fn resolve_name_ref(&self, name_ref: &ast::NameRef) -> Option<???>;\n \n+    pub fn record_literal_missing_fields(\n+        &self,\n+        literal: &ast::RecordLit,\n+    ) -> Vec<(StructField, Type)> {\n+        self.analyze(literal.syntax())\n+            .record_literal_missing_fields(self.db, literal)\n+            .unwrap_or_default()\n+    }\n+\n+    pub fn record_pattern_missing_fields(\n+        &self,\n+        pattern: &ast::RecordPat,\n+    ) -> Vec<(StructField, Type)> {\n+        self.analyze(pattern.syntax())\n+            .record_pattern_missing_fields(self.db, pattern)\n+            .unwrap_or_default()\n+    }\n+\n     pub fn to_def<T: ToDef>(&self, src: &T) -> Option<T::Def> {\n         let src = self.find_file(src.syntax().clone()).with_value(src).cloned();\n         T::to_def(self, src)"}, {"sha": "45631f8fdf821e4d73aaa06db7fb2de9bd42bf3e", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 70, "deletions": 20, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -14,19 +14,24 @@ use hir_def::{\n     },\n     expr::{ExprId, Pat, PatId},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n-    AsMacroCall, DefWithBodyId,\n+    AsMacroCall, DefWithBodyId, LocalStructFieldId, StructFieldId, VariantId,\n };\n use hir_expand::{hygiene::Hygiene, name::AsName, HirFileId, InFile};\n-use hir_ty::InferenceResult;\n+use hir_ty::{\n+    expr::{record_literal_missing_fields, record_pattern_missing_fields},\n+    InferenceResult, Substs, Ty,\n+};\n use ra_syntax::{\n     ast::{self, AstNode},\n     SyntaxNode, SyntaxNodePtr, TextUnit,\n };\n \n use crate::{\n     db::HirDatabase, semantics::PathResolution, Adt, Const, EnumVariant, Function, Local, MacroDef,\n-    ModPath, ModuleDef, Path, PathKind, Static, Struct, Trait, Type, TypeAlias, TypeParam,\n+    ModPath, ModuleDef, Path, PathKind, Static, Struct, StructField, Trait, Type, TypeAlias,\n+    TypeParam,\n };\n+use ra_db::CrateId;\n \n /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of\n /// original source files. It should not be used inside the HIR itself.\n@@ -164,23 +169,6 @@ impl SourceAnalyzer {\n         Some((struct_field.into(), local))\n     }\n \n-    pub(crate) fn resolve_record_literal(\n-        &self,\n-        db: &dyn HirDatabase,\n-        record_lit: &ast::RecordLit,\n-    ) -> Option<crate::VariantDef> {\n-        let expr_id = self.expr_id(db, &record_lit.clone().into())?;\n-        self.infer.as_ref()?.variant_resolution_for_expr(expr_id).map(|it| it.into())\n-    }\n-\n-    pub(crate) fn resolve_record_pattern(\n-        &self,\n-        record_pat: &ast::RecordPat,\n-    ) -> Option<crate::VariantDef> {\n-        let pat_id = self.pat_id(&record_pat.clone().into())?;\n-        self.infer.as_ref()?.variant_resolution_for_pat(pat_id).map(|it| it.into())\n-    }\n-\n     pub(crate) fn resolve_macro_call(\n         &self,\n         db: &dyn HirDatabase,\n@@ -231,6 +219,68 @@ impl SourceAnalyzer {\n         resolve_hir_path(db, &self.resolver, &hir_path)\n     }\n \n+    pub(crate) fn record_literal_missing_fields(\n+        &self,\n+        db: &dyn HirDatabase,\n+        literal: &ast::RecordLit,\n+    ) -> Option<Vec<(StructField, Type)>> {\n+        let krate = self.resolver.krate()?;\n+        let body = self.body.as_ref()?;\n+        let infer = self.infer.as_ref()?;\n+\n+        let expr_id = self.expr_id(db, &literal.clone().into())?;\n+        let substs = match &infer.type_of_expr[expr_id] {\n+            Ty::Apply(a_ty) => &a_ty.parameters,\n+            _ => return None,\n+        };\n+\n+        let (variant, missing_fields, _exhaustive) =\n+            record_literal_missing_fields(db, infer, expr_id, &body[expr_id])?;\n+        let res = self.missing_fields(db, krate, substs, variant, missing_fields);\n+        Some(res)\n+    }\n+\n+    pub(crate) fn record_pattern_missing_fields(\n+        &self,\n+        db: &dyn HirDatabase,\n+        pattern: &ast::RecordPat,\n+    ) -> Option<Vec<(StructField, Type)>> {\n+        let krate = self.resolver.krate()?;\n+        let body = self.body.as_ref()?;\n+        let infer = self.infer.as_ref()?;\n+\n+        let pat_id = self.pat_id(&pattern.clone().into())?;\n+        let substs = match &infer.type_of_pat[pat_id] {\n+            Ty::Apply(a_ty) => &a_ty.parameters,\n+            _ => return None,\n+        };\n+\n+        let (variant, missing_fields) =\n+            record_pattern_missing_fields(db, infer, pat_id, &body[pat_id])?;\n+        let res = self.missing_fields(db, krate, substs, variant, missing_fields);\n+        Some(res)\n+    }\n+\n+    fn missing_fields(\n+        &self,\n+        db: &dyn HirDatabase,\n+        krate: CrateId,\n+        substs: &Substs,\n+        variant: VariantId,\n+        missing_fields: Vec<LocalStructFieldId>,\n+    ) -> Vec<(StructField, Type)> {\n+        let field_types = db.field_types(variant);\n+\n+        missing_fields\n+            .into_iter()\n+            .map(|local_id| {\n+                let field = StructFieldId { parent: variant, local_id };\n+                let ty = field_types[local_id].clone().subst(substs);\n+                (field.into(), Type::new_with_resolver_inner(db, krate, &self.resolver, ty))\n+            })\n+            .collect()\n+    }\n+\n     pub(crate) fn expand(\n         &self,\n         db: &dyn HirDatabase,"}, {"sha": "9e9a9d047519c51ac721871b25768a35a0cb7442", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 59, "deletions": 15, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -235,7 +235,10 @@ impl From<PatId> for PatIdOrWild {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n-pub struct MatchCheckNotImplemented;\n+pub enum MatchCheckErr {\n+    NotImplemented,\n+    MalformedMatchArm,\n+}\n \n /// The return type of `is_useful` is either an indication of usefulness\n /// of the match arm, or an error in the case the match statement\n@@ -244,7 +247,7 @@ pub struct MatchCheckNotImplemented;\n ///\n /// The `std::result::Result` type is used here rather than a custom enum\n /// to allow the use of `?`.\n-pub type MatchCheckResult<T> = Result<T, MatchCheckNotImplemented>;\n+pub type MatchCheckResult<T> = Result<T, MatchCheckErr>;\n \n #[derive(Debug)]\n /// A row in a Matrix.\n@@ -335,29 +338,36 @@ impl PatStack {\n                     Expr::Literal(Literal::Bool(_)) => None,\n                     // perhaps this is actually unreachable given we have\n                     // already checked that these match arms have the appropriate type?\n-                    _ => return Err(MatchCheckNotImplemented),\n+                    _ => return Err(MatchCheckErr::NotImplemented),\n                 }\n             }\n             (Pat::Wild, constructor) => Some(self.expand_wildcard(cx, constructor)?),\n             (Pat::Path(_), Constructor::Enum(constructor)) => {\n-                // enums with no associated data become `Pat::Path`\n+                // unit enum variants become `Pat::Path`\n                 let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n                 if !enum_variant_matches(cx, pat_id, *constructor) {\n                     None\n                 } else {\n                     Some(self.to_tail())\n                 }\n             }\n-            (Pat::TupleStruct { args: ref pat_ids, .. }, Constructor::Enum(constructor)) => {\n+            (Pat::TupleStruct { args: ref pat_ids, .. }, Constructor::Enum(enum_constructor)) => {\n                 let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n-                if !enum_variant_matches(cx, pat_id, *constructor) {\n+                if !enum_variant_matches(cx, pat_id, *enum_constructor) {\n                     None\n                 } else {\n+                    // If the enum variant matches, then we need to confirm\n+                    // that the number of patterns aligns with the expected\n+                    // number of patterns for that enum variant.\n+                    if pat_ids.len() != constructor.arity(cx)? {\n+                        return Err(MatchCheckErr::MalformedMatchArm);\n+                    }\n+\n                     Some(self.replace_head_with(pat_ids))\n                 }\n             }\n-            (Pat::Or(_), _) => return Err(MatchCheckNotImplemented),\n-            (_, _) => return Err(MatchCheckNotImplemented),\n+            (Pat::Or(_), _) => return Err(MatchCheckErr::NotImplemented),\n+            (_, _) => return Err(MatchCheckErr::NotImplemented),\n         };\n \n         Ok(result)\n@@ -514,7 +524,7 @@ pub(crate) fn is_useful(\n         return if any_useful {\n             Ok(Usefulness::Useful)\n         } else if found_unimplemented {\n-            Err(MatchCheckNotImplemented)\n+            Err(MatchCheckErr::NotImplemented)\n         } else {\n             Ok(Usefulness::NotUseful)\n         };\n@@ -567,7 +577,7 @@ pub(crate) fn is_useful(\n                 }\n \n                 if found_unimplemented {\n-                    Err(MatchCheckNotImplemented)\n+                    Err(MatchCheckErr::NotImplemented)\n                 } else {\n                     Ok(Usefulness::NotUseful)\n                 }\n@@ -604,7 +614,7 @@ impl Constructor {\n                 match cx.db.enum_data(e.parent).variants[e.local_id].variant_data.as_ref() {\n                     VariantData::Tuple(struct_field_data) => struct_field_data.len(),\n                     VariantData::Unit => 0,\n-                    _ => return Err(MatchCheckNotImplemented),\n+                    _ => return Err(MatchCheckErr::NotImplemented),\n                 }\n             }\n         };\n@@ -637,20 +647,20 @@ fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> MatchCheckResult<Opt\n         Pat::Tuple(pats) => Some(Constructor::Tuple { arity: pats.len() }),\n         Pat::Lit(lit_expr) => match cx.body.exprs[lit_expr] {\n             Expr::Literal(Literal::Bool(val)) => Some(Constructor::Bool(val)),\n-            _ => return Err(MatchCheckNotImplemented),\n+            _ => return Err(MatchCheckErr::NotImplemented),\n         },\n         Pat::TupleStruct { .. } | Pat::Path(_) => {\n             let pat_id = pat.as_id().expect(\"we already know this pattern is not a wild\");\n             let variant_id =\n-                cx.infer.variant_resolution_for_pat(pat_id).ok_or(MatchCheckNotImplemented)?;\n+                cx.infer.variant_resolution_for_pat(pat_id).ok_or(MatchCheckErr::NotImplemented)?;\n             match variant_id {\n                 VariantId::EnumVariantId(enum_variant_id) => {\n                     Some(Constructor::Enum(enum_variant_id))\n                 }\n-                _ => return Err(MatchCheckNotImplemented),\n+                _ => return Err(MatchCheckErr::NotImplemented),\n             }\n         }\n-        _ => return Err(MatchCheckNotImplemented),\n+        _ => return Err(MatchCheckErr::NotImplemented),\n     };\n \n     Ok(res)\n@@ -1324,6 +1334,40 @@ mod tests {\n         check_diagnostic(content);\n     }\n \n+    #[test]\n+    fn malformed_match_arm_tuple_missing_pattern() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (0) {\n+                    () => (),\n+                }\n+            }\n+        \";\n+\n+        // Match arms with the incorrect type are filtered out.\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn malformed_match_arm_tuple_enum_missing_pattern() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B(u32),\n+            }\n+            fn test_fn() {\n+                match Either::A {\n+                    Either::A => (),\n+                    Either::B() => (),\n+                }\n+            }\n+        \";\n+\n+        // We are testing to be sure we don't panic here when the match\n+        // arm `Either::B` is missing its pattern.\n+        check_no_diagnostic(content);\n+    }\n+\n     #[test]\n     fn enum_not_in_scope() {\n         let content = r\""}, {"sha": "e45e9ea14d7a0273583bacc9b63de789b84e203b", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 91, "deletions": 67, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -2,12 +2,8 @@\n \n use std::sync::Arc;\n \n-use hir_def::{\n-    path::{path, Path},\n-    resolver::HasResolver,\n-    AdtId, FunctionId,\n-};\n-use hir_expand::{diagnostics::DiagnosticSink, name::Name};\n+use hir_def::{path::path, resolver::HasResolver, AdtId, FunctionId};\n+use hir_expand::diagnostics::DiagnosticSink;\n use ra_syntax::{ast, AstPtr};\n use rustc_hash::FxHashSet;\n \n@@ -28,7 +24,7 @@ pub use hir_def::{\n         ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal, LogicOp,\n         MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement, UnaryOp,\n     },\n-    VariantId,\n+    LocalStructFieldId, VariantId,\n };\n \n pub struct ExprValidator<'a, 'b: 'a> {\n@@ -49,14 +45,37 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n     pub fn validate_body(&mut self, db: &dyn HirDatabase) {\n         let body = db.body(self.func.into());\n \n-        for e in body.exprs.iter() {\n-            if let (id, Expr::RecordLit { path, fields, spread }) = e {\n-                self.validate_record_literal(id, path, fields, *spread, db);\n-            } else if let (id, Expr::Match { expr, arms }) = e {\n+        for (id, expr) in body.exprs.iter() {\n+            if let Some((variant_def, missed_fields, true)) =\n+                record_literal_missing_fields(db, &self.infer, id, expr)\n+            {\n+                // XXX: only look at source_map if we do have missing fields\n+                let (_, source_map) = db.body_with_source_map(self.func.into());\n+\n+                if let Ok(source_ptr) = source_map.expr_syntax(id) {\n+                    if let Some(expr) = source_ptr.value.left() {\n+                        let root = source_ptr.file_syntax(db.upcast());\n+                        if let ast::Expr::RecordLit(record_lit) = expr.to_node(&root) {\n+                            if let Some(field_list) = record_lit.record_field_list() {\n+                                let variant_data = variant_data(db.upcast(), variant_def);\n+                                let missed_fields = missed_fields\n+                                    .into_iter()\n+                                    .map(|idx| variant_data.fields()[idx].name.clone())\n+                                    .collect();\n+                                self.sink.push(MissingFields {\n+                                    file: source_ptr.file_id,\n+                                    field_list: AstPtr::new(&field_list),\n+                                    missed_fields,\n+                                })\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            if let Expr::Match { expr, arms } = expr {\n                 self.validate_match(id, *expr, arms, db, self.infer.clone());\n             }\n         }\n-\n         let body_expr = &body[body.body_expr];\n         if let Expr::Block { tail: Some(t), .. } = body_expr {\n             self.validate_results_in_tail_expr(body.body_expr, *t, db);\n@@ -145,61 +164,6 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n     }\n \n-    fn validate_record_literal(\n-        &mut self,\n-        id: ExprId,\n-        _path: &Option<Path>,\n-        fields: &[RecordLitField],\n-        spread: Option<ExprId>,\n-        db: &dyn HirDatabase,\n-    ) {\n-        if spread.is_some() {\n-            return;\n-        };\n-        let variant_def: VariantId = match self.infer.variant_resolution_for_expr(id) {\n-            Some(VariantId::UnionId(_)) | None => return,\n-            Some(it) => it,\n-        };\n-        if let VariantId::UnionId(_) = variant_def {\n-            return;\n-        }\n-\n-        let variant_data = variant_data(db.upcast(), variant_def);\n-\n-        let lit_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();\n-        let missed_fields: Vec<Name> = variant_data\n-            .fields()\n-            .iter()\n-            .filter_map(|(_f, d)| {\n-                let name = d.name.clone();\n-                if lit_fields.contains(&name) {\n-                    None\n-                } else {\n-                    Some(name)\n-                }\n-            })\n-            .collect();\n-        if missed_fields.is_empty() {\n-            return;\n-        }\n-        let (_, source_map) = db.body_with_source_map(self.func.into());\n-\n-        if let Ok(source_ptr) = source_map.expr_syntax(id) {\n-            if let Some(expr) = source_ptr.value.left() {\n-                let root = source_ptr.file_syntax(db.upcast());\n-                if let ast::Expr::RecordLit(record_lit) = expr.to_node(&root) {\n-                    if let Some(field_list) = record_lit.record_field_list() {\n-                        self.sink.push(MissingFields {\n-                            file: source_ptr.file_id,\n-                            field_list: AstPtr::new(&field_list),\n-                            missed_fields,\n-                        })\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn validate_results_in_tail_expr(&mut self, body_id: ExprId, id: ExprId, db: &dyn HirDatabase) {\n         // the mismatch will be on the whole block currently\n         let mismatch = match self.infer.type_mismatch_for_expr(body_id) {\n@@ -232,3 +196,63 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n     }\n }\n+\n+pub fn record_literal_missing_fields(\n+    db: &dyn HirDatabase,\n+    infer: &InferenceResult,\n+    id: ExprId,\n+    expr: &Expr,\n+) -> Option<(VariantId, Vec<LocalStructFieldId>, /*exhaustive*/ bool)> {\n+    let (fields, exhausitve) = match expr {\n+        Expr::RecordLit { path: _, fields, spread } => (fields, spread.is_none()),\n+        _ => return None,\n+    };\n+\n+    let variant_def = infer.variant_resolution_for_expr(id)?;\n+    if let VariantId::UnionId(_) = variant_def {\n+        return None;\n+    }\n+\n+    let variant_data = variant_data(db.upcast(), variant_def);\n+\n+    let specified_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();\n+    let missed_fields: Vec<LocalStructFieldId> = variant_data\n+        .fields()\n+        .iter()\n+        .filter_map(|(f, d)| if specified_fields.contains(&d.name) { None } else { Some(f) })\n+        .collect();\n+    if missed_fields.is_empty() {\n+        return None;\n+    }\n+    Some((variant_def, missed_fields, exhausitve))\n+}\n+\n+pub fn record_pattern_missing_fields(\n+    db: &dyn HirDatabase,\n+    infer: &InferenceResult,\n+    id: PatId,\n+    pat: &Pat,\n+) -> Option<(VariantId, Vec<LocalStructFieldId>)> {\n+    let fields = match pat {\n+        Pat::Record { path: _, args } => args,\n+        _ => return None,\n+    };\n+\n+    let variant_def = infer.variant_resolution_for_pat(id)?;\n+    if let VariantId::UnionId(_) = variant_def {\n+        return None;\n+    }\n+\n+    let variant_data = variant_data(db.upcast(), variant_def);\n+\n+    let specified_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();\n+    let missed_fields: Vec<LocalStructFieldId> = variant_data\n+        .fields()\n+        .iter()\n+        .filter_map(|(f, d)| if specified_fields.contains(&d.name) { None } else { Some(f) })\n+        .collect();\n+    if missed_fields.is_empty() {\n+        return None;\n+    }\n+    Some((variant_def, missed_fields))\n+}"}, {"sha": "608408d88c2011c4c3c4ce289b30c50d17d7f947", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -336,7 +336,7 @@ fn no_such_field_with_feature_flag_diagnostics() {\n             pub(crate) fn new(my_val: usize, bar: bool) -> Self {\n                 Self { my_val, bar }\n             }\n-        \n+\n             #[cfg(not(feature = \"foo\"))]\n             pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\n                 Self { my_val }"}, {"sha": "f46bcee5c43864f50163f1fe8867a2420a3fae0a", "filename": "crates/ra_ide/src/completion/complete_record.rs", "status": "modified", "additions": 44, "deletions": 52, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -1,65 +1,24 @@\n //! Complete fields in record literals and patterns.\n-use ra_syntax::{ast, ast::NameOwner, SmolStr};\n-\n use crate::completion::{CompletionContext, Completions};\n \n pub(super) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    let (ty, variant, already_present_fields) =\n-        match (ctx.record_lit_pat.as_ref(), ctx.record_lit_syntax.as_ref()) {\n-            (None, None) => return None,\n-            (Some(_), Some(_)) => unreachable!(\"A record cannot be both a literal and a pattern\"),\n-            (Some(record_pat), _) => (\n-                ctx.sema.type_of_pat(&record_pat.clone().into())?,\n-                ctx.sema.resolve_record_pattern(record_pat)?,\n-                pattern_ascribed_fields(record_pat),\n-            ),\n-            (_, Some(record_lit)) => (\n-                ctx.sema.type_of_expr(&record_lit.clone().into())?,\n-                ctx.sema.resolve_record_literal(record_lit)?,\n-                literal_ascribed_fields(record_lit),\n-            ),\n-        };\n+    let missing_fields = match (ctx.record_lit_pat.as_ref(), ctx.record_lit_syntax.as_ref()) {\n+        (None, None) => return None,\n+        (Some(_), Some(_)) => unreachable!(\"A record cannot be both a literal and a pattern\"),\n+        (Some(record_pat), _) => ctx.sema.record_pattern_missing_fields(record_pat),\n+        (_, Some(record_lit)) => ctx.sema.record_literal_missing_fields(record_lit),\n+    };\n \n-    for (field, field_ty) in ty.variant_fields(ctx.db, variant).into_iter().filter(|(field, _)| {\n-        // FIXME: already_present_names better be `Vec<hir::Name>`\n-        !already_present_fields.contains(&SmolStr::from(field.name(ctx.db).to_string()))\n-    }) {\n-        acc.add_field(ctx, field, &field_ty);\n+    for (field, ty) in missing_fields {\n+        acc.add_field(ctx, field, &ty)\n     }\n-    Some(())\n-}\n-\n-fn literal_ascribed_fields(record_lit: &ast::RecordLit) -> Vec<SmolStr> {\n-    record_lit\n-        .record_field_list()\n-        .map(|field_list| field_list.fields())\n-        .map(|fields| {\n-            fields\n-                .into_iter()\n-                .filter_map(|field| field.name_ref())\n-                .map(|name_ref| name_ref.text().clone())\n-                .collect()\n-        })\n-        .unwrap_or_default()\n-}\n \n-fn pattern_ascribed_fields(record_pat: &ast::RecordPat) -> Vec<SmolStr> {\n-    record_pat\n-        .record_field_pat_list()\n-        .map(|pat_list| {\n-            pat_list\n-                .record_field_pats()\n-                .filter_map(|fild_pat| fild_pat.name())\n-                .chain(pat_list.bind_pats().filter_map(|bind_pat| bind_pat.name()))\n-                .map(|name| name.text().clone())\n-                .collect()\n-        })\n-        .unwrap_or_default()\n+    Some(())\n }\n \n #[cfg(test)]\n mod tests {\n-    mod record_lit_tests {\n+    mod record_pat_tests {\n         use insta::assert_debug_snapshot;\n \n         use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n@@ -205,7 +164,7 @@ mod tests {\n         }\n     }\n \n-    mod record_pat_tests {\n+    mod record_lit_tests {\n         use insta::assert_debug_snapshot;\n \n         use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n@@ -410,5 +369,38 @@ mod tests {\n         ]\n         \"###);\n         }\n+\n+        #[test]\n+        fn completes_functional_update() {\n+            let completions = complete(\n+                r\"\n+            struct S {\n+                foo1: u32,\n+                foo2: u32,\n+            }\n+\n+            fn main() {\n+                let foo1 = 1;\n+                let s = S {\n+                    foo1,\n+                    <|>\n+                    .. loop {}\n+                }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"foo2\",\n+                source_range: [221; 221),\n+                delete: [221; 221),\n+                insert: \"foo2\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n     }\n }"}, {"sha": "6ec13bd80fbfb188b874add97e889120a1265f82", "filename": "crates/ra_ide/src/snapshots/highlight_injection.html", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_injection.html", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_injection.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_injection.html?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -0,0 +1,39 @@\n+\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.lifetime           { color: #DFAF8F; font-style: italic; }\n+.comment            { color: #7F9F7F; }\n+.struct, .enum      { color: #7CB8BB; }\n+.enum_variant       { color: #BDE0F3; }\n+.string_literal     { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.builtin_type       { color: #8CD0D3; }\n+.type_param         { color: #DFAF8F; }\n+.attribute          { color: #94BFF3; }\n+.numeric_literal    { color: #BFEBBF; }\n+.macro              { color: #94BFF3; }\n+.module             { color: #AFD8AF; }\n+.variable           { color: #DCDCCC; }\n+.mutable            { text-decoration: underline; }\n+\n+.keyword            { color: #F0DFAF; font-weight: bold; }\n+.keyword.unsafe     { color: #BC8383; font-weight: bold; }\n+.control            { font-style: italic; }\n+</style>\n+<pre><code><span class=\"keyword\">fn</span> <span class=\"function declaration\">fixture</span>(<span class=\"variable declaration\">ra_fixture</span>: &<span class=\"builtin_type\">str</span>) {}\n+\n+<span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span>() {\n+    <span class=\"function\">fixture</span>(<span class=\"string_literal\">r#\"</span>\n+        <span class=\"keyword\">trait</span> <span class=\"trait declaration\">Foo</span> {\n+            <span class=\"keyword\">fn</span> <span class=\"function declaration\">foo</span>() {\n+                <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"2 + 2 = {}\"</span>, <span class=\"numeric_literal\">4</span>);\n+            }\n+        }<span class=\"string_literal\">\"#</span>\n+    );\n+}</code></pre>\n\\ No newline at end of file"}, {"sha": "214dcbb620c32e725336dbbfe3caade697cd63ea", "filename": "crates/ra_ide/src/snapshots/highlighting.html", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -26,7 +26,7 @@\n .keyword.unsafe     { color: #BC8383; font-weight: bold; }\n .control            { font-style: italic; }\n </style>\n-<pre><code><span class=\"attribute\">#</span><span class=\"attribute\">[</span><span class=\"attribute\">derive</span><span class=\"attribute\">(</span><span class=\"attribute\">Clone</span><span class=\"attribute\">,</span><span class=\"attribute\"> </span><span class=\"attribute\">Debug</span><span class=\"attribute\">)</span><span class=\"attribute\">]</span>\n+<pre><code><span class=\"attribute\">#[derive(Clone, Debug)]</span>\n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">Foo</span> {\n     <span class=\"keyword\">pub</span> <span class=\"field declaration\">x</span>: <span class=\"builtin_type\">i32</span>,\n     <span class=\"keyword\">pub</span> <span class=\"field declaration\">y</span>: <span class=\"builtin_type\">i32</span>,\n@@ -36,19 +36,19 @@\n     <span class=\"function\">foo</span>::&lt;<span class=\"lifetime\">'a</span>, <span class=\"builtin_type\">i32</span>&gt;()\n }\n \n-<span class=\"macro\">macro_rules</span><span class=\"macro\">!</span> def_fn {\n+<span class=\"macro\">macro_rules!</span> def_fn {\n     ($($tt:tt)*) =&gt; {$($tt)*}\n }\n \n-<span class=\"macro\">def_fn</span><span class=\"macro\">!</span> {\n+<span class=\"macro\">def_fn!</span> {\n     <span class=\"keyword\">fn</span> <span class=\"function declaration\">bar</span>() -&gt; <span class=\"builtin_type\">u32</span> {\n         <span class=\"numeric_literal\">100</span>\n     }\n }\n \n <span class=\"comment\">// comment</span>\n <span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span>() {\n-    <span class=\"macro\">println</span><span class=\"macro\">!</span>(<span class=\"string_literal\">\"Hello, {}!\"</span>, <span class=\"numeric_literal\">92</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello, {}!\"</span>, <span class=\"numeric_literal\">92</span>);\n \n     <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable declaration mutable\">vec</span> = Vec::new();\n     <span class=\"keyword control\">if</span> <span class=\"keyword\">true</span> {\n@@ -73,7 +73,7 @@\n <span class=\"keyword\">impl</span>&lt;<span class=\"type_param declaration\">T</span>&gt; <span class=\"enum\">Option</span>&lt;<span class=\"type_param\">T</span>&gt; {\n     <span class=\"keyword\">fn</span> <span class=\"function declaration\">and</span>&lt;<span class=\"type_param declaration\">U</span>&gt;(<span class=\"keyword\">self</span>, <span class=\"variable declaration\">other</span>: <span class=\"enum\">Option</span>&lt;<span class=\"type_param\">U</span>&gt;) -&gt; <span class=\"enum\">Option</span>&lt;(<span class=\"type_param\">T</span>, <span class=\"type_param\">U</span>)&gt; {\n         <span class=\"keyword control\">match</span> <span class=\"variable\">other</span> {\n-            <span class=\"enum_variant\">None</span> =&gt; <span class=\"macro\">unimplemented</span><span class=\"macro\">!</span>(),\n+            <span class=\"enum_variant\">None</span> =&gt; <span class=\"macro\">unimplemented!</span>(),\n             <span class=\"variable declaration\">Nope</span> =&gt; <span class=\"variable\">Nope</span>,\n         }\n     }"}, {"sha": "83d161f45ac4d03617e1caf890932effe4b72753", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 54, "deletions": 5, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -24,7 +24,7 @@ use crate::{call_info::call_info_for_token, Analysis, FileId};\n pub(crate) use html::highlight_as_html;\n pub use tags::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag};\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct HighlightedRange {\n     pub range: TextRange,\n     pub highlight: Highlight,\n@@ -55,13 +55,55 @@ pub(crate) fn highlight(\n     };\n \n     let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n-    let mut res = Vec::new();\n+    // We use a stack for the DFS traversal below.\n+    // When we leave a node, the we use it to flatten the highlighted ranges.\n+    let mut res: Vec<Vec<HighlightedRange>> = vec![Vec::new()];\n \n     let mut current_macro_call: Option<ast::MacroCall> = None;\n \n     // Walk all nodes, keeping track of whether we are inside a macro or not.\n     // If in macro, expand it first and highlight the expanded code.\n     for event in root.preorder_with_tokens() {\n+        match &event {\n+            WalkEvent::Enter(_) => res.push(Vec::new()),\n+            WalkEvent::Leave(_) => {\n+                /* Flattens the highlighted ranges.\n+                 *\n+                 * For example `#[cfg(feature = \"foo\")]` contains the nested ranges:\n+                 * 1) parent-range: Attribute [0, 23)\n+                 * 2) child-range: String [16, 21)\n+                 *\n+                 * The following code implements the flattening, for our example this results to:\n+                 * `[Attribute [0, 16), String [16, 21), Attribute [21, 23)]`\n+                 */\n+                let children = res.pop().unwrap();\n+                let prev = res.last_mut().unwrap();\n+                let needs_flattening = !children.is_empty()\n+                    && !prev.is_empty()\n+                    && children.first().unwrap().range.is_subrange(&prev.last().unwrap().range);\n+                if !needs_flattening {\n+                    prev.extend(children);\n+                } else {\n+                    let mut parent = prev.pop().unwrap();\n+                    for ele in children {\n+                        assert!(ele.range.is_subrange(&parent.range));\n+                        let mut cloned = parent.clone();\n+                        parent.range = TextRange::from_to(parent.range.start(), ele.range.start());\n+                        cloned.range = TextRange::from_to(ele.range.end(), cloned.range.end());\n+                        if !parent.range.is_empty() {\n+                            prev.push(parent);\n+                        }\n+                        prev.push(ele);\n+                        parent = cloned;\n+                    }\n+                    if !parent.range.is_empty() {\n+                        prev.push(parent);\n+                    }\n+                }\n+            }\n+        };\n+        let current = res.last_mut().expect(\"during DFS traversal, the stack must not be empty\");\n+\n         let event_range = match &event {\n             WalkEvent::Enter(it) => it.text_range(),\n             WalkEvent::Leave(it) => it.text_range(),\n@@ -77,7 +119,7 @@ pub(crate) fn highlight(\n             WalkEvent::Enter(Some(mc)) => {\n                 current_macro_call = Some(mc.clone());\n                 if let Some(range) = macro_call_range(&mc) {\n-                    res.push(HighlightedRange {\n+                    current.push(HighlightedRange {\n                         range,\n                         highlight: HighlightTag::Macro.into(),\n                         binding_hash: None,\n@@ -119,18 +161,25 @@ pub(crate) fn highlight(\n \n         if let Some(token) = element.as_token().cloned().and_then(ast::RawString::cast) {\n             let expanded = element_to_highlight.as_token().unwrap().clone();\n-            if highlight_injection(&mut res, &sema, token, expanded).is_some() {\n+            if highlight_injection(current, &sema, token, expanded).is_some() {\n                 continue;\n             }\n         }\n \n         if let Some((highlight, binding_hash)) =\n             highlight_element(&sema, &mut bindings_shadow_count, element_to_highlight)\n         {\n-            res.push(HighlightedRange { range, highlight, binding_hash });\n+            current.push(HighlightedRange { range, highlight, binding_hash });\n         }\n     }\n \n+    assert_eq!(res.len(), 1, \"after DFS traversal, the stack should only contain a single element\");\n+    let res = res.pop().unwrap();\n+    // Check that ranges are sorted and disjoint\n+    assert!(res\n+        .iter()\n+        .zip(res.iter().skip(1))\n+        .all(|(left, right)| left.range.end() <= right.range.start()));\n     res\n }\n "}, {"sha": "4496529a101e77fdff2e6e9d451a19d17e832c85", "filename": "crates/ra_ide/src/syntax_highlighting/html.rs", "status": "modified", "additions": 25, "deletions": 41, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -1,9 +1,9 @@\n //! Renders a bit of code as HTML.\n \n use ra_db::SourceDatabase;\n-use ra_syntax::AstNode;\n+use ra_syntax::{AstNode, TextUnit};\n \n-use crate::{FileId, HighlightedRange, RootDatabase};\n+use crate::{FileId, RootDatabase};\n \n use super::highlight;\n \n@@ -21,51 +21,35 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n         )\n     }\n \n-    let mut ranges = highlight(db, file_id, None);\n-    ranges.sort_by_key(|it| it.range.start());\n-    // quick non-optimal heuristic to intersect token ranges and highlighted ranges\n-    let mut frontier = 0;\n-    let mut could_intersect: Vec<&HighlightedRange> = Vec::new();\n-\n+    let ranges = highlight(db, file_id, None);\n+    let text = parse.tree().syntax().to_string();\n+    let mut prev_pos = TextUnit::from(0);\n     let mut buf = String::new();\n     buf.push_str(&STYLE);\n     buf.push_str(\"<pre><code>\");\n-    let tokens = parse.tree().syntax().descendants_with_tokens().filter_map(|it| it.into_token());\n-    for token in tokens {\n-        could_intersect.retain(|it| token.text_range().start() <= it.range.end());\n-        while let Some(r) = ranges.get(frontier) {\n-            if r.range.start() <= token.text_range().end() {\n-                could_intersect.push(r);\n-                frontier += 1;\n-            } else {\n-                break;\n-            }\n-        }\n-        let text = html_escape(&token.text());\n-        let ranges = could_intersect\n-            .iter()\n-            .filter(|it| token.text_range().is_subrange(&it.range))\n-            .collect::<Vec<_>>();\n-        if ranges.is_empty() {\n+    for range in &ranges {\n+        if range.range.start() > prev_pos {\n+            let curr = &text[prev_pos.to_usize()..range.range.start().to_usize()];\n+            let text = html_escape(curr);\n             buf.push_str(&text);\n-        } else {\n-            let classes = ranges\n-                .iter()\n-                .map(|it| it.highlight.to_string().replace('.', \" \"))\n-                .collect::<Vec<_>>()\n-                .join(\" \");\n-            let binding_hash = ranges.first().and_then(|x| x.binding_hash);\n-            let color = match (rainbow, binding_hash) {\n-                (true, Some(hash)) => format!(\n-                    \" data-binding-hash=\\\"{}\\\" style=\\\"color: {};\\\"\",\n-                    hash,\n-                    rainbowify(hash)\n-                ),\n-                _ => \"\".into(),\n-            };\n-            buf.push_str(&format!(\"<span class=\\\"{}\\\"{}>{}</span>\", classes, color, text));\n         }\n+        let curr = &text[range.range.start().to_usize()..range.range.end().to_usize()];\n+\n+        let class = range.highlight.to_string().replace('.', \" \");\n+        let color = match (rainbow, range.binding_hash) {\n+            (true, Some(hash)) => {\n+                format!(\" data-binding-hash=\\\"{}\\\" style=\\\"color: {};\\\"\", hash, rainbowify(hash))\n+            }\n+            _ => \"\".into(),\n+        };\n+        buf.push_str(&format!(\"<span class=\\\"{}\\\"{}>{}</span>\", class, color, html_escape(curr)));\n+\n+        prev_pos = range.range.end();\n     }\n+    // Add the remaining (non-highlighted) text\n+    let curr = &text[prev_pos.to_usize()..];\n+    let text = html_escape(curr);\n+    buf.push_str(&text);\n     buf.push_str(\"</code></pre>\");\n     buf\n }"}, {"sha": "110887c2ac4230aa21eec5b056788eae676f8323", "filename": "crates/ra_ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -131,3 +131,28 @@ fn test_ranges() {\n \n     assert_eq!(&highlights[0].highlight.to_string(), \"field.declaration\");\n }\n+\n+#[test]\n+fn test_flattening() {\n+    let (analysis, file_id) = single_file(\n+        r##\"\n+fn fixture(ra_fixture: &str) {}\n+\n+fn main() {\n+    fixture(r#\"\n+        trait Foo {\n+            fn foo() {\n+                println!(\"2 + 2 = {}\", 4);\n+            }\n+        }\"#\n+    );\n+}\"##\n+        .trim(),\n+    );\n+\n+    let dst_file = project_dir().join(\"crates/ra_ide/src/snapshots/highlight_injection.html\");\n+    let actual_html = &analysis.highlight_as_html(file_id, false).unwrap();\n+    let expected_html = &read_text(&dst_file);\n+    fs::write(dst_file, &actual_html).unwrap();\n+    assert_eq_text!(expected_html, actual_html);\n+}"}, {"sha": "254318e239d2938c8dbee05fb30a9f5e3748f62e", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -1614,6 +1614,23 @@ fn test_issue_2520() {\n     );\n }\n \n+#[test]\n+fn test_issue_3861() {\n+    let macro_fixture = parse_macro(\n+        r#\"\n+        macro_rules! rgb_color {\n+            ($p:expr, $t: ty) => {\n+                pub fn new() {\n+                    let _ = 0 as $t << $p;\n+                }\n+            };\n+        }\n+    \"#,\n+    );\n+\n+    macro_fixture.expand_items(r#\"rgb_color!(8 + 8, u32);\"#);\n+}\n+\n #[test]\n fn test_repeat_bad_var() {\n     // FIXME: the second rule of the macro should be removed and an error about"}, {"sha": "386969d2d7e70282d46d018d4a8632bfc968fdb5", "filename": "crates/ra_parser/src/grammar/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -7,7 +7,7 @@ pub(super) const TYPE_FIRST: TokenSet = paths::PATH_FIRST.union(token_set![\n     DYN_KW, L_ANGLE,\n ]);\n \n-const TYPE_RECOVERY_SET: TokenSet = token_set![R_PAREN, COMMA];\n+const TYPE_RECOVERY_SET: TokenSet = token_set![R_PAREN, COMMA, L_DOLLAR];\n \n pub(crate) fn type_(p: &mut Parser) {\n     type_with_bounds_cond(p, true);"}, {"sha": "55d93917c4cf2520047f0e6cf52e8f4e8deff5ec", "filename": "crates/ra_proc_macro_srv/src/proc_macro/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fdiagnostic.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -54,12 +54,14 @@ pub struct Diagnostic {\n }\n \n macro_rules! diagnostic_child_methods {\n-    ($spanned:ident, $regular:ident, $level:expr) => (\n+    ($spanned:ident, $regular:ident, $level:expr) => {\n         /// Adds a new child diagnostic message to `self` with the level\n         /// identified by this method's name with the given `spans` and\n         /// `message`.\n         pub fn $spanned<S, T>(mut self, spans: S, message: T) -> Diagnostic\n-            where S: MultiSpan, T: Into<String>\n+        where\n+            S: MultiSpan,\n+            T: Into<String>,\n         {\n             self.children.push(Diagnostic::spanned(spans, $level, message));\n             self\n@@ -71,7 +73,7 @@ macro_rules! diagnostic_child_methods {\n             self.children.push(Diagnostic::new($level, message));\n             self\n         }\n-    )\n+    };\n }\n \n /// Iterator over the children diagnostics of a `Diagnostic`."}, {"sha": "ee0dc97223c0302bb169c3131c5ae48d3aa755f9", "filename": "crates/ra_proc_macro_srv/src/proc_macro/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fmod.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -169,13 +169,13 @@ pub mod token_stream {\n pub struct Span(bridge::client::Span);\n \n macro_rules! diagnostic_method {\n-    ($name:ident, $level:expr) => (\n+    ($name:ident, $level:expr) => {\n         /// Creates a new `Diagnostic` with the given `message` at the span\n         /// `self`.\n         pub fn $name<T: Into<String>>(self, message: T) -> Diagnostic {\n             Diagnostic::spanned(self, $level, message)\n         }\n-    )\n+    };\n }\n \n impl Span {"}, {"sha": "8d1098036d40f8a40091bebb729c4661b364f3b9", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -316,7 +316,7 @@ impl<'a> SyntaxRewriter<'a> {\n     }\n }\n \n-impl<'a> ops::AddAssign for SyntaxRewriter<'_> {\n+impl ops::AddAssign for SyntaxRewriter<'_> {\n     fn add_assign(&mut self, rhs: SyntaxRewriter) {\n         assert!(rhs.f.is_none());\n         self.replacements.extend(rhs.replacements)"}, {"sha": "abd126340c9bd6b24b2bcf3ae2db8865260d8f3c", "filename": "docs/user/readme.adoc", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/docs%2Fuser%2Freadme.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/docs%2Fuser%2Freadme.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Freadme.adoc?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -187,30 +187,7 @@ Prerequisites:\n \n `LSP` package.\n \n-Installation:\n-\n-1. Invoke the command palette with <kbd>Ctrl+Shift+P</kbd>\n-2. Type `LSP Settings` to open the LSP preferences editor\n-3. Add the following LSP client definition to your settings:\n-+\n-[source,json]\n-----\n-\"rust-analyzer\": {\n-    \"command\": [\"rust-analyzer\"],\n-    \"languageId\": \"rust\",\n-    \"scopes\": [\"source.rust\"],\n-    \"syntaxes\": [\n-        \"Packages/Rust/Rust.sublime-syntax\",\n-        \"Packages/Rust Enhanced/RustEnhanced.sublime-syntax\"\n-    ],\n-    \"initializationOptions\": {\n-      \"featureFlags\": {\n-      }\n-    },\n-}\n-----\n-\n-4. You can now invoke the command palette and type LSP enable to locally/globally enable the rust-analyzer LSP (type LSP enable, then choose either locally or globally, then select rust-analyzer)\n+Invoke the command palette (`ctrl+shift+p`) and type LSP enable to locally/globally enable the rust-analyzer LSP (type LSP enable, then choose either locally or globally, then select rust-analyzer)\n \n == Usage\n "}, {"sha": "eb4f299a1209db9f11f0e6e2d4b2a37d1f512557", "filename": "editors/code/package-lock.json", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/editors%2Fcode%2Fpackage-lock.json", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/editors%2Fcode%2Fpackage-lock.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage-lock.json?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -115,25 +115,25 @@\n             \"dev\": true\n         },\n         \"@typescript-eslint/eslint-plugin\": {\n-            \"version\": \"2.26.0\",\n-            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-2.26.0.tgz\",\n-            \"integrity\": \"sha512-4yUnLv40bzfzsXcTAtZyTjbiGUXMrcIJcIMioI22tSOyAxpdXiZ4r7YQUU8Jj6XXrLz9d5aMHPQf5JFR7h27Nw==\",\n+            \"version\": \"2.27.0\",\n+            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-2.27.0.tgz\",\n+            \"integrity\": \"sha512-/my+vVHRN7zYgcp0n4z5A6HAK7bvKGBiswaM5zIlOQczsxj/aiD7RcgD+dvVFuwFaGh5+kM7XA6Q6PN0bvb1tw==\",\n             \"dev\": true,\n             \"requires\": {\n-                \"@typescript-eslint/experimental-utils\": \"2.26.0\",\n+                \"@typescript-eslint/experimental-utils\": \"2.27.0\",\n                 \"functional-red-black-tree\": \"^1.0.1\",\n                 \"regexpp\": \"^3.0.0\",\n                 \"tsutils\": \"^3.17.1\"\n             }\n         },\n         \"@typescript-eslint/experimental-utils\": {\n-            \"version\": \"2.26.0\",\n-            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/experimental-utils/-/experimental-utils-2.26.0.tgz\",\n-            \"integrity\": \"sha512-RELVoH5EYd+JlGprEyojUv9HeKcZqF7nZUGSblyAw1FwOGNnmQIU8kxJ69fttQvEwCsX5D6ECJT8GTozxrDKVQ==\",\n+            \"version\": \"2.27.0\",\n+            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/experimental-utils/-/experimental-utils-2.27.0.tgz\",\n+            \"integrity\": \"sha512-vOsYzjwJlY6E0NJRXPTeCGqjv5OHgRU1kzxHKWJVPjDYGbPgLudBXjIlc+OD1hDBZ4l1DLbOc5VjofKahsu9Jw==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"@types/json-schema\": \"^7.0.3\",\n-                \"@typescript-eslint/typescript-estree\": \"2.26.0\",\n+                \"@typescript-eslint/typescript-estree\": \"2.27.0\",\n                 \"eslint-scope\": \"^5.0.0\",\n                 \"eslint-utils\": \"^2.0.0\"\n             },\n@@ -150,21 +150,21 @@\n             }\n         },\n         \"@typescript-eslint/parser\": {\n-            \"version\": \"2.26.0\",\n-            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/parser/-/parser-2.26.0.tgz\",\n-            \"integrity\": \"sha512-+Xj5fucDtdKEVGSh9353wcnseMRkPpEAOY96EEenN7kJVrLqy/EVwtIh3mxcUz8lsFXW1mT5nN5vvEam/a5HiQ==\",\n+            \"version\": \"2.27.0\",\n+            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/parser/-/parser-2.27.0.tgz\",\n+            \"integrity\": \"sha512-HFUXZY+EdwrJXZo31DW4IS1ujQW3krzlRjBrFRrJcMDh0zCu107/nRfhk/uBasO8m0NVDbBF5WZKcIUMRO7vPg==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"@types/eslint-visitor-keys\": \"^1.0.0\",\n-                \"@typescript-eslint/experimental-utils\": \"2.26.0\",\n-                \"@typescript-eslint/typescript-estree\": \"2.26.0\",\n+                \"@typescript-eslint/experimental-utils\": \"2.27.0\",\n+                \"@typescript-eslint/typescript-estree\": \"2.27.0\",\n                 \"eslint-visitor-keys\": \"^1.1.0\"\n             }\n         },\n         \"@typescript-eslint/typescript-estree\": {\n-            \"version\": \"2.26.0\",\n-            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-2.26.0.tgz\",\n-            \"integrity\": \"sha512-3x4SyZCLB4zsKsjuhxDLeVJN6W29VwBnYpCsZ7vIdPel9ZqLfIZJgJXO47MNUkurGpQuIBALdPQKtsSnWpE1Yg==\",\n+            \"version\": \"2.27.0\",\n+            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-2.27.0.tgz\",\n+            \"integrity\": \"sha512-t2miCCJIb/FU8yArjAvxllxbTiyNqaXJag7UOpB5DVoM3+xnjeOngtqlJkLRnMtzaRcJhe3CIR9RmL40omubhg==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"debug\": \"^4.1.1\",\n@@ -1367,9 +1367,9 @@\n             }\n         },\n         \"regexpp\": {\n-            \"version\": \"3.0.0\",\n-            \"resolved\": \"https://registry.npmjs.org/regexpp/-/regexpp-3.0.0.tgz\",\n-            \"integrity\": \"sha512-Z+hNr7RAVWxznLPuA7DIh8UNX1j9CDrUQxskw9IrBE1Dxue2lyXT+shqEIeLUjrokxIP8CMy1WkjgG3rTsd5/g==\",\n+            \"version\": \"3.1.0\",\n+            \"resolved\": \"https://registry.npmjs.org/regexpp/-/regexpp-3.1.0.tgz\",\n+            \"integrity\": \"sha512-ZOIzd8yVsQQA7j8GCSlPGXwg5PfmA1mrq0JP4nGhh54LaKN3xdai/vHUDu74pKwV8OxseMS65u2NImosQcSD0Q==\",\n             \"dev\": true\n         },\n         \"resolve\": {\n@@ -1407,9 +1407,9 @@\n             }\n         },\n         \"rollup\": {\n-            \"version\": \"2.3.2\",\n-            \"resolved\": \"https://registry.npmjs.org/rollup/-/rollup-2.3.2.tgz\",\n-            \"integrity\": \"sha512-p66+fbfaUUOGE84sHXAOgfeaYQMslgAazoQMp//nlR519R61213EPFgrMZa48j31jNacJwexSAR1Q8V/BwGKBA==\",\n+            \"version\": \"2.3.3\",\n+            \"resolved\": \"https://registry.npmjs.org/rollup/-/rollup-2.3.3.tgz\",\n+            \"integrity\": \"sha512-uJ9VNWk80mb4wDCSfd1AyHoSc9TrWbkZtnO6wbsMTp9muSWkT26Dvc99MX1yGCOTvUN1Skw/KpFzKdUDuZKTXA==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"fsevents\": \"~2.1.2\""}, {"sha": "0bf7b6ae68c6a6afa82ce1175edac39994a48810", "filename": "editors/code/package.json", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -21,7 +21,7 @@\n         \"Programming Languages\"\n     ],\n     \"engines\": {\n-        \"vscode\": \"^1.43.0\"\n+        \"vscode\": \"^1.44.0\"\n     },\n     \"enableProposedApi\": true,\n     \"scripts\": {\n@@ -42,10 +42,10 @@\n         \"@types/node\": \"^12.12.34\",\n         \"@types/node-fetch\": \"^2.5.5\",\n         \"@types/vscode\": \"^1.43.0\",\n-        \"@typescript-eslint/eslint-plugin\": \"^2.26.0\",\n-        \"@typescript-eslint/parser\": \"^2.26.0\",\n+        \"@typescript-eslint/eslint-plugin\": \"^2.27.0\",\n+        \"@typescript-eslint/parser\": \"^2.27.0\",\n         \"eslint\": \"^6.8.0\",\n-        \"rollup\": \"^2.3.2\",\n+        \"rollup\": \"^2.3.3\",\n         \"tslib\": \"^1.11.1\",\n         \"typescript\": \"^3.8.3\",\n         \"typescript-formatter\": \"^7.2.2\",\n@@ -342,11 +342,6 @@\n                     \"default\": true,\n                     \"description\": \"Show function name and docs in parameter hints\"\n                 },\n-                \"rust-analyzer.highlighting.semanticTokens\": {\n-                    \"type\": \"boolean\",\n-                    \"default\": false,\n-                    \"description\": \"Use proposed semantic tokens API for syntax highlighting\"\n-                },\n                 \"rust-analyzer.updates.channel\": {\n                     \"type\": \"string\",\n                     \"enum\": ["}, {"sha": "0ad4b63aeb18e3cf37e892f6203e323647f6f149", "filename": "editors/code/src/client.ts", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/editors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/editors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fclient.ts?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -1,11 +1,10 @@\n import * as lc from 'vscode-languageclient';\n import * as vscode from 'vscode';\n \n-import { Config } from './config';\n import { CallHierarchyFeature } from 'vscode-languageclient/lib/callHierarchy.proposed';\n import { SemanticTokensFeature, DocumentSemanticsTokensSignature } from 'vscode-languageclient/lib/semanticTokens.proposed';\n \n-export async function createClient(config: Config, serverPath: string, cwd: string): Promise<lc.LanguageClient> {\n+export async function createClient(serverPath: string, cwd: string): Promise<lc.LanguageClient> {\n     // '.' Is the fallback if no folder is open\n     // TODO?: Workspace folders support Uri's (eg: file://test.txt).\n     // It might be a good idea to test if the uri points to a file.\n@@ -73,15 +72,12 @@ export async function createClient(config: Config, serverPath: string, cwd: stri\n     };\n \n     // To turn on all proposed features use: res.registerProposedFeatures();\n-    // Here we want to just enable CallHierarchyFeature since it is available on stable.\n-    // Note that while the CallHierarchyFeature is stable the LSP protocol is not.\n+    // Here we want to enable CallHierarchyFeature and SemanticTokensFeature\n+    // since they are available on stable.\n+    // Note that while these features are stable in vscode their LSP protocol\n+    // implementations are still in the \"proposed\" category for 3.16.\n     res.registerFeature(new CallHierarchyFeature(res));\n-\n-    if (config.package.enableProposedApi) {\n-        if (config.highlightingSemanticTokens) {\n-            res.registerFeature(new SemanticTokensFeature(res));\n-        }\n-    }\n+    res.registerFeature(new SemanticTokensFeature(res));\n \n     return res;\n }"}, {"sha": "21c1c9f232ed11b0526ecc87183799a136efdbfa", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -69,7 +69,6 @@ export class Config {\n     get serverPath() { return this.cfg.get<null | string>(\"serverPath\")!; }\n     get channel() { return this.cfg.get<UpdatesChannel>(\"updates.channel\")!; }\n     get askBeforeDownload() { return this.cfg.get<boolean>(\"updates.askBeforeDownload\")!; }\n-    get highlightingSemanticTokens() { return this.cfg.get<boolean>(\"highlighting.semanticTokens\")!; }\n     get traceExtension() { return this.cfg.get<boolean>(\"trace.extension\")!; }\n \n     get inlayHints() {"}, {"sha": "f7ed62d0356b54372ca0c9838c5e144ad7a46b6a", "filename": "editors/code/src/ctx.ts", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/editors%2Fcode%2Fsrc%2Fctx.ts", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/editors%2Fcode%2Fsrc%2Fctx.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fctx.ts?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -21,7 +21,7 @@ export class Ctx {\n         serverPath: string,\n         cwd: string,\n     ): Promise<Ctx> {\n-        const client = await createClient(config, serverPath, cwd);\n+        const client = await createClient(serverPath, cwd);\n         const res = new Ctx(config, extCtx, client, serverPath);\n         res.pushCleanup(client.start());\n         await client.onReady();"}, {"sha": "a56eeef8d29d250cda72400278134369a7ce6121", "filename": "xtask/src/dist.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/xtask%2Fsrc%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/xtask%2Fsrc%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fdist.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -3,24 +3,20 @@ use std::path::PathBuf;\n use anyhow::Result;\n \n use crate::{\n-    not_bash::{fs2, pushd, rm_rf, run},\n+    not_bash::{date_iso, fs2, pushd, rm_rf, run},\n     project_root,\n };\n \n-pub struct ClientOpts {\n-    pub version: String,\n-    pub release_tag: String,\n-}\n-\n-pub fn run_dist(client_opts: Option<ClientOpts>) -> Result<()> {\n+pub fn run_dist(nightly: bool, client_version: Option<String>) -> Result<()> {\n     let dist = project_root().join(\"dist\");\n     rm_rf(&dist)?;\n     fs2::create_dir_all(&dist)?;\n \n-    if let Some(ClientOpts { version, release_tag }) = client_opts {\n+    if let Some(version) = client_version {\n+        let release_tag = if nightly { \"nightly\".to_string() } else { date_iso()? };\n         dist_client(&version, &release_tag)?;\n     }\n-    dist_server()?;\n+    dist_server(nightly)?;\n     Ok(())\n }\n \n@@ -50,7 +46,7 @@ fn dist_client(version: &str, release_tag: &str) -> Result<()> {\n     Ok(())\n }\n \n-fn dist_server() -> Result<()> {\n+fn dist_server(nightly: bool) -> Result<()> {\n     if cfg!(target_os = \"linux\") {\n         std::env::set_var(\"CC\", \"clang\");\n         run!(\n@@ -60,7 +56,9 @@ fn dist_server() -> Result<()> {\n             // We'd want to add, but that requires setting the right linker somehow\n             // --features=jemalloc\n         )?;\n-        run!(\"strip ./target/x86_64-unknown-linux-musl/release/rust-analyzer\")?;\n+        if !nightly {\n+            run!(\"strip ./target/x86_64-unknown-linux-musl/release/rust-analyzer\")?;\n+        }\n     } else {\n         run!(\"cargo build --manifest-path ./crates/rust-analyzer/Cargo.toml --bin rust-analyzer --release\")?;\n     }"}, {"sha": "9d087daa248cffa20dd7a41db50bb0d5616dd2cd", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -21,7 +21,7 @@ use walkdir::{DirEntry, WalkDir};\n \n use crate::{\n     codegen::Mode,\n-    not_bash::{fs2, pushd, rm_rf, run},\n+    not_bash::{date_iso, fs2, pushd, rm_rf, run},\n };\n \n pub use anyhow::Result;\n@@ -180,7 +180,7 @@ pub fn run_release(dry_run: bool) -> Result<()> {\n     let website_root = project_root().join(\"../rust-analyzer.github.io\");\n     let changelog_dir = website_root.join(\"./thisweek/_posts\");\n \n-    let today = run!(\"date --iso\")?;\n+    let today = date_iso()?;\n     let commit = run!(\"git rev-parse HEAD\")?;\n     let changelog_n = fs2::read_dir(changelog_dir.as_path())?.count();\n "}, {"sha": "dff3ce4a1dd6081d33bc9b4519bd1ec5df86a380", "filename": "xtask/src/main.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -13,7 +13,7 @@ use std::env;\n use pico_args::Arguments;\n use xtask::{\n     codegen::{self, Mode},\n-    dist::{run_dist, ClientOpts},\n+    dist::run_dist,\n     install::{ClientOpt, InstallCmd, ServerOpt},\n     not_bash::pushd,\n     pre_commit, project_root, run_clippy, run_fuzzer, run_pre_cache, run_release, run_rustfmt,\n@@ -103,16 +103,10 @@ FLAGS:\n             run_release(dry_run)\n         }\n         \"dist\" => {\n-            let client_opts = if args.contains(\"--client\") {\n-                Some(ClientOpts {\n-                    version: args.value_from_str(\"--version\")?,\n-                    release_tag: args.value_from_str(\"--tag\")?,\n-                })\n-            } else {\n-                None\n-            };\n+            let nightly = args.contains(\"--nightly\");\n+            let client_version: Option<String> = args.opt_value_from_str(\"--client\")?;\n             args.finish()?;\n-            run_dist(client_opts)\n+            run_dist(nightly, client_version)\n         }\n         _ => {\n             eprintln!("}, {"sha": "ef1699934918f1eea460cd6a6206e545c4f71b51", "filename": "xtask/src/not_bash.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/585bb83e2aec9c79dae8c2e031e9165f40937003/xtask%2Fsrc%2Fnot_bash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bb83e2aec9c79dae8c2e031e9165f40937003/xtask%2Fsrc%2Fnot_bash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fnot_bash.rs?ref=585bb83e2aec9c79dae8c2e031e9165f40937003", "patch": "@@ -94,6 +94,10 @@ pub fn run_process(cmd: String, echo: bool) -> Result<String> {\n     run_process_inner(&cmd, echo).with_context(|| format!(\"process `{}` failed\", cmd))\n }\n \n+pub fn date_iso() -> Result<String> {\n+    run!(\"date --iso --utc\")\n+}\n+\n fn run_process_inner(cmd: &str, echo: bool) -> Result<String> {\n     let mut args = shelx(cmd);\n     let binary = args.remove(0);"}]}