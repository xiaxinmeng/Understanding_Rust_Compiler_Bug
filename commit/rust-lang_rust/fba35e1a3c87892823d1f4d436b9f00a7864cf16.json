{"sha": "fba35e1a3c87892823d1f4d436b9f00a7864cf16", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYTM1ZTFhM2M4Nzg5MjgyM2QxZjRkNDM2YjlmMDBhNzg2NGNmMTY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-01-31T05:00:57Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-01-31T18:08:24Z"}, "message": "Require alts to be exhaustive\n\nmiddle::check_alt does the work. Lots of changes to add default cases\ninto alts that were previously inexhaustive.", "tree": {"sha": "1fadaaee99ef266bd2f709fb2aa5577184ab611e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fadaaee99ef266bd2f709fb2aa5577184ab611e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fba35e1a3c87892823d1f4d436b9f00a7864cf16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fba35e1a3c87892823d1f4d436b9f00a7864cf16", "html_url": "https://github.com/rust-lang/rust/commit/fba35e1a3c87892823d1f4d436b9f00a7864cf16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fba35e1a3c87892823d1f4d436b9f00a7864cf16/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "813a55d89135efb716dd80e96453a091a7cfc631", "url": "https://api.github.com/repos/rust-lang/rust/commits/813a55d89135efb716dd80e96453a091a7cfc631", "html_url": "https://github.com/rust-lang/rust/commit/813a55d89135efb716dd80e96453a091a7cfc631"}], "stats": {"total": 1133, "additions": 766, "deletions": 367}, "files": [{"sha": "da9646e4caaf734d9934368f96a47fae8f55a428", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -93,6 +93,7 @@ fn load_link(mis: [@ast::meta_item]) -> (option::t<str>,\n                     _ { }\n                 }\n             }\n+            _ { fail \"load_link: meta items must be name-values\"; }\n         }\n     }\n     (name, vers, uuid)\n@@ -135,6 +136,7 @@ fn load_pkg(filename: str) -> option::t<pkg> {\n                     uuid = u;\n                 }\n             }\n+            _ { fail \"load_pkg: pkg attributes may not contain meta_words\"; }\n         }\n     }\n "}, {"sha": "a2030e10fabe2d273c6afb24fa821e7dbaa9e293", "filename": "src/comp/back/rpath.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Frpath.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -11,6 +11,13 @@ import util::filesearch;\n \n export get_rpath_flags;\n \n+pure fn not_win32(os: session::os) -> bool {\n+  alt os {\n+      session::os_win32 { false }\n+      _ { true }\n+  }\n+}\n+\n fn get_rpath_flags(sess: session::session, out_filename: str) -> [str] {\n     let os = sess.targ_cfg.os;\n \n@@ -99,12 +106,13 @@ fn get_rpaths_relative_to_output(os: session::os,\n fn get_rpath_relative_to_output(os: session::os,\n                                 cwd: fs::path,\n                                 output: fs::path,\n-                                &&lib: fs::path) -> str {\n+                                &&lib: fs::path) : not_win32(os) -> str {\n     // Mac doesn't appear to support $ORIGIN\n     let prefix = alt os {\n         session::os_linux { \"$ORIGIN\" + fs::path_sep() }\n         session::os_freebsd { \"$ORIGIN\" + fs::path_sep() }\n         session::os_macos { \"@executable_path\" + fs::path_sep() }\n+        session::os_win32 { std::util::unreachable(); }\n     };\n \n     prefix + get_relative_to(\n@@ -309,24 +317,31 @@ mod test {\n     #[test]\n     #[cfg(target_os = \"linux\")]\n     fn test_rpath_relative() {\n-        let res = get_rpath_relative_to_output(session::os_linux,\n+      let o = session::os_linux;\n+      check not_win32(o);\n+      let res = get_rpath_relative_to_output(o,\n             \"/usr\", \"bin/rustc\", \"lib/libstd.so\");\n-        assert res == \"$ORIGIN/../lib\";\n+      assert res == \"$ORIGIN/../lib\";\n     }\n \n     #[test]\n     #[cfg(target_os = \"freebsd\")]\n     fn test_rpath_relative() {\n-        let res = get_rpath_relative_to_output(session::os_freebsd,\n+      let o = session::os_freebsd;\n+      check not_win32(o);\n+      let res = get_rpath_relative_to_output(o,\n             \"/usr\", \"bin/rustc\", \"lib/libstd.so\");\n-        assert res == \"$ORIGIN/../lib\";\n+      assert res == \"$ORIGIN/../lib\";\n     }\n \n     #[test]\n     #[cfg(target_os = \"macos\")]\n     fn test_rpath_relative() {\n-        let res = get_rpath_relative_to_output(session::os_macos,\n-            \"/usr\", \"bin/rustc\", \"lib/libstd.so\");\n+      // this is why refinements would be nice\n+      let o = session::os_macos;\n+      check not_win32(o);\n+      let res = get_rpath_relative_to_output(o, \"/usr\", \"bin/rustc\",\n+                                             \"lib/libstd.so\");\n         assert res == \"@executable_path/../lib\";\n     }\n "}, {"sha": "ac6d785e8b52abba6d72703d70336d689a2e7ebf", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -608,6 +608,8 @@ mod test {\n         let match =\n             alt getopts::getopts([\"--test\"], opts()) {\n               ok(m) { m }\n+              err(f) { fail \"test_switch_implies_cfg_test: \" +\n+                       getopts::fail_str(f); }\n             };\n         let sessopts = build_session_options(match, diagnostic::emit);\n         let sess = build_session(sessopts, \"\", diagnostic::emit);\n@@ -622,6 +624,8 @@ mod test {\n         let match =\n             alt getopts::getopts([\"--test\", \"--cfg=test\"], opts()) {\n               ok(m) { m }\n+              err(f) { fail \"test_switch_implies_cfg_test_unless_cfg_test: \" +\n+                       getopts::fail_str(f); }\n             };\n         let sessopts = build_session_options(match, diagnostic::emit);\n         let sess = build_session(sessopts, \"\", diagnostic::emit);"}, {"sha": "81f1c76a2c929cdec9774ad0f66bed59f47454fb", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -58,7 +58,7 @@ type session = @{targ_cfg: @config,\n                  parse_sess: parse_sess,\n                  codemap: codemap::codemap,\n                  // For a library crate, this is always none\n-                 mutable main_fn: option::t<node_id>,\n+                 mutable main_fn: option::t<(node_id, codemap::span)>,\n                  span_diagnostic: diagnostic::span_handler,\n                  filesearch: filesearch::filesearch,\n                  mutable building_library: bool,"}, {"sha": "8fb12aae533f391e8c0fde7c4a1d5203b3819c88", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -3,6 +3,7 @@\n import std::{ebml, map, io};\n import io::writer_util;\n import syntax::{ast, ast_util};\n+import driver::session::session;\n import front::attr;\n import middle::ty;\n import common::*;\n@@ -302,7 +303,9 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(mth);\n         let ty = doc_type(mth, tcx, cdata);\n-        let fty = alt ty::struct(tcx, ty) { ty::ty_fn(f) { f } };\n+        let fty = alt ty::struct(tcx, ty) { ty::ty_fn(f) { f }\n+          _ { tcx.sess.bug(\"get_iface_methods: id has non-function type\");\n+        } };\n         result += [{ident: name, tps: bounds, fty: fty}];\n     }\n     @result"}, {"sha": "d4cdb7587bf587937cfebc81198dad61b651ea88", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -10,6 +10,7 @@ import middle::trans::common::crate_ctxt;\n import middle::ty;\n import middle::ty::node_id_to_type;\n import front::attr;\n+import driver::session::session;\n \n export encode_metadata;\n export encoded_ty;\n@@ -275,6 +276,8 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n             }\n         }\n       }\n+      _ { ecx.ccx.tcx.sess.bug(\"encode_info_for_mod: \\\n+             undocumented invariant\"); }\n     }\n     ebml::end_tag(ebml_w);\n }"}, {"sha": "f116bb7e17f72c87797c4720566dac6144d09e66", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -5,6 +5,7 @@ import io::writer_util;\n import std::map::hashmap;\n import option::{some, none};\n import syntax::ast::*;\n+import driver::session::session;\n import middle::ty;\n import syntax::print::pprust::*;\n \n@@ -213,6 +214,10 @@ fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n           by_copy { w.write_char('+'); }\n           by_ref { w.write_char('='); }\n           by_val { w.write_char('#'); }\n+          // tediously, this has to be there until there's a way\n+          // to constraint post-typeck types not to contain a mode_infer\n+          mode_infer { cx.tcx.sess.bug(\"enc_ty_fn: shouldn't see \\\n+            mode_infer\"); }\n         }\n         enc_ty(w, cx, arg.ty);\n     }"}, {"sha": "98cade0ca26a2ae47a883e4f094e81a338c49ab4", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -6,10 +6,12 @@ import syntax::visit;\n import visit::vt;\n import core::{vec, option};\n import std::list;\n+import std::util::unreachable;\n import option::{some, none, is_none};\n import list::list;\n import driver::session::session;\n import pat_util::*;\n+import util::ppaux::ty_to_str;\n \n // This is not an alias-analyser (though it would merit from becoming one, or\n // getting input from one, to be more precise). It is a pass that checks\n@@ -575,6 +577,11 @@ fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n             for f in fs { sum += score_ty(tcx, f.mt.ty); }\n             sum\n           }\n+          _ {\n+            tcx.sess.warn(#fmt(\"score_ty: unexpected type %s\",\n+               ty_to_str(tcx, ty)));\n+            1u // ???\n+          }\n         };\n     }\n     ret score_ty(tcx, ty) > 8u;\n@@ -611,6 +618,7 @@ fn pattern_roots(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat)\n             let ty = ty::node_id_to_type(tcx, pat.id);\n             let m = alt ty::struct(tcx, ty) {\n               ty::ty_box(mt) { mt.mut != ast::imm }\n+              _ { tcx.sess.span_bug(pat.span, \"box pat has non-box type\"); }\n             },\n                 c = if m  {some(contains(ty)) } else { mut };\n             walk(tcx, c, p, set);\n@@ -619,6 +627,7 @@ fn pattern_roots(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat)\n             let ty = ty::node_id_to_type(tcx, pat.id);\n             let m = alt ty::struct(tcx, ty) {\n               ty::ty_uniq(mt) { mt.mut != ast::imm }\n+              _ { tcx.sess.span_bug(pat.span, \"uniq pat has non-uniq type\"); }\n             },\n                 c = if m { some(contains(ty)) } else { mut };\n             walk(tcx, c, p, set);\n@@ -672,6 +681,10 @@ fn append_invalid(dest: list<@invalid>, src: list<@invalid>,\n             }\n             cur = *tail;\n           }\n+          list::nil {\n+              fail \"append_invalid: stop doesn't appear to be \\\n+                 a postfix of src\";\n+          }\n         }\n     }\n     ret dest;\n@@ -686,6 +699,10 @@ fn filter_invalid(src: list<@invalid>, bs: [binding]) -> list<@invalid> {\n             if !is_none(p) { out = list::cons(head, @out); }\n             cur = *tail;\n           }\n+          list::nil {\n+            // typestate would help...\n+            unreachable();\n+          }\n         }\n     }\n     ret out;"}, {"sha": "97881ca17a21374fc6cb2aba53c9488707824d6b", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 4, "deletions": 48, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -44,15 +44,15 @@ fn map_fn(cx: ctx, _fk: visit::fn_kind, decl: fn_decl, _body: blk,\n }\n \n fn map_local(cx: ctx, loc: @local) {\n-    pat_util::pat_bindings(loc.node.pat) {|p|\n-        cx.map.insert(p.id, node_local(cx.local_id));\n+    pat_util::pat_bindings(loc.node.pat) {|p_id, _s, _p|\n+        cx.map.insert(p_id, node_local(cx.local_id));\n         cx.local_id += 1u;\n     };\n }\n \n fn map_arm(cx: ctx, arm: arm) {\n-    pat_util::pat_bindings(arm.pats[0]) {|p|\n-        cx.map.insert(p.id, node_local(cx.local_id));\n+    pat_util::pat_bindings(arm.pats[0]) {|p_id, _s, _p|\n+        cx.map.insert(p_id, node_local(cx.local_id));\n         cx.local_id += 1u;\n     };\n }\n@@ -79,50 +79,6 @@ fn map_expr(cx: ctx, ex: @expr) {\n     cx.map.insert(ex.id, node_expr(ex));\n }\n \n-fn node_span(node: ast_node) -> codemap::span {\n-    alt node {\n-      node_item(item) { item.span }\n-      node_native_item(nitem) { nitem.span }\n-      node_expr(expr) { expr.span }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    import syntax::ast_util;\n-\n-    #[test]\n-    fn test_node_span_item() {\n-        let expected: codemap::span = ast_util::mk_sp(20u, 30u);\n-        let node =\n-            node_item(@{ident: \"test\",\n-                        attrs: [],\n-                        id: 0,\n-                        node: item_mod({view_items: [], items: []}),\n-                        span: expected});\n-        assert (node_span(node) == expected);\n-    }\n-\n-    #[test]\n-    fn test_node_span_native_item() {\n-        let expected: codemap::span = ast_util::mk_sp(20u, 30u);\n-        let node =\n-            node_native_item(@{ident: \"test\",\n-                               attrs: [],\n-                               node: native_item_ty,\n-                               id: 0,\n-                               span: expected});\n-        assert (node_span(node) == expected);\n-    }\n-\n-    #[test]\n-    fn test_node_span_expr() {\n-        let expected: codemap::span = ast_util::mk_sp(20u, 30u);\n-        let node = node_expr(@{id: 0, node: expr_break, span: expected});\n-        assert (node_span(node) == expected);\n-    }\n-}\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "2577ed03a932879f8404f172dc64084ebdc42ba6", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 108, "deletions": 7, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -1,10 +1,14 @@\n+\n import syntax::ast::*;\n import syntax::ast_util::{variant_def_ids, dummy_sp, compare_lit_exprs,\n-                          lit_expr_eq};\n+        lit_expr_eq, unguarded_pat};\n+import syntax::codemap::span;\n import pat_util::*;\n import syntax::visit;\n import option::{some, none};\n import driver::session::session;\n+import middle::ty;\n+import middle::ty::*;\n \n fn check_crate(tcx: ty::ctxt, crate: @crate) {\n     let v =\n@@ -18,15 +22,20 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) {\n fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n     visit::visit_expr(ex, s, v);\n     alt ex.node {\n-        expr_alt(_, arms) {\n-            check_arms(tcx, pat_util::normalize_arms(tcx, arms));\n+        expr_alt(scrut, arms) {\n+            check_arms(tcx, ex.span, scrut,\n+                       pat_util::normalize_arms(tcx, arms));\n         }\n         _ { }\n     }\n }\n \n-fn check_arms(tcx: ty::ctxt, arms: [arm]) {\n+fn check_arms(tcx: ty::ctxt, sp:span, scrut: @expr, arms: [arm]) {\n     let i = 0;\n+    let scrut_ty = expr_ty(tcx, scrut);\n+    /* (Could both checks be done in a single pass?) */\n+\n+    /* Check for unreachable patterns */\n     for arm: arm in arms {\n         for arm_pat: @pat in arm.pats {\n             let reachable = true;\n@@ -47,6 +56,97 @@ fn check_arms(tcx: ty::ctxt, arms: [arm]) {\n         }\n         i += 1;\n     }\n+\n+    /* Check for exhaustiveness */\n+\n+    check_exhaustive(tcx, sp, scrut_ty,\n+       vec::concat(vec::filter_map(arms, unguarded_pat)));\n+}\n+\n+// Precondition: patterns have been normalized\n+// (not checked statically yet)\n+fn check_exhaustive(tcx: ty::ctxt, sp:span, scrut_ty:ty::t, pats:[@pat]) {\n+    let represented : [def_id] = [];\n+    /* Determine the type of the scrutinee */\n+    /* If it's not an enum, exit (bailing out on checking non-enum alts\n+       for now) */\n+    /* Otherwise, get the list of variants and make sure each one is\n+     represented. Then recurse on the columns. */\n+\n+    let ty_def_id = alt ty::struct(tcx, scrut_ty) {\n+            ty_enum(id, _) { id }\n+            _ { ret; } };\n+\n+    let variants = *enum_variants(tcx, ty_def_id);\n+    for pat in pats {\n+        if !is_refutable(tcx, pat) {\n+                /* automatically makes this alt complete */ ret;\n+        }\n+        alt pat.node {\n+                // want the def_id for the constructor\n+            pat_enum(id,_) {\n+                alt tcx.def_map.find(pat.id) {\n+                    some(def_variant(_, variant_def_id)) {\n+                        represented += [variant_def_id];\n+                    }\n+                    _ { tcx.sess.span_bug(pat.span, \"check_exhaustive:\n+                          pat_tag not bound to a variant\"); }\n+                }\n+            }\n+            _ { tcx.sess.span_bug(pat.span, \"check_exhaustive: ill-typed \\\n+                  pattern\");   // we know this has enum type,\n+            }                  // so anything else should be impossible\n+         }\n+    }\n+    fn not_represented(v: [def_id], &&vinfo: variant_info) -> bool {\n+        !vec::member(vinfo.id, v)\n+    }\n+    // Could be more efficient (bitvectors?)\n+    alt vec::find(variants, bind not_represented(represented,_)) {\n+        some(bad) {\n+        // complain\n+        // TODO: give examples of cases that aren't covered\n+            tcx.sess.note(\"Patterns not covered include:\");\n+            tcx.sess.note(bad.name);\n+            tcx.sess.span_err(sp, \"Non-exhaustive pattern\");\n+        }\n+        _ {}\n+    }\n+    // Otherwise, check subpatterns\n+    // inefficient\n+    for variant in variants {\n+        // rows consists of the argument list for each pat that's an enum\n+        let rows : [[@pat]] = [];\n+        for pat in pats {\n+            alt pat.node {\n+               pat_enum(id, args) {\n+                  alt tcx.def_map.find(pat.id) {\n+                      some(def_variant(_,variant_id))\n+                        if variant_id == variant.id { rows += [args]; }\n+                      _ { }\n+                  }\n+               }\n+               _ {}\n+            }\n+        }\n+        if check vec::is_not_empty(rows) {\n+             let i = 0u;\n+             for it in rows[0] {\n+                let column = [it];\n+                // Annoying -- see comment in\n+                // tstate::states::find_pre_post_state_loop\n+                check vec::is_not_empty(rows);\n+                for row in vec::tail(rows) {\n+                  column += [row[i]];\n+                }\n+                check_exhaustive(tcx, sp, pat_ty(tcx, it), column);\n+                i += 1u;\n+             }\n+        }\n+        // This shouldn't actually happen, since there were no\n+        // irrefutable patterns if we got here.\n+        else { cont; }\n+    }\n }\n \n fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n@@ -145,8 +245,8 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n       pat_wild | pat_ident(_, none) { false }\n       pat_lit(_) { true }\n       pat_rec(fields, _) {\n-        for field: field_pat in fields {\n-            if is_refutable(tcx, field.pat) { ret true; }\n+        for it: field_pat in fields {\n+            if is_refutable(tcx, it.pat) { ret true; }\n         }\n         false\n       }\n@@ -156,10 +256,11 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n       }\n       pat_enum(_, args) {\n         let vdef = variant_def_ids(tcx.def_map.get(pat.id));\n-        if vec::len(*ty::enum_variants(tcx, vdef.tg)) != 1u { ret true; }\n+        if vec::len(*ty::enum_variants(tcx, vdef.enm)) != 1u { ret true; }\n         for p: @pat in args { if is_refutable(tcx, p) { ret true; } }\n         false\n       }\n+      pat_range(_, _) { true }\n     }\n }\n "}, {"sha": "fe843c6795b1973fedc7aae58c1998698b1aee91", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 44, "deletions": 13, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -12,6 +12,7 @@ import codemap::span;\n import ast::ty;\n import pat_util::*;\n import util::ppaux::ty_to_str;\n+import driver::session::session;\n \n export create_local_var;\n export create_function;\n@@ -249,8 +250,8 @@ fn create_block(cx: @block_ctxt) -> @metadata<block_md> {\n     }*/\n \n     let parent = alt cx.parent {\n-      parent_none { create_function(cx.fcx).node }\n-      parent_some(bcx) { create_block(bcx).node }\n+        parent_none { create_function(cx.fcx).node }\n+        parent_some(bcx) { create_block(bcx).node }\n     };\n     let file_node = create_file(bcx_ccx(cx), fname);\n     let unique_id = alt cache.find(LexicalBlockTag) {\n@@ -306,6 +307,8 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n         ast::ty_f32 {(\"f32\", size_and_align_of::<f32>(), DW_ATE_float)}\n         ast::ty_f64 {(\"f64\", size_and_align_of::<f64>(), DW_ATE_float)}\n       }}\n+      _ { cx.tcx.sess.span_bug(ty.span,\n+             \"create_basic_type: unhandled type\"); }\n     };\n \n     let fname = filename_from_span(cx, ty.span);\n@@ -481,15 +484,15 @@ fn create_composite_type(type_tag: int, name: str, file: ValueRef, line: int,\n     ret llmdnode(lldata);\n }\n \n-fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t, vec_ty: @ast::ty)\n+fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n+              vec_ty_span: codemap::span, elem_ty: @ast::ty)\n     -> @metadata<tydesc_md> {\n-    let fname = filename_from_span(cx, vec_ty.span);\n+    let fname = filename_from_span(cx, vec_ty_span);\n     let file_node = create_file(cx, fname);\n-    let elem_ty = alt vec_ty.node { ast::ty_vec(mt) { mt.ty } };\n     let elem_ty_md = create_ty(cx, elem_t, elem_ty);\n     let tcx = ccx_tcx(cx);\n     let scx = create_structure(file_node, ty_to_str(tcx, vec_t), 0);\n-    let uint_ty = @{node: ast::ty_uint(ast::ty_u), span: vec_ty.span};\n+    let uint_ty = @{node: ast::ty_uint(ast::ty_u), span: vec_ty_span};\n     let size_t_type = create_basic_type(cx, ty::mk_uint(tcx), uint_ty);\n     add_member(scx, \"fill\", 0, sys::size_of::<ctypes::size_t>() as int,\n                sys::align_of::<ctypes::size_t>() as int, size_t_type.node);\n@@ -516,12 +519,14 @@ fn member_size_and_align(ty: @ast::ty) -> (int, int) {\n         ast::ty_i8 { size_and_align_of::<i8>() }\n         ast::ty_i16 { size_and_align_of::<i16>() }\n         ast::ty_i32 { size_and_align_of::<i32>() }\n+        ast::ty_i64 { size_and_align_of::<i64>() }\n       }}\n       ast::ty_uint(m) { alt m {\n         ast::ty_u { size_and_align_of::<uint>() }\n         ast::ty_u8 { size_and_align_of::<i8>() }\n         ast::ty_u16 { size_and_align_of::<u16>() }\n         ast::ty_u32 { size_and_align_of::<u32>() }\n+        ast::ty_u64 { size_and_align_of::<u64>() }\n       }}\n       ast::ty_float(m) { alt m {\n         ast::ty_f { size_and_align_of::<float>() }\n@@ -542,6 +547,7 @@ fn member_size_and_align(ty: @ast::ty) -> (int, int) {\n       ast::ty_vec(_) {\n         size_and_align_of::<ctypes::uintptr_t>()\n       }\n+      _ { fail \"member_size_and_align: can't handle this type\"; }\n     }\n }\n \n@@ -578,6 +584,9 @@ fn create_ty(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n           }\n           ty::ty_vec(mt) { ast::ty_vec({ty: t_to_ty(cx, mt.ty, span),\n                                         mut: mt.mut}) }\n+          _ {\n+            cx.tcx.sess.span_bug(span, \"t_to_ty: Can't handle this type\");\n+          }\n         };\n         ret @{node: ty, span: span};\n     }\n@@ -586,6 +595,7 @@ fn create_ty(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n       ast::ty_box(mt) {\n         let inner_t = alt ty::struct(ccx_tcx(cx), t) {\n           ty::ty_box(boxed) { boxed.ty }\n+          _ { cx.tcx.sess.span_bug(ty.span, \"t_to_ty was incoherent\"); }\n         };\n         let md = create_ty(cx, inner_t, mt.ty);\n         let box = create_boxed_type(cx, t, inner_t, ty.span, md);\n@@ -595,6 +605,8 @@ fn create_ty(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n       ast::ty_uniq(mt) {\n         let inner_t = alt ty::struct(ccx_tcx(cx), t) {\n           ty::ty_uniq(boxed) { boxed.ty }\n+          // Hoping we'll have a way to eliminate this check soon.\n+          _ { cx.tcx.sess.span_bug(ty.span, \"t_to_ty was incoherent\"); }\n         };\n         let md = create_ty(cx, inner_t, mt.ty);\n         ret create_pointer_type(cx, t, ty.span, md);\n@@ -611,7 +623,8 @@ fn create_ty(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n \n       ast::ty_vec(mt) {\n         let inner_t = ty::sequence_element_type(ccx_tcx(cx), t);\n-        let v = create_vec(cx, t, inner_t, ty);\n+        let inner_ast_t = t_to_ty(cx, inner_t, mt.ty.span);\n+        let v = create_vec(cx, t, inner_t, ty.span, inner_ast_t);\n         ret create_pointer_type(cx, t, ty.span, v);\n       }\n \n@@ -650,15 +663,17 @@ fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n     let name = path_to_ident(alt pat_util::normalize_pat(bcx_tcx(bcx),\n                                            local.node.pat).node {\n       ast::pat_ident(ident, _) { ident /*XXX deal w/ optional node binding*/ }\n-    });\n+      _ { bcx_tcx(bcx).sess.span_bug(local.span, \"create_local_var: \\\n+             weird pattern in local\"); }\n+     });\n     let loc = codemap::lookup_char_pos(cx.sess.codemap,\n                                        local.span.lo);\n     let ty = base::node_id_type(cx, local.node.id);\n     let tymd = create_ty(cx, ty, local.node.ty);\n     let filemd = create_file(cx, loc.filename);\n     let context = alt bcx.parent {\n-      parent_none { create_function(bcx.fcx).node }\n-      parent_some(_) { create_block(bcx).node }\n+        parent_none { create_function(bcx.fcx).node }\n+        parent_some(_) { create_block(bcx).node }\n     };\n     let mdnode = create_var(tg, context, name, filemd.node,\n                             loc.line as int, tymd.node);\n@@ -667,9 +682,15 @@ fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n \n     let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n       option::some(local_mem(v)) { v }\n+      option::some(_) {\n+        bcx_tcx(bcx).sess.span_bug(local.span, \"local is bound to \\\n+                something weird\");\n+      }\n       option::none {\n         alt bcx.fcx.lllocals.get(local.node.pat.id) {\n           local_imm(v) { v }\n+          _ { bcx_tcx(bcx).sess.span_bug(local.span, \"local is bound to \\\n+                something weird\"); }\n         }\n       }\n     };\n@@ -745,15 +766,21 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n           ast::item_fn(decl, _, _) | ast::item_res(decl, _, _, _, _) {\n             (item.ident, decl.output, item.id)\n           }\n+          _ { fcx_tcx(fcx).sess.span_bug(item.span, \"create_function: item \\\n+                bound to non-function\"); }\n         }\n       }\n       ast_map::node_method(method) {\n           (method.ident, method.decl.output, method.id)\n       }\n       ast_map::node_res_ctor(item) {\n-        alt item.node { ast::item_res(decl, _, _, _, ctor_id) {\n-          (item.ident, decl.output, ctor_id)\n-        }}\n+        alt item.node {\n+            ast::item_res(decl, _, _, _, ctor_id) {\n+              (item.ident, decl.output, ctor_id)\n+            }\n+            _ { fcx_tcx(fcx).sess.span_bug(item.span, \"create_function: \\\n+                  expected an item_res here\"); }\n+          }\n       }\n       ast_map::node_expr(expr) {\n         alt expr.node {\n@@ -763,8 +790,12 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n           ast::expr_fn_block(decl, _) {\n             (dbg_cx.names(\"fn\"), decl.output, expr.id)\n           }\n+          _ { fcx_tcx(fcx).sess.span_bug(expr.span, \"create_function: \\\n+                  expected an expr_fn or fn_block here\"); }\n         }\n       }\n+      _ { fcx_tcx(fcx).sess.bug(\"create_function: unexpected \\\n+            sort of node\"); }\n     };\n \n     log(debug, ident);"}, {"sha": "31b03cc3705a5c4ea6b3ba17566ef8387f7d108a", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -104,7 +104,7 @@ fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n     alt ty::struct(cx, ty) {\n       ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_int(_) |\n       ty::ty_float(_) | ty::ty_uint(_) | ty::ty_str |\n-      ty::ty_type | ty::ty_ptr(_) | ty::ty_native(_) {\n+      ty::ty_type | ty::ty_send_type | ty::ty_ptr(_) | ty::ty_native(_) {\n         ret false;\n       }\n       ty::ty_rec(fields) {\n@@ -131,9 +131,19 @@ fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n       ty::ty_constr(sub, _) { ret type_is_gc_relevant(cx, sub); }\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_fn(_) |\n       ty::ty_param(_, _) | ty::ty_res(_, _, _) { ret true; }\n+      ty::ty_opaque_closure_ptr(_) {\n+        ret false; // I guess?\n+      }\n+      // A precondition to rule out these cases would be nice\n       ty::ty_var(_) {\n         fail \"ty_var in type_is_gc_relevant\";\n       }\n+      ty::ty_iface(_, _) {\n+        fail \"ty_iface in type_is_gc_relevant\";\n+      }\n+      ty::ty_named(_,_) {\n+        fail \"ty_named in type_is_gc_relevant\";\n+      }\n     }\n }\n "}, {"sha": "e06ce29add89dbf082a37fbd2e585af09ae65fed", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -142,7 +142,9 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n           some(ex) {\n             // All noncopyable fields must be overridden\n             let t = ty::expr_ty(cx.tcx, ex);\n-            let ty_fields = alt ty::struct(cx.tcx, t) { ty::ty_rec(f) { f } };\n+            let ty_fields = alt ty::struct(cx.tcx, t) { ty::ty_rec(f) { f }\n+              _ { cx.tcx.sess.span_bug(ex.span,\n+                     \"Bad expr type in record\"); } };\n             for tf in ty_fields {\n                 if !vec::any(fields, {|f| f.node.ident == tf.ident}) &&\n                     !ty::kind_can_be_copied(ty::type_kind(cx.tcx, tf.mt.ty)) {"}, {"sha": "24b378b8d38663c82b2c5449f9297588c030f2ec", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -2,6 +2,7 @@ import syntax::{visit, ast_util};\n import syntax::ast::*;\n import syntax::codemap::span;\n import std::list::{is_not_empty, list, nil, cons, tail};\n+import std::util::unreachable;\n import core::{vec, option};\n import std::list;\n \n@@ -223,6 +224,11 @@ fn add_block_exit(cx: ctx, tp: block_type) -> bool {\n             }\n             cur = *tail;\n           }\n+          nil {\n+            // typestate can't use the while loop condition --\n+            // *sigh*\n+            unreachable();\n+          }\n         }\n     }\n     ret false;"}, {"sha": "f2f5666a346519eaa7c2990de58362270afc28b5", "filename": "src/comp/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flint.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -51,6 +51,7 @@ fn merge_opts(attrs: [ast::attribute], cmd_opts: [(option, bool)]) ->\n           ast::meta_word(name) {\n             str_to_option(name)\n           }\n+          _ { fail \"meta_to_option: meta_list contains a non-meta-word\"; }\n         };\n     }\n "}, {"sha": "736a31851d2226f135a5f2f6dfec7677111f3890", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -78,6 +78,10 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n               ty::ty_str {\n                 ds += [@{mut: false, kind: index, outer_t: auto_unbox.t}];\n               }\n+              _ {\n+                  tcx.sess.span_bug(base.span, \"Ill-typed base expression in \\\n+                    index\");\n+              }\n             }\n             ds += auto_unbox.ds;\n             ex = base;\n@@ -92,6 +96,8 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n                   ty::ty_res(_, _, _) { }\n                   ty::ty_enum(_, _) { }\n                   ty::ty_ptr(mt) { is_mut = mt.mut == mut; ptr = true; }\n+                  _ { tcx.sess.span_bug(base.span, \"Ill-typed base \\\n+                        expression in deref\"); }\n                 }\n                 ds += [@{mut: is_mut, kind: unbox(ptr && is_mut),\n                          outer_t: base_t}];"}, {"sha": "8a5c2706bb1a8e69bed0e854a5614d39c8eca933", "filename": "src/comp/middle/pat_util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fpat_util.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -3,6 +3,7 @@ import syntax::ast_util;\n import syntax::ast_util::respan;\n import syntax::fold;\n import syntax::fold::*;\n+import syntax::codemap::span;\n \n export normalize_arms;\n export normalize_pat;\n@@ -80,21 +81,20 @@ type pat_id_map = std::map::hashmap<str, node_id>;\n // use the node_id of their namesake in the first pattern.\n fn pat_id_map(tcx: ty::ctxt, pat: @pat) -> pat_id_map {\n     let map = std::map::new_str_hash::<node_id>();\n-    pat_bindings(normalize_pat(tcx, pat)) {|bound|\n-        let name = path_to_ident(alt bound.node\n-           { pat_ident(n, _) { n } });\n-        map.insert(name, bound.id);\n+    pat_bindings(normalize_pat(tcx, pat)) {|p_id, _s, n|\n+      map.insert(path_to_ident(n), p_id);\n     };\n     ret map;\n }\n \n // This does *not* normalize. The pattern should be already normalized\n // if you want to get a normalized pattern out of it.\n // Could return a constrained type in order to express that (future work)\n-fn pat_bindings(pat: @pat, it: fn(@pat)) {\n+fn pat_bindings(pat: @pat, it: fn(node_id, span, @path)) {\n   alt pat.node {\n-      pat_ident(_, option::none) { it(pat); }\n-      pat_ident(_, option::some(sub)) { it(pat); pat_bindings(sub, it); }\n+      pat_ident(pth, option::none) { it(pat.id, pat.span, pth); }\n+      pat_ident(pth, option::some(sub)) { it(pat.id, pat.span, pth);\n+        pat_bindings(sub, it); }\n       pat_enum(_, sub) { for p in sub { pat_bindings(p, it); } }\n       pat_rec(fields, _) { for f in fields { pat_bindings(f.pat, it); } }\n       pat_tup(elts) { for elt in elts { pat_bindings(elt, it); } }\n@@ -106,7 +106,7 @@ fn pat_bindings(pat: @pat, it: fn(@pat)) {\n \n fn pat_binding_ids(pat: @pat) -> [node_id] {\n     let found = [];\n-    pat_bindings(pat) {|b| found += [b.id]; };\n+    pat_bindings(pat) {|b_id, _sp, _pt| found += [b_id]; };\n     ret found;\n }\n "}, {"sha": "1c04541e7640e859ac8899c3e2fe99fa2899aaf1", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 76, "deletions": 52, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -45,15 +45,15 @@ enum scope {\n type scopes = list<scope>;\n \n enum import_state {\n-    todo(ast::node_id, ast::ident, @[ast::ident], codemap::span, scopes),\n-    is_glob(@[ast::ident], scopes, codemap::span),\n+    todo(ast::node_id, ast::ident, @[ast::ident], span, scopes),\n+    is_glob(@[ast::ident], scopes, span),\n     resolving(span),\n     resolved(option::t<def>, /* value */\n              option::t<def>, /* type */\n              option::t<def>, /* module */\n              @[@_impl], /* impls */\n              /* used for reporting unused import warning */\n-             ast::ident, codemap::span),\n+             ast::ident, span),\n }\n \n enum glob_import_state {\n@@ -83,11 +83,13 @@ fn new_ext_hash() -> ext_hash {\n }\n \n enum mod_index_entry {\n-    mie_view_item(@ast::view_item),\n-    mie_import_ident(node_id, codemap::span),\n+    mie_view_item(ident, node_id, span),\n+    mie_import_ident(node_id, span),\n     mie_item(@ast::item),\n     mie_native_item(@ast::native_item),\n-    mie_enum_variant(/* enum item */@ast::item, /* variant index */uint),\n+    mie_enum_variant(/* variant index */uint,\n+                     /*parts of enum item*/ [variant],\n+                    node_id, span),\n }\n \n type mod_index = hashmap<ident, list<mod_index_entry>>;\n@@ -278,6 +280,8 @@ fn map_crate(e: @env, c: @ast::crate) {\n                   scope_crate {\n                     e.mod_map.get(ast::crate_node_id).glob_imports += [glob];\n                   }\n+                  _ { e.sess.span_bug(vi.span, \"Unexpected scope in a glob \\\n+                       import\"); }\n                 }\n             }\n           }\n@@ -294,6 +298,7 @@ fn resolve_imports(e: env) {\n             resolve_import(e, local_def(node_id), name, *path, span, scopes);\n           }\n           resolved(_, _, _, _, _, _) | is_glob(_, _, _) { }\n+          _ { e.sess.bug(\"Shouldn't see a resolving in resolve_imports\"); }\n         }\n     };\n     e.used_imports.track = false;\n@@ -478,7 +483,7 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n         if is_main_name([nm]) && !e.sess.building_library {\n             // This is a main function -- set it in the session\n             // as the main ID\n-            e.sess.main_fn = some(id);\n+            e.sess.main_fn = some((id, sp));\n         }\n       }\n       _ { /* fallthrough */ }\n@@ -665,6 +670,9 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n             lst(id,\n                 option::get(e.mod_map.get(ast::crate_node_id).m).view_items)\n           }\n+          _ {\n+              e.sess.bug(\"find_imports_after: nil or unexpected scope\");\n+          }\n         }\n     }\n     // This function has cleanup code at the end. Do not return without going\n@@ -904,6 +912,10 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n               ast::native_item_fn(decl, ty_params) {\n                 ret lookup_in_fn(e, name, decl, ty_params, ns);\n               }\n+              _ {\n+                  e.sess.span_bug(it.span, \"lookup_in_scope: \\\n+                    scope_native_item doesn't refer to a native item\");\n+              }\n             }\n           }\n           scope_bare_fn(decl, _, ty_params) |\n@@ -1005,10 +1017,10 @@ fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n fn lookup_in_pat(e: env, name: ident, pat: @ast::pat) -> option::t<def_id> {\n     let found = none;\n \n-    pat_util::pat_bindings(normalize_pat_def_map(e.def_map, pat)) {|bound|\n-        let p_name = alt bound.node { ast::pat_ident(n, _) { n } };\n-        if str::eq(path_to_ident(p_name), name)\n-                    { found = some(local_def(bound.id)); }\n+    pat_util::pat_bindings(normalize_pat_def_map(e.def_map, pat))\n+     {|p_id, _sp, n|\n+        if str::eq(path_to_ident(n), name)\n+                    { found = some(local_def(p_id)); }\n     };\n     ret found;\n }\n@@ -1114,6 +1126,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n               _ {}\n             }\n           }\n+          _ { e.sess.span_bug(vi.span, \"Unexpected view_item in block\"); }\n         }\n     }\n     ret none;\n@@ -1189,16 +1202,16 @@ fn lookup_in_mod(e: env, m: def, sp: span, name: ident, ns: namespace,\n       ast::def_native_mod(defid) {\n         ret lookup_in_local_native_mod(e, defid.node, sp, name, ns);\n       }\n+      _ {\n+          // Precondition\n+          e.sess.span_bug(sp, \"lookup_in_mod was passed a non-mod def\");\n+      }\n     }\n }\n \n-fn found_view_item(e: env, vi: @ast::view_item) -> option::t<def> {\n-    alt vi.node {\n-      ast::view_item_use(_, _, id) {\n-        let cnum = cstore::get_use_stmt_cnum(e.cstore, id);\n-        ret some(ast::def_mod({crate: cnum, node: ast::crate_node_id}));\n-      }\n-    }\n+fn found_view_item(e: env, id: node_id) -> def {\n+    let cnum = cstore::get_use_stmt_cnum(e.cstore, id);\n+    ret ast::def_mod({crate: cnum, node: ast::crate_node_id});\n }\n \n fn lookup_import(e: env, defid: def_id, ns: namespace) -> option::t<def> {\n@@ -1220,6 +1233,9 @@ fn lookup_import(e: env, defid: def_id, ns: namespace) -> option::t<def> {\n         ret alt ns { ns_val(_) { val } ns_type { typ }\n                      ns_module { md } };\n       }\n+      is_glob(_,_,_) {\n+          e.sess.bug(\"lookup_import: can't handle is_glob\");\n+      }\n     }\n }\n \n@@ -1267,6 +1283,9 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n           ast::view_item_import_glob(_, id) {\n             if vec::member(id, e.ignored_imports) { ret none; }\n           }\n+          _ {\n+            e.sess.span_bug(sp, \"lookup_in_globs: not a glob\");\n+          }\n         }\n         alt lookup_in_mod(e, def.def, sp, name, ns, dr) {\n           some(d) { option::some({def: d, item: def.item}) }\n@@ -1322,24 +1341,20 @@ fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n    option::t<def> {\n     alt mie {\n-      mie_view_item(view_item) {\n-        if ns == ns_module { ret found_view_item(e, view_item); }\n+      mie_view_item(_, id, _) {\n+         if ns == ns_module { ret some(found_view_item(e, id)); }\n       }\n       mie_import_ident(id, _) { ret lookup_import(e, local_def(id), ns); }\n       mie_item(item) { ret found_def_item(item, ns); }\n-      mie_enum_variant(item, variant_idx) {\n-        alt item.node {\n-          ast::item_enum(variants, _) {\n-              alt ns {\n-                  ns_val(_) {\n-                     let vid = variants[variant_idx].node.id;\n-                     ret some(ast::def_variant(local_def(item.id),\n+      mie_enum_variant(variant_idx, variants, parent_id, parent_span) {\n+         alt ns {\n+            ns_val(_) {\n+               let vid = variants[variant_idx].node.id;\n+               ret some(ast::def_variant(local_def(parent_id),\n                                         local_def(vid)));\n-                  }\n-                  _ { ret none::<def>; }\n-              }\n-          }\n-        }\n+            }\n+            _ { ret none::<def>; }\n+         }\n       }\n       mie_native_item(native_item) {\n         alt native_item.node {\n@@ -1374,8 +1389,8 @@ fn index_mod(md: ast::_mod) -> mod_index {\n     let index = new_str_hash::<list<mod_index_entry>>();\n     for it: @ast::view_item in md.view_items {\n         alt it.node {\n-          ast::view_item_use(ident, _, _) {\n-            add_to_index(index, ident, mie_view_item(it));\n+          ast::view_item_use(ident, _, id) {\n+           add_to_index(index, ident, mie_view_item(ident, id, it.span));\n           }\n           ast::view_item_import(ident, _, id) {\n             add_to_index(index, ident, mie_import_ident(id, it.span));\n@@ -1405,7 +1420,8 @@ fn index_mod(md: ast::_mod) -> mod_index {\n             let variant_idx: uint = 0u;\n             for v: ast::variant in variants {\n                 add_to_index(index, v.node.name,\n-                             mie_enum_variant(it, variant_idx));\n+                             mie_enum_variant(variant_idx, variants,\n+                                             it.id, it.span));\n                 variant_idx += 1u;\n             }\n           }\n@@ -1418,8 +1434,9 @@ fn index_nmod(md: ast::native_mod) -> mod_index {\n     let index = new_str_hash::<list<mod_index_entry>>();\n     for it: @ast::view_item in md.view_items {\n         alt it.node {\n-          ast::view_item_use(ident, _, _) {\n-            add_to_index(index, ident, mie_view_item(it));\n+          ast::view_item_use(ident, _, id) {\n+            add_to_index(index, ident, mie_view_item(ident, id,\n+                                                     it.span));\n           }\n           ast::view_item_import(ident, _, id) {\n             add_to_index(index, ident, mie_import_ident(id, it.span));\n@@ -1431,6 +1448,7 @@ fn index_nmod(md: ast::native_mod) -> mod_index {\n             }\n           }\n           ast::view_item_import_glob(_, _) | ast::view_item_export(_, _) { }\n+          _ { /* tag exports */ }\n         }\n     }\n     for it: @ast::native_item in md.items {\n@@ -1450,6 +1468,7 @@ fn ns_for_def(d: def) -> namespace {\n       ast::def_mod(_) | ast::def_native_mod(_) { ns_module }\n       ast::def_ty(_) | ast::def_binding(_) | ast::def_use(_) |\n       ast::def_native_ty(_) { ns_type }\n+      ast::def_ty_param(_, _) { ns_type }\n     }\n }\n \n@@ -1529,10 +1548,10 @@ fn check_mod_name(e: env, name: ident, entries: list<mod_index_entry>) {\n \n fn mie_span(mie: mod_index_entry) -> span {\n     ret alt mie {\n-          mie_view_item(item) { item.span }\n+          mie_view_item(_, _, span) { span }\n           mie_import_ident(_, span) { span }\n           mie_item(item) { item.span }\n-          mie_enum_variant(item, _) { item.span }\n+          mie_enum_variant(_, _, _, span) { span }\n           mie_native_item(item) { item.span }\n         };\n }\n@@ -1559,9 +1578,8 @@ fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n }\n \n fn check_pat(e: @env, ch: checker, p: @ast::pat) {\n-    pat_util::pat_bindings(normalize_pat_def_map(e.def_map, p)) {|p|\n-        let ident = path_to_ident(alt p.node { pat_ident(n, _) { n } });\n-        add_name(ch, p.span, ident);\n+    pat_util::pat_bindings(normalize_pat_def_map(e.def_map, p)) {|_i, p_sp, n|\n+       add_name(ch, p_sp, path_to_ident(n));\n     };\n }\n \n@@ -1607,14 +1625,13 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n               ast::decl_local(locs) {\n                 let local_values = checker(*e, \"value\");\n                 for (_, loc) in locs {\n-                        pat_util::pat_bindings\n-                            (normalize_pat_def_map(e.def_map, loc.node.pat))\n-                            {|p|\n-                            let ident = path_to_ident(alt p.node\n-                                 { pat_ident(n, _) { n } });\n-                        add_name(local_values, p.span, ident);\n-                        check_name(values, p.span, ident);\n-                    };\n+                     pat_util::pat_bindings\n+                        (normalize_pat_def_map(e.def_map, loc.node.pat))\n+                            {|_i, p_sp, n|\n+                            let ident = path_to_ident(n);\n+                            add_name(local_values, p_sp, ident);\n+                            check_name(values, p_sp, ident);\n+                          };\n                 }\n               }\n               ast::decl_item(it) {\n@@ -1807,8 +1824,9 @@ fn check_exports(e: @env) {\n                             some(ms) {\n                                 list::iter(ms) {|m|\n                                    alt m {\n-                                     mie_enum_variant(parent_item,_) {\n-                                       if parent_item.id != parent_id {\n+                                     mie_enum_variant(_, _, actual_parent_id,\n+                                                     _) {\n+                                       if actual_parent_id != parent_id {\n                                           e.sess.span_err(vi.span,\n                                            #fmt(\"variant %s \\\n                                            doesn't belong to enum %s\",\n@@ -1860,6 +1878,10 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n                            scopes);\n             alt e.imports.get(id) {\n               resolved(_, _, _, is, _, _) { act(is); }\n+              _ {\n+                  e.sess.bug(\"Undocumented invariant in \\\n+                    lookup_imported_impls\");\n+              }\n             }\n           }\n           _ {}\n@@ -1899,6 +1921,8 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n                 _ {}\n               }\n             }\n+            _ { e.sess.span_bug(vi.span, \"Undocumented invariant in \\\n+                  find_impls_in_view_item\"); }\n           }\n       }\n       _ {}"}, {"sha": "69c08d68e2016428cd1f77eafd73caedf7fd2b2c", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -451,6 +451,12 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n       ty::ty_opaque_closure_ptr(_) {\n         s += [shape_opaque_closure_ptr];\n       }\n+      ty::ty_constr(inner_t, _) {\n+        s += shape_of(ccx, inner_t, ty_param_map);\n+      }\n+      ty::ty_named(_, _) {\n+        ccx.tcx.sess.bug(\"shape_of: shouldn't see a ty_named\");\n+      }\n     }\n \n     ret s;\n@@ -699,6 +705,7 @@ fn static_size_of_enum(cx: @crate_ctxt, t: ty::t)\n         cx.enum_sizes.insert(t, max_size);\n         ret max_size;\n       }\n+      _ { cx.tcx.sess.bug(\"static_size_of_enum called on non-enum\"); }\n     }\n }\n \n@@ -779,6 +786,11 @@ fn dynamic_metrics(cx: @block_ctxt, t: ty::t) -> metrics {\n \n         { bcx: bcx, sz: sz, align: C_int(ccx, 1) }\n       }\n+      _ {\n+        // Precondition?\n+        bcx_tcx(cx).sess.bug(\"dynamic_metrics: type has static \\\n+          size\");\n+      }\n     }\n }\n "}, {"sha": "a18a6bb1aa11bb309a6e70acb7696433985969c9", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -21,7 +21,7 @@ import common::*;\n // range)\n enum opt {\n     lit(@ast::expr),\n-    var(/* disr val */int, /* variant dids */{tg: def_id, var: def_id}),\n+    var(/* disr val */int, /* variant dids */{enm: def_id, var: def_id}),\n     range(@ast::expr, @ast::expr)\n }\n fn opt_eq(a: opt, b: opt) -> bool {\n@@ -69,7 +69,7 @@ fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n // FIXME: invariant -- pat_id is bound in the def_map?\n fn variant_opt(ccx: @crate_ctxt, pat_id: ast::node_id) -> opt {\n     let vdef = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n-    let variants = ty::enum_variants(ccx.tcx, vdef.tg);\n+    let variants = ty::enum_variants(ccx.tcx, vdef.enm);\n     for v: ty::variant_info in *variants {\n         if vdef.var == v.id { ret var(v.disr_val, vdef); }\n     }\n@@ -262,24 +262,24 @@ fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n }\n \n fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n-                        vdefs: {tg: def_id, var: def_id}, val: ValueRef) ->\n+                        vdefs: {enm: def_id, var: def_id}, val: ValueRef) ->\n    {vals: [ValueRef], bcx: @block_ctxt} {\n     let ccx = bcx.fcx.lcx.ccx, bcx = bcx;\n     // invariant:\n     // pat_id must have the same length ty_param_substs as vdefs?\n     let ty_param_substs = ty::node_id_to_type_params(ccx.tcx, pat_id);\n     let blobptr = val;\n-    let variants = ty::enum_variants(ccx.tcx, vdefs.tg);\n+    let variants = ty::enum_variants(ccx.tcx, vdefs.enm);\n     let args = [];\n     let size =\n-        vec::len(ty::enum_variant_with_id(ccx.tcx, vdefs.tg, vdefs.var).args);\n+       vec::len(ty::enum_variant_with_id(ccx.tcx, vdefs.enm, vdefs.var).args);\n     if size > 0u && vec::len(*variants) != 1u {\n         let enumptr =\n             PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n         blobptr = GEPi(bcx, enumptr, [0, 1]);\n     }\n     let i = 0u;\n-    let vdefs_tg = vdefs.tg;\n+    let vdefs_tg = vdefs.enm;\n     let vdefs_var = vdefs.var;\n     while i < size {\n         check (valid_variant_index(i, bcx, vdefs_tg, vdefs_var));\n@@ -423,8 +423,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     // Separate path for extracting and binding record fields\n     if vec::len(rec_fields) > 0u {\n         let rec_ty = ty::node_id_to_type(ccx.tcx, pat_id);\n-        let fields =\n-            alt ty::struct(ccx.tcx, rec_ty) { ty::ty_rec(fields) { fields } };\n+        let fields = ty::get_fields(ccx.tcx, rec_ty);\n         let rec_vals = [];\n         for field_name: ast::ident in rec_fields {\n             let ix = option::get(ty::field_idx(field_name, fields));\n@@ -444,6 +443,10 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n         let n_tup_elts =\n             alt ty::struct(ccx.tcx, tup_ty) {\n               ty::ty_tup(elts) { vec::len(elts) }\n+              _ {\n+                  ccx.sess.bug(\"Non-tuple type in tuple\\\n+                    pattern\");\n+              }\n             };\n         let tup_vals = [], i = 0u;\n         while i < n_tup_elts {\n@@ -483,7 +486,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     if vec::len(opts) > 0u {\n         alt opts[0] {\n           var(_, vdef) {\n-            if vec::len(*ty::enum_variants(ccx.tcx, vdef.tg)) == 1u {\n+            if vec::len(*ty::enum_variants(ccx.tcx, vdef.enm)) == 1u {\n                 kind = single;\n             } else {\n                 let enumptr =\n@@ -541,6 +544,8 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n                 llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n                 bcx = r.bcx;\n               }\n+              _ { bcx_tcx(bcx).sess.bug(\"Someone forgot to\\\n+                    document an invariant in compile_submatch\"); }\n             }\n           }\n           compare {\n@@ -624,8 +629,11 @@ fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n         // Copy references that the alias analysis considered unsafe\n         ids.values {|node_id|\n             if bcx_ccx(bcx).copy_map.contains_key(node_id) {\n-                let local = alt bcx.fcx.lllocals.get(node_id) {\n-                  local_mem(x) { x }\n+                let local = alt bcx.fcx.lllocals.find(node_id) {\n+                  some(local_mem(x)) { x }\n+                  _ { bcx_tcx(bcx).sess.bug(\"Someone \\\n+                        forgot to document an invariant in \\\n+                        make_phi_bindings\"); }\n                 };\n                 let e_ty = ty::node_id_to_type(bcx_tcx(bcx), node_id);\n                 let {bcx: abcx, val: alloc} = base::alloc_ty(bcx, e_ty);\n@@ -745,8 +753,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n       }\n       ast::pat_rec(fields, _) {\n         let rec_ty = ty::node_id_to_type(ccx.tcx, pat.id);\n-        let rec_fields =\n-            alt ty::struct(ccx.tcx, rec_ty) { ty::ty_rec(fields) { fields } };\n+        let rec_fields = ty::get_fields(ccx.tcx, rec_ty);\n         for f: ast::field_pat in fields {\n             let ix = option::get(ty::field_idx(f.ident, rec_fields));\n             // how to get rid of this check?"}, {"sha": "7bff9b250608ca7197016e451c091c163e4b6a64", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 123, "deletions": 56, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -42,6 +42,7 @@ import link::{mangle_internal_name_by_type_only,\n import metadata::{csearch, cstore};\n import util::ppaux::{ty_to_str, ty_to_short_str};\n \n+import shape::static_size_of_enum;\n import common::*;\n import build::*;\n \n@@ -489,37 +490,6 @@ fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n     ret ty::fold_ty(ccx.tcx, ty::fm_general(bind simplifier(ccx, _)), typ);\n }\n \n-\n-// Computes the size of the data part of a non-dynamically-sized enum.\n-fn static_size_of_enum(cx: @crate_ctxt, t: ty::t)\n-    : type_has_static_size(cx, t) -> uint {\n-    if cx.enum_sizes.contains_key(t) { ret cx.enum_sizes.get(t); }\n-    alt ty::struct(cx.tcx, t) {\n-      ty::ty_enum(tid, subtys) {\n-        // Compute max(variant sizes).\n-\n-        let max_size = 0u;\n-        let variants = ty::enum_variants(cx.tcx, tid);\n-        for variant: ty::variant_info in *variants {\n-            let tup_ty = simplify_type(cx, ty::mk_tup(cx.tcx, variant.args));\n-            // Perform any type parameter substitutions.\n-\n-            tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n-            // Here we possibly do a recursive call.\n-\n-            // FIXME: Avoid this check. Since the parent has static\n-            // size, any field must as well. There should be a way to\n-            // express that with constrained types.\n-            check (type_has_static_size(cx, tup_ty));\n-            let this_size = llsize_of_real(cx, type_of(cx, tup_ty));\n-            if max_size < this_size { max_size = this_size; }\n-        }\n-        cx.enum_sizes.insert(t, max_size);\n-        ret max_size;\n-      }\n-    }\n-}\n-\n fn dynamic_size_of(cx: @block_ctxt, t: ty::t) -> result {\n     fn align_elements(cx: @block_ctxt, elts: [ty::t]) -> result {\n         //\n@@ -600,6 +570,9 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t) -> result {\n             } else { max_size_val };\n         ret rslt(bcx, total_size);\n       }\n+      // Precondition?\n+      _ { bcx_tcx(cx).sess.fatal(\"trans::dynamic_size_of alled on something \\\n+            with static size\"); }\n     }\n }\n \n@@ -634,6 +607,8 @@ fn dynamic_align_of(cx: @block_ctxt, t: ty::t) -> result {\n         }\n         ret rslt(bcx, a);\n       }\n+      _ { bcx_tcx(cx).sess.bug(\"trans::dynamic_align_of called on \\\n+            something with static size\"); }\n     }\n }\n \n@@ -1457,16 +1432,16 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n       ty::ty_int(_) { ret rslt(cx, f(signed_int)); }\n       ty::ty_uint(_) { ret rslt(cx, f(unsigned_int)); }\n       ty::ty_float(_) { ret rslt(cx, f(floating_point)); }\n+      ty::ty_native(_) {\n+        let cx = trans_fail(cx, none::<span>,\n+                            \"attempt to compare values of type native\");\n+        ret rslt(cx, C_nil());\n+      }\n       ty::ty_type {\n         ret rslt(trans_fail(cx, none,\n                             \"attempt to compare values of type type\"),\n                  C_nil());\n       }\n-      ty::ty_native(_) {\n-        let cx = trans_fail(cx, none,\n-                            \"attempt to compare values of type native\");\n-        ret rslt(cx, C_nil());\n-      }\n       _ {\n         // Should never get here, because t is scalar.\n         bcx_ccx(cx).sess.bug(\"non-scalar type passed to \\\n@@ -1479,13 +1454,20 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n // A helper function to do the actual comparison of scalar values.\n fn compare_scalar_values(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n                          nt: scalar_type, op: ast::binop) -> ValueRef {\n+    fn die_(cx: @block_ctxt) -> ! {\n+        bcx_tcx(cx).sess.bug(\"compare_scalar_values: must be a\\\n+          comparison operator\");\n+    }\n+    let die = bind die_(cx);\n     alt nt {\n       nil_type {\n         // We don't need to do actual comparisons for nil.\n         // () == () holds but () < () does not.\n         alt op {\n           ast::eq | ast::le | ast::ge { ret C_bool(true); }\n           ast::ne | ast::lt | ast::gt { ret C_bool(false); }\n+          // refinements would be nice\n+          _ { die(); }\n         }\n       }\n       floating_point {\n@@ -1496,6 +1478,7 @@ fn compare_scalar_values(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n           ast::le { lib::llvm::LLVMRealOLE }\n           ast::gt { lib::llvm::LLVMRealOGT }\n           ast::ge { lib::llvm::LLVMRealOGE }\n+          _ { die(); }\n         };\n         ret FCmp(cx, cmp, lhs, rhs);\n       }\n@@ -1507,6 +1490,7 @@ fn compare_scalar_values(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n           ast::le { lib::llvm::LLVMIntSLE }\n           ast::gt { lib::llvm::LLVMIntSGT }\n           ast::ge { lib::llvm::LLVMIntSGE }\n+          _ { die(); }\n         };\n         ret ICmp(cx, cmp, lhs, rhs);\n       }\n@@ -1518,6 +1502,7 @@ fn compare_scalar_values(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n           ast::le { lib::llvm::LLVMIntULE }\n           ast::gt { lib::llvm::LLVMIntUGT }\n           ast::ge { lib::llvm::LLVMIntUGE }\n+          _ { die(); }\n         };\n         ret ICmp(cx, cmp, lhs, rhs);\n       }\n@@ -1574,6 +1559,8 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n                 j += 1u;\n             }\n           }\n+          // Precondition?\n+          _ { bcx_tcx(cx).sess.bug(\"iter_variant: not a function type\"); }\n         }\n         ret cx;\n     }\n@@ -1846,6 +1833,8 @@ fn drop_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n     alt ty::struct(bcx_tcx(bcx), t) {\n       ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str { free_ty(bcx, v, t) }\n       ty::ty_box(_) | ty::ty_iface(_, _) { decr_refcnt_maybe_free(bcx, v, t) }\n+      // Precondition?\n+      _ { bcx_tcx(bcx).sess.bug(\"drop_ty_immediate: non-box ty\"); }\n     }\n }\n \n@@ -2112,6 +2101,9 @@ fn trans_compare(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n       ast::eq | ast::ne { llop = C_u8(abi::cmp_glue_op_eq); }\n       ast::lt | ast::ge { llop = C_u8(abi::cmp_glue_op_lt); }\n       ast::le | ast::gt { llop = C_u8(abi::cmp_glue_op_le); }\n+      // Precondition?\n+      _ { bcx_tcx(cx).sess.bug(\"trans_compare got\\\n+              non-comparison-op\"); }\n     }\n \n     let rs = call_cmp_glue(cx, lhs, rhs, rhs_t, llop);\n@@ -2122,6 +2114,8 @@ fn trans_compare(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n       ast::ne | ast::ge | ast::gt {\n         ret rslt(rs.bcx, Not(rs.bcx, rs.val));\n       }\n+      _ { bcx_tcx(cx).sess.bug(\"trans_compare got\\\n+              non-comparison-op\"); }\n     }\n }\n \n@@ -2272,9 +2266,12 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n     ret {bcx: cx, val: v1, ty: t1};\n }\n \n-fn trans_lazy_binop(bcx: @block_ctxt, op: ast::binop, a: @ast::expr,\n+// refinement types would obviate the need for this\n+enum lazy_binop_ty { lazy_and, lazy_or }\n+\n+fn trans_lazy_binop(bcx: @block_ctxt, op: lazy_binop_ty, a: @ast::expr,\n                     b: @ast::expr, dest: dest) -> @block_ctxt {\n-    let is_and = alt op { ast::and { true } ast::or { false } };\n+    let is_and = alt op { lazy_and { true } lazy_or { false } };\n     let lhs_res = trans_temp_expr(bcx, a);\n     if lhs_res.bcx.unreachable { ret lhs_res.bcx; }\n     let rhs_cx = new_scope_block_ctxt(lhs_res.bcx, \"rhs\");\n@@ -2321,8 +2318,11 @@ fn trans_binary(bcx: @block_ctxt, op: ast::binop, lhs: @ast::expr,\n \n     // First couple cases are lazy:\n     alt op {\n-      ast::and | ast::or {\n-        ret trans_lazy_binop(bcx, op, lhs, rhs, dest);\n+      ast::and {\n+        ret trans_lazy_binop(bcx, lazy_and, lhs, rhs, dest);\n+      }\n+      ast::or {\n+        ret trans_lazy_binop(bcx, lazy_or, lhs, rhs, dest);\n       }\n       _ {\n         // Remaining cases are eager:\n@@ -2394,7 +2394,11 @@ fn store_in_dest(bcx: @block_ctxt, val: ValueRef, dest: dest) -> @block_ctxt {\n }\n \n fn get_dest_addr(dest: dest) -> ValueRef {\n-    alt dest { save_in(a) { a } }\n+    alt dest {\n+       save_in(a) { a }\n+       // Precondition?\n+       _ { fail \"get_dest_addr: not a save_in\"; }\n+    }\n }\n \n fn trans_if(cx: @block_ctxt, cond: @ast::expr, thn: ast::blk,\n@@ -2425,6 +2429,9 @@ fn trans_if(cx: @block_ctxt, cond: @ast::expr, thn: ast::blk,\n           ast::expr_block(blk) {\n             else_cx = trans_block_dps(else_cx, blk, else_dest);\n           }\n+          // would be nice to have a constraint on ifs\n+          _ { bcx_tcx(cx).sess.bug(\"Strange alternative\\\n+                in if\"); }\n         }\n       }\n       _ {}\n@@ -2691,7 +2698,12 @@ fn trans_rec_field(bcx: @block_ctxt, base: @ast::expr,\n                    field: ast::ident) -> lval_result {\n     let {bcx, val} = trans_temp_expr(bcx, base);\n     let {bcx, val, ty} = autoderef(bcx, val, ty::expr_ty(bcx_tcx(bcx), base));\n-    let fields = alt ty::struct(bcx_tcx(bcx), ty) { ty::ty_rec(fs) { fs } };\n+    let fields = alt ty::struct(bcx_tcx(bcx), ty) {\n+            ty::ty_rec(fs) { fs }\n+            // Constraint?\n+            _ { bcx_tcx(bcx).sess.span_bug(base.span, \"trans_rec_field:\\\n+                 base expr has non-record type\"); }\n+        };\n     let ix = option::get(ty::field_idx(field, fields));\n     // Silly check\n     check type_is_tup_like(bcx, ty);\n@@ -2763,6 +2775,9 @@ fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n               some(origin) { // An impl method\n                 ret impl::trans_method_callee(bcx, e.id, base, origin);\n               }\n+              // Precondition?\n+              _ { bcx_tcx(bcx).sess.span_bug(e.span, \"trans_callee: weird\\\n+                    expr\"); }\n             }\n         }\n       }\n@@ -2809,6 +2824,11 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n                 PointerCast(sub.bcx, sub.val, ellty)\n               }\n               ty::ty_ptr(_) | ty::ty_uniq(_) { sub.val }\n+              // Precondition?\n+              _ {\n+                  bcx_tcx(cx).sess.span_bug(e.span, \"trans_lval:\\\n+                    Weird argument in deref\");\n+              }\n             };\n         ret lval_owned(sub.bcx, val);\n       }\n@@ -2949,6 +2969,7 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n               integral {int_cast(e_res.bcx, ll_t_out,\n                                   val_ty(lldiscrim_a), lldiscrim_a, true)}\n               float {SIToFP(e_res.bcx, lldiscrim_a, ll_t_out)}\n+              _ { ccx.sess.bug(\"Translating unsupported cast.\") }\n             }\n           }\n           _ { ccx.sess.bug(\"Translating unsupported cast.\") }\n@@ -2990,7 +3011,7 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n         if arg.mode == ast::by_val && (lv.kind == owned || !imm) {\n             val = Load(bcx, val);\n         }\n-    } else if arg.mode == ast::by_copy {\n+        } else if arg.mode == ast::by_copy {\n         let {bcx: cx, val: alloc} = alloc_ty(bcx, e_ty);\n         let last_use = ccx.last_uses.contains_key(e.id);\n         bcx = cx;\n@@ -3341,6 +3362,7 @@ fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n         ret bcx;\n       }\n       save_in(pos) { pos }\n+      _ { bcx_tcx(bcx).sess.bug(\"trans_tup: weird dest\"); }\n     };\n     let temp_cleanups = [], i = 0;\n     for e in elts {\n@@ -3368,9 +3390,12 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n         ret bcx;\n       }\n       save_in(pos) { pos }\n+      _ { bcx_tcx(bcx).sess.bug(\"trans_rec: weird dest\"); }\n     };\n \n-    let ty_fields = alt ty::struct(bcx_tcx(bcx), t) { ty::ty_rec(f) { f } };\n+    let ty_fields = alt ty::struct(bcx_tcx(bcx), t) { ty::ty_rec(f) { f }\n+      _ { bcx_tcx(bcx).sess.bug(\"trans_rec: id doesn't\\\n+           have a record type\") } };\n     let temp_cleanups = [];\n     for fld in fields {\n         let ix = option::get(vec::position_pred(ty_fields, {|ft|\n@@ -3644,6 +3669,9 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         assert dest == ignore;\n         ret trans_assign_op(bcx, e, op, dst, src);\n       }\n+      _ { bcx_tcx(bcx).sess.span_bug(e.span, \"trans_expr reached\\\n+             fall-through case\"); }\n+\n     }\n }\n \n@@ -3914,9 +3942,18 @@ fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     let ty = node_id_type(bcx_ccx(bcx), local.node.id);\n     let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n       some(local_mem(v)) { v }\n+      some(_) { bcx_tcx(bcx).sess.span_bug(local.span,\n+                        \"init_local: Someone forgot to document why it's\\\n+                         safe to assume local.node.init must be local_mem!\");\n+      }\n       // This is a local that is kept immediate\n       none {\n-        let initexpr = alt local.node.init { some({expr, _}) { expr } };\n+        let initexpr = alt local.node.init {\n+                some({expr, _}) { expr }\n+                none { bcx_tcx(bcx).sess.span_bug(local.span,\n+                        \"init_local: Someone forgot to document why it's\\\n+                         safe to assume local.node.init isn't none!\"); }\n+            };\n         let {bcx, val, kind} = trans_temp_lval(bcx, initexpr);\n         if kind != temporary {\n             if kind == owned { val = Load(bcx, val); }\n@@ -3952,6 +3989,8 @@ fn init_ref_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     alt kind {\n       owned_imm { val = do_spill_noroot(bcx, val); }\n       owned {}\n+      _ { bcx_tcx(bcx).sess.span_bug(local.span,\n+           \"Someone forgot to document an invariant in init_ref_local!\"); }\n     }\n     ret alt::bind_irrefutable_pat(bcx, local.node.pat, val, false);\n }\n@@ -4388,9 +4427,15 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n                         arg_tys: [ty::arg]) -> @block_ctxt {\n     let arg_n: uint = 0u, bcx = bcx;\n+    fn epic_fail_(bcx: @block_ctxt) -> ! {\n+        bcx_tcx(bcx).sess.bug(\"Someone forgot\\\n+                to document an invariant in copy_args_to_allocas!\");\n+    }\n+    let epic_fail = bind epic_fail_(bcx);\n     for arg in arg_tys {\n         let id = args[arg_n].id;\n-        let argval = alt fcx.llargs.get(id) { local_mem(v) { v } };\n+        let argval = alt fcx.llargs.get(id) { local_mem(v) { v }\n+                                              _ { epic_fail() } };\n         alt arg.mode {\n           ast::by_mut_ref { }\n           ast::by_move | ast::by_copy { add_clean(bcx, argval, arg.ty); }\n@@ -4405,6 +4450,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n             }\n           }\n           ast::by_ref {}\n+          _ { epic_fail(); }\n         }\n         if fcx_ccx(fcx).sess.opts.extra_debuginfo {\n             debuginfo::create_arg(bcx, args[arg_n], args[arg_n].ty.span);\n@@ -4414,9 +4460,13 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n     ret bcx;\n }\n \n+// cries out for a precondition\n fn arg_tys_of_fn(ccx: @crate_ctxt, id: ast::node_id) -> [ty::arg] {\n-    alt ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, id)) {\n+    let tt = ty::node_id_to_type(ccx.tcx, id);\n+    alt ty::struct(ccx.tcx, tt) {\n       ty::ty_fn({inputs, _}) { inputs }\n+      _ { ccx.sess.bug(#fmt(\"arg_tys_of_fn called on non-function\\\n+            type %s\", ty_to_str(ccx.tcx, tt)));}\n     }\n }\n \n@@ -4438,14 +4488,14 @@ enum self_arg { impl_self(ty::t), no_self, }\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-fn trans_closure(cx: @local_ctxt, sp: span, decl: ast::fn_decl,\n+fn trans_closure(cx: @local_ctxt, decl: ast::fn_decl,\n                  body: ast::blk, llfndecl: ValueRef,\n                  ty_self: self_arg, ty_params: [ast::ty_param],\n                  id: ast::node_id, maybe_load_env: fn(@fn_ctxt)) {\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n-    let fcx = new_fn_ctxt_w_id(cx, llfndecl, id, decl.cf, some(sp));\n+    let fcx = new_fn_ctxt_w_id(cx, llfndecl, id, decl.cf, some(body.span));\n     create_llargs_for_fn_args(fcx, ty_self, decl.inputs, ty_params);\n \n     // Create the first basic block in the function and keep a handle on it to\n@@ -4480,7 +4530,7 @@ fn trans_closure(cx: @local_ctxt, sp: span, decl: ast::fn_decl,\n \n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n-fn trans_fn(cx: @local_ctxt, sp: span, decl: ast::fn_decl, body: ast::blk,\n+fn trans_fn(cx: @local_ctxt, decl: ast::fn_decl, body: ast::blk,\n             llfndecl: ValueRef, ty_self: self_arg, ty_params: [ast::ty_param],\n             id: ast::node_id) {\n     let do_time = cx.ccx.sess.opts.stats;\n@@ -4490,7 +4540,7 @@ fn trans_fn(cx: @local_ctxt, sp: span, decl: ast::fn_decl, body: ast::blk,\n                     {sec: 0u32, usec: 0u32}\n                 };\n     let fcx = option::none;\n-    trans_closure(cx, sp, decl, body, llfndecl, ty_self, ty_params, id,\n+    trans_closure(cx, decl, body, llfndecl, ty_self, ty_params, id,\n                   {|new_fcx| fcx = option::some(new_fcx);});\n     if cx.ccx.sess.opts.extra_debuginfo {\n         debuginfo::create_function(option::get(fcx));\n@@ -4516,6 +4566,8 @@ fn trans_res_ctor(cx: @local_ctxt, dtor: ast::fn_decl,\n     let tup_t = ty::mk_tup(ccx.tcx, [ty::mk_int(ccx.tcx), arg_t]);\n     let arg = alt fcx.llargs.find(dtor.inputs[0].id) {\n       some(local_mem(x)) { x }\n+      _ { ccx.sess.bug(\"Someone forgot to document an invariant \\\n+            in trans_res_ctor\"); }\n     };\n     let llretptr = fcx.llretptr;\n     if ty::type_has_dynamic_size(ccx.tcx, ret_t) {\n@@ -4603,7 +4655,9 @@ fn trans_enum_variant(cx: @local_ctxt, enum_id: ast::node_id,\n         // If this argument to this function is a enum, it'll have come in to\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n-        let llarg = alt fcx.llargs.find(va.id) { some(local_mem(x)) { x } };\n+        let llarg = alt fcx.llargs.find(va.id) { some(local_mem(x)) { x }\n+          _ { bcx_tcx(bcx).sess.span_fatal(variant.span, \"Someone forgot\\\n+                to document an invariant in trans_tag_variant\"); } };\n         let arg_ty = arg_tys[i].ty;\n         if ty::type_contains_params(bcx_tcx(bcx), arg_ty) {\n             lldestptr = PointerCast(bcx, lldestptr, val_ty(llarg));\n@@ -4733,6 +4787,10 @@ fn c_stack_tys(ccx: @crate_ctxt,\n             shim_fn_ty: T_fn([T_ptr(bundle_ty)], T_void())\n         };\n       }\n+      _ {\n+          // Precondition?\n+          ccx.tcx.sess.bug(\"c_stack_tys called on non-function type\");\n+      }\n     }\n }\n \n@@ -4889,7 +4947,7 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n         let sub_cx = extend_path(cx, item.ident);\n         alt cx.ccx.item_ids.find(item.id) {\n           some(llfndecl) {\n-            trans_fn(sub_cx, item.span, decl, body, llfndecl, no_self, tps,\n+            trans_fn(sub_cx, decl, body, llfndecl, no_self, tps,\n                      item.id);\n           }\n           _ {\n@@ -4907,7 +4965,7 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n         // Create a function for the destructor\n         alt cx.ccx.item_ids.find(item.id) {\n           some(lldtor_decl) {\n-            trans_fn(cx, item.span, decl, body, lldtor_decl, no_self,\n+            trans_fn(cx, decl, body, lldtor_decl, no_self,\n                      tps, dtor_id);\n           }\n           _ {\n@@ -4998,8 +5056,10 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n     }\n \n     let main_takes_argv =\n+        // invariant!\n         alt ty::struct(ccx.tcx, main_node_type) {\n           ty::ty_fn({inputs, _}) { vec::len(inputs) != 0u }\n+          _ { ccx.sess.span_fatal(sp, \"main has a non-function type\"); }\n         };\n \n     let llfn = create_main(ccx, main_llfn, main_takes_argv);\n@@ -5094,7 +5154,10 @@ fn fill_fn_pair(bcx: @block_ctxt, pair: ValueRef, llfn: ValueRef,\n fn native_fn_ty_param_count(cx: @crate_ctxt, id: ast::node_id) -> uint {\n     let count;\n     let native_item =\n-        alt cx.ast_map.find(id) { some(ast_map::node_native_item(i)) { i } };\n+        // invariant?!\n+        alt cx.ast_map.find(id) { some(ast_map::node_native_item(i)) { i }\n+         _ { cx.sess.bug(\"native_fn_ty_param_count\\\n+                         given a non-native item\"); } };\n     alt native_item.node {\n       ast::native_item_ty {\n         cx.sess.bug(\"register_native_fn(): native fn isn't \\\n@@ -5107,13 +5170,17 @@ fn native_fn_ty_param_count(cx: @crate_ctxt, id: ast::node_id) -> uint {\n     ret count;\n }\n \n-fn native_fn_wrapper_type(cx: @crate_ctxt,\n+\n+// TODO: precondition\n+fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span,\n                           param_bounds: [ty::param_bounds],\n                           x: ty::t) -> TypeRef {\n     alt ty::struct(cx.tcx, x) {\n       ty::ty_fn({inputs: args, output: out, _}) {\n         ret type_of_fn(cx, args, out, param_bounds);\n       }\n+      _ { cx.sess.span_bug(sp, \"native_fn_wrapper_type got ill-typed\\\n+              thing\"); }\n     }\n }\n "}, {"sha": "4ff6d6fca2b80564a4884f75851dbe8ed7b7d490", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -520,7 +520,7 @@ fn trans_expr_fn(bcx: @block_ctxt,\n         let cap_vars = capture::compute_capture_vars(\n             ccx.tcx, id, proto, cap_clause);\n         let {llbox, cbox_ty, bcx} = build_closure(bcx, cap_vars, ck);\n-        trans_closure(sub_cx, sp, decl, body, llfn, no_self, [], id, {|fcx|\n+        trans_closure(sub_cx, decl, body, llfn, no_self, [], id, {|fcx|\n             load_environment(bcx, fcx, cbox_ty, cap_vars, ck);\n         });\n         llbox\n@@ -532,7 +532,7 @@ fn trans_expr_fn(bcx: @block_ctxt,\n       ast::proto_uniq { trans_closure_env(ty::ck_uniq) }\n       ast::proto_bare {\n         let closure = C_null(T_opaque_cbox_ptr(ccx));\n-        trans_closure(sub_cx, sp, decl, body, llfn, no_self, [],\n+        trans_closure(sub_cx, decl, body, llfn, no_self, [],\n                       id, {|_fcx|});\n         closure\n       }"}, {"sha": "96cc79a6db250a885cf6953f88781233cd7567d1", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -414,6 +414,9 @@ fn find_scope_cx(cx: @block_ctxt) -> @block_ctxt {\n     if cx.kind != NON_SCOPE_BLOCK { ret cx; }\n     alt cx.parent {\n       parent_some(b) { ret find_scope_cx(b); }\n+      _ {\n+          bcx_tcx(cx).sess.bug(\"find_scope_cx: empty scope\");\n+      }\n     }\n }\n "}, {"sha": "ded05d4bc0c92a63a0561bab7ecb867e1f665410", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -2,6 +2,7 @@ import core::ctypes::c_uint;\n import base::*;\n import common::*;\n import build::*;\n+import driver::session::session;\n import option::{some, none};\n import syntax::{ast, ast_util};\n import metadata::csearch;\n@@ -45,10 +46,13 @@ fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method],\n     for m in methods {\n         alt cx.ccx.item_ids.find(m.id) {\n           some(llfn) {\n-            trans_fn(extend_path(sub_cx, m.ident), m.span, m.decl, m.body,\n+            trans_fn(extend_path(sub_cx, m.ident), m.decl, m.body,\n                      llfn, impl_self(ty::node_id_to_type(cx.ccx.tcx, id)),\n                      tps + m.tps, m.id);\n           }\n+          _ {\n+            cx.ccx.tcx.sess.bug(\"Unbound id in trans_impl\");\n+          }\n         }\n     }\n }\n@@ -148,6 +152,9 @@ fn trans_iface_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n                            T_opaque_cbox_ptr(bcx_ccx(bcx)));\n     let iface_id = alt ty::struct(tcx, ty::expr_ty(tcx, base)) {\n         ty::ty_iface(did, _) { did }\n+        // precondition\n+        _ { bcx_tcx(bcx).sess.span_bug(base.span, \"base has non-iface type \\\n+             in trans_iface_callee\"); }\n     };\n     trans_vtable_callee(bcx, self, dict, callee_id, iface_id, n_method)\n }\n@@ -241,6 +248,10 @@ fn trans_impl_vtable(ccx: @crate_ctxt, pt: [ast::ident],\n             let target = ccx.item_ids.get(m.id);\n             trans_impl_wrapper(ccx, new_pt + [m.ident], extra_tps, target)\n           }\n+          _ {\n+            ccx.tcx.sess.span_bug(it.span, \"No matching method \\\n+               in trans_impl_vtable\");\n+          }\n         }\n     });\n     let s = link::mangle_internal_name_by_path(ccx, new_pt + [\"!vtable\"]);\n@@ -340,6 +351,10 @@ fn dict_id(tcx: ty::ctxt, origin: typeck::dict_origin) -> dict_id {\n                     d_params += [dict_param_dict(dict_id(tcx, origs[orig]))];\n                     orig += 1u;\n                   }\n+                  _ {\n+                    tcx.sess.bug(\"Someone forgot to document an invariant in \\\n+                      dict_id\");\n+                  }\n                 }\n             }\n         }\n@@ -348,6 +363,9 @@ fn dict_id(tcx: ty::ctxt, origin: typeck::dict_origin) -> dict_id {\n       typeck::dict_iface(did) {\n         @{def: did, params: []}\n       }\n+      _ {\n+        tcx.sess.bug(\"Unexpected dict_param in dict_id\");\n+      }\n     }\n }\n \n@@ -410,6 +428,9 @@ fn get_dict_ptrs(bcx: @block_ctxt, origin: typeck::dict_origin)\n       typeck::dict_iface(did) {\n         {bcx: bcx, ptrs: [get_vtable(ccx, did)]}\n       }\n+      _ {\n+        bcx_tcx(bcx).sess.bug(\"Unexpected dict_param in get_dict_ptrs\");\n+      }\n     }\n }\n "}, {"sha": "7b4d0033ec8e61c395554c541a48e1f19d0d2e22", "filename": "src/comp/middle/trans/tvec.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -1,6 +1,7 @@\n import vec;\n import option::none;\n import syntax::ast;\n+import driver::session::session;\n import lib::llvm::llvm::{ValueRef, TypeRef};\n import back::abi;\n import base::{call_memmove, trans_shared_malloc, type_of_or_i8,\n@@ -159,6 +160,10 @@ fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     let strings = alt ty::struct(bcx_tcx(cx), vec_ty) {\n       ty::ty_str { true }\n       ty::ty_vec(_) { false }\n+      _ {\n+          // precondition?\n+          bcx_tcx(cx).sess.bug(\"Bad argument type in trans_append\");\n+      }\n     };\n \n     let {bcx: bcx, val: unit_sz} = size_of(cx, unit_ty);\n@@ -230,7 +235,7 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n     let ccx = bcx_ccx(bcx);\n     let strings = alt ty::struct(bcx_tcx(bcx), vec_ty) {\n       ty::ty_str { true }\n-      ty::ty_vec(_) { false }\n+      _ { false }\n     };\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);"}, {"sha": "cca7e8a7399ab82431d023761d9d10db01372b04", "filename": "src/comp/middle/trans/uniq.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -74,6 +74,7 @@ fn content_ty(bcx: @block_ctxt, t: ty::t)\n \n     alt ty::struct(bcx_tcx(bcx), t) {\n       ty::ty_uniq({ty: ct, _}) { ct }\n+      _ { std::util::unreachable(); }\n     }\n }\n "}, {"sha": "2934d4a5b1e066a9e1848c3bdd0c7a9ca08ff16f", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -582,12 +582,14 @@ fn expr_to_constr_arg(tcx: ty::ctxt, e: @expr) -> @constr_arg_use {\n             ret @respan(p.span,\n                         carg_ident({ident: p.node.idents[0], node: id.node}));\n           }\n-          some(_) {\n-            tcx.sess.bug(\"exprs_to_constr_args: non-local variable \" +\n-                             \"as pred arg\");\n+          some(what) {\n+              tcx.sess.span_bug(e.span,\n+                 #fmt(\"exprs_to_constr_args: non-local variable %? \\\n+                                     as pred arg\", what));\n           }\n           none {\n-            tcx.sess.bug(\"exprs_to_constr_args: NONE \" + \"as pred arg\");\n+              tcx.sess.span_bug(e.span,\n+                 \"exprs_to_constr_args: unbound id as pred arg\");\n \n           }\n         }\n@@ -1055,10 +1057,8 @@ type binding = {lhs: [inst], rhs: option::t<initializer>};\n \n fn local_to_bindings(tcx: ty::ctxt, loc: @local) -> binding {\n     let lhs = [];\n-    pat_bindings(pat_util::normalize_pat(tcx, loc.node.pat)) {|p|\n-            let ident = alt p.node\n-               { pat_ident(name, _) { path_to_ident(name) } };\n-        lhs += [{ident: ident, node: p.id}];\n+    pat_bindings(pat_util::normalize_pat(tcx, loc.node.pat)) {|p_id, _s, name|\n+        lhs += [{ident: path_to_ident(name), node: p_id}];\n     };\n     {lhs: lhs, rhs: loc.node.init}\n }\n@@ -1070,7 +1070,7 @@ fn locals_to_bindings(tcx: ty::ctxt,\n     ret rslt;\n }\n \n-fn callee_modes(fcx: fn_ctxt, callee: node_id) -> [ty::mode] {\n+fn callee_modes(fcx: fn_ctxt, callee: node_id) -> [mode] {\n     let ty =\n         ty::type_autoderef(fcx.ccx.tcx,\n                            ty::node_id_to_type(fcx.ccx.tcx, callee));\n@@ -1089,7 +1089,7 @@ fn callee_modes(fcx: fn_ctxt, callee: node_id) -> [ty::mode] {\n }\n \n fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> [init_op] {\n-    fn mode_to_op(m: ty::mode) -> init_op {\n+    fn mode_to_op(m: mode) -> init_op {\n         alt m { by_move { init_move } _ { init_assign } }\n     }\n     vec::map(callee_modes(fcx, callee), mode_to_op)"}, {"sha": "1abc9903d5c1ecd9df5d6123e9a1e94c375cca04", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -12,11 +12,9 @@ import aux::*;\n type ctxt = {cs: @mutable [sp_constr], tcx: ty::ctxt};\n \n fn collect_local(loc: @local, cx: ctxt, v: visit::vt<ctxt>) {\n-    pat_bindings(pat_util::normalize_pat(cx.tcx, loc.node.pat)) {|p|\n-            let ident = alt p.node\n-                 { pat_ident(id, _) { path_to_ident(id) } };\n-        log(debug, \"collect_local: pushing \" + ident);;\n-        *cx.cs += [respan(loc.span, ninit(p.id, ident))];\n+    pat_bindings(pat_util::normalize_pat(cx.tcx, loc.node.pat))\n+     {|p_id, _s, id|\n+       *cx.cs += [respan(loc.span, ninit(p_id, path_to_ident(id)))];\n     };\n     visit::visit_local(loc, cx, v);\n }\n@@ -26,10 +24,6 @@ fn collect_pred(e: @expr, cx: ctxt, v: visit::vt<ctxt>) {\n       expr_check(_, ch) { *cx.cs += [expr_to_constr(cx.tcx, ch)]; }\n       expr_if_check(ex, _, _) { *cx.cs += [expr_to_constr(cx.tcx, ex)]; }\n \n-\n-\n-\n-\n       // If it's a call, generate appropriate instances of the\n       // call's constraints.\n       expr_call(operator, operands, _) {"}, {"sha": "9977b20cddbabc4d89a222a7102d902425297722", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -18,7 +18,6 @@ import util::common::{new_def_hash, log_expr, field_exprs,\n import syntax::codemap::span;\n import driver::session::session;\n \n-\n fn find_pre_post_mod(_m: _mod) -> _mod {\n     #debug(\"implement find_pre_post_mod!\");\n     fail;\n@@ -106,14 +105,12 @@ fn find_pre_post_loop(fcx: fn_ctxt, l: @local, index: @expr, body: blk,\n                       id: node_id) {\n     find_pre_post_expr(fcx, index);\n     find_pre_post_block(fcx, body);\n-    pat_bindings(normalize_pat(fcx.ccx.tcx, l.node.pat)) {|p|\n-        let ident = alt p.node\n-             { pat_ident(id, _) { path_to_ident(id) } };\n-        let v_init = ninit(p.id, ident);\n+    pat_bindings(normalize_pat(fcx.ccx.tcx, l.node.pat)) {|p_id, _s, n|\n+        let v_init = ninit(p_id, path_to_ident(n));\n         relax_precond_block(fcx, bit_num(fcx, v_init) as node_id, body);\n         // Hack: for-loop index variables are frequently ignored,\n         // so we pretend they're used\n-        use_var(fcx, p.id);\n+        use_var(fcx, p_id);\n     };\n \n     let loop_precond =\n@@ -289,10 +286,10 @@ fn handle_var_def(fcx: fn_ctxt, rslt: pre_and_post, def: def, name: ident) {\n     }\n }\n \n-fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: [ty::mode],\n+fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: [mode],\n                         operands: [@expr]) {\n     let i = 0u;\n-    for mode: ty::mode in modes {\n+    for mode: mode in modes {\n         if mode == by_move {\n             forget_in_postcond(fcx, parent.id, operands[i].id);\n         }\n@@ -571,8 +568,8 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                     /* LHS always becomes initialized,\n                      whether or not this is a move */\n                     find_pre_post_expr(fcx, an_init.expr);\n-                    pat_bindings(alocal.node.pat) {|p|\n-                        copy_pre_post(fcx.ccx, p.id, an_init.expr);\n+                    pat_bindings(alocal.node.pat) {|p_id, _s, _n|\n+                        copy_pre_post(fcx.ccx, p_id, an_init.expr);\n                     };\n                     /* Inherit ann from initializer, and add var being\n                        initialized to the postcondition */\n@@ -585,24 +582,20 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                     }\n \n                     pat_bindings(normalize_pat(fcx.ccx.tcx, alocal.node.pat))\n-                        {|pat|\n-                        /* FIXME: This won't be necessary when typestate\n-                        works well enough for pat_bindings to return a\n-                        refinement-typed thing. */\n-                            let ident = alt pat.node\n-                                     { pat_ident(n, _) { path_to_ident(n) } };\n+                        {|p_id, _s, n|\n+                        let ident = path_to_ident(n);\n                         alt p {\n                           some(p) {\n                             copy_in_postcond(fcx, id,\n-                                             {ident: ident, node: pat.id},\n+                                             {ident: ident, node: p_id},\n                                              {ident:\n                                                   path_to_ident(p),\n                                               node: an_init.expr.id},\n                                              op_to_oper_ty(an_init.op));\n                           }\n                           none { }\n                         }\n-                        gen(fcx, id, ninit(pat.id, ident));\n+                        gen(fcx, id, ninit(p_id, ident));\n                     };\n \n                     if an_init.op == init_move && is_path(an_init.expr) {\n@@ -617,22 +610,16 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                     /* Include the LHSs too, since those aren't in the\n                      postconds of the RHSs themselves */\n                     pat_bindings(normalize_pat(fcx.ccx.tcx, alocal.node.pat))\n-                        {|pat|\n-                            // FIXME\n-                            // Generalize this pattern? map_if_ident...\n-                        alt pat.node {\n-                          pat_ident(n, _) {\n+                        {|pat_id, _s, n|\n                             set_in_postcond(bit_num(fcx,\n-                               ninit(pat.id, path_to_ident(n))), prev_pp);\n-                          }\n-                        }\n-                    };\n+                               ninit(pat_id, path_to_ident(n))), prev_pp);\n+                          };\n                     copy_pre_post_(fcx.ccx, id, prev_pp.precondition,\n                                    prev_pp.postcondition);\n                   }\n                   none {\n-                    pat_bindings(alocal.node.pat) {|p|\n-                        clear_pp(node_id_to_ts_ann(fcx.ccx, p.id).conditions);\n+                      pat_bindings(alocal.node.pat) {|p_id, _s, _n|\n+                        clear_pp(node_id_to_ts_ann(fcx.ccx, p_id).conditions);\n                     };\n                     clear_pp(node_id_to_ts_ann(fcx.ccx, id).conditions);\n                   }"}, {"sha": "9a4bfc26ddf948a8cde7ccbbbb32421f9a26e177", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -215,6 +215,8 @@ fn find_pre_post_state_exprs(fcx: fn_ctxt, pres: prestate, id: node_id,\n \n fn find_pre_post_state_loop(fcx: fn_ctxt, pres: prestate, l: @local,\n                             index: @expr, body: blk, id: node_id) -> bool {\n+    // I'm confused about this -- how does the poststate for the body\n+    // ever grow larger? It seems like it can't?\n     let loop_pres = intersect_states(pres, block_poststate(fcx.ccx, body));\n \n     let changed =\n@@ -224,10 +226,9 @@ fn find_pre_post_state_loop(fcx: fn_ctxt, pres: prestate, l: @local,\n     // Make sure the index vars are considered initialized\n     // in the body\n     let index_post = tritv_clone(expr_poststate(fcx.ccx, index));\n-    pat_bindings(pat_util::normalize_pat(fcx.ccx.tcx, l.node.pat)) {|p|\n-        let ident = alt p.node\n-           { pat_ident(name, _) { path_to_ident(name) } };\n-        set_in_poststate_ident(fcx, p.id, ident, index_post);\n+    pat_bindings(pat_util::normalize_pat(fcx.ccx.tcx, l.node.pat))\n+      {|p_id, _s, n|\n+       set_in_poststate_ident(fcx, p_id, path_to_ident(n), index_post);\n     };\n \n     changed |= find_pre_post_state_block(fcx, index_post, body);"}, {"sha": "597fd548f04ca98f90afeb8e78c0968187cf0ba5", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -42,6 +42,7 @@ export fold_ty;\n export field;\n export field_idx;\n export get_field;\n+export get_fields;\n export fm_general;\n export get_element_type;\n export idx_nil;\n@@ -84,7 +85,6 @@ export mk_var;\n export mk_opaque_closure_ptr;\n export mk_named;\n export gen_ty;\n-export mode;\n export mt;\n export node_type_table;\n export pat_ty;\n@@ -125,7 +125,6 @@ export ty_ptr;\n export ty_rec;\n export ty_enum;\n export ty_tup;\n-export ty_type;\n export ty_send_type;\n export ty_uint;\n export ty_uniq;\n@@ -177,7 +176,6 @@ export variant_info;\n export walk_ty;\n export occurs_check_fails;\n export closure_kind;\n-export ck_any;\n export ck_block;\n export ck_box;\n export ck_uniq;\n@@ -186,7 +184,10 @@ export param_bounds_to_kind;\n \n // Data types\n \n-type arg = {mode: mode, ty: t};\n+// TODO: really should be a separate type, or a refinement,\n+// so that we don't have to handle the mode_infer case after\n+// typeck. but that's too hard right now.\n+type arg = {mode: ast::mode, ty: t};\n \n type field = {ident: ast::ident, mt: mt};\n \n@@ -232,7 +233,6 @@ type raw_t = {struct: sty,\n type t = uint;\n \n enum closure_kind {\n-    ck_any,\n     ck_block,\n     ck_box,\n     ck_uniq,\n@@ -458,7 +458,7 @@ fn mk_raw_ty(cx: ctxt, st: sty) -> @raw_t {\n     }\n     alt st {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_str | ty_send_type | ty_type | ty_native(_) |\n+      ty_str | ty_type | ty_send_type | ty_native(_) |\n       ty_opaque_closure_ptr(_) {\n         /* no-op */\n       }\n@@ -629,7 +629,7 @@ pure fn struct_raw(cx: ctxt, typ: t) -> sty {\n     interner::get(*cx.ts, typ).struct\n }\n \n-// Returns struact(cx, typ) but replaces all occurences of platform\n+// Returns struct(cx, typ) but replaces all occurences of platform\n // dependent primitive types with their machine type equivalent\n pure fn mach_struct(cx: ctxt, cfg: @session::config, typ: t) -> sty {\n     alt interner::get(*cx.ts, typ).struct {\n@@ -678,6 +678,9 @@ fn walk_ty(cx: ctxt, ty: t, f: fn(t)) {\n       }\n       ty_constr(sub, _) { walk_ty(cx, sub, f); }\n       ty_uniq(tm) { walk_ty(cx, tm.ty, f); }\n+      // precondition?\n+      ty_named(_,_) { cx.sess.bug(\"walk_ty: should not see a ty_named \\\n+                        here\"); }\n     }\n     f(ty);\n }\n@@ -699,7 +702,7 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n     }\n     alt interner::get(*cx.ts, ty).struct {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_str | ty_send_type | ty_type | ty_native(_) |\n+      ty_str | ty_type | ty_send_type | ty_native(_) |\n       ty_opaque_closure_ptr(_) {\n         /* no-op */\n       }\n@@ -1033,6 +1036,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n           param_bounds_to_kind(cx.ty_param_bounds.get(did.node))\n       }\n       ty_constr(t, _) { type_kind(cx, t) }\n+      _ { cx.sess.bug(\"Bad type in type_kind\"); }\n     };\n \n     cx.kind_cache.insert(ty, result);\n@@ -1192,9 +1196,14 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       }\n       ty_constr(subt, _) { result = type_is_pod(cx, subt); }\n       ty_var(_) {\n-        fail \"ty_var in type_is_pod\";\n+          cx.sess.bug(\"ty_var in type_is_pod\");\n       }\n       ty_param(_, _) { result = false; }\n+      ty_opaque_closure_ptr(_) { result = true; }\n+      ty_named(_,_) {\n+          cx.sess.bug(\"ty_named in type_is_pod\");\n+      }\n+\n     }\n \n     ret result;\n@@ -1577,12 +1586,17 @@ fn field_idx(id: ast::ident, fields: [field]) -> option::t<uint> {\n }\n \n fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n+    alt vec::find(get_fields(tcx, rec_ty), {|f| str::eq(f.ident, id) }) {\n+         some(f) { ret f; }\n+         _ { tcx.sess.bug(#fmt(\"get_field: bad field id %s\", id)); }\n+    }\n+}\n+\n+// TODO: could have a precondition instead of failing\n+fn get_fields(tcx:ctxt, rec_ty:t) -> [field] {\n     alt struct(tcx, rec_ty) {\n-      ty_rec(fields) {\n-        alt vec::find(fields, {|f| str::eq(f.ident, id) }) {\n-            some(f) { ret f; }\n-        }\n-      }\n+       ty::ty_rec(fields) { fields }\n+       _ { tcx.sess.bug(\"get_fields called on non-record type\"); }\n     }\n }\n \n@@ -1669,6 +1683,8 @@ mod unify {\n              variance: variance) -> union_result {\n         let vb = alt cx.st {\n             in_bindings(vb) { vb }\n+            _ { cx.tcx.sess.bug(\"Someone forgot to document an invariant \\\n+                         in union\"); }\n         };\n         ufind::grow(vb.sets, math::max(set_a, set_b) + 1u);\n         let root_a = ufind::find(vb.sets, set_a);\n@@ -1719,7 +1735,10 @@ mod unify {\n     fn record_var_binding(\n         cx: @ctxt, key: int, typ: t, variance: variance) -> result {\n \n-        let vb = alt cx.st { in_bindings(vb) { vb } };\n+        let vb = alt cx.st { in_bindings(vb) { vb }\n+            _ { cx.tcx.sess.bug(\"Someone forgot to document an invariant \\\n+                 in record_var_binding\");  }\n+        };\n         ufind::grow(vb.sets, (key as uint) + 1u);\n         let root = ufind::find(vb.sets, key as uint);\n         let result_type = typ;\n@@ -2060,7 +2079,7 @@ mod unify {\n             ret ures_ok(actual);\n           }\n           ty::ty_bool | ty::ty_int(_) | ty_uint(_) | ty_float(_) |\n-          ty::ty_str | ty::ty_type | ty::ty_send_type {\n+          ty::ty_str | ty::ty_send_type {\n             ret struct_cmp(cx, expected, actual);\n           }\n           ty::ty_native(ex_id) {\n@@ -2333,6 +2352,7 @@ mod unify {\n               }\n             }\n           }\n+          _ { cx.tcx.sess.bug(\"unify: unexpected type\"); }\n         }\n     }\n     fn unify(expected: t, actual: t, st: unify_style,\n@@ -2497,6 +2517,7 @@ fn def_has_ty_params(def: ast::def) -> bool {\n       ast::def_ty_param(_, _) | ast::def_binding(_) | ast::def_use(_) |\n       ast::def_native_ty(_) | ast::def_self(_) | ast::def_ty(_) { false }\n       ast::def_fn(_, _) | ast::def_variant(_, _) { true }\n+      _ { false } // ????\n     }\n }\n \n@@ -2552,6 +2573,7 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n                     // FIXME: issue #1417\n                     disr_val = alt syntax::ast_util::eval_const_expr(ex) {\n                       ast_util::const_int(val) {val as int}\n+                      _ { cx.sess.bug(\"tag_variants: bad disr expr\"); }\n                     }\n                   }\n                   _ {disr_val += 1;}\n@@ -2564,6 +2586,7 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n                  }\n             })\n           }\n+          _ { cx.sess.bug(\"tag_variants: id not bound to an enum\"); }\n         }\n     };\n     cx.enum_var_cache.insert(id, result);"}, {"sha": "da951150c7f5273e1b3a18e93bd2836138d3a52d", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -107,6 +107,9 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n           some(self_impl(impl_t)) {\n             ret {bounds: @[], ty: impl_t};\n           }\n+          none {\n+              fcx.ccx.tcx.sess.span_bug(sp, \"def_self with no self_info\");\n+          }\n         }\n       }\n       ast::def_fn(id, _) | ast::def_const(id) |\n@@ -248,16 +251,14 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n                   some(ast_map::node_native_item(native_item)) {\n                     ty_of_native_item(tcx, mode, native_item)\n                   }\n+                  _ {\n+                    tcx.sess.bug(\"Unexpected sort of item in ast_ty_to_ty\");\n+                  }\n                 }\n             }\n           }\n         }\n     }\n-    fn ast_arg_to_arg(tcx: ty::ctxt, mode: mode, arg: ast::arg)\n-        -> {mode: ty::mode, ty: ty::t} {\n-        let ty = ast_ty_to_ty(tcx, mode, arg.ty);\n-        ret {mode: default_arg_mode_for_ty(tcx, arg.mode, ty), ty: ty};\n-    }\n     alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n       some(some(ty)) { ret ty; }\n       some(none) {\n@@ -364,6 +365,10 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n                                 \"found `ty_infer` in unexpected place\"); }\n         }\n       }\n+      ast::ty_mac(_) {\n+          tcx.sess.span_bug(ast_ty.span,\n+                                \"found `ty_mac` in unexpected place\");\n+      }\n     }\n     tcx.ast_ty_to_ty_cache.insert(ast_ty, some(typ));\n     ret typ;\n@@ -587,7 +592,13 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n         tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n                           \"` has an incompatible set of type parameters\");\n     } else {\n-        let impl_fty = ty::mk_fn(tcx, impl_m.fty);\n+        let auto_modes = vec::map2(impl_m.fty.inputs, if_m.fty.inputs, {|i, f|\n+            alt ty::struct(tcx, f.ty) {\n+              ty::ty_param(0u, _) { {mode: ast::by_ref with i} }\n+              _ { i }\n+            }\n+        });\n+        let impl_fty = ty::mk_fn(tcx, {inputs: auto_modes with impl_m.fty});\n         // Add dummy substs for the parameters of the impl method\n         let substs = substs + vec::init_fn(vec::len(*if_m.tps), {|i|\n             ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n@@ -1209,7 +1220,7 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n         // Typecheck the path.\n         let v_def = lookup_def(fcx, path.span, pat.id);\n         let v_def_ids = ast_util::variant_def_ids(v_def);\n-        let ctor_tpt = ty::lookup_item_type(tcx, v_def_ids.tg);\n+        let ctor_tpt = ty::lookup_item_type(tcx, v_def_ids.enm);\n         instantiate_path(fcx, path, ctor_tpt, pat.span, pat.id);\n \n         // Take the enum type params out of `expected`.\n@@ -1422,6 +1433,9 @@ fn impl_self_ty(tcx: ty::ctxt, did: ast::def_id) -> {n_tps: uint, ty: ty::t} {\n                                _}) {\n             {n_tps: vec::len(ts), ty: ast_ty_to_ty(tcx, m_check, st)}\n           }\n+          an_item {\n+              tcx.sess.bug(\"Undocumented invariant in impl_self_ty\");\n+          }\n         }\n     } else {\n         let tpt = csearch::get_type(tcx, did);\n@@ -1444,6 +1458,10 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n               ty::bound_iface(t) {\n                 let (iid, tps) = alt ty::struct(tcx, t) {\n                     ty::ty_iface(i, tps) { (i, tps) }\n+                    _ {\n+                        tcx.sess.span_bug(sp, \"Undocument invariant in \\\n+                          lookup_method\");\n+                    }\n                 };\n                 let ifce_methods = ty::iface_methods(tcx, iid);\n                 alt vec::position_pred(*ifce_methods, {|m| m.ident == name}) {\n@@ -1485,6 +1503,9 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                 let mt = ty_of_method(tcx, m_check, m);\n                 ty::mk_fn(tcx, mt.fty)\n               }\n+              _ {\n+                  tcx.sess.bug(\"Undocumented invariant in ty_from_did\");\n+              }\n             }\n         } else { csearch::get_type(tcx, did).ty }\n     }\n@@ -1793,7 +1814,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n         let rhs_bot = check_expr_with(fcx, rhs, lhs_t);\n         if !ast_util::lazy_binop(binop) { bot |= rhs_bot; }\n-\n         let result = check_binop(fcx, expr, lhs_t, binop, rhs);\n         write_ty(tcx, id, result);\n       }\n@@ -2335,6 +2355,8 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n         let id_map = pat_util::pat_id_map(fcx.ccx.tcx, local.node.pat);\n         check_pat(fcx, id_map, local.node.pat, t);\n       }\n+      _ { fcx.ccx.tcx.sess.span_bug(local.span, \"Undocumented invariant \\\n+            in check_decl_local\");  }\n     }\n     ret bot;\n }\n@@ -2697,7 +2719,7 @@ fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n     }\n }\n \n-fn check_main_fn_ty(tcx: ty::ctxt, main_id: ast::node_id) {\n+fn check_main_fn_ty(tcx: ty::ctxt, main_id: ast::node_id, main_span: span) {\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     alt ty::struct(tcx, main_t) {\n       ty::ty_fn({proto: ast::proto_bare, inputs, output,\n@@ -2708,15 +2730,13 @@ fn check_main_fn_ty(tcx: ty::ctxt, main_id: ast::node_id) {\n         ok &= num_args == 0u || num_args == 1u &&\n               arg_is_argv_ty(tcx, inputs[0]);\n         if !ok {\n-            let span = ast_map::node_span(tcx.items.get(main_id));\n-            tcx.sess.span_err(span,\n+            tcx.sess.span_err(main_span,\n                               \"wrong type in main function: found `\" +\n                                   ty_to_str(tcx, main_t) + \"`\");\n         }\n       }\n       _ {\n-        let span = ast_map::node_span(tcx.items.get(main_id));\n-        tcx.sess.span_bug(span,\n+        tcx.sess.span_bug(main_span,\n                           \"main has a non-function type: found `\" +\n                               ty_to_str(tcx, main_t) + \"`\");\n       }\n@@ -2726,7 +2746,7 @@ fn check_main_fn_ty(tcx: ty::ctxt, main_id: ast::node_id) {\n fn check_for_main_fn(tcx: ty::ctxt, crate: @ast::crate) {\n     if !tcx.sess.building_library {\n         alt tcx.sess.main_fn {\n-          some(id) { check_main_fn_ty(tcx, id); }\n+          some((id, sp)) { check_main_fn_ty(tcx, id, sp); }\n           none { tcx.sess.span_err(crate.span, \"main function not found\"); }\n         }\n     }\n@@ -2765,6 +2785,8 @@ mod dict {\n         let tcx = fcx.ccx.tcx;\n         let (iface_id, iface_tps) = alt ty::struct(tcx, iface_ty) {\n             ty::ty_iface(did, tps) { (did, tps) }\n+            _ { tcx.sess.span_bug(sp, \"Undocumented invariant in lookup\\\n+                 _dict\"); }\n         };\n         let ty = fixup_ty(fcx, sp, ty);\n         alt ty::struct(tcx, ty) {\n@@ -2777,6 +2799,8 @@ mod dict {\n                       ty::ty_iface(idid, _) {\n                         if iface_id == idid { ret dict_param(n, n_bound); }\n                       }\n+                      _ { tcx.sess.span_bug(sp, \"Undocumented invariant in \\\n+                           lookup_dict\"); }\n                     }\n                     n_bound += 1u;\n                   }\n@@ -2796,6 +2820,9 @@ mod dict {\n                       some(ity) {\n                         alt ty::struct(tcx, ity) {\n                           ty::ty_iface(id, _) { id == iface_id }\n+                          // Bleah, abstract this\n+                          _ { tcx.sess.span_bug(sp, \"Undocumented invariant \\\n+                               in lookup_dict\"); }\n                         }\n                       }\n                       _ { false }\n@@ -2862,6 +2889,10 @@ mod dict {\n             vec::iter2(tps, iface_tys,\n                        {|a, b| demand::simple(fcx, sp, a, b);});\n           }\n+          _ {\n+              tcx.sess.span_bug(sp, \"Undocumented invariant in \\\n+                 connect_iface_tps\");\n+          }\n         }\n     }\n "}, {"sha": "f52afc0875c4f625fbed9353f4bae55a3f9ef429", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -328,14 +328,10 @@ enum ty_ {\n     ty_uniq(mt),\n     ty_vec(mt),\n     ty_ptr(mt),\n-    ty_task,\n-    ty_port(@ty),\n-    ty_chan(@ty),\n     ty_rec([ty_field]),\n     ty_fn(proto, fn_decl),\n     ty_tup([@ty]),\n     ty_path(@path, node_id),\n-    ty_type,\n     ty_constr(@ty, [@ty_constr]),\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been"}, {"sha": "baaa3022eb32baf73949911bd5aebdf67a54c983", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -19,8 +19,10 @@ fn path_name_i(idents: [ident]) -> str { str::connect(idents, \"::\") }\n \n fn local_def(id: node_id) -> def_id { ret {crate: local_crate, node: id}; }\n \n-fn variant_def_ids(d: def) -> {tg: def_id, var: def_id} {\n-    alt d { def_variant(enum_id, var_id) { ret {tg: enum_id, var: var_id}; } }\n+fn variant_def_ids(d: def) -> {enm: def_id, var: def_id} {\n+    alt d { def_variant(enum_id, var_id) {\n+            ret {enm: enum_id, var: var_id}; }\n+        _ { fail \"non-variant in variant_def_ids\"; } }\n }\n \n fn def_id_of_def(d: def) -> def_id {\n@@ -77,6 +79,7 @@ fn is_path(e: @expr) -> bool {\n \n fn int_ty_to_str(t: int_ty) -> str {\n     alt t {\n+      ty_char { \"u8\" } // ???\n       ty_i { \"\" } ty_i8 { \"i8\" } ty_i16 { \"i16\" }\n       ty_i32 { \"i32\" } ty_i64 { \"i64\" }\n     }\n@@ -86,7 +89,7 @@ fn int_ty_max(t: int_ty) -> u64 {\n     alt t {\n       ty_i8 { 0x80u64 }\n       ty_i16 { 0x800u64 }\n-      ty_char | ty_i32 { 0x80000000u64 }\n+      ty_i | ty_char | ty_i32 { 0x80000000u64 } // actually ni about ty_i\n       ty_i64 { 0x8000000000000000u64 }\n     }\n }\n@@ -102,7 +105,7 @@ fn uint_ty_max(t: uint_ty) -> u64 {\n     alt t {\n       ty_u8 { 0xffu64 }\n       ty_u16 { 0xffffu64 }\n-      ty_u32 { 0xffffffffu64 }\n+      ty_u | ty_u32 { 0xffffffffu64 } // actually ni about ty_u\n       ty_u64 { 0xffffffffffffffffu64 }\n     }\n }\n@@ -223,12 +226,14 @@ fn eval_const_expr(e: @expr) -> const_val {\n           const_float(f) { const_float(-f) }\n           const_int(i) { const_int(-i) }\n           const_uint(i) { const_uint(-i) }\n+          _ { fail \"eval_const_expr: bad neg argument\"; }\n         }\n       }\n       expr_unary(not, inner) {\n         alt eval_const_expr(inner) {\n           const_int(i) { const_int(!i) }\n           const_uint(i) { const_uint(!i) }\n+          _ { fail \"eval_const_expr: bad not argument\"; }\n         }\n       }\n       expr_binary(op, a, b) {\n@@ -240,6 +245,7 @@ fn eval_const_expr(e: @expr) -> const_val {\n               rem { const_float(a % b) } eq { fromb(a == b) }\n               lt { fromb(a < b) } le { fromb(a <= b) } ne { fromb(a != b) }\n               ge { fromb(a >= b) } gt { fromb(a > b) }\n+              _ { fail \"eval_const_expr: can't apply this binop to floats\"; }\n             }\n           }\n           (const_int(a), const_int(b)) {\n@@ -253,6 +259,7 @@ fn eval_const_expr(e: @expr) -> const_val {\n               eq { fromb(a == b) } lt { fromb(a < b) }\n               le { fromb(a <= b) } ne { fromb(a != b) }\n               ge { fromb(a >= b) } gt { fromb(a > b) }\n+              _ { fail \"eval_const_expr: can't apply this binop to ints\"; }\n             }\n           }\n           (const_uint(a), const_uint(b)) {\n@@ -267,11 +274,17 @@ fn eval_const_expr(e: @expr) -> const_val {\n               eq { fromb(a == b) } lt { fromb(a < b) }\n               le { fromb(a <= b) } ne { fromb(a != b) }\n               ge { fromb(a >= b) } gt { fromb(a > b) }\n+              _ { fail \"eval_const_expr: can't apply this binop to uints\"; }\n             }\n           }\n+          _ { fail \"eval_constr_expr: bad binary arguments\"; }\n         }\n       }\n       expr_lit(lit) { lit_to_const(lit) }\n+      // Precondition?\n+      _ {\n+          fail \"eval_const_expr: non-constant expression\";\n+      }\n     }\n }\n \n@@ -324,6 +337,9 @@ fn compare_const_vals(a: const_val, b: const_val) -> int {\n             1\n         }\n     }\n+    _ {\n+        fail \"compare_const_vals: ill-typed comparison\";\n+    }\n   }\n }\n \n@@ -341,6 +357,17 @@ fn ident_to_path(s: span, i: ident) -> @path {\n     @respan(s, {global: false, idents: [i], types: []})\n }\n \n+pure fn is_unguarded(&&a: arm) -> bool {\n+    alt a.guard {\n+      none { true }\n+      _    { false }\n+    }\n+}\n+\n+pure fn unguarded_pat(a: arm) -> option::t<[@pat]> {\n+    if is_unguarded(a) { some(a.pats) } else { none }\n+}\n+\n // Provides an extra node_id to hang callee information on, in case the\n // operator is deferred to a user-supplied method. The parser is responsible\n // for reserving this id."}, {"sha": "b7fdfc469084733c26a0c6e619ea4bc9c6b16e06", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -4,6 +4,7 @@ import codemap::span;\n import core::{vec, option};\n import std::map::{hashmap, new_str_hash};\n import option::{some, none};\n+import driver::session::session;\n \n import base::{ext_ctxt, normal};\n \n@@ -460,11 +461,6 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n               }\n             }\n           }\n-\n-\n-\n-\n-\n           /* TODO: handle embedded types and blocks, at least */\n           expr_mac(mac) {\n             p_t_s_r_mac(cx, mac, s, b);\n@@ -483,6 +479,9 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n           }\n         }\n       }\n+      _ {\n+          cx.session().bug(\"undocumented invariant in p_t_s_rec\");\n+      }\n     }\n }\n \n@@ -718,6 +717,10 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: @expr,\n                     // FIXME: check duplicates (or just simplify\n                     // the macro arg situation)\n                   }\n+                  _ {\n+                      cx.span_bug(mac.span, \"undocumented invariant in \\\n+                         add_extension\");\n+                  }\n                 }\n               }\n               _ {"}, {"sha": "95c37b9b8e9ac0f7fd67d3cc06e0441b69aa53e3", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -258,7 +258,7 @@ fn check_bad_word(p: parser) {\n     }\n }\n \n-fn parse_ty_fn(proto: ast::proto, p: parser) -> ast::ty_ {\n+fn parse_ty_fn(p: parser) -> ast::fn_decl {\n     fn parse_fn_input_ty(p: parser) -> ast::arg {\n         let mode = parse_arg_mode(p);\n         let name = if is_plain_ident(p) && p.look_ahead(1u) == token::COLON {\n@@ -275,9 +275,9 @@ fn parse_ty_fn(proto: ast::proto, p: parser) -> ast::ty_ {\n     //  auto constrs = parse_constrs(~[], p);\n     let constrs: [@ast::constr] = [];\n     let (ret_style, ret_ty) = parse_ret_ty(p);\n-    ret ast::ty_fn(proto, {inputs: inputs.node, output: ret_ty,\n+    ret {inputs: inputs.node, output: ret_ty,\n                            purity: ast::impure_fn, cf: ret_style,\n-                           constraints: constrs});\n+                           constraints: constrs};\n }\n \n fn parse_ty_methods(p: parser) -> [ast::ty_method] {\n@@ -287,15 +287,10 @@ fn parse_ty_methods(p: parser) -> [ast::ty_method] {\n         expect_word(p, \"fn\");\n         let ident = parse_method_name(p);\n         let tps = parse_ty_params(p);\n-        let f = parse_ty_fn(ast::proto_bare, p), fhi = p.last_span.hi;\n+        let d = parse_ty_fn(p), fhi = p.last_span.hi;\n         expect(p, token::SEMI);\n-        alt f {\n-          ast::ty_fn(_, d) {\n             {ident: ident, attrs: attrs, decl: d, tps: tps,\n-             span: ast_util::mk_sp(flo, fhi)}\n-          }\n-        }\n-    }, p).node\n+                    span: ast_util::mk_sp(flo, fhi)}}, p).node\n }\n \n fn parse_mt(p: parser) -> ast::mt {\n@@ -506,10 +501,10 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n           ast::proto_bare { p.warn(\"fn is deprecated, use native fn\"); }\n           _ { /* fallthrough */ }\n         }\n-        t = parse_ty_fn(proto, p);\n+        t = ast::ty_fn(proto, parse_ty_fn(p));\n     } else if eat_word(p, \"native\") {\n         expect_word(p, \"fn\");\n-        t = parse_ty_fn(ast::proto_bare, p);\n+        t = ast::ty_fn(ast::proto_bare, parse_ty_fn(p));\n     } else if p.token == token::MOD_SEP || is_ident(p.token) {\n         let path = parse_path(p);\n         t = ast::ty_path(path, p.get_id());"}, {"sha": "fbfa5f4f433616944d33ea9403d7e8f2e2b8c1c7", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -336,17 +336,6 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n         word(s.s, \"]\");\n       }\n       ast::ty_ptr(mt) { word(s.s, \"*\"); print_mt(s, mt); }\n-      ast::ty_task { word(s.s, \"task\"); }\n-      ast::ty_port(t) {\n-        word(s.s, \"port<\");\n-        print_type(s, t);\n-        word(s.s, \">\");\n-      }\n-      ast::ty_chan(t) {\n-        word(s.s, \"chan<\");\n-        print_type(s, t);\n-        word(s.s, \">\");\n-      }\n       ast::ty_rec(fields) {\n         word(s.s, \"{\");\n         fn print_field(s: ps, f: ast::ty_field) {\n@@ -370,12 +359,18 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n         print_ty_fn(s, some(proto), d, none, none);\n       }\n       ast::ty_path(path, _) { print_path(s, path, false); }\n-      ast::ty_type { word(s.s, \"type\"); }\n       ast::ty_constr(t, cs) {\n         print_type(s, t);\n         space(s.s);\n         word(s.s, ast_ty_constrs_str(cs));\n       }\n+      ast::ty_mac(_) {\n+          fail \"print_type doesn't know how to print a ty_mac\";\n+      }\n+      ast::ty_infer {\n+          fail \"print_type shouldn't see a ty_infer\";\n+      }\n+\n     }\n     end(s);\n }\n@@ -703,11 +698,6 @@ fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n         alt els {\n           some(_else) {\n             alt _else.node {\n-\n-\n-\n-\n-\n               // \"another else-if\"\n               ast::expr_if(i, t, e) {\n                 cbox(s, indent_unit - 1u);\n@@ -718,18 +708,17 @@ fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n                 print_block(s, t);\n                 do_else(s, e);\n               }\n-\n-\n-\n-\n-\n               // \"final else\"\n               ast::expr_block(b) {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n                 word(s.s, \" else \");\n                 print_block(s, b);\n               }\n+              // BLEAH, constraints would be great here\n+              _ {\n+                  fail \"print_if saw if with weird alternative\";\n+              }\n             }\n           }\n           _ {/* fall through */ }"}, {"sha": "2ba0567c213feb6044cd4eaba145da3c3a48a662", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -165,7 +165,6 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n         v.visit_ty(decl.output, e, v);\n       }\n       ty_path(p, _) { visit_path(p, e, v); }\n-      ty_type {/* no-op */ }\n       ty_constr(t, cs) {\n         v.visit_ty(t, e, v);\n         for tc: @spanned<constr_general_<@path, node_id>> in cs {"}, {"sha": "9b0be29ca26c109b3f862d78426d65e8519e0a62", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -8,7 +8,7 @@ import syntax::print::pprust::{path_to_str, constr_args_to_str, proto_to_str};\n import syntax::{ast, ast_util};\n import middle::ast_map;\n \n-fn mode_str(m: ty::mode) -> str {\n+fn mode_str(m: ast::mode) -> str {\n     alt m {\n       ast::by_ref { \"&&\" }\n       ast::by_val { \"++\" }\n@@ -20,7 +20,7 @@ fn mode_str(m: ty::mode) -> str {\n }\n \n fn ty_to_str(cx: ctxt, typ: t) -> str {\n-    fn fn_input_to_str(cx: ctxt, input: {mode: middle::ty::mode, ty: t}) ->\n+    fn fn_input_to_str(cx: ctxt, input: {mode: ast::mode, ty: t}) ->\n        str {\n         let modestr = alt input.mode {\n           ast::by_ref {"}, {"sha": "4a98bf5c66175471ac05e5ab116df61ecb354a6e", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -87,12 +87,17 @@ Visit all pairs in the map in order.\n fn traverse<K, V: copy>(m: treemap<K, V>, f: fn(K, V)) {\n     alt *m {\n       empty { }\n-      node(@k, @v, _, _) {\n+      /*\n+        Previously, this had what looked like redundant\n+        matches to me, so I changed it. but that may be a\n+        de-optimization -- tjc\n+       */\n+      node(@k, @v, left, right) {\n         // copy v to make aliases work out\n         let v1 = v;\n-        alt *m { node(_, _, left, _) { traverse(left, f); } }\n+        traverse(left, f);\n         f(k, v1);\n-        alt *m { node(_, _, _, right) { traverse(right, f); } }\n+        traverse(right, f);\n       }\n     }\n }"}, {"sha": "10b3545fc40db3cd235bfec2d29825063d37bfdb", "filename": "src/libstd/test.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -398,15 +398,17 @@ mod tests {\n     fn first_free_arg_should_be_a_filter() {\n         let args = [\"progname\", \"filter\"];\n         check (vec::is_not_empty(args));\n-        let opts = alt parse_opts(args) { either::left(o) { o } };\n+        let opts = alt parse_opts(args) { either::left(o) { o }\n+          _ { fail \"Malformed arg in first_free_arg_should_be_a_filter\"; } };\n         assert (str::eq(\"filter\", option::get(opts.filter)));\n     }\n \n     #[test]\n     fn parse_ignored_flag() {\n         let args = [\"progname\", \"filter\", \"--ignored\"];\n         check (vec::is_not_empty(args));\n-        let opts = alt parse_opts(args) { either::left(o) { o } };\n+        let opts = alt parse_opts(args) { either::left(o) { o }\n+          _ { fail \"Malformed arg in parse_ignored_flag\"; } };\n         assert (opts.run_ignored);\n     }\n "}, {"sha": "1c711952e0b6178cbc2d74c2c19a8d9277a48f81", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -66,14 +66,13 @@ Find a value based on the key\n fn find<K: copy, V: copy>(m: treemap<K, V>, k: K) -> option<V> {\n     alt *m {\n       empty { none }\n-      node(@kk, @v, _, _) {\n+      // TODO: was that an optimization?\n+      node(@kk, @v, left, right) {\n         if k == kk {\n             some(v)\n         } else if k < kk {\n-\n-            // Again, ugliness to unpack left and right individually.\n-            alt *m { node(_, _, left, _) { find(left, k) } }\n-        } else { alt *m { node(_, _, _, right) { find(right, k) } } }\n+            find(left, k)\n+        } else { find(right, k) }\n       }\n     }\n }\n@@ -86,11 +85,16 @@ Visit all pairs in the map in order.\n fn traverse<K, V>(m: treemap<K, V>, f: fn(K, V)) {\n     alt *m {\n       empty { }\n-      node(k, v, _, _) {\n+      /*\n+        Previously, this had what looked like redundant\n+        matches to me, so I changed it. but that may be a\n+        de-optimization -- tjc\n+       */\n+      node(k, v, left, right) {\n         let k1 = k, v1 = v;\n-        alt *m { node(_, _, left, _) { traverse(left, f); } }\n+        traverse(left, f);\n         f(*k1, *v1);\n-        alt *m { node(_, _, _, right) { traverse(right, f); } }\n+        traverse(right, f);\n       }\n     }\n }"}, {"sha": "36e323e967832cadd64e992bbb98c954bf8d9f99", "filename": "src/libstd/uvtmp.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Flibstd%2Fuvtmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Flibstd%2Fuvtmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuvtmp.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -120,6 +120,7 @@ fn test_connect() {\n       connected(cd) {\n         close_connection(thread, 0u32);\n       }\n+      _ { fail \"test_connect: port isn't connected\"; }\n     }\n     join_thread(thread);\n     delete_thread(thread);\n@@ -156,12 +157,15 @@ fn test_http() {\n                     }\n                     delete_buf(buf);\n                   }\n+                  _ { fail \"test_http: protocol error\"; }\n                 }\n             }\n             close_connection(thread, 0u32);\n           }\n+          _ { fail \"test_http: expected `wrote`\"; }\n         }\n       }\n+      _ { fail \"test_http: port not connected\"; }\n     }\n     join_thread(thread);\n     delete_thread(thread);"}, {"sha": "91e065f310b012821a6a24d498247539003bf574", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -70,6 +70,9 @@ fn parse_item_attrs<T>(\n     astsrv::exec(srv) {|ctxt|\n         let attrs = alt ctxt.ast_map.get(id) {\n           ast_map::node_item(item) { item.attrs }\n+          _ {\n+            fail \"parse_item_attrs: not an item\";\n+          }\n         };\n         parse_attrs(attrs)\n     }\n@@ -277,6 +280,7 @@ fn fold_enum(\n \n                     attr_parser::parse_variant(ast_variant.node.attrs)\n                   }\n+                  _ { fail \"fold_enum: undocumented invariant\"; }\n                 }\n             };\n \n@@ -363,7 +367,6 @@ fn fold_res_should_extract_arg_docs() {\n     assert doc.args[0].desc == some(\"b\");\n }\n \n-\n fn fold_iface(\n     fold: fold::fold<astsrv::srv>,\n     doc: doc::ifacedoc\n@@ -395,6 +398,9 @@ fn merge_method_attrs(\n                 (method.ident, attr_parser::parse_method(method.attrs))\n             }\n           }\n+          _ {\n+            fail \"Undocumented invariant in merge_method_attrs\";\n+          }\n         }\n     };\n \n@@ -441,4 +447,4 @@ fn should_extract_iface_method_docs() {\n     assert doc.topmod.ifaces()[0].methods[0].args[0].desc == some(\"a\");\n     assert doc.topmod.ifaces()[0].methods[0].return.desc == some(\"return\");\n     assert doc.topmod.ifaces()[0].methods[0].failure == some(\"failure\");\n-}\n\\ No newline at end of file\n+}"}, {"sha": "c8b13d92769e755d85ee0ba47ae6b75afdfd5ac7", "filename": "src/rustdoc/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Frustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Frustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fparse.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -43,4 +43,4 @@ fn from_str_sess(sess: session::session, source: str) -> @ast::crate {\n \n fn cfg(sess: session::session) -> ast::crate_cfg {\n     driver::default_configuration(sess, \"rustdoc\", \"<anon>\")\n-}\n\\ No newline at end of file\n+}"}, {"sha": "554124f6348de8cd612ee9a9ac4ccfbf72642444", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -111,8 +111,12 @@ fn is_exported_from_mod(\n               ast::item_mod(m) {\n                 ast_util::is_exported(item_name, m)\n               }\n+              _ {\n+                fail \"is_exported_from_mod: not a mod\";\n+              }\n             }\n           }\n+          _ { fail \"is_exported_from_mod: not an item\"; }\n         }\n     }\n }\n@@ -243,4 +247,4 @@ fn should_prune_unexported_ifaces_from_top_mod() {\n     let doc = extract::from_srv(srv, \"\");\n     let doc = run(srv, doc);\n     assert vec::is_empty(doc.topmod.ifaces());\n-}\n\\ No newline at end of file\n+}"}, {"sha": "ecf3049b156a69ddb8daa2d9d6374e42c336323c", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -50,6 +50,9 @@ fn get_fn_sig(srv: astsrv::srv, fn_id: doc::ast_id) -> option<str> {\n           }) {\n             some(pprust::fun_to_str(decl, ident, []))\n           }\n+          _ {\n+            fail \"get_fn_sig: undocumented invariant\";\n+          }\n         }\n     }\n }\n@@ -87,6 +90,7 @@ fn get_ret_ty(srv: astsrv::srv, fn_id: doc::ast_id) -> option<str> {\n           }) {\n             ret_ty_to_str(decl)\n           }\n+          _ { fail \"get_ret_ty: undocumented invariant\"; }\n         }\n     }\n }\n@@ -145,6 +149,9 @@ fn get_arg_tys(srv: astsrv::srv, fn_id: doc::ast_id) -> [(str, str)] {\n           }) {\n             decl_arg_tys(decl)\n           }\n+          _ {\n+            fail \"get_arg_tys: undocumented invariant\";\n+          }\n         }\n     }\n }\n@@ -180,6 +187,9 @@ fn fold_const(\n               }) {\n                 pprust::ty_to_str(ty)\n               }\n+              _ {\n+                fail \"fold_const: undocumented invariant\";\n+              }\n             }\n         })\n         with doc\n@@ -215,6 +225,7 @@ fn fold_enum(\n \n                     pprust::variant_to_str(ast_variant)\n                   }\n+                  _ { fail \"fold_enum: undocumented invariant\"; }\n                 }\n             };\n \n@@ -251,6 +262,7 @@ fn fold_res(\n               }) {\n                 pprust::res_to_str(decl, doc.name, [])\n               }\n+              _ { fail \"fold_res: undocumented invariant\"; }\n             }\n         })\n         with doc\n@@ -336,8 +348,10 @@ fn get_method_ret_ty(\n                 some(method) {\n                     ret_ty_to_str(method.decl)\n                 }\n+                _ { fail \"get_method_ret_ty: undocumented invariant\"; }\n             }\n           }\n+          _ { fail \"get_method_ret_ty: undocumented invariant\"; }\n         }\n     }\n }\n@@ -358,8 +372,10 @@ fn get_method_sig(\n                 some(method) {\n                     some(pprust::fun_to_str(method.decl, method.ident, []))\n                 }\n+                _ { fail \"get_method_ret_sig: undocumented invariant\"; }\n             }\n           }\n+          _ { fail \"get_method_ret_sig: undocumented invariant\"; }\n         }\n     }\n }\n@@ -396,8 +412,10 @@ fn get_method_arg_tys(\n                 some(method) {\n                     decl_arg_tys(method.decl)\n                 }\n+                _ { fail \"get_method_arg_tys: undocumented invariant\"; }\n             }\n           }\n+          _ { fail \"get_method_arg_tys: undocumented invariant\"; }\n         }\n     }\n }"}, {"sha": "b3b854f53e54d340805751e7f43984e00861aeb4", "filename": "src/test/compile-fail/non-exhaustive-match-nested.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -0,0 +1,13 @@\n+// -*- rust -*-\n+// error-pattern: Non-exhaustive pattern\n+enum t { a(u), b }\n+enum u { c, d }\n+\n+fn main() {\n+  let x = a(c);\n+  alt x {\n+      a(d) { fail \"hello\"; }\n+      b { fail \"goodbye\"; }\n+    }\n+}\n+"}, {"sha": "7beb7f1b17d3f1a5d064e0986d48ed182651ec7d", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "renamed", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -1,9 +1,5 @@\n-\n-\n-\n // -*- rust -*-\n-\n-// error-pattern:non-exhaustive match failure\n+// error-pattern: Non-exhaustive pattern\n enum t { a, b, }\n \n fn main() { let x = a; alt x { b { } } }", "previous_filename": "src/test/run-fail/non-exhaustive-match.rs"}, {"sha": "aa3ccfcbafd6690c2b51b1dc9fdbc6cc94260162", "filename": "src/test/run-pass/alt-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Ftest%2Frun-pass%2Falt-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba35e1a3c87892823d1f4d436b9f00a7864cf16/src%2Ftest%2Frun-pass%2Falt-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-path.rs?ref=fba35e1a3c87892823d1f4d436b9f00a7864cf16", "patch": "@@ -4,6 +4,6 @@ mod m1 {\n     enum foo { foo1, foo2, }\n }\n \n-fn bar(x: m1::foo) { alt x { m1::foo1 { } } }\n+fn bar(x: m1::foo) { alt x { m1::foo1 { } m1::foo2 { } } }\n \n fn main() { }"}]}