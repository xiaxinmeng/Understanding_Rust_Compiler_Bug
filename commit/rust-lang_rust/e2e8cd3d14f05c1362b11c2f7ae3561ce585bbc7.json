{"sha": "e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZThjZDNkMTRmMDVjMTM2MmIxMWMyZjdhZTM1NjFjZTU4NWJiYzc=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2018-01-10T03:28:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-01-10T03:28:23Z"}, "message": "Rollup merge of #46777 - frewsxcv:frewsxcv-rotate, r=alexcrichton\n\nDeprecate [T]::rotate in favor of [T]::rotate_{left,right}.\n\nBackground\n==========\n\nSlices currently have an **unstable** [`rotate`] method which rotates\nelements in the slice to the _left_ N positions. [Here][tracking] is the\ntracking issue for this unstable feature.\n\n```rust\nlet mut a = ['a', 'b' ,'c', 'd', 'e', 'f'];\na.rotate(2);\nassert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);\n```\n\nProposal\n========\n\nDeprecate the [`rotate`] method and introduce `rotate_left` and\n`rotate_right` methods.\n\n```rust\nlet mut a = ['a', 'b' ,'c', 'd', 'e', 'f'];\na.rotate_left(2);\nassert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);\n```\n\n```rust\nlet mut a = ['a', 'b' ,'c', 'd', 'e', 'f'];\na.rotate_right(2);\nassert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);\n```\n\nJustification\n=============\n\nI used this method today for my first time and (probably because I\u2019m a\nnaive westerner who reads LTR) was surprised when the docs mentioned that\nelements get rotated in a left-ward direction. I was in a situation\nwhere I needed to shift elements in a right-ward direction and had to\ncontext switch from the main problem I was working on and think how much\nto rotate left in order to accomplish the right-ward rotation I needed.\n\nRuby\u2019s `Array.rotate` shifts left-ward, Python\u2019s `deque.rotate` shifts\nright-ward. Both of their implementations allow passing negative numbers\nto shift in the opposite direction respectively. The current `rotate`\nimplementation takes an unsigned integer argument which doesn't allow\nthe negative number behavior.\n\nIntroducing `rotate_left` and `rotate_right` would:\n\n- remove ambiguity about direction (alleviating need to read docs \ud83d\ude09)\n- make it easier for people who need to rotate right\n\n[`rotate`]: https://doc.rust-lang.org/std/primitive.slice.html#method.rotate\n[tracking]: https://github.com/rust-lang/rust/issues/41891", "tree": {"sha": "ee4434e502c1f4304e05477edb55d9aa7a0fdbac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee4434e502c1f4304e05477edb55d9aa7a0fdbac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7", "html_url": "https://github.com/rust-lang/rust/commit/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b61564f263edd49fa33f34c8acbc79a55959b8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b61564f263edd49fa33f34c8acbc79a55959b8c", "html_url": "https://github.com/rust-lang/rust/commit/2b61564f263edd49fa33f34c8acbc79a55959b8c"}, {"sha": "66ef6b9c0995cc678a00f4d061ba8e6adb16f610", "url": "https://api.github.com/repos/rust-lang/rust/commits/66ef6b9c0995cc678a00f4d061ba8e6adb16f610", "html_url": "https://github.com/rust-lang/rust/commit/66ef6b9c0995cc678a00f4d061ba8e6adb16f610"}], "stats": {"total": 192, "additions": 142, "deletions": 50}, "files": [{"sha": "ee5182a1d46637cf59306139c4de621820f04281", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7", "patch": "@@ -343,7 +343,7 @@ macro_rules! rotate {\n         fn $name(b: &mut Bencher) {\n             let size = mem::size_of_val(&$gen(1)[0]);\n             let mut v = $gen($len * 8 / size);\n-            b.iter(|| black_box(&mut v).rotate(($mid*8+size-1)/size));\n+            b.iter(|| black_box(&mut v).rotate_left(($mid*8+size-1)/size));\n             b.bytes = (v.len() * size) as u64;\n         }\n     }"}, {"sha": "28caccbc87fdea9633db2cb5ff62f8e97787c183", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 64, "deletions": 35, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7", "patch": "@@ -1360,24 +1360,61 @@ impl<T> [T] {\n         core_slice::SliceExt::sort_unstable_by_key(self, f);\n     }\n \n-    /// Permutes the slice in-place such that `self[mid..]` moves to the\n-    /// beginning of the slice while `self[..mid]` moves to the end of the\n-    /// slice.  Equivalently, rotates the slice `mid` places to the left\n-    /// or `k = self.len() - mid` places to the right.\n+    /// Rotates the slice in-place such that the first `mid` elements of the\n+    /// slice move to the end while the last `self.len() - mid` elements move to\n+    /// the front. After calling `rotate_left`, the element previously at index\n+    /// `mid` will become the first element in the slice.\n     ///\n-    /// This is a \"k-rotation\", a permutation in which item `i` moves to\n-    /// position `i + k`, modulo the length of the slice.  See _Elements\n-    /// of Programming_ [\u00a710.4][eop].\n+    /// # Panics\n+    ///\n+    /// This function will panic if `mid` is greater than the length of the\n+    /// slice. Note that `mid == self.len()` does _not_ panic and is a no-op\n+    /// rotation.\n+    ///\n+    /// # Complexity\n+    ///\n+    /// Takes linear (in `self.len()`) time.\n+    ///\n+    /// # Examples\n     ///\n-    /// Rotation by `mid` and rotation by `k` are inverse operations.\n+    /// ```\n+    /// #![feature(slice_rotate)]\n     ///\n-    /// [eop]: https://books.google.com/books?id=CO9ULZGINlsC&pg=PA178&q=k-rotation\n+    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n+    /// a.rotate_left(2);\n+    /// assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);\n+    /// ```\n+    ///\n+    /// Rotating a subslice:\n+    ///\n+    /// ```\n+    /// #![feature(slice_rotate)]\n+    ///\n+    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n+    /// a[1..5].rotate_left(1);\n+    /// assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);\n+    /// ```\n+    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n+    pub fn rotate_left(&mut self, mid: usize) {\n+        core_slice::SliceExt::rotate_left(self, mid);\n+    }\n+\n+    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n+    #[rustc_deprecated(since = \"\", reason = \"renamed to `rotate_left`\")]\n+    pub fn rotate(&mut self, mid: usize) {\n+        core_slice::SliceExt::rotate_left(self, mid);\n+    }\n+\n+    /// Rotates the slice in-place such that the first `self.len() - k`\n+    /// elements of the slice move to the end while the last `k` elements move\n+    /// to the front. After calling `rotate_right`, the element previously at\n+    /// index `self.len() - k` will become the first element in the slice.\n     ///\n     /// # Panics\n     ///\n-    /// This function will panic if `mid` is greater than the length of the\n-    /// slice.  (Note that `mid == self.len()` does _not_ panic; it's a nop\n-    /// rotation with `k == 0`, the inverse of a rotation with `mid == 0`.)\n+    /// This function will panic if `k` is greater than the length of the\n+    /// slice. Note that `k == self.len()` does _not_ panic and is a no-op\n+    /// rotation.\n     ///\n     /// # Complexity\n     ///\n@@ -1388,31 +1425,23 @@ impl<T> [T] {\n     /// ```\n     /// #![feature(slice_rotate)]\n     ///\n-    /// let mut a = [1, 2, 3, 4, 5, 6, 7];\n-    /// let mid = 2;\n-    /// a.rotate(mid);\n-    /// assert_eq!(&a, &[3, 4, 5, 6, 7, 1, 2]);\n-    /// let k = a.len() - mid;\n-    /// a.rotate(k);\n-    /// assert_eq!(&a, &[1, 2, 3, 4, 5, 6, 7]);\n-    ///\n-    /// use std::ops::Range;\n-    /// fn slide<T>(slice: &mut [T], range: Range<usize>, to: usize) {\n-    ///     if to < range.start {\n-    ///         slice[to..range.end].rotate(range.start-to);\n-    ///     } else if to > range.end {\n-    ///         slice[range.start..to].rotate(range.end-range.start);\n-    ///     }\n-    /// }\n-    /// let mut v: Vec<_> = (0..10).collect();\n-    /// slide(&mut v, 1..4, 7);\n-    /// assert_eq!(&v, &[0, 4, 5, 6, 1, 2, 3, 7, 8, 9]);\n-    /// slide(&mut v, 6..8, 1);\n-    /// assert_eq!(&v, &[0, 3, 7, 4, 5, 6, 1, 2, 8, 9]);\n+    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n+    /// a.rotate_right(2);\n+    /// assert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);\n+    /// ```\n+    ///\n+    /// Rotate a subslice:\n+    ///\n+    /// ```\n+    /// #![feature(slice_rotate)]\n+    ///\n+    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n+    /// a[1..5].rotate_right(1);\n+    /// assert_eq!(a, ['a', 'e', 'b', 'c', 'd', 'f']);\n     /// ```\n     #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n-    pub fn rotate(&mut self, mid: usize) {\n-        core_slice::SliceExt::rotate(self, mid);\n+    pub fn rotate_right(&mut self, k: usize) {\n+        core_slice::SliceExt::rotate_right(self, k);\n     }\n \n     /// Copies the elements from `src` into `self`."}, {"sha": "49bdc9e1b90de5c252ac2321e9d0e85da3643899", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7", "patch": "@@ -494,37 +494,72 @@ fn test_sort_stability() {\n }\n \n #[test]\n-fn test_rotate() {\n+fn test_rotate_left() {\n     let expected: Vec<_> = (0..13).collect();\n     let mut v = Vec::new();\n \n     // no-ops\n     v.clone_from(&expected);\n-    v.rotate(0);\n+    v.rotate_left(0);\n     assert_eq!(v, expected);\n-    v.rotate(expected.len());\n+    v.rotate_left(expected.len());\n     assert_eq!(v, expected);\n     let mut zst_array = [(), (), ()];\n-    zst_array.rotate(2);\n+    zst_array.rotate_left(2);\n \n     // happy path\n     v = (5..13).chain(0..5).collect();\n-    v.rotate(8);\n+    v.rotate_left(8);\n     assert_eq!(v, expected);\n \n     let expected: Vec<_> = (0..1000).collect();\n \n     // small rotations in large slice, uses ptr::copy\n     v = (2..1000).chain(0..2).collect();\n-    v.rotate(998);\n+    v.rotate_left(998);\n     assert_eq!(v, expected);\n     v = (998..1000).chain(0..998).collect();\n-    v.rotate(2);\n+    v.rotate_left(2);\n     assert_eq!(v, expected);\n \n     // non-small prime rotation, has a few rounds of swapping\n     v = (389..1000).chain(0..389).collect();\n-    v.rotate(1000-389);\n+    v.rotate_left(1000-389);\n+    assert_eq!(v, expected);\n+}\n+\n+#[test]\n+fn test_rotate_right() {\n+    let expected: Vec<_> = (0..13).collect();\n+    let mut v = Vec::new();\n+\n+    // no-ops\n+    v.clone_from(&expected);\n+    v.rotate_right(0);\n+    assert_eq!(v, expected);\n+    v.rotate_right(expected.len());\n+    assert_eq!(v, expected);\n+    let mut zst_array = [(), (), ()];\n+    zst_array.rotate_right(2);\n+\n+    // happy path\n+    v = (5..13).chain(0..5).collect();\n+    v.rotate_right(5);\n+    assert_eq!(v, expected);\n+\n+    let expected: Vec<_> = (0..1000).collect();\n+\n+    // small rotations in large slice, uses ptr::copy\n+    v = (2..1000).chain(0..2).collect();\n+    v.rotate_right(2);\n+    assert_eq!(v, expected);\n+    v = (998..1000).chain(0..998).collect();\n+    v.rotate_right(998);\n+    assert_eq!(v, expected);\n+\n+    // non-small prime rotation, has a few rounds of swapping\n+    v = (389..1000).chain(0..389).collect();\n+    v.rotate_right(389);\n     assert_eq!(v, expected);\n }\n "}, {"sha": "e6b79314aa96d47a2dd19800b1ce5731be430282", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7", "patch": "@@ -206,7 +206,10 @@ pub trait SliceExt {\n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n-    fn rotate(&mut self, mid: usize);\n+    fn rotate_left(&mut self, mid: usize);\n+\n+    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n+    fn rotate_right(&mut self, k: usize);\n \n     #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n     fn clone_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Clone;\n@@ -645,7 +648,7 @@ impl<T> SliceExt for [T] {\n         self.binary_search_by(|p| p.cmp(x))\n     }\n \n-    fn rotate(&mut self, mid: usize) {\n+    fn rotate_left(&mut self, mid: usize) {\n         assert!(mid <= self.len());\n         let k = self.len() - mid;\n \n@@ -655,6 +658,16 @@ impl<T> SliceExt for [T] {\n         }\n     }\n \n+    fn rotate_right(&mut self, k: usize) {\n+        assert!(k <= self.len());\n+        let mid = self.len() - k;\n+\n+        unsafe {\n+            let p = self.as_mut_ptr();\n+            rotate::ptr_rotate(mid, p.offset(mid as isize), k);\n+        }\n+    }\n+\n     #[inline]\n     fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n         assert!(self.len() == src.len(),"}, {"sha": "40e5fe5758ac987e629444ee0a612d15c3f183d7", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7", "patch": "@@ -329,17 +329,32 @@ fn test_iter_folds() {\n }\n \n #[test]\n-fn test_rotate() {\n+fn test_rotate_left() {\n     const N: usize = 600;\n     let a: &mut [_] = &mut [0; N];\n     for i in 0..N {\n         a[i] = i;\n     }\n \n-    a.rotate(42);\n+    a.rotate_left(42);\n     let k = N - 42;\n \n     for i in 0..N {\n-        assert_eq!(a[(i+k)%N], i);\n+        assert_eq!(a[(i + k) % N], i);\n+    }\n+}\n+\n+#[test]\n+fn test_rotate_right() {\n+    const N: usize = 600;\n+    let a: &mut [_] = &mut [0; N];\n+    for i in 0..N {\n+        a[i] = i;\n+    }\n+\n+    a.rotate_right(42);\n+\n+    for i in 0..N {\n+        assert_eq!(a[(i + 42) % N], i);\n     }\n }"}, {"sha": "d1643c0aa4b63c162049e2a1fbacb356083b4b2b", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=e2e8cd3d14f05c1362b11c2f7ae3561ce585bbc7", "patch": "@@ -2867,7 +2867,7 @@ fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n                     *skipped += data.len();\n                     if data.len() <= TAIL_LEN {\n                         tail[..data.len()].copy_from_slice(data);\n-                        tail.rotate(data.len());\n+                        tail.rotate_left(data.len());\n                     } else {\n                         tail.copy_from_slice(&data[(data.len() - TAIL_LEN)..]);\n                     }"}]}