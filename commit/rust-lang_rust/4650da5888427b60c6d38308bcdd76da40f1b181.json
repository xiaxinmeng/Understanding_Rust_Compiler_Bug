{"sha": "4650da5888427b60c6d38308bcdd76da40f1b181", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2NTBkYTU4ODg0MjdiNjBjNmQzODMwOGJjZGQ3NmRhNDBmMWIxODE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-24T17:54:41Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-26T05:45:46Z"}, "message": "libsyntax: change eat to take a &token", "tree": {"sha": "eb51a60e4f2ae1c8590a55c6743de4e7c1b4d912", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb51a60e4f2ae1c8590a55c6743de4e7c1b4d912"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4650da5888427b60c6d38308bcdd76da40f1b181", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4650da5888427b60c6d38308bcdd76da40f1b181", "html_url": "https://github.com/rust-lang/rust/commit/4650da5888427b60c6d38308bcdd76da40f1b181", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4650da5888427b60c6d38308bcdd76da40f1b181/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1deb858b2217cd9107bef4d64d35f1489f77f2ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/1deb858b2217cd9107bef4d64d35f1489f77f2ff", "html_url": "https://github.com/rust-lang/rust/commit/1deb858b2217cd9107bef4d64d35f1489f77f2ff"}], "stats": {"total": 82, "additions": 41, "deletions": 41}, "files": [{"sha": "b7641e8b19b9a45c89a8ec1288815e4cebf19cda", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4650da5888427b60c6d38308bcdd76da40f1b181/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4650da5888427b60c6d38308bcdd76da40f1b181/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4650da5888427b60c6d38308bcdd76da40f1b181", "patch": "@@ -341,7 +341,7 @@ pub fn get_exprs_from_tts(cx: ext_ctxt, tts: &[ast::token_tree])\n     let mut es = ~[];\n     while *p.token != token::EOF {\n         if es.len() != 0 {\n-            p.eat(token::COMMA);\n+            p.eat(&token::COMMA);\n         }\n         es.push(p.parse_expr());\n     }"}, {"sha": "e336b2bb8146563bc71324c57777d9b27cfe9d4f", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4650da5888427b60c6d38308bcdd76da40f1b181/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4650da5888427b60c6d38308bcdd76da40f1b181/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=4650da5888427b60c6d38308bcdd76da40f1b181", "patch": "@@ -103,8 +103,8 @@ pub impl Parser {\n \n     // consume token 'tok' if it exists. Returns true if the given\n     // token was present, false otherwise.\n-    fn eat(tok: token::Token) -> bool {\n-        return if *self.token == tok { self.bump(); true } else { false };\n+    fn eat(tok: &token::Token) -> bool {\n+        return if *self.token == *tok { self.bump(); true } else { false };\n     }\n \n     // Storing keywords as interned idents instead of strings would be nifty."}, {"sha": "a6834d1b886500722bebbfc02ccfb5edd70ca850", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4650da5888427b60c6d38308bcdd76da40f1b181/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4650da5888427b60c6d38308bcdd76da40f1b181/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4650da5888427b60c6d38308bcdd76da40f1b181", "patch": "@@ -417,7 +417,7 @@ pub impl Parser {\n            Lifetimes\n \n         */\n-        if self.eat(token::LT) {\n+        if self.eat(&token::LT) {\n             let _lifetimes = self.parse_lifetimes();\n             self.expect(token::GT);\n         }\n@@ -525,9 +525,9 @@ pub impl Parser {\n     }\n \n     fn parse_ret_ty() -> (ret_style, @Ty) {\n-        return if self.eat(token::RARROW) {\n+        return if self.eat(&token::RARROW) {\n             let lo = self.span.lo;\n-            if self.eat(token::NOT) {\n+            if self.eat(&token::NOT) {\n                 (\n                     noreturn,\n                     @Ty {\n@@ -719,12 +719,12 @@ pub impl Parser {\n     }\n \n     fn parse_arg_mode() -> mode {\n-        if self.eat(token::BINOP(token::MINUS)) {\n+        if self.eat(&token::BINOP(token::MINUS)) {\n             expl(by_copy) // NDM outdated syntax\n-        } else if self.eat(token::ANDAND) {\n+        } else if self.eat(&token::ANDAND) {\n             expl(by_ref)\n-        } else if self.eat(token::BINOP(token::PLUS)) {\n-            if self.eat(token::BINOP(token::PLUS)) {\n+        } else if self.eat(&token::BINOP(token::PLUS)) {\n+            if self.eat(&token::BINOP(token::PLUS)) {\n                 expl(by_val)\n             } else {\n                 expl(by_copy)\n@@ -806,7 +806,7 @@ pub impl Parser {\n             let m = p.parse_arg_mode();\n             let is_mutbl = self.eat_keyword(&~\"mut\");\n             let pat = p.parse_pat(false);\n-            let t = if p.eat(token::COLON) {\n+            let t = if p.eat(&token::COLON) {\n                 p.parse_ty(false)\n             } else {\n                 @Ty {\n@@ -826,7 +826,7 @@ pub impl Parser {\n     }\n \n     fn maybe_parse_fixed_vstore_with_star() -> Option<uint> {\n-        if self.eat(token::BINOP(token::STAR)) {\n+        if self.eat(&token::BINOP(token::STAR)) {\n             match *self.token {\n                 token::LIT_INT_UNSUFFIXED(i) if i >= 0i64 => {\n                     self.bump();\n@@ -884,7 +884,7 @@ pub impl Parser {\n \n         maybe_whole!(self, nt_path);\n         let lo = self.span.lo;\n-        let global = self.eat(token::MOD_SEP);\n+        let global = self.eat(&token::MOD_SEP);\n         let mut ids = ~[];\n         loop {\n             let is_not_last =\n@@ -917,7 +917,7 @@ pub impl Parser {\n         maybe_whole!(self, nt_path);\n         let lo = self.span.lo;\n         let path = self.parse_path_without_tps();\n-        if colons && !self.eat(token::MOD_SEP) {\n+        if colons && !self.eat(&token::MOD_SEP) {\n             return path;\n         }\n \n@@ -940,7 +940,7 @@ pub impl Parser {\n \n         // Parse any lifetime or type parameters which may appear:\n         let tps = {\n-            if !self.eat(token::LT) {\n+            if !self.eat(&token::LT) {\n                 ~[]\n             } else {\n                 // First consume lifetimes.\n@@ -1251,7 +1251,7 @@ pub impl Parser {\n \n                         self.expect(token::COMMA);\n \n-                        if self.eat(token::DOTDOT) {\n+                        if self.eat(&token::DOTDOT) {\n                             base = Some(self.parse_expr());\n                             break;\n                         }\n@@ -1302,12 +1302,12 @@ pub impl Parser {\n         let mut hi;\n         loop {\n             // expr.f\n-            if self.eat(token::DOT) {\n+            if self.eat(&token::DOT) {\n                 match *self.token {\n                   token::IDENT(i, _) => {\n                     hi = self.span.hi;\n                     self.bump();\n-                    let tys = if self.eat(token::MOD_SEP) {\n+                    let tys = if self.eat(&token::MOD_SEP) {\n                         self.expect(token::LT);\n                         self.parse_seq_to_gt(Some(token::COMMA),\n                                              |p| p.parse_ty(false))\n@@ -1960,7 +1960,7 @@ pub impl Parser {\n             if require_comma {\n                 self.expect(token::COMMA);\n             } else {\n-                self.eat(token::COMMA);\n+                self.eat(&token::COMMA);\n             }\n \n             let blk = codemap::spanned {\n@@ -2218,7 +2218,7 @@ pub impl Parser {\n                 || self.is_keyword(&~\"false\")\n             {\n                 let val = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n-                if self.eat(token::DOTDOT) {\n+                if self.eat(&token::DOTDOT) {\n                     let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n                     pat = pat_range(val, end);\n                 } else {\n@@ -2246,7 +2246,7 @@ pub impl Parser {\n                 if is_plain_ident(*self.token) && cannot_be_enum_or_struct {\n                     let name = self.parse_value_path();\n                     let sub;\n-                    if self.eat(token::AT) {\n+                    if self.eat(&token::AT) {\n                         sub = Some(self.parse_pat(refutable));\n                     } else {\n                         sub = None;\n@@ -2315,7 +2315,7 @@ pub impl Parser {\n                 ~\"expected identifier, found path\");\n         }\n         let name = self.parse_value_path();\n-        let sub = if self.eat(token::AT) {\n+        let sub = if self.eat(&token::AT) {\n             Some(self.parse_pat(refutable))\n         } else { None };\n \n@@ -2343,7 +2343,7 @@ pub impl Parser {\n             node: ty_infer,\n             span: mk_sp(lo, lo),\n         };\n-        if self.eat(token::COLON) { ty = self.parse_ty(false); }\n+        if self.eat(&token::COLON) { ty = self.parse_ty(false); }\n         let init = if allow_init { self.parse_initializer() } else { None };\n         @spanned(\n             lo,\n@@ -2362,7 +2362,7 @@ pub impl Parser {\n         let is_mutbl = self.eat_keyword(&~\"mut\");\n         let lo = self.span.lo;\n         let mut locals = ~[self.parse_local(is_mutbl, true)];\n-        while self.eat(token::COMMA) {\n+        while self.eat(&token::COMMA) {\n             locals.push(self.parse_local(is_mutbl, true));\n         }\n         return @spanned(lo, self.last_span.hi, decl_local(locals));\n@@ -2648,9 +2648,9 @@ pub impl Parser {\n \n     fn parse_optional_ty_param_bounds() -> @~[ty_param_bound] {\n         let mut bounds = ~[];\n-        if self.eat(token::COLON) {\n+        if self.eat(&token::COLON) {\n             loop {\n-                if self.eat(token::BINOP(token::AND)) {\n+                if self.eat(&token::BINOP(token::AND)) {\n                     if self.eat_keyword(&~\"static\") {\n                         bounds.push(RegionTyParamBound);\n                     } else {\n@@ -2695,7 +2695,7 @@ pub impl Parser {\n                     break;\n                 }\n \n-                if self.eat(token::BINOP(token::PLUS)) {\n+                if self.eat(&token::BINOP(token::PLUS)) {\n                     loop;\n                 }\n \n@@ -2715,7 +2715,7 @@ pub impl Parser {\n     }\n \n     fn parse_ty_params() -> ~[ty_param] {\n-        if self.eat(token::LT) {\n+        if self.eat(&token::LT) {\n             let _lifetimes = self.parse_lifetimes();\n             self.parse_seq_to_gt(\n                 Some(token::COMMA),\n@@ -2849,7 +2849,7 @@ pub impl Parser {\n \n     fn parse_fn_block_decl() -> fn_decl {\n         let inputs_captures = {\n-            if self.eat(token::OROR) {\n+            if self.eat(&token::OROR) {\n                 ~[]\n             } else {\n                 self.parse_unspanned_seq(\n@@ -2858,7 +2858,7 @@ pub impl Parser {\n                     |p| p.parse_fn_block_arg())\n             }\n         };\n-        let output = if self.eat(token::RARROW) {\n+        let output = if self.eat(&token::RARROW) {\n             self.parse_ty(false)\n         } else {\n             @Ty { id: self.get_id(), node: ty_infer, span: *self.span }\n@@ -2996,17 +2996,17 @@ pub impl Parser {\n \n             ty = self.parse_ty(false);\n             opt_trait_ref\n-        } else if self.eat(token::COLON) {\n+        } else if self.eat(&token::COLON) {\n             self.obsolete(*self.span, ObsoleteImplSyntax);\n             Some(self.parse_trait_ref())\n         } else {\n             None\n         };\n \n         let mut meths = ~[];\n-        if !self.eat(token::SEMI) {\n+        if !self.eat(&token::SEMI) {\n             self.expect(token::LBRACE);\n-            while !self.eat(token::RBRACE) {\n+            while !self.eat(&token::RBRACE) {\n                 meths.push(self.parse_method());\n             }\n         }\n@@ -3061,7 +3061,7 @@ pub impl Parser {\n         let class_name = self.parse_value_ident();\n         self.parse_region_param();\n         let ty_params = self.parse_ty_params();\n-        if self.eat(token::COLON) {\n+        if self.eat(&token::COLON) {\n             self.obsolete(*self.span, ObsoleteClassTraits);\n             let _ = self.parse_trait_ref_list(token::LBRACE);\n         }\n@@ -3070,7 +3070,7 @@ pub impl Parser {\n         let mut the_dtor: Option<(blk, ~[attribute], codemap::span)> = None;\n         let is_tuple_like;\n \n-        if self.eat(token::LBRACE) {\n+        if self.eat(&token::LBRACE) {\n             // It's a record-like struct.\n             is_tuple_like = false;\n             fields = ~[];\n@@ -3113,7 +3113,7 @@ pub impl Parser {\n                 @spanned(lo, p.span.hi, struct_field_)\n             };\n             self.expect(token::SEMI);\n-        } else if self.eat(token::SEMI) {\n+        } else if self.eat(&token::SEMI) {\n             // It's a unit-like struct.\n             is_tuple_like = true;\n             fields = ~[];\n@@ -3526,7 +3526,7 @@ pub impl Parser {\n         };\n \n         // extern mod { ... }\n-        if items_allowed && self.eat(token::LBRACE) {\n+        if items_allowed && self.eat(&token::LBRACE) {\n             let abi;\n             match abi_opt {\n                 Some(found_abi) => abi = found_abi,\n@@ -3578,7 +3578,7 @@ pub impl Parser {\n     }\n \n     fn parse_region_param() {\n-        if self.eat(token::BINOP(token::SLASH)) {\n+        if self.eat(&token::BINOP(token::SLASH)) {\n             self.expect(token::BINOP(token::AND));\n         }\n     }\n@@ -3659,7 +3659,7 @@ pub impl Parser {\n                 needs_comma = false;\n             } else {\n                 ident = self.parse_value_ident();\n-                if self.eat(token::LBRACE) {\n+                if self.eat(&token::LBRACE) {\n                     // Parse a struct variant.\n                     all_nullary = false;\n                     kind = struct_variant_kind(self.parse_struct_def());\n@@ -3676,7 +3676,7 @@ pub impl Parser {\n                         });\n                     }\n                     kind = tuple_variant_kind(args);\n-                } else if self.eat(token::EQ) {\n+                } else if self.eat(&token::EQ) {\n                     have_disr = true;\n                     disr_expr = Some(self.parse_expr());\n                     kind = tuple_variant_kind(args);\n@@ -3696,7 +3696,7 @@ pub impl Parser {\n             };\n             variants.push(spanned(vlo, self.last_span.hi, vr));\n \n-            if needs_comma && !self.eat(token::COMMA) { break; }\n+            if needs_comma && !self.eat(&token::COMMA) { break; }\n         }\n         self.expect(token::RBRACE);\n         if (have_disr && !all_nullary) {"}]}