{"sha": "9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMTZjZjJiZjY0NmE0YTg4MWYzZjVhY2JmNTU4MmRhY2M0MzM3YmY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-20T09:16:07Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-20T09:16:07Z"}, "message": "Merge #292\n\n292: Vfs r=matklad a=matklad\n\ncloses #243\r\n\r\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "ff90eb390a8f5af47b6d0c6ec4c49b4431b82d1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff90eb390a8f5af47b6d0c6ec4c49b4431b82d1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "html_url": "https://github.com/rust-lang/rust/commit/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "dbb62b5baa36783bbca06f09c77794fce3ceff0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbb62b5baa36783bbca06f09c77794fce3ceff0c", "html_url": "https://github.com/rust-lang/rust/commit/dbb62b5baa36783bbca06f09c77794fce3ceff0c"}, {"sha": "a084412f0698d5f54d586f707930e141c88b0673", "url": "https://api.github.com/repos/rust-lang/rust/commits/a084412f0698d5f54d586f707930e141c88b0673", "html_url": "https://github.com/rust-lang/rust/commit/a084412f0698d5f54d586f707930e141c88b0673"}], "stats": {"total": 2211, "additions": 1354, "deletions": 857}, "files": [{"sha": "7ebe6e67f998fff708151db04db218827750db40", "filename": "Cargo.lock", "status": "modified", "additions": 300, "deletions": 165, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -3,7 +3,7 @@ name = \"aho-corasick\"\n version = \"0.6.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"memchr 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"memchr 2.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -21,41 +21,47 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"arrayvec\"\n-version = \"0.4.7\"\n+version = \"0.4.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"nodrop 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"nodrop 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"atty\"\n version = \"0.2.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"termion 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"autocfg\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"backtrace\"\n-version = \"0.3.9\"\n+version = \"0.3.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"backtrace-sys 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"autocfg 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"backtrace-sys 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-demangle 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"backtrace-sys\"\n-version = \"0.1.24\"\n+version = \"0.1.26\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -93,19 +99,19 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"cargo_metadata\"\n-version = \"0.6.1\"\n+version = \"0.6.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.32 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.25\"\n+version = \"1.0.27\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -120,7 +126,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"num-integer 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"time 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"time 0.1.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -150,11 +156,11 @@ name = \"crossbeam-channel\"\n version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"crossbeam-epoch 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-epoch 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crossbeam-utils 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -171,23 +177,23 @@ name = \"crossbeam-epoch\"\n version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"arrayvec 0.4.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crossbeam-utils 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"nodrop 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"nodrop 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"crossbeam-epoch\"\n-version = \"0.6.0\"\n+version = \"0.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"arrayvec 0.4.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"crossbeam-utils 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam-utils 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -206,14 +212,22 @@ name = \"crossbeam-utils\"\n version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"crossbeam-utils\"\n+version = \"0.6.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"derive-new\"\n version = \"0.5.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -249,15 +263,15 @@ name = \"error-chain\"\n version = \"0.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"backtrace 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"backtrace 0.3.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"failure\"\n version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"backtrace 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"backtrace 0.3.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -266,9 +280,9 @@ name = \"failure_derive\"\n version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -279,18 +293,18 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"flexi_logger\"\n-version = \"0.10.0\"\n+version = \"0.10.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"fst\"\n-version = \"0.3.2\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -319,9 +333,9 @@ dependencies = [\n  \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"languageserver-types 0.53.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.32 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -339,7 +353,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"heck\"\n-version = \"0.3.0\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"unicode-segmentation 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -381,7 +395,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"itertools\"\n-version = \"0.7.8\"\n+version = \"0.7.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -405,9 +419,9 @@ dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-derive 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.32 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -419,15 +433,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.43\"\n+version = \"0.2.45\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"lock_api\"\n-version = \"0.1.4\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"owning_ref 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -451,11 +465,11 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"memchr\"\n-version = \"2.1.1\"\n+version = \"2.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"version_check 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -464,7 +478,7 @@ name = \"memmap\"\n version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -475,7 +489,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"nodrop\"\n-version = \"0.1.12\"\n+version = \"0.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -484,9 +498,9 @@ version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"proc-macro2 0.4.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -504,15 +518,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"num_cpus\"\n-version = \"1.8.0\"\n+version = \"1.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"owning_ref\"\n-version = \"0.3.3\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"stable_deref_trait 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -523,18 +537,39 @@ name = \"parking_lot\"\n version = \"0.6.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lock_api 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lock_api 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"parking_lot\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"lock_api 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"parking_lot_core\"\n version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -568,8 +603,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"pest 2.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest_meta 2.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"proc-macro2 0.4.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.14.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -585,25 +620,25 @@ dependencies = [\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"0.4.20\"\n+version = \"0.4.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"quote\"\n-version = \"0.6.9\"\n+version = \"0.6.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"ra_analysis\"\n version = \"0.1.0\"\n dependencies = [\n- \"fst 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"fst 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_db 0.1.0\",\n@@ -647,7 +682,7 @@ dependencies = [\n name = \"ra_editor\"\n version = \"0.1.0\"\n dependencies = [\n- \"itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_syntax 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n@@ -660,6 +695,7 @@ dependencies = [\n name = \"ra_hir\"\n version = \"0.1.0\"\n dependencies = [\n+ \"arrayvec 0.4.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"id-arena 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -676,50 +712,52 @@ dependencies = [\n name = \"ra_lsp_server\"\n version = \"0.1.0\"\n dependencies = [\n- \"cargo_metadata 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cargo_metadata 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crossbeam-channel 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flexi_logger 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flexi_logger 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gen_lsp_server 0.1.0\",\n  \"im 12.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"languageserver-types 0.53.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_analysis 0.1.0\",\n  \"ra_editor 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n+ \"ra_vfs 0.1.0\",\n  \"rayon 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.32 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smol_str 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempdir 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n  \"text_unit 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"thread_worker 0.1.0\",\n  \"threadpool 1.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"walkdir 2.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"ra_syntax\"\n version = \"0.1.0\"\n dependencies = [\n- \"arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"arrayvec 0.4.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_text_edit 0.1.0\",\n- \"rowan 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rowan 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n  \"text_unit 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"walkdir 2.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -730,13 +768,26 @@ dependencies = [\n  \"text_unit 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"ra_vfs\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"crossbeam-channel 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"thread_worker 0.1.0\",\n+ \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rand\"\n version = \"0.4.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -747,11 +798,38 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_core 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"rand\"\n+version = \"0.6.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_chacha 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_hc 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_isaac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_pcg 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_xorshift 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rand_chacha\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rand_core\"\n version = \"0.2.2\"\n@@ -765,6 +843,39 @@ name = \"rand_core\"\n version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"rand_hc\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rand_isaac\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rand_pcg\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rand_xorshift\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rayon\"\n version = \"1.0.3\"\n@@ -782,41 +893,41 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-deque 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"redox_syscall\"\n-version = \"0.1.40\"\n+version = \"0.1.44\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"redox_termios\"\n version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"redox_syscall 0.1.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"regex\"\n-version = \"1.0.6\"\n+version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"aho-corasick 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"memchr 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"memchr 2.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"utf8-ranges 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.6.2\"\n+version = \"0.6.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"ucd-util 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ucd-util 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -839,12 +950,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"base64 0.9.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rowan\"\n-version = \"0.1.2\"\n+version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -854,7 +965,7 @@ dependencies = [\n \n [[package]]\n name = \"rustc-demangle\"\n-version = \"0.1.9\"\n+version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -875,7 +986,7 @@ dependencies = [\n \n [[package]]\n name = \"ryu\"\n-version = \"0.2.6\"\n+version = \"0.2.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -890,11 +1001,11 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"derive-new 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lock_api 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lock_api 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -916,7 +1027,7 @@ version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -926,30 +1037,30 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.80\"\n+version = \"1.0.82\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde_derive 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.80\"\n+version = \"1.0.82\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.32\"\n+version = \"1.0.33\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"itoa 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"ryu 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ryu 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -973,7 +1084,7 @@ dependencies = [\n \n [[package]]\n name = \"smallvec\"\n-version = \"0.6.5\"\n+version = \"0.6.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -984,7 +1095,7 @@ name = \"smol_str\"\n version = \"0.1.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1007,18 +1118,18 @@ name = \"syn\"\n version = \"0.14.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"syn\"\n-version = \"0.15.18\"\n+version = \"0.15.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1027,9 +1138,9 @@ name = \"synstructure\"\n version = \"0.10.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1042,9 +1153,22 @@ dependencies = [\n  \"remove_dir_all 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"tempfile\"\n+version = \"3.0.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"redox_syscall 0.1.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"remove_dir_all 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"tera\"\n-version = \"0.11.19\"\n+version = \"0.11.20\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1054,9 +1178,9 @@ dependencies = [\n  \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest 2.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest_derive 2.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.32 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"slug 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unic-segment 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1068,18 +1192,18 @@ version = \"0.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"heck 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ron 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"tera 0.11.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tera 0.11.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"termion\"\n version = \"1.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"redox_syscall 0.1.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"redox_termios 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1088,8 +1212,8 @@ name = \"test_utils\"\n version = \"0.1.0\"\n dependencies = [\n  \"difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.32 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"text_unit 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1098,7 +1222,7 @@ name = \"text_unit\"\n version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1131,16 +1255,16 @@ name = \"threadpool\"\n version = \"1.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"time\"\n-version = \"0.1.40\"\n+version = \"0.1.41\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"redox_syscall 0.1.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1150,9 +1274,9 @@ version = \"0.1.0\"\n dependencies = [\n  \"clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"teraron 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"walkdir 2.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1167,7 +1291,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"ucd-util\"\n-version = \"0.1.2\"\n+version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -1265,7 +1389,7 @@ name = \"url_serde\"\n version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1291,7 +1415,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"walkdir\"\n-version = \"2.2.6\"\n+version = \"2.2.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"same-file 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1330,27 +1454,29 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum aho-corasick 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1e9a933f4e58658d7b12defcf96dc5c720f20832deebe3e0a19efd3b6aaeeb9e\"\n \"checksum ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n \"checksum arrayref 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d382e583f07208808f6b1249e60848879ba3543f57c32277bf52d69c2f0f0ee\"\n-\"checksum arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a1e964f9e24d588183fcb43503abda40d288c8657dfc27311516ce2f05675aef\"\n+\"checksum arrayvec 0.4.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d18513977c2d8261c448511c5c53dc66b26dfccbc3d4446672dea1e71a7d8a26\"\n \"checksum atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a7d5b8723950951411ee34d271d99dddcc2035a16ab25310ea2c8cfd4369652\"\n-\"checksum backtrace 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"89a47830402e9981c5c41223151efcced65a0510c13097c769cede7efb34782a\"\n-\"checksum backtrace-sys 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c66d56ac8dabd07f6aacdaf633f4b8262f5b3601a810a0dcddffd5c22c69daa0\"\n+\"checksum autocfg 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4e5f34df7a019573fb8bdc7e24a2bfebe51a2a1d6bfdbaeccedb3c41fc574727\"\n+\"checksum backtrace 0.3.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b5b493b66e03090ebc4343eb02f94ff944e0cbc9ac6571491d170ba026741eb5\"\n+\"checksum backtrace-sys 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3fcce89e5ad5c8949caa9434501f7b55415b3e7ad5270cb88c75a8d35e8f1279\"\n \"checksum base64 0.9.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"489d6c0ed21b11d038c31b6ceccca973e65d73ba3bd8ecb9a2babf5546164643\"\n \"checksum bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"228047a76f468627ca71776ecdebd732a3423081fcf5125585bcd7c49886ce12\"\n \"checksum block-buffer 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a076c298b9ecdb530ed9d967e74a6027d6a7478924520acddcddc24c1c8ab3ab\"\n \"checksum byte-tools 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"560c32574a12a89ecd91f5e742165893f86e3ab98d21f8ea548658eb9eef5f40\"\n \"checksum byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94f88df23a25417badc922ab0f5716cc1330e87f71ddd9203b3a3ccd9cedf75d\"\n-\"checksum cargo_metadata 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1aaa1a9856ae2d188340526d0986feb6899c9ad11c5dfd73453c784fed6e373d\"\n-\"checksum cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f159dfd43363c4d08055a07703eb7a3406b0dac4d0584d96965a3262db3c9d16\"\n+\"checksum cargo_metadata 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e5d1b4d380e1bab994591a24c2bdd1b054f64b60bef483a8c598c7c345bc3bbe\"\n+\"checksum cc 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\" = \"155ed195f7bd722d1dfeb30365b9d0c1f6a078fa7ca4014497e5935d90993d6f\"\n \"checksum cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"082bb9b28e00d3c9d39cc03e64ce4cea0f1bb9b3fde493f0cbc008472d22bdf4\"\n \"checksum chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"45912881121cb26fad7c38c17ba7daa18764771836b34fab7d3fbd93ed633878\"\n \"checksum clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b957d88f4b6a63b9d70d5f454ac8011819c6efa7727858f458ab71c756ce2d3e\"\n \"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f\"\n \"checksum crossbeam-channel 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7b85741761b7f160bc5e7e0c14986ef685b7f8bf9b7ad081c60c604bb4649827\"\n \"checksum crossbeam-deque 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f739f8c5363aca78cfb059edf753d8f0d36908c348f3d8d1503f03d8b75d9cf3\"\n \"checksum crossbeam-epoch 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"927121f5407de9956180ff5e936fe3cf4324279280001cd56b669d28ee7e9150\"\n-\"checksum crossbeam-epoch 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9c90f1474584f38e270b5b613e898c8c328aa4f3dea85e0a27ac2e642f009416\"\n+\"checksum crossbeam-epoch 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2449aaa4ec7ef96e5fb24db16024b935df718e9ae1cec0a1e68feeca2efca7b8\"\n \"checksum crossbeam-utils 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2760899e32a1d58d5abb31129f8fae5de75220bc2176e77ff7c627ae45c918d9\"\n \"checksum crossbeam-utils 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"677d453a17e8bd2b913fa38e8b9cf04bcdbb5be790aa294f2389661d72036015\"\n+\"checksum crossbeam-utils 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"41ee4864f4797060e52044376f7d107429ce1fb43460021b126424b7180ee21a\"\n \"checksum derive-new 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ca414e896ae072546f4d789f452daaecf60ddee4c9df5dc6d5936d769e3d87c\"\n \"checksum deunicode 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"850878694b7933ca4c9569d30a34b55031b9b139ee1fc7b94a527c4ef960d690\"\n \"checksum difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198\"\n@@ -1361,95 +1487,104 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6dd377bcc1b1b7ce911967e3ec24fa19c3224394ec05b54aa7b083d498341ac7\"\n \"checksum failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"64c2d913fe8ed3b6c6518eedf4538255b989945c14c2a7d5cbff62a5e2120596\"\n \"checksum fake-simd 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n-\"checksum flexi_logger 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"553854ebfebeae44ba699a9dc7d53a4036ccc01cd1e144aea0e3054c54383733\"\n-\"checksum fst 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9b0408ab57c1bf7c634b2ac6a165d14f642dc3335a43203090a7f8c78b54577b\"\n+\"checksum flexi_logger 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4dda06444ccc8b0a6da19d939989b4a4e83f328710ada449eedaed48c8b903cd\"\n+\"checksum fst 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"db72126ca7dff566cdbbdd54af44668c544897d9d3862b198141f176f1238bdf\"\n \"checksum fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82\"\n \"checksum fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7\"\n \"checksum generic-array 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef25c5683767570c2bbd7deba372926a55eaae9982d7726ee2a1050239d45b9d\"\n \"checksum glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb\"\n-\"checksum heck 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea04fa3ead4e05e51a7c806fc07271fdbde4e246a6c6d1efd52e72230b771b82\"\n+\"checksum heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"20564e78d53d2bb135c343b3f47714a56af2061f1c928fdb541dc7b9fdd94205\"\n \"checksum humansize 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b6cab2627acfc432780848602f3f558f7e9dd427352224b0d9324025796d2a5e\"\n \"checksum id-arena 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a7250033feafee46a1cecd2c2616a64aec1d064f38c9ae2bdd297728542843e\"\n \"checksum idna 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"38f09e0f0b1fb55fdee1f17470ad800da77af5186a1a76c026b679358b7e844e\"\n \"checksum im 12.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ae9c7f9bb8aee47fc16d535a705f7867a9fc83bb822e5e1043bb98e77ffeed3c\"\n \"checksum indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e81a7c05f79578dbc15793d8b619db9ba32b4577003ef3af1a91c416798c58d\"\n-\"checksum itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f58856976b776fedd95533137617a02fb25719f40e7d9b01c7043cd65474f450\"\n+\"checksum itertools 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d47946d458e94a1b7bcabbf6521ea7c037062c81f534615abcad76e84d4970d\"\n \"checksum itoa 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1306f3464951f30e30d12373d31c79fbd52d236e5e896fd92f96ec7babbbe60b\"\n \"checksum join_to_string 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7bddc885f3fd69dd4b5d747c2efe6dd2c36d795ea9938281ed50910e32c95e31\"\n \"checksum languageserver-types 0.53.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a0be4f8f783832a308975035043c0e8ad18e11c3f3d395aa6f1a9f3a30b8e654\"\n \"checksum lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a374c89b9db55895453a74c1e38861d9deec0b01b405a82516e9d5de4820dea1\"\n-\"checksum libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76e3a3ef172f1a0b9a9ff0dd1491ae5e6c948b94479a3021819ba7d860c8645d\"\n-\"checksum lock_api 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"775751a3e69bde4df9b38dd00a1b5d6ac13791e4223d4a0506577f0dd27cfb7a\"\n+\"checksum libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d2857ec59fadc0773853c664d2d18e7198e83883e7060b63c924cb077bd5c74\"\n+\"checksum lock_api 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"62ebf1391f6acad60e5c8b43706dde4582df75c06698ab44511d15016bc2442c\"\n \"checksum log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c84ec4b527950aa83a329754b01dbe3f58361d1c5efacd1f6d68c494d08a17c6\"\n \"checksum maplit 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"08cbb6b4fef96b6d77bfc40ec491b1690c779e77b05cd9f07f787ed376fd4c43\"\n \"checksum matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08\"\n-\"checksum memchr 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a3eb002f0535929f1199681417029ebea04aadc0c7a4224b46be99c7f5d6a16\"\n+\"checksum memchr 2.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"db4c41318937f6e76648f42826b1d9ade5c09cafb5aef7e351240a70f39206e9\"\n \"checksum memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2ffa2c986de11a9df78620c01eeaaf27d94d3ff02bf81bfcca953102dd0c6ff\"\n \"checksum memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0f9dc261e2b62d7a622bf416ea3c5245cdd5d9a7fcc428c0d06804dfce1775b3\"\n-\"checksum nodrop 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a2228dca57108069a5262f2ed8bd2e82496d2e074a06d1ccc7ce1687b6ae0a2\"\n+\"checksum nodrop 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f9667ddcc6cc8a43afc9b7917599d7216aa09c463919ea32c59ed6cac8bc945\"\n \"checksum num-derive 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8af1847c907c2f04d7bfd572fb25bbb4385c637fe5be163cf2f8c5d778fe1e7d\"\n \"checksum num-integer 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e83d528d2677f0518c570baf2b7abdcf0cd2d248860b68507bdcb3e91d4c0cea\"\n \"checksum num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0b3a5d7cc97d6d30d8b9bc8fa19bf45349ffe46241e8816f50f62f6d6aaabee1\"\n-\"checksum num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c51a3322e4bca9d212ad9a158a02abc6934d005490c054a2778df73a70aa0a30\"\n-\"checksum owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdf84f41639e037b484f93433aa3897863b561ed65c6e59c7073d7c561710f37\"\n+\"checksum num_cpus 1.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5a69d464bdc213aaaff628444e99578ede64e9c854025aa43b9796530afa9238\"\n+\"checksum owning_ref 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49a4b8ea2179e6a2e27411d3bca09ca6dd630821cf6894c6c7c8467a8ee7ef13\"\n \"checksum parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f0802bff09003b291ba756dc7e79313e51cc31667e94afbe847def490424cde5\"\n+\"checksum parking_lot 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9723236a9525c757d9725b993511e3fc941e33f27751942232f0058298297edf\"\n \"checksum parking_lot_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad7f7e6ebdc79edff6fdcb87a55b620174f7a989e3eb31b65231f4af57f00b8c\"\n+\"checksum parking_lot_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94c8c7923936b28d546dfd14d4472eaf34c99b14e1c973a32b3e6d4eb04298c9\"\n \"checksum percent-encoding 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"31010dd2e1ac33d5b46a5b413495239882813e0369f8ed8a5e266f173602f831\"\n \"checksum pest 2.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a677051ad923732bb5c70f2d45f8985a96e3eee2e2bff86697e3b11b0c3fcfde\"\n \"checksum pest_derive 2.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b76f477146419bc539a63f4ef40e902166cb43b3e51cecc71d9136fd12c567e7\"\n \"checksum pest_generator 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ebee4e9680be4fd162e6f3394ae4192a6b60b1e4d17d845e631f0c68d1a3386\"\n \"checksum pest_meta 2.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1f6d5f6f0e6082578c86af197d780dc38328e3f768cec06aac9bc46d714e8221\"\n-\"checksum proc-macro2 0.4.20 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3d7b7eaaa90b4a90a932a9ea6666c95a389e424eff347f0f793979289429feee\"\n-\"checksum quote 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"63b5829244f52738cfee93b3a165c1911388675be000c888d2fae620dee8fa5b\"\n+\"checksum proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"77619697826f31a02ae974457af0b29b723e5619e113e9397b8b82c6bd253f09\"\n+\"checksum quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"53fa22a1994bd0f9372d7a816207d8a2677ad0325b073f5c5332760f0fb62b5c\"\n \"checksum rand 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8356f47b32624fef5b3301c1be97e5944ecdd595409cc5da11d05f211db6cfbd\"\n \"checksum rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e464cd887e869cddcae8792a4ee31d23c7edd516700695608f5b98c67ee0131c\"\n+\"checksum rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ae9d223d52ae411a33cf7e54ec6034ec165df296ccd23533d671a28252b6f66a\"\n+\"checksum rand_chacha 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"771b009e3a508cb67e8823dda454aaa5368c7bc1c16829fb77d3e980440dd34a\"\n \"checksum rand_core 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1961a422c4d189dfb50ffa9320bf1f2a9bd54ecb92792fb9477f99a1045f3372\"\n \"checksum rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0905b6b7079ec73b314d4c748701f6931eb79fd97c668caa3f1899b22b32c6db\"\n+\"checksum rand_hc 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7b40677c7be09ae76218dc623efbf7b18e34bced3f38883af07bb75630a21bc4\"\n+\"checksum rand_isaac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ded997c9d5f13925be2a6fd7e66bf1872597f759fd9dd93513dd7e92e5a5ee08\"\n+\"checksum rand_pcg 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"086bd09a33c7044e56bb44d5bdde5a60e7f119a9e95b0775f545de759a32fe05\"\n+\"checksum rand_xorshift 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"effa3fcaa47e18db002bdde6060944b6d2f9cfd8db471c30e873448ad9187be3\"\n \"checksum rayon 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"373814f27745b2686b350dd261bfd24576a6fb0e2c5919b3a2b6005f820b0473\"\n \"checksum rayon-core 1.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b055d1e92aba6877574d8fe604a63c8b5df60f60e5982bf7ccbb1338ea527356\"\n-\"checksum redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c214e91d3ecf43e9a4e41e578973adeb14b474f2bee858742d127af75a0112b1\"\n+\"checksum redox_syscall 0.1.44 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a84bcd297b87a545980a2d25a0beb72a1f490c31f0a9fde52fca35bfbb1ceb70\"\n \"checksum redox_termios 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e891cfe48e9100a70a3b6eb652fef28920c117d366339687bd5576160db0f76\"\n-\"checksum regex 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ee84f70c8c08744ea9641a731c7fadb475bf2ecc52d7f627feb833e0b3990467\"\n-\"checksum regex-syntax 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"747ba3b235651f6e2f67dfa8bcdcd073ddb7c243cb21c442fc12395dfcac212d\"\n+\"checksum regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"37e7cbbd370869ce2e8dff25c7018702d10b21a20ef7135316f8daecd6c25b7f\"\n+\"checksum regex-syntax 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4e47a2ed29da7a9e1960e1639e7a982e6edc6d49be308a3b02daf511504a16d1\"\n \"checksum relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e7790c7f1cc73d831d28dc5a7deb316a006e7848e6a7f467cdb10a0a9e0fb1c\"\n \"checksum remove_dir_all 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3488ba1b9a2084d38645c4c08276a1752dcbf2c7130d74f1569681ad5d2799c5\"\n \"checksum ron 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c48677d8a9247a4e0d1f3f9cb4b0a8e29167fdc3c04f383a5e669cd7a960ae0f\"\n-\"checksum rowan 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"795b1c830f5335e89f93415315518e9727307308c44c1e5adebe8a38f856c334\"\n-\"checksum rustc-demangle 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bcfe5b13211b4d78e5c2cadfebd7769197d95c639c35a50057eb4c05de811395\"\n+\"checksum rowan 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9ccca91953e9c549cac18e8f41daa5d49dad1c9a4c9bb977ac42718bb34e1bf\"\n+\"checksum rustc-demangle 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"01b90379b8664dd83460d59bdc5dd1fd3172b8913788db483ed1325171eab2f7\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n-\"checksum ryu 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7153dd96dade874ab973e098cb62fcdbb89a03682e46b144fd09550998d4a4a7\"\n+\"checksum ryu 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb9e9b8cde282a9fe6a42dd4681319bfb63f121b8a8ee9439c6f4107e58a46f7\"\n \"checksum safemem 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8dca453248a96cb0749e36ccdfe2b0b4e54a61bfef89fb97ec621eb8e0a93dd9\"\n \"checksum salsa 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e56b13ce9b2bfaa1c89863d76880838c0734de85beeaef437fd70d4fa7e253d3\"\n \"checksum same-file 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8f20c4be53a8a1ff4c1f1b2bd14570d2f634628709752f0702ecdd2b3f9a5267\"\n \"checksum scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94258f53601af11e6a49f722422f6e3425c52b06245a5cf9bc09908b174f5e27\"\n \"checksum semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n \"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n-\"checksum serde 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15c141fc7027dd265a47c090bf864cf62b42c4d228bbcf4e51a0c9e2b0d3f7ef\"\n-\"checksum serde_derive 1.0.80 (registry+https://github.com/rust-lang/crates.io-index)\" = \"225de307c6302bec3898c51ca302fc94a7a1697ef0845fcee6448f33c032249c\"\n-\"checksum serde_json 1.0.32 (registry+https://github.com/rust-lang/crates.io-index)\" = \"43344e7ce05d0d8280c5940cabb4964bea626aa58b1ec0e8c73fa2a8512a38ce\"\n+\"checksum serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6fa52f19aee12441d5ad11c9a00459122bd8f98707cadf9778c540674f1935b6\"\n+\"checksum serde_derive 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\" = \"96a7f9496ac65a2db5929afa087b54f8fc5008dcfbe48a8874ed20049b0d6154\"\n+\"checksum serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c37ccd6be3ed1fdf419ee848f7c758eb31b054d7cd3ae3600e3bae0adf569811\"\n \"checksum sha-1 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"51b9d1f3b5de8a167ab06834a7c883bd197f2191e1dda1a22d9ccfeedbf9aded\"\n \"checksum slug 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b3bc762e6a4b6c6fcaade73e77f9ebc6991b676f88bb2358bddb56560f073373\"\n-\"checksum smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"153ffa32fd170e9944f7e0838edf824a754ec4c1fc64746fcc9fe1f8fa602e5d\"\n+\"checksum smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b73ea3738b47563803ef814925e69be00799a8c07420be8b996f8e98fb2336db\"\n \"checksum smol_str 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f3ed6f19b800d76574926e458d5f8e2dbea86c2b58c08d33a982448f09ac8d0c\"\n \"checksum stable_deref_trait 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dba1a27d3efae4351c8051072d619e3ade2820635c3958d826bfea39d59b54c8\"\n \"checksum strsim 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb4f380125926a99e52bc279241539c018323fab05ad6368b56f93d9369ff550\"\n \"checksum superslice 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b50b13d42370e0f5fc62eafdd5c2d20065eaf5458dab215ff3e20e63eea96b30\"\n \"checksum syn 0.14.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"261ae9ecaa397c42b960649561949d69311f08eeaea86a65696e6e46517cf741\"\n-\"checksum syn 0.15.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"90c39a061e2f412a9f869540471ab679e85e50c6b05604daf28bc3060f75c430\"\n+\"checksum syn 0.15.23 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9545a6a093a3f0bd59adb472700acc08cad3776f860f16a897dfce8c88721cbc\"\n \"checksum synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"73687139bf99285483c96ac0add482c3776528beac1d97d444f6e91f203a2015\"\n \"checksum tempdir 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15f2b5fb00ccdf689e0149d1b1b3c03fead81c2b37735d812fa8bddbbf41b6d8\"\n-\"checksum tera 0.11.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ac6d8ad623a7efcfb4367ce2a36f84ef849d5aa3c7bcf2e0324c4cbcc57ebaf\"\n+\"checksum tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e91405c14320e5c79b3d148e1c86f40749a36e490642202a31689cb1a3452b2\"\n+\"checksum tera 0.11.20 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4b505279e19d8f7d24b1a9dc58327c9c36174b1a2c7ebdeac70792d017cb64f3\"\n \"checksum teraron 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d89ad4617d1dec55331067fadaa041e813479e1779616f3d3ce9308bf46184e\"\n \"checksum termion 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"689a3bdfaab439fd92bc87df5c4c78417d3cbe537487274e9b0b2dce76e92096\"\n \"checksum text_unit 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8009d7bdbd896a7e09b595f8f9325a19047fc708653e60d0895202b82135048f\"\n \"checksum textwrap 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"307686869c93e71f94da64286f9a9524c0f308a9e1c87a583de8e9c9039ad3f6\"\n \"checksum thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c6b53e329000edc2b34dbe8545fd20e55a333362d0a321909685a19bd28c3f1b\"\n \"checksum threadpool 1.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2f0c90a5f3459330ac8bc0d2f879c693bb7a2f59689c1083fc4ef83834da865\"\n-\"checksum time 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d825be0eb33fda1a7e68012d51e9c7f451dc1a69391e7fdc197060bb8c56667b\"\n+\"checksum time 0.1.41 (registry+https://github.com/rust-lang/crates.io-index)\" = \"847da467bf0db05882a9e2375934a8a55cffdc9db0d128af1518200260ba1f6c\"\n \"checksum typenum 1.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"612d636f949607bdf9b123b4a6f6d966dedf3ff669f7f045890d3a4a73948169\"\n \"checksum ucd-trie 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"71a9c5b1fe77426cf144cc30e49e955270f5086e31a6441dfa8b32efc09b9d77\"\n-\"checksum ucd-util 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d0f8bfa9ff0cadcd210129ad9d2c5f145c13e9ced3d3e5d948a6213487d52444\"\n+\"checksum ucd-util 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"535c204ee4d8434478593480b8f86ab45ec9aae0e83c568ca81abf0fd0e88f86\"\n \"checksum unic-char-property 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ce36d3f7ce754afdbccccf8ff0dd0134e50fb44aaae579f96218856e9e5dbd1e\"\n \"checksum unic-char-range 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9ab85fab42ad1b26cafc03bf891f69cb4d6e15f491030e89a0122197baa8ae8\"\n \"checksum unic-common 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff8d4a7ade929ef7d971e16ced21a8cd56a63869aa6032dfb8cb083cf7d077bf\"\n@@ -1468,7 +1603,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum vec_map 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"05c78687fb1a80548ae3250346c3db86a80a7cdd77bda190189f2d0a0987c81a\"\n \"checksum version_check 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"914b1a6776c4c929a602fafd8bc742e06365d4bcbe48c30f9cca5824f70dc9dd\"\n \"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n-\"checksum walkdir 2.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0ffb549f212c31e19f3667c55a7f515b983a84aef10fd0a4d1f9c125425115f3\"\n+\"checksum walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9d9d7ed3431229a144296213105a390676cc49c9b6a72bd19f3176c98e129fa1\"\n \"checksum winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"92c1eb33641e276cfa214a0522acad57be5c56b10cb348b3c5117db75f3ac4b0\"\n \"checksum winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n \"checksum winapi-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afc5508759c5bf4285e61feb862b6083c8480aec864fa17a81fdec6f69b461ab\""}, {"sha": "95830561d291d8e5f8df1568f021415e2279ffef", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -2,4 +2,5 @@\n members = [ \"crates/*\" ]\n \n [profile.release]\n+incremental = true\n debug = true"}, {"sha": "3d0f13f3410b89bbc197a6660944ef6f4c687834", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -30,11 +30,11 @@ impl Default for RootDatabase {\n             runtime: salsa::Runtime::default(),\n             id_maps: Default::default(),\n         };\n-        db.query_mut(ra_db::SourceRootQuery)\n-            .set(ra_db::WORKSPACE, Default::default());\n         db.query_mut(ra_db::CrateGraphQuery)\n             .set((), Default::default());\n-        db.query_mut(ra_db::LibrariesQuery)\n+        db.query_mut(ra_db::LocalRootsQuery)\n+            .set((), Default::default());\n+        db.query_mut(ra_db::LibraryRootsQuery)\n             .set((), Default::default());\n         db\n     }\n@@ -61,9 +61,11 @@ salsa::database_storage! {\n     pub(crate) struct RootDatabaseStorage for RootDatabase {\n         impl ra_db::FilesDatabase {\n             fn file_text() for ra_db::FileTextQuery;\n+            fn file_relative_path() for ra_db::FileRelativePathQuery;\n             fn file_source_root() for ra_db::FileSourceRootQuery;\n             fn source_root() for ra_db::SourceRootQuery;\n-            fn libraries() for ra_db::LibrariesQuery;\n+            fn local_roots() for ra_db::LocalRootsQuery;\n+            fn library_roots() for ra_db::LibraryRootsQuery;\n             fn crate_graph() for ra_db::CrateGraphQuery;\n         }\n         impl ra_db::SyntaxDatabase {"}, {"sha": "c4291885aa726b62def3b6e93a18f8b4449aa15d", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 71, "deletions": 68, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -10,9 +10,8 @@ use ra_syntax::{\n     SyntaxKind::*,\n     SyntaxNodeRef, TextRange, TextUnit,\n };\n-use ra_db::{FilesDatabase, SourceRoot, SourceRootId, WORKSPACE, SyntaxDatabase};\n+use ra_db::{FilesDatabase, SourceRoot, SourceRootId, SyntaxDatabase};\n use rayon::prelude::*;\n-use rustc_hash::FxHashSet;\n use salsa::{Database, ParallelDatabase};\n use hir::{\n     self,\n@@ -24,8 +23,8 @@ use hir::{\n use crate::{\n     completion::{completions, CompletionItem},\n     db,\n-    symbol_index::{SymbolIndex, SymbolsDatabase},\n-    AnalysisChange, Cancelable, CrateId, Diagnostic, FileId,\n+    symbol_index::{SymbolIndex, SymbolsDatabase, LibrarySymbolsQuery},\n+    AnalysisChange, RootChange, Cancelable, CrateId, Diagnostic, FileId,\n     FileSystemEdit, FilePosition, Query, SourceChange, SourceFileNodeEdit,\n     ReferenceResolution,\n };\n@@ -44,70 +43,41 @@ impl AnalysisHostImpl {\n     pub fn apply_change(&mut self, change: AnalysisChange) {\n         log::info!(\"apply_change {:?}\", change);\n         // self.gc_syntax_trees();\n-\n-        for (file_id, text) in change.files_changed {\n-            self.db\n-                .query_mut(ra_db::FileTextQuery)\n-                .set(file_id, Arc::new(text))\n-        }\n-        if !(change.files_added.is_empty() && change.files_removed.is_empty()) {\n-            let file_resolver = change\n-                .file_resolver\n-                .expect(\"change resolver when changing set of files\");\n-            let mut source_root = SourceRoot::clone(&self.db.source_root(WORKSPACE));\n-            for (file_id, text) in change.files_added {\n+        if !change.new_roots.is_empty() {\n+            let mut local_roots = Vec::clone(&self.db.local_roots());\n+            for (root_id, is_local) in change.new_roots {\n                 self.db\n-                    .query_mut(ra_db::FileTextQuery)\n-                    .set(file_id, Arc::new(text));\n-                self.db\n-                    .query_mut(ra_db::FileSourceRootQuery)\n-                    .set(file_id, ra_db::WORKSPACE);\n-                source_root.files.insert(file_id);\n-            }\n-            for file_id in change.files_removed {\n-                self.db\n-                    .query_mut(ra_db::FileTextQuery)\n-                    .set(file_id, Arc::new(String::new()));\n-                source_root.files.remove(&file_id);\n+                    .query_mut(ra_db::SourceRootQuery)\n+                    .set(root_id, Default::default());\n+                if is_local {\n+                    local_roots.push(root_id);\n+                }\n             }\n-            source_root.file_resolver = file_resolver;\n             self.db\n-                .query_mut(ra_db::SourceRootQuery)\n-                .set(WORKSPACE, Arc::new(source_root))\n+                .query_mut(ra_db::LocalRootsQuery)\n+                .set((), Arc::new(local_roots));\n+        }\n+\n+        for (root_id, root_change) in change.roots_changed {\n+            self.apply_root_change(root_id, root_change);\n+        }\n+        for (file_id, text) in change.files_changed {\n+            self.db.query_mut(ra_db::FileTextQuery).set(file_id, text)\n         }\n         if !change.libraries_added.is_empty() {\n-            let mut libraries = Vec::clone(&self.db.libraries());\n+            let mut libraries = Vec::clone(&self.db.library_roots());\n             for library in change.libraries_added {\n-                let source_root_id = SourceRootId(1 + libraries.len() as u32);\n-                libraries.push(source_root_id);\n-                let mut files = FxHashSet::default();\n-                for (file_id, text) in library.files {\n-                    files.insert(file_id);\n-                    log::debug!(\n-                        \"library file: {:?} {:?}\",\n-                        file_id,\n-                        library.file_resolver.debug_path(file_id)\n-                    );\n-                    self.db\n-                        .query_mut(ra_db::FileSourceRootQuery)\n-                        .set_constant(file_id, source_root_id);\n-                    self.db\n-                        .query_mut(ra_db::FileTextQuery)\n-                        .set_constant(file_id, Arc::new(text));\n-                }\n-                let source_root = SourceRoot {\n-                    files,\n-                    file_resolver: library.file_resolver,\n-                };\n+                libraries.push(library.root_id);\n                 self.db\n                     .query_mut(ra_db::SourceRootQuery)\n-                    .set(source_root_id, Arc::new(source_root));\n+                    .set(library.root_id, Default::default());\n                 self.db\n-                    .query_mut(crate::symbol_index::LibrarySymbolsQuery)\n-                    .set(source_root_id, Arc::new(library.symbol_index));\n+                    .query_mut(LibrarySymbolsQuery)\n+                    .set_constant(library.root_id, Arc::new(library.symbol_index));\n+                self.apply_root_change(library.root_id, library.root_change);\n             }\n             self.db\n-                .query_mut(ra_db::LibrariesQuery)\n+                .query_mut(ra_db::LibraryRootsQuery)\n                 .set((), Arc::new(libraries));\n         }\n         if let Some(crate_graph) = change.crate_graph {\n@@ -117,6 +87,34 @@ impl AnalysisHostImpl {\n         }\n     }\n \n+    fn apply_root_change(&mut self, root_id: SourceRootId, root_change: RootChange) {\n+        let mut source_root = SourceRoot::clone(&self.db.source_root(root_id));\n+        for add_file in root_change.added {\n+            self.db\n+                .query_mut(ra_db::FileTextQuery)\n+                .set(add_file.file_id, add_file.text);\n+            self.db\n+                .query_mut(ra_db::FileRelativePathQuery)\n+                .set(add_file.file_id, add_file.path.clone());\n+            self.db\n+                .query_mut(ra_db::FileSourceRootQuery)\n+                .set(add_file.file_id, root_id);\n+            source_root.files.insert(add_file.path, add_file.file_id);\n+        }\n+        for remove_file in root_change.removed {\n+            self.db\n+                .query_mut(ra_db::FileTextQuery)\n+                .set(remove_file.file_id, Default::default());\n+            self.db\n+                .query_mut(ra_db::FileRelativePathQuery)\n+                .set(remove_file.file_id, Default::default());\n+            source_root.files.remove(&remove_file.path);\n+        }\n+        self.db\n+            .query_mut(ra_db::SourceRootQuery)\n+            .set(root_id, Arc::new(source_root));\n+    }\n+\n     #[allow(unused)]\n     /// Ideally, we should call this function from time to time to collect heavy\n     /// syntax trees. However, if we actually do that, everything is recomputed\n@@ -156,21 +154,26 @@ impl AnalysisImpl {\n         self.db.file_lines(file_id)\n     }\n     pub fn world_symbols(&self, query: Query) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n+        /// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n+        struct Snap(salsa::Snapshot<db::RootDatabase>);\n+        impl Clone for Snap {\n+            fn clone(&self) -> Snap {\n+                Snap(self.0.snapshot())\n+            }\n+        }\n+\n         let buf: Vec<Arc<SymbolIndex>> = if query.libs {\n+            let snap = Snap(self.db.snapshot());\n             self.db\n-                .libraries()\n-                .iter()\n-                .map(|&lib_id| self.db.library_symbols(lib_id))\n+                .library_roots()\n+                .par_iter()\n+                .map_with(snap, |db, &lib_id| db.0.library_symbols(lib_id))\n                 .collect()\n         } else {\n-            let files = &self.db.source_root(WORKSPACE).files;\n-\n-            /// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n-            struct Snap(salsa::Snapshot<db::RootDatabase>);\n-            impl Clone for Snap {\n-                fn clone(&self) -> Snap {\n-                    Snap(self.0.snapshot())\n-                }\n+            let mut files = Vec::new();\n+            for &root in self.db.local_roots().iter() {\n+                let sr = self.db.source_root(root);\n+                files.extend(sr.files.values().map(|&it| it))\n             }\n \n             let snap = Snap(self.db.snapshot());"}, {"sha": "a1d462528d60c943f8392f6d6750ea7e279604b2", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 81, "deletions": 23, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -18,9 +18,9 @@ pub mod mock_analysis;\n \n use std::{fmt, sync::Arc};\n \n+use rustc_hash::FxHashMap;\n use ra_syntax::{SourceFileNode, TextRange, TextUnit};\n use ra_text_edit::AtomTextEdit;\n-use ra_db::FileResolverImp;\n use rayon::prelude::*;\n use relative_path::RelativePathBuf;\n \n@@ -39,28 +39,54 @@ pub use hir::FnSignatureInfo;\n \n pub use ra_db::{\n     Canceled, Cancelable, FilePosition,\n-    CrateGraph, CrateId, FileId, FileResolver\n+    CrateGraph, CrateId, SourceRootId, FileId\n };\n \n #[derive(Default)]\n pub struct AnalysisChange {\n-    files_added: Vec<(FileId, String)>,\n-    files_changed: Vec<(FileId, String)>,\n-    files_removed: Vec<(FileId)>,\n+    new_roots: Vec<(SourceRootId, bool)>,\n+    roots_changed: FxHashMap<SourceRootId, RootChange>,\n+    files_changed: Vec<(FileId, Arc<String>)>,\n     libraries_added: Vec<LibraryData>,\n     crate_graph: Option<CrateGraph>,\n-    file_resolver: Option<FileResolverImp>,\n+}\n+\n+#[derive(Default)]\n+struct RootChange {\n+    added: Vec<AddFile>,\n+    removed: Vec<RemoveFile>,\n+}\n+\n+#[derive(Debug)]\n+struct AddFile {\n+    file_id: FileId,\n+    path: RelativePathBuf,\n+    text: Arc<String>,\n+}\n+\n+#[derive(Debug)]\n+struct RemoveFile {\n+    file_id: FileId,\n+    path: RelativePathBuf,\n }\n \n impl fmt::Debug for AnalysisChange {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt.debug_struct(\"AnalysisChange\")\n-            .field(\"files_added\", &self.files_added.len())\n+            .field(\"new_roots\", &self.new_roots)\n+            .field(\"roots_changed\", &self.roots_changed)\n             .field(\"files_changed\", &self.files_changed.len())\n-            .field(\"files_removed\", &self.files_removed.len())\n             .field(\"libraries_added\", &self.libraries_added.len())\n             .field(\"crate_graph\", &self.crate_graph)\n-            .field(\"file_resolver\", &self.file_resolver)\n+            .finish()\n+    }\n+}\n+\n+impl fmt::Debug for RootChange {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt.debug_struct(\"AnalysisChange\")\n+            .field(\"added\", &self.added.len())\n+            .field(\"removed\", &self.removed.len())\n             .finish()\n     }\n }\n@@ -69,24 +95,44 @@ impl AnalysisChange {\n     pub fn new() -> AnalysisChange {\n         AnalysisChange::default()\n     }\n-    pub fn add_file(&mut self, file_id: FileId, text: String) {\n-        self.files_added.push((file_id, text))\n+    pub fn add_root(&mut self, root_id: SourceRootId, is_local: bool) {\n+        self.new_roots.push((root_id, is_local));\n     }\n-    pub fn change_file(&mut self, file_id: FileId, new_text: String) {\n+    pub fn add_file(\n+        &mut self,\n+        root_id: SourceRootId,\n+        file_id: FileId,\n+        path: RelativePathBuf,\n+        text: Arc<String>,\n+    ) {\n+        let file = AddFile {\n+            file_id,\n+            path,\n+            text,\n+        };\n+        self.roots_changed\n+            .entry(root_id)\n+            .or_default()\n+            .added\n+            .push(file);\n+    }\n+    pub fn change_file(&mut self, file_id: FileId, new_text: Arc<String>) {\n         self.files_changed.push((file_id, new_text))\n     }\n-    pub fn remove_file(&mut self, file_id: FileId) {\n-        self.files_removed.push(file_id)\n+    pub fn remove_file(&mut self, root_id: SourceRootId, file_id: FileId, path: RelativePathBuf) {\n+        let file = RemoveFile { file_id, path };\n+        self.roots_changed\n+            .entry(root_id)\n+            .or_default()\n+            .removed\n+            .push(file);\n     }\n     pub fn add_library(&mut self, data: LibraryData) {\n         self.libraries_added.push(data)\n     }\n     pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n         self.crate_graph = Some(graph);\n     }\n-    pub fn set_file_resolver(&mut self, file_resolver: Arc<FileResolver>) {\n-        self.file_resolver = Some(FileResolverImp::new(file_resolver));\n-    }\n }\n \n /// `AnalysisHost` stores the current state of the world.\n@@ -313,20 +359,32 @@ impl Analysis {\n \n #[derive(Debug)]\n pub struct LibraryData {\n-    files: Vec<(FileId, String)>,\n-    file_resolver: FileResolverImp,\n+    root_id: SourceRootId,\n+    root_change: RootChange,\n     symbol_index: SymbolIndex,\n }\n \n impl LibraryData {\n-    pub fn prepare(files: Vec<(FileId, String)>, file_resolver: Arc<FileResolver>) -> LibraryData {\n-        let symbol_index = SymbolIndex::for_files(files.par_iter().map(|(file_id, text)| {\n+    pub fn prepare(\n+        root_id: SourceRootId,\n+        files: Vec<(FileId, RelativePathBuf, Arc<String>)>,\n+    ) -> LibraryData {\n+        let symbol_index = SymbolIndex::for_files(files.par_iter().map(|(file_id, _, text)| {\n             let file = SourceFileNode::parse(text);\n             (*file_id, file)\n         }));\n+        let mut root_change = RootChange::default();\n+        root_change.added = files\n+            .into_iter()\n+            .map(|(file_id, path, text)| AddFile {\n+                file_id,\n+                path,\n+                text,\n+            })\n+            .collect();\n         LibraryData {\n-            files,\n-            file_resolver: FileResolverImp::new(file_resolver),\n+            root_id,\n+            root_change,\n             symbol_index,\n         }\n     }"}, {"sha": "7cbdfb9530f09698d2e193f48f16ce2600f7ba53", "filename": "crates/ra_analysis/src/mock_analysis.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -4,7 +4,7 @@ use relative_path::{RelativePathBuf};\n use test_utils::{extract_offset, parse_fixture, CURSOR_MARKER};\n use ra_db::mock::FileMap;\n \n-use crate::{Analysis, AnalysisChange, AnalysisHost, FileId, FilePosition};\n+use crate::{Analysis, AnalysisChange, AnalysisHost, FileId, FilePosition, SourceRootId};\n \n /// Mock analysis is used in test to bootstrap an AnalysisHost/Analysis\n /// from a set of in-memory files.\n@@ -78,14 +78,16 @@ impl MockAnalysis {\n     pub fn analysis_host(self) -> AnalysisHost {\n         let mut host = AnalysisHost::default();\n         let mut file_map = FileMap::default();\n+        let source_root = SourceRootId(0);\n         let mut change = AnalysisChange::new();\n+        change.add_root(source_root, true);\n         for (path, contents) in self.files.into_iter() {\n             assert!(path.starts_with('/'));\n             let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n-            let file_id = file_map.add(path);\n-            change.add_file(file_id, contents);\n+            let file_id = file_map.add(path.clone());\n+            change.add_file(source_root, file_id, path, Arc::new(contents));\n         }\n-        change.set_file_resolver(Arc::new(file_map));\n+        // change.set_file_resolver(Arc::new(file_map));\n         host.apply_change(change);\n         host\n     }"}, {"sha": "f849ac75214c81d23eff6dd0bfc748358bdaabd1", "filename": "crates/ra_db/src/file_resolver.rs", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/dbb62b5baa36783bbca06f09c77794fce3ceff0c/crates%2Fra_db%2Fsrc%2Ffile_resolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb62b5baa36783bbca06f09c77794fce3ceff0c/crates%2Fra_db%2Fsrc%2Ffile_resolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffile_resolver.rs?ref=dbb62b5baa36783bbca06f09c77794fce3ceff0c", "patch": "@@ -1,76 +0,0 @@\n-use std::{\n-    sync::Arc,\n-    hash::{Hash, Hasher},\n-    fmt,\n-};\n-\n-use relative_path::RelativePath;\n-\n-use crate::input::FileId;\n-\n-pub trait FileResolver: fmt::Debug + Send + Sync + 'static {\n-    fn file_stem(&self, file_id: FileId) -> String;\n-    fn resolve(&self, file_id: FileId, path: &RelativePath) -> Option<FileId>;\n-    fn debug_path(&self, _1file_id: FileId) -> Option<std::path::PathBuf> {\n-        None\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct FileResolverImp {\n-    inner: Arc<FileResolver>,\n-}\n-\n-impl PartialEq for FileResolverImp {\n-    fn eq(&self, other: &FileResolverImp) -> bool {\n-        self.inner() == other.inner()\n-    }\n-}\n-\n-impl Eq for FileResolverImp {}\n-\n-impl Hash for FileResolverImp {\n-    fn hash<H: Hasher>(&self, hasher: &mut H) {\n-        self.inner().hash(hasher);\n-    }\n-}\n-\n-impl FileResolverImp {\n-    pub fn new(inner: Arc<FileResolver>) -> FileResolverImp {\n-        FileResolverImp { inner }\n-    }\n-    pub fn file_stem(&self, file_id: FileId) -> String {\n-        self.inner.file_stem(file_id)\n-    }\n-    pub fn resolve(&self, file_id: FileId, path: &RelativePath) -> Option<FileId> {\n-        self.inner.resolve(file_id, path)\n-    }\n-    pub fn debug_path(&self, file_id: FileId) -> Option<std::path::PathBuf> {\n-        self.inner.debug_path(file_id)\n-    }\n-    fn inner(&self) -> *const FileResolver {\n-        &*self.inner\n-    }\n-}\n-\n-impl Default for FileResolverImp {\n-    fn default() -> FileResolverImp {\n-        #[derive(Debug)]\n-        struct DummyResolver;\n-        impl FileResolver for DummyResolver {\n-            fn file_stem(&self, _file_: FileId) -> String {\n-                panic!(\"file resolver not set\")\n-            }\n-            fn resolve(\n-                &self,\n-                _file_id: FileId,\n-                _path: &::relative_path::RelativePath,\n-            ) -> Option<FileId> {\n-                panic!(\"file resolver not set\")\n-            }\n-        }\n-        FileResolverImp {\n-            inner: Arc::new(DummyResolver),\n-        }\n-    }\n-}"}, {"sha": "cccf37cc28c434318b1c9348e9e957c614ef1172", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -1,10 +1,12 @@\n use std::sync::Arc;\n \n-use rustc_hash::{FxHashSet, FxHashMap};\n+use rustc_hash::{FxHashMap};\n+use relative_path::RelativePathBuf;\n use ra_syntax::SmolStr;\n use salsa;\n \n-use crate::file_resolver::FileResolverImp;\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct SourceRootId(pub u32);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct FileId(pub u32);\n@@ -85,6 +87,11 @@ salsa::query_group! {\n             type FileTextQuery;\n             storage input;\n         }\n+        /// Path to a file, relative to the root of its source root.\n+        fn file_relative_path(file_id: FileId) -> RelativePathBuf {\n+            type FileRelativePathQuery;\n+            storage input;\n+        }\n         fn file_source_root(file_id: FileId) -> SourceRootId {\n             type FileSourceRootQuery;\n             storage input;\n@@ -93,8 +100,12 @@ salsa::query_group! {\n             type SourceRootQuery;\n             storage input;\n         }\n-        fn libraries() -> Arc<Vec<SourceRootId>> {\n-            type LibrariesQuery;\n+        fn local_roots() -> Arc<Vec<SourceRootId>> {\n+            type LocalRootsQuery;\n+            storage input;\n+        }\n+        fn library_roots() -> Arc<Vec<SourceRootId>> {\n+            type LibraryRootsQuery;\n             storage input;\n         }\n         fn crate_graph() -> Arc<CrateGraph> {\n@@ -104,13 +115,7 @@ salsa::query_group! {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub struct SourceRootId(pub u32);\n-\n #[derive(Default, Clone, Debug, PartialEq, Eq)]\n pub struct SourceRoot {\n-    pub file_resolver: FileResolverImp,\n-    pub files: FxHashSet<FileId>,\n+    pub files: FxHashMap<RelativePathBuf, FileId>,\n }\n-\n-pub const WORKSPACE: SourceRootId = SourceRootId(0);"}, {"sha": "65fa3cbfa43702308d4baddfa673df720d0627e4", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -1,6 +1,5 @@\n //! ra_db defines basic database traits. Concrete DB is defined by ra_analysis.\n mod syntax_ptr;\n-mod file_resolver;\n mod input;\n mod loc2id;\n pub mod mock;\n@@ -24,10 +23,10 @@ impl std::error::Error for Canceled {}\n \n pub use crate::{\n     syntax_ptr::LocalSyntaxPtr,\n-    file_resolver::{FileResolver, FileResolverImp},\n     input::{\n-        FilesDatabase, FileId, CrateId, SourceRoot, SourceRootId, CrateGraph, WORKSPACE,\n-        FileTextQuery, FileSourceRootQuery, SourceRootQuery, LibrariesQuery, CrateGraphQuery,\n+        FilesDatabase, FileId, CrateId, SourceRoot, SourceRootId, CrateGraph,\n+        FileTextQuery, FileSourceRootQuery, SourceRootQuery, LocalRootsQuery, LibraryRootsQuery, CrateGraphQuery,\n+        FileRelativePathQuery\n     },\n     loc2id::{LocationIntener, NumericId},\n };"}, {"sha": "5e185062b450e53d03c9969bb374958cd97ed7ac", "filename": "crates/ra_db/src/mock.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_db%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_db%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Fmock.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -1,9 +1,7 @@\n-use std::sync::Arc;\n-\n use rustc_hash::FxHashSet;\n use relative_path::{RelativePath, RelativePathBuf};\n \n-use crate::{FileId, FileResolver, SourceRoot, FileResolverImp};\n+use crate::{FileId};\n \n #[derive(Default, Debug, Clone)]\n pub struct FileMap(Vec<(FileId, RelativePathBuf)>);\n@@ -15,15 +13,6 @@ impl FileMap {\n         file_id\n     }\n \n-    pub fn into_source_root(self) -> SourceRoot {\n-        let files = self.files();\n-        let file_resolver = FileResolverImp::new(Arc::new(self));\n-        SourceRoot {\n-            file_resolver,\n-            files,\n-        }\n-    }\n-\n     pub fn files(&self) -> FxHashSet<FileId> {\n         self.iter().map(|(id, _)| id).collect()\n     }\n@@ -38,19 +27,4 @@ impl FileMap {\n             .iter()\n             .map(|(id, path)| (*id, path.as_relative_path()))\n     }\n-\n-    fn path(&self, id: FileId) -> &RelativePath {\n-        self.iter().find(|&(it, _)| it == id).unwrap().1\n-    }\n-}\n-\n-impl FileResolver for FileMap {\n-    fn file_stem(&self, id: FileId) -> String {\n-        self.path(id).file_stem().unwrap().to_string()\n-    }\n-    fn resolve(&self, id: FileId, rel: &RelativePath) -> Option<FileId> {\n-        let path = self.path(id).join(rel).normalize();\n-        let id = self.iter().find(|&(_, p)| path == p)?.0;\n-        Some(id)\n-    }\n }"}, {"sha": "61650cee9dde17d1119863132e5a4fb25c7dead0", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -5,6 +5,7 @@ version = \"0.1.0\"\n authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n \n [dependencies]\n+arrayvec = \"0.4.9\"\n log = \"0.4.5\"\n relative-path = \"0.4.0\"\n salsa = \"0.8.0\""}, {"sha": "9423e6571403c613253a315df32d67881237c2d4", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -2,12 +2,14 @@ use std::sync::Arc;\n \n use parking_lot::Mutex;\n use salsa::{self, Database};\n-use ra_db::{LocationIntener, BaseDatabase, FilePosition, mock::FileMap, FileId, WORKSPACE, CrateGraph};\n+use ra_db::{LocationIntener, BaseDatabase, FilePosition, FileId, CrateGraph, SourceRoot, SourceRootId};\n use relative_path::RelativePathBuf;\n use test_utils::{parse_fixture, CURSOR_MARKER, extract_offset};\n \n use crate::{db, DefId, DefLoc};\n \n+const WORKSPACE: SourceRootId = SourceRootId(0);\n+\n #[derive(Debug)]\n pub(crate) struct MockDatabase {\n     events: Mutex<Option<Vec<salsa::Event<MockDatabase>>>>,\n@@ -16,10 +18,10 @@ pub(crate) struct MockDatabase {\n }\n \n impl MockDatabase {\n-    pub(crate) fn with_files(fixture: &str) -> (MockDatabase, FileMap) {\n-        let (db, file_map, position) = MockDatabase::from_fixture(fixture);\n+    pub(crate) fn with_files(fixture: &str) -> (MockDatabase, SourceRoot) {\n+        let (db, source_root, position) = MockDatabase::from_fixture(fixture);\n         assert!(position.is_none());\n-        (db, file_map)\n+        (db, source_root)\n     }\n \n     pub(crate) fn with_position(fixture: &str) -> (MockDatabase, FilePosition) {\n@@ -33,48 +35,50 @@ impl MockDatabase {\n             .set((), Arc::new(crate_graph));\n     }\n \n-    fn from_fixture(fixture: &str) -> (MockDatabase, FileMap, Option<FilePosition>) {\n+    fn from_fixture(fixture: &str) -> (MockDatabase, SourceRoot, Option<FilePosition>) {\n         let mut db = MockDatabase::default();\n \n         let mut position = None;\n-        let mut file_map = FileMap::default();\n+        let mut source_root = SourceRoot::default();\n         for entry in parse_fixture(fixture) {\n             if entry.text.contains(CURSOR_MARKER) {\n                 assert!(\n                     position.is_none(),\n                     \"only one marker (<|>) per fixture is allowed\"\n                 );\n-                position = Some(db.add_file_with_position(&mut file_map, &entry.meta, &entry.text));\n+                position =\n+                    Some(db.add_file_with_position(&mut source_root, &entry.meta, &entry.text));\n             } else {\n-                db.add_file(&mut file_map, &entry.meta, &entry.text);\n+                db.add_file(&mut source_root, &entry.meta, &entry.text);\n             }\n         }\n-        let source_root = file_map.clone().into_source_root();\n         db.query_mut(ra_db::SourceRootQuery)\n-            .set(WORKSPACE, Arc::new(source_root));\n-        (db, file_map, position)\n+            .set(WORKSPACE, Arc::new(source_root.clone()));\n+        (db, source_root, position)\n     }\n \n-    fn add_file(&mut self, file_map: &mut FileMap, path: &str, text: &str) -> FileId {\n+    fn add_file(&mut self, source_root: &mut SourceRoot, path: &str, text: &str) -> FileId {\n         assert!(path.starts_with('/'));\n         let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n-\n-        let file_id = file_map.add(path);\n+        let file_id = FileId(source_root.files.len() as u32);\n         let text = Arc::new(text.to_string());\n         self.query_mut(ra_db::FileTextQuery).set(file_id, text);\n+        self.query_mut(ra_db::FileRelativePathQuery)\n+            .set(file_id, path.clone());\n         self.query_mut(ra_db::FileSourceRootQuery)\n             .set(file_id, WORKSPACE);\n+        source_root.files.insert(path, file_id);\n         file_id\n     }\n \n     fn add_file_with_position(\n         &mut self,\n-        file_map: &mut FileMap,\n+        source_root: &mut SourceRoot,\n         path: &str,\n         text: &str,\n     ) -> FilePosition {\n         let (offset, text) = extract_offset(text);\n-        let file_id = self.add_file(file_map, path, &text);\n+        let file_id = self.add_file(source_root, path, &text);\n         FilePosition { file_id, offset }\n     }\n }\n@@ -104,11 +108,11 @@ impl Default for MockDatabase {\n             runtime: salsa::Runtime::default(),\n             id_maps: Default::default(),\n         };\n-        db.query_mut(ra_db::SourceRootQuery)\n-            .set(ra_db::WORKSPACE, Default::default());\n         db.query_mut(ra_db::CrateGraphQuery)\n             .set((), Default::default());\n-        db.query_mut(ra_db::LibrariesQuery)\n+        db.query_mut(ra_db::LocalRootsQuery)\n+            .set((), Default::default());\n+        db.query_mut(ra_db::LibraryRootsQuery)\n             .set((), Default::default());\n         db\n     }\n@@ -158,9 +162,11 @@ salsa::database_storage! {\n     pub(crate) struct MockDatabaseStorage for MockDatabase {\n         impl ra_db::FilesDatabase {\n             fn file_text() for ra_db::FileTextQuery;\n+            fn file_relative_path() for ra_db::FileRelativePathQuery;\n             fn file_source_root() for ra_db::FileSourceRootQuery;\n             fn source_root() for ra_db::SourceRootQuery;\n-            fn libraries() for ra_db::LibrariesQuery;\n+            fn local_roots() for ra_db::LocalRootsQuery;\n+            fn library_roots() for ra_db::LibraryRootsQuery;\n             fn crate_graph() for ra_db::CrateGraphQuery;\n         }\n         impl ra_db::SyntaxDatabase {"}, {"sha": "f3a346152b9d783b5bd6b3c67a6d3a5aa8971665", "filename": "crates/ra_hir/src/module/imp.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -4,9 +4,10 @@ use ra_syntax::{\n     ast::{self, NameOwner},\n     SmolStr,\n };\n-use relative_path::RelativePathBuf;\n+use relative_path::{RelativePathBuf, RelativePath};\n use rustc_hash::{FxHashMap, FxHashSet};\n-use ra_db::{SourceRoot, SourceRootId, FileResolverImp, Cancelable, FileId,};\n+use arrayvec::ArrayVec;\n+use ra_db::{SourceRoot, SourceRootId, Cancelable, FileId};\n \n use crate::{\n     HirDatabase,\n@@ -65,7 +66,7 @@ fn create_module_tree<'a>(\n     let mut visited = FxHashSet::default();\n \n     let source_root = db.source_root(source_root);\n-    for &file_id in source_root.files.iter() {\n+    for &file_id in source_root.files.values() {\n         let source = ModuleSource::new_file(file_id);\n         if visited.contains(&source) {\n             continue; // TODO: use explicit crate_roots here\n@@ -110,8 +111,7 @@ fn build_subtree(\n \n         let (points_to, problem) = match sub {\n             Submodule::Declaration(name) => {\n-                let (points_to, problem) =\n-                    resolve_submodule(source, &name, &source_root.file_resolver);\n+                let (points_to, problem) = resolve_submodule(db, source, &name);\n                 let points_to = points_to\n                     .into_iter()\n                     .map(|file_id| match roots.remove(&file_id) {\n@@ -153,34 +153,42 @@ fn build_subtree(\n }\n \n fn resolve_submodule(\n+    db: &impl HirDatabase,\n     source: ModuleSource,\n     name: &SmolStr,\n-    file_resolver: &FileResolverImp,\n ) -> (Vec<FileId>, Option<Problem>) {\n-    // TODO: handle submodules of inline modules properly\n+    // FIXME: handle submodules of inline modules properly\n     let file_id = source.file_id();\n-    let mod_name = file_resolver.file_stem(file_id);\n+    let source_root_id = db.file_source_root(file_id);\n+    let path = db.file_relative_path(file_id);\n+    let root = RelativePathBuf::default();\n+    let dir_path = path.parent().unwrap_or(&root);\n+    let mod_name = path.file_stem().unwrap_or(\"unknown\");\n     let is_dir_owner = mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n \n-    let file_mod = RelativePathBuf::from(format!(\"../{}.rs\", name));\n-    let dir_mod = RelativePathBuf::from(format!(\"../{}/mod.rs\", name));\n-    let file_dir_mod = RelativePathBuf::from(format!(\"../{}/{}.rs\", mod_name, name));\n-    let tmp1;\n-    let tmp2;\n-    let candidates = if is_dir_owner {\n-        tmp1 = [&file_mod, &dir_mod];\n-        tmp1.iter()\n+    let file_mod = dir_path.join(format!(\"{}.rs\", name));\n+    let dir_mod = dir_path.join(format!(\"{}/mod.rs\", name));\n+    let file_dir_mod = dir_path.join(format!(\"{}/{}.rs\", mod_name, name));\n+    let mut candidates = ArrayVec::<[_; 2]>::new();\n+    if is_dir_owner {\n+        candidates.push(file_mod.clone());\n+        candidates.push(dir_mod);\n     } else {\n-        tmp2 = [&file_dir_mod];\n-        tmp2.iter()\n+        candidates.push(file_dir_mod.clone());\n     };\n-\n+    let sr = db.source_root(source_root_id);\n     let points_to = candidates\n-        .filter_map(|path| file_resolver.resolve(file_id, path))\n+        .into_iter()\n+        .filter_map(|path| sr.files.get(&path))\n+        .map(|&it| it)\n         .collect::<Vec<_>>();\n     let problem = if points_to.is_empty() {\n         Some(Problem::UnresolvedModule {\n-            candidate: if is_dir_owner { file_mod } else { file_dir_mod },\n+            candidate: RelativePath::new(\"../\").join(&if is_dir_owner {\n+                file_mod\n+            } else {\n+                file_dir_mod\n+            }),\n         })\n     } else {\n         None"}, {"sha": "f44abc73062f1ef799768b864c8d03afae212635", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -32,11 +32,12 @@ use crate::{\n     SourceItemId, SourceFileItemId, SourceFileItems,\n     Path, PathKind,\n     HirDatabase, Crate,\n-    module::{ModuleId, ModuleTree},\n+    module::{Module, ModuleId, ModuleTree},\n };\n \n /// Item map is the result of the name resolution. Item map contains, for each\n /// module, the set of visible items.\n+// FIXME: currenty we compute item map per source-root. We should do it per crate instead.\n #[derive(Default, Debug, PartialEq, Eq)]\n pub struct ItemMap {\n     pub per_module: FxHashMap<ModuleId, ModuleScope>,\n@@ -252,7 +253,8 @@ where\n                 let krate = Crate::new(crate_id);\n                 for dep in krate.dependencies(self.db) {\n                     if let Some(module) = dep.krate.root_module(self.db)? {\n-                        self.add_module_item(&mut module_items, dep.name, module.module_id);\n+                        let def_id = module.def_id(self.db);\n+                        self.add_module_item(&mut module_items, dep.name, def_id);\n                     }\n                 }\n             };\n@@ -294,21 +296,21 @@ where\n \n         // Populate modules\n         for (name, module_id) in module_id.children(&self.module_tree) {\n-            self.add_module_item(&mut module_items, name, module_id);\n+            let def_loc = DefLoc {\n+                kind: DefKind::Module,\n+                source_root_id: self.source_root,\n+                module_id,\n+                source_item_id: module_id.source(&self.module_tree).0,\n+            };\n+            let def_id = def_loc.id(self.db);\n+            self.add_module_item(&mut module_items, name, def_id);\n         }\n \n         self.result.per_module.insert(module_id, module_items);\n         Ok(())\n     }\n \n-    fn add_module_item(&self, module_items: &mut ModuleScope, name: SmolStr, module_id: ModuleId) {\n-        let def_loc = DefLoc {\n-            kind: DefKind::Module,\n-            source_root_id: self.source_root,\n-            module_id,\n-            source_item_id: module_id.source(&self.module_tree).0,\n-        };\n-        let def_id = def_loc.id(self.db);\n+    fn add_module_item(&self, module_items: &mut ModuleScope, name: SmolStr, def_id: DefId) {\n         let resolution = Resolution {\n             def_id: Some(def_id),\n             import: None,\n@@ -329,7 +331,7 @@ where\n             ImportKind::Named(ptr) => ptr,\n         };\n \n-        let mut curr = match import.path.kind {\n+        let mut curr: ModuleId = match import.path.kind {\n             PathKind::Plain | PathKind::Self_ => module_id,\n             PathKind::Super => {\n                 match module_id.parent(&self.module_tree) {\n@@ -356,9 +358,30 @@ where\n                 curr = match def_id.loc(self.db) {\n                     DefLoc {\n                         kind: DefKind::Module,\n-                        module_id,\n+                        module_id: target_module_id,\n+                        source_root_id,\n                         ..\n-                    } => module_id,\n+                    } => {\n+                        if source_root_id == self.source_root {\n+                            target_module_id\n+                        } else {\n+                            let module = Module::new(self.db, source_root_id, target_module_id)?;\n+                            let path = Path {\n+                                segments: import.path.segments[i + 1..].iter().cloned().collect(),\n+                                kind: PathKind::Crate,\n+                            };\n+                            if let Some(def_id) = module.resolve_path(self.db, path)? {\n+                                self.update(module_id, |items| {\n+                                    let res = Resolution {\n+                                        def_id: Some(def_id),\n+                                        import: Some(ptr),\n+                                    };\n+                                    items.items.insert(name.clone(), res);\n+                                })\n+                            }\n+                            return Ok(());\n+                        }\n+                    }\n                     _ => return Ok(()),\n                 }\n             } else {"}, {"sha": "9fa9146e3c59b2859063f0dd6f25157fa1a24f69", "filename": "crates/ra_hir/src/module/nameres/tests.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -3,6 +3,7 @@ use std::sync::Arc;\n use salsa::Database;\n use ra_db::{FilesDatabase, CrateGraph};\n use ra_syntax::SmolStr;\n+use relative_path::RelativePath;\n \n use crate::{\n     self as hir,\n@@ -44,7 +45,7 @@ fn item_map_smoke_test() {\n \n #[test]\n fn item_map_across_crates() {\n-    let (mut db, files) = MockDatabase::with_files(\n+    let (mut db, sr) = MockDatabase::with_files(\n         \"\n         //- /main.rs\n         use test_crate::Baz;\n@@ -53,8 +54,8 @@ fn item_map_across_crates() {\n         pub struct Baz;\n     \",\n     );\n-    let main_id = files.file_id(\"/main.rs\");\n-    let lib_id = files.file_id(\"/lib.rs\");\n+    let main_id = sr.files[RelativePath::new(\"/main.rs\")];\n+    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n \n     let mut crate_graph = CrateGraph::default();\n     let main_crate = crate_graph.add_crate_root(main_id);"}, {"sha": "fc10096e5a177484eec37b74d4f9a45ec80f58ec", "filename": "crates/ra_lsp_server/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2FCargo.toml?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -19,19 +19,21 @@ flexi_logger = \"0.10.0\"\n log = \"0.4.3\"\n url_serde = \"0.2.0\"\n languageserver-types = \"0.53.0\"\n-walkdir = \"2.2.0\"\n+walkdir = \"2.2.7\"\n im = \"12.0.0\"\n cargo_metadata = \"0.6.0\"\n text_unit = { version = \"0.1.2\", features = [\"serde\"] }\n smol_str = { version = \"0.1.5\", features = [\"serde\"] }\n rustc-hash = \"1.0\"\n+parking_lot = \"0.7.0\"\n \n thread_worker = { path = \"../thread_worker\" }\n ra_syntax = { path = \"../ra_syntax\" }\n ra_editor = { path = \"../ra_editor\" }\n ra_text_edit = { path = \"../ra_text_edit\" }\n ra_analysis = { path = \"../ra_analysis\" }\n gen_lsp_server = { path = \"../gen_lsp_server\" }\n+ra_vfs = { path = \"../ra_vfs\" }\n \n [dev-dependencies]\n tempdir = \"0.3.7\""}, {"sha": "725b1258a97ddda2fa75cb52b365d2c6d3410d35", "filename": "crates/ra_lsp_server/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Flib.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -1,11 +1,9 @@\n mod caps;\n mod conv;\n mod main_loop;\n-mod path_map;\n mod project_model;\n pub mod req;\n mod server_world;\n-mod vfs;\n \n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n pub use crate::{caps::server_capabilities, main_loop::main_loop, main_loop::LspError};"}, {"sha": "d2f16ea975e1db04bd8fed16300ba2a8cd6474ad", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 58, "deletions": 89, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -1,16 +1,19 @@\n mod handlers;\n mod subscriptions;\n \n-use std::path::PathBuf;\n+use std::{\n+    path::PathBuf,\n+    sync::Arc,\n+};\n \n use crossbeam_channel::{unbounded, select, Receiver, Sender};\n use gen_lsp_server::{\n     handle_shutdown, ErrorCode, RawMessage, RawNotification, RawRequest, RawResponse,\n };\n use languageserver_types::NumberOrString;\n use ra_analysis::{Canceled, FileId, LibraryData};\n+use ra_vfs::{VfsTask};\n use rayon;\n-use thread_worker::Worker;\n use threadpool::ThreadPool;\n use rustc_hash::FxHashSet;\n use serde::{de::DeserializeOwned, Serialize};\n@@ -19,10 +22,9 @@ use failure_derive::Fail;\n \n use crate::{\n     main_loop::subscriptions::Subscriptions,\n-    project_model::{workspace_loader, CargoWorkspace},\n+    project_model::{workspace_loader},\n     req,\n     server_world::{ServerWorld, ServerWorldState},\n-    vfs::{self, FileEvent},\n     Result,\n };\n \n@@ -50,32 +52,42 @@ enum Task {\n \n pub fn main_loop(\n     internal_mode: bool,\n-    root: PathBuf,\n+    ws_root: PathBuf,\n     publish_decorations: bool,\n     msg_receiver: &Receiver<RawMessage>,\n     msg_sender: &Sender<RawMessage>,\n ) -> Result<()> {\n     let pool = ThreadPool::new(8);\n     let (task_sender, task_receiver) = unbounded::<Task>();\n-    let (fs_worker, fs_watcher) = vfs::roots_loader();\n     let (ws_worker, ws_watcher) = workspace_loader();\n \n+    ws_worker.send(ws_root.clone());\n+    // FIXME: support dynamic workspace loading.\n+    let workspaces = match ws_worker.recv().unwrap() {\n+        Ok(ws) => vec![ws],\n+        Err(e) => {\n+            log::warn!(\"loading workspace failed: {}\", e);\n+            Vec::new()\n+        }\n+    };\n+    ws_worker.shutdown();\n+    ws_watcher\n+        .shutdown()\n+        .map_err(|_| format_err!(\"ws watcher died\"))?;\n+    let mut state = ServerWorldState::new(ws_root.clone(), workspaces);\n+\n     log::info!(\"server initialized, serving requests\");\n-    let mut state = ServerWorldState::default();\n \n     let mut pending_requests = FxHashSet::default();\n     let mut subs = Subscriptions::new();\n     let main_res = main_loop_inner(\n         internal_mode,\n         publish_decorations,\n-        root,\n         &pool,\n         msg_sender,\n         msg_receiver,\n         task_sender,\n         task_receiver.clone(),\n-        fs_worker,\n-        ws_worker,\n         &mut state,\n         &mut pending_requests,\n         &mut subs,\n@@ -88,41 +100,34 @@ pub fn main_loop(\n     drop(pool);\n     log::info!(\"...threadpool has finished\");\n \n-    let fs_res = fs_watcher.stop();\n-    let ws_res = ws_watcher.stop();\n+    let vfs = Arc::try_unwrap(state.vfs).expect(\"all snapshots should be dead\");\n+    let vfs_res = vfs.into_inner().shutdown();\n \n     main_res?;\n-    fs_res.map_err(|_| format_err!(\"fs watcher died\"))?;\n-    ws_res.map_err(|_| format_err!(\"ws watcher died\"))?;\n+    vfs_res.map_err(|_| format_err!(\"fs watcher died\"))?;\n \n     Ok(())\n }\n \n fn main_loop_inner(\n     internal_mode: bool,\n     publish_decorations: bool,\n-    ws_root: PathBuf,\n     pool: &ThreadPool,\n     msg_sender: &Sender<RawMessage>,\n     msg_receiver: &Receiver<RawMessage>,\n     task_sender: Sender<Task>,\n     task_receiver: Receiver<Task>,\n-    fs_worker: Worker<PathBuf, (PathBuf, Vec<FileEvent>)>,\n-    ws_worker: Worker<PathBuf, Result<CargoWorkspace>>,\n     state: &mut ServerWorldState,\n     pending_requests: &mut FxHashSet<u64>,\n     subs: &mut Subscriptions,\n ) -> Result<()> {\n     let (libdata_sender, libdata_receiver) = unbounded();\n-    ws_worker.send(ws_root.clone());\n-    fs_worker.send(ws_root.clone());\n     loop {\n         #[derive(Debug)]\n         enum Event {\n             Msg(RawMessage),\n             Task(Task),\n-            Fs(PathBuf, Vec<FileEvent>),\n-            Ws(Result<CargoWorkspace>),\n+            Vfs(VfsTask),\n             Lib(LibraryData),\n         }\n         log::trace!(\"selecting\");\n@@ -132,77 +137,20 @@ fn main_loop_inner(\n                 None => bail!(\"client exited without shutdown\"),\n             },\n             recv(task_receiver, task) => Event::Task(task.unwrap()),\n-            recv(fs_worker.out, events) => match events {\n-                None => bail!(\"roots watcher died\"),\n-                Some((pb, events)) => Event::Fs(pb, events),\n-            }\n-            recv(ws_worker.out, ws) => match ws {\n-                None => bail!(\"workspace watcher died\"),\n-                Some(ws) => Event::Ws(ws),\n+            recv(state.vfs.read().task_receiver(), task) => match task {\n+                None => bail!(\"vfs died\"),\n+                Some(task) => Event::Vfs(task),\n             }\n             recv(libdata_receiver, data) => Event::Lib(data.unwrap())\n         };\n+        log::info!(\"{:?}\", event);\n         let mut state_changed = false;\n         match event {\n             Event::Task(task) => on_task(task, msg_sender, pending_requests),\n-            Event::Fs(root, events) => {\n-                log::info!(\"fs change, {}, {} events\", root.display(), events.len());\n-                if root == ws_root {\n-                    state.apply_fs_changes(events);\n-                } else {\n-                    let (files, resolver) = state.events_to_files(events);\n-                    let sender = libdata_sender.clone();\n-                    pool.execute(move || {\n-                        let start = ::std::time::Instant::now();\n-                        log::info!(\"indexing {} ... \", root.display());\n-                        let data = LibraryData::prepare(files, resolver);\n-                        log::info!(\"indexed {:?} {}\", start.elapsed(), root.display());\n-                        sender.send(data);\n-                    });\n-                }\n+            Event::Vfs(task) => {\n+                state.vfs.write().handle_task(task);\n                 state_changed = true;\n             }\n-            Event::Ws(ws) => match ws {\n-                Ok(ws) => {\n-                    let workspaces = vec![ws];\n-                    feedback(internal_mode, \"workspace loaded\", msg_sender);\n-                    for ws in workspaces.iter() {\n-                        // Add each library as constant input. If library is\n-                        // within the workspace, don't treat it as a library.\n-                        //\n-                        // HACK: If source roots are nested, pick the outer one.\n-\n-                        let mut roots = ws\n-                            .packages()\n-                            .filter(|pkg| !pkg.is_member(ws))\n-                            .filter_map(|pkg| {\n-                                let root = pkg.root(ws).to_path_buf();\n-                                if root.starts_with(&ws_root) {\n-                                    None\n-                                } else {\n-                                    Some(root)\n-                                }\n-                            })\n-                            .collect::<Vec<_>>();\n-                        roots.sort_by_key(|it| it.as_os_str().len());\n-                        let unique = roots\n-                            .iter()\n-                            .enumerate()\n-                            .filter(|&(idx, long)| {\n-                                !roots[..idx].iter().any(|short| long.starts_with(short))\n-                            })\n-                            .map(|(_idx, root)| root);\n-\n-                        for root in unique {\n-                            log::debug!(\"sending root, {}\", root.display());\n-                            fs_worker.send(root.to_owned());\n-                        }\n-                    }\n-                    state.set_workspaces(workspaces);\n-                    state_changed = true;\n-                }\n-                Err(e) => log::warn!(\"loading workspace failed: {}\", e),\n-            },\n             Event::Lib(lib) => {\n                 feedback(internal_mode, \"library loaded\", msg_sender);\n                 state.add_lib(lib);\n@@ -234,6 +182,21 @@ fn main_loop_inner(\n             },\n         };\n \n+        for lib in state.process_changes() {\n+            let (root, files) = lib;\n+            let sender = libdata_sender.clone();\n+            pool.execute(move || {\n+                let start = ::std::time::Instant::now();\n+                log::info!(\"indexing {:?} ... \", root);\n+                let data = LibraryData::prepare(root, files);\n+                log::info!(\"indexed {:?} {:?}\", start.elapsed(), root);\n+                sender.send(data);\n+            });\n+        }\n+        if state.roots_to_scan == 0 {\n+            feedback(internal_mode, \"workspace loaded\", msg_sender);\n+        }\n+\n         if state_changed {\n             update_file_notifications_on_threadpool(\n                 pool,\n@@ -336,8 +299,13 @@ fn on_notification(\n             let path = uri\n                 .to_file_path()\n                 .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n-            let file_id = state.add_mem_file(path, params.text_document.text);\n-            subs.add_sub(file_id);\n+            if let Some(file_id) = state\n+                .vfs\n+                .write()\n+                .add_file_overlay(&path, params.text_document.text)\n+            {\n+                subs.add_sub(FileId(file_id.0));\n+            }\n             return Ok(());\n         }\n         Err(not) => not,\n@@ -353,7 +321,7 @@ fn on_notification(\n                 .pop()\n                 .ok_or_else(|| format_err!(\"empty changes\"))?\n                 .text;\n-            state.change_mem_file(path.as_path(), text)?;\n+            state.vfs.write().change_file_overlay(path.as_path(), text);\n             return Ok(());\n         }\n         Err(not) => not,\n@@ -364,8 +332,9 @@ fn on_notification(\n             let path = uri\n                 .to_file_path()\n                 .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n-            let file_id = state.remove_mem_file(path.as_path())?;\n-            subs.remove_sub(file_id);\n+            if let Some(file_id) = state.vfs.write().remove_file_overlay(path.as_path()) {\n+                subs.remove_sub(FileId(file_id.0));\n+            }\n             let params = req::PublishDiagnosticsParams {\n                 uri,\n                 diagnostics: Vec::new(),"}, {"sha": "572ae7fb53992c1072ba0d866a56007e0e687ff3", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -326,9 +326,9 @@ pub fn handle_runnables(\n                 None => return Ok(None),\n             };\n             let file_id = world.analysis().crate_root(crate_id)?;\n-            let path = world.path_map.get_path(file_id);\n+            let path = world.vfs.read().file2path(ra_vfs::VfsFile(file_id.0));\n             let res = world.workspaces.iter().find_map(|ws| {\n-                let tgt = ws.target_by_root(path)?;\n+                let tgt = ws.target_by_root(&path)?;\n                 let res = CargoTargetSpec {\n                     package: tgt.package(ws).name(ws).to_string(),\n                     target: tgt.name(ws).to_string(),"}, {"sha": "02e54629c7d159f5e3d4fbc3c43a797d9e74a709", "filename": "crates/ra_lsp_server/src/path_map.rs", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/dbb62b5baa36783bbca06f09c77794fce3ceff0c/crates%2Fra_lsp_server%2Fsrc%2Fpath_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb62b5baa36783bbca06f09c77794fce3ceff0c/crates%2Fra_lsp_server%2Fsrc%2Fpath_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fpath_map.rs?ref=dbb62b5baa36783bbca06f09c77794fce3ceff0c", "patch": "@@ -1,126 +0,0 @@\n-use std::{\n-    fmt,\n-    path::{Component, Path, PathBuf},\n-};\n-\n-use im;\n-use ra_analysis::{FileId, FileResolver};\n-use relative_path::RelativePath;\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum Root {\n-    Workspace,\n-    Lib,\n-}\n-\n-#[derive(Default, Clone)]\n-pub struct PathMap {\n-    next_id: u32,\n-    path2id: im::HashMap<PathBuf, FileId>,\n-    id2path: im::HashMap<FileId, PathBuf>,\n-    id2root: im::HashMap<FileId, Root>,\n-}\n-\n-impl fmt::Debug for PathMap {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(\"PathMap { ... }\")\n-    }\n-}\n-\n-impl PathMap {\n-    pub fn get_or_insert(&mut self, path: PathBuf, root: Root) -> (bool, FileId) {\n-        let mut inserted = false;\n-        let file_id = self\n-            .path2id\n-            .get(path.as_path())\n-            .map(|&id| id)\n-            .unwrap_or_else(|| {\n-                inserted = true;\n-                let id = self.new_file_id();\n-                self.insert(path, id, root);\n-                id\n-            });\n-        (inserted, file_id)\n-    }\n-    pub fn get_id(&self, path: &Path) -> Option<FileId> {\n-        self.path2id.get(path).cloned()\n-    }\n-    pub fn get_path(&self, file_id: FileId) -> &Path {\n-        self.id2path.get(&file_id).unwrap().as_path()\n-    }\n-    pub fn get_root(&self, file_id: FileId) -> Root {\n-        self.id2root[&file_id]\n-    }\n-    fn insert(&mut self, path: PathBuf, file_id: FileId, root: Root) {\n-        self.path2id.insert(path.clone(), file_id);\n-        self.id2path.insert(file_id, path.clone());\n-        self.id2root.insert(file_id, root);\n-    }\n-\n-    fn new_file_id(&mut self) -> FileId {\n-        let id = FileId(self.next_id);\n-        self.next_id += 1;\n-        id\n-    }\n-}\n-\n-impl FileResolver for PathMap {\n-    fn file_stem(&self, file_id: FileId) -> String {\n-        self.get_path(file_id)\n-            .file_stem()\n-            .unwrap()\n-            .to_str()\n-            .unwrap()\n-            .to_string()\n-    }\n-\n-    fn resolve(&self, file_id: FileId, path: &RelativePath) -> Option<FileId> {\n-        let path = path.to_path(&self.get_path(file_id));\n-        let path = normalize(&path);\n-        self.get_id(&path)\n-    }\n-\n-    fn debug_path(&self, file_id: FileId) -> Option<PathBuf> {\n-        Some(self.get_path(file_id).to_owned())\n-    }\n-}\n-\n-fn normalize(path: &Path) -> PathBuf {\n-    let mut components = path.components().peekable();\n-    let mut ret = if let Some(c @ Component::Prefix(..)) = components.peek().cloned() {\n-        components.next();\n-        PathBuf::from(c.as_os_str())\n-    } else {\n-        PathBuf::new()\n-    };\n-\n-    for component in components {\n-        match component {\n-            Component::Prefix(..) => unreachable!(),\n-            Component::RootDir => {\n-                ret.push(component.as_os_str());\n-            }\n-            Component::CurDir => {}\n-            Component::ParentDir => {\n-                ret.pop();\n-            }\n-            Component::Normal(c) => {\n-                ret.push(c);\n-            }\n-        }\n-    }\n-    ret\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-\n-    #[test]\n-    fn test_resolve() {\n-        let mut m = PathMap::default();\n-        let (_, id1) = m.get_or_insert(PathBuf::from(\"/foo\"), Root::Workspace);\n-        let (_, id2) = m.get_or_insert(PathBuf::from(\"/foo/bar.rs\"), Root::Workspace);\n-        assert_eq!(m.resolve(id1, &RelativePath::new(\"bar.rs\")), Some(id2),)\n-    }\n-}"}, {"sha": "5852a157d198eb2bc645e6da8bd946842e45e4e8", "filename": "crates/ra_lsp_server/src/project_model.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -69,6 +69,7 @@ impl Package {\n     pub fn targets<'a>(self, ws: &'a CargoWorkspace) -> impl Iterator<Item = Target> + 'a {\n         ws.pkg(self).targets.iter().cloned()\n     }\n+    #[allow(unused)]\n     pub fn is_member(self, ws: &CargoWorkspace) -> bool {\n         ws.pkg(self).is_member\n     }"}, {"sha": "785877c4ba3a9806d0863fa710178fc45c778952", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 102, "deletions": 123, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -1,154 +1,66 @@\n use std::{\n-    fs,\n-    path::{Path, PathBuf},\n+    path::{PathBuf},\n     sync::Arc,\n };\n \n use languageserver_types::Url;\n use ra_analysis::{\n-    Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId, FileResolver, LibraryData,\n+    Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId, LibraryData,\n+    SourceRootId\n };\n+use ra_vfs::{Vfs, VfsChange, VfsFile};\n use rustc_hash::FxHashMap;\n-use failure::{bail, format_err};\n+use relative_path::RelativePathBuf;\n+use parking_lot::RwLock;\n+use failure::{format_err};\n \n use crate::{\n-    path_map::{PathMap, Root},\n     project_model::{CargoWorkspace, TargetKind},\n-    vfs::{FileEvent, FileEventKind},\n     Result,\n };\n \n-#[derive(Debug, Default)]\n+#[derive(Debug)]\n pub struct ServerWorldState {\n+    pub roots_to_scan: usize,\n+    pub root: PathBuf,\n     pub workspaces: Arc<Vec<CargoWorkspace>>,\n     pub analysis_host: AnalysisHost,\n-    pub path_map: PathMap,\n-    pub mem_map: FxHashMap<FileId, Option<String>>,\n+    pub vfs: Arc<RwLock<Vfs>>,\n }\n \n pub struct ServerWorld {\n     pub workspaces: Arc<Vec<CargoWorkspace>>,\n     pub analysis: Analysis,\n-    pub path_map: PathMap,\n+    pub vfs: Arc<RwLock<Vfs>>,\n }\n \n impl ServerWorldState {\n-    pub fn apply_fs_changes(&mut self, events: Vec<FileEvent>) {\n+    pub fn new(root: PathBuf, workspaces: Vec<CargoWorkspace>) -> ServerWorldState {\n         let mut change = AnalysisChange::new();\n-        let mut inserted = false;\n-        {\n-            let pm = &mut self.path_map;\n-            let mm = &mut self.mem_map;\n-            events\n-                .into_iter()\n-                .map(|event| {\n-                    let text = match event.kind {\n-                        FileEventKind::Add(text) => text,\n-                    };\n-                    (event.path, text)\n-                })\n-                .map(|(path, text)| {\n-                    let (ins, file_id) = pm.get_or_insert(path, Root::Workspace);\n-                    inserted |= ins;\n-                    (file_id, text)\n-                })\n-                .filter_map(|(file_id, text)| {\n-                    if mm.contains_key(&file_id) {\n-                        mm.insert(file_id, Some(text));\n-                        None\n-                    } else {\n-                        Some((file_id, text))\n-                    }\n-                })\n-                .for_each(|(file_id, text)| change.add_file(file_id, text));\n-        }\n-        if inserted {\n-            change.set_file_resolver(Arc::new(self.path_map.clone()))\n-        }\n-        self.analysis_host.apply_change(change);\n-    }\n-    pub fn events_to_files(\n-        &mut self,\n-        events: Vec<FileEvent>,\n-    ) -> (Vec<(FileId, String)>, Arc<FileResolver>) {\n-        let files = {\n-            let pm = &mut self.path_map;\n-            events\n-                .into_iter()\n-                .map(|event| {\n-                    let FileEventKind::Add(text) = event.kind;\n-                    (event.path, text)\n-                })\n-                .map(|(path, text)| (pm.get_or_insert(path, Root::Lib).1, text))\n-                .collect()\n-        };\n-        let resolver = Arc::new(self.path_map.clone());\n-        (files, resolver)\n-    }\n-    pub fn add_lib(&mut self, data: LibraryData) {\n-        let mut change = AnalysisChange::new();\n-        change.add_library(data);\n-        self.analysis_host.apply_change(change);\n-    }\n \n-    pub fn add_mem_file(&mut self, path: PathBuf, text: String) -> FileId {\n-        let (inserted, file_id) = self.path_map.get_or_insert(path, Root::Workspace);\n-        if self.path_map.get_root(file_id) != Root::Lib {\n-            let mut change = AnalysisChange::new();\n-            if inserted {\n-                change.add_file(file_id, text);\n-                change.set_file_resolver(Arc::new(self.path_map.clone()));\n-            } else {\n-                change.change_file(file_id, text);\n+        let mut roots = Vec::new();\n+        roots.push(root.clone());\n+        for ws in workspaces.iter() {\n+            for pkg in ws.packages() {\n+                roots.push(pkg.root(&ws).to_path_buf());\n             }\n-            self.analysis_host.apply_change(change);\n         }\n-        self.mem_map.insert(file_id, None);\n-        file_id\n-    }\n-\n-    pub fn change_mem_file(&mut self, path: &Path, text: String) -> Result<()> {\n-        let file_id = self\n-            .path_map\n-            .get_id(path)\n-            .ok_or_else(|| format_err!(\"change to unknown file: {}\", path.display()))?;\n-        if self.path_map.get_root(file_id) != Root::Lib {\n-            let mut change = AnalysisChange::new();\n-            change.change_file(file_id, text);\n-            self.analysis_host.apply_change(change);\n+        let roots_to_scan = roots.len();\n+        let (mut vfs, roots) = Vfs::new(roots);\n+        for r in roots {\n+            let is_local = vfs.root2path(r).starts_with(&root);\n+            change.add_root(SourceRootId(r.0), is_local);\n         }\n-        Ok(())\n-    }\n \n-    pub fn remove_mem_file(&mut self, path: &Path) -> Result<FileId> {\n-        let file_id = self\n-            .path_map\n-            .get_id(path)\n-            .ok_or_else(|| format_err!(\"change to unknown file: {}\", path.display()))?;\n-        match self.mem_map.remove(&file_id) {\n-            Some(_) => (),\n-            None => bail!(\"unmatched close notification\"),\n-        };\n-        // Do this via file watcher ideally.\n-        let text = fs::read_to_string(path).ok();\n-        if self.path_map.get_root(file_id) != Root::Lib {\n-            let mut change = AnalysisChange::new();\n-            if let Some(text) = text {\n-                change.change_file(file_id, text);\n-            }\n-            self.analysis_host.apply_change(change);\n-        }\n-        Ok(file_id)\n-    }\n-    pub fn set_workspaces(&mut self, ws: Vec<CargoWorkspace>) {\n         let mut crate_graph = CrateGraph::default();\n         let mut pkg_to_lib_crate = FxHashMap::default();\n         let mut pkg_crates = FxHashMap::default();\n-        for ws in ws.iter() {\n+        for ws in workspaces.iter() {\n             for pkg in ws.packages() {\n                 for tgt in pkg.targets(ws) {\n                     let root = tgt.root(ws);\n-                    if let Some(file_id) = self.path_map.get_id(root) {\n+                    if let Some(file_id) = vfs.load(root) {\n+                        let file_id = FileId(file_id.0);\n                         let crate_id = crate_graph.add_crate_root(file_id);\n                         if tgt.kind(ws) == TargetKind::Lib {\n                             pkg_to_lib_crate.insert(pkg, crate_id);\n@@ -170,16 +82,80 @@ impl ServerWorldState {\n                 }\n             }\n         }\n-        self.workspaces = Arc::new(ws);\n-        let mut change = AnalysisChange::new();\n         change.set_crate_graph(crate_graph);\n+\n+        let mut analysis_host = AnalysisHost::default();\n+        analysis_host.apply_change(change);\n+        ServerWorldState {\n+            roots_to_scan,\n+            root,\n+            workspaces: Arc::new(workspaces),\n+            analysis_host,\n+            vfs: Arc::new(RwLock::new(vfs)),\n+        }\n+    }\n+\n+    /// Returns a vec of libraries\n+    /// FIXME: better API here\n+    pub fn process_changes(\n+        &mut self,\n+    ) -> Vec<(SourceRootId, Vec<(FileId, RelativePathBuf, Arc<String>)>)> {\n+        let changes = self.vfs.write().commit_changes();\n+        if changes.is_empty() {\n+            return Vec::new();\n+        }\n+        let mut libs = Vec::new();\n+        let mut change = AnalysisChange::new();\n+        for c in changes {\n+            log::info!(\"vfs change {:?}\", c);\n+            match c {\n+                VfsChange::AddRoot { root, files } => {\n+                    let root_path = self.vfs.read().root2path(root);\n+                    if root_path.starts_with(&self.root) {\n+                        self.roots_to_scan -= 1;\n+                        for (file, path, text) in files {\n+                            change.add_file(SourceRootId(root.0), FileId(file.0), path, text);\n+                        }\n+                    } else {\n+                        let files = files\n+                            .into_iter()\n+                            .map(|(vfsfile, path, text)| (FileId(vfsfile.0), path, text))\n+                            .collect();\n+                        libs.push((SourceRootId(root.0), files));\n+                    }\n+                }\n+                VfsChange::AddFile {\n+                    root,\n+                    file,\n+                    path,\n+                    text,\n+                } => {\n+                    change.add_file(SourceRootId(root.0), FileId(file.0), path, text);\n+                }\n+                VfsChange::RemoveFile { root, file, path } => {\n+                    change.remove_file(SourceRootId(root.0), FileId(file.0), path)\n+                }\n+                VfsChange::ChangeFile { file, text } => {\n+                    change.change_file(FileId(file.0), text);\n+                }\n+            }\n+        }\n         self.analysis_host.apply_change(change);\n+        libs\n     }\n+\n+    pub fn add_lib(&mut self, data: LibraryData) {\n+        self.roots_to_scan -= 1;\n+        let mut change = AnalysisChange::new();\n+        change.add_library(data);\n+        self.analysis_host.apply_change(change);\n+    }\n+\n     pub fn snapshot(&self) -> ServerWorld {\n         ServerWorld {\n             workspaces: Arc::clone(&self.workspaces),\n             analysis: self.analysis_host.analysis(),\n-            path_map: self.path_map.clone(),\n+            vfs: Arc::clone(&self.vfs),\n         }\n     }\n }\n@@ -193,15 +169,18 @@ impl ServerWorld {\n         let path = uri\n             .to_file_path()\n             .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n-        self.path_map\n-            .get_id(&path)\n-            .ok_or_else(|| format_err!(\"unknown file: {}\", path.display()))\n+        let file = self\n+            .vfs\n+            .read()\n+            .path2file(&path)\n+            .ok_or_else(|| format_err!(\"unknown file: {}\", path.display()))?;\n+        Ok(FileId(file.0))\n     }\n \n     pub fn file_id_to_uri(&self, id: FileId) -> Result<Url> {\n-        let path = self.path_map.get_path(id);\n-        let url = Url::from_file_path(path)\n-            .map_err(|()| format_err!(\"can't convert path to url: {}\", path.display()))?;\n+        let path = self.vfs.read().file2path(VfsFile(id.0));\n+        let url = Url::from_file_path(&path)\n+            .map_err(|_| format_err!(\"can't convert path to url: {}\", path.display()))?;\n         Ok(url)\n     }\n }"}, {"sha": "fcf7693d86855c227e939fda9275489d68a5b74f", "filename": "crates/ra_lsp_server/src/vfs.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/dbb62b5baa36783bbca06f09c77794fce3ceff0c/crates%2Fra_lsp_server%2Fsrc%2Fvfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb62b5baa36783bbca06f09c77794fce3ceff0c/crates%2Fra_lsp_server%2Fsrc%2Fvfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fvfs.rs?ref=dbb62b5baa36783bbca06f09c77794fce3ceff0c", "patch": "@@ -1,67 +0,0 @@\n-use std::{\n-    fs,\n-    path::{Path, PathBuf},\n-};\n-\n-use walkdir::WalkDir;\n-use thread_worker::{WorkerHandle, Worker};\n-\n-#[derive(Debug)]\n-pub struct FileEvent {\n-    pub path: PathBuf,\n-    pub kind: FileEventKind,\n-}\n-\n-#[derive(Debug)]\n-pub enum FileEventKind {\n-    Add(String),\n-}\n-\n-pub fn roots_loader() -> (Worker<PathBuf, (PathBuf, Vec<FileEvent>)>, WorkerHandle) {\n-    thread_worker::spawn::<PathBuf, (PathBuf, Vec<FileEvent>), _>(\n-        \"roots loader\",\n-        128,\n-        |input_receiver, output_sender| {\n-            input_receiver\n-                .map(|path| {\n-                    log::debug!(\"loading {} ...\", path.as_path().display());\n-                    let events = load_root(path.as_path());\n-                    log::debug!(\"... loaded {}\", path.as_path().display());\n-                    (path, events)\n-                })\n-                .for_each(|it| output_sender.send(it))\n-        },\n-    )\n-}\n-\n-fn load_root(path: &Path) -> Vec<FileEvent> {\n-    let mut res = Vec::new();\n-    for entry in WalkDir::new(path) {\n-        let entry = match entry {\n-            Ok(entry) => entry,\n-            Err(e) => {\n-                log::warn!(\"watcher error: {}\", e);\n-                continue;\n-            }\n-        };\n-        if !entry.file_type().is_file() {\n-            continue;\n-        }\n-        let path = entry.path();\n-        if path.extension().and_then(|os| os.to_str()) != Some(\"rs\") {\n-            continue;\n-        }\n-        let text = match fs::read_to_string(path) {\n-            Ok(text) => text,\n-            Err(e) => {\n-                log::warn!(\"watcher error: {}\", e);\n-                continue;\n-            }\n-        };\n-        res.push(FileEvent {\n-            path: path.to_owned(),\n-            kind: FileEventKind::Add(text),\n-        })\n-    }\n-    res\n-}"}, {"sha": "029a55d4024b2260ff76f430bd78a63a1d999e76", "filename": "crates/ra_lsp_server/tests/heavy_tests/main.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -1,9 +1,7 @@\n mod support;\n \n use serde_json::json;\n-\n use ra_lsp_server::req::{Runnables, RunnablesParams, CodeActionRequest, CodeActionParams};\n-\n use languageserver_types::{Position, Range, CodeActionContext};\n \n use crate::support::project;\n@@ -20,6 +18,7 @@ fn foo() {\n }\n \",\n     );\n+    server.wait_for_feedback(\"workspace loaded\");\n     server.request::<Runnables>(\n         RunnablesParams {\n             text_document: server.doc_id(\"lib.rs\"),"}, {"sha": "c14d287cac2a5b85f1c1033face68479813b594d", "filename": "crates/ra_lsp_server/tests/heavy_tests/support.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -174,11 +174,11 @@ impl Server {\n impl Drop for Server {\n     fn drop(&mut self) {\n         self.send_request::<Shutdown>(666, ());\n-        let receiver = self.worker.take().unwrap().stop();\n+        let receiver = self.worker.take().unwrap().shutdown();\n         while let Some(msg) = recv_timeout(&receiver) {\n             drop(msg);\n         }\n-        self.watcher.take().unwrap().stop().unwrap();\n+        self.watcher.take().unwrap().shutdown().unwrap();\n     }\n }\n "}, {"sha": "ccea8a866fbb3d463f2b694fe217bb3890ecca73", "filename": "crates/ra_vfs/Cargo.toml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_vfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_vfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2FCargo.toml?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -0,0 +1,17 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_vfs\"\n+version = \"0.1.0\"\n+authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n+\n+[dependencies]\n+walkdir = \"2.2.7\"\n+relative-path = \"0.4.0\"\n+rustc-hash = \"1.0\"\n+crossbeam-channel = \"0.2.4\"\n+log = \"0.4.6\"\n+\n+thread_worker = { path = \"../thread_worker\" }\n+\n+[dev-dependencies]\n+tempfile = \"3\""}, {"sha": "6b42ae26d22d432d188aa459de45c8ddfc9ac42b", "filename": "crates/ra_vfs/src/arena.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_vfs%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_vfs%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Farena.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -0,0 +1,53 @@\n+use std::{\n+    marker::PhantomData,\n+    ops::{Index, IndexMut},\n+};\n+\n+#[derive(Clone, Debug)]\n+pub(crate) struct Arena<ID: ArenaId, T> {\n+    data: Vec<T>,\n+    _ty: PhantomData<ID>,\n+}\n+\n+pub(crate) trait ArenaId {\n+    fn from_u32(id: u32) -> Self;\n+    fn to_u32(self) -> u32;\n+}\n+\n+impl<ID: ArenaId, T> Arena<ID, T> {\n+    pub fn alloc(&mut self, value: T) -> ID {\n+        let id = self.data.len() as u32;\n+        self.data.push(value);\n+        ID::from_u32(id)\n+    }\n+    pub fn iter<'a>(&'a self) -> impl Iterator<Item = (ID, &'a T)> {\n+        self.data\n+            .iter()\n+            .enumerate()\n+            .map(|(idx, value)| (ID::from_u32(idx as u32), value))\n+    }\n+}\n+\n+impl<ID: ArenaId, T> Default for Arena<ID, T> {\n+    fn default() -> Arena<ID, T> {\n+        Arena {\n+            data: Vec::new(),\n+            _ty: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<ID: ArenaId, T> Index<ID> for Arena<ID, T> {\n+    type Output = T;\n+    fn index(&self, idx: ID) -> &T {\n+        let idx = idx.to_u32() as usize;\n+        &self.data[idx]\n+    }\n+}\n+\n+impl<ID: ArenaId, T> IndexMut<ID> for Arena<ID, T> {\n+    fn index_mut(&mut self, idx: ID) -> &mut T {\n+        let idx = idx.to_u32() as usize;\n+        &mut self.data[idx]\n+    }\n+}"}, {"sha": "be400bae9e7a42fc3b6437ccfc741de7f54d1914", "filename": "crates/ra_vfs/src/io.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -0,0 +1,76 @@\n+use std::{\n+    fmt,\n+    fs,\n+    path::{Path, PathBuf},\n+};\n+\n+use walkdir::{DirEntry, WalkDir};\n+use thread_worker::{WorkerHandle};\n+use relative_path::RelativePathBuf;\n+\n+use crate::VfsRoot;\n+\n+pub(crate) struct Task {\n+    pub(crate) root: VfsRoot,\n+    pub(crate) path: PathBuf,\n+    pub(crate) filter: Box<Fn(&DirEntry) -> bool + Send>,\n+}\n+\n+pub struct TaskResult {\n+    pub(crate) root: VfsRoot,\n+    pub(crate) files: Vec<(RelativePathBuf, String)>,\n+}\n+\n+impl fmt::Debug for TaskResult {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(\"TaskResult { ... }\")\n+    }\n+}\n+\n+pub(crate) type Worker = thread_worker::Worker<Task, TaskResult>;\n+\n+pub(crate) fn start() -> (Worker, WorkerHandle) {\n+    thread_worker::spawn(\"vfs\", 128, |input_receiver, output_sender| {\n+        input_receiver\n+            .map(handle_task)\n+            .for_each(|it| output_sender.send(it))\n+    })\n+}\n+\n+fn handle_task(task: Task) -> TaskResult {\n+    let Task { root, path, filter } = task;\n+    log::debug!(\"loading {} ...\", path.as_path().display());\n+    let files = load_root(path.as_path(), &*filter);\n+    log::debug!(\"... loaded {}\", path.as_path().display());\n+    TaskResult { root, files }\n+}\n+\n+fn load_root(root: &Path, filter: &dyn Fn(&DirEntry) -> bool) -> Vec<(RelativePathBuf, String)> {\n+    let mut res = Vec::new();\n+    for entry in WalkDir::new(root).into_iter().filter_entry(filter) {\n+        let entry = match entry {\n+            Ok(entry) => entry,\n+            Err(e) => {\n+                log::warn!(\"watcher error: {}\", e);\n+                continue;\n+            }\n+        };\n+        if !entry.file_type().is_file() {\n+            continue;\n+        }\n+        let path = entry.path();\n+        if path.extension().and_then(|os| os.to_str()) != Some(\"rs\") {\n+            continue;\n+        }\n+        let text = match fs::read_to_string(path) {\n+            Ok(text) => text,\n+            Err(e) => {\n+                log::warn!(\"watcher error: {}\", e);\n+                continue;\n+            }\n+        };\n+        let path = RelativePathBuf::from_path(path.strip_prefix(root).unwrap()).unwrap();\n+        res.push((path.to_owned(), text))\n+    }\n+    res\n+}"}, {"sha": "4de07b09319ee428e5742ba3c21ffaee0a9d781b", "filename": "crates/ra_vfs/src/lib.rs", "status": "added", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -0,0 +1,350 @@\n+//! VFS stands for Virtual File System.\n+//!\n+//! When doing analysis, we don't want to do any IO, we want to keep all source\n+//! code in memory. However, the actual source code is stored on disk, so you\n+//! component which does this.\n+//! need to get it into the memory in the first place somehow. VFS is the\n+//!\n+//! It also is responsible for watching the disk for changes, and for merging\n+//! editor state (modified, unsaved files) with disk state.\n+//!\n+//! VFS is based on a concept of roots: a set of directories on the file system\n+//! whihc are watched for changes. Typically, there will be a root for each\n+//! Cargo package.\n+mod arena;\n+mod io;\n+\n+use std::{\n+    fmt,\n+    mem,\n+    thread,\n+    cmp::Reverse,\n+    path::{Path, PathBuf},\n+    ffi::OsStr,\n+    sync::Arc,\n+    fs,\n+};\n+\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use relative_path::RelativePathBuf;\n+use crossbeam_channel::Receiver;\n+use walkdir::DirEntry;\n+use thread_worker::{WorkerHandle};\n+\n+use crate::{\n+    arena::{ArenaId, Arena},\n+};\n+\n+pub use crate::io::TaskResult as VfsTask;\n+\n+/// `RootFilter` is a predicate that checks if a file can belong to a root. If\n+/// several filters match a file (nested dirs), the most nested one wins.\n+struct RootFilter {\n+    root: PathBuf,\n+    file_filter: fn(&Path) -> bool,\n+}\n+\n+impl RootFilter {\n+    fn new(root: PathBuf) -> RootFilter {\n+        RootFilter {\n+            root,\n+            file_filter: has_rs_extension,\n+        }\n+    }\n+    /// Check if this root can contain `path`. NB: even if this returns\n+    /// true, the `path` might actually be conained in some nested root.\n+    fn can_contain(&self, path: &Path) -> Option<RelativePathBuf> {\n+        if !(self.file_filter)(path) {\n+            return None;\n+        }\n+        if !(path.starts_with(&self.root)) {\n+            return None;\n+        }\n+        let path = path.strip_prefix(&self.root).unwrap();\n+        let path = RelativePathBuf::from_path(path).unwrap();\n+        Some(path)\n+    }\n+}\n+\n+fn has_rs_extension(p: &Path) -> bool {\n+    p.extension() == Some(OsStr::new(\"rs\"))\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n+pub struct VfsRoot(pub u32);\n+\n+impl ArenaId for VfsRoot {\n+    fn from_u32(idx: u32) -> VfsRoot {\n+        VfsRoot(idx)\n+    }\n+    fn to_u32(self) -> u32 {\n+        self.0\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n+pub struct VfsFile(pub u32);\n+\n+impl ArenaId for VfsFile {\n+    fn from_u32(idx: u32) -> VfsFile {\n+        VfsFile(idx)\n+    }\n+    fn to_u32(self) -> u32 {\n+        self.0\n+    }\n+}\n+\n+struct VfsFileData {\n+    root: VfsRoot,\n+    path: RelativePathBuf,\n+    text: Arc<String>,\n+}\n+\n+pub struct Vfs {\n+    roots: Arena<VfsRoot, RootFilter>,\n+    files: Arena<VfsFile, VfsFileData>,\n+    root2files: FxHashMap<VfsRoot, FxHashSet<VfsFile>>,\n+    pending_changes: Vec<VfsChange>,\n+    worker: io::Worker,\n+    worker_handle: WorkerHandle,\n+}\n+\n+impl fmt::Debug for Vfs {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(\"Vfs { ... }\")\n+    }\n+}\n+\n+impl Vfs {\n+    pub fn new(mut roots: Vec<PathBuf>) -> (Vfs, Vec<VfsRoot>) {\n+        let (worker, worker_handle) = io::start();\n+\n+        let mut res = Vfs {\n+            roots: Arena::default(),\n+            files: Arena::default(),\n+            root2files: FxHashMap::default(),\n+            worker,\n+            worker_handle,\n+            pending_changes: Vec::new(),\n+        };\n+\n+        // A hack to make nesting work.\n+        roots.sort_by_key(|it| Reverse(it.as_os_str().len()));\n+        for (i, path) in roots.iter().enumerate() {\n+            let root = res.roots.alloc(RootFilter::new(path.clone()));\n+            res.root2files.insert(root, Default::default());\n+            let nested = roots[..i]\n+                .iter()\n+                .filter(|it| it.starts_with(path))\n+                .map(|it| it.clone())\n+                .collect::<Vec<_>>();\n+            let filter = move |entry: &DirEntry| {\n+                if entry.file_type().is_file() {\n+                    has_rs_extension(entry.path())\n+                } else {\n+                    nested.iter().all(|it| it != entry.path())\n+                }\n+            };\n+            let task = io::Task {\n+                root,\n+                path: path.clone(),\n+                filter: Box::new(filter),\n+            };\n+            res.worker.inp.send(task);\n+        }\n+        let roots = res.roots.iter().map(|(id, _)| id).collect();\n+        (res, roots)\n+    }\n+\n+    pub fn root2path(&self, root: VfsRoot) -> PathBuf {\n+        self.roots[root].root.clone()\n+    }\n+\n+    pub fn path2file(&self, path: &Path) -> Option<VfsFile> {\n+        if let Some((_root, _path, Some(file))) = self.find_root(path) {\n+            return Some(file);\n+        }\n+        None\n+    }\n+\n+    pub fn file2path(&self, file: VfsFile) -> PathBuf {\n+        let rel_path = &self.files[file].path;\n+        let root_path = &self.roots[self.files[file].root].root;\n+        rel_path.to_path(root_path)\n+    }\n+\n+    pub fn file_for_path(&self, path: &Path) -> Option<VfsFile> {\n+        if let Some((_root, _path, Some(file))) = self.find_root(path) {\n+            return Some(file);\n+        }\n+        None\n+    }\n+\n+    pub fn load(&mut self, path: &Path) -> Option<VfsFile> {\n+        if let Some((root, rel_path, file)) = self.find_root(path) {\n+            return if let Some(file) = file {\n+                Some(file)\n+            } else {\n+                let text = fs::read_to_string(path).unwrap_or_default();\n+                let text = Arc::new(text);\n+                let file = self.add_file(root, rel_path.clone(), Arc::clone(&text));\n+                let change = VfsChange::AddFile {\n+                    file,\n+                    text,\n+                    root,\n+                    path: rel_path,\n+                };\n+                self.pending_changes.push(change);\n+                Some(file)\n+            };\n+        }\n+        None\n+    }\n+\n+    pub fn task_receiver(&self) -> &Receiver<io::TaskResult> {\n+        &self.worker.out\n+    }\n+\n+    pub fn handle_task(&mut self, task: io::TaskResult) {\n+        let mut files = Vec::new();\n+        // While we were scanning the root in the backgound, a file might have\n+        // been open in the editor, so we need to account for that.\n+        let exising = self.root2files[&task.root]\n+            .iter()\n+            .map(|&file| (self.files[file].path.clone(), file))\n+            .collect::<FxHashMap<_, _>>();\n+        for (path, text) in task.files {\n+            if let Some(&file) = exising.get(&path) {\n+                let text = Arc::clone(&self.files[file].text);\n+                files.push((file, path, text));\n+                continue;\n+            }\n+            let text = Arc::new(text);\n+            let file = self.add_file(task.root, path.clone(), Arc::clone(&text));\n+            files.push((file, path, text));\n+        }\n+\n+        let change = VfsChange::AddRoot {\n+            root: task.root,\n+            files,\n+        };\n+        self.pending_changes.push(change);\n+    }\n+\n+    pub fn add_file_overlay(&mut self, path: &Path, text: String) -> Option<VfsFile> {\n+        let mut res = None;\n+        if let Some((root, path, file)) = self.find_root(path) {\n+            let text = Arc::new(text);\n+            let change = if let Some(file) = file {\n+                res = Some(file);\n+                self.change_file(file, Arc::clone(&text));\n+                VfsChange::ChangeFile { file, text }\n+            } else {\n+                let file = self.add_file(root, path.clone(), Arc::clone(&text));\n+                res = Some(file);\n+                VfsChange::AddFile {\n+                    file,\n+                    text,\n+                    root,\n+                    path,\n+                }\n+            };\n+            self.pending_changes.push(change);\n+        }\n+        res\n+    }\n+\n+    pub fn change_file_overlay(&mut self, path: &Path, new_text: String) {\n+        if let Some((_root, _path, file)) = self.find_root(path) {\n+            let file = file.expect(\"can't change a file which wasn't added\");\n+            let text = Arc::new(new_text);\n+            self.change_file(file, Arc::clone(&text));\n+            let change = VfsChange::ChangeFile { file, text };\n+            self.pending_changes.push(change);\n+        }\n+    }\n+\n+    pub fn remove_file_overlay(&mut self, path: &Path) -> Option<VfsFile> {\n+        let mut res = None;\n+        if let Some((root, path, file)) = self.find_root(path) {\n+            let file = file.expect(\"can't remove a file which wasn't added\");\n+            res = Some(file);\n+            let full_path = path.to_path(&self.roots[root].root);\n+            let change = if let Ok(text) = fs::read_to_string(&full_path) {\n+                let text = Arc::new(text);\n+                self.change_file(file, Arc::clone(&text));\n+                VfsChange::ChangeFile { file, text }\n+            } else {\n+                self.remove_file(file);\n+                VfsChange::RemoveFile { root, file, path }\n+            };\n+            self.pending_changes.push(change);\n+        }\n+        res\n+    }\n+\n+    pub fn commit_changes(&mut self) -> Vec<VfsChange> {\n+        mem::replace(&mut self.pending_changes, Vec::new())\n+    }\n+\n+    /// Sutdown the VFS and terminate the background watching thread.\n+    pub fn shutdown(self) -> thread::Result<()> {\n+        let _ = self.worker.shutdown();\n+        self.worker_handle.shutdown()\n+    }\n+\n+    fn add_file(&mut self, root: VfsRoot, path: RelativePathBuf, text: Arc<String>) -> VfsFile {\n+        let data = VfsFileData { root, path, text };\n+        let file = self.files.alloc(data);\n+        self.root2files.get_mut(&root).unwrap().insert(file);\n+        file\n+    }\n+\n+    fn change_file(&mut self, file: VfsFile, new_text: Arc<String>) {\n+        self.files[file].text = new_text;\n+    }\n+\n+    fn remove_file(&mut self, file: VfsFile) {\n+        //FIXME: use arena with removal\n+        self.files[file].text = Default::default();\n+        self.files[file].path = Default::default();\n+        let root = self.files[file].root;\n+        let removed = self.root2files.get_mut(&root).unwrap().remove(&file);\n+        assert!(removed);\n+    }\n+\n+    fn find_root(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf, Option<VfsFile>)> {\n+        let (root, path) = self\n+            .roots\n+            .iter()\n+            .find_map(|(root, data)| data.can_contain(path).map(|it| (root, it)))?;\n+        let file = self.root2files[&root]\n+            .iter()\n+            .map(|&it| it)\n+            .find(|&file| self.files[file].path == path);\n+        Some((root, path, file))\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum VfsChange {\n+    AddRoot {\n+        root: VfsRoot,\n+        files: Vec<(VfsFile, RelativePathBuf, Arc<String>)>,\n+    },\n+    AddFile {\n+        root: VfsRoot,\n+        file: VfsFile,\n+        path: RelativePathBuf,\n+        text: Arc<String>,\n+    },\n+    RemoveFile {\n+        root: VfsRoot,\n+        file: VfsFile,\n+        path: RelativePathBuf,\n+    },\n+    ChangeFile {\n+        file: VfsFile,\n+        text: Arc<String>,\n+    },\n+}"}, {"sha": "f56fc46037070a3538e523303e441905ef3bca4e", "filename": "crates/ra_vfs/tests/vfs.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Ftests%2Fvfs.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -0,0 +1,101 @@\n+use std::{\n+    fs,\n+    collections::HashSet,\n+};\n+\n+use tempfile::tempdir;\n+\n+use ra_vfs::{Vfs, VfsChange};\n+\n+#[test]\n+fn test_vfs_works() -> std::io::Result<()> {\n+    let files = [\n+        (\"a/foo.rs\", \"hello\"),\n+        (\"a/bar.rs\", \"world\"),\n+        (\"a/b/baz.rs\", \"nested hello\"),\n+    ];\n+\n+    let dir = tempdir()?;\n+    for (path, text) in files.iter() {\n+        let file_path = dir.path().join(path);\n+        fs::create_dir_all(file_path.parent().unwrap())?;\n+        fs::write(file_path, text)?\n+    }\n+\n+    let a_root = dir.path().join(\"a\");\n+    let b_root = dir.path().join(\"a/b\");\n+\n+    let (mut vfs, _) = Vfs::new(vec![a_root, b_root]);\n+    for _ in 0..2 {\n+        let task = vfs.task_receiver().recv().unwrap();\n+        vfs.handle_task(task);\n+    }\n+    {\n+        let files = vfs\n+            .commit_changes()\n+            .into_iter()\n+            .flat_map(|change| {\n+                let files = match change {\n+                    VfsChange::AddRoot { files, .. } => files,\n+                    _ => panic!(\"unexpected change\"),\n+                };\n+                files.into_iter().map(|(_id, path, text)| {\n+                    let text: String = (&*text).clone();\n+                    (format!(\"{}\", path.display()), text)\n+                })\n+            })\n+            .collect::<HashSet<_>>();\n+\n+        let expected_files = [\n+            (\"foo.rs\", \"hello\"),\n+            (\"bar.rs\", \"world\"),\n+            (\"baz.rs\", \"nested hello\"),\n+        ]\n+        .iter()\n+        .map(|(path, text)| (path.to_string(), text.to_string()))\n+        .collect::<HashSet<_>>();\n+\n+        assert_eq!(files, expected_files);\n+    }\n+\n+    vfs.add_file_overlay(&dir.path().join(\"a/b/baz.rs\"), \"quux\".to_string());\n+    let change = vfs.commit_changes().pop().unwrap();\n+    match change {\n+        VfsChange::ChangeFile { text, .. } => assert_eq!(&*text, \"quux\"),\n+        _ => panic!(\"unexpected change\"),\n+    }\n+\n+    vfs.change_file_overlay(&dir.path().join(\"a/b/baz.rs\"), \"m\".to_string());\n+    let change = vfs.commit_changes().pop().unwrap();\n+    match change {\n+        VfsChange::ChangeFile { text, .. } => assert_eq!(&*text, \"m\"),\n+        _ => panic!(\"unexpected change\"),\n+    }\n+\n+    vfs.remove_file_overlay(&dir.path().join(\"a/b/baz.rs\"));\n+    let change = vfs.commit_changes().pop().unwrap();\n+    match change {\n+        VfsChange::ChangeFile { text, .. } => assert_eq!(&*text, \"nested hello\"),\n+        _ => panic!(\"unexpected change\"),\n+    }\n+\n+    vfs.add_file_overlay(&dir.path().join(\"a/b/spam.rs\"), \"spam\".to_string());\n+    let change = vfs.commit_changes().pop().unwrap();\n+    match change {\n+        VfsChange::AddFile { text, path, .. } => {\n+            assert_eq!(&*text, \"spam\");\n+            assert_eq!(path, \"spam.rs\");\n+        }\n+        _ => panic!(\"unexpected change\"),\n+    }\n+\n+    vfs.remove_file_overlay(&dir.path().join(\"a/b/spam.rs\"));\n+    let change = vfs.commit_changes().pop().unwrap();\n+    match change {\n+        VfsChange::RemoveFile { .. } => (),\n+        _ => panic!(\"unexpected change\"),\n+    }\n+\n+    vfs.shutdown().unwrap();\n+    Ok(())\n+}"}, {"sha": "12e8bf17ed32603ab843d66a0e7f50edf3f09cf1", "filename": "crates/thread_worker/src/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fthread_worker%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a16cf2bf646a4a881f3f5acbf5582dacc4337bf/crates%2Fthread_worker%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fthread_worker%2Fsrc%2Flib.rs?ref=9a16cf2bf646a4a881f3f5acbf5582dacc4337bf", "patch": "@@ -30,13 +30,16 @@ where\n impl<I, O> Worker<I, O> {\n     /// Stops the worker. Returns the message receiver to fetch results which\n     /// have become ready before the worker is stopped.\n-    pub fn stop(self) -> Receiver<O> {\n+    pub fn shutdown(self) -> Receiver<O> {\n         self.out\n     }\n \n     pub fn send(&self, item: I) {\n         self.inp.send(item)\n     }\n+    pub fn recv(&self) -> Option<O> {\n+        self.out.recv()\n+    }\n }\n \n impl WorkerHandle {\n@@ -45,11 +48,11 @@ impl WorkerHandle {\n         WorkerHandle {\n             name,\n             thread,\n-            bomb: DropBomb::new(format!(\"WorkerHandle {} was not stopped\", name)),\n+            bomb: DropBomb::new(format!(\"WorkerHandle {} was not shutdown\", name)),\n         }\n     }\n \n-    pub fn stop(mut self) -> thread::Result<()> {\n+    pub fn shutdown(mut self) -> thread::Result<()> {\n         log::info!(\"waiting for {} to finish ...\", self.name);\n         let name = self.name;\n         self.bomb.defuse();"}]}