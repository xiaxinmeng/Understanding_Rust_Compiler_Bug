{"sha": "af1cc5c91131e0ec30f0f34691a5e635350295a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMWNjNWM5MTEzMWUwZWMzMGYwZjM0NjkxYTVlNjM1MzUwMjk1YTE=", "commit": {"author": {"name": "Ryan1729", "email": "Ryan1729@gmail.com", "date": "2020-11-07T23:00:42Z"}, "committer": {"name": "Ryan1729", "email": "Ryan1729@gmail.com", "date": "2020-11-28T00:50:16Z"}, "message": "add suspicious_operation_groupings lint\n\nrun `cargo dev new_lint --category correctness --name suspicious_chained_operators --pass early`\n\nadd (currently failing) tests for suspicious_chained_operators\nadd some tests to answer a question that came up during implementation\n\nwrite usage code for functions we'll need to find or create\n\nComplete left-right tracking TODO\n\nget it compiling with several `todo!` invocations.\n\nrefactor to a set of incomplete functions that don't expect to be able to edit a `Span`\n\ncreate placeholder for `suggestion_with_swapped_ident` function and correct some comments\n\nadd `inside_larger_boolean_expression` test\n\nfill out `get_ident` and `suggestion_with_swapped_ident`\n\nImplementi the `IdentIter`\n\nstart on implementing the `IdentIter`\nhandle the `ExprKind::Path` case in `IdentIter`\n\non second thought, make the iterator type dynamic so we don't need an explicit type for each one we will need\n\nhandle `ExprKind::MacCall` in `IdentIter`\n\nTry handling `box x` expressions\n\nrestructure `IdentIter`\n\nset `self.done` when returning `None`\n\nHandle `ExprKind::Array`\n\nreduce duplication with a macro that we expect to use several more times\n\nhandle ExprKind::Call\n\nadd `new_p` convenience method\n\nhandle `MethodCall`\n\nhandle `Tup` and `Binary`\n\nhandle `Unary`\n\nsimplify by not returning an additional `Expr` from the `IdentIter`\n\nadd cross product test against false positives\n\nrename suspicious_chained_operators to suspicious_operation_groupings within files\n\nFor the record, the exact commands run were:\nfind . -type f -name \"*.md\" -exec sed -i 's/suspicious_chained_operators/suspicious_operation_groupings/g' {} +\n\nfind . -type f -name \"*.rs\" -exec sed -i 's/suspicious_chained_operators/suspicious_operation_groupings/g' {} +\n\nfind . -type f -name \"*.rs\" -exec sed -i 's/SUSPICIOUS_CHAINED_OPERATORS/SUSPICIOUS_OPERATION_GROUPINGS/g' {} +\n\nfind . -type f -name \"*.rs\" -exec sed -i 's/SuspiciousChainedOperators/SuspiciousOperationGroupings/g' {} +\n\nAlso:\nrename file to match module name\n\nrename test file to match lint name\n\nstart implementing `IdentDifference` creation\n\nadd `IdentIter` utility\n\nuse `ident_iter::IdentIter`\n\nfix bug in `suggestion_with_swapped_ident`\n\nadd `inside_if_statements` test\n\nimplement `Add` `todo`s\n\nregister `SuspiciousOperationGroupings` lint pass\n\nfill in `chained_binops`, and fill in a stopgap version of `ident_difference_expr`, but then notice that the lint does not seem to ever be run in the tests\n\nrun `cargo dev update_lints` and not that the `suspicious_operation_groupings` lint still does not seem to be run\n\nfix base index incrementing bug\n\nfix paired_identifiers bug, and remove ident from `Single`\n\nchange help prefix and note our first successful lint messages!\n\nadd odd_number_of_pairs test\n\nget the `non_boolean_operators` test passing, with two copies of the error message\n\nextract `is_useless_with_eq_exprs` so we can know when `eq_op` will already handle something\n\nadd `not_caught_by_eq_op` tests since `s1.b * s1.b` was (reasonably) not caught by `eq_op`\n\ncover the case where the change should be made on either side of the expression with `not_caught_by_eq_op` tests\n\nproduce the expected suggestion on the `not_caught_by_eq_op_middle_change_left` test\n\nconfirm that the previous tests still pass and update references\n\nfix early continue bug and get `not_caught_by_eq_op_middle_change_right` passing\n\nnote that `not_caught_by_eq_op_start` already passes\n\nfix bugs based on misunderstanding of what `Iterator::skip` does, and note that `not_caught_by_eq_op_end` now passes\n\nadd several parens tests and make some of them pass\n\nhandle parens inside `chained_binops_helper` and note that this makes several tests pass\n\nget `inside_larger_boolean_expression_with_unsorted_ops` test passing by extracting out `check_same_op_binops` function\n\nalso run `cargo dev fmt`\n\nnote that `inside_function_call` already passes\n\nadd another `if_statement` test\n\nremove the matching op requirement, making `inside_larger_boolean_expression_with_unsorted_ops` pass\n\nprevent non-change suggestions from being emitted\n\nget the `Nested` tests passing, and remove apparently false note about eq_op\n\nadd a test to justify comment in `ident_difference_expr_with_base_location` but find that the failure mode seems different than expected\n\ncomplete `todo` making `do_not_give_bad_suggestions_for_this_unusual_expr` pass and add some more tests that already pass\n\nadd test to `eq_op`\n\nnote that `inside_fn_with_similar_expression` already passes\n\nfix `inside_an_if_statement` and note that it already passes\n\nattempt to implement if statement extraction and notice that we don't seem to handle unary ops correctly\n\nadd `maximum_unary_minus_right_tree` test and make it pass\n\nadd two tests and note one of them passes\n\nfilter out unary operations in several places, and find that the issue seems to be that we don't currently recognize the error in `multiple_comparison_types_and_unary_minus` even so.\n\nremove filtering that was causing bad suggestions\n\nremove tests that were deemed too much for now\n\nrun `cargo dev fmt`\n\ncorrect eq_op post-merge\n\nfill out the description and delete debugging code\n\nrun `cargo dev update_lints`\n\nupdate eq_op references\n\nadd parens to work around rustfmt issue #3666 and run rustfmt\n\nhttps://github.com/rust-lang/rustfmt/issues/3666#issuecomment-714612257\n\nupdate references after formatting\n\nfix dogfood issues\n\nfix multi-cursor edit\n\nfix missed dogfood error\n\nfix more dogfood pedantic issues, including function length\n\neven more nesting\n\ninsert hidden definition of Vec3 so docs compile\n\nadd spaces to second struct def\n\nreword test description comment\n\nCo-authored-by: llogiq <bogusandre@gmail.com>\n\nadd local `use BinOpKind::*;`\n\nApply suggestions from code review\n\nCo-authored-by: llogiq <bogusandre@gmail.com>\n\nswitch `SUSPICIOUS_OPERATION_GROUPINGS` to a style lint\n\nrun `cargo dev update_lints`\n\nput both usages of `op_types` in the same closure to satisfy `borrowck`\n\nfix compile error", "tree": {"sha": "e6b053c7f6063f2c4ae2e63fb11dc388093ea101", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6b053c7f6063f2c4ae2e63fb11dc388093ea101"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af1cc5c91131e0ec30f0f34691a5e635350295a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af1cc5c91131e0ec30f0f34691a5e635350295a1", "html_url": "https://github.com/rust-lang/rust/commit/af1cc5c91131e0ec30f0f34691a5e635350295a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af1cc5c91131e0ec30f0f34691a5e635350295a1/comments", "author": {"login": "Ryan1729", "id": 2133026, "node_id": "MDQ6VXNlcjIxMzMwMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2133026?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryan1729", "html_url": "https://github.com/Ryan1729", "followers_url": "https://api.github.com/users/Ryan1729/followers", "following_url": "https://api.github.com/users/Ryan1729/following{/other_user}", "gists_url": "https://api.github.com/users/Ryan1729/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryan1729/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryan1729/subscriptions", "organizations_url": "https://api.github.com/users/Ryan1729/orgs", "repos_url": "https://api.github.com/users/Ryan1729/repos", "events_url": "https://api.github.com/users/Ryan1729/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryan1729/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ryan1729", "id": 2133026, "node_id": "MDQ6VXNlcjIxMzMwMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2133026?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryan1729", "html_url": "https://github.com/Ryan1729", "followers_url": "https://api.github.com/users/Ryan1729/followers", "following_url": "https://api.github.com/users/Ryan1729/following{/other_user}", "gists_url": "https://api.github.com/users/Ryan1729/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryan1729/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryan1729/subscriptions", "organizations_url": "https://api.github.com/users/Ryan1729/orgs", "repos_url": "https://api.github.com/users/Ryan1729/repos", "events_url": "https://api.github.com/users/Ryan1729/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryan1729/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84ba08f391508722231566a68edda80d7061ed7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/84ba08f391508722231566a68edda80d7061ed7c", "html_url": "https://github.com/rust-lang/rust/commit/84ba08f391508722231566a68edda80d7061ed7c"}], "stats": {"total": 1174, "additions": 1150, "deletions": 24}, "files": [{"sha": "e76a781f13bc3c5d9c3bd574b728c820cc3799f0", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af1cc5c91131e0ec30f0f34691a5e635350295a1/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/af1cc5c91131e0ec30f0f34691a5e635350295a1/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=af1cc5c91131e0ec30f0f34691a5e635350295a1", "patch": "@@ -2073,6 +2073,7 @@ Released 2018-09-13\n [`suspicious_else_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_else_formatting\n [`suspicious_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_map\n [`suspicious_op_assign_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_op_assign_impl\n+[`suspicious_operation_groupings`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_operation_groupings\n [`suspicious_unary_op_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_unary_op_formatting\n [`tabs_in_doc_comments`]: https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments\n [`temporary_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_assignment"}, {"sha": "6308f6e2e7e9d6d8c825620ad644386dad8b5b6f", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/af1cc5c91131e0ec30f0f34691a5e635350295a1/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1cc5c91131e0ec30f0f34691a5e635350295a1/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=af1cc5c91131e0ec30f0f34691a5e635350295a1", "patch": "@@ -1,10 +1,10 @@\n use crate::utils::{\n-    eq_expr_value, higher, implements_trait, in_macro, is_copy, is_expn_of, multispan_sugg, snippet, span_lint,\n-    span_lint_and_then,\n+    ast_utils::is_useless_with_eq_exprs, eq_expr_value, higher, implements_trait, in_macro, is_copy, is_expn_of,\n+    multispan_sugg, snippet, span_lint, span_lint_and_then,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOp, BinOpKind, BorrowKind, Expr, ExprKind, StmtKind};\n+use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -102,7 +102,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n             if macro_with_not_op(&left.kind) || macro_with_not_op(&right.kind) {\n                 return;\n             }\n-            if is_valid_operator(op) && eq_expr_value(cx, left, right) {\n+            if is_useless_with_eq_exprs(higher::binop(op.node)) && eq_expr_value(cx, left, right) {\n                 span_lint(\n                     cx,\n                     EQ_OP,\n@@ -245,22 +245,3 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n         }\n     }\n }\n-\n-fn is_valid_operator(op: BinOp) -> bool {\n-    matches!(\n-        op.node,\n-        BinOpKind::Sub\n-            | BinOpKind::Div\n-            | BinOpKind::Eq\n-            | BinOpKind::Lt\n-            | BinOpKind::Le\n-            | BinOpKind::Gt\n-            | BinOpKind::Ge\n-            | BinOpKind::Ne\n-            | BinOpKind::And\n-            | BinOpKind::Or\n-            | BinOpKind::BitXor\n-            | BinOpKind::BitAnd\n-            | BinOpKind::BitOr\n-    )\n-}"}, {"sha": "6eb5f6a7f48c3bb75512258567cbf1126ba42d5c", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af1cc5c91131e0ec30f0f34691a5e635350295a1/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1cc5c91131e0ec30f0f34691a5e635350295a1/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=af1cc5c91131e0ec30f0f34691a5e635350295a1", "patch": "@@ -308,6 +308,7 @@ mod single_component_path_imports;\n mod slow_vector_initialization;\n mod stable_sort_primitive;\n mod strings;\n+mod suspicious_operation_groupings;\n mod suspicious_trait_impl;\n mod swap;\n mod tabs_in_doc_comments;\n@@ -834,6 +835,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &strings::STRING_LIT_AS_BYTES,\n         &strings::STRING_TO_STRING,\n         &strings::STR_TO_STRING,\n+        &suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS,\n         &suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL,\n         &suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL,\n         &swap::ALMOST_SWAPPED,\n@@ -1066,6 +1068,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box types::UnitArg);\n     store.register_late_pass(|| box double_comparison::DoubleComparisons);\n     store.register_late_pass(|| box question_mark::QuestionMark);\n+    store.register_early_pass(|| box suspicious_operation_groupings::SuspiciousOperationGroupings);\n     store.register_late_pass(|| box suspicious_trait_impl::SuspiciousImpl);\n     store.register_late_pass(|| box map_unit_fn::MapUnit);\n     store.register_late_pass(|| box inherent_impl::MultipleInherentImpl::default());\n@@ -1547,6 +1550,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n         LintId::of(&stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n         LintId::of(&strings::STRING_FROM_UTF8_AS_BYTES),\n+        LintId::of(&suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n         LintId::of(&swap::ALMOST_SWAPPED),\n@@ -1698,6 +1702,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&returns::LET_AND_RETURN),\n         LintId::of(&returns::NEEDLESS_RETURN),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n+        LintId::of(&suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n         LintId::of(&tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n         LintId::of(&to_digit_is_some::TO_DIGIT_IS_SOME),\n         LintId::of(&try_err::TRY_ERR),"}, {"sha": "cccd24ccf9401eaca5085f88601deb18f0dc9189", "filename": "clippy_lints/src/suspicious_operation_groupings.rs", "status": "added", "additions": 693, "deletions": 0, "changes": 693, "blob_url": "https://github.com/rust-lang/rust/blob/af1cc5c91131e0ec30f0f34691a5e635350295a1/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1cc5c91131e0ec30f0f34691a5e635350295a1/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=af1cc5c91131e0ec30f0f34691a5e635350295a1", "patch": "@@ -0,0 +1,693 @@\n+use crate::utils::ast_utils::{eq_id, is_useless_with_eq_exprs, IdentIter};\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use core::ops::{Add, AddAssign};\n+use if_chain::if_chain;\n+use rustc_ast::ast::{BinOpKind, Expr, ExprKind, StmtKind};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Spanned;\n+use rustc_span::symbol::Ident;\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Checks for unlikely usages of binary operators that are almost\n+    /// certainly typos and/or copy/paste errors, given the other usages\n+    /// of binary operators nearby.\n+    /// **Why is this bad?**\n+    /// They are probably bugs and if they aren't then they look like bugs\n+    /// and you should add a comment explaining why you are doing such an\n+    /// odd set of operations.\n+    /// **Known problems:**\n+    /// There may be some false positives if you are trying to do something\n+    /// unusual that happens to look like a typo.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct Vec3 {\n+    ///     x: f64,\n+    ///     y: f64,\n+    ///     z: f64,\n+    /// }\n+    ///\n+    /// impl Eq for Vec3 {}\n+    ///\n+    /// impl PartialEq for Vec3 {\n+    ///     fn eq(&self, other: &Self) -> bool {\n+    ///         // This should trigger the lint because `self.x` is compared to `other.y`\n+    ///         self.x == other.y && self.y == other.y && self.z == other.z\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # struct Vec3 {\n+    /// #     x: f64,\n+    /// #     y: f64,\n+    /// #     z: f64,\n+    /// # }\n+    /// // same as above except:\n+    /// impl PartialEq for Vec3 {\n+    ///     fn eq(&self, other: &Self) -> bool {\n+    ///         // Note we now compare other.x to self.x\n+    ///         self.x == other.x && self.y == other.y && self.z == other.z\n+    ///     }\n+    /// }\n+    /// ```\n+    pub SUSPICIOUS_OPERATION_GROUPINGS,\n+    style,\n+    \"groupings of binary operations that look suspiciously like typos\"\n+}\n+\n+declare_lint_pass!(SuspiciousOperationGroupings => [SUSPICIOUS_OPERATION_GROUPINGS]);\n+\n+impl EarlyLintPass for SuspiciousOperationGroupings {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        if let Some(binops) = extract_related_binops(&expr.kind) {\n+            check_binops(cx, &binops.iter().collect::<Vec<_>>());\n+\n+            let mut op_types = Vec::with_capacity(binops.len());\n+            // We could use a hashmap, etc. to avoid being O(n*m) here, but\n+            // we want the lints to be emitted in a consistent order. Besides,\n+            // m, (the number of distinct `BinOpKind`s in `binops`)\n+            // will often be small, and does have an upper limit.\n+            binops.iter().map(|b| b.op).for_each(|op| {\n+                if !op_types.contains(&op) {\n+                    op_types.push(op);\n+                }\n+            });\n+\n+            for op_type in op_types {\n+                let ops: Vec<_> = binops.iter().filter(|b| b.op == op_type).collect();\n+\n+                check_binops(cx, &ops);\n+            }\n+        }\n+    }\n+}\n+\n+fn check_binops(cx: &EarlyContext<'_>, binops: &[&BinaryOp<'_>]) {\n+    let binop_count = binops.len();\n+    if binop_count < 2 {\n+        // Single binary operation expressions would likely be false\n+        // positives.\n+        return;\n+    }\n+\n+    let mut one_ident_difference_count = 0;\n+    let mut no_difference_info = None;\n+    let mut double_difference_info = None;\n+    let mut expected_ident_loc = None;\n+\n+    let mut paired_identifiers = FxHashSet::default();\n+\n+    for (i, BinaryOp { left, right, op, .. }) in binops.iter().enumerate() {\n+        match ident_difference_expr(left, right) {\n+            IdentDifference::NoDifference => {\n+                if is_useless_with_eq_exprs(*op) {\n+                    // The `eq_op` lint should catch this in this case.\n+                    return;\n+                }\n+\n+                no_difference_info = Some(i);\n+            },\n+            IdentDifference::Single(ident_loc) => {\n+                one_ident_difference_count += 1;\n+                if let Some(previous_expected) = expected_ident_loc {\n+                    if previous_expected != ident_loc {\n+                        // This expression doesn't match the form we're\n+                        // looking for.\n+                        return;\n+                    }\n+                } else {\n+                    expected_ident_loc = Some(ident_loc);\n+                }\n+\n+                // If there was only a single difference, all other idents\n+                // must have been the same, and thus were paired.\n+                for id in skip_index(IdentIter::from(*left), ident_loc.index) {\n+                    paired_identifiers.insert(id);\n+                }\n+            },\n+            IdentDifference::Double(ident_loc1, ident_loc2) => {\n+                double_difference_info = Some((i, ident_loc1, ident_loc2));\n+            },\n+            IdentDifference::Multiple | IdentDifference::NonIdent => {\n+                // It's too hard to know whether this is a bug or not.\n+                return;\n+            },\n+        }\n+    }\n+\n+    let mut applicability = Applicability::MachineApplicable;\n+\n+    if let Some(expected_loc) = expected_ident_loc {\n+        match (no_difference_info, double_difference_info) {\n+            (Some(i), None) => attempt_to_emit_no_difference_lint(cx, binops, i, expected_loc),\n+            (None, Some((double_difference_index, ident_loc1, ident_loc2))) => {\n+                if_chain! {\n+                    if one_ident_difference_count == binop_count - 1;\n+                    if let Some(binop) = binops.get(double_difference_index);\n+                    then {\n+                        let changed_loc = if ident_loc1 == expected_loc {\n+                            ident_loc2\n+                        } else if ident_loc2 == expected_loc {\n+                            ident_loc1\n+                        } else {\n+                            // This expression doesn't match the form we're\n+                            // looking for.\n+                            return;\n+                        };\n+\n+                        if let Some(sugg) = ident_swap_sugg(\n+                            cx,\n+                            &paired_identifiers,\n+                            binop,\n+                            changed_loc,\n+                            &mut applicability,\n+                        ) {\n+                            emit_suggestion(\n+                                cx,\n+                                binop.span,\n+                                sugg,\n+                                applicability,\n+                            );\n+                        }\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+fn attempt_to_emit_no_difference_lint(\n+    cx: &EarlyContext<'_>,\n+    binops: &[&BinaryOp<'_>],\n+    i: usize,\n+    expected_loc: IdentLocation,\n+) {\n+    if let Some(binop) = binops.get(i).cloned() {\n+        // We need to try and figure out which identifier we should\n+        // suggest using instead. Since there could be multiple\n+        // replacement candidates in a given expression, and we're\n+        // just taking the first one, we may get some bad lint\n+        // messages.\n+        let mut applicability = Applicability::MaybeIncorrect;\n+\n+        // We assume that the correct ident is one used elsewhere in\n+        // the other binops, in a place that there was a single\n+        // difference between idents before.\n+        let old_left_ident = get_ident(binop.left, expected_loc);\n+        let old_right_ident = get_ident(binop.right, expected_loc);\n+\n+        for b in skip_index(binops.iter(), i) {\n+            if_chain! {\n+                if let (Some(old_ident), Some(new_ident)) =\n+                (old_left_ident, get_ident(b.left, expected_loc));\n+                if old_ident != new_ident;\n+                if let Some(sugg) = suggestion_with_swapped_ident(\n+                    cx,\n+                    binop.left,\n+                    expected_loc,\n+                    new_ident,\n+                    &mut applicability,\n+                );\n+                then {\n+                    emit_suggestion(\n+                        cx,\n+                        binop.span,\n+                        replace_left_sugg(cx, &binop, &sugg, &mut applicability),\n+                        applicability,\n+                    );\n+                    return;\n+                }\n+            }\n+\n+            if_chain! {\n+                if let (Some(old_ident), Some(new_ident)) =\n+                    (old_right_ident, get_ident(b.right, expected_loc));\n+                if old_ident != new_ident;\n+                if let Some(sugg) = suggestion_with_swapped_ident(\n+                    cx,\n+                    binop.right,\n+                    expected_loc,\n+                    new_ident,\n+                    &mut applicability,\n+                );\n+                then {\n+                    emit_suggestion(\n+                        cx,\n+                        binop.span,\n+                        replace_right_sugg(cx, &binop, &sugg, &mut applicability),\n+                        applicability,\n+                    );\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn emit_suggestion(cx: &EarlyContext<'_>, span: Span, sugg: String, applicability: Applicability) {\n+    span_lint_and_sugg(\n+        cx,\n+        SUSPICIOUS_OPERATION_GROUPINGS,\n+        span,\n+        \"This sequence of operators looks suspiciously like a bug.\",\n+        \"I think you meant\",\n+        sugg,\n+        applicability,\n+    )\n+}\n+\n+fn ident_swap_sugg(\n+    cx: &EarlyContext<'_>,\n+    paired_identifiers: &FxHashSet<Ident>,\n+    binop: &BinaryOp<'_>,\n+    location: IdentLocation,\n+    applicability: &mut Applicability,\n+) -> Option<String> {\n+    let left_ident = get_ident(&binop.left, location)?;\n+    let right_ident = get_ident(&binop.right, location)?;\n+\n+    let sugg = match (\n+        paired_identifiers.contains(&left_ident),\n+        paired_identifiers.contains(&right_ident),\n+    ) {\n+        (true, true) | (false, false) => {\n+            // We don't have a good guess of what ident should be\n+            // used instead, in these cases.\n+            *applicability = Applicability::MaybeIncorrect;\n+\n+            // We arbitraily choose one side to suggest changing,\n+            // since we don't have a better guess. If the user\n+            // ends up duplicating a clause, the `logic_bug` lint\n+            // should catch it.\n+\n+            let right_suggestion =\n+                suggestion_with_swapped_ident(cx, &binop.right, location, left_ident, applicability)?;\n+\n+            replace_right_sugg(cx, binop, &right_suggestion, applicability)\n+        },\n+        (false, true) => {\n+            // We haven't seen a pair involving the left one, so\n+            // it's probably what is wanted.\n+\n+            let right_suggestion =\n+                suggestion_with_swapped_ident(cx, &binop.right, location, left_ident, applicability)?;\n+\n+            replace_right_sugg(cx, binop, &right_suggestion, applicability)\n+        },\n+        (true, false) => {\n+            // We haven't seen a pair involving the right one, so\n+            // it's probably what is wanted.\n+            let left_suggestion = suggestion_with_swapped_ident(cx, &binop.left, location, right_ident, applicability)?;\n+\n+            replace_left_sugg(cx, binop, &left_suggestion, applicability)\n+        },\n+    };\n+\n+    Some(sugg)\n+}\n+\n+fn replace_left_sugg(\n+    cx: &EarlyContext<'_>,\n+    binop: &BinaryOp<'_>,\n+    left_suggestion: &str,\n+    applicability: &mut Applicability,\n+) -> String {\n+    format!(\n+        \"{} {} {}\",\n+        left_suggestion,\n+        binop.op.to_string(),\n+        snippet_with_applicability(cx, binop.right.span, \"..\", applicability),\n+    )\n+}\n+\n+fn replace_right_sugg(\n+    cx: &EarlyContext<'_>,\n+    binop: &BinaryOp<'_>,\n+    right_suggestion: &str,\n+    applicability: &mut Applicability,\n+) -> String {\n+    format!(\n+        \"{} {} {}\",\n+        snippet_with_applicability(cx, binop.left.span, \"..\", applicability),\n+        binop.op.to_string(),\n+        right_suggestion,\n+    )\n+}\n+\n+#[derive(Clone, Debug)]\n+struct BinaryOp<'exprs> {\n+    op: BinOpKind,\n+    span: Span,\n+    left: &'exprs Expr,\n+    right: &'exprs Expr,\n+}\n+\n+impl BinaryOp<'exprs> {\n+    fn new(op: BinOpKind, span: Span, (left, right): (&'exprs Expr, &'exprs Expr)) -> Self {\n+        Self { op, span, left, right }\n+    }\n+}\n+\n+fn strip_non_ident_wrappers(expr: &Expr) -> &Expr {\n+    let mut output = expr;\n+    loop {\n+        output = match &output.kind {\n+            ExprKind::Paren(ref inner) | ExprKind::Unary(_, ref inner) => inner,\n+            _ => {\n+                return output;\n+            },\n+        };\n+    }\n+}\n+\n+fn extract_related_binops(kind: &ExprKind) -> Option<Vec<BinaryOp<'_>>> {\n+    append_opt_vecs(chained_binops(kind), if_statment_binops(kind))\n+}\n+\n+fn if_statment_binops(kind: &ExprKind) -> Option<Vec<BinaryOp<'_>>> {\n+    match kind {\n+        ExprKind::If(ref condition, _, _) => chained_binops(&condition.kind),\n+        ExprKind::Paren(ref e) => if_statment_binops(&e.kind),\n+        ExprKind::Block(ref block, _) => {\n+            let mut output = None;\n+            for stmt in &block.stmts {\n+                match stmt.kind {\n+                    StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => {\n+                        output = append_opt_vecs(output, if_statment_binops(&e.kind));\n+                    },\n+                    _ => {},\n+                }\n+            }\n+            output\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn append_opt_vecs<A>(target_opt: Option<Vec<A>>, source_opt: Option<Vec<A>>) -> Option<Vec<A>> {\n+    match (target_opt, source_opt) {\n+        (Some(mut target), Some(mut source)) => {\n+            target.reserve(source.len());\n+            for op in source.drain(..) {\n+                target.push(op);\n+            }\n+            Some(target)\n+        },\n+        (Some(v), None) | (None, Some(v)) => Some(v),\n+        (None, None) => None,\n+    }\n+}\n+\n+fn chained_binops(kind: &ExprKind) -> Option<Vec<BinaryOp<'_>>> {\n+    match kind {\n+        ExprKind::Binary(_, left_outer, right_outer) => chained_binops_helper(left_outer, right_outer),\n+        ExprKind::Paren(ref e) | ExprKind::Unary(_, ref e) => chained_binops(&e.kind),\n+        _ => None,\n+    }\n+}\n+\n+fn chained_binops_helper(left_outer: &'expr Expr, right_outer: &'expr Expr) -> Option<Vec<BinaryOp<'expr>>> {\n+    match (&left_outer.kind, &right_outer.kind) {\n+        (\n+            ExprKind::Paren(ref left_e) | ExprKind::Unary(_, ref left_e),\n+            ExprKind::Paren(ref right_e) | ExprKind::Unary(_, ref right_e),\n+        ) => chained_binops_helper(left_e, right_e),\n+        (ExprKind::Paren(ref left_e) | ExprKind::Unary(_, ref left_e), _) => chained_binops_helper(left_e, right_outer),\n+        (_, ExprKind::Paren(ref right_e) | ExprKind::Unary(_, ref right_e)) => {\n+            chained_binops_helper(left_outer, right_e)\n+        },\n+        (\n+            ExprKind::Binary(Spanned { node: left_op, .. }, ref left_left, ref left_right),\n+            ExprKind::Binary(Spanned { node: right_op, .. }, ref right_left, ref right_right),\n+        ) => match (\n+            chained_binops_helper(left_left, left_right),\n+            chained_binops_helper(right_left, right_right),\n+        ) {\n+            (Some(mut left_ops), Some(mut right_ops)) => {\n+                left_ops.reserve(right_ops.len());\n+                for op in right_ops.drain(..) {\n+                    left_ops.push(op);\n+                }\n+                Some(left_ops)\n+            },\n+            (Some(mut left_ops), _) => {\n+                left_ops.push(BinaryOp::new(*right_op, right_outer.span, (right_left, right_right)));\n+                Some(left_ops)\n+            },\n+            (_, Some(mut right_ops)) => {\n+                right_ops.insert(0, BinaryOp::new(*left_op, left_outer.span, (left_left, left_right)));\n+                Some(right_ops)\n+            },\n+            (None, None) => Some(vec![\n+                BinaryOp::new(*left_op, left_outer.span, (left_left, left_right)),\n+                BinaryOp::new(*right_op, right_outer.span, (right_left, right_right)),\n+            ]),\n+        },\n+        _ => None,\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]\n+struct IdentLocation {\n+    index: usize,\n+}\n+\n+impl Add for IdentLocation {\n+    type Output = IdentLocation;\n+\n+    fn add(self, other: Self) -> Self::Output {\n+        Self {\n+            index: self.index + other.index,\n+        }\n+    }\n+}\n+\n+impl AddAssign for IdentLocation {\n+    fn add_assign(&mut self, other: Self) {\n+        *self = *self + other\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum IdentDifference {\n+    NoDifference,\n+    Single(IdentLocation),\n+    Double(IdentLocation, IdentLocation),\n+    Multiple,\n+    NonIdent,\n+}\n+\n+impl Add for IdentDifference {\n+    type Output = IdentDifference;\n+\n+    fn add(self, other: Self) -> Self::Output {\n+        match (self, other) {\n+            (Self::NoDifference, output) | (output, Self::NoDifference) => output,\n+            (Self::Multiple, _)\n+            | (_, Self::Multiple)\n+            | (Self::Double(_, _), Self::Single(_))\n+            | (Self::Single(_) | Self::Double(_, _), Self::Double(_, _)) => Self::Multiple,\n+            (Self::NonIdent, _) | (_, Self::NonIdent) => Self::NonIdent,\n+            (Self::Single(il1), Self::Single(il2)) => Self::Double(il1, il2),\n+        }\n+    }\n+}\n+\n+impl AddAssign for IdentDifference {\n+    fn add_assign(&mut self, other: Self) {\n+        *self = *self + other\n+    }\n+}\n+\n+impl IdentDifference {\n+    /// Returns true if learning about more differences will not change the value\n+    /// of this `IdentDifference`, and false otherwise.\n+    fn is_complete(&self) -> bool {\n+        match self {\n+            Self::NoDifference | Self::Single(_) | Self::Double(_, _) => false,\n+            Self::Multiple | Self::NonIdent => true,\n+        }\n+    }\n+}\n+\n+fn ident_difference_expr(left: &Expr, right: &Expr) -> IdentDifference {\n+    ident_difference_expr_with_base_location(left, right, IdentLocation::default()).0\n+}\n+\n+fn ident_difference_expr_with_base_location(\n+    left: &Expr,\n+    right: &Expr,\n+    mut base: IdentLocation,\n+) -> (IdentDifference, IdentLocation) {\n+    // Ideally, this function should not use IdentIter because it should return\n+    // early if the expressions have any non-ident differences. We want that early\n+    // return because if without that restriction the lint would lead to false\n+    // positives.\n+    //\n+    // But, we cannot (easily?) use a `rustc_ast::visit::Visitor`, since we need\n+    // the two expressions to be walked in lockstep. And without a `Visitor`, we'd\n+    // have to do all the AST traversal ourselves, which is a lot of work, since to\n+    // do it properly we'd need to be able to handle more or less every possible\n+    // AST node since `Item`s can be written inside `Expr`s.\n+    //\n+    // In practice, it seems likely that expressions, above a certain size, that\n+    // happen to use the exact same idents in the exact same order, and which are\n+    // not structured the same, would be rare. Therefore it seems likely that if\n+    // we do only the first layer of matching ourselves and eventually fallback on\n+    // IdentIter, then the output of this function will be almost always be correct\n+    // in practice.\n+    //\n+    // If it turns out that problematic cases are more prelavent than we assume,\n+    // then we should be able to change this function to do the correct traversal,\n+    // without needing to change the rest of the code.\n+\n+    #![allow(clippy::enum_glob_use)]\n+    use ExprKind::*;\n+\n+    match (\n+        &strip_non_ident_wrappers(left).kind,\n+        &strip_non_ident_wrappers(right).kind,\n+    ) {\n+        (Yield(_), Yield(_))\n+        | (Try(_), Try(_))\n+        | (Paren(_), Paren(_))\n+        | (Repeat(_, _), Repeat(_, _))\n+        | (Struct(_, _, _), Struct(_, _, _))\n+        | (MacCall(_), MacCall(_))\n+        | (LlvmInlineAsm(_), LlvmInlineAsm(_))\n+        | (InlineAsm(_), InlineAsm(_))\n+        | (Ret(_), Ret(_))\n+        | (Continue(_), Continue(_))\n+        | (Break(_, _), Break(_, _))\n+        | (AddrOf(_, _, _), AddrOf(_, _, _))\n+        | (Path(_, _), Path(_, _))\n+        | (Range(_, _, _), Range(_, _, _))\n+        | (Index(_, _), Index(_, _))\n+        | (Field(_, _), Field(_, _))\n+        | (AssignOp(_, _, _), AssignOp(_, _, _))\n+        | (Assign(_, _, _), Assign(_, _, _))\n+        | (TryBlock(_), TryBlock(_))\n+        | (Await(_), Await(_))\n+        | (Async(_, _, _), Async(_, _, _))\n+        | (Block(_, _), Block(_, _))\n+        | (Closure(_, _, _, _, _, _), Closure(_, _, _, _, _, _))\n+        | (Match(_, _), Match(_, _))\n+        | (Loop(_, _), Loop(_, _))\n+        | (ForLoop(_, _, _, _), ForLoop(_, _, _, _))\n+        | (While(_, _, _), While(_, _, _))\n+        | (If(_, _, _), If(_, _, _))\n+        | (Let(_, _), Let(_, _))\n+        | (Type(_, _), Type(_, _))\n+        | (Cast(_, _), Cast(_, _))\n+        | (Lit(_), Lit(_))\n+        | (Unary(_, _), Unary(_, _))\n+        | (Binary(_, _, _), Binary(_, _, _))\n+        | (Tup(_), Tup(_))\n+        | (MethodCall(_, _, _), MethodCall(_, _, _))\n+        | (Call(_, _), Call(_, _))\n+        | (ConstBlock(_), ConstBlock(_))\n+        | (Array(_), Array(_))\n+        | (Box(_), Box(_)) => {\n+            // keep going\n+        },\n+        _ => {\n+            return (IdentDifference::NonIdent, base);\n+        },\n+    }\n+\n+    let mut difference = IdentDifference::NoDifference;\n+\n+    for (left_attr, right_attr) in left.attrs.iter().zip(right.attrs.iter()) {\n+        let (new_difference, new_base) =\n+            ident_difference_via_ident_iter_with_base_location(left_attr, right_attr, base);\n+        base = new_base;\n+        difference += new_difference;\n+        if difference.is_complete() {\n+            return (difference, base);\n+        }\n+    }\n+\n+    let (new_difference, new_base) = ident_difference_via_ident_iter_with_base_location(left, right, base);\n+    base = new_base;\n+    difference += new_difference;\n+\n+    (difference, base)\n+}\n+\n+fn ident_difference_via_ident_iter_with_base_location<Iterable: Into<IdentIter>>(\n+    left: Iterable,\n+    right: Iterable,\n+    mut base: IdentLocation,\n+) -> (IdentDifference, IdentLocation) {\n+    // See the note in `ident_difference_expr_with_base_location` about `IdentIter`\n+    let mut difference = IdentDifference::NoDifference;\n+\n+    let mut left_iterator = left.into();\n+    let mut right_iterator = right.into();\n+\n+    loop {\n+        match (left_iterator.next(), right_iterator.next()) {\n+            (Some(left_ident), Some(right_ident)) => {\n+                if !eq_id(left_ident, right_ident) {\n+                    difference += IdentDifference::Single(base);\n+                    if difference.is_complete() {\n+                        return (difference, base);\n+                    }\n+                }\n+            },\n+            (Some(_), None) | (None, Some(_)) => {\n+                return (IdentDifference::NonIdent, base);\n+            },\n+            (None, None) => {\n+                return (difference, base);\n+            },\n+        }\n+        base += IdentLocation { index: 1 };\n+    }\n+}\n+\n+fn get_ident(expr: &Expr, location: IdentLocation) -> Option<Ident> {\n+    IdentIter::from(expr).nth(location.index)\n+}\n+\n+fn suggestion_with_swapped_ident(\n+    cx: &EarlyContext<'_>,\n+    expr: &Expr,\n+    location: IdentLocation,\n+    new_ident: Ident,\n+    applicability: &mut Applicability,\n+) -> Option<String> {\n+    get_ident(expr, location).and_then(|current_ident| {\n+        if eq_id(current_ident, new_ident) {\n+            // We never want to suggest a non-change\n+            return None;\n+        }\n+\n+        Some(format!(\n+            \"{}{}{}\",\n+            snippet_with_applicability(cx, expr.span.with_hi(current_ident.span.lo()), \"..\", applicability),\n+            new_ident.to_string(),\n+            snippet_with_applicability(cx, expr.span.with_lo(current_ident.span.hi()), \"..\", applicability),\n+        ))\n+    })\n+}\n+\n+fn skip_index<A, Iter>(iter: Iter, index: usize) -> impl Iterator<Item = A>\n+where\n+    Iter: Iterator<Item = A>,\n+{\n+    iter.enumerate()\n+        .filter_map(move |(i, a)| if i == index { None } else { Some(a) })\n+}"}, {"sha": "31b4e25411bd39ba24a2aa927d4c28259e24a405", "filename": "clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af1cc5c91131e0ec30f0f34691a5e635350295a1/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1cc5c91131e0ec30f0f34691a5e635350295a1/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=af1cc5c91131e0ec30f0f34691a5e635350295a1", "patch": "@@ -10,6 +10,17 @@ use rustc_ast::{self as ast, *};\n use rustc_span::symbol::Ident;\n use std::mem;\n \n+pub mod ident_iter;\n+pub use ident_iter::IdentIter;\n+\n+pub fn is_useless_with_eq_exprs(kind: BinOpKind) -> bool {\n+    use BinOpKind::*;\n+    matches!(\n+        kind,\n+        Sub | Div | Eq | Lt | Le | Gt | Ge | Ne | And | Or | BitXor | BitAnd | BitOr\n+    )\n+}\n+\n /// Checks if each element in the first slice is contained within the latter as per `eq_fn`.\n pub fn unordered_over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -> bool {\n     left.len() == right.len() && left.iter().all(|l| right.iter().any(|r| eq_fn(l, r)))"}, {"sha": "eefcbabd835d2b669cf65be463c4130b366b66e7", "filename": "clippy_lints/src/utils/ast_utils/ident_iter.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/af1cc5c91131e0ec30f0f34691a5e635350295a1/clippy_lints%2Fsrc%2Futils%2Fast_utils%2Fident_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1cc5c91131e0ec30f0f34691a5e635350295a1/clippy_lints%2Fsrc%2Futils%2Fast_utils%2Fident_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fast_utils%2Fident_iter.rs?ref=af1cc5c91131e0ec30f0f34691a5e635350295a1", "patch": "@@ -0,0 +1,45 @@\n+use core::iter::FusedIterator;\n+use rustc_ast::visit::{walk_attribute, walk_expr, Visitor};\n+use rustc_ast::{Attribute, Expr};\n+use rustc_span::symbol::Ident;\n+\n+pub struct IdentIter(std::vec::IntoIter<Ident>);\n+\n+impl Iterator for IdentIter {\n+    type Item = Ident;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.0.next()\n+    }\n+}\n+\n+impl FusedIterator for IdentIter {}\n+\n+impl From<&Expr> for IdentIter {\n+    fn from(expr: &Expr) -> Self {\n+        let mut visitor = IdentCollector::default();\n+\n+        walk_expr(&mut visitor, expr);\n+\n+        IdentIter(visitor.0.into_iter())\n+    }\n+}\n+\n+impl From<&Attribute> for IdentIter {\n+    fn from(attr: &Attribute) -> Self {\n+        let mut visitor = IdentCollector::default();\n+\n+        walk_attribute(&mut visitor, attr);\n+\n+        IdentIter(visitor.0.into_iter())\n+    }\n+}\n+\n+#[derive(Default)]\n+struct IdentCollector(Vec<Ident>);\n+\n+impl Visitor<'_> for IdentCollector {\n+    fn visit_ident(&mut self, ident: Ident) {\n+        self.0.push(ident);\n+    }\n+}"}, {"sha": "7ab23320db6d1b7aba040e382ea317cb517b2d2c", "filename": "tests/ui/eq_op.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af1cc5c91131e0ec30f0f34691a5e635350295a1/tests%2Fui%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1cc5c91131e0ec30f0f34691a5e635350295a1/tests%2Fui%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feq_op.rs?ref=af1cc5c91131e0ec30f0f34691a5e635350295a1", "patch": "@@ -86,3 +86,12 @@ fn check_ignore_macro() {\n     // checks if the lint ignores macros with `!` operator\n     !bool_macro!(1) && !bool_macro!(\"\");\n }\n+\n+struct Nested {\n+    inner: ((i32,), (i32,), (i32,)),\n+}\n+\n+fn check_nested(n1: &Nested, n2: &Nested) -> bool {\n+    // `n2.inner.0.0` mistyped as `n1.inner.0.0`\n+    (n1.inner.0).0 == (n1.inner.0).0 && (n1.inner.1).0 == (n2.inner.1).0 && (n1.inner.2).0 == (n2.inner.2).0\n+}"}, {"sha": "8ef658af8df429829ec50d85dfcdbe4f8ab3bd74", "filename": "tests/ui/eq_op.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af1cc5c91131e0ec30f0f34691a5e635350295a1/tests%2Fui%2Feq_op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af1cc5c91131e0ec30f0f34691a5e635350295a1/tests%2Fui%2Feq_op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feq_op.stderr?ref=af1cc5c91131e0ec30f0f34691a5e635350295a1", "patch": "@@ -162,5 +162,13 @@ error: equal expressions as operands to `/`\n LL |     const D: u32 = A / A;\n    |                    ^^^^^\n \n-error: aborting due to 27 previous errors\n+error: equal expressions as operands to `==`\n+  --> $DIR/eq_op.rs:96:5\n+   |\n+LL |     (n1.inner.0).0 == (n1.inner.0).0 && (n1.inner.1).0 == (n2.inner.1).0 && (n1.inner.2).0 == (n2.inner.2).0\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[deny(clippy::eq_op)]` on by default\n+\n+error: aborting due to 28 previous errors\n "}, {"sha": "dd6f4ec7bd9b57bed579d463145cf35be8757302", "filename": "tests/ui/suspicious_operation_groupings.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/af1cc5c91131e0ec30f0f34691a5e635350295a1/tests%2Fui%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1cc5c91131e0ec30f0f34691a5e635350295a1/tests%2Fui%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_operation_groupings.rs?ref=af1cc5c91131e0ec30f0f34691a5e635350295a1", "patch": "@@ -0,0 +1,207 @@\n+#![warn(clippy::suspicious_operation_groupings)]\n+\n+struct Vec3 {\n+    x: f64,\n+    y: f64,\n+    z: f64,\n+}\n+\n+impl Eq for Vec3 {}\n+\n+impl PartialEq for Vec3 {\n+    fn eq(&self, other: &Self) -> bool {\n+        // This should trigger the lint because `self.x` is compared to `other.y`\n+        self.x == other.y && self.y == other.y && self.z == other.z\n+    }\n+}\n+\n+struct S {\n+    a: i32,\n+    b: i32,\n+    c: i32,\n+    d: i32,\n+}\n+\n+fn buggy_ab_cmp(s1: &S, s2: &S) -> bool {\n+    // There's no `s1.b`\n+    s1.a < s2.a && s1.a < s2.b\n+}\n+\n+struct SAOnly {\n+    a: i32,\n+}\n+\n+impl S {\n+    fn a(&self) -> i32 {\n+        0\n+    }\n+}\n+\n+fn do_not_give_bad_suggestions_for_this_unusual_expr(s1: &S, s2: &SAOnly) -> bool {\n+    // This is superficially similar to `buggy_ab_cmp`, but we should not suggest\n+    // `s2.b` since that is invalid.\n+    s1.a < s2.a && s1.a() < s1.b\n+}\n+\n+fn do_not_give_bad_suggestions_for_this_macro_expr(s1: &S, s2: &SAOnly) -> bool {\n+    macro_rules! s1 {\n+        () => {\n+            S {\n+                a: 1,\n+                b: 1,\n+                c: 1,\n+                d: 1,\n+            }\n+        };\n+    }\n+\n+    // This is superficially similar to `buggy_ab_cmp`, but we should not suggest\n+    // `s2.b` since that is invalid.\n+    s1.a < s2.a && s1!().a < s1.b\n+}\n+\n+fn do_not_give_bad_suggestions_for_this_incorrect_expr(s1: &S, s2: &SAOnly) -> bool {\n+    // There's two `s1.b`, but we should not suggest `s2.b` since that is invalid\n+    s1.a < s2.a && s1.b < s1.b\n+}\n+\n+fn permissable(s1: &S, s2: &S) -> bool {\n+    // Something like this seems like it might actually be what is desired.\n+    s1.a == s2.b\n+}\n+\n+fn non_boolean_operators(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    s1.a * s2.a + s1.b * s2.b + s1.c * s2.b + s1.d * s2.d\n+}\n+\n+fn odd_number_of_pairs(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.b`\n+    s1.a * s2.a + s1.b * s2.c + s1.c * s2.c\n+}\n+\n+fn not_caught_by_eq_op_middle_change_left(s1: &S, s2: &S) -> i32 {\n+    // There's no `s1.b`\n+    s1.a * s2.a + s2.b * s2.b + s1.c * s2.c\n+}\n+\n+fn not_caught_by_eq_op_middle_change_right(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.b`\n+    s1.a * s2.a + s1.b * s1.b + s1.c * s2.c\n+}\n+\n+fn not_caught_by_eq_op_start(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.a`\n+    s1.a * s1.a + s1.b * s2.b + s1.c * s2.c\n+}\n+\n+fn not_caught_by_eq_op_end(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    s1.a * s2.a + s1.b * s2.b + s1.c * s1.c\n+}\n+\n+fn the_cross_product_should_not_lint(s1: &S, s2: &S) -> (i32, i32, i32) {\n+    (\n+        s1.b * s2.c - s1.c * s2.b,\n+        s1.c * s2.a - s1.a * s2.c,\n+        s1.a * s2.b - s1.b * s2.a,\n+    )\n+}\n+\n+fn outer_parens_simple(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.b`\n+    (s1.a * s2.a + s1.b * s1.b)\n+}\n+\n+fn outer_parens(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    (s1.a * s2.a + s1.b * s2.b + s1.c * s2.b + s1.d * s2.d)\n+}\n+\n+fn inner_parens(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    (s1.a * s2.a) + (s1.b * s2.b) + (s1.c * s2.b) + (s1.d * s2.d)\n+}\n+\n+fn outer_and_some_inner_parens(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    ((s1.a * s2.a) + (s1.b * s2.b) + (s1.c * s2.b) + (s1.d * s2.d))\n+}\n+\n+fn all_parens_balanced_tree(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    (((s1.a * s2.a) + (s1.b * s2.b)) + ((s1.c * s2.b) + (s1.d * s2.d)))\n+}\n+\n+fn all_parens_left_tree(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    (((s1.a * s2.a) + (s1.b * s2.b) + (s1.c * s2.b)) + (s1.d * s2.d))\n+}\n+\n+fn all_parens_right_tree(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    ((s1.a * s2.a) + ((s1.b * s2.b) + (s1.c * s2.b) + (s1.d * s2.d)))\n+}\n+\n+fn inside_other_binop_expression(s1: &S, s2: &S) -> i32 {\n+    // There's no `s1.b`\n+    (s1.a * s2.a + s2.b * s2.b) / 2\n+}\n+\n+fn inside_function_call(s1: &S, s2: &S) -> i32 {\n+    // There's no `s1.b`\n+    i32::swap_bytes(s1.a * s2.a + s2.b * s2.b)\n+}\n+\n+fn inside_larger_boolean_expression(s1: &S, s2: &S) -> bool {\n+    // There's no `s1.c`\n+    s1.a > 0 && s1.b > 0 && s1.d == s2.c && s1.d == s2.d\n+}\n+\n+fn inside_larger_boolean_expression_with_unsorted_ops(s1: &S, s2: &S) -> bool {\n+    // There's no `s1.c`\n+    s1.a > 0 && s1.d == s2.c && s1.b > 0 && s1.d == s2.d\n+}\n+\n+struct Nested {\n+    inner: ((i32,), (i32,), (i32,)),\n+}\n+\n+fn changed_middle_ident(n1: &Nested, n2: &Nested) -> bool {\n+    // There's no `n2.inner.2.0`\n+    (n1.inner.0).0 == (n2.inner.0).0 && (n1.inner.1).0 == (n2.inner.1).0 && (n1.inner.2).0 == (n2.inner.1).0\n+}\n+\n+// `eq_op` should catch this one.\n+fn changed_initial_ident(n1: &Nested, n2: &Nested) -> bool {\n+    // There's no `n2.inner.0.0`\n+    (n1.inner.0).0 == (n1.inner.0).0 && (n1.inner.1).0 == (n2.inner.1).0 && (n1.inner.2).0 == (n2.inner.2).0\n+}\n+\n+fn inside_fn_with_similar_expression(s1: &S, s2: &S, strict: bool) -> bool {\n+    if strict {\n+        s1.a < s2.a && s1.b < s2.b\n+    } else {\n+        // There's no `s1.b` in this subexpression\n+        s1.a <= s2.a && s1.a <= s2.b\n+    }\n+}\n+\n+fn inside_an_if_statement(s1: &S, s2: &S) {\n+    // There's no `s1.b`\n+    if s1.a < s2.a && s1.a < s2.b {\n+        s1.c = s2.c;\n+    }\n+}\n+\n+fn maximum_unary_minus_right_tree(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    -(-(-s1.a * -s2.a) + (-(-s1.b * -s2.b) + -(-s1.c * -s2.b) + -(-s1.d * -s2.d)))\n+}\n+\n+fn unary_minus_and_an_if_expression(s1: &S, s2: &S) -> i32 {\n+    // There's no `s1.b`\n+    -(if -s1.a < -s2.a && -s1.a < -s2.b { s1.c } else { s2.a })\n+}\n+\n+fn main() {}"}, {"sha": "ce7108217f18dccd5d81743633318de7124697ae", "filename": "tests/ui/suspicious_operation_groupings.stderr", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/af1cc5c91131e0ec30f0f34691a5e635350295a1/tests%2Fui%2Fsuspicious_operation_groupings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af1cc5c91131e0ec30f0f34691a5e635350295a1/tests%2Fui%2Fsuspicious_operation_groupings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_operation_groupings.stderr?ref=af1cc5c91131e0ec30f0f34691a5e635350295a1", "patch": "@@ -0,0 +1,166 @@\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:14:9\n+   |\n+LL |         self.x == other.y && self.y == other.y && self.z == other.z\n+   |         ^^^^^^^^^^^^^^^^^ help: I think you meant: `self.x == other.x`\n+   |\n+   = note: `-D clippy::suspicious-operation-groupings` implied by `-D warnings`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:14:9\n+   |\n+LL |         self.x == other.y && self.y == other.y && self.z == other.z\n+   |         ^^^^^^^^^^^^^^^^^ help: I think you meant: `self.x == other.x`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:27:20\n+   |\n+LL |     s1.a < s2.a && s1.a < s2.b\n+   |                    ^^^^^^^^^^^ help: I think you meant: `s1.b < s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:75:33\n+   |\n+LL |     s1.a * s2.a + s1.b * s2.b + s1.c * s2.b + s1.d * s2.d\n+   |                                 ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:80:19\n+   |\n+LL |     s1.a * s2.a + s1.b * s2.c + s1.c * s2.c\n+   |                   ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:80:19\n+   |\n+LL |     s1.a * s2.a + s1.b * s2.c + s1.c * s2.c\n+   |                   ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:85:19\n+   |\n+LL |     s1.a * s2.a + s2.b * s2.b + s1.c * s2.c\n+   |                   ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:90:19\n+   |\n+LL |     s1.a * s2.a + s1.b * s1.b + s1.c * s2.c\n+   |                   ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:95:5\n+   |\n+LL |     s1.a * s1.a + s1.b * s2.b + s1.c * s2.c\n+   |     ^^^^^^^^^^^ help: I think you meant: `s1.a * s2.a`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:100:33\n+   |\n+LL |     s1.a * s2.a + s1.b * s2.b + s1.c * s1.c\n+   |                                 ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:113:20\n+   |\n+LL |     (s1.a * s2.a + s1.b * s1.b)\n+   |                    ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:118:34\n+   |\n+LL |     (s1.a * s2.a + s1.b * s2.b + s1.c * s2.b + s1.d * s2.d)\n+   |                                  ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:123:38\n+   |\n+LL |     (s1.a * s2.a) + (s1.b * s2.b) + (s1.c * s2.b) + (s1.d * s2.d)\n+   |                                      ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:128:39\n+   |\n+LL |     ((s1.a * s2.a) + (s1.b * s2.b) + (s1.c * s2.b) + (s1.d * s2.d))\n+   |                                       ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:133:42\n+   |\n+LL |     (((s1.a * s2.a) + (s1.b * s2.b)) + ((s1.c * s2.b) + (s1.d * s2.d)))\n+   |                                          ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:133:42\n+   |\n+LL |     (((s1.a * s2.a) + (s1.b * s2.b)) + ((s1.c * s2.b) + (s1.d * s2.d)))\n+   |                                          ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:138:40\n+   |\n+LL |     (((s1.a * s2.a) + (s1.b * s2.b) + (s1.c * s2.b)) + (s1.d * s2.d))\n+   |                                        ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:143:40\n+   |\n+LL |     ((s1.a * s2.a) + ((s1.b * s2.b) + (s1.c * s2.b) + (s1.d * s2.d)))\n+   |                                        ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:148:20\n+   |\n+LL |     (s1.a * s2.a + s2.b * s2.b) / 2\n+   |                    ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:153:35\n+   |\n+LL |     i32::swap_bytes(s1.a * s2.a + s2.b * s2.b)\n+   |                                   ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:158:29\n+   |\n+LL |     s1.a > 0 && s1.b > 0 && s1.d == s2.c && s1.d == s2.d\n+   |                             ^^^^^^^^^^^^ help: I think you meant: `s1.c == s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:163:17\n+   |\n+LL |     s1.a > 0 && s1.d == s2.c && s1.b > 0 && s1.d == s2.d\n+   |                 ^^^^^^^^^^^^ help: I think you meant: `s1.c == s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:172:77\n+   |\n+LL |     (n1.inner.0).0 == (n2.inner.0).0 && (n1.inner.1).0 == (n2.inner.1).0 && (n1.inner.2).0 == (n2.inner.1).0\n+   |                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: I think you meant: `(n1.inner.2).0 == (n2.inner.2).0`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:186:25\n+   |\n+LL |         s1.a <= s2.a && s1.a <= s2.b\n+   |                         ^^^^^^^^^^^^ help: I think you meant: `s1.b <= s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:192:23\n+   |\n+LL |     if s1.a < s2.a && s1.a < s2.b {\n+   |                       ^^^^^^^^^^^ help: I think you meant: `s1.b < s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:199:48\n+   |\n+LL |     -(-(-s1.a * -s2.a) + (-(-s1.b * -s2.b) + -(-s1.c * -s2.b) + -(-s1.d * -s2.d)))\n+   |                                                ^^^^^^^^^^^^^ help: I think you meant: `-s1.c * -s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:204:27\n+   |\n+LL |     -(if -s1.a < -s2.a && -s1.a < -s2.b { s1.c } else { s2.a })\n+   |                           ^^^^^^^^^^^^^ help: I think you meant: `-s1.b < -s2.b`\n+\n+error: aborting due to 27 previous errors\n+"}]}