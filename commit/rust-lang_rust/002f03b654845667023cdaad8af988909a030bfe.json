{"sha": "002f03b654845667023cdaad8af988909a030bfe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwMmYwM2I2NTQ4NDU2NjcwMjNjZGFhZDhhZjk4ODkwOWEwMzBiZmU=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-08-23T04:29:38Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-08-23T08:41:55Z"}, "message": "Make SparseBitMatrix a bit lazier.\n\nCurrently when a row is instantiated in SparseBitMatrix, any missing\nrows prior to it are also fully instantiated.\n\nThis patch changes things so that those prior rows are minimally\ninstantiated (with a `None`). This avoids a decent number of allocations\nin NLL, speeding up several benchmarks by up to 0.5%.\n\nThe patch also removes two unused methods, `len()` and\n`iter_enumerated()`.", "tree": {"sha": "cd7877d3c12195da66650d62354c13192b7d70c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd7877d3c12195da66650d62354c13192b7d70c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/002f03b654845667023cdaad8af988909a030bfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/002f03b654845667023cdaad8af988909a030bfe", "html_url": "https://github.com/rust-lang/rust/commit/002f03b654845667023cdaad8af988909a030bfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/002f03b654845667023cdaad8af988909a030bfe/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f4c168a9dd2195b45998ddfecdac111663b26d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f4c168a9dd2195b45998ddfecdac111663b26d1", "html_url": "https://github.com/rust-lang/rust/commit/7f4c168a9dd2195b45998ddfecdac111663b26d1"}], "stats": {"total": 60, "additions": 32, "deletions": 28}, "files": [{"sha": "642d24f48313a26cb76f4880863c115f713f8829", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/002f03b654845667023cdaad8af988909a030bfe/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/002f03b654845667023cdaad8af988909a030bfe/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=002f03b654845667023cdaad8af988909a030bfe", "patch": "@@ -318,16 +318,22 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     }\n }\n \n-/// A moderately sparse bit matrix: rows are appended lazily, but columns\n-/// within appended rows are instantiated fully upon creation.\n+/// A moderately sparse bit matrix, in which rows are instantiated lazily.\n+///\n+/// Initially, every row has no explicit representation. If any bit within a\n+/// row is set, the entire row is instantiated as\n+/// `Some(<full-column-width-BitArray>)`. Furthermore, any previously\n+/// uninstantiated rows prior to it will be instantiated as `None`. Those prior\n+/// rows may themselves become fully instantiated later on if any of their bits\n+/// are set.\n #[derive(Clone, Debug)]\n pub struct SparseBitMatrix<R, C>\n where\n     R: Idx,\n     C: Idx,\n {\n     num_columns: usize,\n-    rows: IndexVec<R, BitArray<C>>,\n+    rows: IndexVec<R, Option<BitArray<C>>>,\n }\n \n impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n@@ -339,27 +345,30 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         }\n     }\n \n-    fn ensure_row(&mut self, row: R) {\n+    fn ensure_row(&mut self, row: R) -> &mut BitArray<C> {\n+        // Instantiate any missing rows up to and including row `row` with an\n+        // empty BitArray.\n+        self.rows.ensure_contains_elem(row, || None);\n+\n+        // Then replace row `row` with a full BitArray if necessary.\n         let num_columns = self.num_columns;\n-        self.rows\n-            .ensure_contains_elem(row, || BitArray::new(num_columns));\n+        self.rows[row].get_or_insert_with(|| BitArray::new(num_columns))\n     }\n \n     /// Sets the cell at `(row, column)` to true. Put another way, insert\n     /// `column` to the bitset for `row`.\n     ///\n     /// Returns true if this changed the matrix, and false otherwise.\n     pub fn add(&mut self, row: R, column: C) -> bool {\n-        self.ensure_row(row);\n-        self.rows[row].insert(column)\n+        self.ensure_row(row).insert(column)\n     }\n \n     /// Do the bits from `row` contain `column`? Put another way, is\n     /// the matrix cell at `(row, column)` true?  Put yet another way,\n     /// if the matrix represents (transitive) reachability, can\n     /// `row` reach `column`?\n     pub fn contains(&self, row: R, column: C) -> bool {\n-        self.rows.get(row).map_or(false, |r| r.contains(column))\n+        self.row(row).map_or(false, |r| r.contains(column))\n     }\n \n     /// Add the bits from row `read` to the bits from row `write`,\n@@ -370,30 +379,26 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     /// `write` can reach everything that `read` can (and\n     /// potentially more).\n     pub fn merge(&mut self, read: R, write: R) -> bool {\n-        if read == write || self.rows.get(read).is_none() {\n+        if read == write || self.row(read).is_none() {\n             return false;\n         }\n \n         self.ensure_row(write);\n-        let (bitvec_read, bitvec_write) = self.rows.pick2_mut(read, write);\n-        bitvec_write.merge(bitvec_read)\n+        if let (Some(bitvec_read), Some(bitvec_write)) = self.rows.pick2_mut(read, write) {\n+            bitvec_write.merge(bitvec_read)\n+        } else {\n+            unreachable!()\n+        }\n     }\n \n     /// Merge a row, `from`, into the `into` row.\n     pub fn merge_into(&mut self, into: R, from: &BitArray<C>) -> bool {\n-        self.ensure_row(into);\n-        self.rows[into].merge(from)\n+        self.ensure_row(into).merge(from)\n     }\n \n     /// Add all bits to the given row.\n     pub fn add_all(&mut self, row: R) {\n-        self.ensure_row(row);\n-        self.rows[row].insert_all();\n-    }\n-\n-    /// Number of elements in the matrix.\n-    pub fn len(&self) -> usize {\n-        self.rows.len()\n+        self.ensure_row(row).insert_all();\n     }\n \n     pub fn rows(&self) -> impl Iterator<Item = R> {\n@@ -403,16 +408,15 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n     pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n-        self.rows.get(row).into_iter().flat_map(|r| r.iter())\n-    }\n-\n-    /// Iterates through each row and the accompanying bit set.\n-    pub fn iter_enumerated<'a>(&'a self) -> impl Iterator<Item = (R, &'a BitArray<C>)> + 'a {\n-        self.rows.iter_enumerated()\n+        self.row(row).into_iter().flat_map(|r| r.iter())\n     }\n \n     pub fn row(&self, row: R) -> Option<&BitArray<C>> {\n-        self.rows.get(row)\n+        if let Some(Some(row)) = self.rows.get(row) {\n+            Some(row)\n+        } else {\n+            None\n+        }\n     }\n }\n "}]}