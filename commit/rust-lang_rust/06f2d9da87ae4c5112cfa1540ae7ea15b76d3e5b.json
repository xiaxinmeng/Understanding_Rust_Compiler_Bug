{"sha": "06f2d9da87ae4c5112cfa1540ae7ea15b76d3e5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ZjJkOWRhODdhZTRjNTExMmNmYTE1NDBhZTdlYTE1Yjc2ZDNlNWI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-18T10:38:50Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-19T00:23:29Z"}, "message": "Modify trans to use an outer walk and ensure that we rotate as we\nencounter each module. This is somewhat different than how it used to\nwork; it should ensure a more equitable distribution of work than\nbefore. The reason is that, before, when we rotated, we would rotate\nbefore we had seen the full contents of the current module. So e.g.  if\nwe have `mod a { mod b { .. } .. }`, then we rotate when we encounter\n`b`, but we haven't processed the remainder of `a` yet. Unclear if this\nmakes any difference in practice, but it seemed suboptimal. Also, this\nstructure (with an outer walk over modules) is closer to what we will\nwant for an incremental setting.", "tree": {"sha": "00e280dad1744816585092ed3836533a3bf33c21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00e280dad1744816585092ed3836533a3bf33c21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06f2d9da87ae4c5112cfa1540ae7ea15b76d3e5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06f2d9da87ae4c5112cfa1540ae7ea15b76d3e5b", "html_url": "https://github.com/rust-lang/rust/commit/06f2d9da87ae4c5112cfa1540ae7ea15b76d3e5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06f2d9da87ae4c5112cfa1540ae7ea15b76d3e5b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bc61402a92670e8c170fec1e35f5c5a19378221", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bc61402a92670e8c170fec1e35f5c5a19378221", "html_url": "https://github.com/rust-lang/rust/commit/0bc61402a92670e8c170fec1e35f5c5a19378221"}], "stats": {"total": 66, "additions": 54, "deletions": 12}, "files": [{"sha": "cd443647ad19382983b849a33cddfd1a2f46f75d", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 54, "deletions": 12, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/06f2d9da87ae4c5112cfa1540ae7ea15b76d3e5b/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f2d9da87ae4c5112cfa1540ae7ea15b76d3e5b/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=06f2d9da87ae4c5112cfa1540ae7ea15b76d3e5b", "patch": "@@ -2142,16 +2142,6 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &hir::EnumDef, sp: Span,\n     }\n }\n \n-pub struct TransItemVisitor<'a, 'tcx: 'a> {\n-    pub ccx: &'a CrateContext<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for TransItemVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &hir::Item) {\n-        trans_item(self.ccx, i);\n-    }\n-}\n-\n pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n     // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n     // applicable to variable declarations and may not really make sense for\n@@ -2963,10 +2953,12 @@ pub fn trans_crate<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // First, verify intrinsics.\n         intrinsic::check_intrinsics(&ccx);\n \n-        // Next, translate all items.\n+        // Next, translate all items. See `TransModVisitor` for\n+        // details on why we walk in this particular way.\n         {\n             let _icx = push_ctxt(\"text\");\n-            krate.visit_all_items(&mut TransItemVisitor { ccx: &ccx });\n+            intravisit::walk_mod(&mut TransItemsWithinModVisitor { ccx: &ccx }, &krate.module);\n+            krate.visit_all_items(&mut TransModVisitor { ccx: &ccx });\n         }\n     }\n \n@@ -3069,3 +3061,53 @@ pub fn trans_crate<'tcx>(tcx: &ty::ctxt<'tcx>,\n         no_builtins: no_builtins,\n     }\n }\n+\n+/// We visit all the items in the krate and translate them.  We do\n+/// this in two walks. The first walk just finds module items. It then\n+/// walks the full contents of those module items and translates all\n+/// the items within. Note that this entire process is O(n). The\n+/// reason for this two phased walk is that each module is\n+/// (potentially) placed into a distinct codegen-unit. This walk also\n+/// ensures that the immediate contents of each module is processed\n+/// entirely before we proceed to find more modules, helping to ensure\n+/// an equitable distribution amongst codegen-units.\n+pub struct TransModVisitor<'a, 'tcx: 'a> {\n+    pub ccx: &'a CrateContext<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for TransModVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &hir::Item) {\n+        match i.node {\n+            hir::ItemMod(_) => {\n+                let item_ccx = self.ccx.rotate();\n+                intravisit::walk_item(&mut TransItemsWithinModVisitor { ccx: &item_ccx }, i);\n+            }\n+            _ => { }\n+        }\n+    }\n+}\n+\n+/// Translates all the items within a given module. Expects owner to\n+/// invoke `walk_item` on a module item. Ignores nested modules.\n+pub struct TransItemsWithinModVisitor<'a, 'tcx: 'a> {\n+    pub ccx: &'a CrateContext<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for TransItemsWithinModVisitor<'a, 'tcx> {\n+    fn visit_nested_item(&mut self, item_id: hir::ItemId) {\n+        self.visit_item(self.ccx.tcx().map.expect_item(item_id.id));\n+    }\n+\n+    fn visit_item(&mut self, i: &hir::Item) {\n+        match i.node {\n+            hir::ItemMod(..) => {\n+                // skip modules, they will be uncovered by the TransModVisitor\n+            }\n+            _ => {\n+                trans_item(self.ccx, i);\n+                intravisit::walk_item(self, i);\n+            }\n+        }\n+    }\n+}\n+"}]}