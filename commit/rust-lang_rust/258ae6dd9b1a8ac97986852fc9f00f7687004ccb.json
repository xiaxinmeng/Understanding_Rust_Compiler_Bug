{"sha": "258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1OGFlNmRkOWIxYThhYzk3OTg2ODUyZmM5ZjAwZjc2ODcwMDRjY2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-15T12:37:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-15T12:37:54Z"}, "message": "Auto merge of #42648 - murarth:merge-alloc-collections, r=alexcrichton\n\nMerge crate `collections` into `alloc`\n\nThis is a necessary step in order to merge #42565", "tree": {"sha": "96936d0ba5ed7f62d1603a5e765f11f203b136c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96936d0ba5ed7f62d1603a5e765f11f203b136c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "html_url": "https://github.com/rust-lang/rust/commit/258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16c27bf713ac7c0afeada808e274c73e10eb96bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/16c27bf713ac7c0afeada808e274c73e10eb96bd", "html_url": "https://github.com/rust-lang/rust/commit/16c27bf713ac7c0afeada808e274c73e10eb96bd"}, {"sha": "eadda7665eb31b1e7cb94a503b4d5cf5c75474c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/eadda7665eb31b1e7cb94a503b4d5cf5c75474c0", "html_url": "https://github.com/rust-lang/rust/commit/eadda7665eb31b1e7cb94a503b4d5cf5c75474c0"}], "stats": {"total": 4863, "additions": 2347, "deletions": 2516}, "files": [{"sha": "5de710b68bbbad71ea4747c6b91e40de6592570d", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -36,6 +36,7 @@ name = \"alloc\"\n version = \"0.0.0\"\n dependencies = [\n  \"core 0.0.0\",\n+ \"std_unicode 0.0.0\",\n ]\n \n [[package]]\n@@ -250,15 +251,6 @@ dependencies = [\n  \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"collections\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"alloc 0.0.0\",\n- \"core 0.0.0\",\n- \"std_unicode 0.0.0\",\n-]\n-\n [[package]]\n name = \"compiler_builtins\"\n version = \"0.0.0\"\n@@ -1594,7 +1586,6 @@ dependencies = [\n  \"alloc_jemalloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"collections 0.0.0\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n  \"gcc 0.3.50 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "4d58620ca648c6328a9effb697915e97c333244c", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -376,8 +376,8 @@ pub fn debugger_scripts(build: &Build,\n         install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n             0o755);\n \n+        cp_debugger_script(\"natvis/liballoc.natvis\");\n         cp_debugger_script(\"natvis/libcore.natvis\");\n-        cp_debugger_script(\"natvis/libcollections.natvis\");\n     } else {\n         cp_debugger_script(\"debugger_pretty_printers_common.py\");\n \n@@ -550,7 +550,6 @@ pub fn rust_src(build: &Build) {\n         \"src/liballoc_jemalloc\",\n         \"src/liballoc_system\",\n         \"src/libbacktrace\",\n-        \"src/libcollections\",\n         \"src/libcompiler_builtins\",\n         \"src/libcore\",\n         \"src/liblibc\","}, {"sha": "fc75b6ff5c3a4ee3f073832fac8fb966f94f09ed", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -246,7 +246,7 @@ pub fn std(build: &Build, stage: u32, target: &str) {\n     // for which docs must be built.\n     if !build.config.compiler_docs {\n         cargo.arg(\"--no-deps\");\n-        for krate in &[\"alloc\", \"collections\", \"core\", \"std\", \"std_unicode\"] {\n+        for krate in &[\"alloc\", \"core\", \"std\", \"std_unicode\"] {\n             cargo.arg(\"-p\").arg(krate);\n             // Create all crate output directories first to make sure rustdoc uses\n             // relative links."}, {"sha": "64bbb104f68e442f69c2cf7c74f0985d78283a71", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -110,7 +110,6 @@\n     - [coerce_unsized](library-features/coerce-unsized.md)\n     - [collection_placement](library-features/collection-placement.md)\n     - [collections_range](library-features/collections-range.md)\n-    - [collections](library-features/collections.md)\n     - [command_envs](library-features/command-envs.md)\n     - [compiler_builtins_lib](library-features/compiler-builtins-lib.md)\n     - [compiler_fences](library-features/compiler-fences.md)"}, {"sha": "5c937833c9e26a4489893b4680a58285f3833a37", "filename": "src/doc/unstable-book/src/library-features/collections.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16c27bf713ac7c0afeada808e274c73e10eb96bd/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcollections.md", "raw_url": "https://github.com/rust-lang/rust/raw/16c27bf713ac7c0afeada808e274c73e10eb96bd/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcollections.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcollections.md?ref=16c27bf713ac7c0afeada808e274c73e10eb96bd", "patch": "@@ -1,5 +0,0 @@\n-# `collections`\n-\n-This feature is internal to the Rust compiler and is not intended for general use.\n-\n-------------------------"}, {"sha": "1f6d17748ab00d1d6fd5b51fc7f7c438ec25103f", "filename": "src/etc/natvis/liballoc.natvis", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fliballoc.natvis?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -1,6 +1,6 @@\n <?xml version=\"1.0\" encoding=\"utf-8\"?>\n <AutoVisualizer xmlns=\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\">\n-  <Type Name=\"collections::vec::Vec&lt;*&gt;\">\n+  <Type Name=\"alloc::vec::Vec&lt;*&gt;\">\n     <DisplayString>{{ size={len} }}</DisplayString>\n     <Expand>\n       <Item Name=\"[size]\" ExcludeView=\"simple\">len</Item>\n@@ -11,7 +11,7 @@\n       </ArrayItems>\n     </Expand>\n   </Type>\n-  <Type Name=\"collections::vec_deque::VecDeque&lt;*&gt;\">\n+  <Type Name=\"alloc::vec_deque::VecDeque&lt;*&gt;\">\n     <DisplayString>{{ size={tail &lt;= head ? head - tail : buf.cap - tail + head} }}</DisplayString>\n     <Expand>\n       <Item Name=\"[size]\" ExcludeView=\"simple\">tail &lt;= head ? head - tail : buf.cap - tail + head</Item>\n@@ -30,18 +30,18 @@\n       </CustomListItems>\n     </Expand>\n   </Type>\n-  <Type Name=\"collections::linked_list::LinkedList&lt;*&gt;\">\n+  <Type Name=\"alloc::linked_list::LinkedList&lt;*&gt;\">\n     <DisplayString>{{ size={len} }}</DisplayString>\n     <Expand>\n       <LinkedListItems>\n         <Size>len</Size>\n-        <HeadPointer>*(collections::linked_list::Node&lt;$T1&gt; **)&amp;head</HeadPointer>\n-        <NextPointer>*(collections::linked_list::Node&lt;$T1&gt; **)&amp;next</NextPointer>\n+        <HeadPointer>*(alloc::linked_list::Node&lt;$T1&gt; **)&amp;head</HeadPointer>\n+        <NextPointer>*(alloc::linked_list::Node&lt;$T1&gt; **)&amp;next</NextPointer>\n         <ValueNode>element</ValueNode>\n       </LinkedListItems>\n     </Expand>\n   </Type>\n-  <Type Name=\"collections::string::String\">\n+  <Type Name=\"alloc::string::String\">\n     <DisplayString>{*(char**)this,[vec.len]}</DisplayString>\n     <StringView>*(char**)this,[vec.len]</StringView>\n     <Expand>\n@@ -53,4 +53,4 @@\n       </ArrayItems>\n     </Expand>\n   </Type>\n-</AutoVisualizer>\n\\ No newline at end of file\n+</AutoVisualizer>", "previous_filename": "src/etc/natvis/libcollections.natvis"}, {"sha": "b09b37c1db423080bd47f8f31155f57f14cb2e32", "filename": "src/etc/rust-windbg.cmd", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fetc%2Frust-windbg.cmd", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fetc%2Frust-windbg.cmd", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-windbg.cmd?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -15,4 +15,4 @@ for /f \"delims=\" %%i in ('rustc --print=sysroot') do set rustc_sysroot=%%i\n \n set rust_etc=%rustc_sysroot%\\lib\\rustlib\\etc\n \n-windbg -c \".nvload %rust_etc%\\libcore.natvis;.nvload %rust_etc%\\libcollections.natvis;\" %*\n\\ No newline at end of file\n+windbg -c \".nvload %rust_etc%\\liballoc.natvis; .nvload %rust_etc%\\libcore.natvis;\" %*"}, {"sha": "686e5681d12b4c68625467efb04c3f3a0c424045", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -9,3 +9,12 @@ path = \"lib.rs\"\n \n [dependencies]\n core = { path = \"../libcore\" }\n+std_unicode = { path = \"../libstd_unicode\" }\n+\n+[[test]]\n+name = \"collectionstests\"\n+path = \"../liballoc/tests/lib.rs\"\n+\n+[[bench]]\n+name = \"collectionsbenches\"\n+path = \"../liballoc/benches/lib.rs\""}, {"sha": "7c51c4b161ca861693e07cfed920fe8b5b0b1935", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -1222,11 +1222,12 @@ mod tests {\n     use std::sync::atomic;\n     use std::sync::atomic::Ordering::{Acquire, SeqCst};\n     use std::thread;\n-    use std::vec::Vec;\n-    use super::{Arc, Weak};\n     use std::sync::Mutex;\n     use std::convert::From;\n \n+    use super::{Arc, Weak};\n+    use vec::Vec;\n+\n     struct Canary(*mut atomic::AtomicUsize);\n \n     impl Drop for Canary {"}, {"sha": "744afb991b00e99ebf4eff3cc8c7836796d6139c", "filename": "src/liballoc/benches/btree/map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/benches/btree/map.rs"}, {"sha": "f436b0ac0c0375063da64723236781c25f628b41", "filename": "src/liballoc/benches/btree/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmod.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/benches/btree/mod.rs"}, {"sha": "958020d0b0e0c33e3b70b803f187fc204c0f84bb", "filename": "src/liballoc/benches/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/benches/lib.rs"}, {"sha": "bbac44553f18a267bfd7b016a3677d5e3e77ede5", "filename": "src/liballoc/benches/linked_list.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flinked_list.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/benches/linked_list.rs"}, {"sha": "aa5a438b35e62341e5611755f233b1b12c7c830e", "filename": "src/liballoc/benches/slice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/benches/slice.rs"}, {"sha": "fc4063fae927754353d5e736099f0a365b0dd2d7", "filename": "src/liballoc/benches/str.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fstr.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/benches/str.rs"}, {"sha": "36be21d978e1fdac8574e031a233a2915d062762", "filename": "src/liballoc/benches/string.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fstring.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/benches/string.rs"}, {"sha": "414901170683effec41392bb7c3002e44a156d5a", "filename": "src/liballoc/benches/vec.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/benches/vec.rs"}, {"sha": "380645e7cd03a9236f31f2ff4cdd88b61fa54aac", "filename": "src/liballoc/benches/vec_deque.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec_deque.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/benches/vec_deque.rs"}, {"sha": "988f88516255731e47a4f43cb9cdc9987b574afc", "filename": "src/liballoc/binary_heap.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbinary_heap.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/binary_heap.rs"}, {"sha": "a662e4b1f4f931de28292c8ed094f559e4d0b031", "filename": "src/liballoc/borrow.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/borrow.rs"}, {"sha": "2f867912f582468c7fdf70589a10b8a29d9a980f", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -95,6 +95,7 @@ pub const HEAP: ExchangeHeapSingleton = ExchangeHeapSingleton { _force_singleton\n #[unstable(feature = \"box_heap\",\n            reason = \"may be renamed; uncertain about custom allocator design\",\n            issue = \"27779\")]\n+#[allow(missing_debug_implementations)]\n #[derive(Copy, Clone)]\n pub struct ExchangeHeapSingleton {\n     _force_singleton: (),\n@@ -129,6 +130,7 @@ pub struct Box<T: ?Sized>(Unique<T>);\n #[unstable(feature = \"placement_in\",\n            reason = \"placement box design is still being worked out.\",\n            issue = \"27779\")]\n+#[allow(missing_debug_implementations)]\n pub struct IntermediateBox<T: ?Sized> {\n     ptr: *mut u8,\n     size: usize,"}, {"sha": "d73c0254a74574221e1cd44d9ff12fe858cf588d", "filename": "src/liballoc/btree/map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/btree/map.rs"}, {"sha": "087c9f228d4448bb6c119675ce28eac9e354a6b4", "filename": "src/liballoc/btree/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmod.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/btree/mod.rs"}, {"sha": "811174b331e2b3669fa4bd9477fc6ecfbc23047f", "filename": "src/liballoc/btree/node.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -41,14 +41,14 @@\n // - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n //   This implies that even an empty internal node has at least one edge.\n \n-use alloc::heap;\n use core::marker::PhantomData;\n use core::mem;\n use core::nonzero::NonZero;\n use core::ptr::{self, Unique};\n use core::slice;\n \n use boxed::Box;\n+use heap;\n \n const B: usize = 6;\n pub const MIN_LEN: usize = B - 1;", "previous_filename": "src/libcollections/btree/node.rs"}, {"sha": "bc1272fbc786e7aa4c2c9e39e24345c3a84f68a4", "filename": "src/liballoc/btree/search.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fsearch.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/btree/search.rs"}, {"sha": "d32460da9392342e12834e28d1e5684956297b0a", "filename": "src/liballoc/btree/set.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fset.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/btree/set.rs"}, {"sha": "62a88164621913fd494c67488ce5f1c720dada64", "filename": "src/liballoc/fmt.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/fmt.rs"}, {"sha": "5252dabc12791d1b2ab308892c85fae7a9f688c1", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 150, "deletions": 10, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014-2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,18 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! # The Rust core allocation library\n+//! # The Rust core allocation and collections library\n //!\n-//! This is the lowest level library through which allocation in Rust can be\n-//! performed.\n+//! This library provides smart pointers and collections for managing\n+//! heap-allocated values.\n //!\n //! This library, like libcore, is not intended for general usage, but rather as\n //! a building block of other libraries. The types and interfaces in this\n //! library are reexported through the [standard library](../std/index.html),\n //! and should not be used through this library.\n //!\n-//! Currently, there are four major definitions in this library.\n-//!\n //! ## Boxed values\n //!\n //! The [`Box`](boxed/index.html) type is a smart pointer type. There can\n@@ -51,6 +49,12 @@\n //! paired with synchronization primitives such as mutexes to allow mutation of\n //! shared resources.\n //!\n+//! ## Collections\n+//!\n+//! Implementations of the most common general purpose data structures are\n+//! defined in this library. They are reexported through the\n+//! [standard collections library](../std/collections/index.html).\n+//!\n //! ## Heap interfaces\n //!\n //! The [`heap`](heap/index.html) module defines the low-level interface to the\n@@ -71,25 +75,54 @@\n #![no_std]\n #![needs_allocator]\n #![deny(warnings)]\n+#![deny(missing_debug_implementations)]\n \n+#![cfg_attr(test, allow(deprecated))] // rand\n+#![cfg_attr(test, feature(placement_in))]\n+#![cfg_attr(not(test), feature(char_escape_debug))]\n+#![cfg_attr(not(test), feature(core_float))]\n+#![cfg_attr(not(test), feature(exact_size_is_empty))]\n+#![cfg_attr(not(test), feature(slice_rotate))]\n+#![cfg_attr(not(test), feature(sort_unstable))]\n+#![cfg_attr(not(test), feature(str_checked_slicing))]\n+#![cfg_attr(test, feature(rand, test))]\n #![feature(allocator)]\n+#![feature(allow_internal_unstable)]\n+#![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(custom_attribute)]\n #![feature(dropck_eyepatch)]\n-#![cfg_attr(not(test), feature(exact_size_is_empty))]\n+#![feature(exact_size_is_empty)]\n+#![feature(fmt_internals)]\n #![feature(fundamental)]\n+#![feature(fused)]\n #![feature(generic_param_attrs)]\n+#![feature(i128_type)]\n+#![feature(inclusive_range)]\n #![feature(lang_items)]\n+#![feature(manually_drop)]\n #![feature(needs_allocator)]\n+#![feature(nonzero)]\n+#![feature(offset_to)]\n #![feature(optin_builtin_traits)]\n+#![feature(pattern)]\n #![feature(placement_in_syntax)]\n+#![feature(placement_new_protocol)]\n #![feature(shared)]\n+#![feature(slice_get_slice)]\n+#![feature(slice_patterns)]\n+#![feature(slice_rsplit)]\n+#![feature(specialization)]\n #![feature(staged_api)]\n+#![feature(str_internals)]\n+#![feature(str_mut_extras)]\n+#![feature(trusted_len)]\n #![feature(unboxed_closures)]\n+#![feature(unicode)]\n #![feature(unique)]\n #![feature(unsize)]\n \n@@ -101,6 +134,10 @@\n #[cfg(test)]\n #[macro_use]\n extern crate std;\n+#[cfg(test)]\n+extern crate test;\n+\n+extern crate std_unicode;\n \n // Module with internal macros used by other modules (needs to be included before other modules).\n #[macro_use]\n@@ -120,16 +157,119 @@ pub mod heap;\n pub mod boxed;\n #[cfg(test)]\n mod boxed {\n-    pub use std::boxed::{Box, HEAP};\n+    pub use std::boxed::{Box, IntermediateBox, HEAP};\n }\n #[cfg(test)]\n mod boxed_test;\n #[cfg(target_has_atomic = \"ptr\")]\n pub mod arc;\n pub mod rc;\n pub mod raw_vec;\n-#[unstable(feature = \"str_box_extras\", issue = \"41119\")]\n-pub mod str;\n pub mod oom;\n \n+// collections modules\n+pub mod binary_heap;\n+mod btree;\n+pub mod borrow;\n+pub mod fmt;\n+pub mod linked_list;\n+pub mod range;\n+pub mod slice;\n+pub mod str;\n+pub mod string;\n+pub mod vec;\n+pub mod vec_deque;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub mod btree_map {\n+    //! A map based on a B-Tree.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use btree::map::*;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub mod btree_set {\n+    //! A set based on a B-Tree.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use btree::set::*;\n+}\n+\n+#[cfg(not(test))]\n+mod std {\n+    pub use core::ops;      // RangeFull\n+}\n+\n+/// An endpoint of a range of keys.\n+///\n+/// # Examples\n+///\n+/// `Bound`s are range endpoints:\n+///\n+/// ```\n+/// #![feature(collections_range)]\n+///\n+/// use std::collections::range::RangeArgument;\n+/// use std::collections::Bound::*;\n+///\n+/// assert_eq!((..100).start(), Unbounded);\n+/// assert_eq!((1..12).start(), Included(&1));\n+/// assert_eq!((1..12).end(), Excluded(&12));\n+/// ```\n+///\n+/// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n+/// Note that in most cases, it's better to use range syntax (`1..5`) instead.\n+///\n+/// ```\n+/// use std::collections::BTreeMap;\n+/// use std::collections::Bound::{Excluded, Included, Unbounded};\n+///\n+/// let mut map = BTreeMap::new();\n+/// map.insert(3, \"a\");\n+/// map.insert(5, \"b\");\n+/// map.insert(8, \"c\");\n+///\n+/// for (key, value) in map.range((Excluded(3), Included(8))) {\n+///     println!(\"{}: {}\", key, value);\n+/// }\n+///\n+/// assert_eq!(Some((&3, &\"a\")), map.range((Unbounded, Included(5))).next());\n+/// ```\n+///\n+/// [`BTreeMap::range`]: btree_map/struct.BTreeMap.html#method.range\n+#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n+pub enum Bound<T> {\n+    /// An inclusive bound.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Included(T),\n+    /// An exclusive bound.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Excluded(T),\n+    /// An infinite endpoint. Indicates that there is no bound in this direction.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Unbounded,\n+}\n+\n+/// An intermediate trait for specialization of `Extend`.\n+#[doc(hidden)]\n+trait SpecExtend<I: IntoIterator> {\n+    /// Extends `self` with the contents of the given iterator.\n+    fn spec_extend(&mut self, iter: I);\n+}\n+\n pub use oom::oom;\n+\n+#[doc(no_inline)]\n+pub use binary_heap::BinaryHeap;\n+#[doc(no_inline)]\n+pub use btree_map::BTreeMap;\n+#[doc(no_inline)]\n+pub use btree_set::BTreeSet;\n+#[doc(no_inline)]\n+pub use linked_list::LinkedList;\n+#[doc(no_inline)]\n+pub use vec_deque::VecDeque;\n+#[doc(no_inline)]\n+pub use string::String;\n+#[doc(no_inline)]\n+pub use vec::Vec;"}, {"sha": "e8973b7d28537fa99d6eb49471afa021a1f441b1", "filename": "src/liballoc/linked_list.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -22,7 +22,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use alloc::boxed::{Box, IntermediateBox};\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n@@ -32,6 +31,7 @@ use core::mem;\n use core::ops::{BoxPlace, InPlace, Place, Placer};\n use core::ptr::{self, Shared};\n \n+use boxed::{Box, IntermediateBox};\n use super::SpecExtend;\n \n /// A doubly-linked list with owned nodes.", "previous_filename": "src/libcollections/linked_list.rs"}, {"sha": "763f04fcd0dcddb698170e89d1fb2d9f45e644d0", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,6 +8,89 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/// Creates a `Vec` containing the arguments.\n+///\n+/// `vec!` allows `Vec`s to be defined with the same syntax as array expressions.\n+/// There are two forms of this macro:\n+///\n+/// - Create a `Vec` containing a given list of elements:\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+/// assert_eq!(v[0], 1);\n+/// assert_eq!(v[1], 2);\n+/// assert_eq!(v[2], 3);\n+/// ```\n+///\n+/// - Create a `Vec` from a given element and size:\n+///\n+/// ```\n+/// let v = vec![1; 3];\n+/// assert_eq!(v, [1, 1, 1]);\n+/// ```\n+///\n+/// Note that unlike array expressions this syntax supports all elements\n+/// which implement `Clone` and the number of elements doesn't have to be\n+/// a constant.\n+///\n+/// This will use `clone()` to duplicate an expression, so one should be careful\n+/// using this with types having a nonstandard `Clone` implementation. For\n+/// example, `vec![Rc::new(1); 5]` will create a vector of five references\n+/// to the same boxed integer value, not five references pointing to independently\n+/// boxed integers.\n+#[cfg(not(test))]\n+#[macro_export]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow_internal_unstable]\n+macro_rules! vec {\n+    ($elem:expr; $n:expr) => (\n+        $crate::vec::from_elem($elem, $n)\n+    );\n+    ($($x:expr),*) => (\n+        <[_]>::into_vec(box [$($x),*])\n+    );\n+    ($($x:expr,)*) => (vec![$($x),*])\n+}\n+\n+// HACK(japaric): with cfg(test) the inherent `[T]::into_vec` method, which is\n+// required for this macro definition, is not available. Instead use the\n+// `slice::into_vec`  function which is only available with cfg(test)\n+// NB see the slice::hack module in slice.rs for more information\n+#[cfg(test)]\n+macro_rules! vec {\n+    ($elem:expr; $n:expr) => (\n+        $crate::vec::from_elem($elem, $n)\n+    );\n+    ($($x:expr),*) => (\n+        $crate::slice::into_vec(box [$($x),*])\n+    );\n+    ($($x:expr,)*) => (vec![$($x),*])\n+}\n+\n+/// Use the syntax described in `std::fmt` to create a value of type `String`.\n+/// See [`std::fmt`][fmt] for more information.\n+///\n+/// [fmt]: ../std/fmt/index.html\n+///\n+/// # Panics\n+///\n+/// `format!` panics if a formatting trait implementation returns an error.\n+/// This indicates an incorrect implementation\n+/// since `fmt::Write for String` never returns an error itself.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// format!(\"test\");\n+/// format!(\"hello {}\", \"world!\");\n+/// format!(\"x = {}, y = {y}\", 10, y = 30);\n+/// ```\n+#[macro_export]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+macro_rules! format {\n+    ($($arg:tt)*) => ($crate::fmt::format(format_args!($($arg)*)))\n+}\n+\n // Private macro to get the offset of a struct field in bytes from the address of the struct.\n macro_rules! offset_of {\n     ($container:path, $field:ident) => {{"}, {"sha": "f862da0d61e012ed816811947a14f3fcab5005a5", "filename": "src/liballoc/range.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frange.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -27,14 +27,14 @@ pub trait RangeArgument<T: ?Sized> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(collections)]\n+    /// #![feature(alloc)]\n     /// #![feature(collections_range)]\n     ///\n-    /// extern crate collections;\n+    /// extern crate alloc;\n     ///\n     /// # fn main() {\n-    /// use collections::range::RangeArgument;\n-    /// use collections::Bound::*;\n+    /// use alloc::range::RangeArgument;\n+    /// use alloc::Bound::*;\n     ///\n     /// assert_eq!((..10).start(), Unbounded);\n     /// assert_eq!((3..10).start(), Included(&3));\n@@ -49,14 +49,14 @@ pub trait RangeArgument<T: ?Sized> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(collections)]\n+    /// #![feature(alloc)]\n     /// #![feature(collections_range)]\n     ///\n-    /// extern crate collections;\n+    /// extern crate alloc;\n     ///\n     /// # fn main() {\n-    /// use collections::range::RangeArgument;\n-    /// use collections::Bound::*;\n+    /// use alloc::range::RangeArgument;\n+    /// use alloc::Bound::*;\n     ///\n     /// assert_eq!((3..).end(), Unbounded);\n     /// assert_eq!((3..10).end(), Excluded(&10));", "previous_filename": "src/libcollections/range.rs"}, {"sha": "34ab0a19d4e0963035ee21189a15449c262e4024", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -44,6 +44,7 @@ use core::cmp;\n /// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n+#[allow(missing_debug_implementations)]\n pub struct RawVec<T> {\n     ptr: Unique<T>,\n     cap: usize,"}, {"sha": "88876999d765afc04b8be737998491ff330c0951", "filename": "src/liballoc/slice.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -97,14 +97,14 @@\n // It's cleaner to just turn off the unused_imports warning than to fix them.\n #![cfg_attr(test, allow(unused_imports, dead_code))]\n \n-use alloc::boxed::Box;\n use core::cmp::Ordering::{self, Less};\n use core::mem::size_of;\n use core::mem;\n use core::ptr;\n use core::slice as core_slice;\n \n use borrow::{Borrow, BorrowMut, ToOwned};\n+use boxed::Box;\n use vec::Vec;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -141,7 +141,7 @@ pub use self::hack::to_vec;\n // `core::slice::SliceExt` - we need to supply these functions for the\n // `test_permutations` test\n mod hack {\n-    use alloc::boxed::Box;\n+    use boxed::Box;\n     use core::mem;\n \n     #[cfg(test)]", "previous_filename": "src/libcollections/slice.rs"}, {"sha": "f56288c30132c13e52196507acfcf17247c40aa7", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 1982, "deletions": 1, "changes": 1983, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,11 +8,1992 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Methods for dealing with boxed strings.\n+//! Unicode string slices.\n+//!\n+//! The `&str` type is one of the two main string types, the other being `String`.\n+//! Unlike its `String` counterpart, its contents are borrowed.\n+//!\n+//! # Basic Usage\n+//!\n+//! A basic string declaration of `&str` type:\n+//!\n+//! ```\n+//! let hello_world = \"Hello, World!\";\n+//! ```\n+//!\n+//! Here we have declared a string literal, also known as a string slice.\n+//! String literals have a static lifetime, which means the string `hello_world`\n+//! is guaranteed to be valid for the duration of the entire program.\n+//! We can explicitly specify `hello_world`'s lifetime as well:\n+//!\n+//! ```\n+//! let hello_world: &'static str = \"Hello, world!\";\n+//! ```\n+//!\n+//! *[See also the `str` primitive type](../../std/primitive.str.html).*\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+// Many of the usings in this module are only used in the test configuration.\n+// It's cleaner to just turn off the unused_imports warning than to fix them.\n+#![allow(unused_imports)]\n+\n+use core::fmt;\n+use core::str as core_str;\n+use core::str::pattern::Pattern;\n+use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n+use core::iter::FusedIterator;\n+use std_unicode::str::{UnicodeStr, Utf16Encoder};\n \n+use vec_deque::VecDeque;\n+use borrow::{Borrow, ToOwned};\n+use string::String;\n+use std_unicode;\n+use vec::Vec;\n+use slice::{SliceConcatExt, SliceIndex};\n use boxed::Box;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{FromStr, Utf8Error};\n+#[allow(deprecated)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{Lines, LinesAny};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{Split, RSplit};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{SplitN, RSplitN};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{SplitTerminator, RSplitTerminator};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{Matches, RMatches};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{MatchIndices, RMatchIndices};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{from_utf8, from_utf8_mut, Chars, CharIndices, Bytes};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::{from_utf8_unchecked, from_utf8_unchecked_mut, ParseBoolError};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use std_unicode::str::SplitWhitespace;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::str::pattern;\n+\n+\n+#[unstable(feature = \"slice_concat_ext\",\n+           reason = \"trait should not have to exist\",\n+           issue = \"27747\")]\n+impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n+    type Output = String;\n+\n+    fn concat(&self) -> String {\n+        if self.is_empty() {\n+            return String::new();\n+        }\n+\n+        // `len` calculation may overflow but push_str will check boundaries\n+        let len = self.iter().map(|s| s.borrow().len()).sum();\n+        let mut result = String::with_capacity(len);\n+\n+        for s in self {\n+            result.push_str(s.borrow())\n+        }\n+\n+        result\n+    }\n+\n+    fn join(&self, sep: &str) -> String {\n+        if self.is_empty() {\n+            return String::new();\n+        }\n+\n+        // concat is faster\n+        if sep.is_empty() {\n+            return self.concat();\n+        }\n+\n+        // this is wrong without the guarantee that `self` is non-empty\n+        // `len` calculation may overflow but push_str but will check boundaries\n+        let len = sep.len() * (self.len() - 1) +\n+                  self.iter().map(|s| s.borrow().len()).sum::<usize>();\n+        let mut result = String::with_capacity(len);\n+        let mut first = true;\n+\n+        for s in self {\n+            if first {\n+                first = false;\n+            } else {\n+                result.push_str(sep);\n+            }\n+            result.push_str(s.borrow());\n+        }\n+        result\n+    }\n+\n+    fn connect(&self, sep: &str) -> String {\n+        self.join(sep)\n+    }\n+}\n+\n+/// An iterator of [`u16`] over the string encoded as UTF-16.\n+///\n+/// [`u16`]: ../../std/primitive.u16.html\n+///\n+/// This struct is created by the [`encode_utf16`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`encode_utf16`]: ../../std/primitive.str.html#method.encode_utf16\n+/// [`str`]: ../../std/primitive.str.html\n+#[derive(Clone)]\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+pub struct EncodeUtf16<'a> {\n+    encoder: Utf16Encoder<Chars<'a>>,\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<'a> fmt::Debug for EncodeUtf16<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"EncodeUtf16 { .. }\")\n+    }\n+}\n+\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+impl<'a> Iterator for EncodeUtf16<'a> {\n+    type Item = u16;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<u16> {\n+        self.encoder.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.encoder.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<'a> FusedIterator for EncodeUtf16<'a> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Borrow<str> for String {\n+    #[inline]\n+    fn borrow(&self) -> &str {\n+        &self[..]\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ToOwned for str {\n+    type Owned = String;\n+    fn to_owned(&self) -> String {\n+        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }\n+    }\n+\n+    fn clone_into(&self, target: &mut String) {\n+        let mut b = mem::replace(target, String::new()).into_bytes();\n+        self.as_bytes().clone_into(&mut b);\n+        *target = unsafe { String::from_utf8_unchecked(b) }\n+    }\n+}\n+\n+/// Methods for string slices.\n+#[lang = \"str\"]\n+#[cfg(not(test))]\n+impl str {\n+    /// Returns the length of `self`.\n+    ///\n+    /// This length is in bytes, not [`char`]s or graphemes. In other words,\n+    /// it may not be what a human considers the length of the string.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let len = \"foo\".len();\n+    /// assert_eq!(3, len);\n+    ///\n+    /// let len = \"\u0192oo\".len(); // fancy f!\n+    /// assert_eq!(4, len);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        core_str::StrExt::len(self)\n+    }\n+\n+    /// Returns `true` if `self` has a length of zero bytes.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"\";\n+    /// assert!(s.is_empty());\n+    ///\n+    /// let s = \"not empty\";\n+    /// assert!(!s.is_empty());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_empty(&self) -> bool {\n+        core_str::StrExt::is_empty(self)\n+    }\n+\n+    /// Checks that `index`-th byte lies at the start and/or end of a\n+    /// UTF-8 code point sequence.\n+    ///\n+    /// The start and end of the string (when `index == self.len()`) are\n+    /// considered to be\n+    /// boundaries.\n+    ///\n+    /// Returns `false` if `index` is greater than `self.len()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert!(s.is_char_boundary(0));\n+    /// // start of `\u8001`\n+    /// assert!(s.is_char_boundary(6));\n+    /// assert!(s.is_char_boundary(s.len()));\n+    ///\n+    /// // second byte of `\u00f6`\n+    /// assert!(!s.is_char_boundary(2));\n+    ///\n+    /// // third byte of `\u8001`\n+    /// assert!(!s.is_char_boundary(8));\n+    /// ```\n+    #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n+    #[inline]\n+    pub fn is_char_boundary(&self, index: usize) -> bool {\n+        core_str::StrExt::is_char_boundary(self, index)\n+    }\n+\n+    /// Converts a string slice to a byte slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bytes = \"bors\".as_bytes();\n+    /// assert_eq!(b\"bors\", bytes);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline(always)]\n+    pub fn as_bytes(&self) -> &[u8] {\n+        core_str::StrExt::as_bytes(self)\n+    }\n+\n+    /// Converts a mutable string slice to a mutable byte slice.\n+    #[unstable(feature = \"str_mut_extras\", issue = \"41119\")]\n+    #[inline(always)]\n+    pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n+        core_str::StrExt::as_bytes_mut(self)\n+    }\n+\n+    /// Converts a string slice to a raw pointer.\n+    ///\n+    /// As string slices are a slice of bytes, the raw pointer points to a\n+    /// [`u8`]. This pointer will be pointing to the first byte of the string\n+    /// slice.\n+    ///\n+    /// [`u8`]: primitive.u8.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"Hello\";\n+    /// let ptr = s.as_ptr();\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn as_ptr(&self) -> *const u8 {\n+        core_str::StrExt::as_ptr(self)\n+    }\n+\n+    /// Returns a subslice of `str`.\n+    ///\n+    /// This is the non-panicking alternative to indexing the `str`. Returns\n+    /// [`None`] whenever equivalent indexing operation would panic.\n+    ///\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n+    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get(0..4));\n+    /// assert!(v.get(1..).is_none());\n+    /// assert!(v.get(..8).is_none());\n+    /// assert!(v.get(..42).is_none());\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    #[inline]\n+    pub fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n+        core_str::StrExt::get(self, i)\n+    }\n+\n+    /// Returns a mutable subslice of `str`.\n+    ///\n+    /// This is the non-panicking alternative to indexing the `str`. Returns\n+    /// [`None`] whenever equivalent indexing operation would panic.\n+    ///\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get_mut(0..4).map(|v| &*v));\n+    /// assert!(v.get_mut(1..).is_none());\n+    /// assert!(v.get_mut(..8).is_none());\n+    /// assert!(v.get_mut(..42).is_none());\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    #[inline]\n+    pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n+        core_str::StrExt::get_mut(self, i)\n+    }\n+\n+    /// Returns a unchecked subslice of `str`.\n+    ///\n+    /// This is the unchecked alternative to indexing the `str`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that these preconditions are\n+    /// satisfied:\n+    ///\n+    /// * The starting index must come before the ending index;\n+    /// * Indexes must be within bounds of the original slice;\n+    /// * Indexes must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// Failing that, the returned string slice may reference invalid memory or\n+    /// violate the invariants communicated by the `str` type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n+    /// unsafe {\n+    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked(0..4));\n+    ///     assert_eq!(\"\u2208\", v.get_unchecked(4..7));\n+    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked(7..11));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n+        core_str::StrExt::get_unchecked(self, i)\n+    }\n+\n+    /// Returns a mutable, unchecked subslice of `str`.\n+    ///\n+    /// This is the unchecked alternative to indexing the `str`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that these preconditions are\n+    /// satisfied:\n+    ///\n+    /// * The starting index must come before the ending index;\n+    /// * Indexes must be within bounds of the original slice;\n+    /// * Indexes must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// Failing that, the returned string slice may reference invalid memory or\n+    /// violate the invariants communicated by the `str` type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    /// unsafe {\n+    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked_mut(0..4));\n+    ///     assert_eq!(\"\u2208\", v.get_unchecked_mut(4..7));\n+    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked_mut(7..11));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n+        core_str::StrExt::get_unchecked_mut(self, i)\n+    }\n+\n+    /// Creates a string slice from another string slice, bypassing safety\n+    /// checks.\n+    ///\n+    /// This is generally not recommended, use with caution! For a safe\n+    /// alternative see [`str`] and [`Index`].\n+    ///\n+    /// [`str`]: primitive.str.html\n+    /// [`Index`]: ops/trait.Index.html\n+    ///\n+    /// This new slice goes from `begin` to `end`, including `begin` but\n+    /// excluding `end`.\n+    ///\n+    /// To get a mutable string slice instead, see the\n+    /// [`slice_mut_unchecked`] method.\n+    ///\n+    /// [`slice_mut_unchecked`]: #method.slice_mut_unchecked\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that three preconditions are\n+    /// satisfied:\n+    ///\n+    /// * `begin` must come before `end`.\n+    /// * `begin` and `end` must be byte positions within the string slice.\n+    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(\"L\u00f6we \u8001\u864e L\u00e9opard\", s.slice_unchecked(0, 21));\n+    /// }\n+    ///\n+    /// let s = \"Hello, world!\";\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(\"world\", s.slice_unchecked(7, 12));\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n+        core_str::StrExt::slice_unchecked(self, begin, end)\n+    }\n+\n+    /// Creates a string slice from another string slice, bypassing safety\n+    /// checks.\n+    /// This is generally not recommended, use with caution! For a safe\n+    /// alternative see [`str`] and [`IndexMut`].\n+    ///\n+    /// [`str`]: primitive.str.html\n+    /// [`IndexMut`]: ops/trait.IndexMut.html\n+    ///\n+    /// This new slice goes from `begin` to `end`, including `begin` but\n+    /// excluding `end`.\n+    ///\n+    /// To get an immutable string slice instead, see the\n+    /// [`slice_unchecked`] method.\n+    ///\n+    /// [`slice_unchecked`]: #method.slice_unchecked\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that three preconditions are\n+    /// satisfied:\n+    ///\n+    /// * `begin` must come before `end`.\n+    /// * `begin` and `end` must be byte positions within the string slice.\n+    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n+    #[stable(feature = \"str_slice_mut\", since = \"1.5.0\")]\n+    #[inline]\n+    pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n+        core_str::StrExt::slice_mut_unchecked(self, begin, end)\n+    }\n+\n+    /// Divide one string slice into two at an index.\n+    ///\n+    /// The argument, `mid`, should be a byte offset from the start of the\n+    /// string. It must also be on the boundary of a UTF-8 code point.\n+    ///\n+    /// The two slices returned go from the start of the string slice to `mid`,\n+    /// and from `mid` to the end of the string slice.\n+    ///\n+    /// To get mutable string slices instead, see the [`split_at_mut`]\n+    /// method.\n+    ///\n+    /// [`split_at_mut`]: #method.split_at_mut\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n+    /// beyond the last code point of the string slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"Per Martin-L\u00f6f\";\n+    ///\n+    /// let (first, last) = s.split_at(3);\n+    ///\n+    /// assert_eq!(\"Per\", first);\n+    /// assert_eq!(\" Martin-L\u00f6f\", last);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n+    pub fn split_at(&self, mid: usize) -> (&str, &str) {\n+        core_str::StrExt::split_at(self, mid)\n+    }\n+\n+    /// Divide one mutable string slice into two at an index.\n+    ///\n+    /// The argument, `mid`, should be a byte offset from the start of the\n+    /// string. It must also be on the boundary of a UTF-8 code point.\n+    ///\n+    /// The two slices returned go from the start of the string slice to `mid`,\n+    /// and from `mid` to the end of the string slice.\n+    ///\n+    /// To get immutable string slices instead, see the [`split_at`] method.\n+    ///\n+    /// [`split_at`]: #method.split_at\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n+    /// beyond the last code point of the string slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut s = \"Per Martin-L\u00f6f\".to_string();\n+    ///\n+    /// let (first, last) = s.split_at_mut(3);\n+    ///\n+    /// assert_eq!(\"Per\", first);\n+    /// assert_eq!(\" Martin-L\u00f6f\", last);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n+    pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n+        core_str::StrExt::split_at_mut(self, mid)\n+    }\n+\n+    /// Returns an iterator over the [`char`]s of a string slice.\n+    ///\n+    /// As a string slice consists of valid UTF-8, we can iterate through a\n+    /// string slice by [`char`]. This method returns such an iterator.\n+    ///\n+    /// It's important to remember that [`char`] represents a Unicode Scalar\n+    /// Value, and may not match your idea of what a 'character' is. Iteration\n+    /// over grapheme clusters may be what you actually want.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let word = \"goodbye\";\n+    ///\n+    /// let count = word.chars().count();\n+    /// assert_eq!(7, count);\n+    ///\n+    /// let mut chars = word.chars();\n+    ///\n+    /// assert_eq!(Some('g'), chars.next());\n+    /// assert_eq!(Some('o'), chars.next());\n+    /// assert_eq!(Some('o'), chars.next());\n+    /// assert_eq!(Some('d'), chars.next());\n+    /// assert_eq!(Some('b'), chars.next());\n+    /// assert_eq!(Some('y'), chars.next());\n+    /// assert_eq!(Some('e'), chars.next());\n+    ///\n+    /// assert_eq!(None, chars.next());\n+    /// ```\n+    ///\n+    /// Remember, [`char`]s may not match your human intuition about characters:\n+    ///\n+    /// ```\n+    /// let y = \"y\u0306\";\n+    ///\n+    /// let mut chars = y.chars();\n+    ///\n+    /// assert_eq!(Some('y'), chars.next()); // not 'y\u0306'\n+    /// assert_eq!(Some('\\u{0306}'), chars.next());\n+    ///\n+    /// assert_eq!(None, chars.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn chars(&self) -> Chars {\n+        core_str::StrExt::chars(self)\n+    }\n+    /// Returns an iterator over the [`char`]s of a string slice, and their\n+    /// positions.\n+    ///\n+    /// As a string slice consists of valid UTF-8, we can iterate through a\n+    /// string slice by [`char`]. This method returns an iterator of both\n+    /// these [`char`]s, as well as their byte positions.\n+    ///\n+    /// The iterator yields tuples. The position is first, the [`char`] is\n+    /// second.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let word = \"goodbye\";\n+    ///\n+    /// let count = word.char_indices().count();\n+    /// assert_eq!(7, count);\n+    ///\n+    /// let mut char_indices = word.char_indices();\n+    ///\n+    /// assert_eq!(Some((0, 'g')), char_indices.next());\n+    /// assert_eq!(Some((1, 'o')), char_indices.next());\n+    /// assert_eq!(Some((2, 'o')), char_indices.next());\n+    /// assert_eq!(Some((3, 'd')), char_indices.next());\n+    /// assert_eq!(Some((4, 'b')), char_indices.next());\n+    /// assert_eq!(Some((5, 'y')), char_indices.next());\n+    /// assert_eq!(Some((6, 'e')), char_indices.next());\n+    ///\n+    /// assert_eq!(None, char_indices.next());\n+    /// ```\n+    ///\n+    /// Remember, [`char`]s may not match your human intuition about characters:\n+    ///\n+    /// ```\n+    /// let y = \"y\u0306\";\n+    ///\n+    /// let mut char_indices = y.char_indices();\n+    ///\n+    /// assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y\u0306')\n+    /// assert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n+    ///\n+    /// assert_eq!(None, char_indices.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn char_indices(&self) -> CharIndices {\n+        core_str::StrExt::char_indices(self)\n+    }\n+\n+    /// An iterator over the bytes of a string slice.\n+    ///\n+    /// As a string slice consists of a sequence of bytes, we can iterate\n+    /// through a string slice by byte. This method returns such an iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut bytes = \"bors\".bytes();\n+    ///\n+    /// assert_eq!(Some(b'b'), bytes.next());\n+    /// assert_eq!(Some(b'o'), bytes.next());\n+    /// assert_eq!(Some(b'r'), bytes.next());\n+    /// assert_eq!(Some(b's'), bytes.next());\n+    ///\n+    /// assert_eq!(None, bytes.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn bytes(&self) -> Bytes {\n+        core_str::StrExt::bytes(self)\n+    }\n+\n+    /// Split a string slice by whitespace.\n+    ///\n+    /// The iterator returned will return string slices that are sub-slices of\n+    /// the original string slice, separated by any amount of whitespace.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut iter = \"A few words\".split_whitespace();\n+    ///\n+    /// assert_eq!(Some(\"A\"), iter.next());\n+    /// assert_eq!(Some(\"few\"), iter.next());\n+    /// assert_eq!(Some(\"words\"), iter.next());\n+    ///\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    ///\n+    /// All kinds of whitespace are considered:\n+    ///\n+    /// ```\n+    /// let mut iter = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\".split_whitespace();\n+    /// assert_eq!(Some(\"Mary\"), iter.next());\n+    /// assert_eq!(Some(\"had\"), iter.next());\n+    /// assert_eq!(Some(\"a\"), iter.next());\n+    /// assert_eq!(Some(\"little\"), iter.next());\n+    /// assert_eq!(Some(\"lamb\"), iter.next());\n+    ///\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+    #[inline]\n+    pub fn split_whitespace(&self) -> SplitWhitespace {\n+        UnicodeStr::split_whitespace(self)\n+    }\n+\n+    /// An iterator over the lines of a string, as string slices.\n+    ///\n+    /// Lines are ended with either a newline (`\\n`) or a carriage return with\n+    /// a line feed (`\\r\\n`).\n+    ///\n+    /// The final line ending is optional.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let text = \"foo\\r\\nbar\\n\\nbaz\\n\";\n+    /// let mut lines = text.lines();\n+    ///\n+    /// assert_eq!(Some(\"foo\"), lines.next());\n+    /// assert_eq!(Some(\"bar\"), lines.next());\n+    /// assert_eq!(Some(\"\"), lines.next());\n+    /// assert_eq!(Some(\"baz\"), lines.next());\n+    ///\n+    /// assert_eq!(None, lines.next());\n+    /// ```\n+    ///\n+    /// The final line ending isn't required:\n+    ///\n+    /// ```\n+    /// let text = \"foo\\nbar\\n\\r\\nbaz\";\n+    /// let mut lines = text.lines();\n+    ///\n+    /// assert_eq!(Some(\"foo\"), lines.next());\n+    /// assert_eq!(Some(\"bar\"), lines.next());\n+    /// assert_eq!(Some(\"\"), lines.next());\n+    /// assert_eq!(Some(\"baz\"), lines.next());\n+    ///\n+    /// assert_eq!(None, lines.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn lines(&self) -> Lines {\n+        core_str::StrExt::lines(self)\n+    }\n+\n+    /// An iterator over the lines of a string.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.4.0\", reason = \"use lines() instead now\")]\n+    #[inline]\n+    #[allow(deprecated)]\n+    pub fn lines_any(&self) -> LinesAny {\n+        core_str::StrExt::lines_any(self)\n+    }\n+\n+    /// Returns an iterator of `u16` over the string encoded as UTF-16.\n+    #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+    pub fn encode_utf16(&self) -> EncodeUtf16 {\n+        EncodeUtf16 { encoder: Utf16Encoder::new(self[..].chars()) }\n+    }\n+\n+    /// Returns `true` if the given pattern matches a sub-slice of\n+    /// this string slice.\n+    ///\n+    /// Returns `false` if it does not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bananas = \"bananas\";\n+    ///\n+    /// assert!(bananas.contains(\"nana\"));\n+    /// assert!(!bananas.contains(\"apples\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        core_str::StrExt::contains(self, pat)\n+    }\n+\n+    /// Returns `true` if the given pattern matches a prefix of this\n+    /// string slice.\n+    ///\n+    /// Returns `false` if it does not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bananas = \"bananas\";\n+    ///\n+    /// assert!(bananas.starts_with(\"bana\"));\n+    /// assert!(!bananas.starts_with(\"nana\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        core_str::StrExt::starts_with(self, pat)\n+    }\n+\n+    /// Returns `true` if the given pattern matches a suffix of this\n+    /// string slice.\n+    ///\n+    /// Returns `false` if it does not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bananas = \"bananas\";\n+    ///\n+    /// assert!(bananas.ends_with(\"anas\"));\n+    /// assert!(!bananas.ends_with(\"nana\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::ends_with(self, pat)\n+    }\n+\n+    /// Returns the byte index of the first character of this string slice that\n+    /// matches the pattern.\n+    ///\n+    /// Returns [`None`] if the pattern doesn't match.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find('L'), Some(0));\n+    /// assert_eq!(s.find('\u00e9'), Some(14));\n+    /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n+    /// ```\n+    ///\n+    /// More complex patterns with closures:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find(char::is_whitespace), Some(5));\n+    /// assert_eq!(s.find(char::is_lowercase), Some(1));\n+    /// ```\n+    ///\n+    /// Not finding the pattern:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let x: &[_] = &['1', '2'];\n+    ///\n+    /// assert_eq!(s.find(x), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n+        core_str::StrExt::find(self, pat)\n+    }\n+\n+    /// Returns the byte index of the last character of this string slice that\n+    /// matches the pattern.\n+    ///\n+    /// Returns [`None`] if the pattern doesn't match.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind('L'), Some(13));\n+    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n+    /// ```\n+    ///\n+    /// More complex patterns with closures:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind(char::is_whitespace), Some(12));\n+    /// assert_eq!(s.rfind(char::is_lowercase), Some(20));\n+    /// ```\n+    ///\n+    /// Not finding the pattern:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let x: &[_] = &['1', '2'];\n+    ///\n+    /// assert_eq!(s.rfind(x), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rfind(self, pat)\n+    }\n+\n+    /// An iterator over substrings of this string slice, separated by\n+    /// characters matched by a pattern.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rsplit`] method can be used.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [`rsplit`]: #method.rsplit\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".split('X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\n+    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\n+    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n+    /// ```\n+    ///\n+    /// If a string contains multiple contiguous separators, you will end up\n+    /// with empty strings in the output:\n+    ///\n+    /// ```\n+    /// let x = \"||||a||b|c\".to_string();\n+    /// let d: Vec<_> = x.split('|').collect();\n+    ///\n+    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n+    /// ```\n+    ///\n+    /// Contiguous separators are separated by the empty string.\n+    ///\n+    /// ```\n+    /// let x = \"(///)\".to_string();\n+    /// let d: Vec<_> = x.split('/').collect();\n+    ///\n+    /// assert_eq!(d, &[\"(\", \"\", \"\", \")\"]);\n+    /// ```\n+    ///\n+    /// Separators at the start or end of a string are neighbored\n+    /// by empty strings.\n+    ///\n+    /// ```\n+    /// let d: Vec<_> = \"010\".split(\"0\").collect();\n+    /// assert_eq!(d, &[\"\", \"1\", \"\"]);\n+    /// ```\n+    ///\n+    /// When the empty string is used as a separator, it separates\n+    /// every character in the string, along with the beginning\n+    /// and end of the string.\n+    ///\n+    /// ```\n+    /// let f: Vec<_> = \"rust\".split(\"\").collect();\n+    /// assert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);\n+    /// ```\n+    ///\n+    /// Contiguous separators can lead to possibly surprising behavior\n+    /// when whitespace is used as the separator. This code is correct:\n+    ///\n+    /// ```\n+    /// let x = \"    a  b c\".to_string();\n+    /// let d: Vec<_> = x.split(' ').collect();\n+    ///\n+    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n+    /// ```\n+    ///\n+    /// It does _not_ give you:\n+    ///\n+    /// ```,ignore\n+    /// assert_eq!(d, &[\"a\", \"b\", \"c\"]);\n+    /// ```\n+    ///\n+    /// Use [`split_whitespace`] for this behavior.\n+    ///\n+    /// [`split_whitespace`]: #method.split_whitespace\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n+        core_str::StrExt::split(self, pat)\n+    }\n+\n+    /// An iterator over substrings of the given string slice, separated by\n+    /// characters matched by a pattern and yielded in reverse order.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a reverse\n+    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// For iterating from the front, the [`split`] method can be used.\n+    ///\n+    /// [`split`]: #method.split\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".rsplit('X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rsplit(self, pat)\n+    }\n+\n+    /// An iterator over substrings of the given string slice, separated by\n+    /// characters matched by a pattern.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// Equivalent to [`split`], except that the trailing substring\n+    /// is skipped if empty.\n+    ///\n+    /// [`split`]: #method.split\n+    ///\n+    /// This method can be used for string data that is _terminated_,\n+    /// rather than _separated_ by a pattern.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rsplit_terminator`] method can be used.\n+    ///\n+    /// [`rsplit_terminator`]: #method.rsplit_terminator\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n+    /// assert_eq!(v, [\"A\", \"B\"]);\n+    ///\n+    /// let v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\n+    /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n+        core_str::StrExt::split_terminator(self, pat)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by a pattern and yielded in reverse order.\n+    ///\n+    /// The pattern can be a simple `&str`, [`char`], or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// Equivalent to [`split`], except that the trailing substring is\n+    /// skipped if empty.\n+    ///\n+    /// [`split`]: #method.split\n+    ///\n+    /// This method can be used for string data that is _terminated_,\n+    /// rather than _separated_ by a pattern.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search, and it will be double ended if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// For iterating from the front, the [`split_terminator`] method can be\n+    /// used.\n+    ///\n+    /// [`split_terminator`]: #method.split_terminator\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\n+    /// assert_eq!(v, [\"B\", \"A\"]);\n+    ///\n+    /// let v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\n+    /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rsplit_terminator(self, pat)\n+    }\n+\n+    /// An iterator over substrings of the given string slice, separated by a\n+    /// pattern, restricted to returning at most `n` items.\n+    ///\n+    /// If `n` substrings are returned, the last substring (the `n`th substring)\n+    /// will contain the remainder of the string.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will not be double ended, because it is\n+    /// not efficient to support.\n+    ///\n+    /// If the pattern allows a reverse search, the [`rsplitn`] method can be\n+    /// used.\n+    ///\n+    /// [`rsplitn`]: #method.rsplitn\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, [\"abcXdef\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"abc\", \"defXghi\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn splitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> SplitN<'a, P> {\n+        core_str::StrExt::splitn(self, n, pat)\n+    }\n+\n+    /// An iterator over substrings of this string slice, separated by a\n+    /// pattern, starting from the end of the string, restricted to returning\n+    /// at most `n` items.\n+    ///\n+    /// If `n` substrings are returned, the last substring (the `n`th substring)\n+    /// will contain the remainder of the string.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n+    /// determines the split.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will not be double ended, because it is not\n+    /// efficient to support.\n+    ///\n+    /// For splitting from the front, the [`splitn`] method can be used.\n+    ///\n+    /// [`splitn`]: #method.splitn\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rsplitn(self, n, pat)\n+    }\n+\n+    /// An iterator over the disjoint matches of a pattern within the given string\n+    /// slice.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n+    /// determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rmatches`] method can be used.\n+    ///\n+    /// [`rmatches`]: #method.rmatches\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\n+    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\n+    /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n+    /// ```\n+    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n+    #[inline]\n+    pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n+        core_str::StrExt::matches(self, pat)\n+    }\n+\n+    /// An iterator over the disjoint matches of a pattern within this string slice,\n+    /// yielded in reverse order.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a reverse\n+    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// For iterating from the front, the [`matches`] method can be used.\n+    ///\n+    /// [`matches`]: #method.matches\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\n+    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\n+    /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n+    /// ```\n+    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n+    #[inline]\n+    pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rmatches(self, pat)\n+    }\n+\n+    /// An iterator over the disjoint matches of a pattern within this string\n+    /// slice as well as the index that the match starts at.\n+    ///\n+    /// For matches of `pat` within `self` that overlap, only the indices\n+    /// corresponding to the first match are returned.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines\n+    /// if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rmatch_indices`] method can be used.\n+    ///\n+    /// [`rmatch_indices`]: #method.rmatch_indices\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\n+    /// assert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n+    /// ```\n+    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n+    #[inline]\n+    pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n+        core_str::StrExt::match_indices(self, pat)\n+    }\n+\n+    /// An iterator over the disjoint matches of a pattern within `self`,\n+    /// yielded in reverse order along with the index of the match.\n+    ///\n+    /// For matches of `pat` within `self` that overlap, only the indices\n+    /// corresponding to the last match are returned.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if a\n+    /// character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a reverse\n+    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// For iterating from the front, the [`match_indices`] method can be used.\n+    ///\n+    /// [`match_indices`]: #method.match_indices\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<_> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(12, \"abc\"), (6, \"abc\"), (0, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(4, \"abc\"), (1, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"ababa\".rmatch_indices(\"aba\").collect();\n+    /// assert_eq!(v, [(2, \"aba\")]); // only the last `aba`\n+    /// ```\n+    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n+    #[inline]\n+    pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rmatch_indices(self, pat)\n+    }\n+\n+    /// Returns a string slice with leading and trailing whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    ///\n+    /// assert_eq!(\"Hello\\tworld\", s.trim());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim(&self) -> &str {\n+        UnicodeStr::trim(self)\n+    }\n+\n+    /// Returns a string slice with leading whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Left' in this context means the first\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _right_ side, not the left.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    ///\n+    /// assert_eq!(\"Hello\\tworld\\t\", s.trim_left());\n+    /// ```\n+    ///\n+    /// Directionality:\n+    ///\n+    /// ```\n+    /// let s = \"  English\";\n+    /// assert!(Some('E') == s.trim_left().chars().next());\n+    ///\n+    /// let s = \"  \u05e2\u05d1\u05e8\u05d9\u05ea\";\n+    /// assert!(Some('\u05e2') == s.trim_left().chars().next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_left(&self) -> &str {\n+        UnicodeStr::trim_left(self)\n+    }\n+\n+    /// Returns a string slice with trailing whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Right' in this context means the last\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _left_ side, not the right.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    ///\n+    /// assert_eq!(\" Hello\\tworld\", s.trim_right());\n+    /// ```\n+    ///\n+    /// Directionality:\n+    ///\n+    /// ```\n+    /// let s = \"English  \";\n+    /// assert!(Some('h') == s.trim_right().chars().rev().next());\n+    ///\n+    /// let s = \"\u05e2\u05d1\u05e8\u05d9\u05ea  \";\n+    /// assert!(Some('\u05ea') == s.trim_right().chars().rev().next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_right(&self) -> &str {\n+        UnicodeStr::trim_right(self)\n+    }\n+\n+    /// Returns a string slice with all prefixes and suffixes that match a\n+    /// pattern repeatedly removed.\n+    ///\n+    /// The pattern can be a [`char`] or a closure that determines if a\n+    /// character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: DoubleEndedSearcher<'a>\n+    {\n+        core_str::StrExt::trim_matches(self, pat)\n+    }\n+\n+    /// Returns a string slice with all prefixes that match a pattern\n+    /// repeatedly removed.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Left' in this context means the first\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _right_ side, not the left.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n+    /// assert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n+        core_str::StrExt::trim_left_matches(self, pat)\n+    }\n+\n+    /// Returns a string slice with all suffixes that match a pattern\n+    /// repeatedly removed.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n+    /// determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Right' in this context means the last\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _left_ side, not the right.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"1fooX\".trim_left_matches(|c| c == '1' || c == 'X'), \"fooX\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::trim_right_matches(self, pat)\n+    }\n+\n+    /// Parses this string slice into another type.\n+    ///\n+    /// Because `parse` is so general, it can cause problems with type\n+    /// inference. As such, `parse` is one of the few times you'll see\n+    /// the syntax affectionately known as the 'turbofish': `::<>`. This\n+    /// helps the inference algorithm understand specifically which type\n+    /// you're trying to parse into.\n+    ///\n+    /// `parse` can parse any type that implements the [`FromStr`] trait.\n+    ///\n+    /// [`FromStr`]: str/trait.FromStr.html\n+    ///\n+    /// # Errors\n+    ///\n+    /// Will return [`Err`] if it's not possible to parse this string slice into\n+    /// the desired type.\n+    ///\n+    /// [`Err`]: str/trait.FromStr.html#associatedtype.Err\n+    ///\n+    /// # Example\n+    ///\n+    /// Basic usage\n+    ///\n+    /// ```\n+    /// let four: u32 = \"4\".parse().unwrap();\n+    ///\n+    /// assert_eq!(4, four);\n+    /// ```\n+    ///\n+    /// Using the 'turbofish' instead of annotating `four`:\n+    ///\n+    /// ```\n+    /// let four = \"4\".parse::<u32>();\n+    ///\n+    /// assert_eq!(Ok(4), four);\n+    /// ```\n+    ///\n+    /// Failing to parse:\n+    ///\n+    /// ```\n+    /// let nope = \"j\".parse::<u32>();\n+    ///\n+    /// assert!(nope.is_err());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n+        core_str::StrExt::parse(self)\n+    }\n+\n+    /// Converts a `Box<str>` into a `Box<[u8]>` without copying or allocating.\n+    #[unstable(feature = \"str_box_extras\", issue = \"41119\")]\n+    pub fn into_boxed_bytes(self: Box<str>) -> Box<[u8]> {\n+        self.into()\n+    }\n+\n+    /// Replaces all matches of a pattern with another string.\n+    ///\n+    /// `replace` creates a new [`String`], and copies the data from this string slice into it.\n+    /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n+    /// replaces them with the replacement string slice.\n+    ///\n+    /// [`String`]: string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"this is old\";\n+    ///\n+    /// assert_eq!(\"this is new\", s.replace(\"old\", \"new\"));\n+    /// ```\n+    ///\n+    /// When the pattern doesn't match:\n+    ///\n+    /// ```\n+    /// let s = \"this is old\";\n+    /// assert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String {\n+        let mut result = String::new();\n+        let mut last_end = 0;\n+        for (start, part) in self.match_indices(from) {\n+            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n+            result.push_str(to);\n+            last_end = start + part.len();\n+        }\n+        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n+        result\n+    }\n+\n+    /// Replaces first N matches of a pattern with another string.\n+    ///\n+    /// `replacen` creates a new [`String`], and copies the data from this string slice into it.\n+    /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n+    /// replaces them with the replacement string slice at most `count` times.\n+    ///\n+    /// [`String`]: string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"foo foo 123 foo\";\n+    /// assert_eq!(\"new new 123 foo\", s.replacen(\"foo\", \"new\", 2));\n+    /// assert_eq!(\"faa fao 123 foo\", s.replacen('o', \"a\", 3));\n+    /// assert_eq!(\"foo foo new23 foo\", s.replacen(char::is_numeric, \"new\", 1));\n+    /// ```\n+    ///\n+    /// When the pattern doesn't match:\n+    ///\n+    /// ```\n+    /// let s = \"this is old\";\n+    /// assert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n+    /// ```\n+    #[stable(feature = \"str_replacen\", since = \"1.16.0\")]\n+    pub fn replacen<'a, P: Pattern<'a>>(&'a self, pat: P, to: &str, count: usize) -> String {\n+        // Hope to reduce the times of re-allocation\n+        let mut result = String::with_capacity(32);\n+        let mut last_end = 0;\n+        for (start, part) in self.match_indices(pat).take(count) {\n+            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n+            result.push_str(to);\n+            last_end = start + part.len();\n+        }\n+        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n+        result\n+    }\n+\n+    /// Returns the lowercase equivalent of this string slice, as a new [`String`].\n+    ///\n+    /// 'Lowercase' is defined according to the terms of the Unicode Derived Core Property\n+    /// `Lowercase`.\n+    ///\n+    /// Since some characters can expand into multiple characters when changing\n+    /// the case, this function returns a [`String`] instead of modifying the\n+    /// parameter in-place.\n+    ///\n+    /// [`String`]: string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"HELLO\";\n+    ///\n+    /// assert_eq!(\"hello\", s.to_lowercase());\n+    /// ```\n+    ///\n+    /// A tricky example, with sigma:\n+    ///\n+    /// ```\n+    /// let sigma = \"\u03a3\";\n+    ///\n+    /// assert_eq!(\"\u03c3\", sigma.to_lowercase());\n+    ///\n+    /// // but at the end of a word, it's \u03c2, not \u03c3:\n+    /// let odysseus = \"\u1f48\u0394\u03a5\u03a3\u03a3\u0395\u038e\u03a3\";\n+    ///\n+    /// assert_eq!(\"\u1f40\u03b4\u03c5\u03c3\u03c3\u03b5\u03cd\u03c2\", odysseus.to_lowercase());\n+    /// ```\n+    ///\n+    /// Languages without case are not changed:\n+    ///\n+    /// ```\n+    /// let new_year = \"\u519c\u5386\u65b0\u5e74\";\n+    ///\n+    /// assert_eq!(new_year, new_year.to_lowercase());\n+    /// ```\n+    #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n+    pub fn to_lowercase(&self) -> String {\n+        let mut s = String::with_capacity(self.len());\n+        for (i, c) in self[..].char_indices() {\n+            if c == '\u03a3' {\n+                // \u03a3 maps to \u03c3, except at the end of a word where it maps to \u03c2.\n+                // This is the only conditional (contextual) but language-independent mapping\n+                // in `SpecialCasing.txt`,\n+                // so hard-code it rather than have a generic \"condition\" mechanism.\n+                // See https://github.com/rust-lang/rust/issues/26035\n+                map_uppercase_sigma(self, i, &mut s)\n+            } else {\n+                s.extend(c.to_lowercase());\n+            }\n+        }\n+        return s;\n+\n+        fn map_uppercase_sigma(from: &str, i: usize, to: &mut String) {\n+            // See http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n+            // for the definition of `Final_Sigma`.\n+            debug_assert!('\u03a3'.len_utf8() == 2);\n+            let is_word_final = case_ignoreable_then_cased(from[..i].chars().rev()) &&\n+                                !case_ignoreable_then_cased(from[i + 2..].chars());\n+            to.push_str(if is_word_final { \"\u03c2\" } else { \"\u03c3\" });\n+        }\n+\n+        fn case_ignoreable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {\n+            use std_unicode::derived_property::{Cased, Case_Ignorable};\n+            match iter.skip_while(|&c| Case_Ignorable(c)).next() {\n+                Some(c) => Cased(c),\n+                None => false,\n+            }\n+        }\n+    }\n+\n+    /// Returns the uppercase equivalent of this string slice, as a new [`String`].\n+    ///\n+    /// 'Uppercase' is defined according to the terms of the Unicode Derived Core Property\n+    /// `Uppercase`.\n+    ///\n+    /// Since some characters can expand into multiple characters when changing\n+    /// the case, this function returns a [`String`] instead of modifying the\n+    /// parameter in-place.\n+    ///\n+    /// [`String`]: string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"hello\";\n+    ///\n+    /// assert_eq!(\"HELLO\", s.to_uppercase());\n+    /// ```\n+    ///\n+    /// Scripts without case are not changed:\n+    ///\n+    /// ```\n+    /// let new_year = \"\u519c\u5386\u65b0\u5e74\";\n+    ///\n+    /// assert_eq!(new_year, new_year.to_uppercase());\n+    /// ```\n+    #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n+    pub fn to_uppercase(&self) -> String {\n+        let mut s = String::with_capacity(self.len());\n+        s.extend(self.chars().flat_map(|c| c.to_uppercase()));\n+        return s;\n+    }\n+\n+    /// Escapes each char in `s` with [`char::escape_debug`].\n+    ///\n+    /// [`char::escape_debug`]: primitive.char.html#method.escape_debug\n+    #[unstable(feature = \"str_escape\",\n+               reason = \"return type may change to be an iterator\",\n+               issue = \"27791\")]\n+    pub fn escape_debug(&self) -> String {\n+        self.chars().flat_map(|c| c.escape_debug()).collect()\n+    }\n+\n+    /// Escapes each char in `s` with [`char::escape_default`].\n+    ///\n+    /// [`char::escape_default`]: primitive.char.html#method.escape_default\n+    #[unstable(feature = \"str_escape\",\n+               reason = \"return type may change to be an iterator\",\n+               issue = \"27791\")]\n+    pub fn escape_default(&self) -> String {\n+        self.chars().flat_map(|c| c.escape_default()).collect()\n+    }\n+\n+    /// Escapes each char in `s` with [`char::escape_unicode`].\n+    ///\n+    /// [`char::escape_unicode`]: primitive.char.html#method.escape_unicode\n+    #[unstable(feature = \"str_escape\",\n+               reason = \"return type may change to be an iterator\",\n+               issue = \"27791\")]\n+    pub fn escape_unicode(&self) -> String {\n+        self.chars().flat_map(|c| c.escape_unicode()).collect()\n+    }\n+\n+    /// Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n+    ///\n+    /// [`String`]: string/struct.String.html\n+    /// [`Box<str>`]: boxed/struct.Box.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let string = String::from(\"birthday gift\");\n+    /// let boxed_str = string.clone().into_boxed_str();\n+    ///\n+    /// assert_eq!(boxed_str.into_string(), string);\n+    /// ```\n+    #[stable(feature = \"box_str\", since = \"1.4.0\")]\n+    pub fn into_string(self: Box<str>) -> String {\n+        unsafe {\n+            let slice = mem::transmute::<Box<str>, Box<[u8]>>(self);\n+            String::from_utf8_unchecked(slice.into_vec())\n+        }\n+    }\n+\n+    /// Create a [`String`] by repeating a string `n` times.\n+    ///\n+    /// [`String`]: string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"abc\".repeat(4), String::from(\"abcabcabcabc\"));\n+    /// ```\n+    #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n+    pub fn repeat(&self, n: usize) -> String {\n+        let mut s = String::with_capacity(self.len() * n);\n+        s.extend((0..n).map(|_| self));\n+        s\n+    }\n+}\n+\n /// Converts a boxed slice of bytes to a boxed string slice without checking\n /// that the string contains valid UTF-8.\n #[unstable(feature = \"str_box_extras\", issue = \"41119\")]"}, {"sha": "1d98626e90b0960606bfcda22794896429b267c8", "filename": "src/liballoc/string.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -56,8 +56,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use alloc::str as alloc_str;\n-\n use core::fmt;\n use core::hash;\n use core::iter::{FromIterator, FusedIterator};\n@@ -70,7 +68,7 @@ use std_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n use borrow::{Cow, ToOwned};\n use range::RangeArgument;\n use Bound::{Excluded, Included, Unbounded};\n-use str::{self, FromStr, Utf8Error, Chars};\n+use str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n use vec::Vec;\n use boxed::Box;\n \n@@ -1464,7 +1462,7 @@ impl String {\n     #[stable(feature = \"box_str\", since = \"1.4.0\")]\n     pub fn into_boxed_str(self) -> Box<str> {\n         let slice = self.vec.into_boxed_slice();\n-        unsafe { alloc_str::from_boxed_utf8_unchecked(slice) }\n+        unsafe { from_boxed_utf8_unchecked(slice) }\n     }\n }\n ", "previous_filename": "src/libcollections/string.rs"}, {"sha": "06d585f8ea82f699e64a181921554f237083ff21", "filename": "src/liballoc/tests/binary_heap.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/tests/binary_heap.rs"}, {"sha": "2c899d96940ece9e222adc3ff21600f7f164c708", "filename": "src/liballoc/tests/btree/map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/tests/btree/map.rs"}, {"sha": "ae8b18d0c9fd92203fef9cc2bfd826aad5883bcc", "filename": "src/liballoc/tests/btree/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/tests/btree/mod.rs"}, {"sha": "6171b8ba624cd5581b505d3eb47cfc43d8e81c7c", "filename": "src/liballoc/tests/btree/set.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/tests/btree/set.rs"}, {"sha": "aa87ee84b3e9769ea36625c20afc7ec77a3698f6", "filename": "src/liballoc/tests/cow_str.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fcow_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fcow_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fcow_str.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/tests/cow_str.rs"}, {"sha": "70e21c65a1806549eb10764d5bbb67ddfb616a6e", "filename": "src/liballoc/tests/fmt.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Ffmt.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/tests/fmt.rs"}, {"sha": "c6d70ee7575f8a6754159504da48bd1075d0e4f6", "filename": "src/liballoc/tests/lib.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -10,11 +10,11 @@\n \n #![deny(warnings)]\n \n+#![feature(alloc)]\n #![feature(attr_literals)]\n #![feature(box_syntax)]\n #![feature(inclusive_range_syntax)]\n #![feature(collection_placement)]\n-#![feature(collections)]\n #![feature(const_fn)]\n #![feature(exact_size_is_empty)]\n #![feature(iterator_step_by)]\n@@ -31,7 +31,7 @@\n #![feature(unicode)]\n #![feature(utf8_error_error_len)]\n \n-extern crate collections;\n+extern crate alloc;\n extern crate test;\n extern crate std_unicode;\n extern crate core;", "previous_filename": "src/libcollections/tests/lib.rs"}, {"sha": "a59724a017b1241de3e9995727a719782b76ea7f", "filename": "src/liballoc/tests/linked_list.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/tests/linked_list.rs"}, {"sha": "7fa65a2144e9b47d1f3f093c04fa980bc6bf5596", "filename": "src/liballoc/tests/slice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/tests/slice.rs"}, {"sha": "9d8ca38b20e48c822af8beb5f756c25c88ad5d7e", "filename": "src/liballoc/tests/str.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/tests/str.rs"}, {"sha": "b1731b2a5dcaa486b8e189e97b88dbdf23b9e85f", "filename": "src/liballoc/tests/string.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/tests/string.rs"}, {"sha": "fdf453b39cf5d9144c21cf9c4091af7c41c44312", "filename": "src/liballoc/tests/vec.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/tests/vec.rs"}, {"sha": "a992351653d7b996e2f2100c57f5c8c1c4ee82a1", "filename": "src/liballoc/tests/vec_deque.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "previous_filename": "src/libcollections/tests/vec_deque.rs"}, {"sha": "8bb16febb0483cbb8465da8435a052060e59d88b", "filename": "src/liballoc/vec.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -66,10 +66,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use alloc::boxed::Box;\n-use alloc::raw_vec::RawVec;\n-use borrow::ToOwned;\n-use borrow::Cow;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{self, Hash};\n@@ -84,6 +80,10 @@ use core::ptr;\n use core::ptr::Shared;\n use core::slice;\n \n+use borrow::ToOwned;\n+use borrow::Cow;\n+use boxed::Box;\n+use raw_vec::RawVec;\n use super::range::RangeArgument;\n use Bound::{Excluded, Included, Unbounded};\n ", "previous_filename": "src/libcollections/vec.rs"}, {"sha": "18175a5d01bd2bc7bb13400a2a7aedae265d6437", "filename": "src/liballoc/vec_deque.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -29,7 +29,7 @@ use core::slice;\n use core::hash::{Hash, Hasher};\n use core::cmp;\n \n-use alloc::raw_vec::RawVec;\n+use raw_vec::RawVec;\n \n use super::range::RangeArgument;\n use Bound::{Excluded, Included, Unbounded};", "previous_filename": "src/libcollections/vec_deque.rs"}, {"sha": "7e92404bc0d6f3dce905231c980c41af9d7ec228", "filename": "src/libcollections/Cargo.toml", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/16c27bf713ac7c0afeada808e274c73e10eb96bd/src%2Flibcollections%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/16c27bf713ac7c0afeada808e274c73e10eb96bd/src%2Flibcollections%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2FCargo.toml?ref=16c27bf713ac7c0afeada808e274c73e10eb96bd", "patch": "@@ -1,21 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"collections\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"collections\"\n-path = \"lib.rs\"\n-\n-[dependencies]\n-alloc = { path = \"../liballoc\" }\n-core = { path = \"../libcore\" }\n-std_unicode = { path = \"../libstd_unicode\" }\n-\n-[[test]]\n-name = \"collectionstests\"\n-path = \"../libcollections/tests/lib.rs\"\n-\n-[[bench]]\n-name = \"collectionsbenches\"\n-path = \"../libcollections/benches/lib.rs\""}, {"sha": "34626326c221ce533c452920960f12f1604dec5d", "filename": "src/libcollections/lib.rs", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/16c27bf713ac7c0afeada808e274c73e10eb96bd/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16c27bf713ac7c0afeada808e274c73e10eb96bd/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=16c27bf713ac7c0afeada808e274c73e10eb96bd", "patch": "@@ -1,192 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Collection types.\n-//!\n-//! See [`std::collections`](../std/collections/index.html) for a detailed\n-//! discussion of collections in Rust.\n-\n-#![crate_name = \"collections\"]\n-#![crate_type = \"rlib\"]\n-#![unstable(feature = \"collections\",\n-            reason = \"library is unlikely to be stabilized with the current \\\n-                      layout and name, use std::collections instead\",\n-            issue = \"27783\")]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"https://play.rust-lang.org/\",\n-       issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n-       test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n-\n-#![cfg_attr(test, allow(deprecated))] // rand\n-#![deny(warnings)]\n-#![deny(missing_debug_implementations)]\n-\n-#![feature(alloc)]\n-#![feature(allow_internal_unstable)]\n-#![feature(box_patterns)]\n-#![feature(box_syntax)]\n-#![cfg_attr(not(test), feature(char_escape_debug))]\n-#![cfg_attr(not(test), feature(core_float))]\n-#![feature(core_intrinsics)]\n-#![feature(dropck_eyepatch)]\n-#![feature(exact_size_is_empty)]\n-#![feature(fmt_internals)]\n-#![feature(fused)]\n-#![feature(generic_param_attrs)]\n-#![feature(heap_api)]\n-#![feature(i128_type)]\n-#![feature(inclusive_range)]\n-#![feature(lang_items)]\n-#![feature(manually_drop)]\n-#![feature(nonzero)]\n-#![feature(pattern)]\n-#![feature(placement_in)]\n-#![feature(placement_in_syntax)]\n-#![feature(placement_new_protocol)]\n-#![feature(shared)]\n-#![feature(slice_get_slice)]\n-#![feature(slice_patterns)]\n-#![cfg_attr(not(test), feature(slice_rotate))]\n-#![feature(slice_rsplit)]\n-#![cfg_attr(not(test), feature(sort_unstable))]\n-#![feature(specialization)]\n-#![feature(staged_api)]\n-#![feature(str_internals)]\n-#![feature(str_box_extras)]\n-#![feature(str_mut_extras)]\n-#![feature(trusted_len)]\n-#![feature(unicode)]\n-#![feature(unique)]\n-#![cfg_attr(not(test), feature(str_checked_slicing))]\n-#![cfg_attr(test, feature(rand, test))]\n-#![feature(offset_to)]\n-\n-#![no_std]\n-\n-extern crate std_unicode;\n-extern crate alloc;\n-\n-#[cfg(test)]\n-#[macro_use]\n-extern crate std;\n-#[cfg(test)]\n-extern crate test;\n-\n-#[doc(no_inline)]\n-pub use binary_heap::BinaryHeap;\n-#[doc(no_inline)]\n-pub use btree_map::BTreeMap;\n-#[doc(no_inline)]\n-pub use btree_set::BTreeSet;\n-#[doc(no_inline)]\n-pub use linked_list::LinkedList;\n-#[doc(no_inline)]\n-pub use vec_deque::VecDeque;\n-#[doc(no_inline)]\n-pub use string::String;\n-#[doc(no_inline)]\n-pub use vec::Vec;\n-\n-// Needed for the vec! macro\n-pub use alloc::boxed;\n-\n-#[macro_use]\n-mod macros;\n-\n-pub mod binary_heap;\n-mod btree;\n-pub mod borrow;\n-pub mod fmt;\n-pub mod linked_list;\n-pub mod range;\n-pub mod slice;\n-pub mod str;\n-pub mod string;\n-pub mod vec;\n-pub mod vec_deque;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod btree_map {\n-    //! A map based on a B-Tree.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use btree::map::*;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod btree_set {\n-    //! A set based on a B-Tree.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use btree::set::*;\n-}\n-\n-#[cfg(not(test))]\n-mod std {\n-    pub use core::ops;      // RangeFull\n-}\n-\n-/// An endpoint of a range of keys.\n-///\n-/// # Examples\n-///\n-/// `Bound`s are range endpoints:\n-///\n-/// ```\n-/// #![feature(collections_range)]\n-///\n-/// use std::collections::range::RangeArgument;\n-/// use std::collections::Bound::*;\n-///\n-/// assert_eq!((..100).start(), Unbounded);\n-/// assert_eq!((1..12).start(), Included(&1));\n-/// assert_eq!((1..12).end(), Excluded(&12));\n-/// ```\n-///\n-/// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n-/// Note that in most cases, it's better to use range syntax (`1..5`) instead.\n-///\n-/// ```\n-/// use std::collections::BTreeMap;\n-/// use std::collections::Bound::{Excluded, Included, Unbounded};\n-///\n-/// let mut map = BTreeMap::new();\n-/// map.insert(3, \"a\");\n-/// map.insert(5, \"b\");\n-/// map.insert(8, \"c\");\n-///\n-/// for (key, value) in map.range((Excluded(3), Included(8))) {\n-///     println!(\"{}: {}\", key, value);\n-/// }\n-///\n-/// assert_eq!(Some((&3, &\"a\")), map.range((Unbounded, Included(5))).next());\n-/// ```\n-///\n-/// [`BTreeMap::range`]: btree_map/struct.BTreeMap.html#method.range\n-#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n-pub enum Bound<T> {\n-    /// An inclusive bound.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Included(T),\n-    /// An exclusive bound.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Excluded(T),\n-    /// An infinite endpoint. Indicates that there is no bound in this direction.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Unbounded,\n-}\n-\n-/// An intermediate trait for specialization of `Extend`.\n-#[doc(hidden)]\n-trait SpecExtend<I: IntoIterator> {\n-    /// Extends `self` with the contents of the given iterator.\n-    fn spec_extend(&mut self, iter: I);\n-}"}, {"sha": "396a917dfde261f87ba8823e17c533f2d0f8f660", "filename": "src/libcollections/macros.rs", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/16c27bf713ac7c0afeada808e274c73e10eb96bd/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16c27bf713ac7c0afeada808e274c73e10eb96bd/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=16c27bf713ac7c0afeada808e274c73e10eb96bd", "patch": "@@ -1,92 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/// Creates a `Vec` containing the arguments.\n-///\n-/// `vec!` allows `Vec`s to be defined with the same syntax as array expressions.\n-/// There are two forms of this macro:\n-///\n-/// - Create a `Vec` containing a given list of elements:\n-///\n-/// ```\n-/// let v = vec![1, 2, 3];\n-/// assert_eq!(v[0], 1);\n-/// assert_eq!(v[1], 2);\n-/// assert_eq!(v[2], 3);\n-/// ```\n-///\n-/// - Create a `Vec` from a given element and size:\n-///\n-/// ```\n-/// let v = vec![1; 3];\n-/// assert_eq!(v, [1, 1, 1]);\n-/// ```\n-///\n-/// Note that unlike array expressions this syntax supports all elements\n-/// which implement `Clone` and the number of elements doesn't have to be\n-/// a constant.\n-///\n-/// This will use `clone()` to duplicate an expression, so one should be careful\n-/// using this with types having a nonstandard `Clone` implementation. For\n-/// example, `vec![Rc::new(1); 5]` will create a vector of five references\n-/// to the same boxed integer value, not five references pointing to independently\n-/// boxed integers.\n-#[cfg(not(test))]\n-#[macro_export]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n-macro_rules! vec {\n-    ($elem:expr; $n:expr) => (\n-        $crate::vec::from_elem($elem, $n)\n-    );\n-    ($($x:expr),*) => (\n-        <[_]>::into_vec(box [$($x),*])\n-    );\n-    ($($x:expr,)*) => (vec![$($x),*])\n-}\n-\n-// HACK(japaric): with cfg(test) the inherent `[T]::into_vec` method, which is\n-// required for this macro definition, is not available. Instead use the\n-// `slice::into_vec`  function which is only available with cfg(test)\n-// NB see the slice::hack module in slice.rs for more information\n-#[cfg(test)]\n-macro_rules! vec {\n-    ($elem:expr; $n:expr) => (\n-        $crate::vec::from_elem($elem, $n)\n-    );\n-    ($($x:expr),*) => (\n-        $crate::slice::into_vec(box [$($x),*])\n-    );\n-    ($($x:expr,)*) => (vec![$($x),*])\n-}\n-\n-/// Use the syntax described in `std::fmt` to create a value of type `String`.\n-/// See [`std::fmt`][fmt] for more information.\n-///\n-/// [fmt]: ../std/fmt/index.html\n-///\n-/// # Panics\n-///\n-/// `format!` panics if a formatting trait implementation returns an error.\n-/// This indicates an incorrect implementation\n-/// since `fmt::Write for String` never returns an error itself.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// format!(\"test\");\n-/// format!(\"hello {}\", \"world!\");\n-/// format!(\"x = {}, y = {y}\", 10, y = 30);\n-/// ```\n-#[macro_export]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-macro_rules! format {\n-    ($($arg:tt)*) => ($crate::fmt::format(format_args!($($arg)*)))\n-}"}, {"sha": "fdb6ee42127b9163357ca879087cb38f135f59b9", "filename": "src/libcollections/str.rs", "status": "removed", "additions": 0, "deletions": 1997, "changes": 1997, "blob_url": "https://github.com/rust-lang/rust/blob/16c27bf713ac7c0afeada808e274c73e10eb96bd/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16c27bf713ac7c0afeada808e274c73e10eb96bd/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=16c27bf713ac7c0afeada808e274c73e10eb96bd", "patch": "@@ -1,1997 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Unicode string slices.\n-//!\n-//! The `&str` type is one of the two main string types, the other being `String`.\n-//! Unlike its `String` counterpart, its contents are borrowed.\n-//!\n-//! # Basic Usage\n-//!\n-//! A basic string declaration of `&str` type:\n-//!\n-//! ```\n-//! let hello_world = \"Hello, World!\";\n-//! ```\n-//!\n-//! Here we have declared a string literal, also known as a string slice.\n-//! String literals have a static lifetime, which means the string `hello_world`\n-//! is guaranteed to be valid for the duration of the entire program.\n-//! We can explicitly specify `hello_world`'s lifetime as well:\n-//!\n-//! ```\n-//! let hello_world: &'static str = \"Hello, world!\";\n-//! ```\n-//!\n-//! *[See also the `str` primitive type](../../std/primitive.str.html).*\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-// Many of the usings in this module are only used in the test configuration.\n-// It's cleaner to just turn off the unused_imports warning than to fix them.\n-#![allow(unused_imports)]\n-\n-use core::fmt;\n-use core::str as core_str;\n-use core::str::pattern::Pattern;\n-use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n-use core::mem;\n-use core::iter::FusedIterator;\n-use std_unicode::str::{UnicodeStr, Utf16Encoder};\n-\n-use vec_deque::VecDeque;\n-use borrow::{Borrow, ToOwned};\n-use string::String;\n-use std_unicode;\n-use vec::Vec;\n-use slice::{SliceConcatExt, SliceIndex};\n-use boxed::Box;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{FromStr, Utf8Error};\n-#[allow(deprecated)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{Lines, LinesAny};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{Split, RSplit};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{SplitN, RSplitN};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{SplitTerminator, RSplitTerminator};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{Matches, RMatches};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{MatchIndices, RMatchIndices};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{from_utf8, from_utf8_mut, Chars, CharIndices, Bytes};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::{from_utf8_unchecked, from_utf8_unchecked_mut, ParseBoolError};\n-#[unstable(feature = \"str_box_extras\", issue = \"41119\")]\n-pub use alloc::str::from_boxed_utf8_unchecked;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use std_unicode::str::SplitWhitespace;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::str::pattern;\n-\n-\n-#[unstable(feature = \"slice_concat_ext\",\n-           reason = \"trait should not have to exist\",\n-           issue = \"27747\")]\n-impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n-    type Output = String;\n-\n-    fn concat(&self) -> String {\n-        if self.is_empty() {\n-            return String::new();\n-        }\n-\n-        // `len` calculation may overflow but push_str will check boundaries\n-        let len = self.iter().map(|s| s.borrow().len()).sum();\n-        let mut result = String::with_capacity(len);\n-\n-        for s in self {\n-            result.push_str(s.borrow())\n-        }\n-\n-        result\n-    }\n-\n-    fn join(&self, sep: &str) -> String {\n-        if self.is_empty() {\n-            return String::new();\n-        }\n-\n-        // concat is faster\n-        if sep.is_empty() {\n-            return self.concat();\n-        }\n-\n-        // this is wrong without the guarantee that `self` is non-empty\n-        // `len` calculation may overflow but push_str but will check boundaries\n-        let len = sep.len() * (self.len() - 1) +\n-                  self.iter().map(|s| s.borrow().len()).sum::<usize>();\n-        let mut result = String::with_capacity(len);\n-        let mut first = true;\n-\n-        for s in self {\n-            if first {\n-                first = false;\n-            } else {\n-                result.push_str(sep);\n-            }\n-            result.push_str(s.borrow());\n-        }\n-        result\n-    }\n-\n-    fn connect(&self, sep: &str) -> String {\n-        self.join(sep)\n-    }\n-}\n-\n-/// An iterator of [`u16`] over the string encoded as UTF-16.\n-///\n-/// [`u16`]: ../../std/primitive.u16.html\n-///\n-/// This struct is created by the [`encode_utf16`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`encode_utf16`]: ../../std/primitive.str.html#method.encode_utf16\n-/// [`str`]: ../../std/primitive.str.html\n-#[derive(Clone)]\n-#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-pub struct EncodeUtf16<'a> {\n-    encoder: Utf16Encoder<Chars<'a>>,\n-}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a> fmt::Debug for EncodeUtf16<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"EncodeUtf16 { .. }\")\n-    }\n-}\n-\n-#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-impl<'a> Iterator for EncodeUtf16<'a> {\n-    type Item = u16;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<u16> {\n-        self.encoder.next()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.encoder.size_hint()\n-    }\n-}\n-\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-impl<'a> FusedIterator for EncodeUtf16<'a> {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Borrow<str> for String {\n-    #[inline]\n-    fn borrow(&self) -> &str {\n-        &self[..]\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ToOwned for str {\n-    type Owned = String;\n-    fn to_owned(&self) -> String {\n-        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }\n-    }\n-\n-    fn clone_into(&self, target: &mut String) {\n-        let mut b = mem::replace(target, String::new()).into_bytes();\n-        self.as_bytes().clone_into(&mut b);\n-        *target = unsafe { String::from_utf8_unchecked(b) }\n-    }\n-}\n-\n-/// Methods for string slices.\n-#[lang = \"str\"]\n-#[cfg(not(test))]\n-impl str {\n-    /// Returns the length of `self`.\n-    ///\n-    /// This length is in bytes, not [`char`]s or graphemes. In other words,\n-    /// it may not be what a human considers the length of the string.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let len = \"foo\".len();\n-    /// assert_eq!(3, len);\n-    ///\n-    /// let len = \"\u0192oo\".len(); // fancy f!\n-    /// assert_eq!(4, len);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn len(&self) -> usize {\n-        core_str::StrExt::len(self)\n-    }\n-\n-    /// Returns `true` if `self` has a length of zero bytes.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"\";\n-    /// assert!(s.is_empty());\n-    ///\n-    /// let s = \"not empty\";\n-    /// assert!(!s.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool {\n-        core_str::StrExt::is_empty(self)\n-    }\n-\n-    /// Checks that `index`-th byte lies at the start and/or end of a\n-    /// UTF-8 code point sequence.\n-    ///\n-    /// The start and end of the string (when `index == self.len()`) are\n-    /// considered to be\n-    /// boundaries.\n-    ///\n-    /// Returns `false` if `index` is greater than `self.len()`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert!(s.is_char_boundary(0));\n-    /// // start of `\u8001`\n-    /// assert!(s.is_char_boundary(6));\n-    /// assert!(s.is_char_boundary(s.len()));\n-    ///\n-    /// // second byte of `\u00f6`\n-    /// assert!(!s.is_char_boundary(2));\n-    ///\n-    /// // third byte of `\u8001`\n-    /// assert!(!s.is_char_boundary(8));\n-    /// ```\n-    #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n-    #[inline]\n-    pub fn is_char_boundary(&self, index: usize) -> bool {\n-        core_str::StrExt::is_char_boundary(self, index)\n-    }\n-\n-    /// Converts a string slice to a byte slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bytes = \"bors\".as_bytes();\n-    /// assert_eq!(b\"bors\", bytes);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline(always)]\n-    pub fn as_bytes(&self) -> &[u8] {\n-        core_str::StrExt::as_bytes(self)\n-    }\n-\n-    /// Converts a mutable string slice to a mutable byte slice.\n-    #[unstable(feature = \"str_mut_extras\", issue = \"41119\")]\n-    #[inline(always)]\n-    pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n-        core_str::StrExt::as_bytes_mut(self)\n-    }\n-\n-    /// Converts a string slice to a raw pointer.\n-    ///\n-    /// As string slices are a slice of bytes, the raw pointer points to a\n-    /// [`u8`]. This pointer will be pointing to the first byte of the string\n-    /// slice.\n-    ///\n-    /// [`u8`]: primitive.u8.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"Hello\";\n-    /// let ptr = s.as_ptr();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn as_ptr(&self) -> *const u8 {\n-        core_str::StrExt::as_ptr(self)\n-    }\n-\n-    /// Returns a subslice of `str`.\n-    ///\n-    /// This is the non-panicking alternative to indexing the `str`. Returns\n-    /// [`None`] whenever equivalent indexing operation would panic.\n-    ///\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(str_checked_slicing)]\n-    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n-    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get(0..4));\n-    /// assert!(v.get(1..).is_none());\n-    /// assert!(v.get(..8).is_none());\n-    /// assert!(v.get(..42).is_none());\n-    /// ```\n-    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n-    #[inline]\n-    pub fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n-        core_str::StrExt::get(self, i)\n-    }\n-\n-    /// Returns a mutable subslice of `str`.\n-    ///\n-    /// This is the non-panicking alternative to indexing the `str`. Returns\n-    /// [`None`] whenever equivalent indexing operation would panic.\n-    ///\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(str_checked_slicing)]\n-    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n-    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get_mut(0..4).map(|v| &*v));\n-    /// assert!(v.get_mut(1..).is_none());\n-    /// assert!(v.get_mut(..8).is_none());\n-    /// assert!(v.get_mut(..42).is_none());\n-    /// ```\n-    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n-    #[inline]\n-    pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n-        core_str::StrExt::get_mut(self, i)\n-    }\n-\n-    /// Returns a unchecked subslice of `str`.\n-    ///\n-    /// This is the unchecked alternative to indexing the `str`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that these preconditions are\n-    /// satisfied:\n-    ///\n-    /// * The starting index must come before the ending index;\n-    /// * Indexes must be within bounds of the original slice;\n-    /// * Indexes must lie on UTF-8 sequence boundaries.\n-    ///\n-    /// Failing that, the returned string slice may reference invalid memory or\n-    /// violate the invariants communicated by the `str` type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(str_checked_slicing)]\n-    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n-    /// unsafe {\n-    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked(0..4));\n-    ///     assert_eq!(\"\u2208\", v.get_unchecked(4..7));\n-    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked(7..11));\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n-    #[inline]\n-    pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n-        core_str::StrExt::get_unchecked(self, i)\n-    }\n-\n-    /// Returns a mutable, unchecked subslice of `str`.\n-    ///\n-    /// This is the unchecked alternative to indexing the `str`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that these preconditions are\n-    /// satisfied:\n-    ///\n-    /// * The starting index must come before the ending index;\n-    /// * Indexes must be within bounds of the original slice;\n-    /// * Indexes must lie on UTF-8 sequence boundaries.\n-    ///\n-    /// Failing that, the returned string slice may reference invalid memory or\n-    /// violate the invariants communicated by the `str` type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(str_checked_slicing)]\n-    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n-    /// unsafe {\n-    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked_mut(0..4));\n-    ///     assert_eq!(\"\u2208\", v.get_unchecked_mut(4..7));\n-    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked_mut(7..11));\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n-    #[inline]\n-    pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n-        core_str::StrExt::get_unchecked_mut(self, i)\n-    }\n-\n-    /// Creates a string slice from another string slice, bypassing safety\n-    /// checks.\n-    ///\n-    /// This is generally not recommended, use with caution! For a safe\n-    /// alternative see [`str`] and [`Index`].\n-    ///\n-    /// [`str`]: primitive.str.html\n-    /// [`Index`]: ops/trait.Index.html\n-    ///\n-    /// This new slice goes from `begin` to `end`, including `begin` but\n-    /// excluding `end`.\n-    ///\n-    /// To get a mutable string slice instead, see the\n-    /// [`slice_mut_unchecked`] method.\n-    ///\n-    /// [`slice_mut_unchecked`]: #method.slice_mut_unchecked\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that three preconditions are\n-    /// satisfied:\n-    ///\n-    /// * `begin` must come before `end`.\n-    /// * `begin` and `end` must be byte positions within the string slice.\n-    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(\"L\u00f6we \u8001\u864e L\u00e9opard\", s.slice_unchecked(0, 21));\n-    /// }\n-    ///\n-    /// let s = \"Hello, world!\";\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(\"world\", s.slice_unchecked(7, 12));\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        core_str::StrExt::slice_unchecked(self, begin, end)\n-    }\n-\n-    /// Creates a string slice from another string slice, bypassing safety\n-    /// checks.\n-    /// This is generally not recommended, use with caution! For a safe\n-    /// alternative see [`str`] and [`IndexMut`].\n-    ///\n-    /// [`str`]: primitive.str.html\n-    /// [`IndexMut`]: ops/trait.IndexMut.html\n-    ///\n-    /// This new slice goes from `begin` to `end`, including `begin` but\n-    /// excluding `end`.\n-    ///\n-    /// To get an immutable string slice instead, see the\n-    /// [`slice_unchecked`] method.\n-    ///\n-    /// [`slice_unchecked`]: #method.slice_unchecked\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that three preconditions are\n-    /// satisfied:\n-    ///\n-    /// * `begin` must come before `end`.\n-    /// * `begin` and `end` must be byte positions within the string slice.\n-    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n-    #[stable(feature = \"str_slice_mut\", since = \"1.5.0\")]\n-    #[inline]\n-    pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n-        core_str::StrExt::slice_mut_unchecked(self, begin, end)\n-    }\n-\n-    /// Divide one string slice into two at an index.\n-    ///\n-    /// The argument, `mid`, should be a byte offset from the start of the\n-    /// string. It must also be on the boundary of a UTF-8 code point.\n-    ///\n-    /// The two slices returned go from the start of the string slice to `mid`,\n-    /// and from `mid` to the end of the string slice.\n-    ///\n-    /// To get mutable string slices instead, see the [`split_at_mut`]\n-    /// method.\n-    ///\n-    /// [`split_at_mut`]: #method.split_at_mut\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n-    /// beyond the last code point of the string slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"Per Martin-L\u00f6f\";\n-    ///\n-    /// let (first, last) = s.split_at(3);\n-    ///\n-    /// assert_eq!(\"Per\", first);\n-    /// assert_eq!(\" Martin-L\u00f6f\", last);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n-    pub fn split_at(&self, mid: usize) -> (&str, &str) {\n-        core_str::StrExt::split_at(self, mid)\n-    }\n-\n-    /// Divide one mutable string slice into two at an index.\n-    ///\n-    /// The argument, `mid`, should be a byte offset from the start of the\n-    /// string. It must also be on the boundary of a UTF-8 code point.\n-    ///\n-    /// The two slices returned go from the start of the string slice to `mid`,\n-    /// and from `mid` to the end of the string slice.\n-    ///\n-    /// To get immutable string slices instead, see the [`split_at`] method.\n-    ///\n-    /// [`split_at`]: #method.split_at\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n-    /// beyond the last code point of the string slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut s = \"Per Martin-L\u00f6f\".to_string();\n-    ///\n-    /// let (first, last) = s.split_at_mut(3);\n-    ///\n-    /// assert_eq!(\"Per\", first);\n-    /// assert_eq!(\" Martin-L\u00f6f\", last);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n-    pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n-        core_str::StrExt::split_at_mut(self, mid)\n-    }\n-\n-    /// Returns an iterator over the [`char`]s of a string slice.\n-    ///\n-    /// As a string slice consists of valid UTF-8, we can iterate through a\n-    /// string slice by [`char`]. This method returns such an iterator.\n-    ///\n-    /// It's important to remember that [`char`] represents a Unicode Scalar\n-    /// Value, and may not match your idea of what a 'character' is. Iteration\n-    /// over grapheme clusters may be what you actually want.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let word = \"goodbye\";\n-    ///\n-    /// let count = word.chars().count();\n-    /// assert_eq!(7, count);\n-    ///\n-    /// let mut chars = word.chars();\n-    ///\n-    /// assert_eq!(Some('g'), chars.next());\n-    /// assert_eq!(Some('o'), chars.next());\n-    /// assert_eq!(Some('o'), chars.next());\n-    /// assert_eq!(Some('d'), chars.next());\n-    /// assert_eq!(Some('b'), chars.next());\n-    /// assert_eq!(Some('y'), chars.next());\n-    /// assert_eq!(Some('e'), chars.next());\n-    ///\n-    /// assert_eq!(None, chars.next());\n-    /// ```\n-    ///\n-    /// Remember, [`char`]s may not match your human intuition about characters:\n-    ///\n-    /// ```\n-    /// let y = \"y\u0306\";\n-    ///\n-    /// let mut chars = y.chars();\n-    ///\n-    /// assert_eq!(Some('y'), chars.next()); // not 'y\u0306'\n-    /// assert_eq!(Some('\\u{0306}'), chars.next());\n-    ///\n-    /// assert_eq!(None, chars.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn chars(&self) -> Chars {\n-        core_str::StrExt::chars(self)\n-    }\n-    /// Returns an iterator over the [`char`]s of a string slice, and their\n-    /// positions.\n-    ///\n-    /// As a string slice consists of valid UTF-8, we can iterate through a\n-    /// string slice by [`char`]. This method returns an iterator of both\n-    /// these [`char`]s, as well as their byte positions.\n-    ///\n-    /// The iterator yields tuples. The position is first, the [`char`] is\n-    /// second.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let word = \"goodbye\";\n-    ///\n-    /// let count = word.char_indices().count();\n-    /// assert_eq!(7, count);\n-    ///\n-    /// let mut char_indices = word.char_indices();\n-    ///\n-    /// assert_eq!(Some((0, 'g')), char_indices.next());\n-    /// assert_eq!(Some((1, 'o')), char_indices.next());\n-    /// assert_eq!(Some((2, 'o')), char_indices.next());\n-    /// assert_eq!(Some((3, 'd')), char_indices.next());\n-    /// assert_eq!(Some((4, 'b')), char_indices.next());\n-    /// assert_eq!(Some((5, 'y')), char_indices.next());\n-    /// assert_eq!(Some((6, 'e')), char_indices.next());\n-    ///\n-    /// assert_eq!(None, char_indices.next());\n-    /// ```\n-    ///\n-    /// Remember, [`char`]s may not match your human intuition about characters:\n-    ///\n-    /// ```\n-    /// let y = \"y\u0306\";\n-    ///\n-    /// let mut char_indices = y.char_indices();\n-    ///\n-    /// assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y\u0306')\n-    /// assert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n-    ///\n-    /// assert_eq!(None, char_indices.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn char_indices(&self) -> CharIndices {\n-        core_str::StrExt::char_indices(self)\n-    }\n-\n-    /// An iterator over the bytes of a string slice.\n-    ///\n-    /// As a string slice consists of a sequence of bytes, we can iterate\n-    /// through a string slice by byte. This method returns such an iterator.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut bytes = \"bors\".bytes();\n-    ///\n-    /// assert_eq!(Some(b'b'), bytes.next());\n-    /// assert_eq!(Some(b'o'), bytes.next());\n-    /// assert_eq!(Some(b'r'), bytes.next());\n-    /// assert_eq!(Some(b's'), bytes.next());\n-    ///\n-    /// assert_eq!(None, bytes.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn bytes(&self) -> Bytes {\n-        core_str::StrExt::bytes(self)\n-    }\n-\n-    /// Split a string slice by whitespace.\n-    ///\n-    /// The iterator returned will return string slices that are sub-slices of\n-    /// the original string slice, separated by any amount of whitespace.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut iter = \"A few words\".split_whitespace();\n-    ///\n-    /// assert_eq!(Some(\"A\"), iter.next());\n-    /// assert_eq!(Some(\"few\"), iter.next());\n-    /// assert_eq!(Some(\"words\"), iter.next());\n-    ///\n-    /// assert_eq!(None, iter.next());\n-    /// ```\n-    ///\n-    /// All kinds of whitespace are considered:\n-    ///\n-    /// ```\n-    /// let mut iter = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\".split_whitespace();\n-    /// assert_eq!(Some(\"Mary\"), iter.next());\n-    /// assert_eq!(Some(\"had\"), iter.next());\n-    /// assert_eq!(Some(\"a\"), iter.next());\n-    /// assert_eq!(Some(\"little\"), iter.next());\n-    /// assert_eq!(Some(\"lamb\"), iter.next());\n-    ///\n-    /// assert_eq!(None, iter.next());\n-    /// ```\n-    #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-    #[inline]\n-    pub fn split_whitespace(&self) -> SplitWhitespace {\n-        UnicodeStr::split_whitespace(self)\n-    }\n-\n-    /// An iterator over the lines of a string, as string slices.\n-    ///\n-    /// Lines are ended with either a newline (`\\n`) or a carriage return with\n-    /// a line feed (`\\r\\n`).\n-    ///\n-    /// The final line ending is optional.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let text = \"foo\\r\\nbar\\n\\nbaz\\n\";\n-    /// let mut lines = text.lines();\n-    ///\n-    /// assert_eq!(Some(\"foo\"), lines.next());\n-    /// assert_eq!(Some(\"bar\"), lines.next());\n-    /// assert_eq!(Some(\"\"), lines.next());\n-    /// assert_eq!(Some(\"baz\"), lines.next());\n-    ///\n-    /// assert_eq!(None, lines.next());\n-    /// ```\n-    ///\n-    /// The final line ending isn't required:\n-    ///\n-    /// ```\n-    /// let text = \"foo\\nbar\\n\\r\\nbaz\";\n-    /// let mut lines = text.lines();\n-    ///\n-    /// assert_eq!(Some(\"foo\"), lines.next());\n-    /// assert_eq!(Some(\"bar\"), lines.next());\n-    /// assert_eq!(Some(\"\"), lines.next());\n-    /// assert_eq!(Some(\"baz\"), lines.next());\n-    ///\n-    /// assert_eq!(None, lines.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn lines(&self) -> Lines {\n-        core_str::StrExt::lines(self)\n-    }\n-\n-    /// An iterator over the lines of a string.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.4.0\", reason = \"use lines() instead now\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn lines_any(&self) -> LinesAny {\n-        core_str::StrExt::lines_any(self)\n-    }\n-\n-    /// Returns an iterator of `u16` over the string encoded as UTF-16.\n-    #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-    pub fn encode_utf16(&self) -> EncodeUtf16 {\n-        EncodeUtf16 { encoder: Utf16Encoder::new(self[..].chars()) }\n-    }\n-\n-    /// Returns `true` if the given pattern matches a sub-slice of\n-    /// this string slice.\n-    ///\n-    /// Returns `false` if it does not.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bananas = \"bananas\";\n-    ///\n-    /// assert!(bananas.contains(\"nana\"));\n-    /// assert!(!bananas.contains(\"apples\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        core_str::StrExt::contains(self, pat)\n-    }\n-\n-    /// Returns `true` if the given pattern matches a prefix of this\n-    /// string slice.\n-    ///\n-    /// Returns `false` if it does not.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bananas = \"bananas\";\n-    ///\n-    /// assert!(bananas.starts_with(\"bana\"));\n-    /// assert!(!bananas.starts_with(\"nana\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        core_str::StrExt::starts_with(self, pat)\n-    }\n-\n-    /// Returns `true` if the given pattern matches a suffix of this\n-    /// string slice.\n-    ///\n-    /// Returns `false` if it does not.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bananas = \"bananas\";\n-    ///\n-    /// assert!(bananas.ends_with(\"anas\"));\n-    /// assert!(!bananas.ends_with(\"nana\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::ends_with(self, pat)\n-    }\n-\n-    /// Returns the byte index of the first character of this string slice that\n-    /// matches the pattern.\n-    ///\n-    /// Returns [`None`] if the pattern doesn't match.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find('L'), Some(0));\n-    /// assert_eq!(s.find('\u00e9'), Some(14));\n-    /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n-    /// ```\n-    ///\n-    /// More complex patterns with closures:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find(char::is_whitespace), Some(5));\n-    /// assert_eq!(s.find(char::is_lowercase), Some(1));\n-    /// ```\n-    ///\n-    /// Not finding the pattern:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let x: &[_] = &['1', '2'];\n-    ///\n-    /// assert_eq!(s.find(x), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n-        core_str::StrExt::find(self, pat)\n-    }\n-\n-    /// Returns the byte index of the last character of this string slice that\n-    /// matches the pattern.\n-    ///\n-    /// Returns [`None`] if the pattern doesn't match.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.rfind('L'), Some(13));\n-    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n-    /// ```\n-    ///\n-    /// More complex patterns with closures:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.rfind(char::is_whitespace), Some(12));\n-    /// assert_eq!(s.rfind(char::is_lowercase), Some(20));\n-    /// ```\n-    ///\n-    /// Not finding the pattern:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let x: &[_] = &['1', '2'];\n-    ///\n-    /// assert_eq!(s.rfind(x), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rfind(self, pat)\n-    }\n-\n-    /// An iterator over substrings of this string slice, separated by\n-    /// characters matched by a pattern.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rsplit`] method can be used.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    /// [`rsplit`]: #method.rsplit\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".split('X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\n-    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\n-    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\n-    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n-    /// ```\n-    ///\n-    /// If a string contains multiple contiguous separators, you will end up\n-    /// with empty strings in the output:\n-    ///\n-    /// ```\n-    /// let x = \"||||a||b|c\".to_string();\n-    /// let d: Vec<_> = x.split('|').collect();\n-    ///\n-    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n-    /// ```\n-    ///\n-    /// Contiguous separators are separated by the empty string.\n-    ///\n-    /// ```\n-    /// let x = \"(///)\".to_string();\n-    /// let d: Vec<_> = x.split('/').collect();\n-    ///\n-    /// assert_eq!(d, &[\"(\", \"\", \"\", \")\"]);\n-    /// ```\n-    ///\n-    /// Separators at the start or end of a string are neighbored\n-    /// by empty strings.\n-    ///\n-    /// ```\n-    /// let d: Vec<_> = \"010\".split(\"0\").collect();\n-    /// assert_eq!(d, &[\"\", \"1\", \"\"]);\n-    /// ```\n-    ///\n-    /// When the empty string is used as a separator, it separates\n-    /// every character in the string, along with the beginning\n-    /// and end of the string.\n-    ///\n-    /// ```\n-    /// let f: Vec<_> = \"rust\".split(\"\").collect();\n-    /// assert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);\n-    /// ```\n-    ///\n-    /// Contiguous separators can lead to possibly surprising behavior\n-    /// when whitespace is used as the separator. This code is correct:\n-    ///\n-    /// ```\n-    /// let x = \"    a  b c\".to_string();\n-    /// let d: Vec<_> = x.split(' ').collect();\n-    ///\n-    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n-    /// ```\n-    ///\n-    /// It does _not_ give you:\n-    ///\n-    /// ```,ignore\n-    /// assert_eq!(d, &[\"a\", \"b\", \"c\"]);\n-    /// ```\n-    ///\n-    /// Use [`split_whitespace`] for this behavior.\n-    ///\n-    /// [`split_whitespace`]: #method.split_whitespace\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n-        core_str::StrExt::split(self, pat)\n-    }\n-\n-    /// An iterator over substrings of the given string slice, separated by\n-    /// characters matched by a pattern and yielded in reverse order.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a reverse\n-    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// For iterating from the front, the [`split`] method can be used.\n-    ///\n-    /// [`split`]: #method.split\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n-    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".rsplit('X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rsplit(self, pat)\n-    }\n-\n-    /// An iterator over substrings of the given string slice, separated by\n-    /// characters matched by a pattern.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// Equivalent to [`split`], except that the trailing substring\n-    /// is skipped if empty.\n-    ///\n-    /// [`split`]: #method.split\n-    ///\n-    /// This method can be used for string data that is _terminated_,\n-    /// rather than _separated_ by a pattern.\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rsplit_terminator`] method can be used.\n-    ///\n-    /// [`rsplit_terminator`]: #method.rsplit_terminator\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n-    /// assert_eq!(v, [\"A\", \"B\"]);\n-    ///\n-    /// let v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\n-    /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n-        core_str::StrExt::split_terminator(self, pat)\n-    }\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by a pattern and yielded in reverse order.\n-    ///\n-    /// The pattern can be a simple `&str`, [`char`], or a closure that\n-    /// determines the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// Equivalent to [`split`], except that the trailing substring is\n-    /// skipped if empty.\n-    ///\n-    /// [`split`]: #method.split\n-    ///\n-    /// This method can be used for string data that is _terminated_,\n-    /// rather than _separated_ by a pattern.\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a\n-    /// reverse search, and it will be double ended if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// For iterating from the front, the [`split_terminator`] method can be\n-    /// used.\n-    ///\n-    /// [`split_terminator`]: #method.split_terminator\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\n-    /// assert_eq!(v, [\"B\", \"A\"]);\n-    ///\n-    /// let v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\n-    /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rsplit_terminator(self, pat)\n-    }\n-\n-    /// An iterator over substrings of the given string slice, separated by a\n-    /// pattern, restricted to returning at most `n` items.\n-    ///\n-    /// If `n` substrings are returned, the last substring (the `n`th substring)\n-    /// will contain the remainder of the string.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will not be double ended, because it is\n-    /// not efficient to support.\n-    ///\n-    /// If the pattern allows a reverse search, the [`rsplitn`] method can be\n-    /// used.\n-    ///\n-    /// [`rsplitn`]: #method.rsplitn\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, [\"abcXdef\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"abc\", \"defXghi\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn splitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> SplitN<'a, P> {\n-        core_str::StrExt::splitn(self, n, pat)\n-    }\n-\n-    /// An iterator over substrings of this string slice, separated by a\n-    /// pattern, starting from the end of the string, restricted to returning\n-    /// at most `n` items.\n-    ///\n-    /// If `n` substrings are returned, the last substring (the `n`th substring)\n-    /// will contain the remainder of the string.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines the split.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will not be double ended, because it is not\n-    /// efficient to support.\n-    ///\n-    /// For splitting from the front, the [`splitn`] method can be used.\n-    ///\n-    /// [`splitn`]: #method.splitn\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n-    /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n-    /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rsplitn(self, n, pat)\n-    }\n-\n-    /// An iterator over the disjoint matches of a pattern within the given string\n-    /// slice.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines if a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rmatches`] method can be used.\n-    ///\n-    /// [`rmatches`]: #method.rmatches\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\n-    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n-    ///\n-    /// let v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\n-    /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n-    /// ```\n-    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n-    #[inline]\n-    pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n-        core_str::StrExt::matches(self, pat)\n-    }\n-\n-    /// An iterator over the disjoint matches of a pattern within this string slice,\n-    /// yielded in reverse order.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a reverse\n-    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// For iterating from the front, the [`matches`] method can be used.\n-    ///\n-    /// [`matches`]: #method.matches\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\n-    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n-    ///\n-    /// let v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\n-    /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n-    /// ```\n-    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n-    #[inline]\n-    pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rmatches(self, pat)\n-    }\n-\n-    /// An iterator over the disjoint matches of a pattern within this string\n-    /// slice as well as the index that the match starts at.\n-    ///\n-    /// For matches of `pat` within `self` that overlap, only the indices\n-    /// corresponding to the first match are returned.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines\n-    /// if a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rmatch_indices`] method can be used.\n-    ///\n-    /// [`rmatch_indices`]: #method.rmatch_indices\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\n-    /// assert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n-    /// ```\n-    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n-        core_str::StrExt::match_indices(self, pat)\n-    }\n-\n-    /// An iterator over the disjoint matches of a pattern within `self`,\n-    /// yielded in reverse order along with the index of the match.\n-    ///\n-    /// For matches of `pat` within `self` that overlap, only the indices\n-    /// corresponding to the last match are returned.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if a\n-    /// character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a reverse\n-    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// For iterating from the front, the [`match_indices`] method can be used.\n-    ///\n-    /// [`match_indices`]: #method.match_indices\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<_> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(12, \"abc\"), (6, \"abc\"), (0, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(4, \"abc\"), (1, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"ababa\".rmatch_indices(\"aba\").collect();\n-    /// assert_eq!(v, [(2, \"aba\")]); // only the last `aba`\n-    /// ```\n-    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rmatch_indices(self, pat)\n-    }\n-\n-    /// Returns a string slice with leading and trailing whitespace removed.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    ///\n-    /// assert_eq!(\"Hello\\tworld\", s.trim());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim(&self) -> &str {\n-        UnicodeStr::trim(self)\n-    }\n-\n-    /// Returns a string slice with leading whitespace removed.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Left' in this context means the first\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _right_ side, not the left.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    ///\n-    /// assert_eq!(\"Hello\\tworld\\t\", s.trim_left());\n-    /// ```\n-    ///\n-    /// Directionality:\n-    ///\n-    /// ```\n-    /// let s = \"  English\";\n-    /// assert!(Some('E') == s.trim_left().chars().next());\n-    ///\n-    /// let s = \"  \u05e2\u05d1\u05e8\u05d9\u05ea\";\n-    /// assert!(Some('\u05e2') == s.trim_left().chars().next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_left(&self) -> &str {\n-        UnicodeStr::trim_left(self)\n-    }\n-\n-    /// Returns a string slice with trailing whitespace removed.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Right' in this context means the last\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _left_ side, not the right.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    ///\n-    /// assert_eq!(\" Hello\\tworld\", s.trim_right());\n-    /// ```\n-    ///\n-    /// Directionality:\n-    ///\n-    /// ```\n-    /// let s = \"English  \";\n-    /// assert!(Some('h') == s.trim_right().chars().rev().next());\n-    ///\n-    /// let s = \"\u05e2\u05d1\u05e8\u05d9\u05ea  \";\n-    /// assert!(Some('\u05ea') == s.trim_right().chars().rev().next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_right(&self) -> &str {\n-        UnicodeStr::trim_right(self)\n-    }\n-\n-    /// Returns a string slice with all prefixes and suffixes that match a\n-    /// pattern repeatedly removed.\n-    ///\n-    /// The pattern can be a [`char`] or a closure that determines if a\n-    /// character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n-    ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: DoubleEndedSearcher<'a>\n-    {\n-        core_str::StrExt::trim_matches(self, pat)\n-    }\n-\n-    /// Returns a string slice with all prefixes that match a pattern\n-    /// repeatedly removed.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Left' in this context means the first\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _right_ side, not the left.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n-    /// assert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n-    ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n-        core_str::StrExt::trim_left_matches(self, pat)\n-    }\n-\n-    /// Returns a string slice with all suffixes that match a pattern\n-    /// repeatedly removed.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines if a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Right' in this context means the last\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _left_ side, not the right.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n-    ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"1fooX\".trim_left_matches(|c| c == '1' || c == 'X'), \"fooX\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::trim_right_matches(self, pat)\n-    }\n-\n-    /// Parses this string slice into another type.\n-    ///\n-    /// Because `parse` is so general, it can cause problems with type\n-    /// inference. As such, `parse` is one of the few times you'll see\n-    /// the syntax affectionately known as the 'turbofish': `::<>`. This\n-    /// helps the inference algorithm understand specifically which type\n-    /// you're trying to parse into.\n-    ///\n-    /// `parse` can parse any type that implements the [`FromStr`] trait.\n-    ///\n-    /// [`FromStr`]: str/trait.FromStr.html\n-    ///\n-    /// # Errors\n-    ///\n-    /// Will return [`Err`] if it's not possible to parse this string slice into\n-    /// the desired type.\n-    ///\n-    /// [`Err`]: str/trait.FromStr.html#associatedtype.Err\n-    ///\n-    /// # Example\n-    ///\n-    /// Basic usage\n-    ///\n-    /// ```\n-    /// let four: u32 = \"4\".parse().unwrap();\n-    ///\n-    /// assert_eq!(4, four);\n-    /// ```\n-    ///\n-    /// Using the 'turbofish' instead of annotating `four`:\n-    ///\n-    /// ```\n-    /// let four = \"4\".parse::<u32>();\n-    ///\n-    /// assert_eq!(Ok(4), four);\n-    /// ```\n-    ///\n-    /// Failing to parse:\n-    ///\n-    /// ```\n-    /// let nope = \"j\".parse::<u32>();\n-    ///\n-    /// assert!(nope.is_err());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n-        core_str::StrExt::parse(self)\n-    }\n-\n-    /// Converts a `Box<str>` into a `Box<[u8]>` without copying or allocating.\n-    #[unstable(feature = \"str_box_extras\", issue = \"41119\")]\n-    pub fn into_boxed_bytes(self: Box<str>) -> Box<[u8]> {\n-        self.into()\n-    }\n-\n-    /// Replaces all matches of a pattern with another string.\n-    ///\n-    /// `replace` creates a new [`String`], and copies the data from this string slice into it.\n-    /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n-    /// replaces them with the replacement string slice.\n-    ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"this is old\";\n-    ///\n-    /// assert_eq!(\"this is new\", s.replace(\"old\", \"new\"));\n-    /// ```\n-    ///\n-    /// When the pattern doesn't match:\n-    ///\n-    /// ```\n-    /// let s = \"this is old\";\n-    /// assert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String {\n-        let mut result = String::new();\n-        let mut last_end = 0;\n-        for (start, part) in self.match_indices(from) {\n-            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n-            result.push_str(to);\n-            last_end = start + part.len();\n-        }\n-        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n-        result\n-    }\n-\n-    /// Replaces first N matches of a pattern with another string.\n-    ///\n-    /// `replacen` creates a new [`String`], and copies the data from this string slice into it.\n-    /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n-    /// replaces them with the replacement string slice at most `count` times.\n-    ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"foo foo 123 foo\";\n-    /// assert_eq!(\"new new 123 foo\", s.replacen(\"foo\", \"new\", 2));\n-    /// assert_eq!(\"faa fao 123 foo\", s.replacen('o', \"a\", 3));\n-    /// assert_eq!(\"foo foo new23 foo\", s.replacen(char::is_numeric, \"new\", 1));\n-    /// ```\n-    ///\n-    /// When the pattern doesn't match:\n-    ///\n-    /// ```\n-    /// let s = \"this is old\";\n-    /// assert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n-    /// ```\n-    #[stable(feature = \"str_replacen\", since = \"1.16.0\")]\n-    pub fn replacen<'a, P: Pattern<'a>>(&'a self, pat: P, to: &str, count: usize) -> String {\n-        // Hope to reduce the times of re-allocation\n-        let mut result = String::with_capacity(32);\n-        let mut last_end = 0;\n-        for (start, part) in self.match_indices(pat).take(count) {\n-            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n-            result.push_str(to);\n-            last_end = start + part.len();\n-        }\n-        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n-        result\n-    }\n-\n-    /// Returns the lowercase equivalent of this string slice, as a new [`String`].\n-    ///\n-    /// 'Lowercase' is defined according to the terms of the Unicode Derived Core Property\n-    /// `Lowercase`.\n-    ///\n-    /// Since some characters can expand into multiple characters when changing\n-    /// the case, this function returns a [`String`] instead of modifying the\n-    /// parameter in-place.\n-    ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"HELLO\";\n-    ///\n-    /// assert_eq!(\"hello\", s.to_lowercase());\n-    /// ```\n-    ///\n-    /// A tricky example, with sigma:\n-    ///\n-    /// ```\n-    /// let sigma = \"\u03a3\";\n-    ///\n-    /// assert_eq!(\"\u03c3\", sigma.to_lowercase());\n-    ///\n-    /// // but at the end of a word, it's \u03c2, not \u03c3:\n-    /// let odysseus = \"\u1f48\u0394\u03a5\u03a3\u03a3\u0395\u038e\u03a3\";\n-    ///\n-    /// assert_eq!(\"\u1f40\u03b4\u03c5\u03c3\u03c3\u03b5\u03cd\u03c2\", odysseus.to_lowercase());\n-    /// ```\n-    ///\n-    /// Languages without case are not changed:\n-    ///\n-    /// ```\n-    /// let new_year = \"\u519c\u5386\u65b0\u5e74\";\n-    ///\n-    /// assert_eq!(new_year, new_year.to_lowercase());\n-    /// ```\n-    #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n-    pub fn to_lowercase(&self) -> String {\n-        let mut s = String::with_capacity(self.len());\n-        for (i, c) in self[..].char_indices() {\n-            if c == '\u03a3' {\n-                // \u03a3 maps to \u03c3, except at the end of a word where it maps to \u03c2.\n-                // This is the only conditional (contextual) but language-independent mapping\n-                // in `SpecialCasing.txt`,\n-                // so hard-code it rather than have a generic \"condition\" mechanism.\n-                // See https://github.com/rust-lang/rust/issues/26035\n-                map_uppercase_sigma(self, i, &mut s)\n-            } else {\n-                s.extend(c.to_lowercase());\n-            }\n-        }\n-        return s;\n-\n-        fn map_uppercase_sigma(from: &str, i: usize, to: &mut String) {\n-            // See http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n-            // for the definition of `Final_Sigma`.\n-            debug_assert!('\u03a3'.len_utf8() == 2);\n-            let is_word_final = case_ignoreable_then_cased(from[..i].chars().rev()) &&\n-                                !case_ignoreable_then_cased(from[i + 2..].chars());\n-            to.push_str(if is_word_final { \"\u03c2\" } else { \"\u03c3\" });\n-        }\n-\n-        fn case_ignoreable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {\n-            use std_unicode::derived_property::{Cased, Case_Ignorable};\n-            match iter.skip_while(|&c| Case_Ignorable(c)).next() {\n-                Some(c) => Cased(c),\n-                None => false,\n-            }\n-        }\n-    }\n-\n-    /// Returns the uppercase equivalent of this string slice, as a new [`String`].\n-    ///\n-    /// 'Uppercase' is defined according to the terms of the Unicode Derived Core Property\n-    /// `Uppercase`.\n-    ///\n-    /// Since some characters can expand into multiple characters when changing\n-    /// the case, this function returns a [`String`] instead of modifying the\n-    /// parameter in-place.\n-    ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"hello\";\n-    ///\n-    /// assert_eq!(\"HELLO\", s.to_uppercase());\n-    /// ```\n-    ///\n-    /// Scripts without case are not changed:\n-    ///\n-    /// ```\n-    /// let new_year = \"\u519c\u5386\u65b0\u5e74\";\n-    ///\n-    /// assert_eq!(new_year, new_year.to_uppercase());\n-    /// ```\n-    #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n-    pub fn to_uppercase(&self) -> String {\n-        let mut s = String::with_capacity(self.len());\n-        s.extend(self.chars().flat_map(|c| c.to_uppercase()));\n-        return s;\n-    }\n-\n-    /// Escapes each char in `s` with [`char::escape_debug`].\n-    ///\n-    /// [`char::escape_debug`]: primitive.char.html#method.escape_debug\n-    #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\",\n-               issue = \"27791\")]\n-    pub fn escape_debug(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_debug()).collect()\n-    }\n-\n-    /// Escapes each char in `s` with [`char::escape_default`].\n-    ///\n-    /// [`char::escape_default`]: primitive.char.html#method.escape_default\n-    #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\",\n-               issue = \"27791\")]\n-    pub fn escape_default(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_default()).collect()\n-    }\n-\n-    /// Escapes each char in `s` with [`char::escape_unicode`].\n-    ///\n-    /// [`char::escape_unicode`]: primitive.char.html#method.escape_unicode\n-    #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\",\n-               issue = \"27791\")]\n-    pub fn escape_unicode(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_unicode()).collect()\n-    }\n-\n-    /// Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n-    ///\n-    /// [`String`]: string/struct.String.html\n-    /// [`Box<str>`]: boxed/struct.Box.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let string = String::from(\"birthday gift\");\n-    /// let boxed_str = string.clone().into_boxed_str();\n-    ///\n-    /// assert_eq!(boxed_str.into_string(), string);\n-    /// ```\n-    #[stable(feature = \"box_str\", since = \"1.4.0\")]\n-    pub fn into_string(self: Box<str>) -> String {\n-        unsafe {\n-            let slice = mem::transmute::<Box<str>, Box<[u8]>>(self);\n-            String::from_utf8_unchecked(slice.into_vec())\n-        }\n-    }\n-\n-    /// Create a [`String`] by repeating a string `n` times.\n-    ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"abc\".repeat(4), String::from(\"abcabcabcabc\"));\n-    /// ```\n-    #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n-    pub fn repeat(&self, n: usize) -> String {\n-        let mut s = String::with_capacity(self.len() * n);\n-        s.extend((0..n).map(|_| self));\n-        s\n-    }\n-}"}, {"sha": "c374f40097441928933e5876ff3d8232bb36db3f", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -2015,7 +2015,7 @@ mod traits {\n            issue = \"32110\")]\n pub trait StrExt {\n     // NB there are no docs here are they're all located on the StrExt trait in\n-    // libcollections, not here.\n+    // liballoc, not here.\n \n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;"}, {"sha": "5bd57236e7c28579e485f746da9565f6fbdde472", "filename": "src/librustc_data_structures/fnv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibrustc_data_structures%2Ffnv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibrustc_data_structures%2Ffnv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffnv.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -26,7 +26,7 @@ pub fn FnvHashSet<V: Hash + Eq>() -> FnvHashSet<V> {\n }\n \n /// A speedy hash algorithm for node ids and def ids. The hashmap in\n-/// libcollections by default uses SipHash which isn't quite as speedy as we\n+/// liballoc by default uses SipHash which isn't quite as speedy as we\n /// want. In the compiler we're not really worried about DOS attempts, so we\n /// just default to a non-cryptographic hash.\n ///"}, {"sha": "00dfc1617a8b6020ca168e1c90957e558e285ccf", "filename": "src/librustc_data_structures/fx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibrustc_data_structures%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibrustc_data_structures%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffx.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -26,7 +26,7 @@ pub fn FxHashSet<V: Hash + Eq>() -> FxHashSet<V> {\n     HashSet::default()\n }\n \n-/// A speedy hash algorithm for use within rustc. The hashmap in libcollections\n+/// A speedy hash algorithm for use within rustc. The hashmap in liballoc\n /// by default uses SipHash which isn't quite as speedy as we want. In the\n /// compiler we're not really worried about DOS attempts, so we use a fast\n /// non-cryptographic hash."}, {"sha": "87c85a5fc96b82e225c95765183673a8ba60648b", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -188,16 +188,16 @@ already been imported.\n Erroneous code example:\n \n ```compile_fail,E0254\n-extern crate collections;\n+extern crate alloc;\n \n mod foo {\n-    pub trait collections {\n+    pub trait alloc {\n         fn do_something();\n     }\n }\n \n-use foo::collections; // error: an extern crate named `collections` has already\n-                      //        been imported in this module\n+use foo::alloc; // error: an extern crate named `alloc` has already\n+                //        been imported in this module\n \n fn main() {}\n ```\n@@ -206,15 +206,15 @@ To fix issue issue, you have to rename at least one of the two imports.\n Example:\n \n ```ignore\n-extern crate collections as libcollections; // ok!\n+extern crate alloc as liballoc; // ok!\n \n mod foo {\n-    pub trait collections {\n+    pub trait alloc {\n         fn do_something();\n     }\n }\n \n-use foo::collections;\n+use foo::alloc;\n \n fn main() {}\n ```\n@@ -1425,7 +1425,7 @@ Erroneous code example:\n \n ```compile_fail,E0469\n #[macro_use(drink, be_merry)] // error: imported macro not found\n-extern crate collections;\n+extern crate alloc;\n \n fn main() {\n     // ...\n@@ -1467,7 +1467,7 @@ Erroneous code example:\n \n ```compile_fail,E0470\n #[macro_reexport(drink, be_merry)]\n-extern crate collections;\n+extern crate alloc;\n \n fn main() {\n     // ..."}, {"sha": "f6103a259dcd6ddf5509a38c47dda47de5490fbd", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -2265,8 +2265,8 @@ If `ForeignTrait` is a trait defined in some external crate `foo`, then the\n following trait `impl` is an error:\n \n ```compile_fail,E0210\n-extern crate collections;\n-use collections::range::RangeArgument;\n+extern crate alloc;\n+use alloc::range::RangeArgument;\n \n impl<T> RangeArgument<T> for T { } // error\n "}, {"sha": "1a995276931d84944ffb3d85b9361acb2c082bfd", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Implementations of serialization for structures found in libcollections\n+//! Implementations of serialization for structures found in liballoc\n \n use std::hash::{Hash, BuildHasher};\n "}, {"sha": "ca27b34d6810044681932bd22ae78b784b049a54", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -28,15 +28,12 @@ Core encoding and decoding interfaces.\n #![deny(warnings)]\n \n #![feature(box_syntax)]\n-#![feature(collections)]\n #![feature(core_intrinsics)]\n #![feature(i128_type)]\n #![feature(specialization)]\n #![cfg_attr(stage0, feature(staged_api))]\n #![cfg_attr(test, feature(test))]\n \n-extern crate collections;\n-\n pub use self::serialize::{Decoder, Encoder, Decodable, Encodable};\n \n pub use self::serialize::{SpecializationError, SpecializedEncoder, SpecializedDecoder};"}, {"sha": "f93af4c192016201ed30b2d88dd503a52e9cdfb7", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -15,7 +15,6 @@ alloc_jemalloc = { path = \"../liballoc_jemalloc\", optional = true }\n alloc_system = { path = \"../liballoc_system\" }\n panic_unwind = { path = \"../libpanic_unwind\", optional = true }\n panic_abort = { path = \"../libpanic_abort\" }\n-collections = { path = \"../libcollections\" }\n core = { path = \"../libcore\" }\n libc = { path = \"../rustc/libc_shim\" }\n rand = { path = \"../librand\" }"}, {"sha": "b8a6a66eaa65d60201d107319749cc7336af40a6", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -420,23 +420,23 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::Bound;\n+pub use alloc::Bound;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::{BinaryHeap, BTreeMap, BTreeSet};\n+pub use alloc::{BinaryHeap, BTreeMap, BTreeSet};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::{LinkedList, VecDeque};\n+pub use alloc::{LinkedList, VecDeque};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::{binary_heap, btree_map, btree_set};\n+pub use alloc::{binary_heap, btree_map, btree_set};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::{linked_list, vec_deque};\n+pub use alloc::{linked_list, vec_deque};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::hash_map::HashMap;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::hash_set::HashSet;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::range;\n+pub use alloc::range;\n \n mod hash;\n "}, {"sha": "f307fbb7c003360108cc801cfe6d3e31781ee8fa", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -254,7 +254,6 @@\n #![feature(cfg_target_vendor)]\n #![feature(char_escape_debug)]\n #![feature(char_internals)]\n-#![feature(collections)]\n #![feature(collections_range)]\n #![feature(compiler_builtins_lib)]\n #![feature(const_fn)]\n@@ -337,11 +336,9 @@ use prelude::v1::*;\n                  debug_assert_ne, unreachable, unimplemented, write, writeln, try)]\n extern crate core as __core;\n \n+#[allow(deprecated)] extern crate rand as core_rand;\n #[macro_use]\n #[macro_reexport(vec, format)]\n-extern crate collections as core_collections;\n-\n-#[allow(deprecated)] extern crate rand as core_rand;\n extern crate alloc;\n extern crate std_unicode;\n extern crate libc;\n@@ -430,17 +427,17 @@ pub use alloc::boxed;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc::rc;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::borrow;\n+pub use alloc::borrow;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::fmt;\n+pub use alloc::fmt;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::slice;\n+pub use alloc::slice;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::str;\n+pub use alloc::str;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::string;\n+pub use alloc::string;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::vec;\n+pub use alloc::vec;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use std_unicode::char;\n #[unstable(feature = \"i128\", issue = \"35118\")]"}, {"sha": "19f2ad1c56f2dc65d0b32e399dad8d75d1304783", "filename": "src/libstd_unicode/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibstd_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibstd_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Flib.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -52,7 +52,7 @@ pub mod str {\n     pub use u_str::Utf16Encoder;\n }\n \n-// For use in libcollections, not re-exported in libstd.\n+// For use in liballoc, not re-exported in libstd.\n pub mod derived_property {\n     pub use tables::derived_property::{Case_Ignorable, Cased};\n }"}, {"sha": "54a5288a57c8b4c39c30a948efe7d729ec754121", "filename": "src/libstd_unicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibstd_unicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Flibstd_unicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fu_str.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -32,7 +32,7 @@ pub struct SplitWhitespace<'a> {\n }\n \n /// Methods for Unicode string slices\n-#[allow(missing_docs)] // docs in libcollections\n+#[allow(missing_docs)] // docs in liballoc\n pub trait UnicodeStr {\n     fn split_whitespace<'a>(&'a self) -> SplitWhitespace<'a>;\n     fn is_whitespace(&self) -> bool;"}, {"sha": "bc17a46a0172a295b619040c585b5adab01ba3e4", "filename": "src/test/compile-fail/E0254.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Fcompile-fail%2FE0254.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Fcompile-fail%2FE0254.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0254.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,18 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(collections)]\n+#![feature(alloc)]\n \n-extern crate collections;\n-//~^ NOTE previous import of `collections` here\n+extern crate alloc;\n+//~^ NOTE previous import of `alloc` here\n \n mod foo {\n-    pub trait collections {\n+    pub trait alloc {\n         fn do_something();\n     }\n }\n \n-use foo::collections;\n+use foo::alloc;\n //~^ ERROR E0254\n //~| NOTE already imported\n "}, {"sha": "259d67fe7cd6caee63f4ffb3d796679059c20ccf", "filename": "src/test/compile-fail/E0259.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Fcompile-fail%2FE0259.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Fcompile-fail%2FE0259.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0259.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(collections, libc)]\n+#![feature(alloc, libc)]\n \n-extern crate collections;\n-//~^ NOTE previous import of `collections` here\n+extern crate alloc;\n+//~^ NOTE previous import of `alloc` here\n \n-extern crate libc as collections;\n+extern crate libc as alloc;\n //~^ ERROR E0259\n-//~| NOTE `collections` already imported\n+//~| NOTE `alloc` already imported\n \n fn main() {}"}, {"sha": "08d78782e4cd7ab104dd2a0ec219d6b53e3beec7", "filename": "src/test/compile-fail/E0260.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Fcompile-fail%2FE0260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Fcompile-fail%2FE0260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0260.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(collections)]\n+#![feature(alloc)]\n \n-extern crate collections;\n-//~^ NOTE previous import of `collections` here\n+extern crate alloc;\n+//~^ NOTE previous import of `alloc` here\n \n-mod collections {\n-//~^ ERROR `collections` has already been imported in this module [E0260]\n-//~| NOTE `collections` already imported\n+mod alloc {\n+//~^ ERROR `alloc` has already been imported in this module [E0260]\n+//~| NOTE `alloc` already imported\n     pub trait MyTrait {\n         fn do_something();\n     }"}, {"sha": "010c55afb2b838ab5baae7ab74983d647a2f556c", "filename": "src/test/compile-fail/lint-unused-extern-crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -13,13 +13,13 @@\n #![deny(unused_extern_crates)]\n #![allow(unused_variables)]\n #![allow(deprecated)]\n+#![feature(alloc)]\n #![feature(libc)]\n-#![feature(collections)]\n #![feature(rand)]\n \n extern crate libc; //~ ERROR: unused extern crate\n \n-extern crate collections as collecs; // no error, it is used\n+extern crate alloc as collecs; // no error, it is used\n \n extern crate rand; // no error, the use marks it as used\n                    // even if imported objects aren't used"}, {"sha": "d49f136f11f31c4e046a2b735aaefed40fb3fb9e", "filename": "src/test/compile-fail/resolve_self_super_hint.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Fcompile-fail%2Fresolve_self_super_hint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Fcompile-fail%2Fresolve_self_super_hint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve_self_super_hint.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,25 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(collections)]\n+#![feature(alloc)]\n \n mod a {\n-    extern crate collections;\n-    use collections::HashMap;\n-    //~^ ERROR unresolved import `collections::HashMap` [E0432]\n-    //~| Did you mean `self::collections`?\n+    extern crate alloc;\n+    use alloc::HashMap;\n+    //~^ ERROR unresolved import `alloc::HashMap` [E0432]\n+    //~| Did you mean `self::alloc`?\n     mod b {\n-        use collections::HashMap;\n-        //~^ ERROR unresolved import `collections::HashMap` [E0432]\n-        //~| Did you mean `a::collections`?\n+        use alloc::HashMap;\n+        //~^ ERROR unresolved import `alloc::HashMap` [E0432]\n+        //~| Did you mean `a::alloc`?\n         mod c {\n-            use collections::HashMap;\n-            //~^ ERROR unresolved import `collections::HashMap` [E0432]\n-            //~| Did you mean `a::collections`?\n+            use alloc::HashMap;\n+            //~^ ERROR unresolved import `alloc::HashMap` [E0432]\n+            //~| Did you mean `a::alloc`?\n             mod d {\n-                use collections::HashMap;\n-                //~^ ERROR unresolved import `collections::HashMap` [E0432]\n-                //~| Did you mean `a::collections`?\n+                use alloc::HashMap;\n+                //~^ ERROR unresolved import `alloc::HashMap` [E0432]\n+                //~| Did you mean `a::alloc`?\n             }\n         }\n     }"}, {"sha": "f999d2d0ed99c8899a3cbe00ba8db91a05bb766d", "filename": "src/test/run-pass-fulldeps/issue-2804.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass-fulldeps%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass-fulldeps%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-2804.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(collections)]\n #![feature(rustc_private)]\n \n-extern crate collections;\n extern crate serialize;\n \n use std::collections::HashMap;"}, {"sha": "670f5380d81fa4666ef45ff4f6c626f8f25af368", "filename": "src/test/run-pass-fulldeps/regions-mock-tcx.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass-fulldeps%2Fregions-mock-tcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass-fulldeps%2Fregions-mock-tcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fregions-mock-tcx.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -15,10 +15,9 @@\n // - Multiple lifetime parameters\n // - Arenas\n \n-#![feature(rustc_private, libc, collections)]\n+#![feature(rustc_private, libc)]\n \n extern crate arena;\n-extern crate collections;\n extern crate libc;\n \n use TypeStructure::{TypeInt, TypeFunction};"}, {"sha": "1f486c1834c0675eebc7db3e7246de88f8c96e50", "filename": "src/test/run-pass/drop-with-type-ascription-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-2.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n \n-#![feature(collections)]\n-\n fn main() {\n     let args = vec![\"foobie\", \"asdf::asdf\"];\n     let arr: Vec<&str> = args[1].split(\"::\").collect();"}, {"sha": "856857156c9403b2fe2e444146536d15b39c2292", "filename": "src/test/run-pass/for-loop-no-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Ffor-loop-no-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Ffor-loop-no-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-loop-no-std.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(lang_items, start, collections)]\n+#![feature(lang_items, start, alloc)]\n #![no_std]\n \n extern crate std as other;\n \n-#[macro_use] extern crate collections;\n+#[macro_use] extern crate alloc;\n \n #[start]\n fn start(_argc: isize, _argv: *const *const u8) -> isize {"}, {"sha": "232af7eca419b3479d48df76697f6315f1601fce", "filename": "src/test/run-pass/foreach-external-iterators-hashmap-break-restart.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap-break-restart.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap-break-restart.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap-break-restart.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -9,10 +9,6 @@\n // except according to those terms.\n \n \n-#![feature(collections)]\n-\n-extern crate collections;\n-\n use std::collections::HashMap;\n \n // This is a fancy one: it uses an external iterator established"}, {"sha": "2ef420187ded24261a83f45d54e89a5792067381", "filename": "src/test/run-pass/foreach-external-iterators-hashmap.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -9,10 +9,6 @@\n // except according to those terms.\n \n \n-#![feature(collections)]\n-\n-extern crate collections;\n-\n use std::collections::HashMap;\n \n pub fn main() {"}, {"sha": "9e8a32185188a222ccc7f5965921da5e3d278c93", "filename": "src/test/run-pass/format-no-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fformat-no-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fformat-no-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fformat-no-std.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -10,14 +10,14 @@\n \n // ignore-emscripten missing rust_begin_unwind\n \n-#![feature(lang_items, start, collections)]\n+#![feature(lang_items, start, alloc)]\n #![no_std]\n \n extern crate std as other;\n \n-#[macro_use] extern crate collections;\n+#[macro_use] extern crate alloc;\n \n-use collections::string::ToString;\n+use alloc::string::ToString;\n \n #[start]\n fn start(_argc: isize, _argv: *const *const u8) -> isize {"}, {"sha": "58ce390cac6915dc728b01819d8255428779f506", "filename": "src/test/run-pass/issue-12860.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12860.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(collections)]\n-\n-extern crate collections;\n-\n use std::collections::HashSet;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]"}, {"sha": "b06285b06a5e4f5a01f8691c3e5624e317dc9b7f", "filename": "src/test/run-pass/issue-1696.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-1696.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-1696.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1696.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(collections)]\n-\n-extern crate collections;\n-\n use std::collections::HashMap;\n \n pub fn main() {"}, {"sha": "b447ffd69b4c97b395c5c5846aa16cc22c0f47fd", "filename": "src/test/run-pass/issue-19811-escape-unicode.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-19811-escape-unicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-19811-escape-unicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19811-escape-unicode.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n \n-#![feature(collections)]\n-\n fn main() {\n     let mut escaped = String::from(\"\");\n     for c in '\\u{10401}'.escape_unicode() {"}, {"sha": "a497a9fda6a6a18dd29f704a5f635e68de72e76c", "filename": "src/test/run-pass/issue-2383.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2383.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -10,9 +10,6 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(collections)]\n-\n-extern crate collections;\n use std::collections::VecDeque;\n \n pub fn main() {"}, {"sha": "e428ecd4e5bb3386fa55b5d35a4626c0b8b66a23", "filename": "src/test/run-pass/issue-2804-2.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -11,10 +11,6 @@\n // Minimized version of issue-2804.rs. Both check that callee IDs don't\n // clobber the previous node ID in a macro expr\n \n-#![feature(collections)]\n-\n-extern crate collections;\n-\n use std::collections::HashMap;\n \n fn add_interfaces(managed_ip: String, device: HashMap<String, isize>)  {"}, {"sha": "7c0dc8a00489084502f3a0c373217d9041080888", "filename": "src/test/run-pass/issue-3026.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3026.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -10,10 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![allow(unknown_features)]\n-#![feature(box_syntax, collections)]\n-\n-extern crate collections;\n+#![feature(box_syntax)]\n \n use std::collections::HashMap;\n "}, {"sha": "64f053d9a8c6d851ea50c89aa91b0100c24bab93", "filename": "src/test/run-pass/issue-3559.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3559.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(collections)]\n-\n-extern crate collections;\n-\n use std::collections::HashMap;\n \n fn check_strs(actual: &str, expected: &str) -> bool {"}, {"sha": "8725b13789657c66e915a1378adf86dcabc12b24", "filename": "src/test/run-pass/issue-6128.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-6128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-6128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6128.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -9,10 +9,7 @@\n // except according to those terms.\n \n \n-#![allow(unknown_features)]\n-#![feature(box_syntax, collections)]\n-\n-extern crate collections;\n+#![feature(box_syntax)]\n \n use std::collections::HashMap;\n "}, {"sha": "3f3e11a2ddb029da4282125d0ce6cbc41ee7a776", "filename": "src/test/run-pass/issue-7660.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-7660.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fissue-7660.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7660.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -13,10 +13,6 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(collections)]\n-\n-extern crate collections;\n-\n use std::collections::HashMap;\n \n struct A(isize, isize);"}, {"sha": "7ebeb79f5666971932b2b19cff08cc6d0983995a", "filename": "src/test/run-pass/istr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fistr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fistr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fistr.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(collections)]\n-\n use std::string::String;\n \n fn test_stack_assign() {"}, {"sha": "2c0417576052e00ad716a2b8671db00cef89d6df", "filename": "src/test/run-pass/new-unicode-escapes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fnew-unicode-escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fnew-unicode-escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-unicode-escapes.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n \n-#![feature(collections)]\n-\n pub fn main() {\n     let s = \"\\u{2603}\";\n     assert_eq!(s, \"\u2603\");"}, {"sha": "c054171ff008ac0e35e4bcb8e4543919288c3312", "filename": "src/test/run-pass/option-ext.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Foption-ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Foption-ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foption-ext.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(collections)]\n-\n pub fn main() {\n     let thing = \"{{ f }}\";\n     let f = thing.find(\"{{\");"}, {"sha": "d9ffbe51aa59631a97934bb768366ca28e92c50b", "filename": "src/test/run-pass/overloaded-autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![allow(unknown_features)]\n-#![feature(box_syntax, collections, core)]\n+#![feature(box_syntax, core)]\n \n use std::cell::RefCell;\n use std::rc::Rc;"}, {"sha": "9cdf45b485c1ba7f6a7d7c53c02c3dc37f2a064b", "filename": "src/test/run-pass/overloaded-deref.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(collections)]\n-\n use std::cell::RefCell;\n use std::rc::Rc;\n use std::string::String;"}, {"sha": "903532e9bc80ac325af1e4f4b34b07783da83468", "filename": "src/test/run-pass/sync-send-iterators-in-libcollections.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -9,21 +9,16 @@\n // except according to those terms.\n \n #![allow(warnings)]\n-#![feature(collections)]\n #![feature(drain, collections_bound, btree_range, vecmap)]\n \n-extern crate collections;\n-\n-use collections::BinaryHeap;\n-use collections::{BTreeMap, BTreeSet};\n-use collections::LinkedList;\n-use collections::String;\n-use collections::Vec;\n-use collections::VecDeque;\n+use std::collections::BinaryHeap;\n+use std::collections::{BTreeMap, BTreeSet};\n+use std::collections::LinkedList;\n+use std::collections::VecDeque;\n use std::collections::HashMap;\n use std::collections::HashSet;\n \n-use collections::Bound::Included;\n+use std::collections::Bound::Included;\n use std::mem;\n \n fn is_sync<T>(_: T) where T: Sync {}"}, {"sha": "b54aed79665aaa210184383c6eb946726bbaf8a3", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n //\n \n-#![feature(collections, core, str_char)]\n+#![feature(core, str_char)]\n \n use std::str;\n "}, {"sha": "5dd551ff513799f218b542202065cdee1defea19", "filename": "src/test/run-pass/vec-macro-no-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fvec-macro-no-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fvec-macro-no-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-macro-no-std.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,17 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(lang_items, start, libc, collections)]\n+#![feature(lang_items, start, libc, alloc)]\n #![no_std]\n \n extern crate std as other;\n \n extern crate libc;\n \n #[macro_use]\n-extern crate collections;\n+extern crate alloc;\n \n-use collections::vec::Vec;\n+use alloc::vec::Vec;\n \n // Issue #16806\n "}, {"sha": "39ed4f53cf7e4a0492984a9b9223459c5a64f8cf", "filename": "src/test/run-pass/while-prelude-drop.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(collections)]\n-\n use std::string::String;\n \n #[derive(PartialEq)]"}, {"sha": "3ea2e6313af4cac383eda19c5162d56214bb2bb6", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/258ae6dd9b1a8ac97986852fc9f00f7687004ccb/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "patch": "@@ -118,15 +118,15 @@ fn check(cache: &mut Cache,\n         return None;\n     }\n     // FIXME(#32553)\n-    if file.ends_with(\"collections/string/struct.String.html\") {\n+    if file.ends_with(\"string/struct.String.html\") {\n         return None;\n     }\n     // FIXME(#32130)\n     if file.ends_with(\"btree_set/struct.BTreeSet.html\") ||\n-       file.ends_with(\"collections/struct.BTreeSet.html\") ||\n-       file.ends_with(\"collections/btree_map/struct.BTreeMap.html\") ||\n-       file.ends_with(\"collections/hash_map/struct.HashMap.html\") ||\n-       file.ends_with(\"collections/hash_set/struct.HashSet.html\") {\n+       file.ends_with(\"struct.BTreeSet.html\") ||\n+       file.ends_with(\"btree_map/struct.BTreeMap.html\") ||\n+       file.ends_with(\"hash_map/struct.HashMap.html\") ||\n+       file.ends_with(\"hash_set/struct.HashSet.html\") {\n         return None;\n     }\n "}]}