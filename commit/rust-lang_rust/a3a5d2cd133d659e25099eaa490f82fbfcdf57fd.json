{"sha": "a3a5d2cd133d659e25099eaa490f82fbfcdf57fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzYTVkMmNkMTMzZDY1OWUyNTA5OWVhYTQ5MGY4MmZiZmNkZjU3ZmQ=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-11-23T02:20:08Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-11-24T14:54:53Z"}, "message": "Get rid of doctree::Function", "tree": {"sha": "4dc1753ef550eac947a72af4779f0ef3fa97681f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dc1753ef550eac947a72af4779f0ef3fa97681f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3a5d2cd133d659e25099eaa490f82fbfcdf57fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3a5d2cd133d659e25099eaa490f82fbfcdf57fd", "html_url": "https://github.com/rust-lang/rust/commit/a3a5d2cd133d659e25099eaa490f82fbfcdf57fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3a5d2cd133d659e25099eaa490f82fbfcdf57fd/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35e7beed0e5a01816f1f447dc7d2200e97137af1", "url": "https://api.github.com/repos/rust-lang/rust/commits/35e7beed0e5a01816f1f447dc7d2200e97137af1", "html_url": "https://github.com/rust-lang/rust/commit/35e7beed0e5a01816f1f447dc7d2200e97137af1"}], "stats": {"total": 208, "additions": 75, "deletions": 133}, "files": [{"sha": "752918250d802f78f8fb58bb269986d24fa7fde3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 65, "deletions": 42, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/a3a5d2cd133d659e25099eaa490f82fbfcdf57fd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a5d2cd133d659e25099eaa490f82fbfcdf57fd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a3a5d2cd133d659e25099eaa490f82fbfcdf57fd", "patch": "@@ -231,13 +231,11 @@ impl Clean<Item> for doctree::Module<'_> {\n         let mut items: Vec<Item> = vec![];\n         items.extend(self.extern_crates.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.imports.iter().flat_map(|x| x.clean(cx)));\n-        items.extend(self.fns.iter().map(|x| x.clean(cx)));\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n         items.extend(self.items.iter().map(|x| x.clean(cx)).flatten());\n         items.extend(self.traits.iter().map(|x| x.clean(cx)));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n-        items.extend(self.proc_macros.iter().map(|x| x.clean(cx)));\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n@@ -871,6 +869,66 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n     }\n }\n \n+fn clean_fn_or_proc_macro(\n+    item: &hir::Item<'_>,\n+    sig: &'a hir::FnSig<'a>,\n+    generics: &'a hir::Generics<'a>,\n+    body_id: hir::BodyId,\n+    name: &mut Symbol,\n+    cx: &DocContext<'_>,\n+) -> ItemKind {\n+    let macro_kind = item.attrs.iter().find_map(|a| {\n+        if a.has_name(sym::proc_macro) {\n+            Some(MacroKind::Bang)\n+        } else if a.has_name(sym::proc_macro_derive) {\n+            Some(MacroKind::Derive)\n+        } else if a.has_name(sym::proc_macro_attribute) {\n+            Some(MacroKind::Attr)\n+        } else {\n+            None\n+        }\n+    });\n+    match macro_kind {\n+        Some(kind) => {\n+            if kind == MacroKind::Derive {\n+                *name = item\n+                    .attrs\n+                    .lists(sym::proc_macro_derive)\n+                    .find_map(|mi| mi.ident())\n+                    .expect(\"proc-macro derives require a name\")\n+                    .name;\n+            }\n+\n+            let mut helpers = Vec::new();\n+            for mi in item.attrs.lists(sym::proc_macro_derive) {\n+                if !mi.has_name(sym::attributes) {\n+                    continue;\n+                }\n+\n+                if let Some(list) = mi.meta_item_list() {\n+                    for inner_mi in list {\n+                        if let Some(ident) = inner_mi.ident() {\n+                            helpers.push(ident.name);\n+                        }\n+                    }\n+                }\n+            }\n+            ProcMacroItem(ProcMacro { kind, helpers: helpers.clean(cx) })\n+        }\n+        None => {\n+            let mut func = (sig, generics, body_id).clean(cx);\n+            let def_id = cx.tcx.hir().local_def_id(item.hir_id).to_def_id();\n+            func.header.constness =\n+                if is_const_fn(cx.tcx, def_id) && is_unstable_const_fn(cx.tcx, def_id).is_none() {\n+                    hir::Constness::Const\n+                } else {\n+                    hir::Constness::NotConst\n+                };\n+            FunctionItem(func)\n+        }\n+    }\n+}\n+\n impl<'a> Clean<Function> for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::BodyId) {\n     fn clean(&self, cx: &DocContext<'_>) -> Function {\n         let (generics, decl) =\n@@ -880,34 +938,6 @@ impl<'a> Clean<Function> for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::Bo\n     }\n }\n \n-impl Clean<Item> for doctree::Function<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let (generics, decl) =\n-            enter_impl_trait(cx, || (self.generics.clean(cx), (self.decl, self.body).clean(cx)));\n-\n-        let did = cx.tcx.hir().local_def_id(self.id).to_def_id();\n-        let constness = if is_const_fn(cx.tcx, did) && !is_unstable_const_fn(cx.tcx, did).is_some()\n-        {\n-            hir::Constness::Const\n-        } else {\n-            hir::Constness::NotConst\n-        };\n-        let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n-        Item::from_def_id_and_parts(\n-            did,\n-            Some(self.name),\n-            FunctionItem(Function {\n-                decl,\n-                generics,\n-                header: hir::FnHeader { constness, ..self.header },\n-                all_types,\n-                ret_types,\n-            }),\n-            cx,\n-        )\n-    }\n-}\n-\n impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], &'a [Ident]) {\n     fn clean(&self, cx: &DocContext<'_>) -> Arguments {\n         Arguments {\n@@ -1927,7 +1957,7 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Ident>) {\n \n         let (item, renamed) = self;\n         let def_id = cx.tcx.hir().local_def_id(item.hir_id).to_def_id();\n-        let name = match renamed {\n+        let mut name = match renamed {\n             Some(ident) => ident.name,\n             None => cx.tcx.hir().name(item.hir_id),\n         };\n@@ -1977,6 +2007,10 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Ident>) {\n                 fields_stripped: false,\n             }),\n             ItemKind::Impl { .. } => return clean_impl(item, cx),\n+            // proc macros can have a name set by attributes\n+            ItemKind::Fn(ref sig, ref generics, body_id) => {\n+                clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n+            }\n             _ => unreachable!(\"not yet converted\"),\n         };\n \n@@ -2239,17 +2273,6 @@ impl Clean<Item> for doctree::Macro {\n     }\n }\n \n-impl Clean<Item> for doctree::ProcMacro {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            ProcMacroItem(ProcMacro { kind: self.kind, helpers: self.helpers.clean(cx) }),\n-            cx,\n-        )\n-    }\n-}\n-\n impl Clean<Deprecation> for attr::Deprecation {\n     fn clean(&self, _: &DocContext<'_>) -> Deprecation {\n         Deprecation {"}, {"sha": "c6c11164e7df181d513eea5b22916a4f6eadadff", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a3a5d2cd133d659e25099eaa490f82fbfcdf57fd/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a5d2cd133d659e25099eaa490f82fbfcdf57fd/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=a3a5d2cd133d659e25099eaa490f82fbfcdf57fd", "patch": "@@ -3,7 +3,6 @@\n crate use self::StructType::*;\n \n use rustc_ast as ast;\n-use rustc_span::hygiene::MacroKind;\n use rustc_span::{self, symbol::Ident, Span, Symbol};\n \n use rustc_hir as hir;\n@@ -17,15 +16,13 @@ crate struct Module<'hir> {\n     crate where_inner: Span,\n     crate extern_crates: Vec<ExternCrate<'hir>>,\n     crate imports: Vec<Import<'hir>>,\n-    crate fns: Vec<Function<'hir>>,\n     crate mods: Vec<Module<'hir>>,\n     crate id: hir::HirId,\n     // (item, renamed)\n     crate items: Vec<(&'hir hir::Item<'hir>, Option<Ident>)>,\n     crate traits: Vec<Trait<'hir>>,\n     crate foreigns: Vec<(&'hir hir::ForeignItem<'hir>, Option<Ident>)>,\n     crate macros: Vec<Macro>,\n-    crate proc_macros: Vec<ProcMacro>,\n     crate is_crate: bool,\n }\n \n@@ -39,13 +36,11 @@ impl Module<'hir> {\n             attrs,\n             extern_crates: Vec::new(),\n             imports: Vec::new(),\n-            fns: Vec::new(),\n             mods: Vec::new(),\n             items: Vec::new(),\n             traits: Vec::new(),\n             foreigns: Vec::new(),\n             macros: Vec::new(),\n-            proc_macros: Vec::new(),\n             is_crate: false,\n         }\n     }\n@@ -67,15 +62,6 @@ crate struct Variant<'hir> {\n     crate def: &'hir hir::VariantData<'hir>,\n }\n \n-crate struct Function<'hir> {\n-    crate decl: &'hir hir::FnDecl<'hir>,\n-    crate id: hir::HirId,\n-    crate name: Symbol,\n-    crate header: hir::FnHeader,\n-    crate generics: &'hir hir::Generics<'hir>,\n-    crate body: hir::BodyId,\n-}\n-\n crate struct Trait<'hir> {\n     crate is_auto: hir::IsAuto,\n     crate unsafety: hir::Unsafety,\n@@ -117,13 +103,6 @@ crate struct Import<'hir> {\n     crate span: Span,\n }\n \n-crate struct ProcMacro {\n-    crate name: Symbol,\n-    crate id: hir::HirId,\n-    crate kind: MacroKind,\n-    crate helpers: Vec<Symbol>,\n-}\n-\n crate fn struct_type_from_def(vdata: &hir::VariantData<'_>) -> StructType {\n     match *vdata {\n         hir::VariantData::Struct(..) => Plain,"}, {"sha": "624d4d07cc0316039d485a3f02de9fb4468a6f2e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 62, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a3a5d2cd133d659e25099eaa490f82fbfcdf57fd/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a5d2cd133d659e25099eaa490f82fbfcdf57fd/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=a3a5d2cd133d659e25099eaa490f82fbfcdf57fd", "patch": "@@ -9,7 +9,6 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::Node;\n use rustc_middle::middle::privacy::AccessLevel;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{self, Span};\n@@ -82,63 +81,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         module\n     }\n \n-    fn visit_fn(\n-        &mut self,\n-        om: &mut Module<'tcx>,\n-        item: &'tcx hir::Item<'_>,\n-        name: Symbol,\n-        decl: &'tcx hir::FnDecl<'_>,\n-        header: hir::FnHeader,\n-        generics: &'tcx hir::Generics<'_>,\n-        body: hir::BodyId,\n-    ) {\n-        debug!(\"visiting fn\");\n-        let macro_kind = item.attrs.iter().find_map(|a| {\n-            if a.has_name(sym::proc_macro) {\n-                Some(MacroKind::Bang)\n-            } else if a.has_name(sym::proc_macro_derive) {\n-                Some(MacroKind::Derive)\n-            } else if a.has_name(sym::proc_macro_attribute) {\n-                Some(MacroKind::Attr)\n-            } else {\n-                None\n-            }\n-        });\n-        match macro_kind {\n-            Some(kind) => {\n-                let name = if kind == MacroKind::Derive {\n-                    item.attrs\n-                        .lists(sym::proc_macro_derive)\n-                        .find_map(|mi| mi.ident())\n-                        .expect(\"proc-macro derives require a name\")\n-                        .name\n-                } else {\n-                    name\n-                };\n-\n-                let mut helpers = Vec::new();\n-                for mi in item.attrs.lists(sym::proc_macro_derive) {\n-                    if !mi.has_name(sym::attributes) {\n-                        continue;\n-                    }\n-\n-                    if let Some(list) = mi.meta_item_list() {\n-                        for inner_mi in list {\n-                            if let Some(ident) = inner_mi.ident() {\n-                                helpers.push(ident.name);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                om.proc_macros.push(ProcMacro { name, id: item.hir_id, kind, helpers });\n-            }\n-            None => {\n-                om.fns.push(Function { id: item.hir_id, decl, name, generics, header, body });\n-            }\n-        }\n-    }\n-\n     fn visit_mod_contents(\n         &mut self,\n         span: Span,\n@@ -370,10 +312,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     Some(ident.name),\n                 ));\n             }\n-            hir::ItemKind::Fn(ref sig, ref gen, body) => {\n-                self.visit_fn(om, item, ident.name, &sig.decl, sig.header, gen, body)\n-            }\n-            hir::ItemKind::Enum(..)\n+            hir::ItemKind::Fn(..)\n+            | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Union(..)\n             | hir::ItemKind::TyAlias(..)"}, {"sha": "0b074e9d53e3d640313aa06e10fc00becfc39df6", "filename": "src/test/rustdoc-ui/intra-links-warning.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a5d2cd133d659e25099eaa490f82fbfcdf57fd/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a5d2cd133d659e25099eaa490f82fbfcdf57fd/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr?ref=a3a5d2cd133d659e25099eaa490f82fbfcdf57fd", "patch": "@@ -36,6 +36,14 @@ warning: unresolved link to `Qux::Z`\n LL |       //! , [Uniooon::X] and [Qux::Z].\n    |                               ^^^^^^ no item named `Qux` in scope\n \n+warning: unresolved link to `Qux:Y`\n+  --> $DIR/intra-links-warning.rs:14:13\n+   |\n+LL |        /// [Qux:Y]\n+   |             ^^^^^ no item named `Qux:Y` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n warning: unresolved link to `BarA`\n   --> $DIR/intra-links-warning.rs:21:10\n    |\n@@ -90,14 +98,6 @@ LL | f!(\"Foo\\nbar [BarF] bar\\nbaz\");\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-warning: unresolved link to `Qux:Y`\n-  --> $DIR/intra-links-warning.rs:14:13\n-   |\n-LL |        /// [Qux:Y]\n-   |             ^^^^^ no item named `Qux:Y` in scope\n-   |\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n-\n warning: unresolved link to `error`\n   --> $DIR/intra-links-warning.rs:58:30\n    |"}]}