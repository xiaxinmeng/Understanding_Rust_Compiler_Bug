{"sha": "ef26f1756c88fe75bc869a0c5f78496aa445b914", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMjZmMTc1NmM4OGZlNzViYzg2OWEwYzVmNzg0OTZhYTQ0NWI5MTQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-07-01T13:41:49Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-07-11T08:30:23Z"}, "message": "Clean up some code", "tree": {"sha": "ef86f5a978bc829507b8a923a1230ab1496c26e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef86f5a978bc829507b8a923a1230ab1496c26e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef26f1756c88fe75bc869a0c5f78496aa445b914", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef26f1756c88fe75bc869a0c5f78496aa445b914", "html_url": "https://github.com/rust-lang/rust/commit/ef26f1756c88fe75bc869a0c5f78496aa445b914", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef26f1756c88fe75bc869a0c5f78496aa445b914/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72", "url": "https://api.github.com/repos/rust-lang/rust/commits/1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72", "html_url": "https://github.com/rust-lang/rust/commit/1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72"}], "stats": {"total": 96, "additions": 41, "deletions": 55}, "files": [{"sha": "cc4d0f7e4c75473e1edfb59ea4f60a41472c1beb", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ef26f1756c88fe75bc869a0c5f78496aa445b914/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef26f1756c88fe75bc869a0c5f78496aa445b914/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=ef26f1756c88fe75bc869a0c5f78496aa445b914", "patch": "@@ -1947,35 +1947,34 @@ Either way, try to update/remove it in order to fix the error.\n \"##,\n \n E0621: r##\"\n-This error code indicates a mismatch between the function signature (i.e.,\n-the parameter types and the return type) and the function body. Most of\n-the time, this indicates that the function signature needs to be changed to\n-match the body, but it may be that the body needs to be changed to match\n-the signature.\n+This error code indicates a mismatch between the lifetimes appearing in the\n+function signature (i.e., the parameter types and the return type) and the\n+data-flow found in the function body.\n \n-Specifically, one or more of the parameters contain borrowed data that\n-needs to have a named lifetime in order for the body to type-check. Most of\n-the time, this is because the borrowed data is being returned from the\n-function, as in this example:\n+Erroneous code example:\n \n ```compile_fail,E0621\n-fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 { // explicit lifetime required\n-                                             // in the type of `y`\n+fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 { // error: explicit lifetime\n+                                             //        required in the type of\n+                                             //        `y`\n     if x > y { x } else { y }\n }\n ```\n \n-Here, the function is returning data borrowed from either x or y, but the\n-'a annotation indicates that it is returning data only from x. We can make\n-the signature match the body by changing the type of y to &'a i32, like so:\n+In the code above, the function is returning data borrowed from either `x` or\n+`y`, but the `'a` annotation indicates that it is returning data only from `x`.\n+To fix the error, the signature and the body must be made to match. Typically,\n+this is done by updating the function signature. So, in this case, we change\n+the type of `y` to `&'a i32`, like so:\n \n ```\n fn foo<'a>(x: &'a i32, y: &'a i32) -> &'a i32 {\n     if x > y { x } else { y }\n }\n ```\n \n-Alternatively, you could change the body not to return data from y:\n+Now the signature indicates that the function data borrowed from either `x` or\n+`y`. Alternatively, you could change the body not to return data from y:\n \n ```\n fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {"}, {"sha": "278ec03c753080d527b0e1cc4bd41de3bde85fba", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ef26f1756c88fe75bc869a0c5f78496aa445b914/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef26f1756c88fe75bc869a0c5f78496aa445b914/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ef26f1756c88fe75bc869a0c5f78496aa445b914", "patch": "@@ -72,12 +72,12 @@ use ty::error::TypeError;\n use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n use errors::{DiagnosticBuilder, DiagnosticStyledString};\n+\n mod note;\n \n mod need_type_info;\n mod named_anon_conflict;\n \n-\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n                                    err: &mut DiagnosticBuilder,\n@@ -265,40 +265,34 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // together into a `ProcessedErrors` group:\n         let errors = self.process_errors(errors);\n \n-        debug!(\"report_region_errors: {} errors after preprocessing\",\n-               errors.len());\n+        debug!(\"report_region_errors: {} errors after preprocessing\", errors.len());\n \n         for error in errors {\n-\n             debug!(\"report_region_errors: error = {:?}\", error);\n \n-            if !self.try_report_named_anon_conflict(&error){\n-\n-               match error.clone() {\n-                  // These errors could indicate all manner of different\n-                  // problems with many different solutions. Rather\n-                  // than generate a \"one size fits all\" error, what we\n-                  // attempt to do is go through a number of specific\n-                  // scenarios and try to find the best way to present\n-                  // the error. If all of these fails, we fall back to a rather\n-                  // general bit of code that displays the error information\n-                  ConcreteFailure(origin, sub, sup) => {\n-\n-                      self.report_concrete_failure(origin, sub, sup).emit();\n-                  }\n-\n-                  GenericBoundFailure(kind, param_ty, sub) => {\n-                      self.report_generic_bound_failure(kind, param_ty, sub);\n-                  }\n-\n-                  SubSupConflict(var_origin,\n-                               sub_origin, sub_r,\n-                               sup_origin, sup_r) => {\n-                      self.report_sub_sup_conflict(var_origin,\n-                                                 sub_origin, sub_r,\n-                                                 sup_origin, sup_r);\n-                  }\n-               }\n+            if !self.try_report_named_anon_conflict(&error) {\n+                match error.clone() {\n+                    // These errors could indicate all manner of different\n+                    // problems with many different solutions. Rather\n+                    // than generate a \"one size fits all\" error, what we\n+                    // attempt to do is go through a number of specific\n+                    // scenarios and try to find the best way to present\n+                    // the error. If all of these fails, we fall back to a rather\n+                    // general bit of code that displays the error information\n+                    ConcreteFailure(origin, sub, sup) => {\n+                        self.report_concrete_failure(origin, sub, sup).emit();\n+                    }\n+                    GenericBoundFailure(kind, param_ty, sub) => {\n+                        self.report_generic_bound_failure(kind, param_ty, sub);\n+                    }\n+                    SubSupConflict(var_origin,\n+                                 sub_origin, sub_r,\n+                                 sup_origin, sup_r) => {\n+                        self.report_sub_sup_conflict(var_origin,\n+                                                     sub_origin, sub_r,\n+                                                     sup_origin, sup_r);\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "48f39ac5b3e56c7f505658123357e25e18f5484c", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef26f1756c88fe75bc869a0c5f78496aa445b914/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef26f1756c88fe75bc869a0c5f78496aa445b914/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=ef26f1756c88fe75bc869a0c5f78496aa445b914", "patch": "@@ -37,7 +37,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         match *anon_region {\n             ty::ReFree(ref free_region) => {\n-\n                 let id = free_region.scope;\n                 let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n                 let body_id = self.tcx.hir.maybe_body_owned_by(node_id).unwrap();\n@@ -69,15 +68,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             _ => None,\n-\n         }\n     }\n \n     // This method generates the error message for the case when\n     // the function arguments consist of a named region and an anonymous\n     // region and corresponds to `ConcreteFailure(..)`\n     pub fn try_report_named_anon_conflict(&self, error: &RegionResolutionError<'tcx>) -> bool {\n-\n         let (span, sub, sup) = match *error {\n             ConcreteFailure(ref origin, sub, sup) => (origin.span(), sub, sup),\n             _ => return false, // inapplicable\n@@ -113,7 +110,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     .collect_referenced_late_bound_regions(&sig.output());\n                 if late_bound_regions.iter().any(|r| *r == br) {\n                     return false;\n-                } else {\n                 }\n             }\n             _ => {}\n@@ -134,10 +130,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n             (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n         } else {\n-            (format!(\"parameter type\"), format!(\"type\"))\n+            (\"parameter type\".to_owned(), \"type\".to_owned())\n         };\n \n-\n         struct_span_err!(self.tcx.sess,\n                          span,\n                          E0621,\n@@ -149,13 +144,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 .emit();\n \n         return true;\n-\n     }\n \n     // This method returns whether the given Region is Anonymous\n     // and returns the DefId corresponding to the region.\n     pub fn is_suitable_anonymous_region(&self, region: Region<'tcx>) -> Option<DefId> {\n-\n         match *region {\n             ty::ReFree(ref free_region) => {\n                 match free_region.bound_region {"}, {"sha": "228481e853021f86b87ee3dc7960a7afb58007c9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef26f1756c88fe75bc869a0c5f78496aa445b914/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef26f1756c88fe75bc869a0c5f78496aa445b914/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=ef26f1756c88fe75bc869a0c5f78496aa445b914", "patch": "@@ -38,6 +38,7 @@ use errors::DiagnosticBuilder;\n use syntax_pos::{self, Span, DUMMY_SP};\n use util::nodemap::FxHashMap;\n use arena::DroplessArena;\n+\n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};"}, {"sha": "ee6c7576aa276dd168f1813a50c80b52bdb17889", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef26f1756c88fe75bc869a0c5f78496aa445b914/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef26f1756c88fe75bc869a0c5f78496aa445b914/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ef26f1756c88fe75bc869a0c5f78496aa445b914", "patch": "@@ -993,7 +993,6 @@ impl RegionKind {\n \n     // This method returns whether the given Region is Named\n     pub fn is_named_region(&self) -> bool {\n-\n         match *self {\n             ty::ReFree(ref free_region) => {\n                 match free_region.bound_region {"}]}