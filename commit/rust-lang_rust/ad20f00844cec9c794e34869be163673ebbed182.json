{"sha": "ad20f00844cec9c794e34869be163673ebbed182", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMjBmMDA4NDRjZWM5Yzc5NGUzNDg2OWJlMTYzNjczZWJiZWQxODI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-05T15:45:18Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-05T17:19:18Z"}, "message": "Use VariableKinds in Binders", "tree": {"sha": "0f37d26295bc9a8372d09df1612bd08a6d19ff72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f37d26295bc9a8372d09df1612bd08a6d19ff72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad20f00844cec9c794e34869be163673ebbed182", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad20f00844cec9c794e34869be163673ebbed182", "html_url": "https://github.com/rust-lang/rust/commit/ad20f00844cec9c794e34869be163673ebbed182", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad20f00844cec9c794e34869be163673ebbed182/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69714d36e6617800f3edea174f5d6f76c985ad4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/69714d36e6617800f3edea174f5d6f76c985ad4c", "html_url": "https://github.com/rust-lang/rust/commit/69714d36e6617800f3edea174f5d6f76c985ad4c"}], "stats": {"total": 191, "additions": 107, "deletions": 84}, "files": [{"sha": "7b8603fd77e1475cd8cbd7b9004a8b897f0b37bf", "filename": "crates/hir_ty/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad20f00844cec9c794e34869be163673ebbed182/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad20f00844cec9c794e34869be163673ebbed182/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs?ref=ad20f00844cec9c794e34869be163673ebbed182", "patch": "@@ -194,7 +194,7 @@ impl TyBuilder<TypeAliasId> {\n \n impl<T: TypeWalk + HasInterner<Interner = Interner>> TyBuilder<Binders<T>> {\n     fn subst_binders(b: Binders<T>) -> Self {\n-        let param_count = b.num_binders;\n+        let param_count = b.binders.len(&Interner);\n         TyBuilder::new(b, param_count)\n     }\n "}, {"sha": "d61ef65f2580a8161bfb2d9c72aac2396a8022b0", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad20f00844cec9c794e34869be163673ebbed182/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad20f00844cec9c794e34869be163673ebbed182/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=ad20f00844cec9c794e34869be163673ebbed182", "patch": "@@ -849,7 +849,7 @@ impl<'a> InferenceContext<'a> {\n                 self.write_method_resolution(tgt_expr, func);\n                 (ty, self.db.value_ty(func.into()), Some(generics(self.db.upcast(), func.into())))\n             }\n-            None => (receiver_ty, Binders::new(0, self.err_ty()), None),\n+            None => (receiver_ty, Binders::empty(&Interner, self.err_ty()), None),\n         };\n         let substs = self.substs_for_method_call(def_generics, generic_args, &derefed_receiver_ty);\n         let method_ty = method_ty.subst(&substs);\n@@ -951,7 +951,7 @@ impl<'a> InferenceContext<'a> {\n             for predicate in generic_predicates.iter() {\n                 let (predicate, binders) =\n                     predicate.clone().subst(parameters).into_value_and_skipped_binders();\n-                always!(binders == 0); // quantified where clauses not yet handled\n+                always!(binders.len(&Interner) == 0); // quantified where clauses not yet handled\n                 self.push_obligation(predicate.cast(&Interner));\n             }\n             // add obligation for trait implementation, if this is a trait method"}, {"sha": "86973c7ed1143aaca4212e3b5c283a38901ff638", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad20f00844cec9c794e34869be163673ebbed182/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad20f00844cec9c794e34869be163673ebbed182/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=ad20f00844cec9c794e34869be163673ebbed182", "patch": "@@ -66,6 +66,8 @@ pub type ClosureId = chalk_ir::ClosureId<Interner>;\n pub type OpaqueTyId = chalk_ir::OpaqueTyId<Interner>;\n pub type PlaceholderIndex = chalk_ir::PlaceholderIndex;\n \n+pub type VariableKind = chalk_ir::VariableKind<Interner>;\n+pub type VariableKinds = chalk_ir::VariableKinds<Interner>;\n pub type CanonicalVarKinds = chalk_ir::CanonicalVarKinds<Interner>;\n \n pub type ChalkTraitId = chalk_ir::TraitId<Interner>;\n@@ -126,22 +128,26 @@ impl<T> Binders<T> {\n     }\n }\n \n-impl<T: Clone> Binders<&T> {\n-    pub fn cloned(&self) -> Binders<T> {\n-        let (value, binders) = self.into_value_and_skipped_binders();\n-        Binders::new(binders, value.clone())\n-    }\n-}\n-\n impl<T: TypeWalk> Binders<T> {\n     /// Substitutes all variables.\n     pub fn subst(self, subst: &Substitution) -> T {\n         let (value, binders) = self.into_value_and_skipped_binders();\n-        assert_eq!(subst.len(&Interner), binders);\n+        assert_eq!(subst.len(&Interner), binders.len(&Interner));\n         value.subst_bound_vars(subst)\n     }\n }\n \n+pub fn make_only_type_binders<T>(num_vars: usize, value: T) -> Binders<T> {\n+    Binders::new(\n+        VariableKinds::from_iter(\n+            &Interner,\n+            std::iter::repeat(chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General))\n+                .take(num_vars),\n+        ),\n+        value,\n+    )\n+}\n+\n impl TraitRef {\n     pub fn self_type_parameter(&self, interner: &Interner) -> &Ty {\n         &self.substitution.at(interner, 0).assert_ty_ref(interner)\n@@ -407,8 +413,8 @@ impl Ty {\n                             // This is only used by type walking.\n                             // Parameters will be walked outside, and projection predicate is not used.\n                             // So just provide the Future trait.\n-                            let impl_bound = Binders::new(\n-                                0,\n+                            let impl_bound = Binders::empty(\n+                                &Interner,\n                                 WhereClause::Implemented(TraitRef {\n                                     trait_id: to_chalk_trait_id(future_trait),\n                                     substitution: Substitution::empty(&Interner),"}, {"sha": "59d2a157fb5e7aa7d62ea30db5dcbb5a51694a35", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/ad20f00844cec9c794e34869be163673ebbed182/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad20f00844cec9c794e34869be163673ebbed182/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=ad20f00844cec9c794e34869be163673ebbed182", "patch": "@@ -31,7 +31,7 @@ use crate::{\n     traits::chalk::{Interner, ToChalk},\n     utils::{\n         all_super_trait_refs, associated_type_by_name_including_super_traits, generics,\n-        variant_data,\n+        variant_data, Generics,\n     },\n     AliasEq, AliasTy, Binders, BoundVar, CallableSig, DebruijnIndex, DynTy, FnPointer, FnSig,\n     ImplTraitId, OpaqueTy, PolyFnSig, ProjectionTy, QuantifiedWhereClause, QuantifiedWhereClauses,\n@@ -196,7 +196,7 @@ impl<'a> TyLoweringContext<'a> {\n                         bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false)),\n                     )\n                 });\n-                let bounds = Binders::new(1, bounds);\n+                let bounds = crate::make_only_type_binders(1, bounds);\n                 TyKind::Dyn(DynTy { bounds }).intern(&Interner)\n             }\n             TypeRef::ImplTrait(bounds) => {\n@@ -209,9 +209,9 @@ impl<'a> TyLoweringContext<'a> {\n                         // this dance is to make sure the data is in the right\n                         // place even if we encounter more opaque types while\n                         // lowering the bounds\n-                        self.opaque_type_data\n-                            .borrow_mut()\n-                            .push(ReturnTypeImplTrait { bounds: Binders::new(1, Vec::new()) });\n+                        self.opaque_type_data.borrow_mut().push(ReturnTypeImplTrait {\n+                            bounds: crate::make_only_type_binders(1, Vec::new()),\n+                        });\n                         // We don't want to lower the bounds inside the binders\n                         // we're currently in, because they don't end up inside\n                         // those binders. E.g. when we have `impl Trait<impl\n@@ -380,7 +380,7 @@ impl<'a> TyLoweringContext<'a> {\n                     TyKind::Error.intern(&Interner)\n                 } else {\n                     let dyn_ty = DynTy {\n-                        bounds: Binders::new(\n+                        bounds: crate::make_only_type_binders(\n                             1,\n                             QuantifiedWhereClauses::from_iter(\n                                 &Interner,\n@@ -787,7 +787,7 @@ impl<'a> TyLoweringContext<'a> {\n         let predicates = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n             bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false)).collect()\n         });\n-        ReturnTypeImplTrait { bounds: Binders::new(1, predicates) }\n+        ReturnTypeImplTrait { bounds: crate::make_only_type_binders(1, predicates) }\n     }\n }\n \n@@ -884,7 +884,7 @@ pub(crate) fn field_types_query(\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     for (field_id, field_data) in var_data.fields().iter() {\n-        res.insert(field_id, Binders::new(generics.len(), ctx.lower_ty(&field_data.type_ref)))\n+        res.insert(field_id, make_binders(&generics, ctx.lower_ty(&field_data.type_ref)))\n     }\n     Arc::new(res)\n }\n@@ -918,9 +918,7 @@ pub(crate) fn generic_predicates_for_param_query(\n             },\n             WherePredicate::Lifetime { .. } => false,\n         })\n-        .flat_map(|pred| {\n-            ctx.lower_where_predicate(pred, true).map(|p| Binders::new(generics.len(), p))\n-        })\n+        .flat_map(|pred| ctx.lower_where_predicate(pred, true).map(|p| make_binders(&generics, p)))\n         .collect()\n }\n \n@@ -991,9 +989,7 @@ pub(crate) fn generic_predicates_query(\n     let generics = generics(db.upcast(), def);\n     resolver\n         .where_predicates_in_scope()\n-        .flat_map(|pred| {\n-            ctx.lower_where_predicate(pred, false).map(|p| Binders::new(generics.len(), p))\n-        })\n+        .flat_map(|pred| ctx.lower_where_predicate(pred, false).map(|p| make_binders(&generics, p)))\n         .collect()\n }\n \n@@ -1030,7 +1026,7 @@ pub(crate) fn generic_defaults_query(\n                 DebruijnIndex::INNERMOST,\n             );\n \n-            Binders::new(idx, ty)\n+            crate::make_only_type_binders(idx, ty)\n         })\n         .collect();\n \n@@ -1043,23 +1039,22 @@ fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n     let ctx_params = TyLoweringContext::new(db, &resolver)\n         .with_impl_trait_mode(ImplTraitLoweringMode::Variable)\n         .with_type_param_mode(TypeParamLoweringMode::Variable);\n-    let params = data.params.iter().map(|tr| (&ctx_params).lower_ty(tr)).collect::<Vec<_>>();\n+    let params = data.params.iter().map(|tr| ctx_params.lower_ty(tr)).collect::<Vec<_>>();\n     let ctx_ret = TyLoweringContext::new(db, &resolver)\n         .with_impl_trait_mode(ImplTraitLoweringMode::Opaque)\n         .with_type_param_mode(TypeParamLoweringMode::Variable);\n-    let ret = (&ctx_ret).lower_ty(&data.ret_type);\n+    let ret = ctx_ret.lower_ty(&data.ret_type);\n     let generics = generics(db.upcast(), def.into());\n-    let num_binders = generics.len();\n-    Binders::new(num_binders, CallableSig::from_params_and_return(params, ret, data.is_varargs()))\n+    make_binders(&generics, CallableSig::from_params_and_return(params, ret, data.is_varargs()))\n }\n \n /// Build the declared type of a function. This should not need to look at the\n /// function body.\n fn type_for_fn(db: &dyn HirDatabase, def: FunctionId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), def.into());\n     let substs = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n-    Binders::new(\n-        substs.len(&Interner),\n+    make_binders(\n+        &generics,\n         TyKind::FnDef(CallableDefId::FunctionId(def).to_chalk(db), substs).intern(&Interner),\n     )\n }\n@@ -1072,7 +1067,7 @@ fn type_for_const(db: &dyn HirDatabase, def: ConstId) -> Binders<Ty> {\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n \n-    Binders::new(generics.len(), ctx.lower_ty(&data.type_ref))\n+    make_binders(&generics, ctx.lower_ty(&data.type_ref))\n }\n \n /// Build the declared type of a static.\n@@ -1081,7 +1076,7 @@ fn type_for_static(db: &dyn HirDatabase, def: StaticId) -> Binders<Ty> {\n     let resolver = def.resolver(db.upcast());\n     let ctx = TyLoweringContext::new(db, &resolver);\n \n-    Binders::new(0, ctx.lower_ty(&data.type_ref))\n+    Binders::empty(&Interner, ctx.lower_ty(&data.type_ref))\n }\n \n fn fn_sig_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> PolyFnSig {\n@@ -1103,8 +1098,8 @@ fn type_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> Binders<T\n     }\n     let generics = generics(db.upcast(), def.into());\n     let substs = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n-    Binders::new(\n-        substs.len(&Interner),\n+    make_binders(\n+        &generics,\n         TyKind::FnDef(CallableDefId::StructId(def).to_chalk(db), substs).intern(&Interner),\n     )\n }\n@@ -1130,17 +1125,17 @@ fn type_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId) -\n     }\n     let generics = generics(db.upcast(), def.parent.into());\n     let substs = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n-    Binders::new(\n-        substs.len(&Interner),\n+    make_binders(\n+        &generics,\n         TyKind::FnDef(CallableDefId::EnumVariantId(def).to_chalk(db), substs).intern(&Interner),\n     )\n }\n \n fn type_for_adt(db: &dyn HirDatabase, adt: AdtId) -> Binders<Ty> {\n+    let generics = generics(db.upcast(), adt.into());\n     let b = TyBuilder::adt(db, adt);\n-    let num_binders = b.remaining();\n     let ty = b.fill_with_bound_vars(DebruijnIndex::INNERMOST, 0).build();\n-    Binders::new(num_binders, ty)\n+    make_binders(&generics, ty)\n }\n \n fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n@@ -1149,11 +1144,11 @@ fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     if db.type_alias_data(t).is_extern {\n-        Binders::new(0, TyKind::Foreign(crate::to_foreign_def_id(t)).intern(&Interner))\n+        Binders::empty(&Interner, TyKind::Foreign(crate::to_foreign_def_id(t)).intern(&Interner))\n     } else {\n         let type_ref = &db.type_alias_data(t).type_ref;\n         let inner = ctx.lower_ty(type_ref.as_deref().unwrap_or(&TypeRef::Error));\n-        Binders::new(generics.len(), inner)\n+        make_binders(&generics, inner)\n     }\n }\n \n@@ -1212,19 +1207,21 @@ impl_from!(FunctionId, StructId, UnionId, EnumVariantId, ConstId, StaticId for V\n /// namespace.\n pub(crate) fn ty_query(db: &dyn HirDatabase, def: TyDefId) -> Binders<Ty> {\n     match def {\n-        TyDefId::BuiltinType(it) => Binders::new(0, TyBuilder::builtin(it)),\n+        TyDefId::BuiltinType(it) => Binders::empty(&Interner, TyBuilder::builtin(it)),\n         TyDefId::AdtId(it) => type_for_adt(db, it),\n         TyDefId::TypeAliasId(it) => type_for_type_alias(db, it),\n     }\n }\n \n pub(crate) fn ty_recover(db: &dyn HirDatabase, _cycle: &[String], def: &TyDefId) -> Binders<Ty> {\n-    let num_binders = match *def {\n-        TyDefId::BuiltinType(_) => 0,\n-        TyDefId::AdtId(it) => generics(db.upcast(), it.into()).len(),\n-        TyDefId::TypeAliasId(it) => generics(db.upcast(), it.into()).len(),\n+    let generics = match *def {\n+        TyDefId::BuiltinType(_) => {\n+            return Binders::empty(&Interner, TyKind::Error.intern(&Interner))\n+        }\n+        TyDefId::AdtId(it) => generics(db.upcast(), it.into()),\n+        TyDefId::TypeAliasId(it) => generics(db.upcast(), it.into()),\n     };\n-    Binders::new(num_binders, TyKind::Error.intern(&Interner))\n+    make_binders(&generics, TyKind::Error.intern(&Interner))\n }\n \n pub(crate) fn value_ty_query(db: &dyn HirDatabase, def: ValueTyDefId) -> Binders<Ty> {\n@@ -1244,7 +1241,7 @@ pub(crate) fn impl_self_ty_query(db: &dyn HirDatabase, impl_id: ImplId) -> Binde\n     let generics = generics(db.upcast(), impl_id.into());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n-    Binders::new(generics.len(), ctx.lower_ty(&impl_data.self_ty))\n+    make_binders(&generics, ctx.lower_ty(&impl_data.self_ty))\n }\n \n pub(crate) fn const_param_ty_query(db: &dyn HirDatabase, def: ConstParamId) -> Ty {\n@@ -1262,7 +1259,7 @@ pub(crate) fn impl_self_ty_recover(\n     impl_id: &ImplId,\n ) -> Binders<Ty> {\n     let generics = generics(db.upcast(), (*impl_id).into());\n-    Binders::new(generics.len(), TyKind::Error.intern(&Interner))\n+    make_binders(&generics, TyKind::Error.intern(&Interner))\n }\n \n pub(crate) fn impl_trait_query(db: &dyn HirDatabase, impl_id: ImplId) -> Option<Binders<TraitRef>> {\n@@ -1287,13 +1284,12 @@ pub(crate) fn return_type_impl_traits(\n         .with_type_param_mode(TypeParamLoweringMode::Variable);\n     let _ret = (&ctx_ret).lower_ty(&data.ret_type);\n     let generics = generics(db.upcast(), def.into());\n-    let num_binders = generics.len();\n     let return_type_impl_traits =\n         ReturnTypeImplTraits { impl_traits: ctx_ret.opaque_type_data.into_inner() };\n     if return_type_impl_traits.impl_traits.is_empty() {\n         None\n     } else {\n-        Some(Arc::new(Binders::new(num_binders, return_type_impl_traits)))\n+        Some(Arc::new(make_binders(&generics, return_type_impl_traits)))\n     }\n }\n \n@@ -1303,3 +1299,7 @@ pub(crate) fn lower_to_chalk_mutability(m: hir_def::type_ref::Mutability) -> Mut\n         hir_def::type_ref::Mutability::Mut => Mutability::Mut,\n     }\n }\n+\n+fn make_binders<T>(generics: &Generics, value: T) -> Binders<T> {\n+    crate::make_only_type_binders(generics.len(), value)\n+}"}, {"sha": "dff87ef70e45dd354bda26132a027503c7037e89", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad20f00844cec9c794e34869be163673ebbed182/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad20f00844cec9c794e34869be163673ebbed182/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=ad20f00844cec9c794e34869be163673ebbed182", "patch": "@@ -184,7 +184,8 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                     .db\n                     .return_type_impl_traits(func)\n                     .expect(\"impl trait id without impl traits\");\n-                let data = &datas.skip_binders().impl_traits[idx as usize];\n+                let (datas, binders) = (*datas).as_ref().into_value_and_skipped_binders();\n+                let data = &datas.impl_traits[idx as usize];\n                 let bound = OpaqueTyDatumBound {\n                     bounds: make_binders(\n                         data.bounds\n@@ -197,8 +198,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                     ),\n                     where_clauses: make_binders(vec![], 0),\n                 };\n-                let num_vars = datas.num_binders;\n-                make_binders(bound, num_vars)\n+                chalk_ir::Binders::new(binders, bound)\n             }\n             crate::ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n                 if let Some((future_trait, future_output)) = self\n@@ -626,7 +626,7 @@ fn type_alias_associated_ty_value(\n     let value = rust_ir::AssociatedTyValue {\n         impl_id: impl_id.to_chalk(db),\n         associated_ty_id: to_assoc_type_id(assoc_ty),\n-        value: make_binders(value_bound, binders),\n+        value: chalk_ir::Binders::new(binders, value_bound),\n     };\n     Arc::new(value)\n }\n@@ -656,7 +656,7 @@ pub(crate) fn fn_def_datum_query(\n     let datum = FnDefDatum {\n         id: fn_def_id,\n         sig: chalk_ir::FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic: sig.is_varargs },\n-        binders: make_binders(bound, binders),\n+        binders: chalk_ir::Binders::new(binders, bound),\n     };\n     Arc::new(datum)\n }"}, {"sha": "2c7407c7ca888498b796916bc88d4b62e3d1ba9d", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad20f00844cec9c794e34869be163673ebbed182/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad20f00844cec9c794e34869be163673ebbed182/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=ad20f00844cec9c794e34869be163673ebbed182", "patch": "@@ -99,7 +99,7 @@ impl ToChalk for Ty {\n                     bounds.interned().iter().cloned().map(|p| p.to_chalk(db)),\n                 );\n                 let bounded_ty = chalk_ir::DynTy {\n-                    bounds: make_binders(where_clauses, binders),\n+                    bounds: chalk_ir::Binders::new(binders, where_clauses),\n                     lifetime: LifetimeData::Static.intern(&Interner),\n                 };\n                 chalk_ir::TyKind::Dyn(bounded_ty).intern(&Interner)\n@@ -149,7 +149,7 @@ impl ToChalk for Ty {\n                     .map(|c| from_chalk(db, c.clone()));\n                 TyKind::Dyn(crate::DynTy {\n                     bounds: crate::Binders::new(\n-                        1,\n+                        where_clauses.bounds.binders.clone(),\n                         crate::QuantifiedWhereClauses::from_iter(&Interner, bounds),\n                     ),\n                 })\n@@ -488,19 +488,12 @@ where\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Binders<T::Chalk> {\n         let (value, binders) = self.into_value_and_skipped_binders();\n-        chalk_ir::Binders::new(\n-            chalk_ir::VariableKinds::from_iter(\n-                &Interner,\n-                std::iter::repeat(chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General))\n-                    .take(binders),\n-            ),\n-            value.to_chalk(db),\n-        )\n+        chalk_ir::Binders::new(binders, value.to_chalk(db))\n     }\n \n     fn from_chalk(db: &dyn HirDatabase, binders: chalk_ir::Binders<T::Chalk>) -> crate::Binders<T> {\n         let (v, b) = binders.into_value_and_skipped_binders();\n-        crate::Binders::new(b.len(&Interner), from_chalk(db, v))\n+        crate::Binders::new(b, from_chalk(db, v))\n     }\n }\n \n@@ -552,7 +545,7 @@ pub(super) fn generic_predicate_to_inline_bound(\n                 .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n                 .collect();\n             let trait_bound = rust_ir::TraitBound { trait_id: trait_ref.trait_id, args_no_self };\n-            Some(make_binders(rust_ir::InlineBound::TraitBound(trait_bound), binders))\n+            Some(chalk_ir::Binders::new(binders, rust_ir::InlineBound::TraitBound(trait_bound)))\n         }\n         WhereClause::AliasEq(AliasEq { alias: AliasTy::Projection(projection_ty), ty }) => {\n             if projection_ty.self_type_parameter(&Interner) != &self_ty_shifted_in {\n@@ -569,7 +562,10 @@ pub(super) fn generic_predicate_to_inline_bound(\n                 associated_ty_id: projection_ty.associated_ty_id,\n                 parameters: Vec::new(), // FIXME we don't support generic associated types yet\n             };\n-            Some(make_binders(rust_ir::InlineBound::AliasEqBound(alias_eq_bound), binders))\n+            Some(chalk_ir::Binders::new(\n+                binders,\n+                rust_ir::InlineBound::AliasEqBound(alias_eq_bound),\n+            ))\n         }\n         _ => None,\n     }"}, {"sha": "59678b45b41b154adf30cd324855295cda75ed5c", "filename": "crates/hir_ty/src/types.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ad20f00844cec9c794e34869be163673ebbed182/crates%2Fhir_ty%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad20f00844cec9c794e34869be163673ebbed182/crates%2Fhir_ty%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftypes.rs?ref=ad20f00844cec9c794e34869be163673ebbed182", "patch": "@@ -12,7 +12,7 @@ use smallvec::SmallVec;\n \n use crate::{\n     AssocTypeId, CanonicalVarKinds, ChalkTraitId, ClosureId, FnDefId, FnSig, ForeignDefId,\n-    InferenceVar, Interner, OpaqueTyId, PlaceholderIndex,\n+    InferenceVar, Interner, OpaqueTyId, PlaceholderIndex, VariableKinds,\n };\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -286,7 +286,7 @@ impl Substitution {\n         Substitution(elements.into_iter().casted(interner).collect())\n     }\n \n-    // We can hopefully add this to Chalk\n+    // Temporary helper functions, to be removed\n     pub fn intern(interned: SmallVec<[GenericArg; 2]>) -> Substitution {\n         Substitution(interned)\n     }\n@@ -296,46 +296,67 @@ impl Substitution {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Binders<T> {\n-    pub num_binders: usize,\n+    /// The binders that quantify over the value.\n+    pub binders: VariableKinds,\n     value: T,\n }\n \n impl<T> Binders<T> {\n-    pub fn new(num_binders: usize, value: T) -> Self {\n-        Self { num_binders, value }\n+    pub fn new(binders: VariableKinds, value: T) -> Self {\n+        Self { binders, value }\n     }\n \n     pub fn empty(_interner: &Interner, value: T) -> Self {\n-        Self { num_binders: 0, value }\n+        crate::make_only_type_binders(0, value)\n     }\n \n     pub fn as_ref(&self) -> Binders<&T> {\n-        Binders { num_binders: self.num_binders, value: &self.value }\n+        Binders { binders: self.binders.clone(), value: &self.value }\n     }\n \n     pub fn map<U>(self, f: impl FnOnce(T) -> U) -> Binders<U> {\n-        Binders { num_binders: self.num_binders, value: f(self.value) }\n+        Binders { binders: self.binders, value: f(self.value) }\n     }\n \n     pub fn filter_map<U>(self, f: impl FnOnce(T) -> Option<U>) -> Option<Binders<U>> {\n-        Some(Binders { num_binders: self.num_binders, value: f(self.value)? })\n+        Some(Binders { binders: self.binders, value: f(self.value)? })\n     }\n \n     pub fn skip_binders(&self) -> &T {\n         &self.value\n     }\n \n-    pub fn into_value_and_skipped_binders(self) -> (T, usize) {\n-        (self.value, self.num_binders)\n+    pub fn into_value_and_skipped_binders(self) -> (T, VariableKinds) {\n+        (self.value, self.binders)\n     }\n \n+    /// Returns the number of binders.\n+    pub fn len(&self, interner: &Interner) -> usize {\n+        self.binders.len(interner)\n+    }\n+\n+    // Temporary helper function, to be removed\n     pub fn skip_binders_mut(&mut self) -> &mut T {\n         &mut self.value\n     }\n }\n \n+impl<T: Clone> Binders<&T> {\n+    pub fn cloned(&self) -> Binders<T> {\n+        Binders::new(self.binders.clone(), self.value.clone())\n+    }\n+}\n+\n+impl<T: std::fmt::Debug> std::fmt::Debug for Binders<T> {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n+        let Binders { ref binders, ref value } = *self;\n+        write!(fmt, \"for{:?} \", binders.inner_debug(&Interner))?;\n+        std::fmt::Debug::fmt(value, fmt)\n+    }\n+}\n+\n /// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct TraitRef {"}]}