{"sha": "ad3fe316c616cbc5640cff19048eabac8941ed01", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkM2ZlMzE2YzYxNmNiYzU2NDBjZmYxOTA0OGVhYmFjODk0MWVkMDE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-27T15:22:14Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-27T15:22:14Z"}, "message": "further simplify assists", "tree": {"sha": "0bac652248688d78bac3742c278039709ebba8c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bac652248688d78bac3742c278039709ebba8c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad3fe316c616cbc5640cff19048eabac8941ed01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad3fe316c616cbc5640cff19048eabac8941ed01", "html_url": "https://github.com/rust-lang/rust/commit/ad3fe316c616cbc5640cff19048eabac8941ed01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad3fe316c616cbc5640cff19048eabac8941ed01/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6588b86768fe426ff85dd0c5c838193a8f27d48", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6588b86768fe426ff85dd0c5c838193a8f27d48", "html_url": "https://github.com/rust-lang/rust/commit/f6588b86768fe426ff85dd0c5c838193a8f27d48"}], "stats": {"total": 119, "additions": 37, "deletions": 82}, "files": [{"sha": "1908bdec90df5216177666f658ecdd2b58b8be96", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ad3fe316c616cbc5640cff19048eabac8941ed01/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad3fe316c616cbc5640cff19048eabac8941ed01/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=ad3fe316c616cbc5640cff19048eabac8941ed01", "patch": "@@ -14,8 +14,8 @@ use crate::{AssistAction, AssistId, AssistLabel};\n \n #[derive(Clone, Debug)]\n pub(crate) enum Assist {\n-    Unresolved(Vec<AssistLabel>),\n-    Resolved(Vec<(AssistLabel, AssistAction)>),\n+    Unresolved { label: AssistLabel },\n+    Resolved { label: AssistLabel, action: AssistAction },\n }\n \n /// `AssistCtx` allows to apply an assist or check if it could be applied.\n@@ -54,7 +54,6 @@ pub(crate) struct AssistCtx<'a, DB> {\n     pub(crate) frange: FileRange,\n     source_file: SourceFile,\n     should_compute_edit: bool,\n-    assist: Assist,\n }\n \n impl<'a, DB> Clone for AssistCtx<'a, DB> {\n@@ -64,7 +63,6 @@ impl<'a, DB> Clone for AssistCtx<'a, DB> {\n             frange: self.frange,\n             source_file: self.source_file.clone(),\n             should_compute_edit: self.should_compute_edit,\n-            assist: self.assist.clone(),\n         }\n     }\n }\n@@ -75,32 +73,30 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n         F: FnOnce(AssistCtx<DB>) -> T,\n     {\n         let parse = db.parse(frange.file_id);\n-        let assist =\n-            if should_compute_edit { Assist::Resolved(vec![]) } else { Assist::Unresolved(vec![]) };\n \n-        let ctx = AssistCtx { db, frange, source_file: parse.tree(), should_compute_edit, assist };\n+        let ctx = AssistCtx { db, frange, source_file: parse.tree(), should_compute_edit };\n         f(ctx)\n     }\n \n     pub(crate) fn add_assist(\n-        mut self,\n+        self,\n         id: AssistId,\n         label: impl Into<String>,\n         f: impl FnOnce(&mut AssistBuilder),\n     ) -> Option<Assist> {\n         let label = AssistLabel { label: label.into(), id };\n-        match &mut self.assist {\n-            Assist::Unresolved(labels) => labels.push(label),\n-            Assist::Resolved(labels_actions) => {\n-                let action = {\n-                    let mut edit = AssistBuilder::default();\n-                    f(&mut edit);\n-                    edit.build()\n-                };\n-                labels_actions.push((label, action));\n-            }\n-        }\n-        Some(self.assist)\n+        let assist = if self.should_compute_edit {\n+            let action = {\n+                let mut edit = AssistBuilder::default();\n+                f(&mut edit);\n+                edit.build()\n+            };\n+            Assist::Resolved { label, action }\n+        } else {\n+            Assist::Unresolved { label }\n+        };\n+\n+        Some(assist)\n     }\n \n     pub(crate) fn token_at_offset(&self) -> TokenAtOffset<SyntaxToken> {"}, {"sha": "38599d4f173c6769ae4d40542ff39cd0e7f98936", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 21, "deletions": 62, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ad3fe316c616cbc5640cff19048eabac8941ed01/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad3fe316c616cbc5640cff19048eabac8941ed01/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=ad3fe316c616cbc5640cff19048eabac8941ed01", "patch": "@@ -11,7 +11,6 @@ mod marks;\n mod doc_tests;\n \n use hir::db::HirDatabase;\n-use itertools::Itertools;\n use ra_db::FileRange;\n use ra_syntax::{TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n@@ -51,10 +50,10 @@ where\n             .iter()\n             .filter_map(|f| f(ctx.clone()))\n             .map(|a| match a {\n-                Assist::Unresolved(labels) => labels,\n-                Assist::Resolved(..) => unreachable!(),\n+                Assist::Unresolved { label } => label,\n+                Assist::Resolved { .. } => unreachable!(),\n             })\n-            .concat()\n+            .collect()\n     })\n }\n \n@@ -73,10 +72,10 @@ where\n             .iter()\n             .filter_map(|f| f(ctx.clone()))\n             .map(|a| match a {\n-                Assist::Resolved(labels_actions) => labels_actions,\n-                Assist::Unresolved(..) => unreachable!(),\n+                Assist::Resolved { label, action } => (label, action),\n+                Assist::Unresolved { .. } => unreachable!(),\n             })\n-            .concat();\n+            .collect::<Vec<_>>();\n         a.sort_by(|a, b| match (a.1.target, b.1.target) {\n             (Some(a), Some(b)) => a.len().cmp(&b.len()),\n             (Some(_), None) => Ordering::Less,\n@@ -158,52 +157,18 @@ mod helpers {\n         assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n         before: &str,\n         after: &str,\n-    ) {\n-        check_assist_nth_action(assist, before, after, 0)\n-    }\n-\n-    pub(crate) fn check_assist_range(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n-        before: &str,\n-        after: &str,\n-    ) {\n-        check_assist_range_nth_action(assist, before, after, 0)\n-    }\n-\n-    pub(crate) fn check_assist_target(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n-        before: &str,\n-        target: &str,\n-    ) {\n-        check_assist_target_nth_action(assist, before, target, 0)\n-    }\n-\n-    pub(crate) fn check_assist_range_target(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n-        before: &str,\n-        target: &str,\n-    ) {\n-        check_assist_range_target_nth_action(assist, before, target, 0)\n-    }\n-\n-    pub(crate) fn check_assist_nth_action(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n-        before: &str,\n-        after: &str,\n-        index: usize,\n     ) {\n         let (before_cursor_pos, before) = extract_offset(before);\n         let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist =\n             AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n-        let labels_actions = match assist {\n-            Assist::Unresolved(_) => unreachable!(),\n-            Assist::Resolved(labels_actions) => labels_actions,\n+        let action = match assist {\n+            Assist::Unresolved { .. } => unreachable!(),\n+            Assist::Resolved { action, .. } => action,\n         };\n \n-        let (_, action) = labels_actions.get(index).expect(\"expect assist action at index\");\n         let actual = action.edit.apply(&before);\n         let actual_cursor_pos = match action.cursor_position {\n             None => action\n@@ -216,69 +181,63 @@ mod helpers {\n         assert_eq_text!(after, &actual);\n     }\n \n-    pub(crate) fn check_assist_range_nth_action(\n+    pub(crate) fn check_assist_range(\n         assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n         before: &str,\n         after: &str,\n-        index: usize,\n     ) {\n         let (range, before) = extract_range(before);\n         let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n         let frange = FileRange { file_id, range };\n         let assist =\n             AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n-        let labels_actions = match assist {\n-            Assist::Unresolved(_) => unreachable!(),\n-            Assist::Resolved(labels_actions) => labels_actions,\n+        let action = match assist {\n+            Assist::Unresolved { .. } => unreachable!(),\n+            Assist::Resolved { action, .. } => action,\n         };\n \n-        let (_, action) = labels_actions.get(index).expect(\"expect assist action at index\");\n         let mut actual = action.edit.apply(&before);\n         if let Some(pos) = action.cursor_position {\n             actual = add_cursor(&actual, pos);\n         }\n         assert_eq_text!(after, &actual);\n     }\n \n-    pub(crate) fn check_assist_target_nth_action(\n+    pub(crate) fn check_assist_target(\n         assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n         before: &str,\n         target: &str,\n-        index: usize,\n     ) {\n         let (before_cursor_pos, before) = extract_offset(before);\n         let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist =\n             AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n-        let labels_actions = match assist {\n-            Assist::Unresolved(_) => unreachable!(),\n-            Assist::Resolved(labels_actions) => labels_actions,\n+        let action = match assist {\n+            Assist::Unresolved { .. } => unreachable!(),\n+            Assist::Resolved { action, .. } => action,\n         };\n \n-        let (_, action) = labels_actions.get(index).expect(\"expect assist action at index\");\n         let range = action.target.expect(\"expected target on action\");\n         assert_eq_text!(&before[range.start().to_usize()..range.end().to_usize()], target);\n     }\n \n-    pub(crate) fn check_assist_range_target_nth_action(\n+    pub(crate) fn check_assist_range_target(\n         assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n         before: &str,\n         target: &str,\n-        index: usize,\n     ) {\n         let (range, before) = extract_range(before);\n         let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n         let frange = FileRange { file_id, range };\n         let assist =\n             AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n-        let labels_actions = match assist {\n-            Assist::Unresolved(_) => unreachable!(),\n-            Assist::Resolved(labels_actions) => labels_actions,\n+        let action = match assist {\n+            Assist::Unresolved { .. } => unreachable!(),\n+            Assist::Resolved { action, .. } => action,\n         };\n \n-        let (_, action) = labels_actions.get(index).expect(\"expect assist action at index\");\n         let range = action.target.expect(\"expected target on action\");\n         assert_eq_text!(&before[range.start().to_usize()..range.end().to_usize()], target);\n     }"}]}