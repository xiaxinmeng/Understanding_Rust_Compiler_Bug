{"sha": "6561732f887e9e379293821d4d802a6fa1c44fd6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NjE3MzJmODg3ZTllMzc5MjkzODIxZDRkODAyYTZmYTFjNDRmZDY=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-11-20T19:07:17Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-12-11T11:18:55Z"}, "message": "Consider privacy in more locations", "tree": {"sha": "19ec60faa0fe171ba9ca9944b500e6aa62205657", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19ec60faa0fe171ba9ca9944b500e6aa62205657"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6561732f887e9e379293821d4d802a6fa1c44fd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6561732f887e9e379293821d4d802a6fa1c44fd6", "html_url": "https://github.com/rust-lang/rust/commit/6561732f887e9e379293821d4d802a6fa1c44fd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6561732f887e9e379293821d4d802a6fa1c44fd6/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d8a6eac397a4acdd5965c4c9f04d236ada2e266", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d8a6eac397a4acdd5965c4c9f04d236ada2e266", "html_url": "https://github.com/rust-lang/rust/commit/4d8a6eac397a4acdd5965c4c9f04d236ada2e266"}], "stats": {"total": 35, "additions": 18, "deletions": 17}, "files": [{"sha": "a33dca0ac046e5c7dcb58b62e473bbcf35dc229a", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6561732f887e9e379293821d4d802a6fa1c44fd6/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6561732f887e9e379293821d4d802a6fa1c44fd6/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=6561732f887e9e379293821d4d802a6fa1c44fd6", "patch": "@@ -415,7 +415,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             args: I) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        if self.tables.expr_ty(call_expr).conservative_is_uninhabited(self.tcx) {\n+        let m = self.tcx.hir.get_module_parent(call_expr.id);\n+        if self.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(call_expr)) {\n             self.add_unreachable_node()\n         } else {\n             ret"}, {"sha": "f4506c8e8197661a3377f9400b5909c12a046586", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6561732f887e9e379293821d4d802a6fa1c44fd6/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6561732f887e9e379293821d4d802a6fa1c44fd6/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=6561732f887e9e379293821d4d802a6fa1c44fd6", "patch": "@@ -194,7 +194,7 @@ fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let layout = cx.layout_raw_uncached(ty);\n             // Type-level uninhabitedness should always imply ABI uninhabitedness.\n             if let Ok(layout) = layout {\n-                if ty.conservative_is_uninhabited(tcx) {\n+                if ty.conservative_is_privately_uninhabited(tcx) {\n                     assert!(layout.abi.is_uninhabited());\n                 }\n             }\n@@ -557,7 +557,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let size = element.size.checked_mul(count, dl)\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n \n-                let abi = if count != 0 && ty.conservative_is_uninhabited(tcx) {\n+                let abi = if count != 0 && ty.conservative_is_privately_uninhabited(tcx) {\n                     Abi::Uninhabited\n                 } else {\n                     Abi::Aggregate { sized: true }"}, {"sha": "2189267cb0b05e130438fb1feaa9ce2e8febe713", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6561732f887e9e379293821d4d802a6fa1c44fd6/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6561732f887e9e379293821d4d802a6fa1c44fd6/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=6561732f887e9e379293821d4d802a6fa1c44fd6", "patch": "@@ -1546,10 +1546,10 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Checks whether a type is definitely uninhabited. This is\n     /// conservative: for some types that are uninhabited we return `false`,\n     /// but we only return `true` for types that are definitely uninhabited.\n-    /// `ty.conservative_is_uninhabited` implies that any value of type `ty`\n+    /// `ty.conservative_is_privately_uninhabited` implies that any value of type `ty`\n     /// will be `Abi::Uninhabited`. (Note that uninhabited types may have nonzero\n     /// size, to account for partial initialisation. See #49298 for details.)\n-    pub fn conservative_is_uninhabited(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    pub fn conservative_is_privately_uninhabited(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         // FIXME(varkor): we can make this less conversative by substituting concrete\n         // type arguments.\n         match self.sty {\n@@ -1565,16 +1565,16 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 //     one uninhabited field.\n                 def.variants.iter().all(|var| {\n                     var.fields.iter().any(|field| {\n-                        tcx.type_of(field.did).conservative_is_uninhabited(tcx)\n+                        tcx.type_of(field.did).conservative_is_privately_uninhabited(tcx)\n                     })\n                 })\n             }\n-            ty::Tuple(tys) => tys.iter().any(|ty| ty.conservative_is_uninhabited(tcx)),\n+            ty::Tuple(tys) => tys.iter().any(|ty| ty.conservative_is_privately_uninhabited(tcx)),\n             ty::Array(ty, len) => {\n                 match len.assert_usize(tcx) {\n                     // If the array is definitely non-empty, it's uninhabited if\n                     // the type of its elements is uninhabited.\n-                    Some(n) if n != 0 => ty.conservative_is_uninhabited(tcx),\n+                    Some(n) if n != 0 => ty.conservative_is_privately_uninhabited(tcx),\n                     _ => false\n                 }\n             }"}, {"sha": "c01502e44d944d671825dbde06b0cf21b983b90f", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6561732f887e9e379293821d4d802a6fa1c44fd6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6561732f887e9e379293821d4d802a6fa1c44fd6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=6561732f887e9e379293821d4d802a6fa1c44fd6", "patch": "@@ -1546,7 +1546,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             None => {\n-                if !sig.output().conservative_is_uninhabited(self.tcx()) {\n+                if !sig.output().conservative_is_privately_uninhabited(self.tcx()) {\n                     span_mirbug!(self, term, \"call to converging function {:?} w/o dest\", sig);\n                 }\n             }"}, {"sha": "8660bbadf3dc2e07d48209155a32b8740e72accc", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6561732f887e9e379293821d4d802a6fa1c44fd6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6561732f887e9e379293821d4d802a6fa1c44fd6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=6561732f887e9e379293821d4d802a6fa1c44fd6", "patch": "@@ -330,11 +330,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             func: fun,\n                             args,\n                             cleanup: Some(cleanup),\n-                            destination: if expr.ty.conservative_is_uninhabited(this.hir.tcx()) {\n-                                None\n-                            } else {\n-                                Some((destination.clone(), success))\n-                            },\n+                            destination:\n+                                if expr.ty.conservative_is_privately_uninhabited(this.hir.tcx()) {\n+                                    None\n+                                } else {\n+                                    Some((destination.clone(), success))\n+                                },\n                             from_hir_call,\n                         },\n                     );\n@@ -419,8 +420,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 });\n \n                 let rvalue = unpack!(block = this.as_local_rvalue(block, expr));\n-                this.cfg\n-                    .push_assign(block, source_info, destination, rvalue);\n+                this.cfg.push_assign(block, source_info, destination, rvalue);\n                 block.unit()\n             }\n         };"}, {"sha": "66de4e6b37f11b10452829f8685441bd87add9c1", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6561732f887e9e379293821d4d802a6fa1c44fd6/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6561732f887e9e379293821d4d802a6fa1c44fd6/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=6561732f887e9e379293821d4d802a6fa1c44fd6", "patch": "@@ -230,7 +230,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 let scrutinee_is_uninhabited = if self.tcx.features().exhaustive_patterns {\n                     self.tcx.is_ty_uninhabited_from(module, pat_ty)\n                 } else {\n-                    pat_ty.conservative_is_uninhabited(self.tcx)\n+                    pat_ty.is_never()\n                 };\n                 if !scrutinee_is_uninhabited {\n                     // We know the type is inhabited, so this must be wrong"}]}