{"sha": "11c63eaad2311bbeea67ec9a9300686dbe400e23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExYzYzZWFhZDIzMTFiYmVlYTY3ZWM5YTkzMDA2ODZkYmU0MDBlMjM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-11T07:19:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-11T07:22:08Z"}, "message": "Fix a soundness problem with `get`", "tree": {"sha": "9325b088dee7d55e9dfe0cc709eb0460e0d17fd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9325b088dee7d55e9dfe0cc709eb0460e0d17fd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11c63eaad2311bbeea67ec9a9300686dbe400e23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11c63eaad2311bbeea67ec9a9300686dbe400e23", "html_url": "https://github.com/rust-lang/rust/commit/11c63eaad2311bbeea67ec9a9300686dbe400e23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11c63eaad2311bbeea67ec9a9300686dbe400e23/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3fb7062aa2d7113c4ff4cb41a27bfb637465d57", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57", "html_url": "https://github.com/rust-lang/rust/commit/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57"}], "stats": {"total": 110, "additions": 79, "deletions": 31}, "files": [{"sha": "711ed15fa9d2f05349b74b32331f5ca8ec34fa9b", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/11c63eaad2311bbeea67ec9a9300686dbe400e23/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11c63eaad2311bbeea67ec9a9300686dbe400e23/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=11c63eaad2311bbeea67ec9a9300686dbe400e23", "patch": "@@ -273,3 +273,11 @@ fn test_static_pointer() {\n         set(key, @&VALUE);\n     }\n }\n+\n+#[test]\n+fn test_owned() {\n+    unsafe {\n+        fn key(_x: ~int) { }\n+        set(key, ~1);\n+    }\n+}"}, {"sha": "42cfcbc16dbf8a7f038cb8e03e52bc532fb77a08", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 71, "deletions": 31, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/11c63eaad2311bbeea67ec9a9300686dbe400e23/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11c63eaad2311bbeea67ec9a9300686dbe400e23/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=11c63eaad2311bbeea67ec9a9300686dbe400e23", "patch": "@@ -48,23 +48,36 @@ impl Handle {\n trait LocalData {}\n impl<T: 'static> LocalData for T {}\n \n-// The task-local-map actually stores all TLS information. Right now it's a list\n-// of triples of (key, value, loans). The key is a code pointer (right now at\n-// least), the value is a trait so destruction can work, and the loans value\n-// is a count of the number of times the value is currently on loan via\n-// `local_data_get`.\n+// The task-local-map stores all TLS information for the currently running task.\n+// It is stored as an owned pointer into the runtime, and it's only allocated\n+// when TLS is used for the first time. This map must be very carefully\n+// constructed because it has many mutable loans unsoundly handed out on it to\n+// the various invocations of TLS requests.\n //\n-// TLS is designed to be able to store owned data, so `local_data_get` must\n-// return a borrowed pointer to this data. In order to have a proper lifetime, a\n-// borrowed pointer is instead yielded to a closure specified to the `get`\n-// function. As a result, it would be unsound to perform `local_data_set` on the\n-// same key inside of a `local_data_get`, so we ensure at runtime that this does\n-// not happen.\n+// One of the most important operations is loaning a value via `get` to a\n+// caller. In doing so, the slot that the TLS entry is occupying cannot be\n+// invalidated because upon returning it's loan state must be updated. Currently\n+// the TLS map is a vector, but this is possibly dangerous because the vector\n+// can be reallocated/moved when new values are pushed onto it.\n //\n-// n.b. Has to be a pointer at outermost layer; the foreign call returns void *.\n+// This problem currently isn't solved in a very elegant way. Inside the `get`\n+// function, it internally \"invalidates\" all references after the loan is\n+// finished and looks up into the vector again. In theory this will prevent\n+// pointers from being moved under our feet so long as LLVM doesn't go too crazy\n+// with the optimizations.\n+//\n+// n.b. Other structures are not sufficient right now:\n+//          * HashMap uses ~[T] internally (push reallocates/moves)\n+//          * TreeMap is plausible, but it's in extra\n+//          * dlist plausible, but not in std\n+//          * a custom owned linked list was attempted, but difficult to write\n+//            and involved a lot of extra code bloat\n+//\n+// n.b. Has to be stored with a pointer at outermost layer; the foreign call\n+//      returns void *.\n //\n // n.b. If TLS is used heavily in future, this could be made more efficient with\n-// a proper map.\n+//      a proper map.\n type TaskLocalMap = ~[Option<(*libc::c_void, TLSValue, uint)>];\n type TLSValue = ~LocalData:;\n \n@@ -181,32 +194,59 @@ pub unsafe fn local_pop<T: 'static>(handle: Handle,\n pub unsafe fn local_get<T: 'static, U>(handle: Handle,\n                                        key: local_data::Key<T>,\n                                        f: &fn(Option<&T>) -> U) -> U {\n-    // This does in theory take multiple mutable loans on the tls map, but the\n-    // references returned are never removed because the map is only increasing\n-    // in size (it never shrinks).\n+    // This function must be extremely careful. Because TLS can store owned\n+    // values, and we must have some form of `get` function other than `pop`,\n+    // this function has to give a `&` reference back to the caller.\n+    //\n+    // One option is to return the reference, but this cannot be sound because\n+    // the actual lifetime of the object is not known. The slot in TLS could not\n+    // be modified until the object goes out of scope, but the TLS code cannot\n+    // know when this happens.\n+    //\n+    // For this reason, the reference is yielded to a specified closure. This\n+    // way the TLS code knows exactly what the lifetime of the yielded pointer\n+    // is, allowing callers to acquire references to owned data. This is also\n+    // sound so long as measures are taken to ensure that while a TLS slot is\n+    // loaned out to a caller, it's not modified recursively.\n     let map = get_local_map(handle);\n     let key_value = key_to_key_value(key);\n-    for map.mut_iter().advance |entry| {\n+\n+    let pos = map.iter().position(|entry| {\n         match *entry {\n-            Some((k, ref data, ref mut loans)) if k == key_value => {\n-                let ret;\n-                *loans = *loans + 1;\n-                // data was created with `~~T as ~LocalData`, so we extract\n-                // pointer part of the trait, (as ~~T), and then use compiler\n-                // coercions to achieve a '&' pointer\n-                match *cast::transmute::<&TLSValue, &(uint, ~~T)>(data) {\n-                    (_vtable, ref box) => {\n-                        let value: &T = **box;\n-                        ret = f(Some(value));\n+            Some((k, _, _)) if k == key_value => true, _ => false\n+        }\n+    });\n+    match pos {\n+        None => { return f(None); }\n+        Some(i) => {\n+            let ret;\n+            match map[i] {\n+                Some((_, ref data, ref mut loans)) => {\n+                    *loans = *loans + 1;\n+                    // data was created with `~~T as ~LocalData`, so we extract\n+                    // pointer part of the trait, (as ~~T), and then use\n+                    // compiler coercions to achieve a '&' pointer\n+                    match *cast::transmute::<&TLSValue, &(uint, ~~T)>(data) {\n+                        (_vtable, ref box) => {\n+                            let value: &T = **box;\n+                            ret = f(Some(value));\n+                        }\n                     }\n                 }\n-                *loans = *loans - 1;\n-                return ret;\n+                _ => libc::abort()\n             }\n-            _ => {}\n+\n+            // n.b. 'data' and 'loans' are both invalid pointers at the point\n+            // 'f' returned because `f` could have appended more TLS items which\n+            // in turn relocated the vector. Hence we do another lookup here to\n+            // fixup the loans.\n+            match map[i] {\n+                Some((_, _, ref mut loans)) => { *loans = *loans - 1; }\n+                None => { libc::abort(); }\n+            }\n+            return ret;\n         }\n     }\n-    return f(None);\n }\n \n pub unsafe fn local_set<T: 'static>(handle: Handle,"}]}