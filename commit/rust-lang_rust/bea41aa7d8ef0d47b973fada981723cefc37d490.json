{"sha": "bea41aa7d8ef0d47b973fada981723cefc37d490", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlYTQxYWE3ZDhlZjBkNDdiOTczZmFkYTk4MTcyM2NlZmMzN2Q0OTA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-26T02:01:44Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-26T02:02:19Z"}, "message": "rustc: Add a function to look up external item info in the item info table", "tree": {"sha": "4f2ec3579162b4a241fad5a154f7112e8cfbae1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f2ec3579162b4a241fad5a154f7112e8cfbae1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bea41aa7d8ef0d47b973fada981723cefc37d490", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bea41aa7d8ef0d47b973fada981723cefc37d490", "html_url": "https://github.com/rust-lang/rust/commit/bea41aa7d8ef0d47b973fada981723cefc37d490", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bea41aa7d8ef0d47b973fada981723cefc37d490/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "027368b885848377a0025ced2734cabf5ff201e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/027368b885848377a0025ced2734cabf5ff201e1", "html_url": "https://github.com/rust-lang/rust/commit/027368b885848377a0025ced2734cabf5ff201e1"}], "stats": {"total": 56, "additions": 52, "deletions": 4}, "files": [{"sha": "32d214611628a650b2bbd699aa5781a460d213c8", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bea41aa7d8ef0d47b973fada981723cefc37d490/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bea41aa7d8ef0d47b973fada981723cefc37d490/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=bea41aa7d8ef0d47b973fada981723cefc37d490", "patch": "@@ -309,7 +309,6 @@ impure fn resolve_path(vec[ast.ident] path, vec[u8] data) -> resolve_result {\n     auto ebml_r = ebml.create_reader(io_r);\n     while (ebml.bytes_left(ebml_r) > 0u) {\n         auto ebml_tag = ebml.peek(ebml_r);\n-        log #fmt(\"outer ebml tag id: %u\", ebml_tag.id);\n         if (ebml_tag.id == metadata.tag_paths) {\n             ebml.move_to_first_child(ebml_r);\n             ret resolve_path_inner(path, ebml_r);\n@@ -321,6 +320,57 @@ impure fn resolve_path(vec[ast.ident] path, vec[u8] data) -> resolve_result {\n     fail;\n }\n \n+impure fn move_to_item(&ebml.reader ebml_r, ast.def_id did) {\n+    while (ebml.bytes_left(ebml_r) > 0u) {\n+        auto outer_ebml_tag = ebml.peek(ebml_r);\n+        if (outer_ebml_tag.id == metadata.tag_items) {\n+            ebml.move_to_first_child(ebml_r);\n+\n+            while (ebml.bytes_left(ebml_r) > 0u) {\n+                auto inner_ebml_tag = ebml.peek(ebml_r);\n+                if (inner_ebml_tag.id == metadata.tag_items_item) {\n+                    ebml.move_to_first_child(ebml_r);\n+\n+                    while (ebml.bytes_left(ebml_r) > 0u) {\n+                        auto innermost_ebml_tag = ebml.peek(ebml_r);\n+                        if (innermost_ebml_tag.id ==\n+                                metadata.tag_items_def_id) {\n+                            ebml.move_to_first_child(ebml_r);\n+                            auto did_data = ebml.read_data(ebml_r);\n+                            ebml.move_to_parent(ebml_r);\n+\n+                            auto this_did = parse_def_id(did_data);\n+                            if (did._0 == this_did._0 &&\n+                                    did._1 == this_did._1) {\n+                                // Move to the start of this item's data.\n+                                ebml.move_to_parent(ebml_r);\n+                                ebml.move_to_first_child(ebml_r);\n+                                ret;\n+                            }\n+                        }\n+                        ebml.move_to_next_sibling(ebml_r);\n+                    }\n+                    ebml.move_to_parent(ebml_r);\n+                }\n+                ebml.move_to_next_sibling(ebml_r);\n+            }\n+            ebml.move_to_parent(ebml_r);\n+        }\n+        ebml.move_to_next_sibling(ebml_r);\n+    }\n+\n+    log #fmt(\"move_to_item: item not found: %d:%d\", did._0, did._1);\n+}\n+\n+impure fn get_item_kind(ast.def_id did, vec[u8] data) -> u8 {\n+    auto io_r = io.new_reader_(io.new_byte_buf_reader(data));\n+    auto ebml_r = ebml.create_reader(io_r);\n+    move_to_item(ebml_r, did);\n+\n+    log \"found item\";\n+    fail;\n+}\n+\n \n fn load_crate(session.session sess,\n               int cnum,\n@@ -407,10 +457,8 @@ fn lookup_def(session.session sess, &span sp, int cnum, vec[ast.ident] path)\n         }\n     }\n \n-    log #fmt(\"resolved '%s' to %d:%d\", _str.connect(path, \".\"), did._0,\n-             did._1);\n-\n     // TODO: Look up item type, use that to determine the type of def.\n+    auto kind_ch = get_item_kind(did, data);\n \n     fail;\n }"}]}