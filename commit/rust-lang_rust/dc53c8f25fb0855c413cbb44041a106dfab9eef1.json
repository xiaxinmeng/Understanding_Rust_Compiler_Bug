{"sha": "dc53c8f25fb0855c413cbb44041a106dfab9eef1", "node_id": "C_kwDOAAsO6NoAKGRjNTNjOGYyNWZiMDg1NWM0MTNjYmI0NDA0MWExMDZkZmFiOWVlZjE", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-10-27T14:32:17Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-10-27T14:41:26Z"}, "message": "Update tooling", "tree": {"sha": "0b648cb2f7f7fc99efeb8c64e7d0f6b91738cba2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b648cb2f7f7fc99efeb8c64e7d0f6b91738cba2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc53c8f25fb0855c413cbb44041a106dfab9eef1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc53c8f25fb0855c413cbb44041a106dfab9eef1", "html_url": "https://github.com/rust-lang/rust/commit/dc53c8f25fb0855c413cbb44041a106dfab9eef1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc53c8f25fb0855c413cbb44041a106dfab9eef1/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a17ccfa6211b978c502cdd6739bb1b58db0dbb03", "url": "https://api.github.com/repos/rust-lang/rust/commits/a17ccfa6211b978c502cdd6739bb1b58db0dbb03", "html_url": "https://github.com/rust-lang/rust/commit/a17ccfa6211b978c502cdd6739bb1b58db0dbb03"}], "stats": {"total": 236, "additions": 137, "deletions": 99}, "files": [{"sha": "1db44502742e921b4bcbbdff9d76bce7e1e5e849", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc53c8f25fb0855c413cbb44041a106dfab9eef1/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53c8f25fb0855c413cbb44041a106dfab9eef1/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=dc53c8f25fb0855c413cbb44041a106dfab9eef1", "patch": "@@ -770,11 +770,7 @@ fn codegen_stmt<'tcx>(\n                     lval.write_cvalue(fx, CValue::by_val(operand, box_layout));\n                 }\n                 Rvalue::NullaryOp(null_op, ty) => {\n-                    assert!(\n-                        lval.layout()\n-                            .ty\n-                            .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all())\n-                    );\n+                    assert!(lval.layout().ty.is_sized(fx.tcx, ParamEnv::reveal_all()));\n                     let layout = fx.layout_of(fx.monomorphize(ty));\n                     let val = match null_op {\n                         NullOp::SizeOf => layout.size.bytes(),"}, {"sha": "148b66d959e8a74126c5fdde83eb48f3a3de1290", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc53c8f25fb0855c413cbb44041a106dfab9eef1/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53c8f25fb0855c413cbb44041a106dfab9eef1/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=dc53c8f25fb0855c413cbb44041a106dfab9eef1", "patch": "@@ -5,7 +5,6 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n     read_target_uint, AllocId, ConstAllocation, ConstValue, ErrorHandled, GlobalAlloc, Scalar,\n };\n-use rustc_span::DUMMY_SP;\n \n use cranelift_module::*;\n \n@@ -291,7 +290,7 @@ fn data_id_for_static(\n     let is_mutable = if tcx.is_mutable_static(def_id) {\n         true\n     } else {\n-        !ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all())\n+        !ty.is_freeze(tcx, ParamEnv::reveal_all())\n     };\n     let align = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().align.pref.bytes();\n "}, {"sha": "764a6d3aa48cf4eb5d917a4ac46ad6386f143556", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=dc53c8f25fb0855c413cbb44041a106dfab9eef1", "patch": "@@ -148,7 +148,7 @@ where\n             })\n             .collect();\n         // We are only interested in case the type *doesn't* implement the Sized trait.\n-        if !ty.is_sized(tcx.at(rustc_span::DUMMY_SP), param_env) {\n+        if !ty.is_sized(tcx, param_env) {\n             // In case `#![no_core]` is used, `sized_trait` returns nothing.\n             if let Some(item) = tcx.lang_items().sized_trait().and_then(|sized_trait_did| {\n                 self.generate_for_trait(ty, sized_trait_did, param_env, item_def_id, &f, true)"}, {"sha": "b9509ca656f7a170117e115cf0a6cd47023eee80", "filename": "src/tools/clippy/clippy_lints/src/casts/ptr_as_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs?ref=dc53c8f25fb0855c413cbb44041a106dfab9eef1", "patch": "@@ -26,7 +26,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: Option<RustcVer\n             (Mutability::Not, Mutability::Not) | (Mutability::Mut, Mutability::Mut));\n         // The `U` in `pointer::cast` have to be `Sized`\n         // as explained here: https://github.com/rust-lang/rust/issues/60602.\n-        if to_pointee_ty.is_sized(cx.tcx.at(expr.span), cx.param_env);\n+        if to_pointee_ty.is_sized(cx.tcx, cx.param_env);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let cast_expr_sugg = Sugg::hir_with_applicability(cx, cast_expr, \"_\", &mut applicability);"}, {"sha": "769b22668e538398158783108db78626473e691d", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=dc53c8f25fb0855c413cbb44041a106dfab9eef1", "patch": "@@ -29,7 +29,7 @@ use rustc_middle::ty::{\n };\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n+use rustc_span::{symbol::sym, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::{query::evaluate_obligation::InferCtxtExt as _, Obligation, ObligationCause};\n use std::collections::VecDeque;\n@@ -990,7 +990,7 @@ fn binding_ty_auto_deref_stability<'tcx>(\n                                 cx.typeck_results().node_type(ty.ty.hir_id),\n                                 binder_args,\n                             ))\n-                            .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                            .is_sized(cx.tcx, cx.param_env.without_caller_bounds()),\n                     )\n                 }\n             },\n@@ -1005,7 +1005,7 @@ fn binding_ty_auto_deref_stability<'tcx>(\n                         cx.typeck_results().node_type(ty.ty.hir_id),\n                         binder_args,\n                     ))\n-                    .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                    .is_sized(cx.tcx, cx.param_env.without_caller_bounds()),\n             ),\n             TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(..) | TyKind::TraitObject(..) | TyKind::Err => {\n                 Position::ReborrowStable(precedence)\n@@ -1297,7 +1297,7 @@ impl<'tcx> TyPosition<'tcx> {\n     fn position_for_result(self, cx: &LateContext<'tcx>) -> Position {\n         match (self.position, self.ty) {\n             (Position::ReborrowStable(precedence), Some(ty)) => {\n-                Position::DerefStable(precedence, ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env))\n+                Position::DerefStable(precedence, ty.is_sized(cx.tcx, cx.param_env))\n             },\n             (position, _) => position,\n         }\n@@ -1348,7 +1348,7 @@ fn ty_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedenc\n             | ty::Tuple(_)\n             | ty::Projection(_) => Position::DerefStable(\n                 precedence,\n-                ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                ty.is_sized(cx.tcx, cx.param_env.without_caller_bounds()),\n             )\n             .into(),\n         };"}, {"sha": "922190a87d8c6dd1fbcec5a558bc2fe7fc06c59d", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=dc53c8f25fb0855c413cbb44041a106dfab9eef1", "patch": "@@ -188,7 +188,7 @@ fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &m\n         // primitive types are never mutable\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n         ty::Adt(adt, substs) => {\n-            tys.insert(adt.did()) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+            tys.insert(adt.did()) && !ty.is_freeze(cx.tcx, cx.param_env)\n                 || KNOWN_WRAPPER_TYS\n                     .iter()\n                     .any(|&sym| cx.tcx.is_diagnostic_item(sym, adt.did()))"}, {"sha": "db41bc67da1a7f34f1d57eef78db8d0c8f29b780", "filename": "src/tools/clippy/clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs?ref=dc53c8f25fb0855c413cbb44041a106dfab9eef1", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                     let span = stmt.span.to(if_.span);\n \n                     let has_interior_mutability = !cx.typeck_results().node_type(canonical_id).is_freeze(\n-                        cx.tcx.at(span),\n+                        cx.tcx,\n                         cx.param_env,\n                     );\n                     if has_interior_mutability { return; }"}, {"sha": "1d0744b631c6c062560a2640995f158fdd93527a", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=dc53c8f25fb0855c413cbb44041a106dfab9eef1", "patch": "@@ -136,12 +136,14 @@ fn check_ty<'tcx>(cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n /// [`Hash`] or [`Ord`].\n fn is_interior_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n     match *ty.kind() {\n-        Ref(_, inner_ty, mutbl) => mutbl == hir::Mutability::Mut || is_interior_mutable_type(cx, inner_ty, span),\n+        Ref(_, inner_ty, mutbl) => {\n+            mutbl == hir::Mutability::Mut || is_interior_mutable_type(cx, inner_ty, span)\n+        }\n         Slice(inner_ty) => is_interior_mutable_type(cx, inner_ty, span),\n         Array(inner_ty, size) => {\n             size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0)\n                 && is_interior_mutable_type(cx, inner_ty, span)\n-        },\n+        }\n         Tuple(fields) => fields.iter().any(|ty| is_interior_mutable_type(cx, ty, span)),\n         Adt(def, substs) => {\n             // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n@@ -167,9 +169,9 @@ fn is_interior_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Sp\n             } else {\n                 !ty.has_escaping_bound_vars()\n                     && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n-                    && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+                    && !ty.is_freeze(cx.tcx, cx.param_env)\n             }\n-        },\n+        }\n         _ => false,\n     }\n }"}, {"sha": "b2e9ce5c94d65db825d650b25e27505c93f48fc3", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=dc53c8f25fb0855c413cbb44041a106dfab9eef1", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::{self, TypeVisitable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::kw;\n-use rustc_span::{sym, Span, DUMMY_SP};\n+use rustc_span::{sym, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::misc::can_type_implement_copy;\n@@ -184,7 +184,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                 if !is_self(arg);\n                 if !ty.is_mutable_ptr();\n                 if !is_copy(cx, ty);\n-                if ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env);\n+                if ty.is_sized(cx.tcx, cx.param_env);\n                 if !allowed_traits.iter().any(|&t| implements_trait(cx, ty, t, &[]));\n                 if !implements_borrow_trait;\n                 if !all_borrowable_trait;"}, {"sha": "671c16953aed8e7299b9a70591f845bcbabf3b6e", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=dc53c8f25fb0855c413cbb44041a106dfab9eef1", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::mir::interpret::{ConstValue, ErrorHandled};\n use rustc_middle::ty::adjustment::Adjust;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{sym, InnerSpan, Span, DUMMY_SP};\n+use rustc_span::{sym, InnerSpan, Span};\n \n // FIXME: this is a correctness problem but there's no suitable\n // warn-by-default category.\n@@ -136,7 +136,7 @@ fn is_unfrozen<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     // since it works when a pointer indirection involves (`Cell<*const T>`).\n     // Making up a `ParamEnv` where every generic params and assoc types are `Freeze`is another option;\n     // but I'm not sure whether it's a decent way, if possible.\n-    cx.tcx.layout_of(cx.param_env.and(ty)).is_ok() && !ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env)\n+    cx.tcx.layout_of(cx.param_env.and(ty)).is_ok() && !ty.is_freeze(cx.tcx, cx.param_env)\n }\n \n fn is_value_unfrozen_raw<'tcx>("}, {"sha": "bb86fb3b7d42f43858db4b853f7fe3cbcb6ca8f6", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=dc53c8f25fb0855c413cbb44041a106dfab9eef1", "patch": "@@ -94,7 +94,7 @@ fn check_is_none_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr: &Ex\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let receiver_str = snippet_with_applicability(cx, caller.span, \"..\", &mut applicability);\n-            let by_ref = !caller_ty.is_copy_modulo_regions(cx.tcx.at(caller.span), cx.param_env) &&\n+            let by_ref = !caller_ty.is_copy_modulo_regions(cx.tcx, cx.param_env) &&\n                 !matches!(caller.kind, ExprKind::Call(..) | ExprKind::MethodCall(..));\n             let sugg = if let Some(else_inner) = r#else {\n                 if eq_expr_value(cx, caller, peel_blocks(else_inner)) {"}, {"sha": "3d4bbbf648c65bbfdc37ee89d0e8b4f412cb18e5", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 98, "deletions": 67, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=dc53c8f25fb0855c413cbb44041a106dfab9eef1", "patch": "@@ -5,7 +5,6 @@ use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::SubstsRef;\n use rustc_middle::ty::{self, IntTy, Ty, TypeAndMut, UintTy};\n-use rustc_span::DUMMY_SP;\n \n #[expect(clippy::too_many_lines)]\n pub(super) fn check<'tcx>(\n@@ -28,24 +27,32 @@ pub(super) fn check<'tcx>(\n \n             // `Repr(C)` <-> unordered type.\n             // If the first field of the `Repr(C)` type matches then the transmute is ok\n-            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::UnorderedFields(to_sub_ty))\n-            | (ReducedTy::UnorderedFields(from_sub_ty), ReducedTy::OrderedFields(_, Some(to_sub_ty))) => {\n+            (\n+                ReducedTy::OrderedFields(_, Some(from_sub_ty)),\n+                ReducedTy::UnorderedFields(to_sub_ty),\n+            )\n+            | (\n+                ReducedTy::UnorderedFields(from_sub_ty),\n+                ReducedTy::OrderedFields(_, Some(to_sub_ty)),\n+            ) => {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            },\n-            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::Other(to_sub_ty)) if reduced_tys.to_fat_ptr => {\n+            }\n+            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::Other(to_sub_ty))\n+                if reduced_tys.to_fat_ptr =>\n+            {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            },\n+            }\n             (ReducedTy::Other(from_sub_ty), ReducedTy::OrderedFields(_, Some(to_sub_ty)))\n                 if reduced_tys.from_fat_ptr =>\n             {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            },\n+            }\n \n             // ptr <-> ptr\n             (ReducedTy::Other(from_sub_ty), ReducedTy::Other(to_sub_ty))\n@@ -55,19 +62,19 @@ pub(super) fn check<'tcx>(\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            },\n+            }\n \n             // fat ptr <-> (*size, *size)\n             (ReducedTy::Other(_), ReducedTy::UnorderedFields(to_ty))\n                 if reduced_tys.from_fat_ptr && is_size_pair(to_ty) =>\n             {\n                 return false;\n-            },\n+            }\n             (ReducedTy::UnorderedFields(from_ty), ReducedTy::Other(_))\n                 if reduced_tys.to_fat_ptr && is_size_pair(from_ty) =>\n             {\n                 return false;\n-            },\n+            }\n \n             // fat ptr -> some struct | some struct -> fat ptr\n             (ReducedTy::Other(_), _) if reduced_tys.from_fat_ptr => {\n@@ -78,12 +85,14 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute from `{from_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if from_ty_orig.peel_refs() != from_ty.peel_refs() {\n-                            diag.note(&format!(\"the contained type `{from_ty}` has an undefined layout\"));\n+                            diag.note(&format!(\n+                                \"the contained type `{from_ty}` has an undefined layout\"\n+                            ));\n                         }\n                     },\n                 );\n                 return true;\n-            },\n+            }\n             (_, ReducedTy::Other(_)) if reduced_tys.to_fat_ptr => {\n                 span_lint_and_then(\n                     cx,\n@@ -92,14 +101,18 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute to `{to_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if to_ty_orig.peel_refs() != to_ty.peel_refs() {\n-                            diag.note(&format!(\"the contained type `{to_ty}` has an undefined layout\"));\n+                            diag.note(&format!(\n+                                \"the contained type `{to_ty}` has an undefined layout\"\n+                            ));\n                         }\n                     },\n                 );\n                 return true;\n-            },\n+            }\n \n-            (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty)) if from_ty != to_ty => {\n+            (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty))\n+                if from_ty != to_ty =>\n+            {\n                 let same_adt_did = if let (ty::Adt(from_def, from_subs), ty::Adt(to_def, to_subs))\n                         = (from_ty.kind(), to_ty.kind())\n                         && from_def == to_def\n@@ -126,19 +139,25 @@ pub(super) fn check<'tcx>(\n                             ));\n                         } else {\n                             if from_ty_orig.peel_refs() != from_ty {\n-                                diag.note(&format!(\"the contained type `{from_ty}` has an undefined layout\"));\n+                                diag.note(&format!(\n+                                    \"the contained type `{from_ty}` has an undefined layout\"\n+                                ));\n                             }\n                             if to_ty_orig.peel_refs() != to_ty {\n-                                diag.note(&format!(\"the contained type `{to_ty}` has an undefined layout\"));\n+                                diag.note(&format!(\n+                                    \"the contained type `{to_ty}` has an undefined layout\"\n+                                ));\n                             }\n                         }\n                     },\n                 );\n                 return true;\n-            },\n+            }\n             (\n                 ReducedTy::UnorderedFields(from_ty),\n-                ReducedTy::Other(_) | ReducedTy::OrderedFields(..) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::Other(_)\n+                | ReducedTy::OrderedFields(..)\n+                | ReducedTy::TypeErasure { raw_ptr_only: true },\n             ) => {\n                 span_lint_and_then(\n                     cx,\n@@ -147,14 +166,18 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute from `{from_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if from_ty_orig.peel_refs() != from_ty {\n-                            diag.note(&format!(\"the contained type `{from_ty}` has an undefined layout\"));\n+                            diag.note(&format!(\n+                                \"the contained type `{from_ty}` has an undefined layout\"\n+                            ));\n                         }\n                     },\n                 );\n                 return true;\n-            },\n+            }\n             (\n-                ReducedTy::Other(_) | ReducedTy::OrderedFields(..) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::Other(_)\n+                | ReducedTy::OrderedFields(..)\n+                | ReducedTy::TypeErasure { raw_ptr_only: true },\n                 ReducedTy::UnorderedFields(to_ty),\n             ) => {\n                 span_lint_and_then(\n@@ -164,19 +187,25 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute into `{to_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if to_ty_orig.peel_refs() != to_ty {\n-                            diag.note(&format!(\"the contained type `{to_ty}` has an undefined layout\"));\n+                            diag.note(&format!(\n+                                \"the contained type `{to_ty}` has an undefined layout\"\n+                            ));\n                         }\n                     },\n                 );\n                 return true;\n-            },\n+            }\n             (\n-                ReducedTy::OrderedFields(..) | ReducedTy::Other(_) | ReducedTy::TypeErasure { raw_ptr_only: true },\n-                ReducedTy::OrderedFields(..) | ReducedTy::Other(_) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::OrderedFields(..)\n+                | ReducedTy::Other(_)\n+                | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::OrderedFields(..)\n+                | ReducedTy::Other(_)\n+                | ReducedTy::TypeErasure { raw_ptr_only: true },\n             )\n             | (ReducedTy::UnorderedFields(_), ReducedTy::UnorderedFields(_)) => {\n                 break;\n-            },\n+            }\n         }\n     }\n \n@@ -194,42 +223,38 @@ struct ReducedTys<'tcx> {\n }\n \n /// Remove references so long as both types are references.\n-fn reduce_refs<'tcx>(cx: &LateContext<'tcx>, mut from_ty: Ty<'tcx>, mut to_ty: Ty<'tcx>) -> ReducedTys<'tcx> {\n+fn reduce_refs<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    mut from_ty: Ty<'tcx>,\n+    mut to_ty: Ty<'tcx>,\n+) -> ReducedTys<'tcx> {\n     let mut from_raw_ptr = false;\n     let mut to_raw_ptr = false;\n-    let (from_fat_ptr, to_fat_ptr) = loop {\n-        break match (from_ty.kind(), to_ty.kind()) {\n-            (\n-                &(ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. })),\n-                &(ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. })),\n-            ) => {\n-                from_raw_ptr = matches!(*from_ty.kind(), ty::RawPtr(_));\n-                from_ty = from_sub_ty;\n-                to_raw_ptr = matches!(*to_ty.kind(), ty::RawPtr(_));\n-                to_ty = to_sub_ty;\n-                continue;\n-            },\n-            (&(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })), _)\n-                if !unsized_ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env) =>\n-            {\n-                (true, false)\n-            },\n-            (_, &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })))\n-                if !unsized_ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env) =>\n-            {\n-                (false, true)\n-            },\n-            _ => (false, false),\n+    let (from_fat_ptr, to_fat_ptr) =\n+        loop {\n+            break match (from_ty.kind(), to_ty.kind()) {\n+                (\n+                    &(ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. })),\n+                    &(ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. })),\n+                ) => {\n+                    from_raw_ptr = matches!(*from_ty.kind(), ty::RawPtr(_));\n+                    from_ty = from_sub_ty;\n+                    to_raw_ptr = matches!(*to_ty.kind(), ty::RawPtr(_));\n+                    to_ty = to_sub_ty;\n+                    continue;\n+                }\n+                (\n+                    &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })),\n+                    _,\n+                ) if !unsized_ty.is_sized(cx.tcx, cx.param_env) => (true, false),\n+                (\n+                    _,\n+                    &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })),\n+                ) if !unsized_ty.is_sized(cx.tcx, cx.param_env) => (false, true),\n+                _ => (false, false),\n+            };\n         };\n-    };\n-    ReducedTys {\n-        from_ty,\n-        to_ty,\n-        from_raw_ptr,\n-        to_raw_ptr,\n-        from_fat_ptr,\n-        to_fat_ptr,\n-    }\n+    ReducedTys { from_ty, to_ty, from_raw_ptr, to_raw_ptr, from_fat_ptr, to_fat_ptr }\n }\n \n enum ReducedTy<'tcx> {\n@@ -252,11 +277,11 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n         return match *ty.kind() {\n             ty::Array(sub_ty, _) if matches!(sub_ty.kind(), ty::Int(_) | ty::Uint(_)) => {\n                 ReducedTy::TypeErasure { raw_ptr_only: false }\n-            },\n+            }\n             ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n                 ty = sub_ty;\n                 continue;\n-            },\n+            }\n             ty::Tuple(args) if args.is_empty() => ReducedTy::TypeErasure { raw_ptr_only: false },\n             ty::Tuple(args) => {\n                 let mut iter = args.iter();\n@@ -268,7 +293,7 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                     continue;\n                 }\n                 ReducedTy::UnorderedFields(ty)\n-            },\n+            }\n             ty::Adt(def, substs) if def.is_struct() => {\n                 let mut iter = def\n                     .non_enum_variant()\n@@ -287,10 +312,12 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                 } else {\n                     ReducedTy::UnorderedFields(ty)\n                 }\n-            },\n-            ty::Adt(def, _) if def.is_enum() && (def.variants().is_empty() || is_c_void(cx, ty)) => {\n+            }\n+            ty::Adt(def, _)\n+                if def.is_enum() && (def.variants().is_empty() || is_c_void(cx, ty)) =>\n+            {\n                 ReducedTy::TypeErasure { raw_ptr_only: false }\n-            },\n+            }\n             // TODO: Check if the conversion to or from at least one of a union's fields is valid.\n             ty::Adt(def, _) if def.is_union() => ReducedTy::TypeErasure { raw_ptr_only: false },\n             ty::Foreign(_) | ty::Param(_) => ReducedTy::TypeErasure { raw_ptr_only: false },\n@@ -329,7 +356,11 @@ fn same_except_params<'tcx>(subs1: SubstsRef<'tcx>, subs2: SubstsRef<'tcx>) -> b\n     for (ty1, ty2) in subs1.types().zip(subs2.types()).filter(|(ty1, ty2)| ty1 != ty2) {\n         match (ty1.kind(), ty2.kind()) {\n             (ty::Param(_), _) | (_, ty::Param(_)) => (),\n-            (ty::Adt(adt1, subs1), ty::Adt(adt2, subs2)) if adt1 == adt2 && same_except_params(subs1, subs2) => (),\n+            (ty::Adt(adt1, subs1), ty::Adt(adt2, subs2))\n+                if adt1 == adt2 && same_except_params(subs1, subs2) =>\n+            {\n+                ()\n+            }\n             _ => return false,\n         }\n     }"}, {"sha": "2b964b64a3305d702ea51f8684316d61fc758738", "filename": "src/tools/clippy/clippy_lints/src/types/redundant_allocation.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs?ref=dc53c8f25fb0855c413cbb44041a106dfab9eef1", "patch": "@@ -9,7 +9,12 @@ use rustc_span::symbol::sym;\n \n use super::{utils, REDUNDANT_ALLOCATION};\n \n-pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    hir_ty: &hir::Ty<'_>,\n+    qpath: &QPath<'_>,\n+    def_id: DefId,\n+) -> bool {\n     let mut applicability = Applicability::MaybeIncorrect;\n     let outer_sym = if Some(def_id) == cx.tcx.lang_items().owned_box() {\n         \"Box\"\n@@ -29,7 +34,12 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n             hir_ty.span,\n             &format!(\"usage of `{outer_sym}<{generic_snippet}>`\"),\n             |diag| {\n-                diag.span_suggestion(hir_ty.span, \"try\", format!(\"{generic_snippet}\"), applicability);\n+                diag.span_suggestion(\n+                    hir_ty.span,\n+                    \"try\",\n+                    format!(\"{generic_snippet}\"),\n+                    applicability,\n+                );\n                 diag.note(&format!(\n                     \"`{generic_snippet}` is already a pointer, `{outer_sym}<{generic_snippet}>` allocates a pointer on the heap\"\n                 ));\n@@ -55,11 +65,11 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n             // Reallocation of a fat pointer causes it to become thin. `hir_ty_to_ty` is safe to use\n             // here because `mod.rs` guarantees this lint is only run on types outside of bodies and\n             // is not run on locals.\n-            if !hir_ty_to_ty(cx.tcx, ty).is_sized(cx.tcx.at(ty.span), cx.param_env) {\n+            if !hir_ty_to_ty(cx.tcx, ty).is_sized(cx.tcx, cx.param_env) {\n                 return false;\n             }\n             ty.span\n-        },\n+        }\n         None => return false,\n     };\n     if inner_sym == outer_sym {"}, {"sha": "9ad2cb853d39a474255c0256dd2e30e5ce778ecf", "filename": "src/tools/clippy/clippy_lints/src/types/vec_box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs?ref=dc53c8f25fb0855c413cbb44041a106dfab9eef1", "patch": "@@ -40,7 +40,7 @@ pub(super) fn check(\n             });\n             let ty_ty = hir_ty_to_ty(cx.tcx, boxed_ty);\n             if !ty_ty.has_escaping_bound_vars();\n-            if ty_ty.is_sized(cx.tcx.at(ty.span), cx.param_env);\n+            if ty_ty.is_sized(cx.tcx, cx.param_env);\n             if let Ok(ty_ty_size) = cx.layout_of(ty_ty).map(|l| l.size.bytes());\n             if ty_ty_size <= box_size_threshold;\n             then {"}, {"sha": "4e024ce4017932c2948c7095f510b4c594ee85cc", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53c8f25fb0855c413cbb44041a106dfab9eef1/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=dc53c8f25fb0855c413cbb44041a106dfab9eef1", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::ty::{\n };\n use rustc_middle::ty::{GenericArg, GenericArgKind};\n use rustc_span::symbol::Ident;\n-use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n+use rustc_span::{sym, Span, Symbol};\n use rustc_target::abi::{Size, VariantIdx};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n@@ -28,7 +28,7 @@ use crate::{match_def_path, path_res, paths};\n \n // Checks if the given type implements copy.\n pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_copy_modulo_regions(cx.tcx.at(DUMMY_SP), cx.param_env)\n+    ty.is_copy_modulo_regions(cx.tcx, cx.param_env)\n }\n \n /// This checks whether a given type is known to implement Debug."}]}