{"sha": "8849273efb890e767d7bfa610f6e5040583a6545", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NDkyNzNlZmI4OTBlNzY3ZDdiZmE2MTBmNmU1MDQwNTgzYTY1NDU=", "commit": {"author": {"name": "Ruben Schmidmeister", "email": "ruben.schmidmeister@icloud.com", "date": "2019-04-24T17:45:11Z"}, "committer": {"name": "Ruben Schmidmeister", "email": "ruben.schmidmeister@icloud.com", "date": "2019-04-24T19:01:09Z"}, "message": "Convert to free standing functions", "tree": {"sha": "1223e7a9e245121f3497b5126e4cba9c29fa3c75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1223e7a9e245121f3497b5126e4cba9c29fa3c75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8849273efb890e767d7bfa610f6e5040583a6545", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEEU0FXzFYkrmfOhhqxKTh7Wnqvhj8FAlzAsnUACgkQKTh7Wnqv\nhj+p/Af9EJ65l/l+vlsf9/tVHQWf8vwd3ScLVxgTcQpjue3GI25XG2oywzheRlkw\nyUF+r/kxxhrE2vMS5a+WopS8SGoSkVX/mVmUO/9JIZ4hSRRmWn/kYLZF3FTQKZ96\nUvTr/Zk4/3XdbGej4WqNIWBJEwj6brLwX+v+2jFYJL6uFjAEb5yqWAMVHsWIlaCD\nuRQKtmyAGb+84Y52JkaX0mnKGo2zaD9oWAbBRFBI+f7VJpsUtN7eyocdNTsnVSaf\nriGqbjwkutvLwZrVp1ss1DbaxgMullVtd0eIHo+XH9u+u6/Lkti0qIKkntr8AbGG\nYG/+F+YsbAW542SyolZwHOtoE9swvA==\n=mdij\n-----END PGP SIGNATURE-----", "payload": "tree 1223e7a9e245121f3497b5126e4cba9c29fa3c75\nparent ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a\nauthor Ruben Schmidmeister <ruben.schmidmeister@icloud.com> 1556127911 +0200\ncommitter Ruben Schmidmeister <ruben.schmidmeister@icloud.com> 1556132469 +0200\n\nConvert to free standing functions\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8849273efb890e767d7bfa610f6e5040583a6545", "html_url": "https://github.com/rust-lang/rust/commit/8849273efb890e767d7bfa610f6e5040583a6545", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8849273efb890e767d7bfa610f6e5040583a6545/comments", "author": {"login": "bash", "id": 4602612, "node_id": "MDQ6VXNlcjQ2MDI2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/4602612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bash", "html_url": "https://github.com/bash", "followers_url": "https://api.github.com/users/bash/followers", "following_url": "https://api.github.com/users/bash/following{/other_user}", "gists_url": "https://api.github.com/users/bash/gists{/gist_id}", "starred_url": "https://api.github.com/users/bash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bash/subscriptions", "organizations_url": "https://api.github.com/users/bash/orgs", "repos_url": "https://api.github.com/users/bash/repos", "events_url": "https://api.github.com/users/bash/events{/privacy}", "received_events_url": "https://api.github.com/users/bash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bash", "id": 4602612, "node_id": "MDQ6VXNlcjQ2MDI2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/4602612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bash", "html_url": "https://github.com/bash", "followers_url": "https://api.github.com/users/bash/followers", "following_url": "https://api.github.com/users/bash/following{/other_user}", "gists_url": "https://api.github.com/users/bash/gists{/gist_id}", "starred_url": "https://api.github.com/users/bash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bash/subscriptions", "organizations_url": "https://api.github.com/users/bash/orgs", "repos_url": "https://api.github.com/users/bash/repos", "events_url": "https://api.github.com/users/bash/events{/privacy}", "received_events_url": "https://api.github.com/users/bash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a", "html_url": "https://github.com/rust-lang/rust/commit/ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a"}], "stats": {"total": 112, "additions": 59, "deletions": 53}, "files": [{"sha": "3ae73ea1c990dd67a7e7cfb4f28d06395c69e9ee", "filename": "src/formatting.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8849273efb890e767d7bfa610f6e5040583a6545/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8849273efb890e767d7bfa610f6e5040583a6545/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=8849273efb890e767d7bfa610f6e5040583a6545", "patch": "@@ -12,6 +12,7 @@ use syntax::errors::{DiagnosticBuilder, Handler};\n use syntax::parse::{self, ParseSess};\n use syntax::source_map::{FilePathMapping, SourceMap, Span, DUMMY_SP};\n \n+use self::newline_style::apply_newline_style;\n use crate::comment::{CharClasses, FullCodeCharKind};\n use crate::config::{Config, FileName, Verbosity};\n use crate::ignore_path::IgnorePathSet;\n@@ -193,9 +194,12 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n             &self.config,\n             &self.report,\n         );\n-        self.config\n-            .newline_style()\n-            .apply(&mut visitor.buffer, &big_snippet);\n+\n+        apply_newline_style(\n+            self.config.newline_style(),\n+            &mut visitor.buffer,\n+            &big_snippet,\n+        );\n \n         if visitor.macro_rewrite_failure {\n             self.report.add_macro_format_failure();"}, {"sha": "91d8466bb9dc731d75582c5eb77e24e90f9ec043", "filename": "src/formatting/newline_style.rs", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/8849273efb890e767d7bfa610f6e5040583a6545/src%2Fformatting%2Fnewline_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8849273efb890e767d7bfa610f6e5040583a6545/src%2Fformatting%2Fnewline_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting%2Fnewline_style.rs?ref=8849273efb890e767d7bfa610f6e5040583a6545", "patch": "@@ -1,58 +1,60 @@\n use crate::NewlineStyle;\n \n-impl NewlineStyle {\n-    fn auto_detect(raw_input_text: &str) -> NewlineStyle {\n-        if let Some(pos) = raw_input_text.find('\\n') {\n-            let pos = pos.saturating_sub(1);\n-            if let Some('\\r') = raw_input_text.chars().nth(pos) {\n-                NewlineStyle::Windows\n-            } else {\n-                NewlineStyle::Unix\n+/// Apply this newline style to the formatted text. When the style is set\n+/// to `Auto`, the `raw_input_text` is used to detect the existing line\n+/// endings.\n+///\n+/// If the style is set to `Auto` and `raw_input_text` contains no\n+/// newlines, the `Native` style will be used.\n+pub(crate) fn apply_newline_style(\n+    newline_style: NewlineStyle,\n+    formatted_text: &mut String,\n+    raw_input_text: &str,\n+) {\n+    use crate::NewlineStyle::*;\n+    let mut style = newline_style;\n+    if style == Auto {\n+        style = auto_detect_newline_style(raw_input_text);\n+    }\n+    if style == Native {\n+        style = native();\n+    }\n+    match style {\n+        Windows => {\n+            let mut transformed = String::with_capacity(2 * formatted_text.capacity());\n+            for c in formatted_text.chars() {\n+                match c {\n+                    '\\n' => transformed.push_str(\"\\r\\n\"),\n+                    '\\r' => continue,\n+                    c => transformed.push(c),\n+                }\n             }\n-        } else {\n-            NewlineStyle::Native\n+            *formatted_text = transformed;\n         }\n+        Unix => return,\n+        Native => unreachable!(\"NewlineStyle::Native\"),\n+        Auto => unreachable!(\"NewlineStyle::Auto\"),\n     }\n+}\n \n-    fn native() -> NewlineStyle {\n-        if cfg!(windows) {\n+fn auto_detect_newline_style(raw_input_text: &str) -> NewlineStyle {\n+    if let Some(pos) = raw_input_text.find('\\n') {\n+        let pos = pos.saturating_sub(1);\n+        if let Some('\\r') = raw_input_text.chars().nth(pos) {\n             NewlineStyle::Windows\n         } else {\n             NewlineStyle::Unix\n         }\n+    } else {\n+        NewlineStyle::Native\n     }\n+}\n \n-    /// Apply this newline style to the formatted text. When the style is set\n-    /// to `Auto`, the `raw_input_text` is used to detect the existing line\n-    /// endings.\n-    ///\n-    /// If the style is set to `Auto` and `raw_input_text` contains no\n-    /// newlines, the `Native` style will be used.\n-    pub(crate) fn apply(self, formatted_text: &mut String, raw_input_text: &str) {\n-        use crate::NewlineStyle::*;\n-        let mut style = self;\n-        if style == Auto {\n-            style = Self::auto_detect(raw_input_text);\n-        }\n-        if style == Native {\n-            style = Self::native();\n-        }\n-        match style {\n-            Windows => {\n-                let mut transformed = String::with_capacity(2 * formatted_text.capacity());\n-                for c in formatted_text.chars() {\n-                    match c {\n-                        '\\n' => transformed.push_str(\"\\r\\n\"),\n-                        '\\r' => continue,\n-                        c => transformed.push(c),\n-                    }\n-                }\n-                *formatted_text = transformed;\n-            }\n-            Unix => return,\n-            Native => unreachable!(\"NewlineStyle::Native\"),\n-            Auto => unreachable!(\"NewlineStyle::Auto\"),\n-        }\n+fn native() -> NewlineStyle {\n+    if cfg!(windows) {\n+        NewlineStyle::Windows\n+    } else {\n+        NewlineStyle::Unix\n     }\n }\n \n@@ -66,9 +68,9 @@ mod tests {\n         let crlf = \"One\\r\\nTwo\\r\\nThree\";\n         let none = \"One Two Three\";\n \n-        assert_eq!(NewlineStyle::Unix, NewlineStyle::auto_detect(lf));\n-        assert_eq!(NewlineStyle::Windows, NewlineStyle::auto_detect(crlf));\n-        assert_eq!(NewlineStyle::Native, NewlineStyle::auto_detect(none));\n+        assert_eq!(NewlineStyle::Unix, auto_detect_newline_style(lf));\n+        assert_eq!(NewlineStyle::Windows, auto_detect_newline_style(crlf));\n+        assert_eq!(NewlineStyle::Native, auto_detect_newline_style(none));\n     }\n \n     #[test]\n@@ -79,14 +81,14 @@ mod tests {\n         let raw_input_text = \"One\\nTwo\\nThree\";\n \n         let mut out = String::from(formatted_text);\n-        auto.apply(&mut out, raw_input_text);\n+        apply_newline_style(auto, &mut out, raw_input_text);\n         assert_eq!(\"One\\nTwo\\nThree\", &out, \"auto should detect 'lf'\");\n \n         let formatted_text = \"One\\nTwo\\nThree\";\n         let raw_input_text = \"One\\r\\nTwo\\r\\nThree\";\n \n         let mut out = String::from(formatted_text);\n-        auto.apply(&mut out, raw_input_text);\n+        apply_newline_style(auto, &mut out, raw_input_text);\n         assert_eq!(\"One\\r\\nTwo\\r\\nThree\", &out, \"auto should detect 'crlf'\");\n \n         #[cfg(not(windows))]\n@@ -95,7 +97,7 @@ mod tests {\n             let raw_input_text = \"One Two Three\";\n \n             let mut out = String::from(formatted_text);\n-            auto.apply(&mut out, raw_input_text);\n+            apply_newline_style(auto, &mut out, raw_input_text);\n             assert_eq!(\n                 \"One\\nTwo\\nThree\", &out,\n                 \"auto-native-unix should detect 'lf'\"\n@@ -108,7 +110,7 @@ mod tests {\n             let raw_input_text = \"One Two Three\";\n \n             let mut out = String::from(formatted_text);\n-            auto.apply(&mut out, raw_input_text);\n+            apply_newline_style(auto, &mut out, raw_input_text);\n             assert_eq!(\n                 \"One\\r\\nTwo\\r\\nThree\", &out,\n                 \"auto-native-windows should detect 'crlf'\""}]}