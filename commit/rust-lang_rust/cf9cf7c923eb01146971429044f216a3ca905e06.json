{"sha": "cf9cf7c923eb01146971429044f216a3ca905e06", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmOWNmN2M5MjNlYjAxMTQ2OTcxNDI5MDQ0ZjIxNmEzY2E5MDVlMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-10T10:43:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-10T10:43:14Z"}, "message": "Auto merge of #78904 - Dylan-DPC:rollup-8d2w3vu, r=Dylan-DPC\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #74754 (Add `#[cfg(panic = '...')]`)\n - #76468 (Improve lifetime name annotations for closures & async functions)\n - #77016 (Test clippy on PR CI on changes)\n - #78480 (BTreeMap: fix pointer provenance rules)\n - #78502 (Update Chalk to 0.36.0)\n - #78513 (Infer the default host target from the host toolchain if possible)\n - #78566 (Enable LLVM Polly via llvm-args.)\n - #78580 (inliner: Break inlining cycles)\n - #78710 (rustc_ast: Do not panic by default when visiting macro calls)\n - #78746 (Demote i686-unknown-freebsd to tier 2 compiler target)\n - #78830 (fix `super_visit_with` for `Terminator`)\n - #78844 (Monomorphize a type argument of size-of operation during codegen)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "3c062e157444df6991fc582cf36b48a8d83b7e2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c062e157444df6991fc582cf36b48a8d83b7e2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf9cf7c923eb01146971429044f216a3ca905e06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf9cf7c923eb01146971429044f216a3ca905e06", "html_url": "https://github.com/rust-lang/rust/commit/cf9cf7c923eb01146971429044f216a3ca905e06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf9cf7c923eb01146971429044f216a3ca905e06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25f6938da459a57b43bdf16ed6bdad3225b2a3ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/25f6938da459a57b43bdf16ed6bdad3225b2a3ce", "html_url": "https://github.com/rust-lang/rust/commit/25f6938da459a57b43bdf16ed6bdad3225b2a3ce"}, {"sha": "c150b933ac73a7a1102f1ee934e8f94bfe73be63", "url": "https://api.github.com/repos/rust-lang/rust/commits/c150b933ac73a7a1102f1ee934e8f94bfe73be63", "html_url": "https://github.com/rust-lang/rust/commit/c150b933ac73a7a1102f1ee934e8f94bfe73be63"}], "stats": {"total": 2400, "additions": 1465, "deletions": 935}, "files": [{"sha": "84e39a4189eb4792b99db7e1e92bf476c038f468", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -183,9 +183,6 @@ jobs:\n           - name: dist-i586-gnu-i586-i686-musl\n             os: ubuntu-latest-xl\n             env: {}\n-          - name: dist-i686-freebsd\n-            os: ubuntu-latest-xl\n-            env: {}\n           - name: dist-i686-linux\n             os: ubuntu-latest-xl\n             env: {}"}, {"sha": "45a19fd79634e68747f18d72d0d39ea5d5136ca9", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -460,9 +460,9 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.32.0\"\n+version = \"0.36.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2d072b2ba723f0bada7c515d8b3725224bc4f5052d2a92dcbeb0b118ff37084a\"\n+checksum = \"9f88ce4deae1dace71e49b7611cfae2d5489de3530d6daba5758043c47ac3a10\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -472,9 +472,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-engine\"\n-version = \"0.32.0\"\n+version = \"0.36.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6fb5475f6083d6d6c509e1c335c4f69ad04144ac090faa1afb134a53c3695841\"\n+checksum = \"0e34c9b1b10616782143d7f49490f91ae94afaf2202de3ab0b2835e78b4f0ccc\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -485,19 +485,19 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.32.0\"\n+version = \"0.36.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f60cdb0e18c5455cb6a85e8464aad3622b70476018edfa8845691df66f7e9a05\"\n+checksum = \"63362c629c2014ab639b04029070763fb8224df136d1363d30e9ece4c8877da3\"\n dependencies = [\n  \"chalk-derive\",\n  \"lazy_static\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.32.0\"\n+version = \"0.36.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"981534d499a8476ecc0b520be4d3864757f96211826a75360fbf2cb6fae362ab\"\n+checksum = \"cac338a67af52a7f50bb2f8232e730a3518ce432dbe303246acfe525ddd838c7\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\","}, {"sha": "7b85d28568bd3fb1969e585d5b2f6a81eb31b2b2", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -210,11 +210,8 @@ pub trait MutVisitor: Sized {\n         noop_visit_local(l, self);\n     }\n \n-    fn visit_mac(&mut self, _mac: &mut MacCall) {\n-        panic!(\"visit_mac disabled by default\");\n-        // N.B., see note about macros above. If you really want a visitor that\n-        // works on macros, use this definition in your trait impl:\n-        //   mut_visit::noop_visit_mac(_mac, self);\n+    fn visit_mac_call(&mut self, mac: &mut MacCall) {\n+        noop_visit_mac(mac, self);\n     }\n \n     fn visit_macro_def(&mut self, def: &mut MacroDef) {\n@@ -494,7 +491,7 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n             vis.visit_id(id);\n             visit_vec(bounds, |bound| vis.visit_param_bound(bound));\n         }\n-        TyKind::MacCall(mac) => vis.visit_mac(mac),\n+        TyKind::MacCall(mac) => vis.visit_mac_call(mac),\n     }\n     vis.visit_span(span);\n     visit_lazy_tts(tokens, vis);\n@@ -962,7 +959,7 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n             vis.visit_generics(generics);\n             visit_bounds(bounds, vis);\n         }\n-        ItemKind::MacCall(m) => vis.visit_mac(m),\n+        ItemKind::MacCall(m) => vis.visit_mac_call(m),\n         ItemKind::MacroDef(def) => vis.visit_macro_def(def),\n     }\n }\n@@ -991,7 +988,7 @@ pub fn noop_flat_map_assoc_item<T: MutVisitor>(\n             visit_bounds(bounds, visitor);\n             visit_opt(ty, |ty| visitor.visit_ty(ty));\n         }\n-        AssocItemKind::MacCall(mac) => visitor.visit_mac(mac),\n+        AssocItemKind::MacCall(mac) => visitor.visit_mac_call(mac),\n     }\n     visitor.visit_span(span);\n     visit_lazy_tts(tokens, visitor);\n@@ -1081,7 +1078,7 @@ pub fn noop_flat_map_foreign_item<T: MutVisitor>(\n             visit_bounds(bounds, visitor);\n             visit_opt(ty, |ty| visitor.visit_ty(ty));\n         }\n-        ForeignItemKind::MacCall(mac) => visitor.visit_mac(mac),\n+        ForeignItemKind::MacCall(mac) => visitor.visit_mac_call(mac),\n     }\n     visitor.visit_span(span);\n     visit_lazy_tts(tokens, visitor);\n@@ -1121,7 +1118,7 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n             visit_vec(elems, |elem| vis.visit_pat(elem))\n         }\n         PatKind::Paren(inner) => vis.visit_pat(inner),\n-        PatKind::MacCall(mac) => vis.visit_mac(mac),\n+        PatKind::MacCall(mac) => vis.visit_mac_call(mac),\n     }\n     vis.visit_span(span);\n     visit_lazy_tts(tokens, vis);\n@@ -1287,7 +1284,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             }\n             visit_vec(inputs, |(_c, expr)| vis.visit_expr(expr));\n         }\n-        ExprKind::MacCall(mac) => vis.visit_mac(mac),\n+        ExprKind::MacCall(mac) => vis.visit_mac_call(mac),\n         ExprKind::Struct(path, fields, expr) => {\n             vis.visit_path(path);\n             fields.flat_map_in_place(|field| vis.flat_map_field(field));\n@@ -1350,7 +1347,7 @@ pub fn noop_flat_map_stmt_kind<T: MutVisitor>(\n         StmtKind::Empty => smallvec![StmtKind::Empty],\n         StmtKind::MacCall(mut mac) => {\n             let MacCallStmt { mac: mac_, style: _, attrs } = mac.deref_mut();\n-            vis.visit_mac(mac_);\n+            vis.visit_mac_call(mac_);\n             visit_thin_attrs(attrs, vis);\n             smallvec![StmtKind::MacCall(mac)]\n         }"}, {"sha": "8751f09cfcbbe1bb785344c622de967263ff8ab3", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -176,13 +176,8 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n-    fn visit_mac(&mut self, _mac: &'ast MacCall) {\n-        panic!(\"visit_mac disabled by default\");\n-        // N.B., see note about macros above.\n-        // if you really want a visitor that\n-        // works on macros, use this\n-        // definition in your trait impl:\n-        // visit::walk_mac(self, _mac)\n+    fn visit_mac_call(&mut self, mac: &'ast MacCall) {\n+        walk_mac(self, mac)\n     }\n     fn visit_mac_def(&mut self, _mac: &'ast MacroDef, _id: NodeId) {\n         // Nothing to do\n@@ -346,7 +341,7 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n-        ItemKind::MacCall(ref mac) => visitor.visit_mac(mac),\n+        ItemKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n         ItemKind::MacroDef(ref ts) => visitor.visit_mac_def(ts, item.id),\n     }\n     walk_list!(visitor, visit_attribute, &item.attrs);\n@@ -414,7 +409,7 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n         }\n         TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n         TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err => {}\n-        TyKind::MacCall(ref mac) => visitor.visit_mac(mac),\n+        TyKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n         TyKind::Never | TyKind::CVarArgs => {}\n     }\n }\n@@ -532,7 +527,7 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n         PatKind::Tuple(ref elems) | PatKind::Slice(ref elems) | PatKind::Or(ref elems) => {\n             walk_list!(visitor, visit_pat, elems);\n         }\n-        PatKind::MacCall(ref mac) => visitor.visit_mac(mac),\n+        PatKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n     }\n }\n \n@@ -557,7 +552,7 @@ pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignI\n             walk_list!(visitor, visit_ty, ty);\n         }\n         ForeignItemKind::MacCall(mac) => {\n-            visitor.visit_mac(mac);\n+            visitor.visit_mac_call(mac);\n         }\n     }\n }\n@@ -662,7 +657,7 @@ pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem,\n             walk_list!(visitor, visit_ty, ty);\n         }\n         AssocItemKind::MacCall(mac) => {\n-            visitor.visit_mac(mac);\n+            visitor.visit_mac_call(mac);\n         }\n     }\n }\n@@ -692,7 +687,7 @@ pub fn walk_stmt<'a, V: Visitor<'a>>(visitor: &mut V, statement: &'a Stmt) {\n         StmtKind::Empty => {}\n         StmtKind::MacCall(ref mac) => {\n             let MacCallStmt { ref mac, style: _, ref attrs } = **mac;\n-            visitor.visit_mac(mac);\n+            visitor.visit_mac_call(mac);\n             for attr in attrs.iter() {\n                 visitor.visit_attribute(attr);\n             }\n@@ -823,7 +818,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         ExprKind::Ret(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprKind::MacCall(ref mac) => visitor.visit_mac(mac),\n+        ExprKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n         ExprKind::Paren(ref subexpression) => visitor.visit_expr(subexpression),\n         ExprKind::InlineAsm(ref ia) => {\n             for (op, _) in &ia.operands {"}, {"sha": "6efc78c88427ee9ac317d41e62d8317d06fe7f99", "filename": "compiler/rustc_ast_passes/src/node_count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -114,9 +114,9 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_lifetime(self, lifetime)\n     }\n-    fn visit_mac(&mut self, _mac: &MacCall) {\n+    fn visit_mac_call(&mut self, mac: &MacCall) {\n         self.count += 1;\n-        walk_mac(self, _mac)\n+        walk_mac(self, mac)\n     }\n     fn visit_path(&mut self, path: &Path, _id: NodeId) {\n         self.count += 1;"}, {"sha": "6cef26a13e6b00e3aa469a0fa999dbc3a81af925", "filename": "compiler/rustc_ast_passes/src/show_span.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -54,10 +54,6 @@ impl<'a> Visitor<'a> for ShowSpanVisitor<'a> {\n         }\n         visit::walk_ty(self, t);\n     }\n-\n-    fn visit_mac(&mut self, mac: &'a ast::MacCall) {\n-        visit::walk_mac(self, mac);\n-    }\n }\n \n pub fn run(span_diagnostic: &rustc_errors::Handler, mode: &str, krate: &ast::Crate) {"}, {"sha": "0642edff6b67817084809fe89a9adcd0343a1ac8", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -358,7 +358,7 @@ fn find_type_parameters(\n             visit::walk_ty(self, ty)\n         }\n \n-        fn visit_mac(&mut self, mac: &ast::MacCall) {\n+        fn visit_mac_call(&mut self, mac: &ast::MacCall) {\n             self.cx.span_err(mac.span(), \"`derive` cannot be used on items with type macros\");\n         }\n     }"}, {"sha": "4e91436199a53f6faad6413ab6392c545961d7b6", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -344,10 +344,6 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         visit::walk_item(self, item);\n         self.in_root = prev_in_root;\n     }\n-\n-    fn visit_mac(&mut self, mac: &'a ast::MacCall) {\n-        visit::walk_mac(self, mac)\n-    }\n }\n \n // Creates a new module which looks like:"}, {"sha": "e68b626e22d9ef5ca676a641a6f2cfd872d2ec10", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -130,10 +130,6 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n         }\n         smallvec![P(item)]\n     }\n-\n-    fn visit_mac(&mut self, _mac: &mut ast::MacCall) {\n-        // Do nothing.\n-    }\n }\n \n // Beware, this is duplicated in librustc_passes/entry.rs (with\n@@ -201,10 +197,6 @@ impl<'a> MutVisitor for EntryPointCleaner<'a> {\n \n         smallvec![item]\n     }\n-\n-    fn visit_mac(&mut self, _mac: &mut ast::MacCall) {\n-        // Do nothing.\n-    }\n }\n \n /// Crawl over the crate, inserting test reexports and the test main function"}, {"sha": "40ae0a13c729539409e48b3c302ee86d09141339", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -502,6 +502,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n+                let ty = self.monomorphize(&ty);\n                 assert!(bx.cx().type_is_sized(ty));\n                 let val = bx.cx().const_usize(bx.cx().layout_of(ty).size.bytes());\n                 let tcx = self.cx.tcx();"}, {"sha": "a07dd8ede8bbae3439ab64b8d9a853a9bb81e281", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -547,11 +547,6 @@ impl<'a> MutVisitor for StripUnconfigured<'a> {\n         noop_flat_map_assoc_item(configure!(self, item), self)\n     }\n \n-    fn visit_mac(&mut self, _mac: &mut ast::MacCall) {\n-        // Don't configure interpolated AST (cf. issue #34171).\n-        // Interpolated AST will get configured once the surrounding tokens are parsed.\n-    }\n-\n     fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n         self.configure_pat(pat);\n         noop_visit_pat(pat, self)"}, {"sha": "8c7a4f06838a249ae329f19e0ab3fa99c718e4c1", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -850,8 +850,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n                 visit::walk_item(self, item);\n             }\n-\n-            fn visit_mac(&mut self, _: &'ast ast::MacCall) {}\n         }\n \n         if !self.cx.ecfg.proc_macro_hygiene() {"}, {"sha": "dde65d998d81b2a3531a7f87a1ee71f06d387d88", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -5,7 +5,6 @@ use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n use rustc_ast::mut_visit::{self, MutVisitor};\n use rustc_ast::token::{self, NtTT, Token};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndSpacing};\n-use rustc_ast::MacCall;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{pluralize, PResult};\n@@ -27,10 +26,6 @@ impl MutVisitor for Marker {\n     fn visit_span(&mut self, span: &mut Span) {\n         *span = span.apply_mark(self.0, self.1)\n     }\n-\n-    fn visit_mac(&mut self, mac: &mut MacCall) {\n-        mut_visit::noop_visit_mac(mac, self)\n-    }\n }\n \n /// An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`)."}, {"sha": "be0300bad98bd1aa5f7274d001134a1f051fac17", "filename": "compiler/rustc_expand/src/mut_visit/tests.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_expand%2Fsrc%2Fmut_visit%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_expand%2Fsrc%2Fmut_visit%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmut_visit%2Ftests.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -1,7 +1,7 @@\n use crate::tests::{matches_codepattern, string_to_crate};\n \n use rustc_ast as ast;\n-use rustc_ast::mut_visit::{self, MutVisitor};\n+use rustc_ast::mut_visit::MutVisitor;\n use rustc_ast_pretty::pprust;\n use rustc_span::symbol::Ident;\n use rustc_span::with_default_session_globals;\n@@ -21,9 +21,6 @@ impl MutVisitor for ToZzIdentMutVisitor {\n     fn visit_ident(&mut self, ident: &mut Ident) {\n         *ident = Ident::from_str(\"zz\");\n     }\n-    fn visit_mac(&mut self, mac: &mut ast::MacCall) {\n-        mut_visit::noop_visit_mac(mac, self)\n-    }\n }\n \n // Maybe add to `expand.rs`."}, {"sha": "f0e5826f403fb9689ba32b1baa5d219d9aecde7b", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -385,8 +385,4 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n             |item| !matches!(item.kind, ast::ItemKind::MacCall(_) if !self.cx.ecfg.keep_macs),\n         );\n     }\n-\n-    fn visit_mac(&mut self, _mac: &mut ast::MacCall) {\n-        // Do nothing.\n-    }\n }"}, {"sha": "0df67b63eba58bcbebb16826819dc1cb2291a201", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -613,6 +613,9 @@ declare_features! (\n     /// Allows the use of destructuring assignments.\n     (active, destructuring_assignment, \"1.49.0\", Some(71126), None),\n \n+    /// Enables `#[cfg(panic = \"...\")]` config key.\n+    (active, cfg_panic, \"1.49.0\", Some(77443), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "5c5cf609ac33c5594643263057781157cd3003d4", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -33,6 +33,7 @@ const GATED_CFGS: &[GatedCfg] = &[\n     ),\n     (sym::sanitize, sym::cfg_sanitize, cfg_fn!(cfg_sanitize)),\n     (sym::version, sym::cfg_version, cfg_fn!(cfg_version)),\n+    (sym::panic, sym::cfg_panic, cfg_fn!(cfg_panic)),\n ];\n \n /// Find a gated cfg determined by the `pred`icate which is given the cfg's name."}, {"sha": "d9ec6d51cdfa83d28a9dc71aa340beefd806433a", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -880,12 +880,6 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n             })\n         }\n     }\n-\n-    // in general the pretty printer processes unexpanded code, so\n-    // we override the default `visit_mac` method which panics.\n-    fn visit_mac(&mut self, mac: &mut ast::MacCall) {\n-        noop_visit_mac(mac, self)\n-    }\n }\n \n /// Returns a version string such as \"rustc 1.46.0 (04488afe3 2020-08-24)\""}, {"sha": "08c147ec3ac3f0a23d1775193fb10dfc7acfdf77", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -270,15 +270,9 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         self.check_id(id);\n     }\n \n-    fn visit_mac(&mut self, mac: &'a ast::MacCall) {\n-        // FIXME(#54110): So, this setup isn't really right. I think\n-        // that (a) the librustc_ast visitor ought to be doing this as\n-        // part of `walk_mac`, and (b) we should be calling\n-        // `visit_path`, *but* that would require a `NodeId`, and I\n-        // want to get #53686 fixed quickly. -nmatsakis\n-        ast_visit::walk_path(self, &mac.path);\n-\n+    fn visit_mac_call(&mut self, mac: &'a ast::MacCall) {\n         run_early_pass!(self, check_mac, mac);\n+        ast_visit::walk_mac(self, mac);\n     }\n }\n "}, {"sha": "3250f1830de18598575312312d7a4557a49ee5fd", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -26,7 +26,7 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n-chalk-ir = \"0.32.0\"\n+chalk-ir = \"0.36.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"9.0.0\"\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "0801188b27881c80d9c531a0d483da710e51f06a", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -109,24 +109,21 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 args.visit_with(visitor)\n             }\n             Assert { ref cond, ref msg, .. } => {\n-                if cond.visit_with(visitor).is_break() {\n-                    use AssertKind::*;\n-                    match msg {\n-                        BoundsCheck { ref len, ref index } => {\n-                            len.visit_with(visitor)?;\n-                            index.visit_with(visitor)\n-                        }\n-                        Overflow(_, l, r) => {\n-                            l.visit_with(visitor)?;\n-                            r.visit_with(visitor)\n-                        }\n-                        OverflowNeg(op) | DivisionByZero(op) | RemainderByZero(op) => {\n-                            op.visit_with(visitor)\n-                        }\n-                        ResumedAfterReturn(_) | ResumedAfterPanic(_) => ControlFlow::CONTINUE,\n+                cond.visit_with(visitor)?;\n+                use AssertKind::*;\n+                match msg {\n+                    BoundsCheck { ref len, ref index } => {\n+                        len.visit_with(visitor)?;\n+                        index.visit_with(visitor)\n+                    }\n+                    Overflow(_, l, r) => {\n+                        l.visit_with(visitor)?;\n+                        r.visit_with(visitor)\n+                    }\n+                    OverflowNeg(op) | DivisionByZero(op) | RemainderByZero(op) => {\n+                        op.visit_with(visitor)\n                     }\n-                } else {\n-                    ControlFlow::CONTINUE\n+                    ResumedAfterReturn(_) | ResumedAfterPanic(_) => ControlFlow::CONTINUE,\n                 }\n             }\n             InlineAsm { ref operands, .. } => operands.visit_with(visitor),"}, {"sha": "f864ad8ebcd8a0f52fa34244d6c0c211e119d78e", "filename": "compiler/rustc_middle/src/traits/chalk.rs", "status": "modified", "additions": 26, "deletions": 42, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -102,48 +102,6 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         Some(write())\n     }\n \n-    fn debug_application_ty(\n-        application_ty: &chalk_ir::ApplicationTy<Self>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        match application_ty.name {\n-            chalk_ir::TypeName::Ref(mutbl) => {\n-                let data = application_ty.substitution.interned();\n-                match (&**data[0].interned(), &**data[1].interned()) {\n-                    (\n-                        chalk_ir::GenericArgData::Lifetime(lifetime),\n-                        chalk_ir::GenericArgData::Ty(ty),\n-                    ) => Some(match mutbl {\n-                        chalk_ir::Mutability::Not => write!(fmt, \"(&{:?} {:?})\", lifetime, ty),\n-                        chalk_ir::Mutability::Mut => write!(fmt, \"(&{:?} mut {:?})\", lifetime, ty),\n-                    }),\n-                    _ => unreachable!(),\n-                }\n-            }\n-            chalk_ir::TypeName::Array => {\n-                let data = application_ty.substitution.interned();\n-                match (&**data[0].interned(), &**data[1].interned()) {\n-                    (chalk_ir::GenericArgData::Ty(ty), chalk_ir::GenericArgData::Const(len)) => {\n-                        Some(write!(fmt, \"[{:?}; {:?}]\", ty, len))\n-                    }\n-                    _ => unreachable!(),\n-                }\n-            }\n-            chalk_ir::TypeName::Slice => {\n-                let data = application_ty.substitution.interned();\n-                let ty = match &**data[0].interned() {\n-                    chalk_ir::GenericArgData::Ty(t) => t,\n-                    _ => unreachable!(),\n-                };\n-                Some(write!(fmt, \"[{:?}]\", ty))\n-            }\n-            _ => {\n-                let chalk_ir::ApplicationTy { name, substitution } = application_ty;\n-                Some(write!(fmt, \"{:?}{:?}\", name, chalk_ir::debug::Angle(substitution.interned())))\n-            }\n-        }\n-    }\n-\n     fn debug_substitution(\n         substitution: &chalk_ir::Substitution<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n@@ -174,6 +132,32 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         Some(write!(fmt, \"{:?}\", clauses.interned()))\n     }\n \n+    fn debug_ty(ty: &chalk_ir::Ty<Self>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n+        match &ty.interned().kind {\n+            chalk_ir::TyKind::Ref(chalk_ir::Mutability::Not, lifetime, ty) => {\n+                Some(write!(fmt, \"(&{:?} {:?})\", lifetime, ty))\n+            }\n+            chalk_ir::TyKind::Ref(chalk_ir::Mutability::Mut, lifetime, ty) => {\n+                Some(write!(fmt, \"(&{:?} mut {:?})\", lifetime, ty))\n+            }\n+            chalk_ir::TyKind::Array(ty, len) => Some(write!(fmt, \"[{:?}; {:?}]\", ty, len)),\n+            chalk_ir::TyKind::Slice(ty) => Some(write!(fmt, \"[{:?}]\", ty)),\n+            chalk_ir::TyKind::Tuple(len, substs) => Some((|| {\n+                write!(fmt, \"(\")?;\n+                for (idx, substitution) in substs.interned().iter().enumerate() {\n+                    if idx == *len && *len != 1 {\n+                        // Don't add a trailing comma if the tuple has more than one element\n+                        write!(fmt, \"{:?}\", substitution)?;\n+                    } else {\n+                        write!(fmt, \"{:?},\", substitution)?;\n+                    }\n+                }\n+                write!(fmt, \")\")\n+            })()),\n+            _ => None,\n+        }\n+    }\n+\n     fn debug_alias(\n         alias_ty: &chalk_ir::AliasTy<Self>,\n         fmt: &mut fmt::Formatter<'_>,"}, {"sha": "1e4fd0921ee0fd4b380f502b9aaa952e7fdbed9a", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -63,7 +63,7 @@ thread_local! {\n /// Avoids running any queries during any prints that occur\n /// during the closure. This may alter the appearance of some\n /// types (e.g. forcing verbose printing for opaque types).\n-/// This method is used during some queries (e.g. `predicates_of`\n+/// This method is used during some queries (e.g. `explicit_item_bounds`\n /// for opaque types), to ensure that any debug printing that\n /// occurs during the query computation does not end up recursively\n /// calling the same query."}, {"sha": "2a90fb042dd7183408b0d5d72b73c14c9dff1e89", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 161, "deletions": 43, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -6,8 +6,8 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_middle::ty::print::RegionHighlightMode;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, RegionVid, Ty};\n-use rustc_span::symbol::kw;\n-use rustc_span::{symbol::Symbol, Span, DUMMY_SP};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::{Span, DUMMY_SP};\n \n use crate::borrow_check::{nll::ToRegionVid, universal_regions::DefiningTy, MirBorrowckCtxt};\n \n@@ -39,7 +39,7 @@ crate enum RegionNameSource {\n     /// The region corresponding to a closure upvar.\n     AnonRegionFromUpvar(Span, String),\n     /// The region corresponding to the return type of a closure.\n-    AnonRegionFromOutput(Span, String, String),\n+    AnonRegionFromOutput(RegionNameHighlight, String),\n     /// The region from a type yielded by a generator.\n     AnonRegionFromYieldTy(Span, String),\n     /// An anonymous region from an async fn.\n@@ -57,6 +57,10 @@ crate enum RegionNameHighlight {\n     /// The anonymous region corresponds to a region where the type annotation is completely missing\n     /// from the code, e.g. in a closure arguments `|x| { ... }`, where `x` is a reference.\n     CannotMatchHirTy(Span, String),\n+    /// The anonymous region corresponds to a region where the type annotation is completely missing\n+    /// from the code, and *even if* we print out the full name of the type, the region name won't\n+    /// be included. This currently occurs for opaque types like `impl Future`.\n+    Occluded(Span, String),\n }\n \n impl RegionName {\n@@ -81,13 +85,14 @@ impl RegionName {\n             | RegionNameSource::NamedFreeRegion(span)\n             | RegionNameSource::SynthesizedFreeEnvRegion(span, _)\n             | RegionNameSource::AnonRegionFromUpvar(span, _)\n-            | RegionNameSource::AnonRegionFromOutput(span, _, _)\n             | RegionNameSource::AnonRegionFromYieldTy(span, _)\n             | RegionNameSource::AnonRegionFromAsyncFn(span) => Some(span),\n-            RegionNameSource::AnonRegionFromArgument(ref highlight) => match *highlight {\n+            RegionNameSource::AnonRegionFromArgument(ref highlight)\n+            | RegionNameSource::AnonRegionFromOutput(ref highlight, _) => match *highlight {\n                 RegionNameHighlight::MatchedHirTy(span)\n                 | RegionNameHighlight::MatchedAdtAndSegment(span)\n-                | RegionNameHighlight::CannotMatchHirTy(span, _) => Some(span),\n+                | RegionNameHighlight::CannotMatchHirTy(span, _)\n+                | RegionNameHighlight::Occluded(span, _) => Some(span),\n             },\n         }\n     }\n@@ -112,6 +117,7 @@ impl RegionName {\n                 diag.span_label(*span, format!(\"has type `{}`\", type_name));\n             }\n             RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::MatchedHirTy(span))\n+            | RegionNameSource::AnonRegionFromOutput(RegionNameHighlight::MatchedHirTy(span), _)\n             | RegionNameSource::AnonRegionFromAsyncFn(span) => {\n                 diag.span_label(\n                     *span,\n@@ -120,16 +126,44 @@ impl RegionName {\n             }\n             RegionNameSource::AnonRegionFromArgument(\n                 RegionNameHighlight::MatchedAdtAndSegment(span),\n+            )\n+            | RegionNameSource::AnonRegionFromOutput(\n+                RegionNameHighlight::MatchedAdtAndSegment(span),\n+                _,\n             ) => {\n                 diag.span_label(*span, format!(\"let's call this `{}`\", self));\n             }\n+            RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::Occluded(\n+                span,\n+                type_name,\n+            )) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\"lifetime `{}` appears in the type {}\", self, type_name),\n+                );\n+            }\n+            RegionNameSource::AnonRegionFromOutput(\n+                RegionNameHighlight::Occluded(span, type_name),\n+                mir_description,\n+            ) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\n+                        \"return type{} `{}` contains a lifetime `{}`\",\n+                        mir_description, type_name, self\n+                    ),\n+                );\n+            }\n             RegionNameSource::AnonRegionFromUpvar(span, upvar_name) => {\n                 diag.span_label(\n                     *span,\n                     format!(\"lifetime `{}` appears in the type of `{}`\", self, upvar_name),\n                 );\n             }\n-            RegionNameSource::AnonRegionFromOutput(span, mir_description, type_name) => {\n+            RegionNameSource::AnonRegionFromOutput(\n+                RegionNameHighlight::CannotMatchHirTy(span, type_name),\n+                mir_description,\n+            ) => {\n                 diag.span_label(*span, format!(\"return type{} is {}\", mir_description, type_name));\n             }\n             RegionNameSource::AnonRegionFromYieldTy(span, type_name) => {\n@@ -349,19 +383,21 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             argument_index,\n         );\n \n-        self.get_argument_hir_ty_for_highlighting(argument_index)\n+        let highlight = self\n+            .get_argument_hir_ty_for_highlighting(argument_index)\n             .and_then(|arg_hir_ty| self.highlight_if_we_can_match_hir_ty(fr, arg_ty, arg_hir_ty))\n-            .or_else(|| {\n+            .unwrap_or_else(|| {\n                 // `highlight_if_we_cannot_match_hir_ty` needs to know the number we will give to\n                 // the anonymous region. If it succeeds, the `synthesize_region_name` call below\n                 // will increment the counter, \"reserving\" the number we just used.\n                 let counter = *self.next_region_name.try_borrow().unwrap();\n                 self.highlight_if_we_cannot_match_hir_ty(fr, arg_ty, span, counter)\n-            })\n-            .map(|highlight| RegionName {\n-                name: self.synthesize_region_name(),\n-                source: RegionNameSource::AnonRegionFromArgument(highlight),\n-            })\n+            });\n+\n+        Some(RegionName {\n+            name: self.synthesize_region_name(),\n+            source: RegionNameSource::AnonRegionFromArgument(highlight),\n+        })\n     }\n \n     fn get_argument_hir_ty_for_highlighting(\n@@ -399,7 +435,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         ty: Ty<'tcx>,\n         span: Span,\n         counter: usize,\n-    ) -> Option<RegionNameHighlight> {\n+    ) -> RegionNameHighlight {\n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(needle_fr, counter);\n         let type_name =\n@@ -411,9 +447,9 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         );\n         if type_name.find(&format!(\"'{}\", counter)).is_some() {\n             // Only add a label if we can confirm that a region was labelled.\n-            Some(RegionNameHighlight::CannotMatchHirTy(span, type_name))\n+            RegionNameHighlight::CannotMatchHirTy(span, type_name)\n         } else {\n-            None\n+            RegionNameHighlight::Occluded(span, type_name)\n         }\n     }\n \n@@ -643,49 +679,131 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// or be early bound (named, not in argument).\n     fn give_name_if_anonymous_region_appears_in_output(&self, fr: RegionVid) -> Option<RegionName> {\n         let tcx = self.infcx.tcx;\n+        let hir = tcx.hir();\n \n         let return_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n         debug!(\"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\", return_ty);\n         if !tcx.any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr) {\n             return None;\n         }\n \n-        let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n-        let type_name =\n-            self.infcx.extract_inference_diagnostics_data(return_ty.into(), Some(highlight)).name;\n+        let mir_hir_id = self.mir_hir_id();\n \n-        let (return_span, mir_description) = match tcx.hir().get(self.mir_hir_id()) {\n+        let (return_span, mir_description, hir_ty) = match hir.get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n-                kind: hir::ExprKind::Closure(_, return_ty, _, span, gen_move),\n-                ..\n-            }) => (\n-                match return_ty.output {\n-                    hir::FnRetTy::DefaultReturn(_) => tcx.sess.source_map().end_point(*span),\n-                    hir::FnRetTy::Return(_) => return_ty.output.span(),\n-                },\n-                if gen_move.is_some() { \" of generator\" } else { \" of closure\" },\n-            ),\n-            hir::Node::ImplItem(hir::ImplItem {\n-                kind: hir::ImplItemKind::Fn(method_sig, _),\n+                kind: hir::ExprKind::Closure(_, return_ty, body_id, span, _),\n                 ..\n-            }) => (method_sig.decl.output.span(), \"\"),\n-            _ => (self.body.span, \"\"),\n+            }) => {\n+                let (mut span, mut hir_ty) = match return_ty.output {\n+                    hir::FnRetTy::DefaultReturn(_) => {\n+                        (tcx.sess.source_map().end_point(*span), None)\n+                    }\n+                    hir::FnRetTy::Return(hir_ty) => (return_ty.output.span(), Some(hir_ty)),\n+                };\n+                let mir_description = match hir.body(*body_id).generator_kind {\n+                    Some(hir::GeneratorKind::Async(gen)) => match gen {\n+                        hir::AsyncGeneratorKind::Block => \" of async block\",\n+                        hir::AsyncGeneratorKind::Closure => \" of async closure\",\n+                        hir::AsyncGeneratorKind::Fn => {\n+                            let parent_item = hir.get(hir.get_parent_item(mir_hir_id));\n+                            let output = &parent_item\n+                                .fn_decl()\n+                                .expect(\"generator lowered from async fn should be in fn\")\n+                                .output;\n+                            span = output.span();\n+                            if let hir::FnRetTy::Return(ret) = output {\n+                                hir_ty = Some(self.get_future_inner_return_ty(*ret));\n+                            }\n+                            \" of async function\"\n+                        }\n+                    },\n+                    Some(hir::GeneratorKind::Gen) => \" of generator\",\n+                    None => \" of closure\",\n+                };\n+                (span, mir_description, hir_ty)\n+            }\n+            node => match node.fn_decl() {\n+                Some(fn_decl) => {\n+                    let hir_ty = match fn_decl.output {\n+                        hir::FnRetTy::DefaultReturn(_) => None,\n+                        hir::FnRetTy::Return(ty) => Some(ty),\n+                    };\n+                    (fn_decl.output.span(), \"\", hir_ty)\n+                }\n+                None => (self.body.span, \"\", None),\n+            },\n         };\n \n+        let highlight = hir_ty\n+            .and_then(|hir_ty| self.highlight_if_we_can_match_hir_ty(fr, return_ty, hir_ty))\n+            .unwrap_or_else(|| {\n+                // `highlight_if_we_cannot_match_hir_ty` needs to know the number we will give to\n+                // the anonymous region. If it succeeds, the `synthesize_region_name` call below\n+                // will increment the counter, \"reserving\" the number we just used.\n+                let counter = *self.next_region_name.try_borrow().unwrap();\n+                self.highlight_if_we_cannot_match_hir_ty(fr, return_ty, return_span, counter)\n+            });\n+\n         Some(RegionName {\n-            // This counter value will already have been used, so this function will increment it\n-            // so the next value will be used next and return the region name that would have been\n-            // used.\n             name: self.synthesize_region_name(),\n-            source: RegionNameSource::AnonRegionFromOutput(\n-                return_span,\n-                mir_description.to_string(),\n-                type_name,\n-            ),\n+            source: RegionNameSource::AnonRegionFromOutput(highlight, mir_description.to_string()),\n         })\n     }\n \n+    /// From the [`hir::Ty`] of an async function's lowered return type,\n+    /// retrieve the `hir::Ty` representing the type the user originally wrote.\n+    ///\n+    /// e.g. given the function:\n+    ///\n+    /// ```\n+    /// async fn foo() -> i32 {}\n+    /// ```\n+    ///\n+    /// this function, given the lowered return type of `foo`, an [`OpaqueDef`] that implements `Future<Output=i32>`,\n+    /// returns the `i32`.\n+    ///\n+    /// [`OpaqueDef`]: hir::TyKind::OpaqueDef\n+    fn get_future_inner_return_ty(&self, hir_ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n+        let hir = self.infcx.tcx.hir();\n+\n+        if let hir::TyKind::OpaqueDef(id, _) = hir_ty.kind {\n+            let opaque_ty = hir.item(id.id);\n+            if let hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                bounds:\n+                    [hir::GenericBound::LangItemTrait(\n+                        hir::LangItem::Future,\n+                        _,\n+                        _,\n+                        hir::GenericArgs {\n+                            bindings:\n+                                [hir::TypeBinding {\n+                                    ident: Ident { name: sym::Output, .. },\n+                                    kind: hir::TypeBindingKind::Equality { ty },\n+                                    ..\n+                                }],\n+                            ..\n+                        },\n+                    )],\n+                ..\n+            }) = opaque_ty.kind\n+            {\n+                ty\n+            } else {\n+                span_bug!(\n+                    hir_ty.span,\n+                    \"bounds from lowered return type of async fn did not match expected format: {:?}\",\n+                    opaque_ty\n+                );\n+            }\n+        } else {\n+            span_bug!(\n+                hir_ty.span,\n+                \"lowered return type of async fn is not OpaqueDef: {:?}\",\n+                hir_ty\n+            );\n+        }\n+    }\n+\n     fn give_name_if_anonymous_region_appears_in_yield_ty(\n         &self,\n         fr: RegionVid,"}, {"sha": "97b513445264a67c91e887892a919e28d2fddd0a", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 114, "deletions": 123, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -1,6 +1,7 @@\n //! Inlining pass for MIR functions\n \n use rustc_attr as attr;\n+use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n@@ -12,9 +13,8 @@ use rustc_target::spec::abi::Abi;\n \n use super::simplify::{remove_dead_blocks, CfgSimplifier};\n use crate::transform::MirPass;\n-use std::collections::VecDeque;\n use std::iter;\n-use std::ops::RangeFrom;\n+use std::ops::{Range, RangeFrom};\n \n const DEFAULT_THRESHOLD: usize = 50;\n const HINT_THRESHOLD: usize = 100;\n@@ -37,132 +37,128 @@ struct CallSite<'tcx> {\n \n impl<'tcx> MirPass<'tcx> for Inline {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n-            if tcx.sess.opts.debugging_opts.instrument_coverage {\n-                // The current implementation of source code coverage injects code region counters\n-                // into the MIR, and assumes a 1-to-1 correspondence between MIR and source-code-\n-                // based function.\n-                debug!(\"function inlining is disabled when compiling with `instrument_coverage`\");\n-            } else {\n-                Inliner {\n-                    tcx,\n-                    param_env: tcx.param_env_reveal_all_normalized(body.source.def_id()),\n-                    codegen_fn_attrs: tcx.codegen_fn_attrs(body.source.def_id()),\n-                }\n-                .run_pass(body);\n-            }\n+        if tcx.sess.opts.debugging_opts.mir_opt_level < 2 {\n+            return;\n+        }\n+\n+        if tcx.sess.opts.debugging_opts.instrument_coverage {\n+            // The current implementation of source code coverage injects code region counters\n+            // into the MIR, and assumes a 1-to-1 correspondence between MIR and source-code-\n+            // based function.\n+            debug!(\"function inlining is disabled when compiling with `instrument_coverage`\");\n+            return;\n+        }\n+\n+        if inline(tcx, body) {\n+            debug!(\"running simplify cfg on {:?}\", body.source);\n+            CfgSimplifier::new(body).simplify();\n+            remove_dead_blocks(body);\n         }\n     }\n }\n \n+fn inline(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) -> bool {\n+    let def_id = body.source.def_id();\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+\n+    // Only do inlining into fn bodies.\n+    if !tcx.hir().body_owner_kind(hir_id).is_fn_or_closure() {\n+        return false;\n+    }\n+    if body.source.promoted.is_some() {\n+        return false;\n+    }\n+\n+    let mut this = Inliner {\n+        tcx,\n+        param_env: tcx.param_env_reveal_all_normalized(body.source.def_id()),\n+        codegen_fn_attrs: tcx.codegen_fn_attrs(body.source.def_id()),\n+        hir_id,\n+        history: Vec::new(),\n+        changed: false,\n+    };\n+    let blocks = BasicBlock::new(0)..body.basic_blocks().next_index();\n+    this.process_blocks(body, blocks);\n+    this.changed\n+}\n+\n struct Inliner<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n+    /// Caller codegen attributes.\n     codegen_fn_attrs: &'tcx CodegenFnAttrs,\n+    /// Caller HirID.\n+    hir_id: hir::HirId,\n+    /// Stack of inlined instances.\n+    history: Vec<Instance<'tcx>>,\n+    /// Indicates that the caller body has been modified.\n+    changed: bool,\n }\n \n impl Inliner<'tcx> {\n-    fn run_pass(&self, caller_body: &mut Body<'tcx>) {\n-        // Keep a queue of callsites to try inlining on. We take\n-        // advantage of the fact that queries detect cycles here to\n-        // allow us to try and fetch the fully optimized MIR of a\n-        // call; if it succeeds, we can inline it and we know that\n-        // they do not call us.  Otherwise, we just don't try to\n-        // inline.\n-        //\n-        // We use a queue so that we inline \"broadly\" before we inline\n-        // in depth. It is unclear if this is the best heuristic,\n-        // really, but that's true of all the heuristics in this\n-        // file. =)\n-\n-        let mut callsites = VecDeque::new();\n-\n-        let def_id = caller_body.source.def_id();\n-\n-        // Only do inlining into fn bodies.\n-        let self_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-        if self.tcx.hir().body_owner_kind(self_hir_id).is_fn_or_closure()\n-            && caller_body.source.promoted.is_none()\n-        {\n-            for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated() {\n-                if let Some(callsite) = self.get_valid_function_call(bb, bb_data, caller_body) {\n-                    callsites.push_back(callsite);\n-                }\n-            }\n-        } else {\n-            return;\n-        }\n-\n-        let mut changed = false;\n-        while let Some(callsite) = callsites.pop_front() {\n-            debug!(\"checking whether to inline callsite {:?}\", callsite);\n+    fn process_blocks(&mut self, caller_body: &mut Body<'tcx>, blocks: Range<BasicBlock>) {\n+        for bb in blocks {\n+            let callsite = match self.get_valid_function_call(bb, &caller_body[bb], caller_body) {\n+                None => continue,\n+                Some(it) => it,\n+            };\n \n-            if let InstanceDef::Item(_) = callsite.callee.def {\n-                if !self.tcx.is_mir_available(callsite.callee.def_id()) {\n-                    debug!(\"checking whether to inline callsite {:?} - MIR unavailable\", callsite,);\n-                    continue;\n-                }\n+            if !self.is_mir_available(&callsite.callee, caller_body) {\n+                debug!(\"MIR unavailable {}\", callsite.callee);\n+                continue;\n             }\n \n-            let callee_body = if let Some(callee_def_id) = callsite.callee.def_id().as_local() {\n-                let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n-                // Avoid a cycle here by only using `instance_mir` only if we have\n-                // a lower `HirId` than the callee. This ensures that the callee will\n-                // not inline us. This trick only works without incremental compilation.\n-                // So don't do it if that is enabled. Also avoid inlining into generators,\n-                // since their `optimized_mir` is used for layout computation, which can\n-                // create a cycle, even when no attempt is made to inline the function\n-                // in the other direction.\n-                if !self.tcx.dep_graph.is_fully_enabled()\n-                    && self_hir_id < callee_hir_id\n-                    && caller_body.generator_kind.is_none()\n-                {\n-                    self.tcx.instance_mir(callsite.callee.def)\n-                } else {\n-                    continue;\n-                }\n-            } else {\n-                // This cannot result in a cycle since the callee MIR is from another crate\n-                // and is already optimized.\n-                self.tcx.instance_mir(callsite.callee.def)\n-            };\n-\n-            if !self.consider_optimizing(callsite, &callee_body) {\n+            let callee_body = self.tcx.instance_mir(callsite.callee.def);\n+            if !self.should_inline(callsite, callee_body) {\n                 continue;\n             }\n \n+            if !self.tcx.consider_optimizing(|| {\n+                format!(\"Inline {:?} into {}\", callee_body.span, callsite.callee)\n+            }) {\n+                return;\n+            }\n+\n             let callee_body = callsite.callee.subst_mir_and_normalize_erasing_regions(\n                 self.tcx,\n                 self.param_env,\n                 callee_body,\n             );\n \n-            let start = caller_body.basic_blocks().len();\n-            debug!(\"attempting to inline callsite {:?} - body={:?}\", callsite, callee_body);\n-            if !self.inline_call(callsite, caller_body, callee_body) {\n-                debug!(\"attempting to inline callsite {:?} - failure\", callsite);\n-                continue;\n-            }\n-            debug!(\"attempting to inline callsite {:?} - success\", callsite);\n-\n-            // Add callsites from inlined function\n-            for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated().skip(start) {\n-                if let Some(new_callsite) = self.get_valid_function_call(bb, bb_data, caller_body) {\n-                    // Don't inline the same function multiple times.\n-                    if callsite.callee != new_callsite.callee {\n-                        callsites.push_back(new_callsite);\n-                    }\n-                }\n-            }\n+            let old_blocks = caller_body.basic_blocks().next_index();\n+            self.inline_call(callsite, caller_body, callee_body);\n+            let new_blocks = old_blocks..caller_body.basic_blocks().next_index();\n+            self.changed = true;\n+\n+            self.history.push(callsite.callee);\n+            self.process_blocks(caller_body, new_blocks);\n+            self.history.pop();\n+        }\n+    }\n \n-            changed = true;\n+    fn is_mir_available(&self, callee: &Instance<'tcx>, caller_body: &Body<'tcx>) -> bool {\n+        if let InstanceDef::Item(_) = callee.def {\n+            if !self.tcx.is_mir_available(callee.def_id()) {\n+                return false;\n+            }\n         }\n \n-        // Simplify if we inlined anything.\n-        if changed {\n-            debug!(\"running simplify cfg on {:?}\", caller_body.source);\n-            CfgSimplifier::new(caller_body).simplify();\n-            remove_dead_blocks(caller_body);\n+        if let Some(callee_def_id) = callee.def_id().as_local() {\n+            let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n+            // Avoid a cycle here by only using `instance_mir` only if we have\n+            // a lower `HirId` than the callee. This ensures that the callee will\n+            // not inline us. This trick only works without incremental compilation.\n+            // So don't do it if that is enabled. Also avoid inlining into generators,\n+            // since their `optimized_mir` is used for layout computation, which can\n+            // create a cycle, even when no attempt is made to inline the function\n+            // in the other direction.\n+            !self.tcx.dep_graph.is_fully_enabled()\n+                && self.hir_id < callee_hir_id\n+                && caller_body.generator_kind.is_none()\n+        } else {\n+            // This cannot result in a cycle since the callee MIR is from another crate\n+            // and is already optimized.\n+            true\n         }\n     }\n \n@@ -179,7 +175,8 @@ impl Inliner<'tcx> {\n \n         // Only consider direct calls to functions\n         let terminator = bb_data.terminator();\n-        if let TerminatorKind::Call { func: ref op, .. } = terminator.kind {\n+        // FIXME: Handle inlining of diverging calls\n+        if let TerminatorKind::Call { func: ref op, destination: Some(_), .. } = terminator.kind {\n             if let ty::FnDef(callee_def_id, substs) = *op.ty(caller_body, self.tcx).kind() {\n                 // To resolve an instance its substs have to be fully normalized, so\n                 // we do this here.\n@@ -200,14 +197,6 @@ impl Inliner<'tcx> {\n         None\n     }\n \n-    fn consider_optimizing(&self, callsite: CallSite<'tcx>, callee_body: &Body<'tcx>) -> bool {\n-        debug!(\"consider_optimizing({:?})\", callsite);\n-        self.should_inline(callsite, callee_body)\n-            && self.tcx.consider_optimizing(|| {\n-                format!(\"Inline {:?} into {:?}\", callee_body.span, callsite)\n-            })\n-    }\n-\n     fn should_inline(&self, callsite: CallSite<'tcx>, callee_body: &Body<'tcx>) -> bool {\n         debug!(\"should_inline({:?})\", callsite);\n         let tcx = self.tcx;\n@@ -327,7 +316,18 @@ impl Inliner<'tcx> {\n                 }\n \n                 TerminatorKind::Call { func: Operand::Constant(ref f), cleanup, .. } => {\n-                    if let ty::FnDef(def_id, _) = *f.literal.ty.kind() {\n+                    if let ty::FnDef(def_id, substs) =\n+                        *callsite.callee.subst_mir(self.tcx, &f.literal.ty).kind()\n+                    {\n+                        let substs = self.tcx.normalize_erasing_regions(self.param_env, substs);\n+                        if let Ok(Some(instance)) =\n+                            Instance::resolve(self.tcx, self.param_env, def_id, substs)\n+                        {\n+                            if callsite.callee == instance || self.history.contains(&instance) {\n+                                debug!(\"`callee is recursive - not inlining\");\n+                                return false;\n+                            }\n+                        }\n                         // Don't give intrinsics the extra penalty for calls\n                         let f = tcx.fn_sig(def_id);\n                         if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n@@ -397,13 +397,10 @@ impl Inliner<'tcx> {\n         callsite: CallSite<'tcx>,\n         caller_body: &mut Body<'tcx>,\n         mut callee_body: Body<'tcx>,\n-    ) -> bool {\n+    ) {\n         let terminator = caller_body[callsite.bb].terminator.take().unwrap();\n         match terminator.kind {\n-            // FIXME: Handle inlining of diverging calls\n             TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n-                debug!(\"inlined {:?} into {:?}\", callsite.callee, caller_body.source);\n-\n                 // If the call is something like `a[*i] = f(i)`, where\n                 // `i : &mut usize`, then just duplicating the `a[*i]`\n                 // Place could result in two different locations if `f`\n@@ -519,14 +516,8 @@ impl Inliner<'tcx> {\n                         matches!(constant.literal.val, ConstKind::Unevaluated(_, _, _))\n                     }),\n                 );\n-\n-                true\n-            }\n-            kind => {\n-                caller_body[callsite.bb].terminator =\n-                    Some(Terminator { source_info: terminator.source_info, kind });\n-                false\n             }\n+            kind => bug!(\"unexpected terminator kind {:?}\", kind),\n         }\n     }\n "}, {"sha": "ee9a6dca5ade985331bcb31ff83e00048851e5ab", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -1,6 +1,6 @@\n use super::{Parser, PathStyle};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n-use rustc_ast::mut_visit::{noop_visit_mac, noop_visit_pat, MutVisitor};\n+use rustc_ast::mut_visit::{noop_visit_pat, MutVisitor};\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::{self as ast, AttrVec, Attribute, FieldPat, MacCall, Pat, PatKind, RangeEnd};\n@@ -570,10 +570,6 @@ impl<'a> Parser<'a> {\n     fn make_all_value_bindings_mutable(pat: &mut P<Pat>) -> bool {\n         struct AddMut(bool);\n         impl MutVisitor for AddMut {\n-            fn visit_mac(&mut self, mac: &mut MacCall) {\n-                noop_visit_mac(mac, self);\n-            }\n-\n             fn visit_pat(&mut self, pat: &mut P<Pat>) {\n                 if let PatKind::Ident(BindingMode::ByValue(m @ Mutability::Not), ..) = &mut pat.kind\n                 {"}, {"sha": "1d02c9aa6375dd5666e40eddf2d703c94c81176c", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -336,8 +336,9 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n         ast_visit::walk_lifetime(self, lifetime)\n     }\n \n-    fn visit_mac(&mut self, mac: &'v ast::MacCall) {\n+    fn visit_mac_call(&mut self, mac: &'v ast::MacCall) {\n         self.record(\"MacCall\", Id::None, mac);\n+        ast_visit::walk_mac(self, mac)\n     }\n \n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v ast::PathSegment) {"}, {"sha": "ab694ad4c5afdd4d08ec6feab11dc00be0f847b9", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -793,6 +793,9 @@ pub fn default_configuration(sess: &Session) -> CrateConfig {\n         }\n     }\n \n+    let panic_strategy = sess.panic_strategy();\n+    ret.insert((sym::panic, Some(panic_strategy.desc_symbol())));\n+\n     for s in sess.opts.debugging_opts.sanitizer {\n         let symbol = Symbol::intern(&s.to_string());\n         ret.insert((sym::sanitize, Some(symbol)));"}, {"sha": "ad58f89d87da7969058a5cc082bdf5bed13f3c5c", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -326,6 +326,7 @@ symbols! {\n         cfg_attr,\n         cfg_attr_multi,\n         cfg_doctest,\n+        cfg_panic,\n         cfg_sanitize,\n         cfg_target_feature,\n         cfg_target_has_atomic,"}, {"sha": "55d27fd8698a72428d74e53abca8bbff6853038c", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -37,6 +37,7 @@\n use crate::spec::abi::{lookup as lookup_abi, Abi};\n use crate::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_serialize::json::{Json, ToJson};\n+use rustc_span::symbol::{sym, Symbol};\n use std::collections::BTreeMap;\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n@@ -176,6 +177,13 @@ impl PanicStrategy {\n             PanicStrategy::Abort => \"abort\",\n         }\n     }\n+\n+    pub fn desc_symbol(&self) -> Symbol {\n+        match *self {\n+            PanicStrategy::Unwind => sym::unwind,\n+            PanicStrategy::Abort => sym::abort,\n+        }\n+    }\n }\n \n impl ToJson for PanicStrategy {"}, {"sha": "8bd9e29629dce8baa8929764fcb2a6ec661131e2", "filename": "compiler/rustc_traits/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2FCargo.toml?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -12,9 +12,9 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n-chalk-ir = \"0.32.0\"\n-chalk-solve = \"0.32.0\"\n-chalk-engine = \"0.32.0\"\n+chalk-ir = \"0.36.0\"\n+chalk-solve = \"0.36.0\"\n+chalk-engine = \"0.36.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }"}, {"sha": "c5a46b1003dfaaf44d11710cc435dbb639f8898a", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 128, "deletions": 78, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -37,7 +37,7 @@ impl<'tcx> RustIrDatabase<'tcx> {\n         def_id: DefId,\n         bound_vars: SubstsRef<'tcx>,\n     ) -> Vec<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n-        let predicates = self.interner.tcx.predicates_of(def_id).predicates;\n+        let predicates = self.interner.tcx.predicates_defined_on(def_id).predicates;\n         let mut regions_substitutor =\n             lowering::RegionsSubstitutor::new(self.interner.tcx, self.reempty_placeholder);\n         predicates\n@@ -118,34 +118,27 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             .map(|i| chalk_ir::AssocTypeId(i.def_id))\n             .collect();\n \n-        let well_known = if self.interner.tcx.lang_items().sized_trait() == Some(def_id) {\n+        let lang_items = self.interner.tcx.lang_items();\n+        let well_known = if lang_items.sized_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Sized)\n-        } else if self.interner.tcx.lang_items().copy_trait() == Some(def_id) {\n+        } else if lang_items.copy_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Copy)\n-        } else if self.interner.tcx.lang_items().clone_trait() == Some(def_id) {\n+        } else if lang_items.clone_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Clone)\n-        } else if self.interner.tcx.lang_items().drop_trait() == Some(def_id) {\n+        } else if lang_items.drop_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Drop)\n-        } else if self.interner.tcx.lang_items().fn_trait() == Some(def_id) {\n+        } else if lang_items.fn_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Fn)\n-        } else if self\n-            .interner\n-            .tcx\n-            .lang_items()\n-            .fn_once_trait()\n-            .map(|t| def_id == t)\n-            .unwrap_or(false)\n-        {\n+        } else if lang_items.fn_once_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::FnOnce)\n-        } else if self\n-            .interner\n-            .tcx\n-            .lang_items()\n-            .fn_mut_trait()\n-            .map(|t| def_id == t)\n-            .unwrap_or(false)\n-        {\n+        } else if lang_items.fn_mut_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::FnMut)\n+        } else if lang_items.unsize_trait() == Some(def_id) {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Unsize)\n+        } else if lang_items.unpin_trait() == Some(def_id) {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Unpin)\n+        } else if lang_items.coerce_unsized_trait() == Some(def_id) {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::CoerceUnsized)\n         } else {\n             None\n         };\n@@ -281,11 +274,20 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             where_clauses,\n         };\n \n+        let associated_ty_value_ids: Vec<_> = self\n+            .interner\n+            .tcx\n+            .associated_items(def_id)\n+            .in_definition_order()\n+            .filter(|i| i.kind == AssocKind::Type)\n+            .map(|i| chalk_solve::rust_ir::AssociatedTyValueId(i.def_id))\n+            .collect();\n+\n         Arc::new(chalk_solve::rust_ir::ImplDatum {\n-            polarity: chalk_solve::rust_ir::Polarity::Positive,\n+            polarity: self.interner.tcx.impl_polarity(def_id).lower_into(&self.interner),\n             binders: chalk_ir::Binders::new(binders, value),\n             impl_type: chalk_solve::rust_ir::ImplType::Local,\n-            associated_ty_value_ids: vec![],\n+            associated_ty_value_ids,\n         })\n     }\n \n@@ -324,19 +326,19 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     fn impl_provided_for(\n         &self,\n         auto_trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n-        app_ty: &chalk_ir::ApplicationTy<RustInterner<'tcx>>,\n+        chalk_ty: &chalk_ir::TyKind<RustInterner<'tcx>>,\n     ) -> bool {\n         use chalk_ir::Scalar::*;\n-        use chalk_ir::TypeName::*;\n+        use chalk_ir::TyKind::*;\n \n         let trait_def_id = auto_trait_id.0;\n         let all_impls = self.interner.tcx.all_impls(trait_def_id);\n         for impl_def_id in all_impls {\n             let trait_ref = self.interner.tcx.impl_trait_ref(impl_def_id).unwrap();\n             let self_ty = trait_ref.self_ty();\n-            let provides = match (self_ty.kind(), app_ty.name) {\n-                (&ty::Adt(impl_adt_def, ..), Adt(id)) => impl_adt_def.did == id.0.did,\n-                (_, AssociatedType(_ty_id)) => {\n+            let provides = match (self_ty.kind(), chalk_ty) {\n+                (&ty::Adt(impl_adt_def, ..), Adt(id, ..)) => impl_adt_def.did == id.0.did,\n+                (_, AssociatedType(_ty_id, ..)) => {\n                     // FIXME(chalk): See https://github.com/rust-lang/rust/pull/77152#discussion_r494484774\n                     false\n                 }\n@@ -365,28 +367,30 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                     (ast::FloatTy::F32, chalk_ir::FloatTy::F32)\n                         | (ast::FloatTy::F64, chalk_ir::FloatTy::F64)\n                 ),\n-                (&ty::Tuple(..), Tuple(..)) => true,\n-                (&ty::Array(..), Array) => true,\n-                (&ty::Slice(..), Slice) => true,\n-                (&ty::RawPtr(type_and_mut), Raw(mutability)) => {\n+                (&ty::Tuple(substs), Tuple(len, _)) => substs.len() == *len,\n+                (&ty::Array(..), Array(..)) => true,\n+                (&ty::Slice(..), Slice(..)) => true,\n+                (&ty::RawPtr(type_and_mut), Raw(mutability, _)) => {\n                     match (type_and_mut.mutbl, mutability) {\n                         (ast::Mutability::Mut, chalk_ir::Mutability::Mut) => true,\n                         (ast::Mutability::Mut, chalk_ir::Mutability::Not) => false,\n                         (ast::Mutability::Not, chalk_ir::Mutability::Mut) => false,\n                         (ast::Mutability::Not, chalk_ir::Mutability::Not) => true,\n                     }\n                 }\n-                (&ty::Ref(.., mutability1), Ref(mutability2)) => match (mutability1, mutability2) {\n-                    (ast::Mutability::Mut, chalk_ir::Mutability::Mut) => true,\n-                    (ast::Mutability::Mut, chalk_ir::Mutability::Not) => false,\n-                    (ast::Mutability::Not, chalk_ir::Mutability::Mut) => false,\n-                    (ast::Mutability::Not, chalk_ir::Mutability::Not) => true,\n-                },\n-                (&ty::Opaque(def_id, ..), OpaqueType(opaque_ty_id)) => def_id == opaque_ty_id.0,\n-                (&ty::FnDef(def_id, ..), FnDef(fn_def_id)) => def_id == fn_def_id.0,\n+                (&ty::Ref(.., mutability1), Ref(mutability2, ..)) => {\n+                    match (mutability1, mutability2) {\n+                        (ast::Mutability::Mut, chalk_ir::Mutability::Mut) => true,\n+                        (ast::Mutability::Mut, chalk_ir::Mutability::Not) => false,\n+                        (ast::Mutability::Not, chalk_ir::Mutability::Mut) => false,\n+                        (ast::Mutability::Not, chalk_ir::Mutability::Not) => true,\n+                    }\n+                }\n+                (&ty::Opaque(def_id, ..), OpaqueType(opaque_ty_id, ..)) => def_id == opaque_ty_id.0,\n+                (&ty::FnDef(def_id, ..), FnDef(fn_def_id, ..)) => def_id == fn_def_id.0,\n                 (&ty::Str, Str) => true,\n                 (&ty::Never, Never) => true,\n-                (&ty::Closure(def_id, ..), Closure(closure_id)) => def_id == closure_id.0,\n+                (&ty::Closure(def_id, ..), Closure(closure_id, _)) => def_id == closure_id.0,\n                 (&ty::Foreign(def_id), Foreign(foreign_def_id)) => def_id == foreign_def_id.0,\n                 (&ty::Error(..), Error) => false,\n                 _ => false,\n@@ -404,24 +408,38 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> Arc<chalk_solve::rust_ir::AssociatedTyValue<RustInterner<'tcx>>> {\n         let def_id = associated_ty_id.0;\n         let assoc_item = self.interner.tcx.associated_item(def_id);\n-        let impl_id = match assoc_item.container {\n-            AssocItemContainer::TraitContainer(def_id) => def_id,\n-            _ => unimplemented!(\"Not possible??\"),\n+        let (impl_id, trait_id) = match assoc_item.container {\n+            AssocItemContainer::TraitContainer(def_id) => (def_id, def_id),\n+            AssocItemContainer::ImplContainer(def_id) => {\n+                (def_id, self.interner.tcx.impl_trait_ref(def_id).unwrap().def_id)\n+            }\n         };\n         match assoc_item.kind {\n             AssocKind::Type => {}\n             _ => unimplemented!(\"Not possible??\"),\n         }\n+\n+        let trait_item = self\n+            .interner\n+            .tcx\n+            .associated_items(trait_id)\n+            .find_by_name_and_kind(self.interner.tcx, assoc_item.ident, assoc_item.kind, trait_id)\n+            .unwrap();\n         let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n-        let ty = self.interner.tcx.type_of(def_id);\n+        let ty = self\n+            .interner\n+            .tcx\n+            .type_of(def_id)\n+            .subst(self.interner.tcx, bound_vars)\n+            .lower_into(&self.interner);\n \n         Arc::new(chalk_solve::rust_ir::AssociatedTyValue {\n             impl_id: chalk_ir::ImplId(impl_id),\n-            associated_ty_id: chalk_ir::AssocTypeId(def_id),\n+            associated_ty_id: chalk_ir::AssocTypeId(trait_item.def_id),\n             value: chalk_ir::Binders::new(\n                 binders,\n-                chalk_solve::rust_ir::AssociatedTyValueBound { ty: ty.lower_into(&self.interner) },\n+                chalk_solve::rust_ir::AssociatedTyValueBound { ty },\n             ),\n         })\n     }\n@@ -441,19 +459,61 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         &self,\n         opaque_ty_id: chalk_ir::OpaqueTyId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::OpaqueTyDatum<RustInterner<'tcx>>> {\n-        let bound_vars = bound_vars_for_item(self.interner.tcx, opaque_ty_id.0);\n-        let binders = binders_for(&self.interner, bound_vars);\n+        let bound_vars = ty::fold::shift_vars(\n+            self.interner.tcx,\n+            &bound_vars_for_item(self.interner.tcx, opaque_ty_id.0),\n+            1,\n+        );\n         let where_clauses = self.where_clauses_for(opaque_ty_id.0, bound_vars);\n-        let bounds = self.bounds_for(opaque_ty_id.0, bound_vars);\n+\n+        let identity_substs = InternalSubsts::identity_for_item(self.interner.tcx, opaque_ty_id.0);\n+\n+        let bounds =\n+            self.interner\n+                .tcx\n+                .explicit_item_bounds(opaque_ty_id.0)\n+                .iter()\n+                .map(|(bound, _)| bound.subst(self.interner.tcx, &bound_vars))\n+                .map(|bound| {\n+                    bound.fold_with(&mut ty::fold::BottomUpFolder {\n+                        tcx: self.interner.tcx,\n+                        ty_op: |ty| {\n+                            if let ty::Opaque(def_id, substs) = *ty.kind() {\n+                                if def_id == opaque_ty_id.0 && substs == identity_substs {\n+                                    return self.interner.tcx.mk_ty(ty::Bound(\n+                                        ty::INNERMOST,\n+                                        ty::BoundTy::from(ty::BoundVar::from_u32(0)),\n+                                    ));\n+                                }\n+                            }\n+                            ty\n+                        },\n+                        lt_op: |lt| lt,\n+                        ct_op: |ct| ct,\n+                    })\n+                })\n+                .filter_map(|bound| {\n+                    LowerInto::<\n+                    Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>\n+                >::lower_into(bound, &self.interner)\n+                })\n+                .collect();\n+\n+        // Binder for the bound variable representing the concrete impl Trait type.\n+        let existential_binder = chalk_ir::VariableKinds::from1(\n+            &self.interner,\n+            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n+        );\n \n         let value = chalk_solve::rust_ir::OpaqueTyDatumBound {\n-            bounds: chalk_ir::Binders::new(binders.clone(), bounds),\n-            where_clauses: chalk_ir::Binders::new(binders, where_clauses),\n+            bounds: chalk_ir::Binders::new(existential_binder.clone(), bounds),\n+            where_clauses: chalk_ir::Binders::new(existential_binder, where_clauses),\n         };\n \n+        let binders = binders_for(&self.interner, bound_vars);\n         Arc::new(chalk_solve::rust_ir::OpaqueTyDatum {\n             opaque_ty_id,\n-            bound: chalk_ir::Binders::empty(&self.interner, value),\n+            bound: chalk_ir::Binders::new(binders, value),\n         })\n     }\n \n@@ -506,17 +566,11 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         substs: &chalk_ir::Substitution<RustInterner<'tcx>>,\n     ) -> chalk_solve::rust_ir::ClosureKind {\n         let kind = &substs.as_slice(&self.interner)[substs.len(&self.interner) - 3];\n-        match kind.assert_ty_ref(&self.interner).data(&self.interner) {\n-            chalk_ir::TyData::Apply(apply) => match apply.name {\n-                chalk_ir::TypeName::Scalar(scalar) => match scalar {\n-                    chalk_ir::Scalar::Int(int_ty) => match int_ty {\n-                        chalk_ir::IntTy::I8 => chalk_solve::rust_ir::ClosureKind::Fn,\n-                        chalk_ir::IntTy::I16 => chalk_solve::rust_ir::ClosureKind::FnMut,\n-                        chalk_ir::IntTy::I32 => chalk_solve::rust_ir::ClosureKind::FnOnce,\n-                        _ => bug!(\"bad closure kind\"),\n-                    },\n-                    _ => bug!(\"bad closure kind\"),\n-                },\n+        match kind.assert_ty_ref(&self.interner).kind(&self.interner) {\n+            chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Int(int_ty)) => match int_ty {\n+                chalk_ir::IntTy::I8 => chalk_solve::rust_ir::ClosureKind::Fn,\n+                chalk_ir::IntTy::I16 => chalk_solve::rust_ir::ClosureKind::FnMut,\n+                chalk_ir::IntTy::I32 => chalk_solve::rust_ir::ClosureKind::FnOnce,\n                 _ => bug!(\"bad closure kind\"),\n             },\n             _ => bug!(\"bad closure kind\"),\n@@ -530,23 +584,19 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> chalk_ir::Binders<chalk_solve::rust_ir::FnDefInputsAndOutputDatum<RustInterner<'tcx>>>\n     {\n         let sig = &substs.as_slice(&self.interner)[substs.len(&self.interner) - 2];\n-        match sig.assert_ty_ref(&self.interner).data(&self.interner) {\n-            chalk_ir::TyData::Function(f) => {\n+        match sig.assert_ty_ref(&self.interner).kind(&self.interner) {\n+            chalk_ir::TyKind::Function(f) => {\n                 let substitution = f.substitution.as_slice(&self.interner);\n                 let return_type =\n                     substitution.last().unwrap().assert_ty_ref(&self.interner).clone();\n                 // Closure arguments are tupled\n                 let argument_tuple = substitution[0].assert_ty_ref(&self.interner);\n-                let argument_types = match argument_tuple.data(&self.interner) {\n-                    chalk_ir::TyData::Apply(apply) => match apply.name {\n-                        chalk_ir::TypeName::Tuple(_) => apply\n-                            .substitution\n-                            .iter(&self.interner)\n-                            .map(|arg| arg.assert_ty_ref(&self.interner))\n-                            .cloned()\n-                            .collect(),\n-                        _ => bug!(\"Expecting closure FnSig args to be tupled.\"),\n-                    },\n+                let argument_types = match argument_tuple.kind(&self.interner) {\n+                    chalk_ir::TyKind::Tuple(_len, substitution) => substitution\n+                        .iter(&self.interner)\n+                        .map(|arg| arg.assert_ty_ref(&self.interner))\n+                        .cloned()\n+                        .collect(),\n                     _ => bug!(\"Expecting closure FnSig args to be tupled.\"),\n                 };\n \n@@ -637,7 +687,7 @@ fn binders_for<'tcx>(\n         bound_vars.iter().map(|arg| match arg.unpack() {\n             ty::subst::GenericArgKind::Lifetime(_re) => chalk_ir::VariableKind::Lifetime,\n             ty::subst::GenericArgKind::Type(_ty) => {\n-                chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General)\n+                chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General)\n             }\n             ty::subst::GenericArgKind::Const(c) => {\n                 chalk_ir::VariableKind::Const(c.ty.lower_into(interner))"}, {"sha": "c4e2c7f839d70141dc310d1c999ef1a21b43efa0", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 171, "deletions": 210, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -31,11 +31,12 @@\n //! not. To lower anything wrapped in a `Binder`, we first deeply find any bound\n //! variables from the current `Binder`.\n \n+use rustc_ast::ast;\n use rustc_middle::traits::{ChalkEnvironmentAndGoal, ChalkRustInterner as RustInterner};\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{\n-    self, Binder, BoundRegion, Region, RegionKind, Ty, TyCtxt, TyKind, TypeFoldable, TypeVisitor,\n+    self, Binder, BoundRegion, Region, RegionKind, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n };\n use rustc_span::def_id::DefId;\n \n@@ -240,113 +241,60 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::AliasEq<RustInterner<'tcx>>>\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Ty<RustInterner<'tcx>> {\n-        use chalk_ir::TyData;\n         use rustc_ast as ast;\n-        use TyKind::*;\n \n-        let empty = || chalk_ir::Substitution::empty(interner);\n-        let struct_ty =\n-            |def_id| chalk_ir::TypeName::Adt(chalk_ir::AdtId(interner.tcx.adt_def(def_id)));\n-        let apply = |name, substitution| {\n-            TyData::Apply(chalk_ir::ApplicationTy { name, substitution }).intern(interner)\n-        };\n-        let int = |i| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Int(i)), empty());\n-        let uint = |i| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Uint(i)), empty());\n-        let float = |f| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Float(f)), empty());\n+        let int = |i| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Int(i));\n+        let uint = |i| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Uint(i));\n+        let float = |f| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Float(f));\n \n         match *self.kind() {\n-            Bool => apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Bool), empty()),\n-            Char => apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Char), empty()),\n-            Int(ty) => match ty {\n+            ty::Bool => chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Bool),\n+            ty::Char => chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Char),\n+            ty::Int(ty) => match ty {\n                 ast::IntTy::Isize => int(chalk_ir::IntTy::Isize),\n                 ast::IntTy::I8 => int(chalk_ir::IntTy::I8),\n                 ast::IntTy::I16 => int(chalk_ir::IntTy::I16),\n                 ast::IntTy::I32 => int(chalk_ir::IntTy::I32),\n                 ast::IntTy::I64 => int(chalk_ir::IntTy::I64),\n                 ast::IntTy::I128 => int(chalk_ir::IntTy::I128),\n             },\n-            Uint(ty) => match ty {\n+            ty::Uint(ty) => match ty {\n                 ast::UintTy::Usize => uint(chalk_ir::UintTy::Usize),\n                 ast::UintTy::U8 => uint(chalk_ir::UintTy::U8),\n                 ast::UintTy::U16 => uint(chalk_ir::UintTy::U16),\n                 ast::UintTy::U32 => uint(chalk_ir::UintTy::U32),\n                 ast::UintTy::U64 => uint(chalk_ir::UintTy::U64),\n                 ast::UintTy::U128 => uint(chalk_ir::UintTy::U128),\n             },\n-            Float(ty) => match ty {\n+            ty::Float(ty) => match ty {\n                 ast::FloatTy::F32 => float(chalk_ir::FloatTy::F32),\n                 ast::FloatTy::F64 => float(chalk_ir::FloatTy::F64),\n             },\n-            Adt(def, substs) => apply(struct_ty(def.did), substs.lower_into(interner)),\n-            Foreign(def_id) => apply(chalk_ir::TypeName::Foreign(ForeignDefId(def_id)), empty()),\n-            Str => apply(chalk_ir::TypeName::Str, empty()),\n-            Array(ty, len) => {\n-                let value = match len.val {\n-                    ty::ConstKind::Value(val) => {\n-                        chalk_ir::ConstValue::Concrete(chalk_ir::ConcreteConst { interned: val })\n-                    }\n-                    ty::ConstKind::Bound(db, bound) => {\n-                        chalk_ir::ConstValue::BoundVar(chalk_ir::BoundVar::new(\n-                            chalk_ir::DebruijnIndex::new(db.as_u32()),\n-                            bound.index(),\n-                        ))\n-                    }\n-                    _ => unimplemented!(\"Const not implemented. {:?}\", len.val),\n-                };\n-                apply(\n-                    chalk_ir::TypeName::Array,\n-                    chalk_ir::Substitution::from_iter(\n-                        interner,\n-                        &[\n-                            chalk_ir::GenericArgData::Ty(ty.lower_into(interner)).intern(interner),\n-                            chalk_ir::GenericArgData::Const(\n-                                chalk_ir::ConstData { ty: len.ty.lower_into(interner), value }\n-                                    .intern(interner),\n-                            )\n-                            .intern(interner),\n-                        ],\n-                    ),\n-                )\n+            ty::Adt(def, substs) => {\n+                chalk_ir::TyKind::Adt(chalk_ir::AdtId(def), substs.lower_into(interner))\n             }\n-            Slice(ty) => apply(\n-                chalk_ir::TypeName::Slice,\n-                chalk_ir::Substitution::from1(\n-                    interner,\n-                    chalk_ir::GenericArgData::Ty(ty.lower_into(interner)).intern(interner),\n-                ),\n-            ),\n-            RawPtr(ptr) => {\n-                let name = match ptr.mutbl {\n-                    ast::Mutability::Mut => chalk_ir::TypeName::Raw(chalk_ir::Mutability::Mut),\n-                    ast::Mutability::Not => chalk_ir::TypeName::Raw(chalk_ir::Mutability::Not),\n-                };\n-                apply(name, chalk_ir::Substitution::from1(interner, ptr.ty.lower_into(interner)))\n+            ty::Foreign(def_id) => chalk_ir::TyKind::Foreign(ForeignDefId(def_id)),\n+            ty::Str => chalk_ir::TyKind::Str,\n+            ty::Array(ty, len) => {\n+                chalk_ir::TyKind::Array(ty.lower_into(interner), len.lower_into(interner))\n             }\n-            Ref(region, ty, mutability) => {\n-                let name = match mutability {\n-                    ast::Mutability::Mut => chalk_ir::TypeName::Ref(chalk_ir::Mutability::Mut),\n-                    ast::Mutability::Not => chalk_ir::TypeName::Ref(chalk_ir::Mutability::Not),\n-                };\n-                apply(\n-                    name,\n-                    chalk_ir::Substitution::from_iter(\n-                        interner,\n-                        &[\n-                            chalk_ir::GenericArgData::Lifetime(region.lower_into(interner))\n-                                .intern(interner),\n-                            chalk_ir::GenericArgData::Ty(ty.lower_into(interner)).intern(interner),\n-                        ],\n-                    ),\n-                )\n+            ty::Slice(ty) => chalk_ir::TyKind::Slice(ty.lower_into(interner)),\n+\n+            ty::RawPtr(ptr) => {\n+                chalk_ir::TyKind::Raw(ptr.mutbl.lower_into(interner), ptr.ty.lower_into(interner))\n             }\n-            FnDef(def_id, substs) => apply(\n-                chalk_ir::TypeName::FnDef(chalk_ir::FnDefId(def_id)),\n-                substs.lower_into(interner),\n+            ty::Ref(region, ty, mutability) => chalk_ir::TyKind::Ref(\n+                mutability.lower_into(interner),\n+                region.lower_into(interner),\n+                ty.lower_into(interner),\n             ),\n-            FnPtr(sig) => {\n+            ty::FnDef(def_id, substs) => {\n+                chalk_ir::TyKind::FnDef(chalk_ir::FnDefId(def_id), substs.lower_into(interner))\n+            }\n+            ty::FnPtr(sig) => {\n                 let (inputs_and_outputs, binders, _named_regions) =\n                     collect_bound_vars(interner, interner.tcx, &sig.inputs_and_output());\n-                TyData::Function(chalk_ir::FnPointer {\n+                chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n                     num_binders: binders.len(interner),\n                     sig: sig.lower_into(interner),\n                     substitution: chalk_ir::Substitution::from_iter(\n@@ -356,148 +304,115 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                         }),\n                     ),\n                 })\n-                .intern(interner)\n             }\n-            Dynamic(predicates, region) => TyData::Dyn(chalk_ir::DynTy {\n+            ty::Dynamic(predicates, region) => chalk_ir::TyKind::Dyn(chalk_ir::DynTy {\n                 bounds: predicates.lower_into(interner),\n                 lifetime: region.lower_into(interner),\n-            })\n-            .intern(interner),\n-            Closure(def_id, substs) => apply(\n-                chalk_ir::TypeName::Closure(chalk_ir::ClosureId(def_id)),\n-                substs.lower_into(interner),\n-            ),\n-            Generator(_def_id, _substs, _) => unimplemented!(),\n-            GeneratorWitness(_) => unimplemented!(),\n-            Never => apply(chalk_ir::TypeName::Never, empty()),\n-            Tuple(substs) => {\n-                apply(chalk_ir::TypeName::Tuple(substs.len()), substs.lower_into(interner))\n+            }),\n+            ty::Closure(def_id, substs) => {\n+                chalk_ir::TyKind::Closure(chalk_ir::ClosureId(def_id), substs.lower_into(interner))\n             }\n-            Projection(proj) => TyData::Alias(proj.lower_into(interner)).intern(interner),\n-            Opaque(def_id, substs) => {\n-                TyData::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n+            ty::Generator(_def_id, _substs, _) => unimplemented!(),\n+            ty::GeneratorWitness(_) => unimplemented!(),\n+            ty::Never => chalk_ir::TyKind::Never,\n+            ty::Tuple(substs) => chalk_ir::TyKind::Tuple(substs.len(), substs.lower_into(interner)),\n+            ty::Projection(proj) => chalk_ir::TyKind::Alias(proj.lower_into(interner)),\n+            ty::Opaque(def_id, substs) => {\n+                chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n                     opaque_ty_id: chalk_ir::OpaqueTyId(def_id),\n                     substitution: substs.lower_into(interner),\n                 }))\n-                .intern(interner)\n             }\n             // This should have been done eagerly prior to this, and all Params\n             // should have been substituted to placeholders\n-            Param(_) => panic!(\"Lowering Param when not expected.\"),\n-            Bound(db, bound) => TyData::BoundVar(chalk_ir::BoundVar::new(\n+            ty::Param(_) => panic!(\"Lowering Param when not expected.\"),\n+            ty::Bound(db, bound) => chalk_ir::TyKind::BoundVar(chalk_ir::BoundVar::new(\n                 chalk_ir::DebruijnIndex::new(db.as_u32()),\n                 bound.var.index(),\n-            ))\n-            .intern(interner),\n-            Placeholder(_placeholder) => TyData::Placeholder(chalk_ir::PlaceholderIndex {\n-                ui: chalk_ir::UniverseIndex { counter: _placeholder.universe.as_usize() },\n-                idx: _placeholder.name.as_usize(),\n-            })\n-            .intern(interner),\n-            Infer(_infer) => unimplemented!(),\n-            Error(_) => apply(chalk_ir::TypeName::Error, empty()),\n+            )),\n+            ty::Placeholder(_placeholder) => {\n+                chalk_ir::TyKind::Placeholder(chalk_ir::PlaceholderIndex {\n+                    ui: chalk_ir::UniverseIndex { counter: _placeholder.universe.as_usize() },\n+                    idx: _placeholder.name.as_usize(),\n+                })\n+            }\n+            ty::Infer(_infer) => unimplemented!(),\n+            ty::Error(_) => chalk_ir::TyKind::Error,\n         }\n+        .intern(interner)\n     }\n }\n \n impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> Ty<'tcx> {\n-        use chalk_ir::TyData;\n-        use rustc_ast::ast;\n+        use chalk_ir::TyKind;\n \n-        let kind = match self.data(interner) {\n-            TyData::Apply(application_ty) => match application_ty.name {\n-                chalk_ir::TypeName::Adt(struct_id) => {\n-                    ty::Adt(struct_id.0, application_ty.substitution.lower_into(interner))\n-                }\n-                chalk_ir::TypeName::Scalar(scalar) => match scalar {\n-                    chalk_ir::Scalar::Bool => ty::Bool,\n-                    chalk_ir::Scalar::Char => ty::Char,\n-                    chalk_ir::Scalar::Int(int_ty) => match int_ty {\n-                        chalk_ir::IntTy::Isize => ty::Int(ast::IntTy::Isize),\n-                        chalk_ir::IntTy::I8 => ty::Int(ast::IntTy::I8),\n-                        chalk_ir::IntTy::I16 => ty::Int(ast::IntTy::I16),\n-                        chalk_ir::IntTy::I32 => ty::Int(ast::IntTy::I32),\n-                        chalk_ir::IntTy::I64 => ty::Int(ast::IntTy::I64),\n-                        chalk_ir::IntTy::I128 => ty::Int(ast::IntTy::I128),\n-                    },\n-                    chalk_ir::Scalar::Uint(int_ty) => match int_ty {\n-                        chalk_ir::UintTy::Usize => ty::Uint(ast::UintTy::Usize),\n-                        chalk_ir::UintTy::U8 => ty::Uint(ast::UintTy::U8),\n-                        chalk_ir::UintTy::U16 => ty::Uint(ast::UintTy::U16),\n-                        chalk_ir::UintTy::U32 => ty::Uint(ast::UintTy::U32),\n-                        chalk_ir::UintTy::U64 => ty::Uint(ast::UintTy::U64),\n-                        chalk_ir::UintTy::U128 => ty::Uint(ast::UintTy::U128),\n-                    },\n-                    chalk_ir::Scalar::Float(float_ty) => match float_ty {\n-                        chalk_ir::FloatTy::F32 => ty::Float(ast::FloatTy::F32),\n-                        chalk_ir::FloatTy::F64 => ty::Float(ast::FloatTy::F64),\n-                    },\n+        let kind = match self.kind(interner) {\n+            TyKind::Adt(struct_id, substitution) => {\n+                ty::Adt(struct_id.0, substitution.lower_into(interner))\n+            }\n+            TyKind::Scalar(scalar) => match scalar {\n+                chalk_ir::Scalar::Bool => ty::Bool,\n+                chalk_ir::Scalar::Char => ty::Char,\n+                chalk_ir::Scalar::Int(int_ty) => match int_ty {\n+                    chalk_ir::IntTy::Isize => ty::Int(ast::IntTy::Isize),\n+                    chalk_ir::IntTy::I8 => ty::Int(ast::IntTy::I8),\n+                    chalk_ir::IntTy::I16 => ty::Int(ast::IntTy::I16),\n+                    chalk_ir::IntTy::I32 => ty::Int(ast::IntTy::I32),\n+                    chalk_ir::IntTy::I64 => ty::Int(ast::IntTy::I64),\n+                    chalk_ir::IntTy::I128 => ty::Int(ast::IntTy::I128),\n+                },\n+                chalk_ir::Scalar::Uint(int_ty) => match int_ty {\n+                    chalk_ir::UintTy::Usize => ty::Uint(ast::UintTy::Usize),\n+                    chalk_ir::UintTy::U8 => ty::Uint(ast::UintTy::U8),\n+                    chalk_ir::UintTy::U16 => ty::Uint(ast::UintTy::U16),\n+                    chalk_ir::UintTy::U32 => ty::Uint(ast::UintTy::U32),\n+                    chalk_ir::UintTy::U64 => ty::Uint(ast::UintTy::U64),\n+                    chalk_ir::UintTy::U128 => ty::Uint(ast::UintTy::U128),\n+                },\n+                chalk_ir::Scalar::Float(float_ty) => match float_ty {\n+                    chalk_ir::FloatTy::F32 => ty::Float(ast::FloatTy::F32),\n+                    chalk_ir::FloatTy::F64 => ty::Float(ast::FloatTy::F64),\n                 },\n-                chalk_ir::TypeName::Array => {\n-                    let substs = application_ty.substitution.as_slice(interner);\n-                    let ty = substs[0].assert_ty_ref(interner).lower_into(interner);\n-                    let c = substs[1].assert_const_ref(interner).lower_into(interner);\n-                    ty::Array(ty, interner.tcx.mk_const(c))\n-                }\n-                chalk_ir::TypeName::FnDef(id) => {\n-                    ty::FnDef(id.0, application_ty.substitution.lower_into(interner))\n-                }\n-                chalk_ir::TypeName::Closure(closure) => {\n-                    ty::Closure(closure.0, application_ty.substitution.lower_into(interner))\n-                }\n-                chalk_ir::TypeName::Generator(_) => unimplemented!(),\n-                chalk_ir::TypeName::GeneratorWitness(_) => unimplemented!(),\n-                chalk_ir::TypeName::Never => ty::Never,\n-                chalk_ir::TypeName::Tuple(_size) => {\n-                    ty::Tuple(application_ty.substitution.lower_into(interner))\n-                }\n-                chalk_ir::TypeName::Slice => ty::Slice(\n-                    application_ty.substitution.as_slice(interner)[0]\n-                        .ty(interner)\n-                        .unwrap()\n-                        .lower_into(interner),\n-                ),\n-                chalk_ir::TypeName::Raw(mutbl) => ty::RawPtr(ty::TypeAndMut {\n-                    ty: application_ty.substitution.as_slice(interner)[0]\n-                        .ty(interner)\n-                        .unwrap()\n-                        .lower_into(interner),\n-                    mutbl: match mutbl {\n-                        chalk_ir::Mutability::Mut => ast::Mutability::Mut,\n-                        chalk_ir::Mutability::Not => ast::Mutability::Not,\n-                    },\n-                }),\n-                chalk_ir::TypeName::Ref(mutbl) => ty::Ref(\n-                    application_ty.substitution.as_slice(interner)[0]\n-                        .lifetime(interner)\n-                        .unwrap()\n-                        .lower_into(interner),\n-                    application_ty.substitution.as_slice(interner)[1]\n-                        .ty(interner)\n-                        .unwrap()\n-                        .lower_into(interner),\n-                    match mutbl {\n-                        chalk_ir::Mutability::Mut => ast::Mutability::Mut,\n-                        chalk_ir::Mutability::Not => ast::Mutability::Not,\n-                    },\n-                ),\n-                chalk_ir::TypeName::Str => ty::Str,\n-                chalk_ir::TypeName::OpaqueType(opaque_ty) => {\n-                    ty::Opaque(opaque_ty.0, application_ty.substitution.lower_into(interner))\n-                }\n-                chalk_ir::TypeName::AssociatedType(assoc_ty) => ty::Projection(ty::ProjectionTy {\n-                    substs: application_ty.substitution.lower_into(interner),\n-                    item_def_id: assoc_ty.0,\n-                }),\n-                chalk_ir::TypeName::Foreign(def_id) => ty::Foreign(def_id.0),\n-                chalk_ir::TypeName::Error => unimplemented!(),\n             },\n-            TyData::Placeholder(placeholder) => ty::Placeholder(ty::Placeholder {\n+            TyKind::Array(ty, c) => {\n+                let ty = ty.lower_into(interner);\n+                let c = c.lower_into(interner);\n+                ty::Array(ty, interner.tcx.mk_const(c))\n+            }\n+            TyKind::FnDef(id, substitution) => ty::FnDef(id.0, substitution.lower_into(interner)),\n+            TyKind::Closure(closure, substitution) => {\n+                ty::Closure(closure.0, substitution.lower_into(interner))\n+            }\n+            TyKind::Generator(..) => unimplemented!(),\n+            TyKind::GeneratorWitness(..) => unimplemented!(),\n+            TyKind::Never => ty::Never,\n+            TyKind::Tuple(_len, substitution) => ty::Tuple(substitution.lower_into(interner)),\n+            TyKind::Slice(ty) => ty::Slice(ty.lower_into(interner)),\n+            TyKind::Raw(mutbl, ty) => ty::RawPtr(ty::TypeAndMut {\n+                ty: ty.lower_into(interner),\n+                mutbl: mutbl.lower_into(interner),\n+            }),\n+            TyKind::Ref(mutbl, lifetime, ty) => ty::Ref(\n+                lifetime.lower_into(interner),\n+                ty.lower_into(interner),\n+                mutbl.lower_into(interner),\n+            ),\n+            TyKind::Str => ty::Str,\n+            TyKind::OpaqueType(opaque_ty, substitution) => {\n+                ty::Opaque(opaque_ty.0, substitution.lower_into(interner))\n+            }\n+            TyKind::AssociatedType(assoc_ty, substitution) => ty::Projection(ty::ProjectionTy {\n+                substs: substitution.lower_into(interner),\n+                item_def_id: assoc_ty.0,\n+            }),\n+            TyKind::Foreign(def_id) => ty::Foreign(def_id.0),\n+            TyKind::Error => return interner.tcx.ty_error(),\n+            TyKind::Placeholder(placeholder) => ty::Placeholder(ty::Placeholder {\n                 universe: ty::UniverseIndex::from_usize(placeholder.ui.counter),\n                 name: ty::BoundVar::from_usize(placeholder.idx),\n             }),\n-            chalk_ir::TyData::Alias(alias_ty) => match alias_ty {\n+            TyKind::Alias(alias_ty) => match alias_ty {\n                 chalk_ir::AliasTy::Projection(projection) => ty::Projection(ty::ProjectionTy {\n                     item_def_id: projection.associated_ty_id.0,\n                     substs: projection.substitution.lower_into(interner),\n@@ -506,16 +421,16 @@ impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n                     ty::Opaque(opaque.opaque_ty_id.0, opaque.substitution.lower_into(interner))\n                 }\n             },\n-            TyData::Function(_quantified_ty) => unimplemented!(),\n-            TyData::BoundVar(_bound) => ty::Bound(\n+            TyKind::Function(_quantified_ty) => unimplemented!(),\n+            TyKind::BoundVar(_bound) => ty::Bound(\n                 ty::DebruijnIndex::from_usize(_bound.debruijn.depth() as usize),\n                 ty::BoundTy {\n                     var: ty::BoundVar::from_usize(_bound.index),\n                     kind: ty::BoundTyKind::Anon,\n                 },\n             ),\n-            TyData::InferenceVar(_, _) => unimplemented!(),\n-            TyData::Dyn(_) => unimplemented!(),\n+            TyKind::InferenceVar(_, _) => unimplemented!(),\n+            TyKind::Dyn(_) => unimplemented!(),\n         };\n         interner.tcx.mk_ty(kind)\n     }\n@@ -706,8 +621,16 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<RustInterner<'tcx>>> {\n+        // `Self` has one binder:\n+        // Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>\n+        // The return type has two:\n+        // Binders<&[Binders<WhereClause<I>>]>\n+        // This means that any variables that are escaping `self` need to be\n+        // shifted in by one so that they are still escaping.\n+        let shifted_predicates = ty::fold::shift_vars(interner.tcx, &self, 1);\n+\n         let (predicates, binders, _named_regions) =\n-            collect_bound_vars(interner, interner.tcx, &self);\n+            collect_bound_vars(interner, interner.tcx, &shifted_predicates);\n         let self_ty = interner.tcx.mk_ty(ty::Bound(\n             // This is going to be wrapped in a binder\n             ty::DebruijnIndex::from_usize(1),\n@@ -716,7 +639,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n         let where_clauses = predicates.into_iter().map(|predicate| match predicate {\n             ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef { def_id, substs }) => {\n                 chalk_ir::Binders::new(\n-                    chalk_ir::VariableKinds::empty(interner),\n+                    binders.clone(),\n                     chalk_ir::WhereClause::Implemented(chalk_ir::TraitRef {\n                         trait_id: chalk_ir::TraitId(def_id),\n                         substitution: interner\n@@ -727,25 +650,34 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n                 )\n             }\n             ty::ExistentialPredicate::Projection(predicate) => chalk_ir::Binders::new(\n-                chalk_ir::VariableKinds::empty(interner),\n+                binders.clone(),\n                 chalk_ir::WhereClause::AliasEq(chalk_ir::AliasEq {\n                     alias: chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n                         associated_ty_id: chalk_ir::AssocTypeId(predicate.item_def_id),\n-                        substitution: predicate.substs.lower_into(interner),\n+                        substitution: interner\n+                            .tcx\n+                            .mk_substs_trait(self_ty, predicate.substs)\n+                            .lower_into(interner),\n                     }),\n                     ty: predicate.ty.lower_into(interner),\n                 }),\n             ),\n             ty::ExistentialPredicate::AutoTrait(def_id) => chalk_ir::Binders::new(\n-                chalk_ir::VariableKinds::empty(interner),\n+                binders.clone(),\n                 chalk_ir::WhereClause::Implemented(chalk_ir::TraitRef {\n                     trait_id: chalk_ir::TraitId(def_id),\n                     substitution: interner.tcx.mk_substs_trait(self_ty, &[]).lower_into(interner),\n                 }),\n             ),\n         });\n+\n+        // Binder for the bound variable representing the concrete underlying type.\n+        let existential_binder = chalk_ir::VariableKinds::from1(\n+            interner,\n+            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n+        );\n         let value = chalk_ir::QuantifiedWhereClauses::from_iter(interner, where_clauses);\n-        chalk_ir::Binders::new(binders, value)\n+        chalk_ir::Binders::new(existential_binder, value)\n     }\n }\n \n@@ -818,6 +750,35 @@ impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::TraitBound<RustInterner<'tcx>>>\n     }\n }\n \n+impl<'tcx> LowerInto<'tcx, chalk_ir::Mutability> for ast::Mutability {\n+    fn lower_into(self, _interner: &RustInterner<'tcx>) -> chalk_ir::Mutability {\n+        match self {\n+            rustc_ast::Mutability::Mut => chalk_ir::Mutability::Mut,\n+            rustc_ast::Mutability::Not => chalk_ir::Mutability::Not,\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, ast::Mutability> for chalk_ir::Mutability {\n+    fn lower_into(self, _interner: &RustInterner<'tcx>) -> ast::Mutability {\n+        match self {\n+            chalk_ir::Mutability::Mut => ast::Mutability::Mut,\n+            chalk_ir::Mutability::Not => ast::Mutability::Not,\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::Polarity> for ty::ImplPolarity {\n+    fn lower_into(self, _interner: &RustInterner<'tcx>) -> chalk_solve::rust_ir::Polarity {\n+        match self {\n+            ty::ImplPolarity::Positive => chalk_solve::rust_ir::Polarity::Positive,\n+            ty::ImplPolarity::Negative => chalk_solve::rust_ir::Polarity::Negative,\n+            // FIXME(chalk) reservation impls\n+            ty::ImplPolarity::Reservation => chalk_solve::rust_ir::Polarity::Negative,\n+        }\n+    }\n+}\n+\n impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>>>\n     for ty::ProjectionPredicate<'tcx>\n {\n@@ -910,7 +871,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n                 match self.parameters.entry(bound_ty.var.as_u32()) {\n                     Entry::Vacant(entry) => {\n-                        entry.insert(chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General));\n+                        entry.insert(chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General));\n                     }\n                     Entry::Occupied(entry) => match entry.get() {\n                         chalk_ir::VariableKind::Ty(_) => {}"}, {"sha": "b117e28875e768649238bc790d20a7ebd21b584b", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -69,15 +69,15 @@ crate fn evaluate_goal<'tcx>(\n                     CanonicalVarKind::PlaceholderRegion(_ui) => unimplemented!(),\n                     CanonicalVarKind::Ty(ty) => match ty {\n                         CanonicalTyVarKind::General(ui) => chalk_ir::WithKind::new(\n-                            chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General),\n+                            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n                             chalk_ir::UniverseIndex { counter: ui.index() },\n                         ),\n                         CanonicalTyVarKind::Int => chalk_ir::WithKind::new(\n-                            chalk_ir::VariableKind::Ty(chalk_ir::TyKind::Integer),\n+                            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::Integer),\n                             chalk_ir::UniverseIndex::root(),\n                         ),\n                         CanonicalTyVarKind::Float => chalk_ir::WithKind::new(\n-                            chalk_ir::VariableKind::Ty(chalk_ir::TyKind::Float),\n+                            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::Float),\n                             chalk_ir::UniverseIndex::root(),\n                         ),\n                     },\n@@ -97,7 +97,8 @@ crate fn evaluate_goal<'tcx>(\n     use chalk_solve::Solver;\n     let mut solver = chalk_engine::solve::SLGSolver::new(32, None);\n     let db = ChalkRustIrDatabase { interner, reempty_placeholder };\n-    let solution = chalk_solve::logging::with_tracing_logs(|| solver.solve(&db, &lowered_goal));\n+    let solution = solver.solve(&db, &lowered_goal);\n+    debug!(?obligation, ?solution, \"evaluatate goal\");\n \n     // Ideally, the code to convert *back* to rustc types would live close to\n     // the code to convert *from* rustc types. Right now though, we don't"}, {"sha": "e596dd1a396c910d3c68ce292b139bed2c863b3b", "filename": "compiler/rustc_typeck/src/collect/item_bounds.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -61,23 +61,23 @@ fn opaque_type_bounds<'tcx>(\n     bounds: &'tcx [hir::GenericBound<'tcx>],\n     span: Span,\n ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n-    let item_ty =\n-        tcx.mk_opaque(opaque_def_id, InternalSubsts::identity_for_item(tcx, opaque_def_id));\n+    ty::print::with_no_queries(|| {\n+        let item_ty =\n+            tcx.mk_opaque(opaque_def_id, InternalSubsts::identity_for_item(tcx, opaque_def_id));\n \n-    let bounds = ty::print::with_no_queries(|| {\n-        AstConv::compute_bounds(\n+        let bounds = AstConv::compute_bounds(\n             &ItemCtxt::new(tcx, opaque_def_id),\n             item_ty,\n             bounds,\n             SizedByDefault::Yes,\n             span,\n         )\n-    });\n+        .predicates(tcx, item_ty);\n \n-    let bounds = bounds.predicates(tcx, item_ty);\n-    debug!(\"opaque_type_bounds({}) = {:?}\", tcx.def_path_str(opaque_def_id), bounds);\n+        debug!(\"opaque_type_bounds({}) = {:?}\", tcx.def_path_str(opaque_def_id), bounds);\n \n-    tcx.arena.alloc_slice(&bounds)\n+        tcx.arena.alloc_slice(&bounds)\n+    })\n }\n \n pub(super) fn explicit_item_bounds("}, {"sha": "1dcc5f13415dc8680ee00e119e33c3817c57635c", "filename": "config.toml.example", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -138,6 +138,9 @@ changelog-seen = 2\n # Whether or not to specify `-DLLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN=YES`\n #allow-old-toolchain = false\n \n+# Whether to include the Polly optimizer.\n+#polly = false\n+\n # =============================================================================\n # General build configuration options\n # ============================================================================="}, {"sha": "dbf9031620ee1e7f401edb145ef058efe49041f8", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 326, "deletions": 246, "changes": 572, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -32,7 +32,6 @@ use core::cmp::Ordering;\n use core::marker::PhantomData;\n use core::mem::{self, MaybeUninit};\n use core::ptr::{self, NonNull, Unique};\n-use core::slice;\n \n use crate::alloc::{AllocRef, Global, Layout};\n use crate::boxed::Box;\n@@ -120,11 +119,11 @@ struct BoxedNode<K, V> {\n \n impl<K, V> BoxedNode<K, V> {\n     fn from_leaf(node: Box<LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Box::into_unique(node).0 }\n+        BoxedNode { ptr: Unique::from(Box::leak(node)) }\n     }\n \n     fn from_internal(node: Box<InternalNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::from(&mut Box::leak(node).data) }\n+        BoxedNode { ptr: Unique::from(Box::leak(node)).cast() }\n     }\n \n     fn as_ptr(&self) -> NonNull<LeafNode<K, V>> {\n@@ -189,6 +188,11 @@ impl<K, V> Root<K, V> {\n         NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n     }\n \n+    /// Packs the reference, aware of type and height, into a type-agnostic pointer.\n+    fn into_boxed_node(self) -> BoxedNode<K, V> {\n+        self.node\n+    }\n+\n     /// Adds a new internal node with a single edge pointing to the previous root node,\n     /// make that new node the root node, and return it. This increases the height by 1\n     /// and is the opposite of `pop_internal_level`.\n@@ -218,15 +222,16 @@ impl<K, V> Root<K, V> {\n     pub fn pop_internal_level(&mut self) {\n         assert!(self.height > 0);\n \n-        let top = self.node.ptr;\n+        let top = BoxedNode::as_ptr(&self.node);\n \n         let mut internal_node = unsafe { self.internal_node_as_mut() };\n-        self.node = unsafe { internal_node.as_internal_mut().edges[0].assume_init_read() };\n+        let internal_node = NodeRef::as_internal_mut(&mut internal_node);\n+        self.node = unsafe { internal_node.edges[0].assume_init_read() };\n         self.height -= 1;\n-        self.node_as_mut().as_leaf_mut().parent = None;\n+        self.node_as_mut().clear_parent_link();\n \n         unsafe {\n-            Global.dealloc(NonNull::from(top).cast(), Layout::new::<InternalNode<K, V>>());\n+            Global.dealloc(top.cast(), Layout::new::<InternalNode<K, V>>());\n         }\n     }\n }\n@@ -236,21 +241,49 @@ impl<K, V> Root<K, V> {\n // internal use of `NodeRef` because we stay completely generic over `K` and `V`.\n // However, whenever a public type wraps `NodeRef`, make sure that it has the\n // correct variance.\n+///\n /// A reference to a node.\n ///\n /// This type has a number of parameters that controls how it acts:\n-/// - `BorrowType`: This can be `Immut<'a>`, `Mut<'a>` or `ValMut<'a>' for some `'a`\n-///    or `Owned`.\n-///    When this is `Immut<'a>`, the `NodeRef` acts roughly like `&'a Node`,\n-///    when this is `Mut<'a>`, the `NodeRef` acts roughly like `&'a mut Node`,\n-///    when this is `ValMut<'a>`, the `NodeRef` acts as immutable with respect\n-///    to keys and tree structure, but allows mutable references to values,\n-///    and when this is `Owned`, the `NodeRef` acts roughly like `Box<Node>`.\n-/// - `K` and `V`: These control what types of things are stored in the nodes.\n+/// - `BorrowType`: A dummy type that describes the kind of borrow and carries a lifetime.\n+///    - When this is `Immut<'a>`, the `NodeRef` acts roughly like `&'a Node`.\n+///    - When this is `ValMut<'a>`, the `NodeRef` acts roughly like `&'a Node`\n+///      with respect to keys and tree structure, but also allows many\n+///      mutable references to values throughout the tree to coexist.\n+///    - When this is `Mut<'a>`, the `NodeRef` acts roughly like `&'a mut Node`,\n+///      although insert methods allow a mutable pointer to a value to coexist.\n+///    - When this is `Owned`, the `NodeRef` acts roughly like `Box<Node>`,\n+///      but does not have a destructor, and must be cleaned up manually.\n+/// - `K` and `V`: These are the types of keys and values stored in the nodes.\n /// - `Type`: This can be `Leaf`, `Internal`, or `LeafOrInternal`. When this is\n ///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n ///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n ///   `NodeRef` could be pointing to either type of node.\n+///   `Type` is named `NodeType` when used outside `NodeRef`.\n+///\n+/// Both `BorrowType` and `NodeType` restrict what methods we implement, to\n+/// exploit static type safety. There are limitations in the way we can apply\n+/// such restrictions:\n+/// - For each type parameter, we can only define a method either generically\n+///   or for one particular type. For example, we cannot define a method like\n+///   `key_at` generically for all `BorrowType`, because we want to return\n+///   `&'a K` for most choices of `BorrowType`, but plain `K` for `Owned`.\n+///   We cannot define `key_at` once for all types that have a lifetime.\n+///   Therefore, we define it only for the least powerful type `Immut<'a>`.\n+/// - We cannot get implicit coercion from say `Mut<'a>` to `Immut<'a>`.\n+///   Therefore, we have to explicitly call `reborrow` on a more powerfull\n+///   `NodeRef` in order to reach a method like `key_at`.\n+/// - All methods on `NodeRef` that return some kind of reference, except\n+///   `reborrow` and `reborrow_mut`, take `self` by value and not by reference.\n+///   This avoids silently returning a second reference somewhere in the tree.\n+///   That is irrelevant when `BorrowType` is `Immut<'a>`, but the rule does\n+///   no harm because we make those `NodeRef` implicitly `Copy`.\n+///   The rule also avoids implicitly returning the lifetime of `&self`,\n+///   instead of the lifetime contained in `BorrowType`.\n+///   An exception to this rule are the insert functions.\n+/// - Given the above, we need a `reborrow_mut` to explicitly copy a `Mut<'a>`\n+///   `NodeRef` whenever we want to invoke a method returning an extra reference\n+///   somewhere in the tree.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     /// The number of levels below the node, a property of the node that cannot be\n     /// entirely described by `Type` and that the node does not store itself either.\n@@ -277,30 +310,45 @@ unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::Mut<'\n unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::ValMut<'a>, K, V, Type> {}\n unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Owned, K, V, Type> {}\n \n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+    /// Unpack a node reference that was packed by `Root::into_boxed_node`.\n+    fn from_boxed_node(boxed_node: BoxedNode<K, V>, height: usize) -> Self {\n+        NodeRef { height, node: boxed_node.as_ptr(), _marker: PhantomData }\n+    }\n+}\n+\n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n+    /// Unpack a node reference that was packed as `NodeRef::parent`.\n+    fn from_internal(node: NonNull<InternalNode<K, V>>, height: usize) -> Self {\n+        debug_assert!(height > 0);\n+        NodeRef { height, node: node.cast(), _marker: PhantomData }\n+    }\n+}\n+\n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n-    /// Exposes the data of an internal node for reading.\n+    /// Exposes the data of an internal node.\n     ///\n-    /// Returns a raw ptr to avoid invalidating other references to this node,\n-    /// which is possible when BorrowType is marker::ValMut.\n-    fn as_internal_ptr(&self) -> *const InternalNode<K, V> {\n-        self.node.as_ptr() as *const InternalNode<K, V>\n+    /// Returns a raw ptr to avoid invalidating other references to this node.\n+    fn as_internal_ptr(this: &Self) -> *mut InternalNode<K, V> {\n+        // SAFETY: the static node type is `Internal`.\n+        this.node.as_ptr() as *mut InternalNode<K, V>\n     }\n }\n \n-impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// Exposes the data of an internal node for reading,\n-    /// when we know we have exclusive access.\n-    fn as_internal(&mut self) -> &InternalNode<K, V> {\n-        unsafe { &*self.as_internal_ptr() }\n+impl<'a, K, V> NodeRef<marker::Immut<'a>, K, V, marker::Internal> {\n+    /// Exposes the data of an internal node in an immutable tree.\n+    fn as_internal(this: &Self) -> &'a InternalNode<K, V> {\n+        let ptr = Self::as_internal_ptr(this);\n+        // SAFETY: there can be no mutable references into this tree borrowed as `Immut`.\n+        unsafe { &*ptr }\n     }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// Exposes the data of an internal node for writing.\n-    ///\n-    /// We don't need to return a raw ptr because we have unique access to the entire node.\n-    fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {\n-        unsafe { &mut *(self.node.as_ptr() as *mut InternalNode<K, V>) }\n+    /// Offers exclusive access to the data of an internal node.\n+    fn as_internal_mut(this: &mut Self) -> &'a mut InternalNode<K, V> {\n+        let ptr = Self::as_internal_ptr(this);\n+        unsafe { &mut *ptr }\n     }\n }\n \n@@ -312,7 +360,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     pub fn len(&self) -> usize {\n         // Crucially, we only access the `len` field here. If BorrowType is marker::ValMut,\n         // there might be outstanding mutable references to values that we must not invalidate.\n-        unsafe { usize::from((*self.as_leaf_ptr()).len) }\n+        unsafe { usize::from((*Self::as_leaf_ptr(self)).len) }\n     }\n \n     /// Returns the height of this node with respect to the leaf level. Zero height means the\n@@ -322,48 +370,49 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n \n     /// Temporarily takes out another, immutable reference to the same node.\n-    fn reborrow(&self) -> NodeRef<marker::Immut<'_>, K, V, Type> {\n+    pub fn reborrow(&self) -> NodeRef<marker::Immut<'_>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n     /// Exposes the leaf portion of any leaf or internal node.\n     ///\n-    /// Returns a raw ptr to avoid invalidating other references to this node,\n-    /// which is possible when BorrowType is marker::ValMut.\n-    fn as_leaf_ptr(&self) -> *const LeafNode<K, V> {\n+    /// Returns a raw ptr to avoid invalidating other references to this node.\n+    fn as_leaf_ptr(this: &Self) -> *mut LeafNode<K, V> {\n         // The node must be valid for at least the LeafNode portion.\n         // This is not a reference in the NodeRef type because we don't know if\n         // it should be unique or shared.\n-        self.node.as_ptr()\n+        this.node.as_ptr()\n     }\n+}\n \n-    /// Borrows a reference to one of the keys stored in the node.\n+impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n+    /// Exposes one of the keys stored in the node.\n     ///\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n-    pub unsafe fn key_at(&self, idx: usize) -> &K {\n-        unsafe { self.reborrow().into_key_at(idx) }\n+    pub unsafe fn key_at(self, idx: usize) -> &'a K {\n+        debug_assert!(idx < self.len());\n+        unsafe { Self::as_leaf(&self).keys.get_unchecked(idx).assume_init_ref() }\n     }\n \n-    /// Borrows a reference to one of the values stored in the node.\n+    /// Exposes one of the values stored in the node.\n     ///\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n-    unsafe fn val_at(&self, idx: usize) -> &V {\n-        unsafe { self.reborrow().into_val_at(idx) }\n+    unsafe fn val_at(self, idx: usize) -> &'a V {\n+        debug_assert!(idx < self.len());\n+        unsafe { Self::as_leaf(&self).vals.get_unchecked(idx).assume_init_ref() }\n     }\n }\n \n-impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n-    /// Borrows a reference to the contents of one of the edges that delimit\n-    /// the elements of the node, without invalidating other references.\n+impl<'a, K, V> NodeRef<marker::Immut<'a>, K, V, marker::Internal> {\n+    /// Exposes the contents of one of the edges in the node.\n     ///\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n-    unsafe fn edge_at(&self, idx: usize) -> &BoxedNode<K, V> {\n+    unsafe fn edge_at(self, idx: usize) -> &'a BoxedNode<K, V> {\n         debug_assert!(idx <= self.len());\n-        let node = self.as_internal_ptr();\n-        unsafe { (*node).edges.get_unchecked(idx).assume_init_ref() }\n+        unsafe { Self::as_internal(&self).edges.get_unchecked(idx).assume_init_ref() }\n     }\n }\n \n@@ -380,15 +429,11 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     ) -> Result<Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>, Self> {\n         // We need to use raw pointers to nodes because, if BorrowType is marker::ValMut,\n         // there might be outstanding mutable references to values that we must not invalidate.\n-        let leaf_ptr = self.as_leaf_ptr();\n+        let leaf_ptr: *const _ = Self::as_leaf_ptr(&self);\n         unsafe { (*leaf_ptr).parent }\n             .as_ref()\n             .map(|parent| Handle {\n-                node: NodeRef {\n-                    height: self.height + 1,\n-                    node: parent.cast(),\n-                    _marker: PhantomData,\n-                },\n+                node: NodeRef::from_internal(*parent, self.height + 1),\n                 idx: unsafe { usize::from((*leaf_ptr).parent_idx.assume_init()) },\n                 _marker: PhantomData,\n             })\n@@ -420,11 +465,11 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    /// Exposes the data of a leaf node for reading in an immutable tree.\n-    fn into_leaf(self) -> &'a LeafNode<K, V> {\n-        // SAFETY: we can access the entire node freely and do no need raw pointers,\n-        // because there can be no mutable references to this Immut tree.\n-        unsafe { &(*self.as_leaf_ptr()) }\n+    /// Exposes the leaf portion of any leaf or internal node in an immutable tree.\n+    fn as_leaf(this: &Self) -> &'a LeafNode<K, V> {\n+        let ptr = Self::as_leaf_ptr(this);\n+        // SAFETY: there can be no mutable references into this tree borrowed as `Immut`.\n+        unsafe { &*ptr }\n     }\n }\n \n@@ -473,139 +518,155 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n-    /// Exposes the leaf portion of any leaf or internal node for writing.\n-    ///\n-    /// We don't need to return a raw ptr because we have unique access to the entire node.\n-    fn as_leaf_mut(&mut self) -> &'a mut LeafNode<K, V> {\n-        unsafe { &mut (*self.node.as_ptr()) }\n+    /// Offers exclusive access to the leaf portion of any leaf or internal node.\n+    fn as_leaf_mut(this: &mut Self) -> &'a mut LeafNode<K, V> {\n+        let ptr = Self::as_leaf_ptr(this);\n+        // SAFETY: we have exclusive access to the entire node.\n+        unsafe { &mut *ptr }\n     }\n+}\n \n-    /// Borrows a mutable reference to one of the keys stored in the node.\n+impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n+    /// Offers exclusive access to a part of the key storage area.\n     ///\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n-    unsafe fn key_mut_at(&mut self, idx: usize) -> &mut K {\n-        unsafe { self.reborrow_mut().into_key_mut_at(idx) }\n+    unsafe fn into_key_area_mut_at(mut self, idx: usize) -> &'a mut MaybeUninit<K> {\n+        debug_assert!(idx < self.len());\n+        unsafe { Self::as_leaf_mut(&mut self).keys.get_unchecked_mut(idx) }\n     }\n \n-    /// Borrows a mutable reference to one of the values stored in the node.\n+    /// Offers exclusive access to a part of the value storage area.\n     ///\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n-    unsafe fn val_mut_at(&mut self, idx: usize) -> &mut V {\n-        unsafe { self.reborrow_mut().into_val_mut_at(idx) }\n-    }\n-\n-    fn keys_mut(&mut self) -> &mut [K]\n-    where\n-        K: 'a,\n-        V: 'a,\n-    {\n-        // SAFETY: the caller will not be able to call further methods on self\n-        // until the key slice reference is dropped, as we have unique access\n-        // for the lifetime of the borrow.\n-        // SAFETY: The keys of a node must always be initialized up to length.\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().keys),\n-                self.len(),\n-            )\n-        }\n-    }\n-\n-    fn vals_mut(&mut self) -> &mut [V]\n-    where\n-        K: 'a,\n-        V: 'a,\n-    {\n-        // SAFETY: the caller will not be able to call further methods on self\n-        // until the value slice reference is dropped, as we have unique access\n-        // for the lifetime of the borrow.\n-        // SAFETY: The values of a node must always be initialized up to length.\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().vals),\n-                self.len(),\n-            )\n-        }\n+    unsafe fn into_val_area_mut_at(mut self, idx: usize) -> &'a mut MaybeUninit<V> {\n+        debug_assert!(idx < self.len());\n+        unsafe { Self::as_leaf_mut(&mut self).vals.get_unchecked_mut(idx) }\n     }\n }\n \n-impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    fn edges_mut(&mut self) -> &mut [BoxedNode<K, V>] {\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::slice_as_mut_ptr(&mut self.as_internal_mut().edges),\n-                self.len() + 1,\n-            )\n-        }\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    /// Offers exclusive access to a part of the storage area for edge contents.\n+    ///\n+    /// # Safety\n+    /// The node has at least `idx` initialized elements.\n+    unsafe fn into_edge_area_mut_at(mut self, idx: usize) -> &'a mut MaybeUninit<BoxedNode<K, V>> {\n+        debug_assert!(idx <= self.len());\n+        unsafe { Self::as_internal_mut(&mut self).edges.get_unchecked_mut(idx) }\n     }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    /// # Safety\n-    /// The node has more than `idx` initialized elements.\n-    unsafe fn into_key_at(self, idx: usize) -> &'a K {\n-        unsafe { self.into_leaf().keys.get_unchecked(idx).assume_init_ref() }\n+    /// Exposes the entire key storage area in the node,\n+    /// regardless of the node's current length,\n+    /// having exclusive access to the entire node.\n+    unsafe fn key_area(self) -> &'a [MaybeUninit<K>] {\n+        Self::as_leaf(&self).keys.as_slice()\n     }\n \n-    /// # Safety\n-    /// The node has more than `idx` initialized elements.\n-    unsafe fn into_val_at(self, idx: usize) -> &'a V {\n-        unsafe { self.into_leaf().vals.get_unchecked(idx).assume_init_ref() }\n+    /// Exposes the entire value storage area in the node,\n+    /// regardless of the node's current length,\n+    /// having exclusive access to the entire node.\n+    unsafe fn val_area(self) -> &'a [MaybeUninit<V>] {\n+        Self::as_leaf(&self).vals.as_slice()\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n-    /// # Safety\n-    /// The node has more than `idx` initialized elements.\n-    unsafe fn into_key_mut_at(mut self, idx: usize) -> &'a mut K {\n-        debug_assert!(idx < self.len());\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::Internal> {\n+    /// Exposes the entire storage area for edge contents in the node,\n+    /// regardless of the node's current length,\n+    /// having exclusive access to the entire node.\n+    unsafe fn edge_area(self) -> &'a [MaybeUninit<BoxedNode<K, V>>] {\n+        Self::as_internal(&self).edges.as_slice()\n+    }\n+}\n \n-        let leaf = self.as_leaf_mut();\n-        unsafe { leaf.keys.get_unchecked_mut(idx).assume_init_mut() }\n+impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n+    /// Offers exclusive access to a sized slice of key storage area in the node.\n+    unsafe fn into_key_area_slice(mut self) -> &'a mut [MaybeUninit<K>] {\n+        let len = self.len();\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the key slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { Self::as_leaf_mut(&mut self).keys.get_unchecked_mut(..len) }\n     }\n \n-    /// # Safety\n-    /// The node has more than `idx` initialized elements.\n-    unsafe fn into_val_mut_at(mut self, idx: usize) -> &'a mut V {\n-        debug_assert!(idx < self.len());\n+    /// Offers exclusive access to a sized slice of value storage area in the node.\n+    unsafe fn into_val_area_slice(mut self) -> &'a mut [MaybeUninit<V>] {\n+        let len = self.len();\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the value slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { Self::as_leaf_mut(&mut self).vals.get_unchecked_mut(..len) }\n+    }\n+}\n \n-        let leaf = self.as_leaf_mut();\n-        unsafe { leaf.vals.get_unchecked_mut(idx).assume_init_mut() }\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    /// Offers exclusive access to a sized slice of storage area for edge contents in the node.\n+    unsafe fn into_edge_area_slice(mut self) -> &'a mut [MaybeUninit<BoxedNode<K, V>>] {\n+        let len = self.len();\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the edge slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { Self::as_internal_mut(&mut self).edges.get_unchecked_mut(..len + 1) }\n     }\n }\n \n impl<'a, K, V, Type> NodeRef<marker::ValMut<'a>, K, V, Type> {\n     /// # Safety\n-    /// The node has more than `idx` initialized elements.\n-    unsafe fn into_key_val_mut_at(self, idx: usize) -> (&'a K, &'a mut V) {\n+    /// - The node has more than `idx` initialized elements.\n+    /// - The keys and values of the node must be initialized up to its current length.\n+    unsafe fn into_key_val_mut_at(mut self, idx: usize) -> (&'a K, &'a mut V) {\n         // We only create a reference to the one element we are interested in,\n         // to avoid aliasing with outstanding references to other elements,\n         // in particular, those returned to the caller in earlier iterations.\n-        let leaf = self.node.as_ptr();\n+        let leaf = Self::as_leaf_ptr(&mut self);\n         let keys = unsafe { &raw const (*leaf).keys };\n         let vals = unsafe { &raw mut (*leaf).vals };\n         // We must coerce to unsized array pointers because of Rust issue #74679.\n         let keys: *const [_] = keys;\n         let vals: *mut [_] = vals;\n-        // SAFETY: The keys and values of a node must always be initialized up to length.\n         let key = unsafe { (&*keys.get_unchecked(idx)).assume_init_ref() };\n         let val = unsafe { (&mut *vals.get_unchecked_mut(idx)).assume_init_mut() };\n         (key, val)\n     }\n }\n \n+impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n+    /// Exposes exclusive access to the length of the node.\n+    pub fn into_len_mut(mut self) -> &'a mut u16 {\n+        &mut (*Self::as_leaf_mut(&mut self)).len\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+    /// Set or clear the node's link to its parent edge,\n+    /// without invalidating other references to the node.\n+    fn set_parent_link(&mut self, parent: NonNull<InternalNode<K, V>>, parent_idx: usize) {\n+        let leaf = Self::as_leaf_ptr(self);\n+        unsafe { (*leaf).parent = Some(parent) };\n+        unsafe { (*leaf).parent_idx.write(parent_idx as u16) };\n+    }\n+\n+    /// Clear the node's link to its parent edge, freeing it from its tree.\n+    /// This only makes sense when there are no other references to the node.\n+    fn clear_parent_link(&mut self) {\n+        let leaf = Self::as_leaf_mut(self);\n+        leaf.parent = None;\n+    }\n+}\n+\n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair to the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n-        let len = &mut self.as_leaf_mut().len;\n+        let len = unsafe { self.reborrow_mut().into_len_mut() };\n         let idx = usize::from(*len);\n         assert!(idx < CAPACITY);\n         *len += 1;\n         unsafe {\n-            ptr::write(self.key_mut_at(idx), key);\n-            ptr::write(self.val_mut_at(idx), val);\n+            self.reborrow_mut().into_key_area_mut_at(idx).write(key);\n+            self.reborrow_mut().into_val_area_mut_at(idx).write(val);\n         }\n     }\n \n@@ -614,10 +675,10 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         assert!(self.len() < CAPACITY);\n \n         unsafe {\n-            slice_insert(self.keys_mut(), 0, key);\n-            slice_insert(self.vals_mut(), 0, val);\n+            *self.reborrow_mut().into_len_mut() += 1;\n+            slice_insert(self.reborrow_mut().into_key_area_slice(), 0, key);\n+            slice_insert(self.reborrow_mut().into_val_area_slice(), 0, val);\n         }\n-        self.as_leaf_mut().len += 1;\n     }\n }\n \n@@ -643,14 +704,14 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n \n-        let len = &mut self.as_leaf_mut().len;\n+        let len = unsafe { self.reborrow_mut().into_len_mut() };\n         let idx = usize::from(*len);\n         assert!(idx < CAPACITY);\n         *len += 1;\n         unsafe {\n-            ptr::write(self.key_mut_at(idx), key);\n-            ptr::write(self.val_mut_at(idx), val);\n-            self.as_internal_mut().edges.get_unchecked_mut(idx + 1).write(edge.node);\n+            self.reborrow_mut().into_key_area_mut_at(idx).write(key);\n+            self.reborrow_mut().into_val_area_mut_at(idx).write(val);\n+            self.reborrow_mut().into_edge_area_mut_at(idx + 1).write(edge.into_boxed_node());\n             Handle::new_edge(self.reborrow_mut(), idx + 1).correct_parent_link();\n         }\n     }\n@@ -662,13 +723,12 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         assert!(self.len() < CAPACITY);\n \n         unsafe {\n-            slice_insert(self.keys_mut(), 0, key);\n-            slice_insert(self.vals_mut(), 0, val);\n-            slice_insert(self.edges_mut(), 0, edge.node);\n+            *self.reborrow_mut().into_len_mut() += 1;\n+            slice_insert(self.reborrow_mut().into_key_area_slice(), 0, key);\n+            slice_insert(self.reborrow_mut().into_val_area_slice(), 0, val);\n+            slice_insert(self.reborrow_mut().into_edge_area_slice(), 0, edge.into_boxed_node());\n         }\n \n-        self.as_leaf_mut().len += 1;\n-\n         self.correct_all_childrens_parent_links();\n     }\n }\n@@ -683,19 +743,21 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let idx = self.len() - 1;\n \n         unsafe {\n-            let key = ptr::read(self.key_at(idx));\n-            let val = ptr::read(self.val_at(idx));\n+            let key = ptr::read(self.reborrow().key_at(idx));\n+            let val = ptr::read(self.reborrow().val_at(idx));\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(internal) => {\n-                    let edge = ptr::read(internal.edge_at(idx + 1));\n-                    let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    new_root.node_as_mut().as_leaf_mut().parent = None;\n-                    Some(new_root)\n+                    let boxed_node = ptr::read(internal.reborrow().edge_at(idx + 1));\n+                    let mut edge = Root { node: boxed_node, height: internal.height - 1 };\n+                    // In practice, clearing the parent is a waste of time, because we will\n+                    // insert the node elsewhere and set its parent link again.\n+                    edge.node_as_mut().clear_parent_link();\n+                    Some(edge)\n                 }\n             };\n \n-            self.as_leaf_mut().len -= 1;\n+            *self.reborrow_mut().into_len_mut() -= 1;\n             (key, val, edge)\n         }\n     }\n@@ -709,29 +771,35 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let old_len = self.len();\n \n         unsafe {\n-            let key = slice_remove(self.keys_mut(), 0);\n-            let val = slice_remove(self.vals_mut(), 0);\n+            let key = slice_remove(self.reborrow_mut().into_key_area_slice(), 0);\n+            let val = slice_remove(self.reborrow_mut().into_val_area_slice(), 0);\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(mut internal) => {\n-                    let edge = slice_remove(internal.edges_mut(), 0);\n-                    let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    new_root.node_as_mut().as_leaf_mut().parent = None;\n+                    let boxed_node =\n+                        slice_remove(internal.reborrow_mut().into_edge_area_slice(), 0);\n+                    let mut edge = Root { node: boxed_node, height: internal.height - 1 };\n+                    // In practice, clearing the parent is a waste of time, because we will\n+                    // insert the node elsewhere and set its parent link again.\n+                    edge.node_as_mut().clear_parent_link();\n \n                     internal.correct_childrens_parent_links(0..old_len);\n \n-                    Some(new_root)\n+                    Some(edge)\n                 }\n             };\n \n-            self.as_leaf_mut().len -= 1;\n+            *self.reborrow_mut().into_len_mut() -= 1;\n \n             (key, val, edge)\n         }\n     }\n \n     fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n-        (self.keys_mut().as_mut_ptr(), self.vals_mut().as_mut_ptr())\n+        let leaf = Self::as_leaf_mut(&mut self);\n+        let keys = MaybeUninit::slice_as_mut_ptr(&mut leaf.keys);\n+        let vals = MaybeUninit::slice_as_mut_ptr(&mut leaf.vals);\n+        (keys, vals)\n     }\n }\n \n@@ -816,7 +884,7 @@ impl<BorrowType, K, V, NodeType> NodeRef<BorrowType, K, V, NodeType> {\n     /// Could be a public implementation of PartialEq, but only used in this module.\n     fn eq(&self, other: &Self) -> bool {\n         let Self { node, height, _marker: _ } = self;\n-        if *node == other.node {\n+        if node.eq(&other.node) {\n             debug_assert_eq!(*height, other.height);\n             true\n         } else {\n@@ -924,11 +992,11 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n         debug_assert!(self.node.len() < CAPACITY);\n \n         unsafe {\n-            slice_insert(self.node.keys_mut(), self.idx, key);\n-            slice_insert(self.node.vals_mut(), self.idx, val);\n-            self.node.as_leaf_mut().len += 1;\n+            *self.node.reborrow_mut().into_len_mut() += 1;\n+            slice_insert(self.node.reborrow_mut().into_key_area_slice(), self.idx, key);\n+            slice_insert(self.node.reborrow_mut().into_val_area_slice(), self.idx, val);\n \n-            self.node.val_mut_at(self.idx)\n+            self.node.reborrow_mut().into_val_area_mut_at(self.idx).assume_init_mut()\n         }\n     }\n }\n@@ -964,12 +1032,12 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n     /// Fixes the parent pointer and index in the child node below this edge. This is useful\n     /// when the ordering of edges has been changed, such as in the various `insert` methods.\n-    fn correct_parent_link(mut self) {\n-        let idx = self.idx as u16;\n-        let ptr = NonNull::new(self.node.as_internal_mut());\n+    fn correct_parent_link(self) {\n+        // Create backpointer without invalidating other references to the node.\n+        let ptr = unsafe { NonNull::new_unchecked(NodeRef::as_internal_ptr(&self.node)) };\n+        let idx = self.idx;\n         let mut child = self.descend();\n-        child.as_leaf_mut().parent = ptr;\n-        child.as_leaf_mut().parent_idx.write(idx);\n+        child.set_parent_link(ptr, idx);\n     }\n }\n \n@@ -981,11 +1049,12 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n         debug_assert!(self.node.len() < CAPACITY);\n         debug_assert!(edge.height == self.node.height - 1);\n \n+        let boxed_node = edge.into_boxed_node();\n         unsafe {\n-            slice_insert(self.node.keys_mut(), self.idx, key);\n-            slice_insert(self.node.vals_mut(), self.idx, val);\n-            slice_insert(self.node.edges_mut(), self.idx + 1, edge.node);\n-            self.node.as_leaf_mut().len += 1;\n+            *self.node.reborrow_mut().into_len_mut() += 1;\n+            slice_insert(self.node.reborrow_mut().into_key_area_slice(), self.idx, key);\n+            slice_insert(self.node.reborrow_mut().into_val_area_slice(), self.idx, val);\n+            slice_insert(self.node.reborrow_mut().into_edge_area_slice(), self.idx + 1, boxed_node);\n \n             self.node.correct_childrens_parent_links((self.idx + 1)..=self.node.len());\n         }\n@@ -1073,28 +1142,25 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marke\n         // node pointer is dereferenced, we access the edges array with a\n         // reference (Rust issue #73987) and invalidate any other references\n         // to or inside the array, should any be around.\n-        let internal_node = self.node.as_internal_ptr();\n-        NodeRef {\n-            height: self.node.height - 1,\n-            node: unsafe { (&*(*internal_node).edges.get_unchecked(self.idx).as_ptr()).as_ptr() },\n-            _marker: PhantomData,\n-        }\n+        let parent_ptr = NodeRef::as_internal_ptr(&self.node);\n+        let boxed_node = unsafe { (*parent_ptr).edges.get_unchecked(self.idx).assume_init_read() };\n+        NodeRef::from_boxed_node(boxed_node, self.node.height - 1)\n     }\n }\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv(self) -> (&'a K, &'a V) {\n-        (unsafe { self.node.into_key_at(self.idx) }, unsafe { self.node.into_val_at(self.idx) })\n+        (unsafe { self.node.key_at(self.idx) }, unsafe { self.node.val_at(self.idx) })\n     }\n }\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_key_mut(self) -> &'a mut K {\n-        unsafe { self.node.into_key_mut_at(self.idx) }\n+        unsafe { self.node.into_key_area_mut_at(self.idx).assume_init_mut() }\n     }\n \n     pub fn into_val_mut(self) -> &'a mut V {\n-        unsafe { self.node.into_val_mut_at(self.idx) }\n+        unsafe { self.node.into_val_area_mut_at(self.idx).assume_init_mut() }\n     }\n }\n \n@@ -1106,12 +1172,14 @@ impl<'a, K, V, NodeType> Handle<NodeRef<marker::ValMut<'a>, K, V, NodeType>, mar\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn kv_mut(&mut self) -> (&mut K, &mut V) {\n-        // We cannot call into_key_mut_at and into_val_mut_at, because calling the second one\n+        // We cannot call separate key and value methods, because calling the second one\n         // invalidates the reference returned by the first.\n-        let leaf = self.node.as_leaf_mut();\n-        let key = unsafe { leaf.keys.get_unchecked_mut(self.idx).assume_init_mut() };\n-        let val = unsafe { leaf.vals.get_unchecked_mut(self.idx).assume_init_mut() };\n-        (key, val)\n+        unsafe {\n+            let leaf = NodeRef::as_leaf_mut(&mut self.node.reborrow_mut());\n+            let key = leaf.keys.get_unchecked_mut(self.idx).assume_init_mut();\n+            let val = leaf.vals.get_unchecked_mut(self.idx).assume_init_mut();\n+            (key, val)\n+        }\n     }\n }\n \n@@ -1127,23 +1195,23 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n     /// by taking care of leaf data.\n     fn split_leaf_data(&mut self, new_node: &mut LeafNode<K, V>) -> (K, V) {\n         let new_len = self.split_new_node_len();\n+        new_node.len = new_len as u16;\n         unsafe {\n-            let k = ptr::read(self.node.key_at(self.idx));\n-            let v = ptr::read(self.node.val_at(self.idx));\n+            let k = ptr::read(self.node.reborrow().key_at(self.idx));\n+            let v = ptr::read(self.node.reborrow().val_at(self.idx));\n \n             ptr::copy_nonoverlapping(\n-                self.node.key_at(self.idx + 1),\n-                MaybeUninit::slice_as_mut_ptr(&mut new_node.keys),\n+                self.node.reborrow().key_area().as_ptr().add(self.idx + 1),\n+                new_node.keys.as_mut_ptr(),\n                 new_len,\n             );\n             ptr::copy_nonoverlapping(\n-                self.node.val_at(self.idx + 1),\n-                MaybeUninit::slice_as_mut_ptr(&mut new_node.vals),\n+                self.node.reborrow().val_area().as_ptr().add(self.idx + 1),\n+                new_node.vals.as_mut_ptr(),\n                 new_len,\n             );\n \n-            self.node.as_leaf_mut().len = self.idx as u16;\n-            new_node.len = new_len as u16;\n+            *self.node.reborrow_mut().into_len_mut() = self.idx as u16;\n             (k, v)\n         }\n     }\n@@ -1174,9 +1242,9 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n         mut self,\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         unsafe {\n-            let k = slice_remove(self.node.keys_mut(), self.idx);\n-            let v = slice_remove(self.node.vals_mut(), self.idx);\n-            self.node.as_leaf_mut().len -= 1;\n+            let k = slice_remove(self.node.reborrow_mut().into_key_area_slice(), self.idx);\n+            let v = slice_remove(self.node.reborrow_mut().into_val_area_slice(), self.idx);\n+            *self.node.reborrow_mut().into_len_mut() -= 1;\n             ((k, v), self.left_edge())\n         }\n     }\n@@ -1205,11 +1273,11 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Internal>, K, V, Root<K, V>) {\n         unsafe {\n             let mut new_node = Box::new(InternalNode::new());\n-            // Move edges out before reducing length:\n             let new_len = self.split_new_node_len();\n+            // Move edges out before reducing length:\n             ptr::copy_nonoverlapping(\n-                self.node.edge_at(self.idx + 1),\n-                MaybeUninit::slice_as_mut_ptr(&mut new_node.edges),\n+                self.node.reborrow().edge_area().as_ptr().add(self.idx + 1),\n+                new_node.edges.as_mut_ptr(),\n                 new_len + 1,\n             );\n             let (k, v) = self.split_leaf_data(&mut new_node.data);\n@@ -1241,40 +1309,37 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n         assert!(left_len + right_len < CAPACITY);\n \n         unsafe {\n-            ptr::write(\n-                left_node.keys_mut().get_unchecked_mut(left_len),\n-                slice_remove(self.node.keys_mut(), self.idx),\n-            );\n+            *left_node.reborrow_mut().into_len_mut() += right_len as u16 + 1;\n+\n+            let parent_key = slice_remove(self.node.reborrow_mut().into_key_area_slice(), self.idx);\n+            left_node.reborrow_mut().into_key_area_mut_at(left_len).write(parent_key);\n             ptr::copy_nonoverlapping(\n-                right_node.key_at(0),\n-                left_node.keys_mut().as_mut_ptr().add(left_len + 1),\n+                right_node.reborrow().key_area().as_ptr(),\n+                left_node.reborrow_mut().into_key_area_slice().as_mut_ptr().add(left_len + 1),\n                 right_len,\n             );\n-            ptr::write(\n-                left_node.vals_mut().get_unchecked_mut(left_len),\n-                slice_remove(self.node.vals_mut(), self.idx),\n-            );\n+\n+            let parent_val = slice_remove(self.node.reborrow_mut().into_val_area_slice(), self.idx);\n+            left_node.reborrow_mut().into_val_area_mut_at(left_len).write(parent_val);\n             ptr::copy_nonoverlapping(\n-                right_node.val_at(0),\n-                left_node.vals_mut().as_mut_ptr().add(left_len + 1),\n+                right_node.reborrow().val_area().as_ptr(),\n+                left_node.reborrow_mut().into_val_area_slice().as_mut_ptr().add(left_len + 1),\n                 right_len,\n             );\n \n-            slice_remove(&mut self.node.edges_mut(), self.idx + 1);\n+            slice_remove(&mut self.node.reborrow_mut().into_edge_area_slice(), self.idx + 1);\n             let self_len = self.node.len();\n             self.node.correct_childrens_parent_links(self.idx + 1..self_len);\n-            self.node.as_leaf_mut().len -= 1;\n-\n-            left_node.as_leaf_mut().len += right_len as u16 + 1;\n+            *self.node.reborrow_mut().into_len_mut() -= 1;\n \n             if self.node.height > 1 {\n                 // SAFETY: the height of the nodes being merged is one below the height\n                 // of the node of this edge, thus above zero, so they are internal.\n                 let mut left_node = left_node.cast_to_internal_unchecked();\n                 let right_node = right_node.cast_to_internal_unchecked();\n                 ptr::copy_nonoverlapping(\n-                    right_node.edge_at(0),\n-                    left_node.edges_mut().as_mut_ptr().add(left_len + 1),\n+                    right_node.reborrow().edge_area().as_ptr(),\n+                    left_node.reborrow_mut().into_edge_area_slice().as_mut_ptr().add(left_len + 1),\n                     right_len + 1,\n                 );\n \n@@ -1360,13 +1425,14 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                 move_kv(left_kv, new_left_len, parent_kv, 0, 1);\n             }\n \n-            left_node.as_leaf_mut().len -= count as u16;\n-            right_node.as_leaf_mut().len += count as u16;\n+            *left_node.reborrow_mut().into_len_mut() -= count as u16;\n+            *right_node.reborrow_mut().into_len_mut() += count as u16;\n \n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n                     // Make room for stolen edges.\n-                    let right_edges = right.reborrow_mut().as_internal_mut().edges.as_mut_ptr();\n+                    let left = left.reborrow();\n+                    let right_edges = right.reborrow_mut().into_edge_area_slice().as_mut_ptr();\n                     ptr::copy(right_edges, right_edges.add(count), right_len + 1);\n                     right.correct_childrens_parent_links(count..count + right_len + 1);\n \n@@ -1415,15 +1481,15 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                 ptr::copy(right_kv.1.add(count), right_kv.1, new_right_len);\n             }\n \n-            left_node.as_leaf_mut().len += count as u16;\n-            right_node.as_leaf_mut().len -= count as u16;\n+            *left_node.reborrow_mut().into_len_mut() += count as u16;\n+            *right_node.reborrow_mut().into_len_mut() -= count as u16;\n \n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n-                    move_edges(right.reborrow_mut(), 0, left, left_len + 1, count);\n+                    move_edges(right.reborrow(), 0, left, left_len + 1, count);\n \n                     // Fix right indexing.\n-                    let right_edges = right.reborrow_mut().as_internal_mut().edges.as_mut_ptr();\n+                    let right_edges = right.reborrow_mut().into_edge_area_slice().as_mut_ptr();\n                     ptr::copy(right_edges.add(count), right_edges, new_right_len + 1);\n                     right.correct_childrens_parent_links(0..=new_right_len);\n                 }\n@@ -1448,16 +1514,16 @@ unsafe fn move_kv<K, V>(\n }\n \n // Source and destination must have the same height.\n-unsafe fn move_edges<K, V>(\n-    mut source: NodeRef<marker::Mut<'_>, K, V, marker::Internal>,\n+unsafe fn move_edges<'a, K: 'a, V: 'a>(\n+    source: NodeRef<marker::Immut<'a>, K, V, marker::Internal>,\n     source_offset: usize,\n-    mut dest: NodeRef<marker::Mut<'_>, K, V, marker::Internal>,\n+    mut dest: NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     dest_offset: usize,\n     count: usize,\n ) {\n-    let source_ptr = source.as_internal().edges.as_ptr();\n-    let dest_ptr = dest.as_internal_mut().edges.as_mut_ptr();\n     unsafe {\n+        let source_ptr = source.edge_area().as_ptr();\n+        let dest_ptr = dest.reborrow_mut().into_edge_area_slice().as_mut_ptr();\n         ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr.add(dest_offset), count);\n         dest.correct_childrens_parent_links(dest_offset..dest_offset + count);\n     }\n@@ -1553,11 +1619,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n \n                 move_kv(left_kv, left_new_len, right_kv, 0, right_new_len);\n \n-                left_node.as_leaf_mut().len = left_new_len as u16;\n-                right_node.as_leaf_mut().len = right_new_len as u16;\n+                *left_node.reborrow_mut().into_len_mut() = left_new_len as u16;\n+                *right_node.reborrow_mut().into_len_mut() = right_new_len as u16;\n \n                 match (left_node.force(), right_node.force()) {\n                     (ForceResult::Internal(left), ForceResult::Internal(right)) => {\n+                        let left = left.reborrow();\n                         move_edges(left, left_new_len + 1, right, 1, right_new_len);\n                     }\n                     (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n@@ -1606,20 +1673,33 @@ pub mod marker {\n     pub enum Edge {}\n }\n \n-unsafe fn slice_insert<T>(slice: &mut [T], idx: usize, val: T) {\n+/// Inserts a value into a slice of initialized elements followed by one uninitialized element.\n+///\n+/// # Safety\n+/// The slice has more than `idx` elements.\n+unsafe fn slice_insert<T>(slice: &mut [MaybeUninit<T>], idx: usize, val: T) {\n     unsafe {\n         let len = slice.len();\n+        debug_assert!(len > idx);\n         let slice_ptr = slice.as_mut_ptr();\n-        ptr::copy(slice_ptr.add(idx), slice_ptr.add(idx + 1), len - idx);\n-        ptr::write(slice_ptr.add(idx), val);\n+        if len > idx + 1 {\n+            ptr::copy(slice_ptr.add(idx), slice_ptr.add(idx + 1), len - idx - 1);\n+        }\n+        (*slice_ptr.add(idx)).write(val);\n     }\n }\n \n-unsafe fn slice_remove<T>(slice: &mut [T], idx: usize) -> T {\n+/// Removes and returns a value from a slice of all initialized elements, leaving behind one\n+/// trailing uninitialized element.\n+///\n+/// # Safety\n+/// The slice has more than `idx` elements.\n+unsafe fn slice_remove<T>(slice: &mut [MaybeUninit<T>], idx: usize) -> T {\n     unsafe {\n         let len = slice.len();\n+        debug_assert!(idx < len);\n         let slice_ptr = slice.as_mut_ptr();\n-        let ret = ptr::read(slice_ptr.add(idx));\n+        let ret = (*slice_ptr.add(idx)).assume_init_read();\n         ptr::copy(slice_ptr.add(idx + 1), slice_ptr.add(idx), len - idx - 1);\n         ret\n     }"}, {"sha": "701d5ec73e218ddfb38bcd2d73db6f40a8e8d4bb", "filename": "library/alloc/src/collections/btree/search.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -72,7 +72,7 @@ where\n     // is an index -- not a reference.\n     let len = node.len();\n     for i in 0..len {\n-        let k = unsafe { node.key_at(i) };\n+        let k = unsafe { node.reborrow().key_at(i) };\n         match key.cmp(k.borrow()) {\n             Ordering::Greater => {}\n             Ordering::Equal => return (i, true),"}, {"sha": "f21fc8854d05e16af76539b0493fee70616a092b", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -78,6 +78,7 @@\n #![cfg_attr(test, feature(new_uninit))]\n #![feature(allocator_api)]\n #![feature(array_chunks)]\n+#![feature(array_methods)]\n #![feature(array_value_iter)]\n #![feature(array_windows)]\n #![feature(allow_internal_unstable)]"}, {"sha": "a103c9fb0b78c05d6bafba8d47abaa2b6cd9b3d1", "filename": "src/bootstrap/CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fbootstrap%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fbootstrap%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCHANGELOG.md?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -8,6 +8,8 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n \n - `x.py check` needs opt-in to check tests (--all-targets) [#77473](https://github.com/rust-lang/rust/pull/77473)\n - The default bootstrap profiles are now located at `bootstrap/defaults/config.$PROFILE.toml` (previously they were located at `bootstrap/defaults/config.toml.$PROFILE`) [#77558](https://github.com/rust-lang/rust/pull/77558)\n+- If you have Rust already installed, `x.py` will now infer the host target\n+  from the default rust toolchain. [#78513](https://github.com/rust-lang/rust/pull/78513)\n \n \n ## [Version 2] - 2020-09-25"}, {"sha": "54d0a23dec58da846669cb11a850b178041fa3c5", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -187,8 +187,23 @@ def format_build_time(duration):\n     return str(datetime.timedelta(seconds=int(duration)))\n \n \n-def default_build_triple():\n+def default_build_triple(verbose):\n     \"\"\"Build triple as in LLVM\"\"\"\n+    # If the user already has a host build triple with an existing `rustc`\n+    # install, use their preference. This fixes most issues with Windows builds\n+    # being detected as GNU instead of MSVC.\n+    try:\n+        version = subprocess.check_output([\"rustc\", \"--version\", \"--verbose\"])\n+        host = next(x for x in version.split('\\n') if x.startswith(\"host: \"))\n+        triple = host.split(\"host: \")[1]\n+        if verbose:\n+            print(\"detected default triple {}\".format(triple))\n+        return triple\n+    except Exception as e:\n+        if verbose:\n+            print(\"rustup not detected: {}\".format(e))\n+            print(\"falling back to auto-detect\")\n+\n     default_encoding = sys.getdefaultencoding()\n     required = sys.platform != 'win32'\n     ostype = require([\"uname\", \"-s\"], exit=required)\n@@ -831,7 +846,7 @@ def build_triple(self):\n         config = self.get_toml('build')\n         if config:\n             return config\n-        return default_build_triple()\n+        return default_build_triple(self.verbose)\n \n     def check_submodule(self, module, slow_submodules):\n         if not slow_submodules:"}, {"sha": "2fc121a2e8613aecbfdbd004985e7af832be1cf4", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -99,6 +99,7 @@ pub struct Config {\n     pub llvm_version_suffix: Option<String>,\n     pub llvm_use_linker: Option<String>,\n     pub llvm_allow_old_toolchain: Option<bool>,\n+    pub llvm_polly: Option<bool>,\n     pub llvm_from_ci: bool,\n \n     pub use_lld: bool,\n@@ -418,6 +419,7 @@ struct Llvm {\n     use_libcxx: Option<bool>,\n     use_linker: Option<String>,\n     allow_old_toolchain: Option<bool>,\n+    polly: Option<bool>,\n     download_ci_llvm: Option<StringOrBool>,\n }\n \n@@ -762,6 +764,7 @@ impl Config {\n             set(&mut config.llvm_use_libcxx, llvm.use_libcxx);\n             config.llvm_use_linker = llvm.use_linker.clone();\n             config.llvm_allow_old_toolchain = llvm.allow_old_toolchain;\n+            config.llvm_polly = llvm.polly;\n             config.llvm_from_ci = match llvm.download_ci_llvm {\n                 Some(StringOrBool::String(s)) => {\n                     assert!(s == \"if-available\", \"unknown option `{}` for download-ci-llvm\", s);\n@@ -795,6 +798,7 @@ impl Config {\n                 check_ci_llvm!(llvm.use_libcxx);\n                 check_ci_llvm!(llvm.use_linker);\n                 check_ci_llvm!(llvm.allow_old_toolchain);\n+                check_ci_llvm!(llvm.polly);\n \n                 // CI-built LLVM is shared\n                 config.llvm_link_shared = true;"}, {"sha": "322e9d6923295fbc11d70747969fb459687caabc", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -266,7 +266,7 @@ def err(msg):\n def build():\n     if 'build' in known_args:\n         return known_args['build'][-1][1]\n-    return bootstrap.default_build_triple()\n+    return bootstrap.default_build_triple(verbose=False)\n \n \n def set(key, value):"}, {"sha": "6dc83c7d70af69c04868779bacb615ebc05ba31f", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -257,6 +257,10 @@ impl Step for Llvm {\n             enabled_llvm_projects.push(\"compiler-rt\");\n         }\n \n+        if let Some(true) = builder.config.llvm_polly {\n+            enabled_llvm_projects.push(\"polly\");\n+        }\n+\n         // We want libxml to be disabled.\n         // See https://github.com/rust-lang/rust/pull/50104\n         cfg.define(\"LLVM_ENABLE_LIBXML2\", \"OFF\");"}, {"sha": "7db6e58c4d688a018b2fe9fa9a26c02ba7b53e7b", "filename": "src/ci/docker/host-x86_64/dist-i686-freebsd/Dockerfile", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/25f6938da459a57b43bdf16ed6bdad3225b2a3ce/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/25f6938da459a57b43bdf16ed6bdad3225b2a3ce/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-freebsd%2FDockerfile?ref=25f6938da459a57b43bdf16ed6bdad3225b2a3ce", "patch": "@@ -1,34 +0,0 @@\n-FROM ubuntu:18.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  clang \\\n-  make \\\n-  ninja-build \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python3 \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  bzip2 \\\n-  xz-utils \\\n-  wget \\\n-  libssl-dev \\\n-  pkg-config\n-\n-COPY scripts/freebsd-toolchain.sh /tmp/\n-RUN /tmp/freebsd-toolchain.sh i686\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV \\\n-    AR_i686_unknown_freebsd=i686-unknown-freebsd11-ar \\\n-    CC_i686_unknown_freebsd=i686-unknown-freebsd11-clang \\\n-    CXX_i686_unknown_freebsd=i686-unknown-freebsd11-clang++\n-\n-ENV HOSTS=i686-unknown-freebsd\n-\n-ENV RUST_CONFIGURE_ARGS --enable-extended --enable-profiler --disable-docs\n-ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "b8b81ab327b0232d7d6583815d81ff9222b5285a", "filename": "src/ci/docker/host-x86_64/dist-various-2/Dockerfile", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -48,6 +48,9 @@ ENV \\\n     CFLAGS_x86_64_fortanix_unknown_sgx=\"-mlvi-hardening -mllvm -x86-experimental-lvi-inline-asm-hardening\" \\\n     CXX_x86_64_fortanix_unknown_sgx=x86_64-fortanix-unknown-sgx-clang++-11 \\\n     CXXFLAGS_x86_64_fortanix_unknown_sgx=\"-mlvi-hardening -mllvm -x86-experimental-lvi-inline-asm-hardening\" \\\n+    AR_i686_unknown_freebsd=i686-unknown-freebsd11-ar \\\n+    CC_i686_unknown_freebsd=i686-unknown-freebsd11-clang \\\n+    CXX_i686_unknown_freebsd=i686-unknown-freebsd11-clang++ \\\n     CC=gcc-7 \\\n     CXX=g++-7\n \n@@ -74,6 +77,9 @@ RUN /tmp/build-x86_64-fortanix-unknown-sgx-toolchain.sh\n COPY host-x86_64/dist-various-2/build-wasi-toolchain.sh /tmp/\n RUN /tmp/build-wasi-toolchain.sh\n \n+COPY scripts/freebsd-toolchain.sh /tmp/\n+RUN /tmp/freebsd-toolchain.sh i686\n+\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n@@ -99,6 +105,7 @@ ENV TARGETS=$TARGETS,x86_64-fortanix-unknown-sgx\n ENV TARGETS=$TARGETS,nvptx64-nvidia-cuda\n ENV TARGETS=$TARGETS,armv7-unknown-linux-gnueabi\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabi\n+ENV TARGETS=$TARGETS,i686-unknown-freebsd\n \n # As per https://bugs.launchpad.net/ubuntu/+source/gcc-defaults/+bug/1300211\n # we need asm in the search path for gcc-7 (for gnux32) but not in the search path of the"}, {"sha": "031000d147cdfc1601a88ca853c7a74422677f7b", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -328,9 +328,6 @@ jobs:\n           - name: dist-i586-gnu-i586-i686-musl\n             <<: *job-linux-xl\n \n-          - name: dist-i686-freebsd\n-            <<: *job-linux-xl\n-\n           - name: dist-i686-linux\n             <<: *job-linux-xl\n "}, {"sha": "36bf4368990c90f3d1ce415b6b928ba5d4257c66", "filename": "src/ci/scripts/should-skip-this.sh", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fci%2Fscripts%2Fshould-skip-this.sh", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fci%2Fscripts%2Fshould-skip-this.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fshould-skip-this.sh?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -14,6 +14,10 @@ elif git diff HEAD^ | grep --quiet \"^index .* 160000\"; then\n     # Submodules pseudo-files inside git have the 160000 permissions, so when\n     # those files are present in the diff a submodule was updated.\n     echo \"Executing the job since submodules are updated\"\n+elif git diff --name-only HEAD^ | grep --quiet src/tools/clippy; then\n+    # There is not an easy blanket search for subtrees. For now, manually list\n+    # clippy.\n+    echo \"Executing the job since clippy subtree was updated\"\n else\n     echo \"Not executing this job since no submodules were updated\"\n     ciCommandSetEnv SKIP_JOB 1"}, {"sha": "215e5d3d1043ae2f12fc0f6986496b7e55e3193f", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -94,7 +94,7 @@ target | std | host | notes\n `i586-unknown-linux-gnu` | \u2713 |  | 32-bit Linux w/o SSE (kernel 4.4, glibc 2.23)\n `i586-unknown-linux-musl` | \u2713 |  | 32-bit Linux w/o SSE, MUSL\n `i686-linux-android` | \u2713 |  | 32-bit x86 Android\n-`i686-unknown-freebsd` | \u2713 | \u2713 | 32-bit FreeBSD\n+`i686-unknown-freebsd` | \u2713 |  | 32-bit FreeBSD\n `i686-unknown-linux-musl` | \u2713 |  | 32-bit Linux with MUSL\n `mips-unknown-linux-gnu` | \u2713 | \u2713 | MIPS Linux (kernel 4.4, glibc 2.23)\n `mips-unknown-linux-musl` | \u2713 |  | MIPS Linux with MUSL"}, {"sha": "f5b73128ad6c28a80a259f75f85879ca881f0b25", "filename": "src/doc/unstable-book/src/language-features/cfg-panic.md", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-panic.md", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-panic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-panic.md?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -0,0 +1,38 @@\n+# `cfg_panic`\n+\n+The tracking issue for this feature is: [#77443]\n+\n+[#77443]: https://github.com/rust-lang/rust/issues/77443\n+\n+------------------------\n+\n+The `cfg_panic` feature makes it possible to execute different code\n+depending on the panic strategy.\n+\n+Possible values at the moment are `\"unwind\"` or `\"abort\"`, although\n+it is possible that new panic strategies may be added to Rust in the\n+future.\n+\n+## Examples\n+\n+```rust\n+#![feature(cfg_panic)]\n+\n+#[cfg(panic = \"unwind\")]\n+fn a() {\n+    // ...\n+}\n+\n+#[cfg(not(panic = \"unwind\"))]\n+fn a() {\n+    // ...\n+}\n+\n+fn b() {\n+    if cfg!(panic = \"abort\") {\n+        // ...\n+    } else {\n+        // ...\n+    }\n+}\n+```"}, {"sha": "63ad57de1d46495147c786fc4f69c73952d6d29b", "filename": "src/test/mir-opt/inline/inline-cycle.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fmir-opt%2Finline%2Finline-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fmir-opt%2Finline%2Finline-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-cycle.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -0,0 +1,60 @@\n+// Check that inliner handles various forms of recursion and doesn't fall into\n+// an infinite inlining cycle. The particular outcome of inlining is not\n+// crucial otherwise.\n+//\n+// Regression test for issue #78573.\n+\n+fn main() {\n+    one();\n+    two();\n+}\n+\n+// EMIT_MIR inline_cycle.one.Inline.diff\n+fn one() {\n+    <C as Call>::call();\n+}\n+\n+pub trait Call {\n+    fn call();\n+}\n+\n+pub struct A<T>(T);\n+pub struct B<T>(T);\n+pub struct C;\n+\n+impl<T: Call> Call for A<T> {\n+    #[inline]\n+    fn call() {\n+        <B<T> as Call>::call()\n+    }\n+}\n+\n+\n+impl<T: Call> Call for B<T> {\n+    #[inline]\n+    fn call() {\n+        <T as Call>::call()\n+    }\n+}\n+\n+impl Call for C {\n+    #[inline]\n+    fn call() {\n+        A::<C>::call()\n+    }\n+}\n+\n+// EMIT_MIR inline_cycle.two.Inline.diff\n+fn two() {\n+    call(f);\n+}\n+\n+#[inline]\n+fn call<F: FnOnce()>(f: F) {\n+    f();\n+}\n+\n+#[inline]\n+fn f() {\n+    call(f);\n+}"}, {"sha": "1b53c82788540b1b093b66e57895ad8cb2453930", "filename": "src/test/mir-opt/inline/inline_cycle.one.Inline.diff", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.one.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.one.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.one.Inline.diff?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -0,0 +1,27 @@\n+- // MIR for `one` before Inline\n++ // MIR for `one` after Inline\n+  \n+  fn one() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-cycle.rs:13:10: 13:10\n+      let _1: ();                          // in scope 0 at $DIR/inline-cycle.rs:14:5: 14:24\n++     scope 1 (inlined <C as Call>::call) { // at $DIR/inline-cycle.rs:14:5: 14:24\n++     }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-cycle.rs:14:5: 14:24\n+-         _1 = <C as Call>::call() -> bb1; // scope 0 at $DIR/inline-cycle.rs:14:5: 14:24\n++         _1 = <A<C> as Call>::call() -> bb1; // scope 1 at $DIR/inline-cycle.rs:14:5: 14:24\n+                                           // mir::Constant\n+-                                          // + span: $DIR/inline-cycle.rs:14:5: 14:22\n+-                                          // + literal: Const { ty: fn() {<C as Call>::call}, val: Value(Scalar(<ZST>)) }\n++                                          // + span: $DIR/inline-cycle.rs:14:5: 14:24\n++                                          // + literal: Const { ty: fn() {<A<C> as Call>::call}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-cycle.rs:14:24: 14:25\n+          _0 = const ();                   // scope 0 at $DIR/inline-cycle.rs:13:10: 15:2\n+          return;                          // scope 0 at $DIR/inline-cycle.rs:15:2: 15:2\n+      }\n+  }\n+  "}, {"sha": "b44baca9bf49794ef9268408168fb58dcdb3ecfa", "filename": "src/test/mir-opt/inline/inline_cycle.two.Inline.diff", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.two.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.two.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.two.Inline.diff?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -0,0 +1,47 @@\n+- // MIR for `two` before Inline\n++ // MIR for `two` after Inline\n+  \n+  fn two() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-cycle.rs:48:10: 48:10\n+      let _1: ();                          // in scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n++     let mut _2: fn() {f};                // in scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n++     let mut _5: ();                      // in scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n++     scope 1 (inlined call::<fn() {f}>) { // at $DIR/inline-cycle.rs:49:5: 49:12\n++         debug f => _2;                   // in scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         let _3: ();                      // in scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         let mut _4: fn() {f};            // in scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         scope 2 (inlined <fn() {f} as FnOnce<()>>::call_once - shim(fn() {f})) { // at $DIR/inline-cycle.rs:49:5: 49:12\n++         }\n++     }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n+-         _1 = call::<fn() {f}>(f) -> bb1; // scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n++         StorageLive(_2);                 // scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n++         _2 = f;                          // scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n+                                           // mir::Constant\n+-                                          // + span: $DIR/inline-cycle.rs:49:5: 49:9\n+-                                          // + literal: Const { ty: fn(fn() {f}) {call::<fn() {f}>}, val: Value(Scalar(<ZST>)) }\n+-                                          // mir::Constant\n+                                           // + span: $DIR/inline-cycle.rs:49:10: 49:11\n+                                           // + literal: Const { ty: fn() {f}, val: Value(Scalar(<ZST>)) }\n++         StorageLive(_3);                 // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         StorageLive(_4);                 // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         _4 = move _2;                    // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         StorageLive(_5);                 // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         _5 = const ();                   // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         _3 = move _4() -> bb1;           // scope 2 at $DIR/inline-cycle.rs:49:5: 49:12\n+      }\n+  \n+      bb1: {\n++         StorageDead(_5);                 // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         StorageDead(_4);                 // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         StorageDead(_3);                 // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         _1 = const ();                   // scope 1 at $DIR/inline-cycle.rs:49:5: 49:12\n++         StorageDead(_2);                 // scope 0 at $DIR/inline-cycle.rs:49:5: 49:12\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-cycle.rs:49:12: 49:13\n+          _0 = const ();                   // scope 0 at $DIR/inline-cycle.rs:48:10: 50:2\n+          return;                          // scope 0 at $DIR/inline-cycle.rs:50:2: 50:2\n+      }\n+  }\n+  "}, {"sha": "95683241aba26738fb72c501138ccc1956f80d74", "filename": "src/test/ui/async-await/issue-74072-lifetime-name-annotations.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -0,0 +1,37 @@\n+// edition:2018\n+#![feature(async_closure)]\n+use std::future::Future;\n+\n+// test the quality of annotations giving lifetimes names (`'1`) when async constructs are involved\n+\n+pub async fn async_fn(x: &mut i32) -> &i32 {\n+    let y = &*x;\n+    *x += 1; //~ ERROR cannot assign to `*x` because it is borrowed\n+    y\n+}\n+\n+pub fn async_closure(x: &mut i32) -> impl Future<Output=&i32> {\n+    (async move || {\n+        let y = &*x;\n+        *x += 1; //~ ERROR cannot assign to `*x` because it is borrowed\n+        y\n+    })()\n+}\n+\n+pub fn async_closure_explicit_return_type(x: &mut i32) -> impl Future<Output=&i32> {\n+    (async move || -> &i32 {\n+        let y = &*x;\n+        *x += 1; //~ ERROR cannot assign to `*x` because it is borrowed\n+        y\n+    })()\n+}\n+\n+pub fn async_block(x: &mut i32) -> impl Future<Output=&i32> {\n+    async move {\n+        let y = &*x;\n+        *x += 1; //~ ERROR cannot assign to `*x` because it is borrowed\n+        y\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "123c3192cffba66552ab8130dbcad9643b32f0ef", "filename": "src/test/ui/async-await/issue-74072-lifetime-name-annotations.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.stderr?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -0,0 +1,51 @@\n+error[E0506]: cannot assign to `*x` because it is borrowed\n+  --> $DIR/issue-74072-lifetime-name-annotations.rs:9:5\n+   |\n+LL | pub async fn async_fn(x: &mut i32) -> &i32 {\n+   |                                       - let's call the lifetime of this reference `'1`\n+LL |     let y = &*x;\n+   |             --- borrow of `*x` occurs here\n+LL |     *x += 1;\n+   |     ^^^^^^^ assignment to borrowed `*x` occurs here\n+LL |     y\n+   |     - returning this value requires that `*x` is borrowed for `'1`\n+\n+error[E0506]: cannot assign to `*x` because it is borrowed\n+  --> $DIR/issue-74072-lifetime-name-annotations.rs:16:9\n+   |\n+LL |         let y = &*x;\n+   |                 --- borrow of `*x` occurs here\n+LL |         *x += 1;\n+   |         ^^^^^^^ assignment to borrowed `*x` occurs here\n+LL |         y\n+   |         - returning this value requires that `*x` is borrowed for `'1`\n+LL |     })()\n+   |     - return type of async closure is &'1 i32\n+\n+error[E0506]: cannot assign to `*x` because it is borrowed\n+  --> $DIR/issue-74072-lifetime-name-annotations.rs:24:9\n+   |\n+LL |     (async move || -> &i32 {\n+   |                       - let's call the lifetime of this reference `'1`\n+LL |         let y = &*x;\n+   |                 --- borrow of `*x` occurs here\n+LL |         *x += 1;\n+   |         ^^^^^^^ assignment to borrowed `*x` occurs here\n+LL |         y\n+   |         - returning this value requires that `*x` is borrowed for `'1`\n+\n+error[E0506]: cannot assign to `*x` because it is borrowed\n+  --> $DIR/issue-74072-lifetime-name-annotations.rs:32:9\n+   |\n+LL |         let y = &*x;\n+   |                 --- borrow of `*x` occurs here\n+LL |         *x += 1;\n+   |         ^^^^^^^ assignment to borrowed `*x` occurs here\n+LL |         y\n+   |         - returning this value requires that `*x` is borrowed for `'1`\n+LL |     }\n+   |     - return type of async block is &'1 i32\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "2d765eb41be07ecca0865d24d74a5250d4c3e489", "filename": "src/test/ui/async-await/issue-74497-lifetime-in-opaque.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -0,0 +1,19 @@\n+// edition:2018\n+\n+// test that names give to anonymous lifetimes in opaque types like `impl Future` are correctly\n+// introduced in error messages\n+\n+use std::future::Future;\n+\n+pub async fn foo<F, T>(_: F)\n+where\n+    F: Fn(&u8) -> T,\n+    T: Future<Output = ()>,\n+{\n+}\n+\n+pub async fn bar(_: &u8) {}\n+\n+fn main() {\n+    let _ = foo(|x| bar(x)); //~ ERROR lifetime may not live long enough\n+}"}, {"sha": "89fe1abb3656b5c3e2eda9076c53b0528993fd65", "filename": "src/test/ui/async-await/issue-74497-lifetime-in-opaque.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.stderr?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -0,0 +1,11 @@\n+error: lifetime may not live long enough\n+  --> $DIR/issue-74497-lifetime-in-opaque.rs:18:21\n+   |\n+LL |     let _ = foo(|x| bar(x));\n+   |                  -- ^^^^^^ returning this value requires that `'1` must outlive `'2`\n+   |                  ||\n+   |                  |return type of closure `impl Future` contains a lifetime `'2`\n+   |                  has type `&'1 u8`\n+\n+error: aborting due to previous error\n+"}, {"sha": "a7c3b9eec73c5624cb94f2c1718ae4e81299720a", "filename": "src/test/ui/borrowck/issue-53432-nested-closure-outlives-borrowed-value.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fborrowck%2Fissue-53432-nested-closure-outlives-borrowed-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fborrowck%2Fissue-53432-nested-closure-outlives-borrowed-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-53432-nested-closure-outlives-borrowed-value.stderr?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -4,7 +4,7 @@ error: lifetime may not live long enough\n LL |     let _action = move || {\n    |                   -------\n    |                   |     |\n-   |                   |     return type of closure is [closure@$DIR/issue-53432-nested-closure-outlives-borrowed-value.rs:4:9: 4:15]\n+   |                   |     return type of closure `[closure@$DIR/issue-53432-nested-closure-outlives-borrowed-value.rs:4:9: 4:15]` contains a lifetime `'2`\n    |                   lifetime `'1` represents this closure's body\n LL |         || f() // The `nested` closure\n    |         ^^^^^^ returning this value requires that `'1` must outlive `'2`"}, {"sha": "9b88eff12ed38481a659aa4be038c586aba00917", "filename": "src/test/ui/cfg/cfg-panic-abort.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fcfg%2Fcfg-panic-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fcfg%2Fcfg-panic-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg%2Fcfg-panic-abort.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -0,0 +1,16 @@\n+// build-pass\n+// compile-flags: -C panic=abort\n+// no-prefer-dynamic\n+#![feature(cfg_panic)]\n+\n+#[cfg(panic = \"unwind\")]\n+pub fn bad() -> i32 { }\n+\n+#[cfg(not(panic = \"abort\"))]\n+pub fn bad() -> i32 { }\n+\n+#[cfg(panic = \"some_imaginary_future_panic_handler\")]\n+pub fn bad() -> i32 { }\n+\n+#[cfg(panic = \"abort\")]\n+pub fn main() { }"}, {"sha": "dbb5932a9bb85a6a64cb47f1b07ecaf83e4b2ebe", "filename": "src/test/ui/cfg/cfg-panic.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fcfg%2Fcfg-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fcfg%2Fcfg-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg%2Fcfg-panic.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -0,0 +1,18 @@\n+// build-pass\n+// compile-flags: -C panic=unwind\n+// ignore-emscripten no panic_unwind implementation\n+// ignore-wasm32     no panic_unwind implementation\n+// ignore-wasm64     no panic_unwind implementation\n+#![feature(cfg_panic)]\n+\n+#[cfg(panic = \"abort\")]\n+pub fn bad() -> i32 { }\n+\n+#[cfg(not(panic = \"unwind\"))]\n+pub fn bad() -> i32 { }\n+\n+#[cfg(panic = \"some_imaginary_future_panic_handler\")]\n+pub fn bad() -> i32 { }\n+\n+#[cfg(panic = \"unwind\")]\n+pub fn main() { }"}, {"sha": "a20acce4c76b2e64e986ddff4dbc8c93ad1bb5be", "filename": "src/test/ui/chalkify/arithmetic.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fchalkify%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fchalkify%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Farithmetic.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+fn main() {\n+    1 + 2;\n+    3 * 6;\n+    2 - 5;\n+    17 / 6;\n+    23 % 11;\n+    4 & 6;\n+    7 | 15;\n+    4 << 7;\n+    123 >> 3;\n+    1 == 2;\n+    5 != 5;\n+    6 < 2;\n+    7 > 11;\n+    3 <= 1;\n+    9 >= 14;\n+}"}, {"sha": "13d9e6a6578856fd89c5a359bcf2f4434280ce0c", "filename": "src/test/ui/chalkify/trait-objects.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fchalkify%2Ftrait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fchalkify%2Ftrait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftrait-objects.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+use std::fmt::Display;\n+\n+fn main() {\n+    let d: &dyn Display = &mut 3;\n+    // FIXME(chalk) should be able to call d.to_string() as well, but doing so\n+    // requires Chalk to be able to prove trait object well-formed goals.\n+    (&d).to_string();\n+    let f: &dyn Fn(i32) -> _ = &|x| x + x;\n+    f(2);\n+}"}, {"sha": "03662a352090927a1e25d7504c08c43e7bcfd029", "filename": "src/test/ui/consts/control-flow/assert.const_panic.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.const_panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.const_panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.const_panic.stderr?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "previous_filename": "src/test/ui/consts/control-flow/assert.panic.stderr"}, {"sha": "90017fee1933738022a13a7cc6b0167f21af6f97", "filename": "src/test/ui/consts/control-flow/assert.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -1,14 +1,14 @@\n // Test that `assert` works when `const_panic` is enabled.\n \n-// revisions: stock panic\n+// revisions: stock const_panic\n \n-#![cfg_attr(panic, feature(const_panic))]\n+#![cfg_attr(const_panic, feature(const_panic))]\n \n const _: () = assert!(true);\n //[stock]~^ ERROR panicking in constants is unstable\n \n const _: () = assert!(false);\n //[stock]~^ ERROR panicking in constants is unstable\n-//[panic]~^^ ERROR any use of this value will cause an error\n+//[const_panic]~^^ ERROR any use of this value will cause an error\n \n fn main() {}"}, {"sha": "1508374d9426622b852b97403aa99d7aeaac458f", "filename": "src/test/ui/feature-gates/feature-gate-cfg-panic.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-panic.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -0,0 +1,11 @@\n+#[cfg(panic = \"unwind\")]\n+//~^ ERROR `cfg(panic)` is experimental and subject to change\n+fn foo() -> bool { true }\n+#[cfg(not(panic = \"unwind\"))]\n+//~^ ERROR `cfg(panic)` is experimental and subject to change\n+fn foo() -> bool { false }\n+\n+\n+fn main() {\n+    assert!(foo());\n+}"}, {"sha": "ea5cd54fa90f0e3716f67758198408711edbb572", "filename": "src/test/ui/feature-gates/feature-gate-cfg-panic.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-panic.stderr?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -0,0 +1,21 @@\n+error[E0658]: `cfg(panic)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-panic.rs:1:7\n+   |\n+LL | #[cfg(panic = \"unwind\")]\n+   |       ^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #77443 <https://github.com/rust-lang/rust/issues/77443> for more information\n+   = help: add `#![feature(cfg_panic)]` to the crate attributes to enable\n+\n+error[E0658]: `cfg(panic)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-panic.rs:4:11\n+   |\n+LL | #[cfg(not(panic = \"unwind\"))]\n+   |           ^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #77443 <https://github.com/rust-lang/rust/issues/77443> for more information\n+   = help: add `#![feature(cfg_panic)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "9348bb46dfe34e6ffd3b229232f24bea461337c6", "filename": "src/test/ui/fmt/format-args-capture.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Ffmt%2Fformat-args-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Ffmt%2Fformat-args-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-args-capture.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -1,13 +1,16 @@\n // run-pass\n-// ignore-wasm32\n-// ignore-wasm64\n #![feature(format_args_capture)]\n+#![feature(cfg_panic)]\n \n fn main() {\n     named_argument_takes_precedence_to_captured();\n-    panic_with_single_argument_does_not_get_formatted();\n-    panic_with_multiple_arguments_is_formatted();\n     formatting_parameters_can_be_captured();\n+\n+    #[cfg(panic = \"unwind\")]\n+    {\n+        panic_with_single_argument_does_not_get_formatted();\n+        panic_with_multiple_arguments_is_formatted();\n+    }\n }\n \n fn named_argument_takes_precedence_to_captured() {\n@@ -22,6 +25,7 @@ fn named_argument_takes_precedence_to_captured() {\n     assert_eq!(&s, \"positional-named-captured\");\n }\n \n+#[cfg(panic = \"unwind\")]\n fn panic_with_single_argument_does_not_get_formatted() {\n     // panic! with a single argument does not perform string formatting.\n     // RFC #2795 suggests that this may need to change so that captured arguments are formatted.\n@@ -34,6 +38,7 @@ fn panic_with_single_argument_does_not_get_formatted() {\n     assert_eq!(msg.downcast_ref::<&str>(), Some(&\"{foo}\"))\n }\n \n+#[cfg(panic = \"unwind\")]\n fn panic_with_multiple_arguments_is_formatted() {\n     let foo = \"captured\";\n "}, {"sha": "f25a78f59cd20792dc6a4baf1cdcfe2fdcd7b550", "filename": "src/test/ui/issues/issue-68696-catch-during-unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fissues%2Fissue-68696-catch-during-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fissues%2Fissue-68696-catch-during-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-68696-catch-during-unwind.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -4,8 +4,7 @@\n // entering the catch_unwind.\n //\n // run-pass\n-// ignore-wasm       no panic support\n-// ignore-emscripten no panic support\n+#![feature(cfg_panic)]\n \n use std::panic::catch_unwind;\n \n@@ -19,6 +18,7 @@ impl Drop for Guard {\n }\n \n fn main() {\n+    #[cfg(panic = \"unwind\")]\n     let _ = catch_unwind(|| {\n         let _guard = Guard::default();\n         panic!();"}, {"sha": "e41ee8a89709caf48ed2af2c6b3d953c35c325a4", "filename": "src/test/ui/nll/issue-58053.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fnll%2Fissue-58053.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fnll%2Fissue-58053.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-58053.stderr?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -2,9 +2,9 @@ error: lifetime may not live long enough\n   --> $DIR/issue-58053.rs:6:33\n    |\n LL |     let f = |x: &i32| -> &i32 { x };\n-   |                 -        ----   ^ returning this value requires that `'1` must outlive `'2`\n+   |                 -        -      ^ returning this value requires that `'1` must outlive `'2`\n    |                 |        |\n-   |                 |        return type of closure is &'2 i32\n+   |                 |        let's call the lifetime of this reference `'2`\n    |                 let's call the lifetime of this reference `'1`\n \n error: lifetime may not live long enough"}, {"sha": "30f3781bf7743c5af43c1e324a7715ddf1726729", "filename": "src/test/ui/parser/issue-65122-mac-invoc-in-mut-patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fparser%2Fissue-65122-mac-invoc-in-mut-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Fparser%2Fissue-65122-mac-invoc-in-mut-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-65122-mac-invoc-in-mut-patterns.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -1,4 +1,4 @@\n-// Regression test; used to ICE with 'visit_mac disabled by default' due to a\n+// Regression test; used to ICE with 'visit_mac_call disabled by default' due to a\n // `MutVisitor` in `fn make_all_value_bindings_mutable` (`parse/parser/pat.rs`).\n \n macro_rules! mac1 {"}, {"sha": "29ce9f7c2e94fe3dd1d5f663cf9854e3c528e70c", "filename": "src/test/ui/test-attrs/test-allow-fail-attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-allow-fail-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-allow-fail-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-allow-fail-attr.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -1,11 +1,12 @@\n // run-pass\n-// ignore-wasm32-bare compiled with panic=abort by default\n // compile-flags: --test\n #![feature(allow_fail)]\n+#![feature(cfg_panic)]\n \n #[test]\n #[allow_fail]\n fn test1() {\n+    #[cfg(not(panic = \"abort\"))]\n     panic!();\n }\n "}, {"sha": "6b175490cc8331f2d6cda2efe280079d0d957a9e", "filename": "src/tools/clippy/clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9cf7c923eb01146971429044f216a3ca905e06/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=cf9cf7c923eb01146971429044f216a3ca905e06", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{span_lint, span_lint_and_then};\n use rustc_ast::ast::{\n-    Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, Item, ItemKind, Local, MacCall, Pat, PatKind,\n+    Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, Item, ItemKind, Local, Pat, PatKind,\n };\n use rustc_ast::visit::{walk_block, walk_expr, walk_pat, Visitor};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n@@ -150,9 +150,6 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n             _ => walk_pat(self, pat),\n         }\n     }\n-    fn visit_mac(&mut self, _mac: &MacCall) {\n-        // do not check macs\n-    }\n }\n \n #[must_use]\n@@ -357,9 +354,6 @@ impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, _: &Item) {\n         // do not recurse into inner items\n     }\n-    fn visit_mac(&mut self, _mac: &MacCall) {\n-        // do not check macs\n-    }\n }\n \n impl EarlyLintPass for NonExpressiveNames {"}]}