{"sha": "d2ae28fc99328ab1b7176560ed643a84a8883403", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyYWUyOGZjOTkzMjhhYjFiNzE3NjU2MGVkNjQzYTg0YTg4ODM0MDM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T06:39:08Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:54:45Z"}, "message": "Convert rustc::util to istrs. Issue #855", "tree": {"sha": "c39f2049db5afa95604679df1954b9734edb50b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c39f2049db5afa95604679df1954b9734edb50b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2ae28fc99328ab1b7176560ed643a84a8883403", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ae28fc99328ab1b7176560ed643a84a8883403", "html_url": "https://github.com/rust-lang/rust/commit/d2ae28fc99328ab1b7176560ed643a84a8883403", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2ae28fc99328ab1b7176560ed643a84a8883403/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "html_url": "https://github.com/rust-lang/rust/commit/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e"}], "stats": {"total": 420, "additions": 221, "deletions": 199}, "files": [{"sha": "666145cdd9c7eceb94532a0d2d10c39a23c28507", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=d2ae28fc99328ab1b7176560ed643a84a8883403", "patch": "@@ -118,7 +118,7 @@ fn time<@T>(do_it: bool, what: str, thunk: fn() -> T) -> T {\n     let rv = thunk();\n     let end = std::time::precise_time_s();\n     log_err #fmt[\"time: %s took %s s\", what,\n-                 common::float_to_str(end - start, 3u)];\n+                 istr::to_estr(common::float_to_str(end - start, 3u))];\n     ret rv;\n }\n \n@@ -184,7 +184,9 @@ fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n             pp::space(s.s);\n             pp::word(s.s, \"as\");\n             pp::space(s.s);\n-            pp::word(s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n+            pp::word(\n+                s.s,\n+                istr::to_estr(ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr))));\n             pprust::pclose(s);\n           }\n           _ { }"}, {"sha": "078f3e1850ddb99fac29add55a14060254f669fb", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=d2ae28fc99328ab1b7176560ed643a84a8883403", "patch": "@@ -123,7 +123,8 @@ fn default_native_lib_naming(sess: session::session, static: bool) ->\n }\n \n fn find_library_crate(sess: &session::session, ident: &ast::ident,\n-                      metas: &[@ast::meta_item], library_search_paths: &[istr])\n+                      metas: &[@ast::meta_item],\n+                      library_search_paths: &[istr])\n    -> option::t<{ident: istr, data: @[u8]}> {\n \n     attr::require_unique_names(sess, metas);"}, {"sha": "646913eafb468309e65ea01b7c93d5c40af3dded", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=d2ae28fc99328ab1b7176560ed643a84a8883403", "patch": "@@ -390,9 +390,10 @@ fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n       ty::ty_vec(mt) { if mt.mut != ast::imm { unsafe = [seq_t]; } }\n       ty::ty_str. | ty::ty_istr. {/* no-op */ }\n       _ {\n-        cx.tcx.sess.span_unimpl(seq.span,\n-                                \"unknown seq type \" +\n-                                    util::ppaux::ty_to_str(cx.tcx, seq_t));\n+        cx.tcx.sess.span_unimpl(\n+            seq.span,\n+            \"unknown seq type \" +\n+            istr::to_estr(util::ppaux::ty_to_str(cx.tcx, seq_t)));\n       }\n     }\n     let bindings = ast_util::pat_binding_ids(local.node.pat);"}, {"sha": "20fa549adb342678cf8179a01f09f05e77427ae5", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=d2ae28fc99328ab1b7176560ed643a84a8883403", "patch": "@@ -77,6 +77,7 @@ import syntax::visit;\n \n import std::vec;\n import std::option;\n+import std::istr;\n \n import ast::kind;\n import ast::kind_unique;\n@@ -115,13 +116,13 @@ fn need_expr_kind(tcx: &ty::ctxt, e: &@ast::expr, k_need: ast::kind,\n     let tk = type_and_kind(tcx, e);\n     log #fmt[\"for %s: want %s type, got %s type %s\", descr,\n              kind_to_str(k_need), kind_to_str(tk.kind),\n-             util::ppaux::ty_to_str(tcx, tk.ty)];\n+             istr::to_estr(util::ppaux::ty_to_str(tcx, tk.ty))];\n \n     if !kind_lteq(k_need, tk.kind) {\n         let s =\n             #fmt[\"mismatched kinds for %s: needed %s type, got %s type %s\",\n                  descr, kind_to_str(k_need), kind_to_str(tk.kind),\n-                 util::ppaux::ty_to_str(tcx, tk.ty)];\n+                 istr::to_estr(util::ppaux::ty_to_str(tcx, tk.ty))];\n         tcx.sess.span_err(e.span, s);\n     }\n }\n@@ -170,7 +171,7 @@ fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n                         #fmt[\"mismatched kinds for typaram %d: \\\n                                   needed %s type, got %s type %s\",\n                              i, kind_to_str(k_need), kind_to_str(k),\n-                             util::ppaux::ty_to_str(tcx, t)];\n+                             istr::to_estr(util::ppaux::ty_to_str(tcx, t))];\n                     tcx.sess.span_err(e.span, s);\n                 }\n                 i += 1;"}, {"sha": "67189688b3470621f47f395eb82519172cce0999", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d2ae28fc99328ab1b7176560ed643a84a8883403", "patch": "@@ -84,7 +84,7 @@ fn type_of(cx: &@crate_ctxt, sp: &span, t: ty::t) -> TypeRef {\n     if ty::type_has_dynamic_size(cx.tcx, t) {\n         cx.sess.span_fatal(sp,\n                            \"type_of() called on a type with dynamic size: \" +\n-                               ty_to_str(cx.tcx, t));\n+                           istr::to_estr(ty_to_str(cx.tcx, t)));\n     }\n     ret type_of_inner(cx, sp, t);\n }\n@@ -1060,12 +1060,13 @@ fn get_tydesc(cx: &@block_ctxt, orig_t: ty::t, escapes: bool,\n         if id < vec::len(cx.fcx.lltydescs) {\n             ret {kind: tk_param, result: rslt(cx, cx.fcx.lltydescs[id])};\n         } else {\n-            bcx_tcx(cx).sess.span_bug(cx.sp,\n-                                      \"Unbound typaram in get_tydesc: \" +\n-                                      \"orig_t = \" +\n-                                      ty_to_str(bcx_tcx(cx), orig_t) +\n-                                      \" ty_param = \" +\n-                                      istr::to_estr(std::uint::str(id)));\n+            bcx_tcx(cx).sess.span_bug(\n+                cx.sp,\n+                \"Unbound typaram in get_tydesc: \" +\n+                \"orig_t = \" +\n+                istr::to_estr(ty_to_str(bcx_tcx(cx), orig_t)) +\n+                \" ty_param = \" +\n+                istr::to_estr(std::uint::str(id)));\n         }\n       }\n       none. {/* fall through */ }\n@@ -1129,7 +1130,7 @@ fn set_glue_inlining(cx: &@local_ctxt, f: ValueRef, t: ty::t) {\n // Generates the declaration for (but doesn't emit) a type descriptor.\n fn declare_tydesc(cx: &@local_ctxt, sp: &span, t: ty::t, ty_params: &[uint])\n    -> @tydesc_info {\n-    log \"+++ declare_tydesc \" + ty_to_str(cx.ccx.tcx, t);\n+    log ~\"+++ declare_tydesc \" + ty_to_str(cx.ccx.tcx, t);\n     let ccx = cx.ccx;\n     let llsize;\n     let llalign;\n@@ -1163,7 +1164,7 @@ fn declare_tydesc(cx: &@local_ctxt, sp: &span, t: ty::t, ty_params: &[uint])\n           mutable cmp_glue: none::<ValueRef>,\n           mutable copy_glue: none::<ValueRef>,\n           ty_params: ty_params};\n-    log \"--- declare_tydesc \" + ty_to_str(cx.ccx.tcx, t);\n+    log ~\"--- declare_tydesc \" + ty_to_str(cx.ccx.tcx, t);\n     ret info;\n }\n \n@@ -2029,9 +2030,9 @@ fn iter_sequence(cx: @block_ctxt, v: ValueRef, t: ty::t, f: &val_and_ty_fn)\n         ret iter_sequence_body(cx, v, et, f, true, true);\n       }\n       _ {\n-        bcx_ccx(cx).sess.bug(\"unexpected type in \\\n-                                 trans::iter_sequence: \"\n-                                 + ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n+        bcx_ccx(cx).sess.bug(\n+            \"unexpected type in trans::iter_sequence: \"\n+            + istr::to_estr(ty_to_str(cx.fcx.lcx.ccx.tcx, t)));\n       }\n     }\n }\n@@ -2062,7 +2063,7 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n               some(_) { }\n               none. {\n                 log #fmt[\"+++ lazily_emit_tydesc_glue TAKE %s\",\n-                         ty_to_str(bcx_tcx(cx), ti.ty)];\n+                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n                     declare_generic_glue(lcx, ti.ty, T_glue_fn(*lcx.ccx),\n@@ -2072,15 +2073,15 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                                   default_helper(make_take_glue),\n                                   ti.ty_params, ~\"take\");\n                 log #fmt[\"--- lazily_emit_tydesc_glue TAKE %s\",\n-                         ty_to_str(bcx_tcx(cx), ti.ty)];\n+                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n               }\n             }\n         } else if field == abi::tydesc_field_drop_glue {\n             alt { ti.drop_glue } {\n               some(_) { }\n               none. {\n                 log #fmt[\"+++ lazily_emit_tydesc_glue DROP %s\",\n-                         ty_to_str(bcx_tcx(cx), ti.ty)];\n+                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n                     declare_generic_glue(lcx, ti.ty, T_glue_fn(*lcx.ccx),\n@@ -2090,15 +2091,15 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                                   default_helper(make_drop_glue),\n                                   ti.ty_params, ~\"drop\");\n                 log #fmt[\"--- lazily_emit_tydesc_glue DROP %s\",\n-                         ty_to_str(bcx_tcx(cx), ti.ty)];\n+                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n               }\n             }\n          } else if field == abi::tydesc_field_free_glue {\n             alt { ti.free_glue } {\n               some(_) { }\n               none. {\n                 log #fmt[\"+++ lazily_emit_tydesc_glue FREE %s\",\n-                         ty_to_str(bcx_tcx(cx), ti.ty)];\n+                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n                     declare_generic_glue(lcx, ti.ty, T_glue_fn(*lcx.ccx),\n@@ -2108,18 +2109,18 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                                   default_helper(make_free_glue),\n                                   ti.ty_params, ~\"free\");\n                 log #fmt[\"--- lazily_emit_tydesc_glue FREE %s\",\n-                         ty_to_str(bcx_tcx(cx), ti.ty)];\n+                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n               }\n             }\n         } else if field == abi::tydesc_field_cmp_glue {\n             alt { ti.cmp_glue } {\n               some(_) { }\n               none. {\n                 log #fmt[\"+++ lazily_emit_tydesc_glue CMP %s\",\n-                         ty_to_str(bcx_tcx(cx), ti.ty)];\n+                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n                 ti.cmp_glue = some(bcx_ccx(cx).upcalls.cmp_type);\n                 log #fmt[\"--- lazily_emit_tydesc_glue CMP %s\",\n-                         ty_to_str(bcx_tcx(cx), ti.ty)];\n+                         istr::to_estr(ty_to_str(bcx_tcx(cx), ti.ty))];\n               }\n             }\n         } else if field == abi::tydesc_field_copy_glue {\n@@ -2421,7 +2422,7 @@ fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n         }\n     }\n     ccx.sess.bug(\"unexpected type in trans::copy_val_no_check: \" +\n-                     ty_to_str(ccx.tcx, t));\n+                 istr::to_estr(ty_to_str(ccx.tcx, t)));\n }\n \n \n@@ -2468,7 +2469,7 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n         }\n     }\n     bcx_ccx(cx).sess.bug(\"unexpected type in trans::move_val: \" +\n-                             ty_to_str(tcx, t));\n+                         istr::to_estr(ty_to_str(tcx, t)));\n }\n \n fn move_val_if_temp(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n@@ -4627,9 +4628,8 @@ fn trans_fail_expr(cx: &@block_ctxt, sp_opt: &option::t<span>,\n             ret trans_fail_value(bcx, sp_opt, elt);\n         } else {\n             bcx_ccx(cx).sess.span_bug(expr.span,\n-                                      \"fail called with unsupported \\\n-                                             type \"\n-                                          + ty_to_str(tcx, e_ty));\n+                                      \"fail called with unsupported type \"\n+                                      + istr::to_estr(ty_to_str(tcx, e_ty)));\n         }\n       }\n       _ { ret trans_fail(bcx, sp_opt, ~\"explicit failure\"); }"}, {"sha": "a8e0bab361715a452c5b4d5bc488f0a2cff41d06", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=d2ae28fc99328ab1b7176560ed643a84a8883403", "patch": "@@ -1119,8 +1119,9 @@ fn callee_modes(fcx: &fn_ctxt, callee: node_id) -> [ty::mode] {\n       }\n       _ {\n         // Shouldn't happen; callee should be ty_fn.\n-        fcx.ccx.tcx.sess.bug(\"non-fn callee type in callee_modes: \" +\n-                                 util::ppaux::ty_to_str(fcx.ccx.tcx, ty));\n+        fcx.ccx.tcx.sess.bug(\n+            \"non-fn callee type in callee_modes: \" +\n+            istr::to_estr(util::ppaux::ty_to_str(fcx.ccx.tcx, ty)));\n       }\n     }\n }"}, {"sha": "2f5db9c4c02854161bb7330ff3abbdef2fa8f36a", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=d2ae28fc99328ab1b7176560ed643a84a8883403", "patch": "@@ -94,7 +94,7 @@ fn add_constraint(tcx: &ty::ctxt, c: sp_constr, next: uint, tbl: constr_map)\n    to a bit number in the precondition/postcondition vectors */\n fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &[ty_param], f_sp: &span,\n               f_name: &fn_ident, id: node_id) {\n-    let name = istr::from_estr(fn_ident_to_string(id, f_name));\n+    let name = fn_ident_to_string(id, f_name);\n     let res_map = @new_def_hash::<constraint>();\n     let next: uint = 0u;\n "}, {"sha": "84c94981615f1dda3caa60341b324484dc100218", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=d2ae28fc99328ab1b7176560ed643a84a8883403", "patch": "@@ -751,7 +751,7 @@ fn fn_pre_post(f: &_fn, tps: &[ty_param], sp: &span, i: &fn_ident,\n     let fcx =\n         {enclosing: ccx.fm.get(id),\n          id: id,\n-         name: istr::from_estr(fn_ident_to_string(id, i)),\n+         name: fn_ident_to_string(id, i),\n          ccx: ccx};\n     find_pre_post_fn(fcx, f);\n }"}, {"sha": "3a7ac5bd6b4b016b422cbd28cd6716159058823d", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=d2ae28fc99328ab1b7176560ed643a84a8883403", "patch": "@@ -896,7 +896,8 @@ fn get_element_type(cx: &ctxt, ty: t, i: uint) -> t {\n       ty_rec(flds) { ret flds[i].mt.ty; }\n       ty_tup(ts) { ret ts[i]; }\n       _ {\n-        cx.sess.bug(\"get_element_type called on type \" + ty_to_str(cx, ty) +\n+        cx.sess.bug(\"get_element_type called on type \" +\n+                    istr::to_estr(ty_to_str(cx, ty)) +\n                         \" - expected a \\\n             tuple or record\");\n       }\n@@ -1120,7 +1121,7 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n \n \n       _ {\n-        cx.sess.bug(\"missed case: \" + ty_to_str(cx, ty));\n+        cx.sess.bug(\"missed case: \" + istr::to_estr(ty_to_str(cx, ty)));\n       }\n     }\n \n@@ -1848,8 +1849,9 @@ fn occurs_check_fails(tcx: &ctxt, sp: &option::t<span>, vid: int, rt: t) ->\n                 s,\n                 \"Type inference failed because I \\\n                  could not find a type\\n that's both of the form \"\n-                + ty_to_str(tcx, ty::mk_var(tcx, vid)) +\n-                \" and of the form \" + ty_to_str(tcx, rt) +\n+                + istr::to_estr(ty_to_str(tcx, ty::mk_var(tcx, vid))) +\n+                \" and of the form \" +\n+                istr::to_estr(ty_to_str(tcx, rt)) +\n                 \". Such a type would have to be infinitely \\\n                  large.\");\n           }\n@@ -2541,7 +2543,9 @@ mod unify {\n             let typespec;\n             alt smallintmap::find::<t>(vb.types, i) {\n               none. { typespec = \"\"; }\n-              some(typ) { typespec = \" =\" + ty_to_str(tcx, typ); }\n+              some(typ) {\n+                typespec = \" =\" + istr::to_estr(ty_to_str(tcx, typ));\n+              }\n             }\n             log_err #fmt[\"set %u:%s%s\", i, typespec, sets];\n             i += 1u;\n@@ -2598,54 +2602,54 @@ mod unify {\n     }\n }\n \n-fn type_err_to_str(err: &ty::type_err) -> str {\n+fn type_err_to_str(err: &ty::type_err) -> istr {\n     alt err {\n-      terr_mismatch. { ret \"types differ\"; }\n+      terr_mismatch. { ret ~\"types differ\"; }\n       terr_controlflow_mismatch. {\n-        ret \"returning function used where non-returning function\" +\n-                \" was expected\";\n+        ret ~\"returning function used where non-returning function\" +\n+                ~\" was expected\";\n       }\n-      terr_box_mutability. { ret \"boxed values differ in mutability\"; }\n-      terr_vec_mutability. { ret \"vectors differ in mutability\"; }\n+      terr_box_mutability. { ret ~\"boxed values differ in mutability\"; }\n+      terr_vec_mutability. { ret ~\"vectors differ in mutability\"; }\n       terr_tuple_size(e_sz, a_sz) {\n-        ret istr::to_estr(~\"expected a tuple with \" +\n-                          uint::to_str(e_sz, 10u) +\n-                          ~\" elements but found one with \" +\n-                          uint::to_str(a_sz, 10u) +\n-                          ~\" elements\");\n+        ret ~\"expected a tuple with \" +\n+            uint::to_str(e_sz, 10u) +\n+            ~\" elements but found one with \" +\n+            uint::to_str(a_sz, 10u) +\n+            ~\" elements\";\n       }\n       terr_record_size(e_sz, a_sz) {\n-        ret istr::to_estr(~\"expected a record with \" +\n-                          uint::to_str(e_sz, 10u) +\n-                          ~\" fields but found one with \" +\n-                          uint::to_str(a_sz, 10u) +\n-                          ~\" fields\");\n+        ret ~\"expected a record with \" +\n+            uint::to_str(e_sz, 10u) +\n+            ~\" fields but found one with \" +\n+            uint::to_str(a_sz, 10u) +\n+            ~\" fields\";\n       }\n-      terr_record_mutability. { ret \"record elements differ in mutability\"; }\n+      terr_record_mutability. { ret ~\"record elements differ in mutability\"; }\n       terr_record_fields(e_fld, a_fld) {\n-        ret \"expected a record with field '\" + istr::to_estr(e_fld) +\n-                \"' but found one with field '\" + istr::to_estr(a_fld) + \"'\";\n+        ret ~\"expected a record with field '\" + e_fld +\n+                ~\"' but found one with field '\" + a_fld + ~\"'\";\n       }\n-      terr_arg_count. { ret \"incorrect number of function parameters\"; }\n-      terr_meth_count. { ret \"incorrect number of object methods\"; }\n+      terr_arg_count. { ret ~\"incorrect number of function parameters\"; }\n+      terr_meth_count. { ret ~\"incorrect number of object methods\"; }\n       terr_obj_meths(e_meth, a_meth) {\n-        ret \"expected an obj with method '\" + istr::to_estr(e_meth) +\n-                \"' but found one with method '\" + istr::to_estr(a_meth) + \"'\";\n+        ret ~\"expected an obj with method '\" + e_meth +\n+                ~\"' but found one with method '\" + a_meth + ~\"'\";\n       }\n       terr_mode_mismatch(e_mode, a_mode) {\n-        ret \"expected argument mode \" + mode_str_1(e_mode) + \" but found \" +\n+        ret ~\"expected argument mode \" + mode_str_1(e_mode) + ~\" but found \" +\n                 mode_str_1(a_mode);\n       }\n       terr_constr_len(e_len, a_len) {\n-        ret istr::to_estr(~\"Expected a type with \" +\n-                          uint::str(e_len) +\n-                          ~\" constraints, but found one with \" +\n-                          uint::str(a_len) + ~\" constraints\");\n+        ret ~\"Expected a type with \" +\n+            uint::str(e_len) +\n+            ~\" constraints, but found one with \" +\n+            uint::str(a_len) + ~\" constraints\";\n       }\n       terr_constr_mismatch(e_constr, a_constr) {\n-        ret \"Expected a type with constraint \" + ty_constr_to_str(e_constr) +\n-                \" but found one with constraint \" +\n-                ty_constr_to_str(a_constr);\n+        ret ~\"Expected a type with constraint \" + ty_constr_to_str(e_constr) +\n+            ~\" but found one with constraint \" +\n+            ty_constr_to_str(a_constr);\n       }\n     }\n }\n@@ -2781,7 +2785,7 @@ fn ret_ty_of_fn_ty(cx: ctxt, a_ty: t) -> t {\n       ty::ty_native_fn(_, _, ret_ty) { ret ret_ty; }\n       _ {\n         cx.sess.bug(\"ret_ty_of_fn_ty() called on non-function type: \" +\n-                        ty_to_str(cx, a_ty));\n+                    istr::to_estr(ty_to_str(cx, a_ty)));\n       }\n     }\n }"}, {"sha": "de71ae08a27aa57e22553d873b15b026d21d95f6", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 53, "deletions": 48, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=d2ae28fc99328ab1b7176560ed643a84a8883403", "patch": "@@ -1010,12 +1010,14 @@ mod demand {\n           ures_err(err) {\n             let e_err = resolve_type_vars_if_possible(fcx, expected);\n             let a_err = resolve_type_vars_if_possible(fcx, actual);\n-            fcx.ccx.tcx.sess.span_err(sp,\n-                                      \"mismatched types: expected \" +\n-                                          ty_to_str(fcx.ccx.tcx, e_err) +\n-                                          \" but found \" +\n-                                          ty_to_str(fcx.ccx.tcx, a_err) + \" (\"\n-                                          + ty::type_err_to_str(err) + \")\");\n+            fcx.ccx.tcx.sess.span_err(\n+                sp,\n+                \"mismatched types: expected \" +\n+                istr::to_estr(ty_to_str(fcx.ccx.tcx, e_err)) +\n+                \" but found \" +\n+                istr::to_estr(ty_to_str(fcx.ccx.tcx, a_err)) + \" (\"\n+                + istr::to_estr(ty::type_err_to_str(err))\n+                + \")\");\n             ret mk_result(fcx, expected, ty_param_subst_var_ids);\n           }\n         }\n@@ -1398,11 +1400,10 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n           _ {\n             // FIXME: Switch expected and actual in this message? I\n             // can never tell.\n-            fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                                        #fmt[\"mismatched types: \\\n-                                                  expected %s, found tag\",\n-                                             ty_to_str(fcx.ccx.tcx,\n-                                                       expected)]);\n+            fcx.ccx.tcx.sess.span_fatal(\n+                pat.span,\n+                #fmt[\"mismatched types: expected %s, found tag\",\n+                     istr::to_estr(ty_to_str(fcx.ccx.tcx, expected))]);\n           }\n         }\n         write::ty_fixup(fcx, pat.id, path_tpot);\n@@ -1412,11 +1413,10 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n         alt structure_of(fcx, pat.span, expected) {\n           ty::ty_rec(fields) { ex_fields = fields; }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                                        #fmt[\"mismatched types: expected %s, \\\n-                                         found record\",\n-                                             ty_to_str(fcx.ccx.tcx,\n-                                                       expected)]);\n+            fcx.ccx.tcx.sess.span_fatal(\n+                pat.span,\n+                #fmt[\"mismatched types: expected %s, found record\",\n+                     istr::to_estr(ty_to_str(fcx.ccx.tcx, expected))]);\n           }\n         }\n         let f_count = vec::len(fields);\n@@ -1450,11 +1450,10 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n         alt structure_of(fcx, pat.span, expected) {\n           ty::ty_tup(elts) { ex_elts = elts; }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                                        #fmt[\"mismatched types: expected %s, \\\n-                                         found tuple\",\n-                                             ty_to_str(fcx.ccx.tcx,\n-                                                       expected)]);\n+            fcx.ccx.tcx.sess.span_fatal(\n+                pat.span,\n+                #fmt[\"mismatched types: expected %s, found tuple\",\n+                     istr::to_estr(ty_to_str(fcx.ccx.tcx, expected))]);\n           }\n         }\n         let e_count = vec::len(elts);\n@@ -1477,10 +1476,11 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n             write::ty_only_fixup(fcx, pat.id, expected);\n           }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                                        \"mismatched types: expected \" +\n-                                            ty_to_str(fcx.ccx.tcx, expected) +\n-                                            \" found box\");\n+            fcx.ccx.tcx.sess.span_fatal(\n+                pat.span,\n+                \"mismatched types: expected \" +\n+                istr::to_estr(ty_to_str(fcx.ccx.tcx, expected)) +\n+                \" found box\");\n           }\n         }\n       }\n@@ -1578,11 +1578,12 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                 arg_tys\n               }\n               _ {\n-                fcx.ccx.tcx.sess.span_fatal(f.span,\n-                                            \"mismatched types: \\\n-                                           expected function or native \\\n-                                           function but found \"\n-                                                + ty_to_str(fcx.ccx.tcx, fty))\n+                fcx.ccx.tcx.sess.span_fatal(\n+                    f.span,\n+                    \"mismatched types: \\\n+                     expected function or native \\\n+                     function but found \"\n+                    + istr::to_estr(ty_to_str(fcx.ccx.tcx, fty)))\n               }\n             };\n \n@@ -1790,7 +1791,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             let t_str = ty_to_str(fcx.ccx.tcx, resolved_t);\n             let errmsg =\n                 \"binary operation \" + binopstr +\n-                    \" cannot be applied to type `\" + t_str + \"`\";\n+                    \" cannot be applied to type `\" +\n+                istr::to_estr(t_str) + \"`\";\n             fcx.ccx.tcx.sess.span_err(span, errmsg);\n         }\n     }\n@@ -1848,20 +1850,22 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n               }\n               ty::ty_ptr(inner) { oper_t = inner.ty; }\n               _ {\n-                tcx.sess.span_fatal(expr.span,\n-                                    \"dereferencing non-\" +\n-                                        \"dereferenceable type: \" +\n-                                        ty_to_str(tcx, oper_t));\n+                tcx.sess.span_fatal(\n+                    expr.span,\n+                    \"dereferencing non-\" +\n+                    \"dereferenceable type: \" +\n+                    istr::to_estr(ty_to_str(tcx, oper_t)));\n               }\n             }\n           }\n           ast::not. {\n             if !type_is_integral(fcx, oper.span, oper_t) &&\n                    structure_of(fcx, oper.span, oper_t) != ty::ty_bool {\n-                tcx.sess.span_err(expr.span,\n-                                  #fmt[\"mismatched types: expected bool \\\n-                                        or integer but found %s\",\n-                                       ty_to_str(tcx, oper_t)]);\n+                tcx.sess.span_err(\n+                    expr.span,\n+                    #fmt[\"mismatched types: expected bool \\\n+                          or integer but found %s\",\n+                         istr::to_estr(ty_to_str(tcx, oper_t))]);\n             }\n           }\n           ast::neg. {\n@@ -1871,7 +1875,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                 tcx.sess.span_err(expr.span,\n                                   \"applying unary minus to \\\n                    non-numeric type \"\n-                                      + ty_to_str(tcx, oper_t));\n+                                  + istr::to_estr(ty_to_str(tcx, oper_t)));\n             }\n           }\n         }\n@@ -2004,7 +2008,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             tcx.sess.span_fatal(\n                 expr.span,\n                 \"mismatched types: expected vector or string but \"\n-                + \"found \" + ty_to_str(tcx, ety));\n+                + \"found \" + istr::to_estr(ty_to_str(tcx, ety)));\n           }\n         }\n         bot |= check_for_or_for_each(fcx, decl, elt_ty, body, id);\n@@ -2199,8 +2203,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                  type_is_scalar(fcx, expr.span, t_1)) {\n             tcx.sess.span_err(expr.span,\n                               \"non-scalar cast: \" +\n-                                  ty_to_str(tcx, expr_ty(tcx, e)) + \" as \" +\n-                                  ty_to_str(tcx, t_1));\n+                              istr::to_estr(ty_to_str(tcx, expr_ty(tcx, e)))\n+                              + \" as \" +\n+                              istr::to_estr(ty_to_str(tcx, t_1)));\n         }\n         write::ty_only_fixup(fcx, id, t_1);\n       }\n@@ -2297,7 +2302,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             let t_err = resolve_type_vars_if_possible(fcx, base_t);\n             let msg =\n                 #fmt[\"attempted field access on type %s\",\n-                     ty_to_str(tcx, t_err)];\n+                     istr::to_estr(ty_to_str(tcx, t_err))];\n             tcx.sess.span_fatal(expr.span, msg);\n           }\n         }\n@@ -2312,7 +2317,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             tcx.sess.span_err(idx.span,\n                               \"mismatched types: expected \\\n                                integer but found \"\n-                                  + ty_to_str(tcx, idx_t));\n+                              + istr::to_estr(ty_to_str(tcx, idx_t)));\n         }\n         alt structure_of(fcx, expr.span, base_t) {\n           ty::ty_vec(mt) { write::ty_only_fixup(fcx, id, mt.ty); }\n@@ -2327,7 +2332,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n           _ {\n             tcx.sess.span_fatal(expr.span,\n                                 \"vector-indexing bad type: \" +\n-                                    ty_to_str(tcx, base_t));\n+                                istr::to_estr(ty_to_str(tcx, base_t)));\n           }\n         }\n       }\n@@ -2692,14 +2697,14 @@ fn check_main_fn_ty(tcx: &ty::ctxt, main_id: &ast::node_id) {\n             let span = ast_map::node_span(tcx.items.get(main_id));\n             tcx.sess.span_err(span,\n                               \"wrong type in main function: found \" +\n-                                  ty_to_str(tcx, main_t));\n+                              istr::to_estr(ty_to_str(tcx, main_t)));\n         }\n       }\n       _ {\n         let span = ast_map::node_span(tcx.items.get(main_id));\n         tcx.sess.span_bug(span,\n                           \"main has a non-function type: found\" +\n-                              ty_to_str(tcx, main_t));\n+                          istr::to_estr(ty_to_str(tcx, main_t)));\n       }\n     }\n }"}, {"sha": "18a1ff84c2287cc0fb6d5ba8fc47b31202d868aa", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=d2ae28fc99328ab1b7176560ed643a84a8883403", "patch": "@@ -145,12 +145,12 @@ fn lit_eq(l: &@ast::lit, m: &@ast::lit) -> bool {\n \n tag call_kind { kind_call; kind_spawn; kind_bind; kind_for_each; }\n \n-fn call_kind_str(c: call_kind) -> str {\n+fn call_kind_str(c: call_kind) -> istr {\n     alt c {\n-      kind_call. { \"Call\" }\n-      kind_spawn. { \"Spawn\" }\n-      kind_bind. { \"Bind\" }\n-      kind_for_each. { \"For-Each\" }\n+      kind_call. { ~\"Call\" }\n+      kind_spawn. { ~\"Spawn\" }\n+      kind_bind. { ~\"Bind\" }\n+      kind_for_each. { ~\"For-Each\" }\n     }\n }\n \n@@ -160,17 +160,17 @@ fn is_main_name(path: &[ast::ident]) -> bool {\n \n // FIXME mode this to std::float when editing the stdlib no longer\n // requires a snapshot\n-fn float_to_str(num: float, digits: uint) -> str {\n-    let accum = if num < 0.0 { num = -num; \"-\" } else { \"\" };\n+fn float_to_str(num: float, digits: uint) -> istr {\n+    let accum = if num < 0.0 { num = -num; ~\"-\" } else { ~\"\" };\n     let trunc = num as uint;\n     let frac = num - (trunc as float);\n-    accum += istr::to_estr(uint::str(trunc));\n+    accum += uint::str(trunc);\n     if frac == 0.0 || digits == 0u { ret accum; }\n-    accum += \".\";\n+    accum += ~\".\";\n     while digits > 0u && frac > 0.0 {\n         frac *= 10.0;\n         let digit = frac as uint;\n-        accum += istr::to_estr(uint::str(digit));\n+        accum += uint::str(digit);\n         frac -= digit as float;\n         digits -= 1u;\n     }"}, {"sha": "3a672f453b327da3bf2d58ca0b6a21013ccfe43b", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 73, "deletions": 66, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ae28fc99328ab1b7176560ed643a84a8883403/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=d2ae28fc99328ab1b7176560ed643a84a8883403", "patch": "@@ -22,117 +22,122 @@ import syntax::ast;\n import middle::ast_map;\n import metadata::csearch;\n \n-fn mode_str(m: &ty::mode) -> str {\n+fn mode_str(m: &ty::mode) -> istr {\n     alt m {\n-      mo_val. { \"\" }\n-      mo_alias(false) { \"&\" }\n-      mo_alias(true) { \"&mutable \" }\n-      mo_move. { \"-\" }\n+      mo_val. { ~\"\" }\n+      mo_alias(false) { ~\"&\" }\n+      mo_alias(true) { ~\"&mutable \" }\n+      mo_move. { ~\"-\" }\n     }\n }\n \n-fn mode_str_1(m: &ty::mode) -> str {\n-    alt m { mo_val. { \"val\" } _ { mode_str(m) } }\n+fn mode_str_1(m: &ty::mode) -> istr {\n+    alt m { mo_val. { ~\"val\" } _ { mode_str(m) } }\n }\n \n-fn fn_ident_to_string(id: ast::node_id, i: &ast::fn_ident) -> str {\n+fn fn_ident_to_string(id: ast::node_id, i: &ast::fn_ident) -> istr {\n     ret alt i {\n-      none. { istr::to_estr(~\"anon\" + int::str(id)) }\n-      some(s) { istr::to_estr(s) }\n+      none. { ~\"anon\" + int::str(id) }\n+      some(s) { s }\n     };\n }\n \n-fn get_id_ident(cx: &ctxt, id: ast::def_id) -> str {\n+fn get_id_ident(cx: &ctxt, id: ast::def_id) -> istr {\n     if id.crate != ast::local_crate {\n-        str::connect(istr::to_estrs(cx.ext_map.get(id)), \"::\")\n+        istr::connect(cx.ext_map.get(id), ~\"::\")\n     } else {\n         alt cx.items.find(id.node) {\n-          some(ast_map::node_item(it)) { istr::to_estr(it.ident) }\n+          some(ast_map::node_item(it)) { it.ident }\n           _ { fail \"get_id_ident: can't find item in ast_map\" }\n         }\n     }\n }\n \n-fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n+fn ty_to_str(cx: &ctxt, typ: &t) -> istr {\n     fn fn_input_to_str(cx: &ctxt, input: &{mode: middle::ty::mode, ty: t}) ->\n-       str {\n+       istr {\n         let s = mode_str(input.mode);\n         ret s + ty_to_str(cx, input.ty);\n     }\n     fn fn_to_str(cx: &ctxt, proto: ast::proto, ident: option::t<ast::ident>,\n                  inputs: &[arg], output: t, cf: ast::controlflow,\n-                 constrs: &[@constr]) -> str {\n-        let s = proto_to_str(proto);\n+                 constrs: &[@constr]) -> istr {\n+        let s = istr::from_estr(proto_to_str(proto));\n         alt ident {\n           some(i) {\n-            s += \" \";\n-            s += istr::to_estr(i);\n+            s += ~\" \";\n+            s += i;\n           }\n           _ { }\n         }\n-        s += \"(\";\n+        s += ~\"(\";\n         let strs = [];\n         for a: arg in inputs { strs += [fn_input_to_str(cx, a)]; }\n-        s += str::connect(strs, \", \");\n-        s += \")\";\n+        s += istr::connect(strs, ~\", \");\n+        s += ~\")\";\n         if struct(cx, output) != ty_nil {\n             alt cf {\n-              ast::noreturn. { s += \" -> !\"; }\n-              ast::return. { s += \" -> \" + ty_to_str(cx, output); }\n+              ast::noreturn. { s += ~\" -> !\"; }\n+              ast::return. { s += ~\" -> \" + ty_to_str(cx, output); }\n             }\n         }\n         s += constrs_str(constrs);\n         ret s;\n     }\n-    fn method_to_str(cx: &ctxt, m: &method) -> str {\n+    fn method_to_str(cx: &ctxt, m: &method) -> istr {\n         ret fn_to_str(cx, m.proto, some::<ast::ident>(m.ident), m.inputs,\n-                      m.output, m.cf, m.constrs) + \";\";\n+                      m.output, m.cf, m.constrs) + ~\";\";\n     }\n-    fn field_to_str(cx: &ctxt, f: &field) -> str {\n-        ret istr::to_estr(f.ident) + \": \" + mt_to_str(cx, f.mt);\n+    fn field_to_str(cx: &ctxt, f: &field) -> istr {\n+        ret f.ident + ~\": \" + mt_to_str(cx, f.mt);\n     }\n-    fn mt_to_str(cx: &ctxt, m: &mt) -> str {\n+    fn mt_to_str(cx: &ctxt, m: &mt) -> istr {\n         let mstr;\n         alt m.mut {\n-          ast::mut. { mstr = \"mutable \"; }\n-          ast::imm. { mstr = \"\"; }\n-          ast::maybe_mut. { mstr = \"mutable? \"; }\n+          ast::mut. { mstr = ~\"mutable \"; }\n+          ast::imm. { mstr = ~\"\"; }\n+          ast::maybe_mut. { mstr = ~\"mutable? \"; }\n         }\n         ret mstr + ty_to_str(cx, m.ty);\n     }\n-    alt cname(cx, typ) { some(cs) { ret cs; } _ { } }\n+    alt cname(cx, typ) {\n+      some(cs) {\n+        ret istr::from_estr(cs);\n+      }\n+      _ { }\n+    }\n     ret alt struct(cx, typ) {\n-          ty_native(_) { \"native\" }\n-          ty_nil. { \"()\" }\n-          ty_bot. { \"_|_\" }\n-          ty_bool. { \"bool\" }\n-          ty_int. { \"int\" }\n-          ty_float. { \"float\" }\n-          ty_uint. { \"uint\" }\n-          ty_machine(tm) { ty_mach_to_str(tm) }\n-          ty_char. { \"char\" }\n-          ty_str. { \"str\" }\n-          ty_istr. { \"istr\" }\n-          ty_box(tm) { \"@\" + mt_to_str(cx, tm) }\n-          ty_uniq(t) { \"~\" + ty_to_str(cx, t) }\n-          ty_vec(tm) { \"[\" + mt_to_str(cx, tm) + \"]\" }\n-          ty_type. { \"type\" }\n+          ty_native(_) { ~\"native\" }\n+          ty_nil. { ~\"()\" }\n+          ty_bot. { ~\"_|_\" }\n+          ty_bool. { ~\"bool\" }\n+          ty_int. { ~\"int\" }\n+          ty_float. { ~\"float\" }\n+          ty_uint. { ~\"uint\" }\n+          ty_machine(tm) { istr::from_estr(ty_mach_to_str(tm)) }\n+          ty_char. { ~\"char\" }\n+          ty_str. { ~\"str\" }\n+          ty_istr. { ~\"istr\" }\n+          ty_box(tm) { ~\"@\" + mt_to_str(cx, tm) }\n+          ty_uniq(t) { ~\"~\" + ty_to_str(cx, t) }\n+          ty_vec(tm) { ~\"[\" + mt_to_str(cx, tm) + ~\"]\" }\n+          ty_type. { ~\"type\" }\n           ty_rec(elems) {\n-            let strs: [str] = [];\n+            let strs: [istr] = [];\n             for fld: field in elems { strs += [field_to_str(cx, fld)]; }\n-            \"{\" + str::connect(strs, \",\") + \"}\"\n+            ~\"{\" + istr::connect(strs, ~\",\") + ~\"}\"\n           }\n           ty_tup(elems) {\n             let strs = [];\n             for elem in elems { strs += [ty_to_str(cx, elem)]; }\n-            \"(\" + str::connect(strs, \",\") + \")\"\n+            ~\"(\" + istr::connect(strs, ~\",\") + ~\")\"\n           }\n           ty_tag(id, tps) {\n             let s = get_id_ident(cx, id);\n             if vec::len::<t>(tps) > 0u {\n-                let strs: [str] = [];\n+                let strs: [istr] = [];\n                 for typ: t in tps { strs += [ty_to_str(cx, typ)]; }\n-                s += \"[\" + str::connect(strs, \",\") + \"]\";\n+                s += ~\"[\" + istr::connect(strs, ~\",\") + ~\"]\";\n             }\n             s\n           }\n@@ -146,14 +151,14 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n           ty_obj(meths) {\n             let strs = [];\n             for m: method in meths { strs += [method_to_str(cx, m)]; }\n-            \"obj {\\n\\t\" + str::connect(strs, \"\\n\\t\") + \"\\n}\"\n+            ~\"obj {\\n\\t\" + istr::connect(strs, ~\"\\n\\t\") + ~\"\\n}\"\n           }\n           ty_res(id, _, _) { get_id_ident(cx, id) }\n-          ty_var(v) { istr::to_estr(~\"<T\" + int::str(v) + ~\">\") }\n+          ty_var(v) { ~\"<T\" + int::str(v) + ~\">\" }\n           ty_param(id, _) {\n-            \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)])\n+            ~\"'\" + istr::unsafe_from_bytes([('a' as u8) + (id as u8)])\n           }\n-          _ { istr::to_estr(ty_to_short_str(cx, typ)) }\n+          _ { ty_to_short_str(cx, typ) }\n         }\n }\n \n@@ -163,25 +168,27 @@ fn ty_to_short_str(cx: &ctxt, typ: t) -> istr {\n     ret s;\n }\n \n-fn constr_to_str(c: &@constr) -> str {\n-    ret path_to_str(c.node.path) +\n-            pprust::constr_args_to_str(pprust::uint_to_str, c.node.args);\n+fn constr_to_str(c: &@constr) -> istr {\n+    ret istr::from_estr(path_to_str(c.node.path)) +\n+        istr::from_estr(\n+            pprust::constr_args_to_str(pprust::uint_to_str, c.node.args));\n }\n \n-fn constrs_str(constrs: &[@constr]) -> str {\n-    let s = \"\";\n+fn constrs_str(constrs: &[@constr]) -> istr {\n+    let s = ~\"\";\n     let colon = true;\n     for c: @constr in constrs {\n-        if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n+        if colon { s += ~\" : \"; colon = false; } else { s += ~\", \"; }\n         s += constr_to_str(c);\n     }\n     ret s;\n }\n \n fn ty_constr_to_str<Q>(c: &@ast::spanned<ast::constr_general_<ast::path, Q>>)\n-   -> str {\n-    ret path_to_str(c.node.path) +\n-            constr_args_to_str::<ast::path>(path_to_str, c.node.args);\n+   -> istr {\n+    ret istr::from_estr(path_to_str(c.node.path)) +\n+        istr::from_estr(\n+            constr_args_to_str::<ast::path>(path_to_str, c.node.args));\n }\n \n // Local Variables:"}]}