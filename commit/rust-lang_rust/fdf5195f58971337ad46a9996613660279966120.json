{"sha": "fdf5195f58971337ad46a9996613660279966120", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZjUxOTVmNTg5NzEzMzdhZDQ2YTk5OTY2MTM2NjAyNzk5NjYxMjA=", "commit": {"author": {"name": "klutzy", "email": "klutzytheklutzy@gmail.com", "date": "2014-11-05T18:53:27Z"}, "committer": {"name": "klutzy", "email": "klutzytheklutzy@gmail.com", "date": "2014-11-06T13:01:31Z"}, "message": "std::rand::OsRng: Use `getrandom` syscall on Linux\n\n`getrandom(2)` system call [1] has been added on Linux 3.17.\nThis patch makes `OsRng` use `getrandom` if available, and use\ntraditional `/dev/urandom` fallback if not.\n\n[1]:\nhttps://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c6e9d6f38894798696f23c8084ca7edbf16ee895", "tree": {"sha": "7d4f7e6dffb59f7c8b9a2243b55bebfb258189c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d4f7e6dffb59f7c8b9a2243b55bebfb258189c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdf5195f58971337ad46a9996613660279966120", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdf5195f58971337ad46a9996613660279966120", "html_url": "https://github.com/rust-lang/rust/commit/fdf5195f58971337ad46a9996613660279966120", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdf5195f58971337ad46a9996613660279966120/comments", "author": {"login": "klutzy", "id": 1589355, "node_id": "MDQ6VXNlcjE1ODkzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1589355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klutzy", "html_url": "https://github.com/klutzy", "followers_url": "https://api.github.com/users/klutzy/followers", "following_url": "https://api.github.com/users/klutzy/following{/other_user}", "gists_url": "https://api.github.com/users/klutzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klutzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klutzy/subscriptions", "organizations_url": "https://api.github.com/users/klutzy/orgs", "repos_url": "https://api.github.com/users/klutzy/repos", "events_url": "https://api.github.com/users/klutzy/events{/privacy}", "received_events_url": "https://api.github.com/users/klutzy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "klutzy", "id": 1589355, "node_id": "MDQ6VXNlcjE1ODkzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1589355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klutzy", "html_url": "https://github.com/klutzy", "followers_url": "https://api.github.com/users/klutzy/followers", "following_url": "https://api.github.com/users/klutzy/following{/other_user}", "gists_url": "https://api.github.com/users/klutzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klutzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klutzy/subscriptions", "organizations_url": "https://api.github.com/users/klutzy/orgs", "repos_url": "https://api.github.com/users/klutzy/repos", "events_url": "https://api.github.com/users/klutzy/events{/privacy}", "received_events_url": "https://api.github.com/users/klutzy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14cd5c590e2157f153ed38625011e7fc3c83659c", "url": "https://api.github.com/repos/rust-lang/rust/commits/14cd5c590e2157f153ed38625011e7fc3c83659c", "html_url": "https://github.com/rust-lang/rust/commit/14cd5c590e2157f153ed38625011e7fc3c83659c"}], "stats": {"total": 132, "additions": 120, "deletions": 12}, "files": [{"sha": "5ef2c2fe23d35a65880933410c78f44c41cacfa0", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdf5195f58971337ad46a9996613660279966120/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf5195f58971337ad46a9996613660279966120/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=fdf5195f58971337ad46a9996613660279966120", "patch": "@@ -45,8 +45,12 @@\n //!     so the \"quality\" of `/dev/random` is not better than `/dev/urandom` in most cases.\n //!     However, this means that `/dev/urandom` can yield somewhat predictable randomness\n //!     if the entropy pool is very small, such as immediately after first booting.\n-//!     If an application likely to be run soon after first booting, or on a system with very\n-//!     few entropy sources, one should consider using `/dev/random` via `ReaderRng`.\n+//!     Linux 3,17 added `getrandom(2)` system call which solves the issue: it blocks if entropy\n+//!     pool is not initialized yet, but it does not block once initialized.\n+//!     `OsRng` tries to use `getrandom(2)` if available, and use `/dev/urandom` fallback if not.\n+//!     If an application does not have `getrandom` and likely to be run soon after first booting,\n+//!     or on a system with very few entropy sources, one should consider using `/dev/random` via\n+//!     `ReaderRng`.\n //! -   On some systems (e.g. FreeBSD, OpenBSD and Mac OS X) there is no difference\n //!     between the two sources. (Also note that, on some systems e.g. FreeBSD, both `/dev/random`\n //!     and `/dev/urandom` may block once if the CSPRNG has not seeded yet.)"}, {"sha": "89e13f7650a3297c36511bdf265c0d55eb5e117b", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 114, "deletions": 10, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/fdf5195f58971337ad46a9996613660279966120/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf5195f58971337ad46a9996613660279966120/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=fdf5195f58971337ad46a9996613660279966120", "patch": "@@ -15,45 +15,149 @@ pub use self::imp::OsRng;\n \n #[cfg(all(unix, not(target_os = \"ios\")))]\n mod imp {\n+    extern crate libc;\n+\n     use io::{IoResult, File};\n     use path::Path;\n     use rand::Rng;\n     use rand::reader::ReaderRng;\n     use result::{Ok, Err};\n+    use slice::{ImmutableSlice, MutableSlice};\n+    use mem;\n+    use os::errno;\n+\n+    #[cfg(all(target_os = \"linux\",\n+              any(target_arch = \"x86_64\", target_arch = \"x86\", target_arch = \"arm\")))]\n+    fn getrandom(buf: &mut [u8]) -> libc::c_long {\n+        extern \"C\" {\n+            fn syscall(number: libc::c_long, ...) -> libc::c_long;\n+        }\n+\n+        #[cfg(target_arch = \"x86_64\")]\n+        const NR_GETRANDOM: libc::c_long = 318;\n+        #[cfg(target_arch = \"x86\")]\n+        const NR_GETRANDOM: libc::c_long = 355;\n+        #[cfg(target_arch = \"arm\")]\n+        const NR_GETRANDOM: libc::c_long = 384;\n+\n+        unsafe {\n+            syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), 0u)\n+        }\n+    }\n+\n+    #[cfg(not(all(target_os = \"linux\",\n+                  any(target_arch = \"x86_64\", target_arch = \"x86\", target_arch = \"arm\"))))]\n+    fn getrandom(_buf: &mut [u8]) -> libc::c_long { -1 }\n+\n+    fn getrandom_fill_bytes(v: &mut [u8]) {\n+        let mut read = 0;\n+        let len = v.len();\n+        while read < len {\n+            let result = getrandom(v[mut read..]);\n+            if result == -1 {\n+                let err = errno() as libc::c_int;\n+                if err == libc::EINTR {\n+                    continue;\n+                } else {\n+                    panic!(\"unexpected getrandom error: {}\", err);\n+                }\n+            } else {\n+                read += result as uint;\n+            }\n+        }\n+    }\n+\n+    fn getrandom_next_u32() -> u32 {\n+        let mut buf: [u8, ..4] = [0u8, ..4];\n+        getrandom_fill_bytes(&mut buf);\n+        unsafe { mem::transmute::<[u8, ..4], u32>(buf) }\n+    }\n+\n+    fn getrandom_next_u64() -> u64 {\n+        let mut buf: [u8, ..8] = [0u8, ..8];\n+        getrandom_fill_bytes(&mut buf);\n+        unsafe { mem::transmute::<[u8, ..8], u64>(buf) }\n+    }\n+\n+    #[cfg(all(target_os = \"linux\",\n+              any(target_arch = \"x86_64\", target_arch = \"x86\", target_arch = \"arm\")))]\n+    fn is_getrandom_available() -> bool {\n+        use sync::atomic::{AtomicBool, INIT_ATOMIC_BOOL, Relaxed};\n+\n+        static GETRANDOM_CHECKED: AtomicBool = INIT_ATOMIC_BOOL;\n+        static GETRANDOM_AVAILABLE: AtomicBool = INIT_ATOMIC_BOOL;\n+\n+        if !GETRANDOM_CHECKED.load(Relaxed) {\n+            let mut buf: [u8, ..0] = [];\n+            let result = getrandom(&mut buf);\n+            let available = if result == -1 {\n+                let err = errno() as libc::c_int;\n+                err != libc::ENOSYS\n+            } else {\n+                true\n+            };\n+            GETRANDOM_AVAILABLE.store(available, Relaxed);\n+            GETRANDOM_CHECKED.store(true, Relaxed);\n+            available\n+        } else {\n+            GETRANDOM_AVAILABLE.load(Relaxed)\n+        }\n+    }\n+\n+    #[cfg(not(all(target_os = \"linux\",\n+                  any(target_arch = \"x86_64\", target_arch = \"x86\", target_arch = \"arm\"))))]\n+    fn is_getrandom_available() -> bool { false }\n \n     /// A random number generator that retrieves randomness straight from\n     /// the operating system. Platform sources:\n     ///\n     /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n-    ///   `/dev/urandom`.\n+    ///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n     /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n     ///   service provider with the `PROV_RSA_FULL` type.\n     /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed\n     /// This does not block.\n-    #[cfg(unix)]\n     pub struct OsRng {\n-        inner: ReaderRng<File>\n+        inner: OsRngInner,\n+    }\n+\n+    enum OsRngInner {\n+        OsGetrandomRng,\n+        OsReaderRng(ReaderRng<File>),\n     }\n \n     impl OsRng {\n         /// Create a new `OsRng`.\n         pub fn new() -> IoResult<OsRng> {\n+            if is_getrandom_available() {\n+                return Ok(OsRng { inner: OsGetrandomRng });\n+            }\n+\n             let reader = try!(File::open(&Path::new(\"/dev/urandom\")));\n             let reader_rng = ReaderRng::new(reader);\n \n-            Ok(OsRng { inner: reader_rng })\n+            Ok(OsRng { inner: OsReaderRng(reader_rng) })\n         }\n     }\n \n     impl Rng for OsRng {\n         fn next_u32(&mut self) -> u32 {\n-            self.inner.next_u32()\n+            match self.inner {\n+                OsGetrandomRng => getrandom_next_u32(),\n+                OsReaderRng(ref mut rng) => rng.next_u32(),\n+            }\n         }\n         fn next_u64(&mut self) -> u64 {\n-            self.inner.next_u64()\n+            match self.inner {\n+                OsGetrandomRng => getrandom_next_u64(),\n+                OsReaderRng(ref mut rng) => rng.next_u64(),\n+            }\n         }\n         fn fill_bytes(&mut self, v: &mut [u8]) {\n-            self.inner.fill_bytes(v)\n+            match self.inner {\n+                OsGetrandomRng => getrandom_fill_bytes(v),\n+                OsReaderRng(ref mut rng) => rng.fill_bytes(v)\n+            }\n         }\n     }\n }\n@@ -75,7 +179,7 @@ mod imp {\n     /// the operating system. Platform sources:\n     ///\n     /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n-    ///   `/dev/urandom`.\n+    ///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n     /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n     ///   service provider with the `PROV_RSA_FULL` type.\n     /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed\n@@ -145,10 +249,10 @@ mod imp {\n     /// the operating system. Platform sources:\n     ///\n     /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n-    ///   `/dev/urandom`.\n+    ///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n     /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n     ///   service provider with the `PROV_RSA_FULL` type.\n-    ///\n+    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed\n     /// This does not block.\n     pub struct OsRng {\n         hcryptprov: HCRYPTPROV"}]}