{"sha": "6269137760988863cb7438c2bb4e5cf69a263e9d", "node_id": "C_kwDOAAsO6NoAKDYyNjkxMzc3NjA5ODg4NjNjYjc0MzhjMmJiNGU1Y2Y2OWEyNjNlOWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-17T13:10:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-17T13:10:05Z"}, "message": "Auto merge of #12560 - Veykril:completion, r=Veykril\n\ninternal: More completions refactoring\n\nThis gets rid of the remaining `ImmediateLocation` bits", "tree": {"sha": "6e09db24861af24816680831bc71d3587ea687fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e09db24861af24816680831bc71d3587ea687fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6269137760988863cb7438c2bb4e5cf69a263e9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6269137760988863cb7438c2bb4e5cf69a263e9d", "html_url": "https://github.com/rust-lang/rust/commit/6269137760988863cb7438c2bb4e5cf69a263e9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6269137760988863cb7438c2bb4e5cf69a263e9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7322a982f99e41cc2a025d1ae3b11a5acd4a771e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7322a982f99e41cc2a025d1ae3b11a5acd4a771e", "html_url": "https://github.com/rust-lang/rust/commit/7322a982f99e41cc2a025d1ae3b11a5acd4a771e"}, {"sha": "f201a40492fb245d95e4bcbc543f36d7b43645b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f201a40492fb245d95e4bcbc543f36d7b43645b3", "html_url": "https://github.com/rust-lang/rust/commit/f201a40492fb245d95e4bcbc543f36d7b43645b3"}], "stats": {"total": 675, "additions": 332, "deletions": 343}, "files": [{"sha": "ade57bed958ec06745eb01bd3130fcd1242d00d3", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=6269137760988863cb7438c2bb4e5cf69a263e9d", "patch": "@@ -4,7 +4,8 @@ use ide_db::FxHashSet;\n \n use crate::{\n     context::{\n-        CompletionContext, DotAccess, DotAccessKind, NameRefContext, PathCompletionCtx, PathKind,\n+        CompletionContext, DotAccess, DotAccessKind, NameRefContext, NameRefKind,\n+        PathCompletionCtx, PathKind,\n     },\n     CompletionItem, CompletionItemKind, Completions,\n };\n@@ -13,7 +14,8 @@ use crate::{\n pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n     let (dot_access, receiver_ty) = match ctx.nameref_ctx() {\n         Some(NameRefContext {\n-            dot_access: Some(access @ DotAccess { receiver_ty: Some(receiver_ty), .. }),\n+            kind:\n+                Some(NameRefKind::DotAccess(access @ DotAccess { receiver_ty: Some(receiver_ty), .. })),\n             ..\n         }) => (access, &receiver_ty.original),\n         _ => return complete_undotted_self(acc, ctx),"}, {"sha": "3d92a0cceffe4afd2aa7080f9f6287ddd530a7f7", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=6269137760988863cb7438c2bb4e5cf69a263e9d", "patch": "@@ -5,7 +5,7 @@ use ide_db::FxHashSet;\n use syntax::T;\n \n use crate::{\n-    context::{NameRefContext, PathCompletionCtx, PathKind, PathQualifierCtx},\n+    context::{NameRefContext, NameRefKind, PathCompletionCtx, PathKind, PathQualifierCtx},\n     CompletionContext, Completions,\n };\n \n@@ -21,24 +21,29 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n         after_if_expr,\n         wants_mut_token,\n     ) = match ctx.nameref_ctx() {\n-        Some(NameRefContext {\n-            path_ctx:\n-                Some(PathCompletionCtx {\n+        Some(&NameRefContext {\n+            kind:\n+                Some(NameRefKind::Path(PathCompletionCtx {\n                     kind:\n-                        PathKind::Expr { in_block_expr, in_loop_body, after_if_expr, ref_expr_parent },\n+                        PathKind::Expr {\n+                            in_block_expr,\n+                            in_loop_body,\n+                            after_if_expr,\n+                            ref ref_expr_parent,\n+                            ref is_func_update,\n+                        },\n                     is_absolute_path,\n-                    qualifier,\n+                    ref qualifier,\n                     ..\n-                }),\n-            record_expr,\n+                })),\n             ..\n         }) if ctx.qualifier_ctx.none() => (\n-            *is_absolute_path,\n+            is_absolute_path,\n             qualifier,\n-            *in_block_expr,\n-            *in_loop_body,\n-            record_expr.as_ref().map_or(false, |&(_, it)| it),\n-            *after_if_expr,\n+            in_block_expr,\n+            in_loop_body,\n+            is_func_update.is_some(),\n+            after_if_expr,\n             ref_expr_parent.as_ref().map(|it| it.mut_token().is_none()).unwrap_or(false),\n         ),\n         _ => return,"}, {"sha": "c540b87a46fda9b0a208025a8e600d7e9394a9dc", "filename": "crates/ide-completion/src/completions/field.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs?ref=6269137760988863cb7438c2bb4e5cf69a263e9d", "patch": "@@ -1,24 +1,27 @@\n //! Completion of field list position.\n \n use crate::{\n-    context::{IdentContext, NameContext, NameKind, NameRefContext, PathCompletionCtx, PathKind},\n+    context::{\n+        IdentContext, NameContext, NameKind, NameRefContext, NameRefKind, PathCompletionCtx,\n+        PathKind, TypeLocation,\n+    },\n     CompletionContext, Completions,\n };\n \n pub(crate) fn complete_field_list(acc: &mut Completions, ctx: &CompletionContext) {\n     match &ctx.ident_ctx {\n         IdentContext::Name(NameContext { kind: NameKind::RecordField, .. })\n         | IdentContext::NameRef(NameRefContext {\n-            path_ctx:\n-                Some(PathCompletionCtx {\n+            kind:\n+                Some(NameRefKind::Path(PathCompletionCtx {\n                     has_macro_bang: false,\n                     is_absolute_path: false,\n                     qualifier: None,\n                     parent: None,\n-                    kind: PathKind::Type { in_tuple_struct: true },\n+                    kind: PathKind::Type { location: TypeLocation::TupleField },\n                     has_type_args: false,\n                     ..\n-                }),\n+                })),\n             ..\n         }) => {\n             if ctx.qualifier_ctx.vis_node.is_none() {"}, {"sha": "6266bcef34e0bf6bff1957b68d33e0c8d0eb9ad0", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=6269137760988863cb7438c2bb4e5cf69a263e9d", "patch": "@@ -8,8 +8,10 @@ use itertools::Itertools;\n use syntax::{AstNode, SyntaxNode, T};\n \n use crate::{\n-    context::{CompletionContext, NameRefContext, PathCompletionCtx, PathKind, PatternContext},\n-    patterns::ImmediateLocation,\n+    context::{\n+        CompletionContext, NameRefContext, NameRefKind, PathCompletionCtx, PathKind,\n+        PatternContext, TypeLocation,\n+    },\n     render::{render_resolution_with_import, RenderContext},\n };\n \n@@ -111,19 +113,20 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n         return None;\n     }\n     let path_kind = match ctx.nameref_ctx() {\n-        Some(NameRefContext { path_ctx: Some(PathCompletionCtx { kind, .. }), .. })\n-            if matches!(\n-                kind,\n-                PathKind::Expr { .. }\n-                    | PathKind::Type { .. }\n-                    | PathKind::Attr { .. }\n-                    | PathKind::Derive\n-                    | PathKind::Pat\n-            ) =>\n-        {\n-            Some(kind)\n-        }\n-        Some(NameRefContext { dot_access: Some(_), .. }) => None,\n+        Some(NameRefContext {\n+            kind:\n+                Some(NameRefKind::Path(PathCompletionCtx {\n+                    kind:\n+                        kind @ (PathKind::Expr { .. }\n+                        | PathKind::Type { .. }\n+                        | PathKind::Attr { .. }\n+                        | PathKind::Derive\n+                        | PathKind::Pat),\n+                    ..\n+                })),\n+            ..\n+        }) => Some(kind),\n+        Some(NameRefContext { kind: Some(NameRefKind::DotAccess(_)), .. }) => None,\n         None if matches!(ctx.pattern_ctx, Some(PatternContext { record_pat: None, .. })) => {\n             Some(&PathKind::Pat)\n         }\n@@ -173,8 +176,8 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n             (PathKind::Pat, ItemInNs::Types(_)) => true,\n             (PathKind::Pat, ItemInNs::Values(def)) => matches!(def, hir::ModuleDef::Const(_)),\n \n-            (PathKind::Type { .. }, ItemInNs::Types(ty)) => {\n-                if matches!(ctx.completion_location, Some(ImmediateLocation::TypeBound)) {\n+            (PathKind::Type { location }, ItemInNs::Types(ty)) => {\n+                if matches!(location, TypeLocation::TypeBound) {\n                     matches!(ty, ModuleDef::Trait(_))\n                 } else {\n                     true"}, {"sha": "846d5f090287e38f5f0c5c3d5fdffd139a10ba97", "filename": "crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=6269137760988863cb7438c2bb4e5cf69a263e9d", "patch": "@@ -44,8 +44,8 @@ use text_edit::TextEdit;\n \n use crate::{\n     context::{\n-        IdentContext, ItemListKind, NameContext, NameKind, NameRefContext, PathCompletionCtx,\n-        PathKind,\n+        IdentContext, ItemListKind, NameContext, NameKind, NameRefContext, NameRefKind,\n+        PathCompletionCtx, PathKind,\n     },\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance, Completions,\n };\n@@ -106,14 +106,13 @@ fn completion_match(ctx: &CompletionContext) -> Option<(ImplCompletionKind, Text\n         }\n         IdentContext::NameRef(NameRefContext {\n             nameref,\n-            path_ctx:\n-                Some(\n+            kind:\n+                Some(NameRefKind::Path(\n                     path_ctx @ PathCompletionCtx {\n                         kind: PathKind::Item { kind: ItemListKind::TraitImpl },\n                         ..\n                     },\n-                ),\n-            ..\n+                )),\n         }) if path_ctx.is_trivial_path() => Some((\n             ImplCompletionKind::All,\n             match nameref {"}, {"sha": "2e266b7714c8d3d6f4889617531322ed671a5974", "filename": "crates/ide-completion/src/completions/keyword.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=6269137760988863cb7438c2bb4e5cf69a263e9d", "patch": "@@ -4,11 +4,14 @@\n \n use syntax::ast::Item;\n \n-use crate::{context::NameRefContext, CompletionContext, Completions};\n+use crate::{\n+    context::{NameRefContext, NameRefKind},\n+    CompletionContext, Completions,\n+};\n \n pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n     let item = match ctx.nameref_ctx() {\n-        Some(NameRefContext { keyword: Some(item), record_expr: None, .. }) => item,\n+        Some(NameRefContext { kind: Some(NameRefKind::Keyword(item)), .. }) => item,\n         _ => return,\n     };\n "}, {"sha": "888b8f34884f1d2fc91ea4cc4bc9584f6e6fdf0b", "filename": "crates/ide-completion/src/completions/postfix.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=6269137760988863cb7438c2bb4e5cf69a263e9d", "patch": "@@ -13,7 +13,7 @@ use text_edit::TextEdit;\n \n use crate::{\n     completions::postfix::format_like::add_format_like_completions,\n-    context::{CompletionContext, DotAccess, DotAccessKind, NameRefContext},\n+    context::{CompletionContext, DotAccess, DotAccessKind, NameRefContext, NameRefKind},\n     item::{Builder, CompletionRelevancePostfixMatch},\n     CompletionItem, CompletionItemKind, CompletionRelevance, Completions, SnippetScope,\n };\n@@ -25,7 +25,13 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n \n     let (dot_receiver, receiver_ty, receiver_is_ambiguous_float_literal) = match ctx.nameref_ctx() {\n         Some(NameRefContext {\n-            dot_access: Some(DotAccess { receiver_ty: Some(ty), receiver: Some(it), kind, .. }),\n+            kind:\n+                Some(NameRefKind::DotAccess(DotAccess {\n+                    receiver_ty: Some(ty),\n+                    receiver: Some(it),\n+                    kind,\n+                    ..\n+                })),\n             ..\n         }) => (\n             it,"}, {"sha": "d74ae260b5dfa771d0936aa07c5a269a01b086a4", "filename": "crates/ide-completion/src/completions/record.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=6269137760988863cb7438c2bb4e5cf69a263e9d", "patch": "@@ -3,7 +3,7 @@ use ide_db::SymbolKind;\n use syntax::{ast::Expr, T};\n \n use crate::{\n-    context::{NameRefContext, PatternContext},\n+    context::{NameRefContext, NameRefKind, PathCompletionCtx, PathKind, PatternContext},\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance,\n     CompletionRelevancePostfixMatch, Completions,\n };\n@@ -13,8 +13,18 @@ pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) ->\n         &ctx.pattern_ctx\n     {\n         ctx.sema.record_pattern_missing_fields(record_pat)\n-    } else if let Some(NameRefContext { record_expr: Some((record_expr, _)), .. }) =\n-        ctx.nameref_ctx()\n+    } else if let Some(NameRefContext {\n+        kind:\n+            Some(\n+                NameRefKind::RecordExpr(record_expr)\n+                | NameRefKind::Path(PathCompletionCtx {\n+                    kind: PathKind::Expr { is_func_update: Some(record_expr), .. },\n+                    qualifier: None,\n+                    ..\n+                }),\n+            ),\n+        ..\n+    }) = ctx.nameref_ctx()\n     {\n         let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_expr.clone()));\n \n@@ -39,7 +49,7 @@ pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) ->\n                     ty.original.impls_trait(ctx.db, default_trait, &[])\n                 });\n \n-            if impl_default_trait && !missing_fields.is_empty() && ctx.path_qual().is_none() {\n+            if impl_default_trait && !missing_fields.is_empty() {\n                 let completion_text = \"..Default::default()\";\n                 let mut item =\n                     CompletionItem::new(SymbolKind::Field, ctx.source_range(), completion_text);"}, {"sha": "9d3a1c24293d78c33a3dba563ea5a7b17d6b3d54", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=6269137760988863cb7438c2bb4e5cf69a263e9d", "patch": "@@ -5,22 +5,21 @@ use ide_db::FxHashSet;\n use syntax::{ast, AstNode};\n \n use crate::{\n-    context::{PathCompletionCtx, PathKind, PathQualifierCtx},\n-    patterns::{ImmediateLocation, TypeAnnotation},\n+    context::{PathCompletionCtx, PathKind, PathQualifierCtx, TypeAscriptionTarget, TypeLocation},\n     render::render_type_inference,\n     CompletionContext, Completions,\n };\n \n pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext) {\n     let _p = profile::span(\"complete_type_path\");\n \n-    let (&is_absolute_path, qualifier) = match ctx.path_context() {\n+    let (&is_absolute_path, location, qualifier) = match ctx.path_context() {\n         Some(PathCompletionCtx {\n-            kind: PathKind::Type { .. },\n+            kind: PathKind::Type { location },\n             is_absolute_path,\n             qualifier,\n             ..\n-        }) => (is_absolute_path, qualifier),\n+        }) => (is_absolute_path, location, qualifier),\n         _ => return,\n     };\n \n@@ -32,7 +31,7 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n             ScopeDef::ModuleDef(Function(_) | Variant(_) | Static(_)) | ScopeDef::Local(_) => false,\n             // unless its a constant in a generic arg list position\n             ScopeDef::ModuleDef(Const(_)) | ScopeDef::GenericParam(ConstParam(_)) => {\n-                ctx.expects_generic_arg()\n+                matches!(location, TypeLocation::GenericArgList(_))\n             }\n             ScopeDef::ImplSelfType(_) => {\n                 !ctx.previous_token_is(syntax::T![impl]) && !ctx.previous_token_is(syntax::T![for])\n@@ -47,14 +46,22 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n         }\n     };\n \n+    let add_assoc_item = |acc: &mut Completions, item| match item {\n+        hir::AssocItem::Const(ct) if matches!(location, TypeLocation::GenericArgList(_)) => {\n+            acc.add_const(ctx, ct)\n+        }\n+        hir::AssocItem::Function(_) | hir::AssocItem::Const(_) => (),\n+        hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n+    };\n+\n     match qualifier {\n         Some(PathQualifierCtx { is_infer_qualifier, resolution, .. }) => {\n             if *is_infer_qualifier {\n                 ctx.traits_in_scope()\n                     .0\n                     .into_iter()\n                     .flat_map(|it| hir::Trait::from(it).items(ctx.sema.db))\n-                    .for_each(|item| add_assoc_item(acc, ctx, item));\n+                    .for_each(|item| add_assoc_item(acc, item));\n                 return;\n             }\n             let resolution = match resolution {\n@@ -98,7 +105,7 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n                         Some(ctx.module),\n                         None,\n                         |item| {\n-                            add_assoc_item(acc, ctx, item);\n+                            add_assoc_item(acc, item);\n                             None::<()>\n                         },\n                     );\n@@ -114,7 +121,7 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n                 hir::PathResolution::Def(hir::ModuleDef::Trait(t)) => {\n                     // Handles `Trait::assoc` as well as `<Ty as Trait>::assoc`.\n                     for item in t.items(ctx.db) {\n-                        add_assoc_item(acc, ctx, item);\n+                        add_assoc_item(acc, item);\n                     }\n                 }\n                 hir::PathResolution::TypeParam(_) | hir::PathResolution::SelfType(_) => {\n@@ -135,7 +142,7 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n                             // We might iterate candidates of a trait multiple times here, so deduplicate\n                             // them.\n                             if seen.insert(item) {\n-                                add_assoc_item(acc, ctx, item);\n+                                add_assoc_item(acc, item);\n                             }\n                             None::<()>\n                         },\n@@ -147,7 +154,7 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n         None if is_absolute_path => acc.add_crate_roots(ctx),\n         None => {\n             acc.add_nameref_keywords_with_colon(ctx);\n-            if let Some(ImmediateLocation::TypeBound) = &ctx.completion_location {\n+            if let TypeLocation::TypeBound = location {\n                 ctx.process_all_names(&mut |name, res| {\n                     let add_resolution = match res {\n                         ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => mac.is_fn_like(ctx.db),\n@@ -162,7 +169,7 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n                 });\n                 return;\n             }\n-            if let Some(ImmediateLocation::GenericArgList(arg_list)) = &ctx.completion_location {\n+            if let TypeLocation::GenericArgList(Some(arg_list)) = location {\n                 if let Some(path_seg) = arg_list.syntax().parent().and_then(ast::PathSegment::cast)\n                 {\n                     if path_seg.syntax().ancestors().find_map(ast::TypeBound::cast).is_some() {\n@@ -189,25 +196,25 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n }\n \n pub(crate) fn complete_inferred_type(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    use TypeAnnotation::*;\n-    let pat = match &ctx.completion_location {\n-        Some(ImmediateLocation::TypeAnnotation(t)) => t,\n+    let pat = match ctx.path_context() {\n+        Some(\n+            ctx @ PathCompletionCtx {\n+                kind: PathKind::Type { location: TypeLocation::TypeAscription(ascription), .. },\n+                ..\n+            },\n+        ) if ctx.is_trivial_path() => ascription,\n         _ => return None,\n     };\n     let x = match pat {\n-        Let(pat) | FnParam(pat) => ctx.sema.type_of_pat(pat.as_ref()?),\n-        Const(exp) | RetType(exp) => ctx.sema.type_of_expr(exp.as_ref()?),\n+        TypeAscriptionTarget::Let(pat) | TypeAscriptionTarget::FnParam(pat) => {\n+            ctx.sema.type_of_pat(pat.as_ref()?)\n+        }\n+        TypeAscriptionTarget::Const(exp) | TypeAscriptionTarget::RetType(exp) => {\n+            ctx.sema.type_of_expr(exp.as_ref()?)\n+        }\n     }?\n     .adjusted();\n     let ty_string = x.display_source_code(ctx.db, ctx.module.into()).ok()?;\n     acc.add(render_type_inference(ty_string, ctx));\n     None\n }\n-\n-fn add_assoc_item(acc: &mut Completions, ctx: &CompletionContext, item: hir::AssocItem) {\n-    match item {\n-        hir::AssocItem::Const(ct) if ctx.expects_generic_arg() => acc.add_const(ctx, ct),\n-        hir::AssocItem::Function(_) | hir::AssocItem::Const(_) => (),\n-        hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n-    }\n-}"}, {"sha": "5d062098d7d623f9f98ac334d34706041d794cc8", "filename": "crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=6269137760988863cb7438c2bb4e5cf69a263e9d", "patch": "@@ -5,16 +5,24 @@ use ide_db::{FxHashSet, SymbolKind};\n use syntax::{ast, AstNode};\n \n use crate::{\n-    context::{CompletionContext, NameRefContext, PathCompletionCtx, PathKind, PathQualifierCtx},\n+    context::{\n+        CompletionContext, NameRefContext, NameRefKind, PathCompletionCtx, PathKind,\n+        PathQualifierCtx,\n+    },\n     item::Builder,\n     CompletionItem, CompletionItemKind, CompletionRelevance, Completions,\n };\n \n pub(crate) fn complete_use_tree(acc: &mut Completions, ctx: &CompletionContext) {\n     let (&is_absolute_path, qualifier, name_ref) = match ctx.nameref_ctx() {\n         Some(NameRefContext {\n-            path_ctx:\n-                Some(PathCompletionCtx { kind: PathKind::Use, is_absolute_path, qualifier, .. }),\n+            kind:\n+                Some(NameRefKind::Path(PathCompletionCtx {\n+                    kind: PathKind::Use,\n+                    is_absolute_path,\n+                    qualifier,\n+                    ..\n+                })),\n             nameref,\n             ..\n         }) => (is_absolute_path, qualifier, nameref),"}, {"sha": "7421a3e98bf087485ef52d408e49671d5d25dd72", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 199, "deletions": 102, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=6269137760988863cb7438c2bb4e5cf69a263e9d", "patch": "@@ -22,10 +22,7 @@ use syntax::{\n use text_edit::Indel;\n \n use crate::{\n-    patterns::{\n-        determine_location, is_in_loop_body, is_in_token_of_for_loop, previous_token,\n-        ImmediateLocation,\n-    },\n+    patterns::{is_in_loop_body, is_in_token_of_for_loop, previous_token},\n     CompletionConfig,\n };\n \n@@ -43,43 +40,7 @@ pub(crate) enum Visible {\n     No,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(super) enum PathKind {\n-    Expr {\n-        in_block_expr: bool,\n-        in_loop_body: bool,\n-        after_if_expr: bool,\n-        ref_expr_parent: Option<ast::RefExpr>,\n-    },\n-    Type {\n-        in_tuple_struct: bool,\n-    },\n-    Attr {\n-        kind: AttrKind,\n-        annotated_item_kind: Option<SyntaxKind>,\n-    },\n-    Derive,\n-    /// Path in item position, that is inside an (Assoc)ItemList\n-    Item {\n-        kind: ItemListKind,\n-    },\n-    Pat,\n-    Vis {\n-        has_in_token: bool,\n-    },\n-    Use,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub(super) enum ItemListKind {\n-    SourceFile,\n-    Module,\n-    Impl,\n-    TraitImpl,\n-    Trait,\n-    ExternBlock,\n-}\n-\n+/// Existing qualifiers for the thing we are currently completing.\n #[derive(Debug, Default)]\n pub(super) struct QualifierCtx {\n     pub(super) unsafe_tok: Option<SyntaxToken>,\n@@ -92,6 +53,7 @@ impl QualifierCtx {\n     }\n }\n \n+/// The state of the path we are currently completing.\n #[derive(Debug)]\n pub(crate) struct PathCompletionCtx {\n     /// If this is a call with () already there (or {} in case of record patterns)\n@@ -126,6 +88,65 @@ impl PathCompletionCtx {\n     }\n }\n \n+/// The kind of path we are completing right now.\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(super) enum PathKind {\n+    Expr {\n+        in_block_expr: bool,\n+        in_loop_body: bool,\n+        after_if_expr: bool,\n+        ref_expr_parent: Option<ast::RefExpr>,\n+        is_func_update: Option<ast::RecordExpr>,\n+    },\n+    Type {\n+        location: TypeLocation,\n+    },\n+    Attr {\n+        kind: AttrKind,\n+        annotated_item_kind: Option<SyntaxKind>,\n+    },\n+    Derive,\n+    /// Path in item position, that is inside an (Assoc)ItemList\n+    Item {\n+        kind: ItemListKind,\n+    },\n+    Pat,\n+    Vis {\n+        has_in_token: bool,\n+    },\n+    Use,\n+}\n+\n+/// Original file ast nodes\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum TypeLocation {\n+    TupleField,\n+    TypeAscription(TypeAscriptionTarget),\n+    GenericArgList(Option<ast::GenericArgList>),\n+    TypeBound,\n+    Other,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum TypeAscriptionTarget {\n+    Let(Option<ast::Pat>),\n+    FnParam(Option<ast::Pat>),\n+    RetType(Option<ast::Expr>),\n+    Const(Option<ast::Expr>),\n+}\n+\n+/// The kind of item list a [`PathKind::Item`] belongs to.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(super) enum ItemListKind {\n+    SourceFile,\n+    Module,\n+    Impl,\n+    TraitImpl,\n+    Trait,\n+    ExternBlock,\n+}\n+\n+/// The path qualifier state of the path we are completing.\n #[derive(Debug)]\n pub(crate) struct PathQualifierCtx {\n     pub(crate) path: ast::Path,\n@@ -138,6 +159,7 @@ pub(crate) struct PathQualifierCtx {\n     pub(crate) is_infer_qualifier: bool,\n }\n \n+/// The state of the pattern we are completing.\n #[derive(Debug)]\n pub(super) struct PatternContext {\n     pub(super) refutability: PatternRefutability,\n@@ -150,12 +172,14 @@ pub(super) struct PatternContext {\n     pub(super) record_pat: Option<ast::RecordPat>,\n }\n \n+/// The state of the lifetime we are completing.\n #[derive(Debug)]\n pub(super) struct LifetimeContext {\n     pub(super) lifetime: Option<ast::Lifetime>,\n     pub(super) kind: LifetimeKind,\n }\n \n+/// The kind of lifetime we are completing.\n #[derive(Debug)]\n pub(super) enum LifetimeKind {\n     LifetimeParam { is_decl: bool, param: ast::LifetimeParam },\n@@ -164,13 +188,15 @@ pub(super) enum LifetimeKind {\n     LabelDef,\n }\n \n+/// The state of the name we are completing.\n #[derive(Debug)]\n pub(super) struct NameContext {\n     #[allow(dead_code)]\n     pub(super) name: Option<ast::Name>,\n     pub(super) kind: NameKind,\n }\n \n+/// The kind of the name we are completing.\n #[derive(Debug)]\n #[allow(dead_code)]\n pub(super) enum NameKind {\n@@ -195,34 +221,46 @@ pub(super) enum NameKind {\n     Variant,\n }\n \n+/// The state of the NameRef we are completing.\n #[derive(Debug)]\n pub(super) struct NameRefContext {\n     /// NameRef syntax in the original file\n     pub(super) nameref: Option<ast::NameRef>,\n-    // FIXME: these fields are actually disjoint -> enum\n-    pub(super) dot_access: Option<DotAccess>,\n-    pub(super) path_ctx: Option<PathCompletionCtx>,\n+    // FIXME: This shouldn't be an Option\n+    pub(super) kind: Option<NameRefKind>,\n+}\n+\n+/// The kind of the NameRef we are completing.\n+#[derive(Debug)]\n+pub(super) enum NameRefKind {\n+    Path(PathCompletionCtx),\n+    DotAccess(DotAccess),\n     /// Position where we are only interested in keyword completions\n-    pub(super) keyword: Option<ast::Item>,\n+    Keyword(ast::Item),\n     /// The record expression this nameref is a field of\n-    pub(super) record_expr: Option<(ast::RecordExpr, bool)>,\n+    RecordExpr(ast::RecordExpr),\n }\n \n+/// The identifier we are currently completing.\n #[derive(Debug)]\n pub(super) enum IdentContext {\n     Name(NameContext),\n     NameRef(NameRefContext),\n     Lifetime(LifetimeContext),\n-    /// Original token, fake token\n+    /// The string the cursor is currently inside\n     String {\n+        /// original token\n         original: ast::String,\n+        /// fake token\n         expanded: Option<ast::String>,\n     },\n+    /// Set if we are currently completing in an unexpanded attribute, this usually implies a builtin attribute like `allow($0)`\n     UnexpandedAttrTT {\n         fake_attribute_under_caret: Option<ast::Attr>,\n     },\n }\n \n+/// Information about the field or method access we are completing.\n #[derive(Debug)]\n pub(super) struct DotAccess {\n     pub(super) receiver: Option<ast::Expr>,\n@@ -278,9 +316,9 @@ pub(crate) struct CompletionContext<'a> {\n     /// The parent impl of the cursor position if it exists.\n     pub(super) impl_def: Option<ast::Impl>,\n     /// Are we completing inside a let statement with a missing semicolon?\n+    // FIXME: This should be part of PathKind::Expr\n     pub(super) incomplete_let: bool,\n \n-    pub(super) completion_location: Option<ImmediateLocation>,\n     pub(super) previous_token: Option<SyntaxToken>,\n \n     pub(super) ident_ctx: IdentContext,\n@@ -341,9 +379,10 @@ impl<'a> CompletionContext<'a> {\n \n     pub(crate) fn dot_receiver(&self) -> Option<&ast::Expr> {\n         match self.nameref_ctx() {\n-            Some(NameRefContext { dot_access: Some(DotAccess { receiver, .. }), .. }) => {\n-                receiver.as_ref()\n-            }\n+            Some(NameRefContext {\n+                kind: Some(NameRefKind::DotAccess(DotAccess { receiver, .. })),\n+                ..\n+            }) => receiver.as_ref(),\n             _ => None,\n         }\n     }\n@@ -352,13 +391,11 @@ impl<'a> CompletionContext<'a> {\n         self.dot_receiver().is_some()\n     }\n \n-    // FIXME: This shouldn't exist\n-    pub(crate) fn expects_generic_arg(&self) -> bool {\n-        matches!(self.completion_location, Some(ImmediateLocation::GenericArgList(_)))\n-    }\n-\n     pub(crate) fn path_context(&self) -> Option<&PathCompletionCtx> {\n-        self.nameref_ctx().and_then(|ctx| ctx.path_ctx.as_ref())\n+        self.nameref_ctx().and_then(|ctx| match &ctx.kind {\n+            Some(NameRefKind::Path(path)) => Some(path),\n+            _ => None,\n+        })\n     }\n \n     pub(crate) fn path_qual(&self) -> Option<&ast::Path> {\n@@ -505,7 +542,6 @@ impl<'a> CompletionContext<'a> {\n             function_def: None,\n             impl_def: None,\n             incomplete_let: false,\n-            completion_location: None,\n             previous_token: None,\n             // dummy value, will be overwritten\n             ident_ctx: IdentContext::UnexpandedAttrTT { fake_attribute_under_caret: None },\n@@ -857,7 +893,7 @@ impl<'a> CompletionContext<'a> {\n                 let parent = name_ref.syntax().parent()?;\n                 let (mut nameref_ctx, _, _) =\n                     Self::classify_name_ref(&self.sema, &original_file, name_ref, parent);\n-                if let Some(path_ctx) = &mut nameref_ctx.path_ctx {\n+                if let Some(NameRefKind::Path(path_ctx)) = &mut nameref_ctx.kind {\n                     path_ctx.kind = PathKind::Derive;\n                 }\n                 self.ident_ctx = IdentContext::NameRef(nameref_ctx);\n@@ -898,8 +934,6 @@ impl<'a> CompletionContext<'a> {\n                 return Some(());\n             }\n         };\n-        self.completion_location =\n-            determine_location(&self.sema, original_file, offset, &name_like);\n         self.impl_def = self\n             .sema\n             .token_ancestors_with_macros(self.token.clone())\n@@ -1026,23 +1060,13 @@ impl<'a> CompletionContext<'a> {\n     ) -> (NameRefContext, Option<PatternContext>, QualifierCtx) {\n         let nameref = find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n \n-        let mut res = (\n-            NameRefContext {\n-                dot_access: None,\n-                path_ctx: None,\n-                nameref,\n-                record_expr: None,\n-                keyword: None,\n-            },\n-            None,\n-            QualifierCtx::default(),\n-        );\n+        let mut res = (NameRefContext { nameref, kind: None }, None, QualifierCtx::default());\n         let (nameref_ctx, pattern_ctx, qualifier_ctx) = &mut res;\n \n         if let Some(record_field) = ast::RecordExprField::for_field_name(&name_ref) {\n-            nameref_ctx.record_expr =\n+            nameref_ctx.kind =\n                 find_node_in_file_compensated(original_file, &record_field.parent_record_lit())\n-                    .zip(Some(false));\n+                    .map(NameRefKind::RecordExpr);\n             return res;\n         }\n         if let Some(record_field) = ast::RecordPatField::for_field_name_ref(&name_ref) {\n@@ -1067,28 +1091,28 @@ impl<'a> CompletionContext<'a> {\n             match parent {\n                 ast::PathSegment(segment) => segment,\n                 ast::FieldExpr(field) => {\n-                    let receiver = find_in_original_file(field.expr(), original_file);\n+                    let receiver = find_opt_node_in_file(original_file, field.expr());\n                     let receiver_is_ambiguous_float_literal = match &receiver {\n                         Some(ast::Expr::Literal(l)) => matches! {\n                             l.kind(),\n                             ast::LiteralKind::FloatNumber { .. } if l.syntax().last_token().map_or(false, |it| it.text().ends_with('.'))\n                         },\n                         _ => false,\n                     };\n-                    nameref_ctx.dot_access = Some(DotAccess {\n+                    nameref_ctx.kind = Some(NameRefKind::DotAccess(DotAccess {\n                         receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n                         kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal },\n                         receiver\n-                    });\n+                    }));\n                     return res;\n                 },\n                 ast::MethodCallExpr(method) => {\n-                    let receiver = find_in_original_file(method.receiver(), original_file);\n-                    nameref_ctx.dot_access = Some(DotAccess {\n+                    let receiver = find_opt_node_in_file(original_file, method.receiver());\n+                    nameref_ctx.kind = Some(NameRefKind::DotAccess(DotAccess {\n                         receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n                         kind: DotAccessKind::Method { has_parens: method.arg_list().map_or(false, |it| it.l_paren_token().is_some()) },\n                         receiver\n-                    });\n+                    }));\n                     return res;\n                 },\n                 _ => return res,\n@@ -1113,10 +1137,11 @@ impl<'a> CompletionContext<'a> {\n                 })\n                 .unwrap_or(false)\n         };\n-        let mut fill_record_expr = |syn: &SyntaxNode| {\n+        let func_update_record = |syn: &SyntaxNode| {\n             if let Some(record_expr) = syn.ancestors().nth(2).and_then(ast::RecordExpr::cast) {\n-                nameref_ctx.record_expr =\n-                    find_node_in_file_compensated(original_file, &record_expr).zip(Some(true));\n+                find_node_in_file_compensated(original_file, &record_expr)\n+            } else {\n+                None\n             }\n         };\n         let after_if_expr = |node: SyntaxNode| {\n@@ -1161,33 +1186,91 @@ impl<'a> CompletionContext<'a> {\n             None\n         };\n \n+        let type_location = |it: Option<SyntaxNode>| {\n+            let parent = it?;\n+            let res = match_ast! {\n+                match parent {\n+                    ast::Const(it) => {\n+                        let name = find_opt_node_in_file(original_file, it.name())?;\n+                        let original = ast::Const::cast(name.syntax().parent()?)?;\n+                        TypeLocation::TypeAscription(TypeAscriptionTarget::Const(original.body()))\n+                    },\n+                    ast::RetType(it) => {\n+                        if it.thin_arrow_token().is_none() {\n+                            return None;\n+                        }\n+                        let parent = match ast::Fn::cast(parent.parent()?) {\n+                            Some(x) => x.param_list(),\n+                            None => ast::ClosureExpr::cast(parent.parent()?)?.param_list(),\n+                        };\n+\n+                        let parent = find_opt_node_in_file(original_file, parent)?.syntax().parent()?;\n+                        TypeLocation::TypeAscription(TypeAscriptionTarget::RetType(match_ast! {\n+                            match parent {\n+                                ast::ClosureExpr(it) => {\n+                                    it.body()\n+                                },\n+                                ast::Fn(it) => {\n+                                    it.body().map(ast::Expr::BlockExpr)\n+                                },\n+                                _ => return None,\n+                            }\n+                        }))\n+                    },\n+                    ast::Param(it) => {\n+                        if it.colon_token().is_none() {\n+                            return None;\n+                        }\n+                        TypeLocation::TypeAscription(TypeAscriptionTarget::FnParam(find_opt_node_in_file(original_file, it.pat())))\n+                    },\n+                    ast::LetStmt(it) => {\n+                        if it.colon_token().is_none() {\n+                            return None;\n+                        }\n+                        TypeLocation::TypeAscription(TypeAscriptionTarget::Let(find_opt_node_in_file(original_file, it.pat())))\n+                    },\n+                    ast::TypeBound(_) => TypeLocation::TypeBound,\n+                    // is this case needed?\n+                    ast::TypeBoundList(_) => TypeLocation::TypeBound,\n+                    ast::GenericArg(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(original_file, it.syntax().parent().and_then(ast::GenericArgList::cast))),\n+                    // is this case needed?\n+                    ast::GenericArgList(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(original_file, Some(it))),\n+                    ast::TupleField(_) => TypeLocation::TupleField,\n+                    _ => return None,\n+                }\n+            };\n+            Some(res)\n+        };\n+\n         // Infer the path kind\n         let kind = path.syntax().parent().and_then(|it| {\n             match_ast! {\n                 match it {\n-                    ast::PathType(it) => Some(PathKind::Type {\n-                        in_tuple_struct: it.syntax().parent().map_or(false, |it| ast::TupleField::can_cast(it.kind()))\n-                    }),\n+                    ast::PathType(it) => {\n+                        let location = type_location(it.syntax().parent());\n+                        Some(PathKind::Type {\n+                            location: location.unwrap_or(TypeLocation::Other),\n+                        })\n+                    },\n                     ast::PathExpr(it) => {\n                         if let Some(p) = it.syntax().parent() {\n                             if ast::ExprStmt::can_cast(p.kind()) {\n                                 if let Some(kind) = inbetween_body_and_decl_check(p) {\n-                                    nameref_ctx.keyword = Some(kind);\n+                                    nameref_ctx.kind = Some(NameRefKind::Keyword(kind));\n                                     return None;\n                                 }\n                             }\n                         }\n \n-                        fill_record_expr(it.syntax());\n-\n                         path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n                         let in_block_expr = is_in_block(it.syntax());\n                         let in_loop_body = is_in_loop_body(it.syntax());\n                         let after_if_expr = after_if_expr(it.syntax().clone());\n                         let ref_expr_parent = path.as_single_name_ref()\n                             .and_then(|_| it.syntax().parent()).and_then(ast::RefExpr::cast);\n+                        let is_func_update = func_update_record(it.syntax());\n \n-                        Some(PathKind::Expr { in_block_expr, in_loop_body, after_if_expr, ref_expr_parent })\n+                        Some(PathKind::Expr { in_block_expr, in_loop_body, after_if_expr, ref_expr_parent, is_func_update })\n                     },\n                     ast::TupleStructPat(it) => {\n                         path_ctx.has_call_parens = true;\n@@ -1205,15 +1288,20 @@ impl<'a> CompletionContext<'a> {\n                     },\n                     ast::MacroCall(it) => {\n                         if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n-                            nameref_ctx.keyword = Some(kind);\n+                            nameref_ctx.kind = Some(NameRefKind::Keyword(kind));\n                             return None;\n                         }\n \n                         path_ctx.has_macro_bang = it.excl_token().is_some();\n                         let parent = it.syntax().parent();\n                         match parent.as_ref().map(|it| it.kind()) {\n                             Some(SyntaxKind::MACRO_PAT) => Some(PathKind::Pat),\n-                            Some(SyntaxKind::MACRO_TYPE) => Some(PathKind::Type { in_tuple_struct: false }),\n+                            Some(SyntaxKind::MACRO_TYPE) => {\n+                                let location = type_location(parent.unwrap().parent());\n+                                Some(PathKind::Type {\n+                                    location: location.unwrap_or(TypeLocation::Other),\n+                                })\n+                            },\n                             Some(SyntaxKind::ITEM_LIST) => Some(PathKind::Item { kind: ItemListKind::Module }),\n                             Some(SyntaxKind::ASSOC_ITEM_LIST) => Some(PathKind::Item { kind: match parent.and_then(|it| it.parent()) {\n                                 Some(it) => match_ast! {\n@@ -1236,10 +1324,10 @@ impl<'a> CompletionContext<'a> {\n                                     let in_loop_body = is_in_loop_body(it.syntax());\n                                     let in_block_expr = is_in_block(it.syntax());\n                                     let after_if_expr = after_if_expr(it.syntax().clone());\n-                                    fill_record_expr(it.syntax());\n                                     let ref_expr_parent = path.as_single_name_ref()\n                                         .and_then(|_| it.syntax().parent()).and_then(ast::RefExpr::cast);\n-                                    PathKind::Expr { in_block_expr, in_loop_body, after_if_expr, ref_expr_parent }\n+                                    let is_func_update = func_update_record(it.syntax());\n+                                    PathKind::Expr { in_block_expr, in_loop_body, after_if_expr, ref_expr_parent, is_func_update }\n                                 });\n                             },\n                         }\n@@ -1365,7 +1453,7 @@ impl<'a> CompletionContext<'a> {\n                 }\n             }\n         }\n-        nameref_ctx.path_ctx = Some(path_ctx);\n+        nameref_ctx.kind = Some(NameRefKind::Path(path_ctx));\n         res\n     }\n }\n@@ -1422,15 +1510,14 @@ fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternCont\n     }\n }\n \n-fn find_in_original_file<N: AstNode>(x: Option<N>, original_file: &SyntaxNode) -> Option<N> {\n-    fn find_node_with_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Option<N> {\n-        let range = syntax.text_range().intersect(range)?;\n-        syntax.covering_element(range).ancestors().find_map(N::cast)\n-    }\n-    x.map(|e| e.syntax().text_range()).and_then(|r| find_node_with_range(original_file, r))\n+/// Attempts to find `node` inside `syntax` via `node`'s text range.\n+/// If the fake identifier has been inserted after this node or inside of this node use the `_compensated` version instead.\n+fn find_opt_node_in_file<N: AstNode>(syntax: &SyntaxNode, node: Option<N>) -> Option<N> {\n+    find_node_in_file(syntax, &node?)\n }\n \n /// Attempts to find `node` inside `syntax` via `node`'s text range.\n+/// If the fake identifier has been inserted after this node or inside of this node use the `_compensated` version instead.\n fn find_node_in_file<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {\n     let syntax_range = syntax.text_range();\n     let range = node.syntax().text_range();\n@@ -1449,11 +1536,21 @@ fn find_node_in_file_compensated<N: AstNode>(syntax: &SyntaxNode, node: &N) -> O\n         return None;\n     }\n     let range = TextRange::new(range.start(), end);\n-    // our inserted ident could cause `range` to be go outside of the original syntax, so cap it\n+    // our inserted ident could cause `range` to go outside of the original syntax, so cap it\n     let intersection = range.intersect(syntax_range)?;\n     syntax.covering_element(intersection).ancestors().find_map(N::cast)\n }\n \n+/// Attempts to find `node` inside `syntax` via `node`'s text range while compensating\n+/// for the offset introduced by the fake ident..\n+/// This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.\n+fn find_opt_node_in_file_compensated<N: AstNode>(\n+    syntax: &SyntaxNode,\n+    node: Option<N>,\n+) -> Option<N> {\n+    find_node_in_file_compensated(syntax, &node?)\n+}\n+\n fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<(ast::Path, bool)> {\n     if let Some(qual) = path.qualifier() {\n         return Some((qual, false));"}, {"sha": "9efb42c4de75813836f739612513d53a09343118", "filename": "crates/ide-completion/src/patterns.rs", "status": "modified", "additions": 2, "deletions": 157, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fpatterns.rs?ref=6269137760988863cb7438c2bb4e5cf69a263e9d", "patch": "@@ -4,171 +4,16 @@\n //! This means we for example expand a NameRef token to its outermost Path node, as semantically these act in the same location\n //! and the completions usually query for path specific things on the Path context instead. This simplifies some location handling.\n \n-use hir::Semantics;\n-use ide_db::RootDatabase;\n use syntax::{\n-    ast::{self, HasLoopBody, HasName},\n+    ast::{self, HasLoopBody},\n     match_ast, AstNode, SyntaxElement,\n     SyntaxKind::*,\n-    SyntaxNode, SyntaxToken, TextRange, TextSize,\n+    SyntaxNode, SyntaxToken,\n };\n \n #[cfg(test)]\n use crate::tests::check_pattern_is_applicable;\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) enum TypeAnnotation {\n-    Let(Option<ast::Pat>),\n-    FnParam(Option<ast::Pat>),\n-    RetType(Option<ast::Expr>),\n-    Const(Option<ast::Expr>),\n-}\n-\n-/// Direct parent \"thing\" of what we are currently completing.\n-///\n-/// This may contain nodes of the fake file as well as the original, comments on the variants specify\n-/// from which file the nodes are.\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) enum ImmediateLocation {\n-    TypeBound,\n-    /// Original file ast node\n-    TypeAnnotation(TypeAnnotation),\n-    // Only set from a type arg\n-    /// Original file ast node\n-    GenericArgList(ast::GenericArgList),\n-}\n-\n-pub(crate) fn determine_location(\n-    sema: &Semantics<RootDatabase>,\n-    original_file: &SyntaxNode,\n-    offset: TextSize,\n-    name_like: &ast::NameLike,\n-) -> Option<ImmediateLocation> {\n-    let node = match name_like {\n-        ast::NameLike::NameRef(name_ref) => maximize_name_ref(name_ref),\n-        ast::NameLike::Name(name) => name.syntax().clone(),\n-        ast::NameLike::Lifetime(lt) => lt.syntax().clone(),\n-    };\n-\n-    match_ast! {\n-        match node {\n-            ast::TypeBoundList(_it) => return Some(ImmediateLocation::TypeBound),\n-            _ => (),\n-        }\n-    };\n-\n-    let parent = match node.parent() {\n-        Some(parent) => match ast::MacroCall::cast(parent.clone()) {\n-            // When a path is being typed in an (Assoc)ItemList the parser will always emit a macro_call.\n-            // This is usually fine as the node expansion code above already accounts for that with\n-            // the ancestors call, but there is one exception to this which is that when an attribute\n-            // precedes it the code above will not walk the Path to the parent MacroCall as their ranges differ.\n-            // FIXME path expr and statement have a similar problem\n-            Some(call)\n-                if call.excl_token().is_none()\n-                    && call.token_tree().is_none()\n-                    && call.semicolon_token().is_none() =>\n-            {\n-                call.syntax().parent()?\n-            }\n-            _ => parent,\n-        },\n-        // SourceFile\n-        None => return None,\n-    };\n-\n-    let res = match_ast! {\n-        match parent {\n-            ast::TypeBound(_) => ImmediateLocation::TypeBound,\n-            ast::TypeBoundList(_) => ImmediateLocation::TypeBound,\n-            ast::GenericArgList(_) => sema\n-                .find_node_at_offset_with_macros(original_file, offset)\n-                .map(ImmediateLocation::GenericArgList)?,\n-            ast::Const(it) => {\n-                if !it.ty().map_or(false, |x| x.syntax().text_range().contains(offset)) {\n-                    return None;\n-                }\n-                let name = find_in_original_file(it.name(), original_file)?;\n-                let original = ast::Const::cast(name.syntax().parent()?)?;\n-                ImmediateLocation::TypeAnnotation(TypeAnnotation::Const(original.body()))\n-            },\n-            ast::RetType(it) => {\n-                if it.thin_arrow_token().is_none() {\n-                    return None;\n-                }\n-                if !it.ty().map_or(false, |x| x.syntax().text_range().contains(offset)) {\n-                    return None;\n-                }\n-                let parent = match ast::Fn::cast(parent.parent()?) {\n-                    Some(x) => x.param_list(),\n-                    None => ast::ClosureExpr::cast(parent.parent()?)?.param_list(),\n-                };\n-                let parent = find_in_original_file(parent, original_file)?.syntax().parent()?;\n-                ImmediateLocation::TypeAnnotation(TypeAnnotation::RetType(match_ast! {\n-                    match parent {\n-                        ast::ClosureExpr(it) => {\n-                            it.body()\n-                        },\n-                        ast::Fn(it) => {\n-                            it.body().map(ast::Expr::BlockExpr)\n-                        },\n-                        _ => return None,\n-                    }\n-                }))\n-            },\n-            ast::Param(it) => {\n-                if it.colon_token().is_none() {\n-                    return None;\n-                }\n-                if !it.ty().map_or(false, |x| x.syntax().text_range().contains(offset)) {\n-                    return None;\n-                }\n-                ImmediateLocation::TypeAnnotation(TypeAnnotation::FnParam(find_in_original_file(it.pat(), original_file)))\n-            },\n-            ast::LetStmt(it) => {\n-                if it.colon_token().is_none() {\n-                    return None;\n-                }\n-                if !it.ty().map_or(false, |x| x.syntax().text_range().contains(offset)) {\n-                    return None;\n-                }\n-                ImmediateLocation::TypeAnnotation(TypeAnnotation::Let(find_in_original_file(it.pat(), original_file)))\n-            },\n-            _ => return None,\n-        }\n-    };\n-    fn find_in_original_file<N: AstNode>(x: Option<N>, original_file: &SyntaxNode) -> Option<N> {\n-        x.map(|e| e.syntax().text_range()).and_then(|r| find_node_with_range(original_file, r))\n-    }\n-    Some(res)\n-}\n-\n-/// Maximize a nameref to its enclosing path if its the last segment of said path.\n-/// That is, when completing a [`NameRef`] we actually handle it as the path it is part of when determining\n-/// its location.\n-fn maximize_name_ref(name_ref: &ast::NameRef) -> SyntaxNode {\n-    if let Some(segment) = name_ref.syntax().parent().and_then(ast::PathSegment::cast) {\n-        let p = segment.parent_path();\n-        if p.parent_path().is_none() {\n-            // Get rid of PathExpr, PathType, etc...\n-            let path = p\n-                .syntax()\n-                .ancestors()\n-                .take_while(|it| it.text_range() == p.syntax().text_range())\n-                .last();\n-            if let Some(it) = path {\n-                return it;\n-            }\n-        }\n-    }\n-    name_ref.syntax().clone()\n-}\n-\n-fn find_node_with_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Option<N> {\n-    let range = syntax.text_range().intersect(range)?;\n-    syntax.covering_element(range).ancestors().find_map(N::cast)\n-}\n-\n pub(crate) fn previous_token(element: SyntaxElement) -> Option<SyntaxToken> {\n     element.into_token().and_then(previous_non_trivia_token)\n }"}, {"sha": "566eaa575d49dd0c6e1ff9d00d5f327bb767b4ae", "filename": "crates/ide-completion/src/render/function.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs?ref=6269137760988863cb7438c2bb4e5cf69a263e9d", "patch": "@@ -8,7 +8,8 @@ use syntax::SmolStr;\n \n use crate::{\n     context::{\n-        CompletionContext, DotAccess, DotAccessKind, NameRefContext, PathCompletionCtx, PathKind,\n+        CompletionContext, DotAccess, DotAccessKind, NameRefContext, NameRefKind,\n+        PathCompletionCtx, PathKind,\n     },\n     item::{Builder, CompletionItem, CompletionItemKind, CompletionRelevance},\n     render::{compute_exact_name_match, compute_ref_match, compute_type_match, RenderContext},\n@@ -212,7 +213,10 @@ fn should_add_parens(ctx: &CompletionContext) -> bool {\n     if matches!(\n         ctx.nameref_ctx(),\n         Some(NameRefContext {\n-            dot_access: Some(DotAccess { kind: DotAccessKind::Method { has_parens: true }, .. }),\n+            kind: Some(NameRefKind::DotAccess(DotAccess {\n+                kind: DotAccessKind::Method { has_parens: true },\n+                ..\n+            })),\n             ..\n         })\n     ) {"}, {"sha": "c7514e1b578739487e50fce351b93a2812984aea", "filename": "crates/ide-completion/src/tests/record.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs?ref=6269137760988863cb7438c2bb4e5cf69a263e9d", "patch": "@@ -105,7 +105,6 @@ fn foo(f: Struct) {\n #[test]\n fn functional_update() {\n     // FIXME: This should filter out all completions that do not have the type `Foo`\n-    // FIXME: Fields should not show up after `.`\n     check(\n         r#\"\n //- minicore:default\n@@ -192,8 +191,6 @@ fn main() {\n }\n \"#,\n         expect![[r#\"\n-            fd foo1                   u32\n-            fd foo2                   u32\n             fn default() (as Default) fn() -> Self\n         \"#]],\n     );"}]}