{"sha": "244231720d29db856c5a28c0dda6c2efd7c9219a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0NDIzMTcyMGQyOWRiODU2YzVhMjhjMGRkYTZjMmVmZDdjOTIxOWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-07T11:53:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-07T20:51:30Z"}, "message": "Update parser with `for` syntax", "tree": {"sha": "41648e7c6c16102a7a602be441b4f1cdad8e7411", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41648e7c6c16102a7a602be441b4f1cdad8e7411"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/244231720d29db856c5a28c0dda6c2efd7c9219a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/244231720d29db856c5a28c0dda6c2efd7c9219a", "html_url": "https://github.com/rust-lang/rust/commit/244231720d29db856c5a28c0dda6c2efd7c9219a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/244231720d29db856c5a28c0dda6c2efd7c9219a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c18a1327e3ccf02ae9f755ca280d53177eeb298d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c18a1327e3ccf02ae9f755ca280d53177eeb298d", "html_url": "https://github.com/rust-lang/rust/commit/c18a1327e3ccf02ae9f755ca280d53177eeb298d"}], "stats": {"total": 949, "additions": 544, "deletions": 405}, "files": [{"sha": "6f1287014d7760b73d1428e5644b31c0d66419a9", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -1690,8 +1690,8 @@ impl LintPass for Stability {\n                 for t in supertraits.iter() {\n                     match *t {\n                         ast::TraitTyParamBound(ref t) => {\n-                            let id = ty::trait_ref_to_def_id(cx.tcx, t);\n-                            self.lint(cx, id, t.path.span);\n+                            let id = ty::trait_ref_to_def_id(cx.tcx, &t.trait_ref);\n+                            self.lint(cx, id, t.trait_ref.path.span);\n                         }\n                         _ => (/* pass */)\n                     }"}, {"sha": "eddd616e616e0ca05898cb59f1290d59bf4f7a3c", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -1291,7 +1291,7 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n         match *ty_param_bound {\n             ast::TraitTyParamBound(ref trait_ref) => {\n                 if !self.tcx.sess.features.borrow().visible_private_types &&\n-                        self.path_is_private_type(trait_ref.ref_id) {\n+                        self.path_is_private_type(trait_ref.trait_ref.ref_id) {\n                     self.tcx.sess.span_err(span,\n                                            \"private type in exported type \\\n                                             parameter bound\");\n@@ -1432,7 +1432,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                             //\n                             // Those in 2. are warned via walk_generics and this\n                             // call here.\n-                            visit::walk_trait_ref_helper(self, tr)\n+                            self.visit_trait_ref(tr)\n                         }\n                     }\n                 } else if trait_ref.is_none() && self_is_public_path {"}, {"sha": "62d1e13d41f0665071e370fe0490b0291b4b907b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -33,12 +33,12 @@ use syntax::ast::{ItemTrait, ItemTy, LOCAL_CRATE, Local, ItemConst};\n use syntax::ast::{MethodImplItem, Mod, Name, NamedField, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path, PathListIdent, PathListMod};\n-use syntax::ast::{PrimTy, Public, SelfExplicit, SelfStatic};\n+use syntax::ast::{PolyTraitRef, PrimTy, Public, SelfExplicit, SelfStatic};\n use syntax::ast::{RegionTyParamBound, StmtDecl, StructField};\n use syntax::ast::{StructVariantKind, TraitRef, TraitTyParamBound};\n use syntax::ast::{TupleVariantKind, Ty, TyBool, TyChar, TyClosure, TyF32};\n use syntax::ast::{TyF64, TyFloat, TyI, TyI8, TyI16, TyI32, TyI64, TyInt};\n-use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyProc, TyQPath};\n+use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyPolyTraitRef, TyProc, TyQPath};\n use syntax::ast::{TyRptr, TyStr, TyU, TyU8, TyU16, TyU32, TyU64, TyUint};\n use syntax::ast::{TypeImplItem, UnnamedField};\n use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n@@ -607,6 +607,7 @@ enum TraitReferenceType {\n     TraitImplementation,             // impl SomeTrait for T { ... }\n     TraitDerivation,                 // trait T : SomeTrait { ... }\n     TraitBoundingTypeParameter,      // fn f<T:SomeTrait>() { ... }\n+    TraitObject,                     // Box<for<'a> SomeTrait>\n }\n \n impl NameBindings {\n@@ -4244,11 +4245,11 @@ impl<'a> Resolver<'a> {\n                     this.resolve_type_parameter_bounds(item.id, bounds,\n                                                        TraitDerivation);\n \n-                    match unbound {\n-                        &Some(ast::TraitTyParamBound(ref tpb)) => {\n+                    match *unbound {\n+                        Some(ref tpb) => {\n                             this.resolve_trait_reference(item.id, tpb, TraitDerivation);\n                         }\n-                        _ => {}\n+                        None => {}\n                     }\n \n                     for trait_item in (*trait_items).iter() {\n@@ -4495,7 +4496,7 @@ impl<'a> Resolver<'a> {\n         }\n         match &type_parameter.unbound {\n             &Some(ref unbound) =>\n-                self.resolve_type_parameter_bound(\n+                self.resolve_trait_reference(\n                     type_parameter.id, unbound, TraitBoundingTypeParameter),\n             &None => {}\n         }\n@@ -4521,12 +4522,19 @@ impl<'a> Resolver<'a> {\n                                     reference_type: TraitReferenceType) {\n         match *type_parameter_bound {\n             TraitTyParamBound(ref tref) => {\n-                self.resolve_trait_reference(id, tref, reference_type)\n+                self.resolve_poly_trait_reference(id, tref, reference_type)\n             }\n             RegionTyParamBound(..) => {}\n         }\n     }\n \n+    fn resolve_poly_trait_reference(&mut self,\n+                                    id: NodeId,\n+                                    poly_trait_reference: &PolyTraitRef,\n+                                    reference_type: TraitReferenceType) {\n+        self.resolve_trait_reference(id, &poly_trait_reference.trait_ref, reference_type)\n+    }\n+\n     fn resolve_trait_reference(&mut self,\n                                id: NodeId,\n                                trait_reference: &TraitRef,\n@@ -4538,6 +4546,7 @@ impl<'a> Resolver<'a> {\n                     TraitBoundingTypeParameter => \"bound type parameter with\",\n                     TraitImplementation        => \"implement\",\n                     TraitDerivation            => \"derive\",\n+                    TraitObject                => \"reference\",\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n@@ -5044,6 +5053,13 @@ impl<'a> Resolver<'a> {\n                 visit::walk_ty(self, ty);\n             }\n \n+            TyPolyTraitRef(ref poly_trait_ref) => {\n+                self.resolve_poly_trait_reference(\n+                    ty.id,\n+                    &**poly_trait_ref,\n+                    TraitObject);\n+                visit::walk_ty(self, ty);\n+            }\n             _ => {\n                 // Just resolve embedded types.\n                 visit::walk_ty(self, ty);"}, {"sha": "8ac52b891b99d65ad735175bd0f57daa410a5af5", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 78, "deletions": 83, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -19,6 +19,7 @@\n \n use driver::session::Session;\n use middle::subst;\n+use std::fmt;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::owned_slice::OwnedSlice;\n@@ -46,18 +47,12 @@ pub enum DefRegion {\n // that it corresponds to\n pub type NamedRegionMap = NodeMap<DefRegion>;\n \n-// Returns an instance of some type that implements std::fmt::Show\n-fn lifetime_show(lt_name: &ast::Name) -> token::InternedString {\n-    token::get_name(*lt_name)\n-}\n-\n struct LifetimeContext<'a> {\n     sess: &'a Session,\n     named_region_map: &'a mut NamedRegionMap,\n     scope: Scope<'a>\n }\n \n-#[deriving(Show)]\n enum ScopeChain<'a> {\n     /// EarlyScope(i, ['a, 'b, ...], s) extends s with early-bound\n     /// lifetimes, assigning indexes 'a => i, 'b => i+1, ... etc.\n@@ -88,50 +83,42 @@ pub fn krate(sess: &Session, krate: &ast::Crate) -> NamedRegionMap {\n \n impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        let lifetimes = match item.node {\n-            ast::ItemFn(..) | // fn lifetimes get added in visit_fn below\n+        match item.node {\n+            ast::ItemFn(..) => {\n+                // Fn lifetimes get added in visit_fn below:\n+                self.with(RootScope, |this| visit::walk_item(this, item));\n+            }\n             ast::ItemMod(..) |\n             ast::ItemMac(..) |\n             ast::ItemForeignMod(..) |\n-            ast::ItemStatic(..) | ast::ItemConst(..) => {\n-                self.with(|_, f| f(RootScope), |v| visit::walk_item(v, item));\n-                return;\n+            ast::ItemStatic(..) |\n+            ast::ItemConst(..) => {\n+                // These sorts of items have no lifetime parameters at all.\n+                self.with(RootScope, |this| visit::walk_item(this, item));\n             }\n             ast::ItemTy(_, ref generics) |\n             ast::ItemEnum(_, ref generics) |\n             ast::ItemStruct(_, ref generics) |\n-            ast::ItemTrait(ref generics, _, _, _) => {\n-                self.with(|scope, f| {\n-                    f(EarlyScope(subst::TypeSpace,\n-                                 &generics.lifetimes,\n-                                 scope))\n-                }, |v| v.check_lifetime_defs(&generics.lifetimes));\n-                &generics.lifetimes\n-            }\n+            ast::ItemTrait(ref generics, _, _, _) |\n             ast::ItemImpl(ref generics, _, _, _) => {\n-                self.with(|scope, f| {\n-                    f(EarlyScope(subst::TypeSpace,\n-                                 &generics.lifetimes,\n-                                 scope))\n-                }, |v| v.check_lifetime_defs(&generics.lifetimes));\n-                &generics.lifetimes\n+                // These kinds of items have only early bound lifetime parameters.\n+                let lifetimes = &generics.lifetimes;\n+                self.with(EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE), |this| {\n+                    this.check_lifetime_defs(lifetimes);\n+                    visit::walk_item(this, item);\n+                });\n             }\n-        };\n-\n-        self.with(|_, f| f(EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE)), |v| {\n-            debug!(\"entering scope {}\", v.scope);\n-            v.check_lifetime_defs(lifetimes);\n-            visit::walk_item(v, item);\n-            debug!(\"exiting scope {}\", v.scope);\n-        });\n+        }\n     }\n \n     fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n                 b: &'v ast::Block, s: Span, n: ast::NodeId) {\n         match fk {\n             visit::FkItemFn(_, generics, _, _) |\n             visit::FkMethod(_, generics, _) => {\n-                self.visit_fn_decl(n, generics, |v| visit::walk_fn(v, fk, fd, b, s))\n+                self.visit_early_late(\n+                    subst::FnSpace, n, generics,\n+                    |this| visit::walk_fn(this, fk, fd, b, s))\n             }\n             visit::FkFnBlock(..) => {\n                 visit::walk_fn(self, fk, fd, b, s)\n@@ -146,22 +133,20 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n             _ => return visit::walk_ty(self, ty)\n         };\n \n-        self.with(|scope, f| f(LateScope(ty.id, lifetimes, scope)), |v| {\n-            v.check_lifetime_defs(lifetimes);\n-            debug!(\"pushing fn scope id={} due to type\", ty.id);\n-            visit::walk_ty(v, ty);\n-            debug!(\"popping fn scope id={} due to type\", ty.id);\n+        self.with(LateScope(ty.id, lifetimes, self.scope), |this| {\n+            this.check_lifetime_defs(lifetimes);\n+            visit::walk_ty(this, ty);\n         });\n     }\n \n     fn visit_ty_method(&mut self, m: &ast::TypeMethod) {\n-        self.visit_fn_decl(m.id, &m.generics, |v| visit::walk_ty_method(v, m))\n+        self.visit_early_late(\n+            subst::FnSpace, m.id, &m.generics,\n+            |this| visit::walk_ty_method(this, m))\n     }\n \n     fn visit_block(&mut self, b: &ast::Block) {\n-        debug!(\"pushing block scope {}\", b.id);\n-        self.with(|scope, f| f(BlockScope(b.id, scope)), |v| visit::walk_block(v, b));\n-        debug!(\"popping block scope {}\", b.id);\n+        self.with(BlockScope(b.id, self.scope), |this| visit::walk_block(this, b));\n     }\n \n     fn visit_lifetime_ref(&mut self, lifetime_ref: &ast::Lifetime) {\n@@ -188,21 +173,24 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n }\n \n impl<'a> LifetimeContext<'a> {\n-    fn with(&mut self, wrap_scope: |Scope, |ScopeChain||, f: |&mut LifetimeContext|) {\n-        let LifetimeContext { sess, ref mut named_region_map, scope} = *self;\n-        wrap_scope(scope, |scope1| f(&mut LifetimeContext {\n+    fn with(&mut self, wrap_scope: ScopeChain, f: |&mut LifetimeContext|) {\n+        let LifetimeContext {sess, ref mut named_region_map, ..} = *self;\n+        let mut this = LifetimeContext {\n             sess: sess,\n             named_region_map: *named_region_map,\n-            scope: &scope1\n-        }))\n+            scope: &wrap_scope\n+        };\n+        debug!(\"entering scope {}\", this.scope);\n+        f(&mut this);\n+        debug!(\"exiting scope {}\", this.scope);\n     }\n \n     fn visit_ty_param_bounds(&mut self,\n                              bounds: &OwnedSlice<ast::TyParamBound>) {\n         for bound in bounds.iter() {\n             match *bound {\n                 ast::TraitTyParamBound(ref trait_ref) => {\n-                    self.visit_trait_ref(trait_ref);\n+                    self.visit_poly_trait_ref(trait_ref);\n                 }\n                 ast::RegionTyParamBound(ref lifetime) => {\n                     self.visit_lifetime_ref(lifetime);\n@@ -211,23 +199,27 @@ impl<'a> LifetimeContext<'a> {\n         }\n     }\n \n-    fn visit_trait_ref(&mut self, trait_ref: &ast::TraitRef) {\n-        self.with(|scope, f| {\n-            f(LateScope(trait_ref.ref_id, &trait_ref.lifetimes, scope))\n-        }, |v| {\n-            v.check_lifetime_defs(&trait_ref.lifetimes);\n-            for lifetime in trait_ref.lifetimes.iter() {\n-                v.visit_lifetime_decl(lifetime);\n+    fn visit_poly_trait_ref(&mut self, trait_ref: &ast::PolyTraitRef) {\n+        let ref_id = trait_ref.trait_ref.ref_id;\n+        self.with(LateScope(ref_id, &trait_ref.bound_lifetimes, self.scope), |this| {\n+            this.check_lifetime_defs(&trait_ref.bound_lifetimes);\n+            for lifetime in trait_ref.bound_lifetimes.iter() {\n+                this.visit_lifetime_decl(lifetime);\n             }\n-            v.visit_path(&trait_ref.path, trait_ref.ref_id);\n+            this.visit_trait_ref(&trait_ref.trait_ref)\n         })\n     }\n \n+    fn visit_trait_ref(&mut self, trait_ref: &ast::TraitRef) {\n+        self.visit_path(&trait_ref.path, trait_ref.ref_id);\n+    }\n+\n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n-    fn visit_fn_decl(&mut self,\n-                     n: ast::NodeId,\n-                     generics: &ast::Generics,\n-                     walk: |&mut LifetimeContext|) {\n+    fn visit_early_late(&mut self,\n+                        early_space: subst::ParamSpace,\n+                        binder_id: ast::NodeId,\n+                        generics: &ast::Generics,\n+                        walk: |&mut LifetimeContext|) {\n         /*!\n          * Handles visiting fns and methods. These are a bit\n          * complicated because we must distinguish early- vs late-bound\n@@ -248,33 +240,25 @@ impl<'a> LifetimeContext<'a> {\n          * numbered sequentially, starting from the lowest index that\n          * is already in scope (for a fn item, that will be 0, but for\n          * a method it might not be). Late bound lifetimes are\n-         * resolved by name and associated with a binder id (`n`), so\n+         * resolved by name and associated with a binder id (`binder_id`), so\n          * the ordering is not important there.\n          */\n \n         let referenced_idents = early_bound_lifetime_names(generics);\n-        debug!(\"pushing fn scope id={} due to fn item/method\\\n-               referenced_idents={}\",\n-               n,\n-               referenced_idents.iter().map(lifetime_show).collect::<Vec<token::InternedString>>());\n-        let lifetimes = &generics.lifetimes;\n-        if referenced_idents.is_empty() {\n-            self.with(|scope, f| f(LateScope(n, lifetimes, scope)), |v| {\n-                v.check_lifetime_defs(lifetimes);\n-                walk(v);\n-            });\n-        } else {\n-            let (early, late) = lifetimes.clone().partition(\n-                |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n-\n-            self.with(|scope, f| f(EarlyScope(subst::FnSpace, &early, scope)), |v| {\n-                v.with(|scope1, f| f(LateScope(n, &late, scope1)), |v| {\n-                    v.check_lifetime_defs(lifetimes);\n-                    walk(v);\n-                });\n+\n+        debug!(\"visit_early_late: binder_id={} referenced_idents={}\",\n+               binder_id,\n+               referenced_idents);\n+\n+        let (early, late) = generics.lifetimes.clone().partition(\n+            |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n+\n+        self.with(EarlyScope(early_space, &early, self.scope), |this| {\n+            this.with(LateScope(binder_id, &late, this.scope), |this| {\n+                this.check_lifetime_defs(&generics.lifetimes);\n+                walk(this);\n             });\n-        }\n-        debug!(\"popping fn scope id={} due to fn item/method\", n);\n+        });\n     }\n \n     fn resolve_lifetime_ref(&mut self, lifetime_ref: &ast::Lifetime) {\n@@ -525,3 +509,14 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n         }\n     }\n }\n+\n+impl<'a> fmt::Show for ScopeChain<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            EarlyScope(space, defs, _) => write!(fmt, \"EarlyScope({}, {})\", space, defs),\n+            LateScope(id, defs, _) => write!(fmt, \"LateScope({}, {})\", id, defs),\n+            BlockScope(id, _) => write!(fmt, \"BlockScope({})\", id),\n+            RootScope => write!(fmt, \"RootScope\"),\n+        }\n+    }\n+}"}, {"sha": "a2b80686d010ef7853ad97946b826e185017a77a", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -710,6 +710,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 }\n             };\n \n+            let trait_ref = &trait_ref.trait_ref;\n             match self.lookup_type_ref(trait_ref.ref_id) {\n                 Some(id) => {\n                     let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n@@ -1068,7 +1069,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             for bound in param.bounds.iter() {\n                 match *bound {\n                     ast::TraitTyParamBound(ref trait_ref) => {\n-                        self.process_trait_ref(trait_ref, None);\n+                        self.process_trait_ref(&trait_ref.trait_ref, None);\n                     }\n                     _ => {}\n                 }"}, {"sha": "1a6e8eeb320f048378527b559edc57f94805b60a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -5546,7 +5546,8 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_param(_) |\n             ty_infer(_) |\n             ty_open(_) |\n-            ty_err => {}\n+            ty_err => {\n+            }\n         }\n     });\n "}, {"sha": "e27ff636a2a6f3779a0526a0b294c09a3418d6c7", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 51, "deletions": 37, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -51,8 +51,6 @@\n \n use middle::const_eval;\n use middle::def;\n-use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n-use middle::lang_items::{FnOnceTraitLangItem};\n use middle::resolve_lifetime as rl;\n use middle::subst::{FnSpace, TypeSpace, AssocSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n@@ -398,6 +396,46 @@ fn ast_path_substs<'tcx,AC,RS>(\n     }\n }\n \n+pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n+                                         rscope: &RS,\n+                                         ast_trait_ref: &ast::TraitRef,\n+                                         self_ty: Option<ty::t>,\n+                                         associated_type: Option<ty::t>)\n+                                         -> Rc<ty::TraitRef>\n+                                         where AC: AstConv<'tcx>,\n+                                               RS: RegionScope\n+{\n+    /*!\n+     * Instantiates the path for the given trait reference, assuming that\n+     * it's bound to a valid trait type. Returns the def_id for the defining\n+     * trait. Fails if the type is a type other than a trait type.\n+     */\n+\n+    match lookup_def_tcx(this.tcx(),\n+                         ast_trait_ref.path.span,\n+                         ast_trait_ref.ref_id) {\n+        def::DefTrait(trait_did) => {\n+            let trait_ref =\n+                Rc::new(ast_path_to_trait_ref(this,\n+                                              rscope,\n+                                              trait_did,\n+                                              self_ty,\n+                                              associated_type,\n+                                              &ast_trait_ref.path,\n+                                              ast_trait_ref.ref_id));\n+\n+            this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n+                                                      trait_ref.clone());\n+            trait_ref\n+        }\n+        _ => {\n+            this.tcx().sess.span_fatal(\n+                ast_trait_ref.path.span,\n+                format!(\"`{}` is not a trait\", ast_trait_ref.path.user_string(this.tcx()))[]);\n+        }\n+    }\n+}\n+\n pub fn ast_path_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                          rscope: &RS,\n                                          trait_def_id: ast::DefId,\n@@ -620,41 +658,6 @@ enum PointerTy {\n     Uniq\n }\n \n-pub fn trait_ref_for_unboxed_function<'tcx, AC: AstConv<'tcx>,\n-                                      RS:RegionScope>(\n-                                      this: &AC,\n-                                      rscope: &RS,\n-                                      kind: ast::UnboxedClosureKind,\n-                                      decl: &ast::FnDecl,\n-                                      self_ty: Option<ty::t>)\n-                                      -> ty::TraitRef {\n-    let lang_item = match kind {\n-        ast::FnUnboxedClosureKind => FnTraitLangItem,\n-        ast::FnMutUnboxedClosureKind => FnMutTraitLangItem,\n-        ast::FnOnceUnboxedClosureKind => FnOnceTraitLangItem,\n-    };\n-    let trait_did = this.tcx().lang_items.require(lang_item).unwrap();\n-    let input_types = decl.inputs\n-                          .iter()\n-                          .map(|input| {\n-                            ast_ty_to_ty(this, rscope, &*input.ty)\n-                          }).collect::<Vec<_>>();\n-    let input_tuple = ty::mk_tup_or_nil(this.tcx(), input_types);\n-    let output_type = ast_ty_to_ty(this, rscope, &*decl.output);\n-    let mut substs = Substs::new_type(vec!(input_tuple, output_type),\n-                                      Vec::new());\n-\n-    match self_ty {\n-        Some(s) => substs.types.push(SelfSpace, s),\n-        None => ()\n-    }\n-\n-    ty::TraitRef {\n-        def_id: trait_did,\n-        substs: substs,\n-    }\n-}\n-\n // Handle `~`, `Box`, and `&` being able to mean strs and vecs.\n // If a_seq_ty is a str or a vec, make it a str/vec.\n // Also handle first-class trait types.\n@@ -898,6 +901,16 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n                 ty::mk_closure(tcx, fn_decl)\n             }\n+            ast::TyPolyTraitRef(ref data) => {\n+                // FIXME(#18639) this is just a placeholder for code to come\n+                let principal = instantiate_trait_ref(this, rscope, &data.trait_ref, None, None);\n+                let bounds = conv_existential_bounds(this,\n+                                                     rscope,\n+                                                     ast_ty.span,\n+                                                     &[principal.clone()],\n+                                                     &[]);\n+                ty::mk_trait(tcx, (*principal).clone(), bounds)\n+            }\n             ast::TyPath(ref path, ref bounds, id) => {\n                 let a_def = match tcx.def_map.borrow().get(&id) {\n                     None => {\n@@ -1536,6 +1549,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n     for &ast_bound in ast_bounds.iter() {\n         match *ast_bound {\n             ast::TraitTyParamBound(ref b) => {\n+                let b = &b.trait_ref; // FIXME\n                 match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n                     def::DefTrait(trait_did) => {\n                         match trait_def_ids.get(&trait_did) {"}, {"sha": "42411b598bfae824176114b3bd822bc5cab41059", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 33, "deletions": 65, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -61,7 +61,6 @@ use syntax::ast_util::{local_def, PostExpansionMethod};\n use syntax::codemap::Span;\n use syntax::parse::token::{special_idents};\n use syntax::parse::token;\n-use syntax::print::pprust::{path_to_string};\n use syntax::ptr::P;\n use syntax::visit;\n \n@@ -633,24 +632,33 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n                                  span: Span,\n                                  generics: &ast::Generics,\n                                  thing: &'static str) {\n+    let mut warn = false;\n+\n     for ty_param in generics.ty_params.iter() {\n-        let bounds = ty_param.bounds.iter();\n-        let mut bounds = bounds.chain(ty_param.unbound.iter());\n-        for bound in bounds {\n+        for bound in ty_param.bounds.iter() {\n             match *bound {\n                 ast::TraitTyParamBound(..) => {\n-                    // According to accepted RFC #XXX, we should\n-                    // eventually accept these, but it will not be\n-                    // part of this PR. Still, convert to warning to\n-                    // make bootstrapping easier.\n-                    span_warn!(ccx.tcx.sess, span, E0122,\n-                               \"trait bounds are not (yet) enforced \\\n-                                in {} definitions\",\n-                               thing);\n+                    warn = true;\n                 }\n                 ast::RegionTyParamBound(..) => { }\n             }\n         }\n+\n+        match ty_param.unbound {\n+            Some(_) => { warn = true; }\n+            None => { }\n+        }\n+    }\n+\n+    if warn {\n+        // According to accepted RFC #XXX, we should\n+        // eventually accept these, but it will not be\n+        // part of this PR. Still, convert to warning to\n+        // make bootstrapping easier.\n+        span_warn!(ccx.tcx.sess, span, E0122,\n+                   \"trait bounds are not (yet) enforced \\\n+                   in {} definitions\",\n+                   thing);\n     }\n }\n \n@@ -1147,7 +1155,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                             parent_visibility);\n \n             for trait_ref in opt_trait_ref.iter() {\n-                instantiate_trait_ref(&icx, trait_ref, selfty, None);\n+                astconv::instantiate_trait_ref(&icx, &ExplicitRscope, trait_ref, Some(selfty), None);\n             }\n         },\n         ast::ItemTrait(_, _, _, ref trait_methods) => {\n@@ -1315,47 +1323,6 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), pty);\n }\n \n-pub fn instantiate_trait_ref<'tcx,AC>(this: &AC,\n-                                      ast_trait_ref: &ast::TraitRef,\n-                                      self_ty: ty::t,\n-                                      associated_type: Option<ty::t>)\n-                                      -> Rc<ty::TraitRef>\n-                                      where AC: AstConv<'tcx> {\n-    /*!\n-     * Instantiates the path for the given trait reference, assuming that\n-     * it's bound to a valid trait type. Returns the def_id for the defining\n-     * trait. Fails if the type is a type other than a trait type.\n-     */\n-\n-    // FIXME(#5121) -- distinguish early vs late lifetime params\n-    let rscope = ExplicitRscope;\n-\n-    match lookup_def_tcx(this.tcx(),\n-                         ast_trait_ref.path.span,\n-                         ast_trait_ref.ref_id) {\n-        def::DefTrait(trait_did) => {\n-            let trait_ref =\n-                Rc::new(astconv::ast_path_to_trait_ref(this,\n-                                                       &rscope,\n-                                                       trait_did,\n-                                                       Some(self_ty),\n-                                                       associated_type,\n-                                                       &ast_trait_ref.path,\n-                                                       ast_trait_ref.ref_id));\n-\n-            this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n-                                                      trait_ref.clone());\n-            trait_ref\n-        }\n-        _ => {\n-            this.tcx().sess.span_fatal(\n-                ast_trait_ref.path.span,\n-                format!(\"`{}` is not a trait\",\n-                        path_to_string(&ast_trait_ref.path)).as_slice());\n-        }\n-    }\n-}\n-\n fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n     if trait_id.krate != ast::LOCAL_CRATE {\n         return ty::lookup_trait_def(ccx.tcx, trait_id)\n@@ -1720,14 +1687,14 @@ fn ty_generics_for_fn_or_method<'tcx,AC>(\n \n // Add the Sized bound, unless the type parameter is marked as `Sized?`.\n fn add_unsized_bound<'tcx,AC>(this: &AC,\n-                              unbound: &Option<ast::TyParamBound>,\n+                              unbound: &Option<ast::TraitRef>,\n                               bounds: &mut ty::BuiltinBounds,\n                               desc: &str,\n                               span: Span)\n                               where AC: AstConv<'tcx> {\n     let kind_id = this.tcx().lang_items.require(SizedTraitLangItem);\n     match unbound {\n-        &Some(ast::TraitTyParamBound(ref tpb)) => {\n+        &Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n             let trait_def_id = ty::trait_ref_to_def_id(this.tcx(), tpb);\n             match kind_id {\n@@ -1752,7 +1719,7 @@ fn add_unsized_bound<'tcx,AC>(this: &AC,\n             ty::try_add_builtin_trait(this.tcx(), kind_id.unwrap(), bounds);\n         }\n         // No lang item for Sized, so we can't add it as a bound.\n-        _ => {}\n+        &None => {}\n     }\n }\n \n@@ -1870,11 +1837,11 @@ fn ty_generics<'tcx,AC>(this: &AC,\n \n                 let trait_def_id =\n                     match lookup_def_tcx(this.tcx(),\n-                                         ast_trait_ref.path.span,\n-                                         ast_trait_ref.ref_id) {\n+                                         ast_trait_ref.trait_ref.path.span,\n+                                         ast_trait_ref.trait_ref.ref_id) {\n                         def::DefTrait(trait_def_id) => trait_def_id,\n                         _ => {\n-                            this.tcx().sess.span_bug(ast_trait_ref.path.span,\n+                            this.tcx().sess.span_bug(ast_trait_ref.trait_ref.path.span,\n                                                      \"not a trait?!\")\n                         }\n                     };\n@@ -1972,7 +1939,7 @@ fn compute_bounds<'tcx,AC>(this: &AC,\n                            name_of_bounded_thing: ast::Name,\n                            param_ty: ty::ParamTy,\n                            ast_bounds: &[ast::TyParamBound],\n-                           unbound: &Option<ast::TyParamBound>,\n+                           unbound: &Option<ast::TraitRef>,\n                            span: Span,\n                            where_clause: &ast::WhereClause)\n                            -> ty::ParamBounds\n@@ -2047,10 +2014,11 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n     let trait_bounds: Vec<Rc<ty::TraitRef>> =\n         trait_bounds.into_iter()\n         .map(|b| {\n-            instantiate_trait_ref(this,\n-                                  b,\n-                                  param_ty.to_ty(this.tcx()),\n-                                  Some(param_ty.to_ty(this.tcx())))\n+            astconv::instantiate_trait_ref(this,\n+                                           &ExplicitRscope,\n+                                           b,\n+                                           Some(param_ty.to_ty(this.tcx())),\n+                                           Some(param_ty.to_ty(this.tcx())))\n         })\n         .collect();\n     let region_bounds: Vec<ty::Region> ="}, {"sha": "83d90274fd323c183f16a4ed34c3874846bd6560", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -52,7 +52,6 @@ use middle::typeck::infer::type_variable::{RelationDir, EqTo,\n use middle::ty_fold::{TypeFoldable};\n use util::ppaux::Repr;\n \n-\n use syntax::ast::{Onceness, FnStyle};\n use syntax::ast;\n use syntax::abi;"}, {"sha": "80b4948f6fbf26bbc0e48ce3ba6380b67ca1a0a7", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -1102,7 +1102,8 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     // be passing down a map.\n                     ast::RegionTyParamBound(lt)\n                 }\n-                &ast::TraitTyParamBound(ref tr) => {\n+                &ast::TraitTyParamBound(ref poly_tr) => {\n+                    let tr = &poly_tr.trait_ref;\n                     let last_seg = tr.path.segments.last().unwrap();\n                     let mut insert = Vec::new();\n                     let lifetimes = last_seg.parameters.lifetimes();\n@@ -1119,10 +1120,12 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         region_names: region_names\n                     };\n                     let new_path = self.rebuild_path(rebuild_info, lifetime);\n-                    ast::TraitTyParamBound(ast::TraitRef {\n-                        path: new_path,\n-                        ref_id: tr.ref_id,\n-                        lifetimes: tr.lifetimes.clone(),\n+                    ast::TraitTyParamBound(ast::PolyTraitRef {\n+                        bound_lifetimes: poly_tr.bound_lifetimes.clone(),\n+                        trait_ref: ast::TraitRef {\n+                            path: new_path,\n+                            ref_id: tr.ref_id,\n+                        }\n                     })\n                 }\n             }"}, {"sha": "38e0c4fe040bdd042422e2fe72c162892217f59f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -963,6 +963,12 @@ impl Clean<Type> for ast::TraitRef {\n     }\n }\n \n+impl Clean<Type> for ast::PolyTraitRef {\n+    fn clean(&self, cx: &DocContext) -> Type {\n+        self.trait_ref.clean(cx)\n+    }\n+}\n+\n #[deriving(Clone, Encodable, Decodable)]\n pub enum TraitMethod {\n     RequiredMethod(Item),\n@@ -1306,7 +1312,8 @@ impl Clean<Type> for ty::t {\n             }\n             ty::ty_struct(did, ref substs) |\n             ty::ty_enum(did, ref substs) |\n-            ty::ty_trait(box ty::TyTrait { def_id: did, ref substs, .. }) => {\n+            ty::ty_trait(box ty::TyTrait { principal: ty::TraitRef { def_id: did, ref substs },\n+                                           .. }) => {\n                 let fqn = csearch::get_item_path(cx.tcx(), did);\n                 let fqn: Vec<String> = fqn.into_iter().map(|i| {\n                     i.to_string()"}, {"sha": "145978bb73f4be6c7458445c6bf604f68039a57f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -307,7 +307,7 @@ pub const DUMMY_NODE_ID: NodeId = -1;\n /// detects Copy, Send and Sync.\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum TyParamBound {\n-    TraitTyParamBound(TraitRef),\n+    TraitTyParamBound(PolyTraitRef),\n     RegionTyParamBound(Lifetime)\n }\n \n@@ -318,7 +318,7 @@ pub struct TyParam {\n     pub ident: Ident,\n     pub id: NodeId,\n     pub bounds: TyParamBounds,\n-    pub unbound: Option<TyParamBound>,\n+    pub unbound: Option<TraitRef>,\n     pub default: Option<P<Ty>>,\n     pub span: Span\n }\n@@ -1097,6 +1097,7 @@ pub enum Ty_ {\n     TyBareFn(P<BareFnTy>),\n     TyTup(Vec<P<Ty>> ),\n     TyPath(Path, Option<TyParamBounds>, NodeId), // for #7264; see above\n+    TyPolyTraitRef(P<PolyTraitRef>), // a type like `for<'a> Foo<&'a Bar>`\n     /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`\n     TyQPath(P<QPath>),\n     /// No-op; kept solely so that we can pretty-print faithfully\n@@ -1350,7 +1351,6 @@ pub struct Attribute_ {\n     pub is_sugared_doc: bool,\n }\n \n-\n /// TraitRef's appear in impls.\n /// resolve maps each TraitRef's ref_id to its defining trait; that's all\n /// that the ref_id is for. The impl_id maps to the \"self type\" of this impl.\n@@ -1360,7 +1360,15 @@ pub struct Attribute_ {\n pub struct TraitRef {\n     pub path: Path,\n     pub ref_id: NodeId,\n-    pub lifetimes: Vec<LifetimeDef>,\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct PolyTraitRef {\n+    /// The `'a` in `<'a> Foo<&'a T>`\n+    pub bound_lifetimes: Vec<LifetimeDef>,\n+\n+    /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`\n+    pub trait_ref: TraitRef\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n@@ -1448,8 +1456,8 @@ pub enum Item_ {\n     ItemStruct(P<StructDef>, Generics),\n     /// Represents a Trait Declaration\n     ItemTrait(Generics,\n-              Option<TyParamBound>, // (optional) default bound not required for Self.\n-                                    // Currently, only Sized makes sense here.\n+              Option<TraitRef>, // (optional) default bound not required for Self.\n+                                // Currently, only Sized makes sense here.\n               TyParamBounds,\n               Vec<TraitItem>),\n     ItemImpl(Generics,"}, {"sha": "d65be4c45e8f3a849c74cb5fcb412546d478d620", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -770,7 +770,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                 for b in bounds.iter() {\n                     match *b {\n                         TraitTyParamBound(ref t) => {\n-                            self.insert(t.ref_id, NodeItem(i));\n+                            self.insert(t.trait_ref.ref_id, NodeItem(i));\n                         }\n                         _ => {}\n                     }"}, {"sha": "862cbf3d7ca06f3506bf0f33602e8e3055f24048", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -68,10 +68,11 @@ pub trait AstBuilder {\n                span: Span,\n                id: ast::Ident,\n                bounds: OwnedSlice<ast::TyParamBound>,\n-               unbound: Option<ast::TyParamBound>,\n+               unbound: Option<ast::TraitRef>,\n                default: Option<P<ast::Ty>>) -> ast::TyParam;\n \n     fn trait_ref(&self, path: ast::Path) -> ast::TraitRef;\n+    fn poly_trait_ref(&self, path: ast::Path) -> ast::PolyTraitRef;\n     fn typarambound(&self, path: ast::Path) -> ast::TyParamBound;\n     fn lifetime(&self, span: Span, ident: ast::Name) -> ast::Lifetime;\n     fn lifetime_def(&self,\n@@ -417,7 +418,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                span: Span,\n                id: ast::Ident,\n                bounds: OwnedSlice<ast::TyParamBound>,\n-               unbound: Option<ast::TyParamBound>,\n+               unbound: Option<ast::TraitRef>,\n                default: Option<P<ast::Ty>>) -> ast::TyParam {\n         ast::TyParam {\n             ident: id,\n@@ -445,12 +446,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         ast::TraitRef {\n             path: path,\n             ref_id: ast::DUMMY_NODE_ID,\n-            lifetimes: Vec::new(),\n+        }\n+    }\n+\n+    fn poly_trait_ref(&self, path: ast::Path) -> ast::PolyTraitRef {\n+        ast::PolyTraitRef {\n+            bound_lifetimes: Vec::new(),\n+            trait_ref: self.trait_ref(path)\n         }\n     }\n \n     fn typarambound(&self, path: ast::Path) -> ast::TyParamBound {\n-        ast::TraitTyParamBound(self.trait_ref(path))\n+        ast::TraitTyParamBound(self.poly_trait_ref(path))\n     }\n \n     fn lifetime(&self, span: Span, name: ast::Name) -> ast::Lifetime {"}, {"sha": "1ec1e3b1224c4d3d7cad2637d7445bb9adf8a160", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -194,7 +194,7 @@ impl<'a> Ty<'a> {\n \n \n fn mk_ty_param(cx: &ExtCtxt, span: Span, name: &str,\n-               bounds: &[Path], unbound: Option<ast::TyParamBound>,\n+               bounds: &[Path], unbound: Option<ast::TraitRef>,\n                self_ident: Ident, self_generics: &Generics) -> ast::TyParam {\n     let bounds =\n         bounds.iter().map(|b| {\n@@ -220,7 +220,7 @@ fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>)\n #[deriving(Clone)]\n pub struct LifetimeBounds<'a> {\n     pub lifetimes: Vec<(&'a str, Vec<&'a str>)>,\n-    pub bounds: Vec<(&'a str, Option<ast::TyParamBound>, Vec<Path<'a>>)>,\n+    pub bounds: Vec<(&'a str, Option<ast::TraitRef>, Vec<Path<'a>>)>,\n }\n \n impl<'a> LifetimeBounds<'a> {"}, {"sha": "85d4e157b7b84f46fca51bc8e4ef026bccd9c042", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -227,6 +227,10 @@ pub trait Folder {\n         noop_fold_trait_ref(p, self)\n     }\n \n+    fn fold_poly_trait_ref(&mut self, p: PolyTraitRef) -> PolyTraitRef {\n+        noop_fold_poly_trait_ref(p, self)\n+    }\n+\n     fn fold_struct_def(&mut self, struct_def: P<StructDef>) -> P<StructDef> {\n         noop_fold_struct_def(struct_def, self)\n     }\n@@ -442,7 +446,10 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n             TyFixedLengthVec(ty, e) => {\n                 TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n             }\n-            TyTypeof(expr) => TyTypeof(fld.fold_expr(expr))\n+            TyTypeof(expr) => TyTypeof(fld.fold_expr(expr)),\n+            TyPolyTraitRef(poly_trait_ref) => {\n+                TyPolyTraitRef(poly_trait_ref.map(|p| fld.fold_poly_trait_ref(p)))\n+            },\n         },\n         span: fld.new_span(span)\n     })\n@@ -711,7 +718,7 @@ pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T)\n                                    -> TyParamBound\n                                    where T: Folder {\n     match tpb {\n-        TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_trait_ref(ty)),\n+        TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_poly_trait_ref(ty)),\n         RegionTyParamBound(lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n     }\n }\n@@ -722,7 +729,7 @@ pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n         id: fld.new_id(id),\n         ident: ident,\n         bounds: fld.fold_bounds(bounds),\n-        unbound: unbound.map(|x| fld.fold_ty_param_bound(x)),\n+        unbound: unbound.map(|x| fld.fold_trait_ref(x)),\n         default: default.map(|x| fld.fold_ty(x)),\n         span: span\n     }\n@@ -842,13 +849,18 @@ pub fn noop_fold_trait_ref<T: Folder>(p: TraitRef, fld: &mut T) -> TraitRef {\n     let id = fld.new_id(p.ref_id);\n     let TraitRef {\n         path,\n-        lifetimes,\n-        ..\n+        ref_id: _,\n     } = p;\n     ast::TraitRef {\n         path: fld.fold_path(path),\n         ref_id: id,\n-        lifetimes: fld.fold_lifetime_defs(lifetimes),\n+    }\n+}\n+\n+pub fn noop_fold_poly_trait_ref<T: Folder>(p: PolyTraitRef, fld: &mut T) -> PolyTraitRef {\n+    ast::PolyTraitRef {\n+        bound_lifetimes: fld.fold_lifetime_defs(p.bound_lifetimes),\n+        trait_ref: fld.fold_trait_ref(p.trait_ref)\n     }\n }\n "}, {"sha": "6873c015fd51c43c657cc7d8743c0464e66baa37", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 174, "deletions": 136, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -42,6 +42,7 @@ use ast::{Method, MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, UnNot};\n use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n+use ast::{PolyTraitRef};\n use ast::{QPath, RequiredMethod};\n use ast::{RetStyle, Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n@@ -53,7 +54,7 @@ use ast::{TtDelimited, TtSequence, TtToken};\n use ast::{TupleVariantKind, Ty, Ty_, TyBot};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n-use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPtr, TyQPath};\n+use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n use ast::{TyRptr, TyTup, TyU32, TyUniq, TyVec, UnUniq};\n use ast::{TypeImplItem, TypeTraitItem, Typedef, UnboxedClosureKind};\n use ast::{UnnamedField, UnsafeBlock};\n@@ -968,30 +969,14 @@ impl<'a> Parser<'a> {\n     /// Is the current token one of the keywords that signals a bare function\n     /// type?\n     pub fn token_is_bare_fn_keyword(&mut self) -> bool {\n-        if self.token.is_keyword(keywords::Fn) {\n-            return true\n-        }\n-\n-        if self.token.is_keyword(keywords::Unsafe) ||\n-            self.token.is_keyword(keywords::Once) {\n-            return self.look_ahead(1, |t| t.is_keyword(keywords::Fn))\n-        }\n-\n-        false\n+        self.token.is_keyword(keywords::Fn) ||\n+            self.token.is_keyword(keywords::Unsafe) ||\n+            self.token.is_keyword(keywords::Extern)\n     }\n \n     /// Is the current token one of the keywords that signals a closure type?\n     pub fn token_is_closure_keyword(&mut self) -> bool {\n-        self.token.is_keyword(keywords::Unsafe) ||\n-            self.token.is_keyword(keywords::Once)\n-    }\n-\n-    /// Is the current token one of the keywords that signals an old-style\n-    /// closure type (with explicit sigil)?\n-    pub fn token_is_old_style_closure_keyword(&mut self) -> bool {\n-        self.token.is_keyword(keywords::Unsafe) ||\n-            self.token.is_keyword(keywords::Once) ||\n-            self.token.is_keyword(keywords::Fn)\n+        self.token.is_keyword(keywords::Unsafe)\n     }\n \n     pub fn get_lifetime(&mut self) -> ast::Ident {\n@@ -1001,8 +986,57 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    pub fn parse_for_in_type(&mut self) -> Ty_ {\n+        /*\n+        Parses whatever can come after a `for` keyword in a type.\n+        The `for` has already been consumed.\n+\n+        Deprecated:\n+\n+        - for <'lt> |S| -> T\n+        - for <'lt> proc(S) -> T\n+\n+        Eventually:\n+\n+        - for <'lt> [unsafe] [extern \"ABI\"] fn (S) -> T\n+        - for <'lt> path::foo(a, b)\n+\n+        */\n+\n+        // parse <'lt>\n+        let lifetime_defs = self.parse_late_bound_lifetime_defs();\n+\n+        // examine next token to decide to do\n+        if self.eat_keyword(keywords::Proc) {\n+            self.parse_proc_type(lifetime_defs)\n+        } else if self.token_is_bare_fn_keyword() || self.token_is_closure_keyword() {\n+            self.parse_ty_bare_fn_or_ty_closure(lifetime_defs)\n+        } else if self.token == token::ModSep ||\n+                  self.token.is_ident() ||\n+                  self.token.is_path() {\n+            let trait_ref = self.parse_trait_ref();\n+            TyPolyTraitRef(P(PolyTraitRef { bound_lifetimes: lifetime_defs,\n+                                            trait_ref: trait_ref }))\n+        } else {\n+            self.parse_ty_closure(lifetime_defs)\n+        }\n+    }\n+\n+    pub fn parse_ty_path(&mut self, plus_allowed: bool) -> Ty_ {\n+        let mode = if plus_allowed {\n+            LifetimeAndTypesAndBounds\n+        } else {\n+            LifetimeAndTypesWithoutColons\n+        };\n+        let PathAndBounds {\n+            path,\n+            bounds\n+        } = self.parse_path(mode);\n+        TyPath(path, bounds, ast::DUMMY_NODE_ID)\n+    }\n+\n     /// parse a TyBareFn type:\n-    pub fn parse_ty_bare_fn(&mut self) -> Ty_ {\n+    pub fn parse_ty_bare_fn(&mut self, lifetime_defs: Vec<ast::LifetimeDef>) -> Ty_ {\n         /*\n \n         [unsafe] [extern \"ABI\"] fn <'lt> (S) -> T\n@@ -1023,18 +1057,26 @@ impl<'a> Parser<'a> {\n         };\n \n         self.expect_keyword(keywords::Fn);\n-        let (decl, lifetimes) = self.parse_ty_fn_decl(true);\n+        let lifetime_defs = self.parse_legacy_lifetime_defs(lifetime_defs);\n+        let (inputs, variadic) = self.parse_fn_args(false, true);\n+        let (ret_style, ret_ty) = self.parse_ret_ty();\n+        let decl = P(FnDecl {\n+            inputs: inputs,\n+            output: ret_ty,\n+            cf: ret_style,\n+            variadic: variadic\n+        });\n         TyBareFn(P(BareFnTy {\n             abi: abi,\n             fn_style: fn_style,\n-            lifetimes: lifetimes,\n+            lifetimes: lifetime_defs,\n             decl: decl\n         }))\n     }\n \n     /// Parses a procedure type (`proc`). The initial `proc` keyword must\n     /// already have been parsed.\n-    pub fn parse_proc_type(&mut self) -> Ty_ {\n+    pub fn parse_proc_type(&mut self, lifetime_defs: Vec<ast::LifetimeDef>) -> Ty_ {\n         /*\n \n         proc <'lt> (S) [:Bounds] -> T\n@@ -1043,19 +1085,12 @@ impl<'a> Parser<'a> {\n          |     |    |      |      Return type\n          |     |    |    Bounds\n          |     |  Argument types\n-         |   Lifetimes\n+         |   Legacy lifetimes\n         the `proc` keyword\n \n         */\n \n-        let lifetime_defs = if self.eat(&token::Lt) {\n-            let lifetime_defs = self.parse_lifetime_defs();\n-            self.expect_gt();\n-            lifetime_defs\n-        } else {\n-            Vec::new()\n-        };\n-\n+        let lifetime_defs = self.parse_legacy_lifetime_defs(lifetime_defs);\n         let (inputs, variadic) = self.parse_fn_args(false, false);\n         let bounds = self.parse_colon_then_ty_param_bounds();\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n@@ -1100,33 +1135,49 @@ impl<'a> Parser<'a> {\n         return None\n     }\n \n+    pub fn parse_ty_bare_fn_or_ty_closure(&mut self, lifetime_defs: Vec<LifetimeDef>) -> Ty_ {\n+        // Both bare fns and closures can begin with stuff like unsafe\n+        // and extern. So we just scan ahead a few tokens to see if we see\n+        // a `fn`.\n+        //\n+        // Closure:  [unsafe] <'lt> |S| [:Bounds] -> T\n+        // Fn:       [unsafe] [extern \"ABI\"] fn <'lt> (S) -> T\n+\n+        if self.token.is_keyword(keywords::Fn) {\n+            self.parse_ty_bare_fn(lifetime_defs)\n+        } else if self.token.is_keyword(keywords::Extern) {\n+            self.parse_ty_bare_fn(lifetime_defs)\n+        } else if self.token.is_keyword(keywords::Unsafe) {\n+            if self.look_ahead(1, |t| t.is_keyword(keywords::Fn) ||\n+                                      t.is_keyword(keywords::Extern)) {\n+                self.parse_ty_bare_fn(lifetime_defs)\n+            } else {\n+                self.parse_ty_closure(lifetime_defs)\n+            }\n+        } else {\n+            self.parse_ty_closure(lifetime_defs)\n+        }\n+    }\n+\n     /// Parse a TyClosure type\n-    pub fn parse_ty_closure(&mut self) -> Ty_ {\n+    pub fn parse_ty_closure(&mut self, lifetime_defs: Vec<ast::LifetimeDef>) -> Ty_ {\n         /*\n \n-        [unsafe] [once] <'lt> |S| [:Bounds] -> T\n-        ^~~~~~~^ ^~~~~^ ^~~~^  ^  ^~~~~~~~^    ^\n-          |        |      |    |      |        |\n-          |        |      |    |      |      Return type\n-          |        |      |    |  Closure bounds\n-          |        |      |  Argument types\n-          |        |    Lifetime defs\n-          |     Once-ness (a.k.a., affine)\n+        [unsafe] <'lt> |S| [:Bounds] -> T\n+        ^~~~~~~^ ^~~~^  ^  ^~~~~~~~^    ^\n+          |        |       |      |        |\n+          |        |       |      |      Return type\n+          |        |       |  Closure bounds\n+          |        |     Argument types\n+          |      Deprecated lifetime defs\n+          |\n         Function Style\n \n         */\n \n         let fn_style = self.parse_unsafety();\n-        let onceness = if self.eat_keyword(keywords::Once) {Once} else {Many};\n \n-        let lifetime_defs = if self.eat(&token::Lt) {\n-            let lifetime_defs = self.parse_lifetime_defs();\n-            self.expect_gt();\n-\n-            lifetime_defs\n-        } else {\n-            Vec::new()\n-        };\n+        let lifetime_defs = self.parse_legacy_lifetime_defs(lifetime_defs);\n \n         let inputs = if self.eat(&token::OrOr) {\n             Vec::new()\n@@ -1152,7 +1203,7 @@ impl<'a> Parser<'a> {\n \n         TyClosure(P(ClosureTy {\n             fn_style: fn_style,\n-            onceness: onceness,\n+            onceness: Many,\n             bounds: bounds,\n             decl: decl,\n             lifetimes: lifetime_defs,\n@@ -1167,36 +1218,23 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse a function type (following the 'fn')\n-    pub fn parse_ty_fn_decl(&mut self, allow_variadic: bool)\n-                            -> (P<FnDecl>, Vec<ast::LifetimeDef>) {\n-        /*\n-\n-        (fn) <'lt> (S) -> T\n-             ^~~~^ ^~^    ^\n-               |    |     |\n-               |    |   Return type\n-               |  Argument types\n-           Lifetime_defs\n-\n-        */\n-        let lifetime_defs = if self.eat(&token::Lt) {\n-            let lifetime_defs = self.parse_lifetime_defs();\n-            self.expect_gt();\n-            lifetime_defs\n+    /// Parses `[ 'for' '<' lifetime_defs '>' ]'\n+    fn parse_legacy_lifetime_defs(&mut self,\n+                                  lifetime_defs: Vec<ast::LifetimeDef>)\n+                                  -> Vec<ast::LifetimeDef>\n+    {\n+        if self.eat(&token::Lt) {\n+            if lifetime_defs.is_empty() {\n+                self.warn(\"deprecated syntax, use `for` keyword now\");\n+                let lifetime_defs = self.parse_lifetime_defs();\n+                self.expect_gt();\n+                lifetime_defs\n+            } else {\n+                self.fatal(\"cannot use new `for` keyword and older syntax together\");\n+            }\n         } else {\n-            Vec::new()\n-        };\n-\n-        let (inputs, variadic) = self.parse_fn_args(false, allow_variadic);\n-        let (ret_style, ret_ty) = self.parse_ret_ty();\n-        let decl = P(FnDecl {\n-            inputs: inputs,\n-            output: ret_ty,\n-            cf: ret_style,\n-            variadic: variadic\n-        });\n-        (decl, lifetime_defs)\n+            lifetime_defs\n+        }\n     }\n \n     /// Parses `type Foo;` in a trait declaration only. The `type` keyword has\n@@ -1433,25 +1471,24 @@ impl<'a> Parser<'a> {\n             self.expect(&token::CloseDelim(token::Bracket));\n             t\n         } else if self.token == token::BinOp(token::And) ||\n-                self.token == token::AndAnd {\n+                  self.token == token::AndAnd {\n             // BORROWED POINTER\n             self.expect_and();\n             self.parse_borrowed_pointee()\n-        } else if self.token.is_keyword(keywords::Extern) ||\n-                  self.token.is_keyword(keywords::Unsafe) ||\n-                self.token_is_bare_fn_keyword() {\n-            // BARE FUNCTION\n-            self.parse_ty_bare_fn()\n-        } else if self.token_is_closure_keyword() ||\n-                self.token == token::BinOp(token::Or) ||\n-                self.token == token::OrOr ||\n-                (self.token == token::Lt &&\n-                 self.look_ahead(1, |t| {\n-                     *t == token::Gt || t.is_lifetime()\n-                 })) {\n+        } else if self.token.is_keyword(keywords::For) {\n+            self.parse_for_in_type()\n+        } else if self.token_is_bare_fn_keyword() ||\n+                  self.token_is_closure_keyword() {\n+            // BARE FUNCTION OR CLOSURE\n+            self.parse_ty_bare_fn_or_ty_closure(Vec::new())\n+        } else if self.token == token::BinOp(token::Or) ||\n+                  self.token == token::OrOr ||\n+                  (self.token == token::Lt &&\n+                   self.look_ahead(1, |t| {\n+                       *t == token::Gt || t.is_lifetime()\n+                   })) {\n             // CLOSURE\n-\n-            self.parse_ty_closure()\n+            self.parse_ty_closure(Vec::new())\n         } else if self.eat_keyword(keywords::Typeof) {\n             // TYPEOF\n             // In order to not be ambiguous, the type must be surrounded by parens.\n@@ -1460,7 +1497,7 @@ impl<'a> Parser<'a> {\n             self.expect(&token::CloseDelim(token::Paren));\n             TyTypeof(e)\n         } else if self.eat_keyword(keywords::Proc) {\n-            self.parse_proc_type()\n+            self.parse_proc_type(Vec::new())\n         } else if self.token == token::Lt {\n             // QUALIFIED PATH\n             self.bump();\n@@ -1479,16 +1516,7 @@ impl<'a> Parser<'a> {\n                   self.token.is_ident() ||\n                   self.token.is_path() {\n             // NAMED TYPE\n-            let mode = if plus_allowed {\n-                LifetimeAndTypesAndBounds\n-            } else {\n-                LifetimeAndTypesWithoutColons\n-            };\n-            let PathAndBounds {\n-                path,\n-                bounds\n-            } = self.parse_path(mode);\n-            TyPath(path, bounds, ast::DUMMY_NODE_ID)\n+            self.parse_ty_path(plus_allowed)\n         } else if self.eat(&token::Underscore) {\n             // TYPE TO BE INFERRED\n             TyInfer\n@@ -3848,29 +3876,17 @@ impl<'a> Parser<'a> {\n     }\n \n     // matches bounds    = ( boundseq )?\n-    // where   boundseq  = ( bound + boundseq ) | bound\n-    // and     bound     = 'region | ty\n+    // where   boundseq  = ( polybound + boundseq ) | polybound\n+    // and     polybound = ( 'for' '<' 'region '>' )? bound\n+    // and     bound     = 'region | trait_ref\n     // NB: The None/Some distinction is important for issue #7264.\n     fn parse_ty_param_bounds(&mut self)\n                              -> OwnedSlice<TyParamBound>\n     {\n         let mut result = vec!();\n         loop {\n-            let lifetime_defs = if self.eat(&token::Lt) {\n-                let lifetime_defs = self.parse_lifetime_defs();\n-                self.expect_gt();\n-                lifetime_defs\n-            } else {\n-                Vec::new()\n-            };\n             match self.token {\n                 token::Lifetime(lifetime) => {\n-                    if lifetime_defs.len() > 0 {\n-                        let span = self.last_span;\n-                        self.span_err(span, \"lifetime declarations are not \\\n-                                             allowed here\")\n-                    }\n-\n                     result.push(RegionTyParamBound(ast::Lifetime {\n                         id: ast::DUMMY_NODE_ID,\n                         span: self.span,\n@@ -3879,13 +3895,8 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                 }\n                 token::ModSep | token::Ident(..) => {\n-                    let path =\n-                        self.parse_path(LifetimeAndTypesWithoutColons).path;\n-                    result.push(TraitTyParamBound(ast::TraitRef {\n-                        path: path,\n-                        ref_id: ast::DUMMY_NODE_ID,\n-                        lifetimes: lifetime_defs,\n-                    }))\n+                    let poly_trait_ref = self.parse_poly_trait_ref();\n+                    result.push(TraitTyParamBound(poly_trait_ref))\n                 }\n                 _ => break,\n             }\n@@ -3898,7 +3909,7 @@ impl<'a> Parser<'a> {\n         return OwnedSlice::from_vec(result);\n     }\n \n-    fn trait_ref_from_ident(ident: Ident, span: Span) -> ast::TraitRef {\n+    fn trait_ref_from_ident(ident: Ident, span: Span) -> TraitRef {\n         let segment = ast::PathSegment {\n             identifier: ident,\n             parameters: ast::PathParameters::none()\n@@ -3911,7 +3922,6 @@ impl<'a> Parser<'a> {\n         ast::TraitRef {\n             path: path,\n             ref_id: ast::DUMMY_NODE_ID,\n-            lifetimes: Vec::new(),\n         }\n     }\n \n@@ -3927,7 +3937,7 @@ impl<'a> Parser<'a> {\n         let mut unbound = None;\n         if self.eat(&token::Question) {\n             let tref = Parser::trait_ref_from_ident(ident, span);\n-            unbound = Some(TraitTyParamBound(tref));\n+            unbound = Some(tref);\n             span = self.span;\n             ident = self.parse_ident();\n         }\n@@ -4538,7 +4548,6 @@ impl<'a> Parser<'a> {\n                     Some(TraitRef {\n                         path: (*path).clone(),\n                         ref_id: node_id,\n-                        lifetimes: Vec::new(),\n                     })\n                 }\n                 TyPath(_, Some(_), _) => {\n@@ -4568,6 +4577,35 @@ impl<'a> Parser<'a> {\n          Some(attrs))\n     }\n \n+    /// Parse a::B<String,int>\n+    fn parse_trait_ref(&mut self) -> TraitRef {\n+        ast::TraitRef {\n+            path: self.parse_path(LifetimeAndTypesWithoutColons).path,\n+            ref_id: ast::DUMMY_NODE_ID,\n+        }\n+    }\n+\n+    fn parse_late_bound_lifetime_defs(&mut self) -> Vec<ast::LifetimeDef> {\n+        if self.eat_keyword(keywords::For) {\n+            self.expect(&token::Lt);\n+            let lifetime_defs = self.parse_lifetime_defs();\n+            self.expect_gt();\n+            lifetime_defs\n+        } else {\n+            Vec::new()\n+        }\n+    }\n+\n+    /// Parse for<'l> a::B<String,int>\n+    fn parse_poly_trait_ref(&mut self) -> PolyTraitRef {\n+        let lifetime_defs = self.parse_late_bound_lifetime_defs();\n+\n+        ast::PolyTraitRef {\n+            bound_lifetimes: lifetime_defs,\n+            trait_ref: self.parse_trait_ref()\n+        }\n+    }\n+\n     /// Parse struct Foo { ... }\n     fn parse_item_struct(&mut self) -> ItemInfo {\n         let class_name = self.parse_ident();\n@@ -4681,7 +4719,7 @@ impl<'a> Parser<'a> {\n         else { Inherited }\n     }\n \n-    fn parse_for_sized(&mut self) -> Option<ast::TyParamBound> {\n+    fn parse_for_sized(&mut self) -> Option<ast::TraitRef> {\n         if self.eat_keyword(keywords::For) {\n             let span = self.span;\n             let ident = self.parse_ident();\n@@ -4691,7 +4729,7 @@ impl<'a> Parser<'a> {\n                 return None;\n             }\n             let tref = Parser::trait_ref_from_ident(ident, span);\n-            Some(TraitTyParamBound(tref))\n+            Some(tref)\n         } else {\n             None\n         }"}, {"sha": "5b57a875c4afb2d36dcf8d07fa6c2d72964958c5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -743,6 +743,9 @@ impl<'a> State<'a> {\n             ast::TyPath(ref path, ref bounds, _) => {\n                 try!(self.print_bounded_path(path, bounds));\n             }\n+            ast::TyPolyTraitRef(ref poly_trait_ref) => {\n+                try!(self.print_poly_trait_ref(&**poly_trait_ref));\n+            }\n             ast::TyQPath(ref qpath) => {\n                 try!(word(&mut self.s, \"<\"));\n                 try!(self.print_type(&*qpath.for_type));\n@@ -960,7 +963,7 @@ impl<'a> State<'a> {\n                 try!(self.print_ident(item.ident));\n                 try!(self.print_generics(generics));\n                 match unbound {\n-                    &Some(TraitTyParamBound(ref tref)) => {\n+                    &Some(ref tref) => {\n                         try!(space(&mut self.s));\n                         try!(self.word_space(\"for\"));\n                         try!(self.print_trait_ref(tref));\n@@ -995,19 +998,21 @@ impl<'a> State<'a> {\n     }\n \n     fn print_trait_ref(&mut self, t: &ast::TraitRef) -> IoResult<()> {\n-        if t.lifetimes.len() > 0 {\n-            try!(self.print_generics(&ast::Generics {\n-                lifetimes: t.lifetimes.clone(),\n-                ty_params: OwnedSlice::empty(),\n-                where_clause: ast::WhereClause {\n-                    id: ast::DUMMY_NODE_ID,\n-                    predicates: Vec::new(),\n-                },\n-            }));\n-        }\n         self.print_path(&t.path, false)\n     }\n \n+    fn print_poly_trait_ref(&mut self, t: &ast::PolyTraitRef) -> IoResult<()> {\n+        if !t.bound_lifetimes.is_empty() {\n+            try!(word(&mut self.s, \"for<\"));\n+            for lifetime_def in t.bound_lifetimes.iter() {\n+                try!(self.print_lifetime_def(lifetime_def));\n+            }\n+            try!(word(&mut self.s, \">\"));\n+        }\n+\n+        self.print_trait_ref(&t.trait_ref)\n+    }\n+\n     pub fn print_enum_def(&mut self, enum_definition: &ast::EnumDef,\n                           generics: &ast::Generics, ident: ast::Ident,\n                           span: codemap::Span,\n@@ -2383,7 +2388,7 @@ impl<'a> State<'a> {\n \n                 try!(match *bound {\n                     TraitTyParamBound(ref tref) => {\n-                        self.print_trait_ref(tref)\n+                        self.print_poly_trait_ref(tref)\n                     }\n                     RegionTyParamBound(ref lt) => {\n                         self.print_lifetime(lt)\n@@ -2450,7 +2455,7 @@ impl<'a> State<'a> {\n \n     pub fn print_ty_param(&mut self, param: &ast::TyParam) -> IoResult<()> {\n         match param.unbound {\n-            Some(TraitTyParamBound(ref tref)) => {\n+            Some(ref tref) => {\n                 try!(self.print_trait_ref(tref));\n                 try!(self.word_space(\"?\"));\n             }"}, {"sha": "1b1d1e9cace1a8b8746ca95e324ab47413d78f1d", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -75,6 +75,10 @@ pub trait Visitor<'v> {\n     }\n     fn visit_ty_method(&mut self, t: &'v TypeMethod) { walk_ty_method(self, t) }\n     fn visit_trait_item(&mut self, t: &'v TraitItem) { walk_trait_item(self, t) }\n+    fn visit_trait_ref(&mut self, t: &'v TraitRef) { walk_trait_ref(self, t) }\n+    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef) {\n+        walk_poly_trait_ref(self, t)\n+    }\n     fn visit_struct_def(&mut self, s: &'v StructDef, _: Ident, _: &'v Generics, _: NodeId) {\n         walk_struct_def(self, s)\n     }\n@@ -202,9 +206,20 @@ pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n \n /// Like with walk_method_helper this doesn't correspond to a method\n /// in Visitor, and so it gets a _helper suffix.\n-pub fn walk_trait_ref_helper<'v,V>(visitor: &mut V, trait_ref: &'v TraitRef)\n-                                   where V: Visitor<'v> {\n-    walk_lifetime_decls(visitor, &trait_ref.lifetimes);\n+pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n+                                         trait_ref: &'v PolyTraitRef)\n+    where V: Visitor<'v>\n+{\n+    walk_lifetime_decls(visitor, &trait_ref.bound_lifetimes);\n+    visitor.visit_trait_ref(&trait_ref.trait_ref);\n+}\n+\n+/// Like with walk_method_helper this doesn't correspond to a method\n+/// in Visitor, and so it gets a _helper suffix.\n+pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n+                                   trait_ref: &'v TraitRef)\n+    where V: Visitor<'v>\n+{\n     visitor.visit_path(&trait_ref.path, trait_ref.ref_id)\n }\n \n@@ -248,8 +263,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                  ref impl_items) => {\n             visitor.visit_generics(type_parameters);\n             match *trait_reference {\n-                Some(ref trait_reference) => walk_trait_ref_helper(visitor,\n-                                                                   trait_reference),\n+                Some(ref trait_reference) => visitor.visit_trait_ref(trait_reference),\n                 None => ()\n             }\n             visitor.visit_ty(&**typ);\n@@ -383,6 +397,9 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_ty(&**ty);\n             visitor.visit_expr(&**expression)\n         }\n+        TyPolyTraitRef(ref poly_trait_ref) => {\n+            visitor.visit_poly_trait_ref(&**poly_trait_ref)\n+        }\n         TyTypeof(ref expression) => {\n             visitor.visit_expr(&**expression)\n         }\n@@ -497,7 +514,7 @@ pub fn walk_ty_param_bounds<'v, V: Visitor<'v>>(visitor: &mut V,\n     for bound in bounds.iter() {\n         match *bound {\n             TraitTyParamBound(ref typ) => {\n-                walk_trait_ref_helper(visitor, typ)\n+                visitor.visit_poly_trait_ref(typ)\n             }\n             RegionTyParamBound(ref lifetime) => {\n                 visitor.visit_lifetime_ref(lifetime);"}, {"sha": "924132c6de26bff8023a066ecc71ff66e77813df", "filename": "src/test/compile-fail/issue-10291.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn test<'x>(x: &'x int) {\n-    drop::< <'z>|&'z int| -> &'z int >(|z| {\n+    drop::< for<'z>|&'z int| -> &'z int >(|z| {\n         x\n         //~^ ERROR cannot infer an appropriate lifetime\n     });"}, {"sha": "ac56e8ce14df6ad99820434ef6d7de7af9862d90", "filename": "src/test/compile-fail/regions-fn-subtyping-return-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -22,11 +22,11 @@\n struct S;\n \n // Given 'cx, return 'cx\n-type F = fn<'cx>(&'cx S) -> &'cx S;\n+type F = for<'cx> fn(&'cx S) -> &'cx S;\n fn want_F(f: F) { }\n \n // Given anything, return 'static\n-type G = fn<'cx>(&'cx S) -> &'static S;\n+type G = for<'cx> fn(&'cx S) -> &'static S;\n fn want_G(f: G) { }\n \n // Should meet both."}, {"sha": "91a6ff789ea39fb9ca31fba3b84b238711b82b7f", "filename": "src/test/compile-fail/regions-fn-subtyping.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -17,29 +17,29 @@ fn test_fn<'x,'y,'z,T>(_x: &'x T, _y: &'y T, _z: &'z T) {\n     // subtype::<T1>(of::<T2>()) will typecheck\n     // iff T1 <: T2.\n \n-    subtype::< <'a>|&'a T|>(\n-        of::< <'a>|&'a T|>());\n+    subtype::< for<'a>|&'a T|>(\n+        of::< for<'a>|&'a T|>());\n \n-    subtype::< <'a>|&'a T|>(\n-        of::< <'b>|&'b T|>());\n+    subtype::< for<'a>|&'a T|>(\n+        of::< for<'b>|&'b T|>());\n \n-    subtype::< <'b>|&'b T|>(\n+    subtype::< for<'b>|&'b T|>(\n         of::<|&'x T|>());\n \n     subtype::<|&'x T|>(\n-        of::< <'b>|&'b T|>());  //~ ERROR mismatched types\n+        of::< for<'b>|&'b T|>());  //~ ERROR mismatched types\n \n-    subtype::< <'a,'b>|&'a T, &'b T|>(\n-        of::< <'a>|&'a T, &'a T|>());\n+    subtype::< for<'a,'b>|&'a T, &'b T|>(\n+        of::< for<'a>|&'a T, &'a T|>());\n \n-    subtype::< <'a>|&'a T, &'a T|>(\n-        of::< <'a,'b>|&'a T, &'b T|>()); //~ ERROR mismatched types\n+    subtype::< for<'a>|&'a T, &'a T|>(\n+        of::< for<'a,'b>|&'a T, &'b T|>()); //~ ERROR mismatched types\n \n-    subtype::< <'a,'b>|&'a T, &'b T|>(\n+    subtype::< for<'a,'b>|&'a T, &'b T|>(\n         of::<|&'x T, &'y T|>());\n \n     subtype::<|&'x T, &'y T|>(\n-        of::< <'a,'b>|&'a T, &'b T|>()); //~ ERROR mismatched types\n+        of::< for<'a,'b>|&'a T, &'b T|>()); //~ ERROR mismatched types\n }\n \n fn main() {}"}, {"sha": "e9e585e84d0ef89c4b63b29c5cfd3827f79c020e", "filename": "src/test/compile-fail/regions-name-undeclared.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Fcompile-fail%2Fregions-name-undeclared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Fcompile-fail%2Fregions-name-undeclared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-name-undeclared.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -43,16 +43,16 @@ fn bar<'a>(x: &'a int) {\n \n     // &'a CAN be declared on functions and used then:\n     fn g<'a>(a: &'a int) { } // OK\n-    fn h(a: <'a>|&'a int|) { } // OK\n+    fn h(a: for<'a>|&'a int|) { } // OK\n }\n \n // Test nesting of lifetimes in fn type declarations\n fn fn_types(a: &'a int, //~ ERROR undeclared lifetime\n-            b: <'a>|a: &'a int,\n-                    b: &'b int, //~ ERROR undeclared lifetime\n-                    c: <'b>|a: &'a int,\n-                            b: &'b int|,\n-                    d: &'b int|, //~ ERROR undeclared lifetime\n+            b: for<'a>|a: &'a int,\n+                       b: &'b int, //~ ERROR undeclared lifetime\n+                       c: for<'b>|a: &'a int,\n+                                  b: &'b int|,\n+                       d: &'b int|, //~ ERROR undeclared lifetime\n             c: &'a int) //~ ERROR undeclared lifetime\n {\n }"}, {"sha": "a08cf2263894dfc5396a63164f119f48588b16a8", "filename": "src/test/compile-fail/regions-nested-fns-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn ignore(_f: <'z>|&'z int| -> &'z int) {}\n+fn ignore(_f: for<'z>|&'z int| -> &'z int) {}\n \n fn nested() {\n     let y = 3;"}, {"sha": "cf0b615bb01abbd6dd7e5b82f14207f00da98026", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -14,13 +14,13 @@ fn nested<'x>(x: &'x int) {\n     let y = 3;\n     let mut ay = &y; //~ ERROR cannot infer\n \n-    ignore::< <'z>|&'z int|>(|z| {\n+    ignore::< for<'z>|&'z int|>(|z| {\n         ay = x;\n         ay = &y;\n         ay = z;\n     });\n \n-    ignore::< <'z>|&'z int| -> &'z int>(|z| {\n+    ignore::< for<'z>|&'z int| -> &'z int>(|z| {\n         if false { return x; }  //~ ERROR cannot infer an appropriate lifetime for automatic\n         if false { return ay; }\n         return z;"}, {"sha": "997775efa84b52d60756dfc3ed3c62652f37dbbb", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -12,7 +12,7 @@\n // some point regions-ret-borrowed reported an error but this file did\n // not, due to special hardcoding around the anonymous region.\n \n-fn with<R>(f: <'a>|x: &'a int| -> R) -> R {\n+fn with<R>(f: for<'a>|x: &'a int| -> R) -> R {\n     f(&3)\n }\n "}, {"sha": "080523f0060a7a3eed88fe8834a5eb1f4a2a67ac", "filename": "src/test/run-pass/hrtb-parse.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Frun-pass%2Fhrtb-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Frun-pass%2Fhrtb-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-parse.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can parse all the various places that a `for` keyword\n+// can appear representing universal quantification.\n+\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+\n+trait Get<A,R> {\n+    fn get(&self, arg: A) -> R;\n+}\n+\n+// Parse HRTB with explicit `for` in a where-clause:\n+\n+fn foo00<T>(t: T)\n+    where T : for<'a> Get<&'a int, &'a int>\n+{\n+}\n+\n+fn foo01<T: for<'a> Get<&'a int, &'a int>>(t: T)\n+{\n+}\n+\n+// Parse HRTB with explicit `for` in various sorts of types:\n+\n+fn foo10(t: Box<for<'a> Get<int, int>>) { }\n+fn foo11(t: Box<for<'a> Get(int) -> int>) { }\n+\n+fn foo20(t: for<'a> fn(int) -> int) { }\n+fn foo21(t: for<'a> unsafe fn(int) -> int) { }\n+fn foo22(t: for<'a> extern \"C\" fn(int) -> int) { }\n+fn foo23(t: for<'a> unsafe extern \"C\" fn(int) -> int) { }\n+\n+fn foo30(t: for<'a> |int| -> int) { }\n+fn foo31(t: for<'a> unsafe |int| -> int) { }\n+\n+//fn foo40(t: for<'a> proc(int) -> int) { }\n+\n+fn main() {\n+}"}, {"sha": "32432c07dcf415fd84f59f228c9cfa5210939c55", "filename": "src/test/run-pass/nullable-pointer-ffi-compat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Frun-pass%2Fnullable-pointer-ffi-compat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244231720d29db856c5a28c0dda6c2efd7c9219a/src%2Ftest%2Frun-pass%2Fnullable-pointer-ffi-compat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-ffi-compat.rs?ref=244231720d29db856c5a28c0dda6c2efd7c9219a", "patch": "@@ -29,7 +29,7 @@ static FOO: int = 0xDEADBEE;\n \n pub fn main() {\n     unsafe {\n-        let f: extern \"C\" fn<'a>(&'a int) -> &'a int = mem::transmute(foo);\n+        let f: for<'a> extern \"C\" fn(&'a int) -> &'a int = mem::transmute(foo);\n         assert_eq!(*f(&FOO), FOO);\n     }\n }"}]}