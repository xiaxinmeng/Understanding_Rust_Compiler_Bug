{"sha": "1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MzJkN2E1MmQ4Y2RmZGFkYmYxNjVmMjM0MGRlNDVlOWU5ZWY5ZTI=", "commit": {"author": {"name": "Hirokazu Hata", "email": "h.hata.ai.t@gmail.com", "date": "2019-02-23T07:40:07Z"}, "committer": {"name": "Hirokazu Hata", "email": "h.hata.ai.t@gmail.com", "date": "2019-02-23T07:40:07Z"}, "message": "Transition librustdoc to 2018 edition", "tree": {"sha": "ddb5d481975e0b49148e76faa7738f9c591d0228", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddb5d481975e0b49148e76faa7738f9c591d0228"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "html_url": "https://github.com/rust-lang/rust/commit/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/comments", "author": {"login": "h-michael", "id": 4556097, "node_id": "MDQ6VXNlcjQ1NTYwOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4556097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/h-michael", "html_url": "https://github.com/h-michael", "followers_url": "https://api.github.com/users/h-michael/followers", "following_url": "https://api.github.com/users/h-michael/following{/other_user}", "gists_url": "https://api.github.com/users/h-michael/gists{/gist_id}", "starred_url": "https://api.github.com/users/h-michael/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/h-michael/subscriptions", "organizations_url": "https://api.github.com/users/h-michael/orgs", "repos_url": "https://api.github.com/users/h-michael/repos", "events_url": "https://api.github.com/users/h-michael/events{/privacy}", "received_events_url": "https://api.github.com/users/h-michael/received_events", "type": "User", "site_admin": false}, "committer": {"login": "h-michael", "id": 4556097, "node_id": "MDQ6VXNlcjQ1NTYwOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4556097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/h-michael", "html_url": "https://github.com/h-michael", "followers_url": "https://api.github.com/users/h-michael/followers", "following_url": "https://api.github.com/users/h-michael/following{/other_user}", "gists_url": "https://api.github.com/users/h-michael/gists{/gist_id}", "starred_url": "https://api.github.com/users/h-michael/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/h-michael/subscriptions", "organizations_url": "https://api.github.com/users/h-michael/orgs", "repos_url": "https://api.github.com/users/h-michael/repos", "events_url": "https://api.github.com/users/h-michael/events{/privacy}", "received_events_url": "https://api.github.com/users/h-michael/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "082c86175fcf72c355e6a889956fbea59e65bcdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/082c86175fcf72c355e6a889956fbea59e65bcdb", "html_url": "https://github.com/rust-lang/rust/commit/082c86175fcf72c355e6a889956fbea59e65bcdb"}], "stats": {"total": 842, "additions": 419, "deletions": 423}, "files": [{"sha": "bdd18e88840da352b7f00d6a3115c272304284ce", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustdoc\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"rustdoc\""}, {"sha": "661aef664823d2c0e33c5d1b150479b46bfc4966", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -220,7 +220,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         }\n     }\n \n-    fn get_lifetime(&self, region: Region, names_map: &FxHashMap<String, Lifetime>) -> Lifetime {\n+    fn get_lifetime(&self, region: Region<'_>, names_map: &FxHashMap<String, Lifetime>) -> Lifetime {\n         self.region_name(region)\n             .map(|name| {\n                 names_map.get(&name).unwrap_or_else(|| {\n@@ -231,7 +231,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n             .clone()\n     }\n \n-    fn region_name(&self, region: Region) -> Option<String> {\n+    fn region_name(&self, region: Region<'_>) -> Option<String> {\n         match region {\n             &ty::ReEarlyBound(r) => Some(r.name.to_string()),\n             _ => None,\n@@ -259,7 +259,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         // we need to create the Generics.\n         let mut finished: FxHashMap<_, Vec<_>> = Default::default();\n \n-        let mut vid_map: FxHashMap<RegionTarget, RegionDeps> = Default::default();\n+        let mut vid_map: FxHashMap<RegionTarget<'_>, RegionDeps<'_>> = Default::default();\n \n         // Flattening is done in two parts. First, we insert all of the constraints\n         // into a map. Each RegionTarget (either a RegionVid or a Region) maps\n@@ -842,7 +842,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         vec.sort_by_cached_key(|x| format!(\"{:?}\", x))\n     }\n \n-    fn is_fn_ty(&self, tcx: &TyCtxt, ty: &Type) -> bool {\n+    fn is_fn_ty(&self, tcx: &TyCtxt<'_, '_, '_>, ty: &Type) -> bool {\n         match &ty {\n             &&Type::ResolvedPath { ref did, .. } => {\n                 *did == tcx.require_lang_item(lang_items::FnTraitLangItem)"}, {"sha": "55abcb4a93bd3e4b44af89c603c4bc2cc64da999", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -5,7 +5,7 @@ use rustc::ty::subst::Subst;\n use rustc::infer::InferOk;\n use syntax_pos::DUMMY_SP;\n \n-use core::DocAccessLevels;\n+use crate::core::DocAccessLevels;\n \n use super::*;\n "}, {"sha": "6a0b6003600148af363f3e1aa02a54f73a347033", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -14,7 +14,7 @@ use syntax::feature_gate::Features;\n \n use syntax_pos::Span;\n \n-use html::escape::Escape;\n+use crate::html::escape::Escape;\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, Hash)]\n pub enum Cfg {\n@@ -261,7 +261,7 @@ impl ops::BitOr for Cfg {\n struct Html<'a>(&'a Cfg, bool);\n \n fn write_with_opt_paren<T: fmt::Display>(\n-    fmt: &mut fmt::Formatter,\n+    fmt: &mut fmt::Formatter<'_>,\n     has_paren: bool,\n     obj: T,\n ) -> fmt::Result {\n@@ -277,7 +277,7 @@ fn write_with_opt_paren<T: fmt::Display>(\n \n \n impl<'a> fmt::Display for Html<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self.0 {\n             Cfg::Not(ref child) => match **child {\n                 Cfg::Any(ref sub_cfgs) => {"}, {"sha": "fce86d590159b56bc07db985805aa835b740149a", "filename": "src/librustdoc/clean/def_ctor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -1,8 +1,8 @@\n-use core::DocContext;\n+use crate::core::DocContext;\n \n use super::*;\n \n-pub fn get_def_from_def_id<F>(cx: &DocContext,\n+pub fn get_def_from_def_id<F>(cx: &DocContext<'_, '_, '_>,\n                               def_id: DefId,\n                               callback: &F,\n ) -> Vec<Item>\n@@ -38,7 +38,7 @@ where F: Fn(& dyn Fn(DefId) -> Def) -> Vec<Item> {\n     }\n }\n \n-pub fn get_def_from_node_id<F>(cx: &DocContext,\n+pub fn get_def_from_node_id<F>(cx: &DocContext<'_, '_, '_>,\n                                id: ast::NodeId,\n                                name: String,\n                                callback: &F,"}, {"sha": "136b28f36aee55e5ae8092516a1f6e639bbce91a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -13,9 +13,9 @@ use rustc_metadata::cstore::LoadedMacro;\n use rustc::ty;\n use rustc::util::nodemap::FxHashSet;\n \n-use core::{DocContext, DocAccessLevels};\n-use doctree;\n-use clean::{\n+use crate::core::{DocContext, DocAccessLevels};\n+use crate::doctree;\n+use crate::clean::{\n     self,\n     GetDefId,\n     ToSource,\n@@ -35,7 +35,7 @@ use super::Clean;\n ///\n /// The returned value is `None` if the definition could not be inlined,\n /// and `Some` of a vector of items if it was successfully expanded.\n-pub fn try_inline(cx: &DocContext, def: Def, name: ast::Name, visited: &mut FxHashSet<DefId>)\n+pub fn try_inline(cx: &DocContext<'_, '_, '_>, def: Def, name: ast::Name, visited: &mut FxHashSet<DefId>)\n                   -> Option<Vec<clean::Item>> {\n     let did = if let Some(did) = def.opt_def_id() {\n         did\n@@ -124,7 +124,7 @@ pub fn try_inline(cx: &DocContext, def: Def, name: ast::Name, visited: &mut FxHa\n     Some(ret)\n }\n \n-pub fn try_inline_glob(cx: &DocContext, def: Def, visited: &mut FxHashSet<DefId>)\n+pub fn try_inline_glob(cx: &DocContext<'_, '_, '_>, def: Def, visited: &mut FxHashSet<DefId>)\n     -> Option<Vec<clean::Item>>\n {\n     if def == Def::Err { return None }\n@@ -141,15 +141,15 @@ pub fn try_inline_glob(cx: &DocContext, def: Def, visited: &mut FxHashSet<DefId>\n     }\n }\n \n-pub fn load_attrs(cx: &DocContext, did: DefId) -> clean::Attributes {\n+pub fn load_attrs(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Attributes {\n     cx.tcx.get_attrs(did).clean(cx)\n }\n \n /// Record an external fully qualified name in the external_paths cache.\n ///\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n-pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n+pub fn record_extern_fqn(cx: &DocContext<'_, '_, '_>, did: DefId, kind: clean::TypeKind) {\n     let mut crate_name = cx.tcx.crate_name(did.krate).to_string();\n     if did.is_local() {\n         crate_name = cx.crate_name.clone().unwrap_or(crate_name);\n@@ -177,7 +177,7 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n     }\n }\n \n-pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n+pub fn build_external_trait(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Trait {\n     let auto_trait = cx.tcx.trait_def(did).has_auto_impl;\n     let trait_items = cx.tcx.associated_items(did).map(|item| item.clean(cx)).collect();\n     let predicates = cx.tcx.predicates_of(did);\n@@ -197,7 +197,7 @@ pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n     }\n }\n \n-fn build_external_function(cx: &DocContext, did: DefId) -> clean::Function {\n+fn build_external_function(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Function {\n     let sig = cx.tcx.fn_sig(did);\n \n     let constness = if cx.tcx.is_min_const_fn(did) {\n@@ -219,7 +219,7 @@ fn build_external_function(cx: &DocContext, did: DefId) -> clean::Function {\n     }\n }\n \n-fn build_enum(cx: &DocContext, did: DefId) -> clean::Enum {\n+fn build_enum(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Enum {\n     let predicates = cx.tcx.predicates_of(did);\n \n     clean::Enum {\n@@ -229,7 +229,7 @@ fn build_enum(cx: &DocContext, did: DefId) -> clean::Enum {\n     }\n }\n \n-fn build_struct(cx: &DocContext, did: DefId) -> clean::Struct {\n+fn build_struct(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Struct {\n     let predicates = cx.tcx.predicates_of(did);\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n@@ -245,7 +245,7 @@ fn build_struct(cx: &DocContext, did: DefId) -> clean::Struct {\n     }\n }\n \n-fn build_union(cx: &DocContext, did: DefId) -> clean::Union {\n+fn build_union(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Union {\n     let predicates = cx.tcx.predicates_of(did);\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n@@ -257,7 +257,7 @@ fn build_union(cx: &DocContext, did: DefId) -> clean::Union {\n     }\n }\n \n-fn build_type_alias(cx: &DocContext, did: DefId) -> clean::Typedef {\n+fn build_type_alias(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Typedef {\n     let predicates = cx.tcx.predicates_of(did);\n \n     clean::Typedef {\n@@ -266,7 +266,7 @@ fn build_type_alias(cx: &DocContext, did: DefId) -> clean::Typedef {\n     }\n }\n \n-pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n+pub fn build_impls(cx: &DocContext<'_, '_, '_>, did: DefId) -> Vec<clean::Item> {\n     let tcx = cx.tcx;\n     let mut impls = Vec::new();\n \n@@ -277,7 +277,7 @@ pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n     impls\n }\n \n-pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n+pub fn build_impl(cx: &DocContext<'_, '_, '_>, did: DefId, ret: &mut Vec<clean::Item>) {\n     if !cx.renderinfo.borrow_mut().inlined.insert(did) {\n         return\n     }\n@@ -387,15 +387,15 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n     });\n }\n \n-fn build_module(cx: &DocContext, did: DefId, visited: &mut FxHashSet<DefId>) -> clean::Module {\n+fn build_module(cx: &DocContext<'_, '_, '_>, did: DefId, visited: &mut FxHashSet<DefId>) -> clean::Module {\n     let mut items = Vec::new();\n     fill_in(cx, did, &mut items, visited);\n     return clean::Module {\n         items,\n         is_crate: false,\n     };\n \n-    fn fill_in(cx: &DocContext, did: DefId, items: &mut Vec<clean::Item>,\n+    fn fill_in(cx: &DocContext<'_, '_, '_>, did: DefId, items: &mut Vec<clean::Item>,\n                visited: &mut FxHashSet<DefId>) {\n         // If we're re-exporting a re-export it may actually re-export something in\n         // two namespaces, so the target may be listed twice. Make sure we only\n@@ -412,30 +412,30 @@ fn build_module(cx: &DocContext, did: DefId, visited: &mut FxHashSet<DefId>) ->\n     }\n }\n \n-pub fn print_inlined_const(cx: &DocContext, did: DefId) -> String {\n+pub fn print_inlined_const(cx: &DocContext<'_, '_, '_>, did: DefId) -> String {\n     if let Some(node_id) = cx.tcx.hir().as_local_node_id(did) {\n         cx.tcx.hir().node_to_pretty_string(node_id)\n     } else {\n         cx.tcx.rendered_const(did)\n     }\n }\n \n-fn build_const(cx: &DocContext, did: DefId) -> clean::Constant {\n+fn build_const(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Constant {\n     clean::Constant {\n         type_: cx.tcx.type_of(did).clean(cx),\n         expr: print_inlined_const(cx, did)\n     }\n }\n \n-fn build_static(cx: &DocContext, did: DefId, mutable: bool) -> clean::Static {\n+fn build_static(cx: &DocContext<'_, '_, '_>, did: DefId, mutable: bool) -> clean::Static {\n     clean::Static {\n         type_: cx.tcx.type_of(did).clean(cx),\n         mutability: if mutable {clean::Mutable} else {clean::Immutable},\n         expr: \"\\n\\n\\n\".to_string(), // trigger the \"[definition]\" links\n     }\n }\n \n-fn build_macro(cx: &DocContext, did: DefId, name: ast::Name) -> clean::ItemEnum {\n+fn build_macro(cx: &DocContext<'_, '_, '_>, did: DefId, name: ast::Name) -> clean::ItemEnum {\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n     match cx.cstore.load_macro_untracked(did, cx.sess()) {\n         LoadedMacro::MacroDef(def) => {\n@@ -537,7 +537,7 @@ fn separate_supertrait_bounds(mut g: clean::Generics)\n     (g, ty_bounds)\n }\n \n-pub fn record_extern_trait(cx: &DocContext, did: DefId) {\n+pub fn record_extern_trait(cx: &DocContext<'_, '_, '_>, did: DefId) {\n     if did.is_local() {\n         return;\n     }"}, {"sha": "626c2802e8390ff4ecbde8940bb9d68e6233f21d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 122, "deletions": 120, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -48,11 +48,12 @@ use std::u32;\n \n use parking_lot::ReentrantMutex;\n \n-use core::{self, DocContext};\n-use doctree;\n-use visit_ast;\n-use html::render::{cache, ExternalLocation};\n-use html::item_type::ItemType;\n+use crate::core::{self, DocContext};\n+use crate::doctree;\n+use crate::visit_ast;\n+use crate::html::render::{cache, ExternalLocation};\n+use crate::html::item_type::ItemType;\n+\n \n use self::cfg::Cfg;\n use self::auto_trait::AutoTraitFinder;\n@@ -70,56 +71,56 @@ thread_local!(pub static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> = Defau\n const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n // extract the stability index for a node from tcx, if possible\n-fn get_stability(cx: &DocContext, def_id: DefId) -> Option<Stability> {\n+fn get_stability(cx: &DocContext<'_, '_, '_>, def_id: DefId) -> Option<Stability> {\n     cx.tcx.lookup_stability(def_id).clean(cx)\n }\n \n-fn get_deprecation(cx: &DocContext, def_id: DefId) -> Option<Deprecation> {\n+fn get_deprecation(cx: &DocContext<'_, '_, '_>, def_id: DefId) -> Option<Deprecation> {\n     cx.tcx.lookup_deprecation(def_id).clean(cx)\n }\n \n pub trait Clean<T> {\n-    fn clean(&self, cx: &DocContext) -> T;\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> T;\n }\n \n impl<T: Clean<U>, U> Clean<Vec<U>> for [T] {\n-    fn clean(&self, cx: &DocContext) -> Vec<U> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n impl<T: Clean<U>, U, V: Idx> Clean<IndexVec<V, U>> for IndexVec<V, T> {\n-    fn clean(&self, cx: &DocContext) -> IndexVec<V, U> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> IndexVec<V, U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n impl<T: Clean<U>, U> Clean<U> for P<T> {\n-    fn clean(&self, cx: &DocContext) -> U {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> U {\n         (**self).clean(cx)\n     }\n }\n \n impl<T: Clean<U>, U> Clean<U> for Rc<T> {\n-    fn clean(&self, cx: &DocContext) -> U {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> U {\n         (**self).clean(cx)\n     }\n }\n \n impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n-    fn clean(&self, cx: &DocContext) -> Option<U> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<U> {\n         self.as_ref().map(|v| v.clean(cx))\n     }\n }\n \n impl<T, U> Clean<U> for ty::Binder<T> where T: Clean<U> {\n-    fn clean(&self, cx: &DocContext) -> U {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> U {\n         self.skip_binder().clean(cx)\n     }\n }\n \n impl<T: Clean<U>, U> Clean<Vec<U>> for P<[T]> {\n-    fn clean(&self, cx: &DocContext) -> Vec<U> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n@@ -139,8 +140,8 @@ pub struct Crate {\n }\n \n impl<'a, 'tcx, 'rcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx, 'rcx> {\n-    fn clean(&self, cx: &DocContext) -> Crate {\n-        use ::visit_lib::LibEmbargoVisitor;\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Crate {\n+        use crate::visit_lib::LibEmbargoVisitor;\n \n         {\n             let mut r = cx.renderinfo.borrow_mut();\n@@ -233,7 +234,7 @@ pub struct ExternalCrate {\n }\n \n impl Clean<ExternalCrate> for CrateNum {\n-    fn clean(&self, cx: &DocContext) -> ExternalCrate {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> ExternalCrate {\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n         let krate_span = cx.tcx.def_span(root);\n         let krate_src = cx.sess().source_map().span_to_filename(krate_span);\n@@ -365,7 +366,7 @@ pub struct Item {\n }\n \n impl fmt::Debug for Item {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n \n         let fake = MAX_DEF_ID.with(|m| m.borrow().get(&self.def_id.krate)\n                                    .map(|id| self.def_id >= *id).unwrap_or(false));\n@@ -581,7 +582,7 @@ pub struct Module {\n }\n \n impl Clean<Item> for doctree::Module {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let name = if self.name.is_some() {\n             self.name.expect(\"No name provided\").clean(cx)\n         } else {\n@@ -949,7 +950,8 @@ impl Attributes {\n     ///\n     /// Cache must be populated before call\n     pub fn links(&self, krate: &CrateNum) -> Vec<(String, String)> {\n-        use html::format::href;\n+        use crate::html::format::href;\n+\n         self.links.iter().filter_map(|&(ref s, did, ref fragment)| {\n             match did {\n                 Some(did) => {\n@@ -1019,7 +1021,7 @@ impl AttributesExt for Attributes {\n }\n \n impl Clean<Attributes> for [ast::Attribute] {\n-    fn clean(&self, cx: &DocContext) -> Attributes {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Attributes {\n         Attributes::from_ast(cx.sess().diagnostic(), self)\n     }\n }\n@@ -1031,7 +1033,7 @@ pub enum GenericBound {\n }\n \n impl GenericBound {\n-    fn maybe_sized(cx: &DocContext) -> GenericBound {\n+    fn maybe_sized(cx: &DocContext<'_, '_, '_>) -> GenericBound {\n         let did = cx.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n         let empty = cx.tcx.intern_substs(&[]);\n         let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n@@ -1048,7 +1050,7 @@ impl GenericBound {\n         }, hir::TraitBoundModifier::Maybe)\n     }\n \n-    fn is_sized_bound(&self, cx: &DocContext) -> bool {\n+    fn is_sized_bound(&self, cx: &DocContext<'_, '_, '_>) -> bool {\n         use rustc::hir::TraitBoundModifier as TBM;\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n             if trait_.def_id() == cx.tcx.lang_items().sized_trait() {\n@@ -1074,7 +1076,7 @@ impl GenericBound {\n }\n \n impl Clean<GenericBound> for hir::GenericBound {\n-    fn clean(&self, cx: &DocContext) -> GenericBound {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericBound {\n         match *self {\n             hir::GenericBound::Outlives(lt) => GenericBound::Outlives(lt.clean(cx)),\n             hir::GenericBound::Trait(ref t, modifier) => {\n@@ -1084,8 +1086,8 @@ impl Clean<GenericBound> for hir::GenericBound {\n     }\n }\n \n-fn external_generic_args(cx: &DocContext, trait_did: Option<DefId>, has_self: bool,\n-                        bindings: Vec<TypeBinding>, substs: &Substs) -> GenericArgs {\n+fn external_generic_args(cx: &DocContext<'_, '_, '_>, trait_did: Option<DefId>, has_self: bool,\n+                        bindings: Vec<TypeBinding>, substs: &Substs<'_>) -> GenericArgs {\n     let lifetimes = substs.regions().filter_map(|v| v.clean(cx)).collect();\n     let types = substs.types().skip(has_self as usize).collect::<Vec<_>>();\n \n@@ -1126,8 +1128,8 @@ fn external_generic_args(cx: &DocContext, trait_did: Option<DefId>, has_self: bo\n \n // trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n // from Fn<(A, B,), C> to Fn(A, B) -> C\n-fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>, has_self: bool,\n-                 bindings: Vec<TypeBinding>, substs: &Substs) -> Path {\n+fn external_path(cx: &DocContext<'_, '_, '_>, name: &str, trait_did: Option<DefId>, has_self: bool,\n+                 bindings: Vec<TypeBinding>, substs: &Substs<'_>) -> Path {\n     Path {\n         global: false,\n         def: Def::Err,\n@@ -1139,7 +1141,7 @@ fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>, has_self\n }\n \n impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>) {\n-    fn clean(&self, cx: &DocContext) -> GenericBound {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericBound {\n         let (trait_ref, ref bounds) = *self;\n         inline::record_extern_fqn(cx, trait_ref.def_id, TypeKind::Trait);\n         let path = external_path(cx, &cx.tcx.item_name(trait_ref.def_id).as_str(),\n@@ -1183,13 +1185,13 @@ impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>\n }\n \n impl<'tcx> Clean<GenericBound> for ty::TraitRef<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> GenericBound {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericBound {\n         (self, vec![]).clean(cx)\n     }\n }\n \n impl<'tcx> Clean<Option<Vec<GenericBound>>> for Substs<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Option<Vec<GenericBound>> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<Vec<GenericBound>> {\n         let mut v = Vec::new();\n         v.extend(self.regions().filter_map(|r| r.clean(cx)).map(GenericBound::Outlives));\n         v.extend(self.types().map(|t| GenericBound::TraitBound(PolyTrait {\n@@ -1216,7 +1218,7 @@ impl Lifetime {\n }\n \n impl Clean<Lifetime> for hir::Lifetime {\n-    fn clean(&self, cx: &DocContext) -> Lifetime {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Lifetime {\n         if self.id != ast::DUMMY_NODE_ID {\n             let def = cx.tcx.named_region(self.hir_id);\n             match def {\n@@ -1235,7 +1237,7 @@ impl Clean<Lifetime> for hir::Lifetime {\n }\n \n impl Clean<Lifetime> for hir::GenericParam {\n-    fn clean(&self, _: &DocContext) -> Lifetime {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> Lifetime {\n         match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n                 if self.bounds.len() > 0 {\n@@ -1259,7 +1261,7 @@ impl Clean<Lifetime> for hir::GenericParam {\n }\n \n impl Clean<Constant> for hir::ConstArg {\n-    fn clean(&self, cx: &DocContext) -> Constant {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Constant {\n         Constant {\n             type_: cx.tcx.type_of(cx.tcx.hir().body_owner_def_id(self.value.body)).clean(cx),\n             expr: print_const_expr(cx, self.value.body),\n@@ -1268,13 +1270,13 @@ impl Clean<Constant> for hir::ConstArg {\n }\n \n impl<'tcx> Clean<Lifetime> for ty::GenericParamDef {\n-    fn clean(&self, _cx: &DocContext) -> Lifetime {\n+    fn clean(&self, _cx: &DocContext<'_, '_, '_>) -> Lifetime {\n         Lifetime(self.name.to_string())\n     }\n }\n \n impl Clean<Option<Lifetime>> for ty::RegionKind {\n-    fn clean(&self, cx: &DocContext) -> Option<Lifetime> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n             ty::ReLateBound(_, ty::BrNamed(_, name)) => Some(Lifetime(name.to_string())),\n@@ -1303,7 +1305,7 @@ pub enum WherePredicate {\n }\n \n impl Clean<WherePredicate> for hir::WherePredicate {\n-    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> WherePredicate {\n         match *self {\n             hir::WherePredicate::BoundPredicate(ref wbp) => {\n                 WherePredicate::BoundPredicate {\n@@ -1330,7 +1332,7 @@ impl Clean<WherePredicate> for hir::WherePredicate {\n }\n \n impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n-    fn clean(&self, cx: &DocContext) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<WherePredicate> {\n         use rustc::ty::Predicate;\n \n         match *self {\n@@ -1349,7 +1351,7 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n }\n \n impl<'a> Clean<WherePredicate> for ty::TraitPredicate<'a> {\n-    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> WherePredicate {\n         WherePredicate::BoundPredicate {\n             ty: self.trait_ref.self_ty().clean(cx),\n             bounds: vec![self.trait_ref.clean(cx)]\n@@ -1358,7 +1360,7 @@ impl<'a> Clean<WherePredicate> for ty::TraitPredicate<'a> {\n }\n \n impl<'tcx> Clean<WherePredicate> for ty::SubtypePredicate<'tcx> {\n-    fn clean(&self, _cx: &DocContext) -> WherePredicate {\n+    fn clean(&self, _cx: &DocContext<'_, '_, '_>) -> WherePredicate {\n         panic!(\"subtype predicates are an internal rustc artifact \\\n                 and should not be seen by rustdoc\")\n     }\n@@ -1367,7 +1369,7 @@ impl<'tcx> Clean<WherePredicate> for ty::SubtypePredicate<'tcx> {\n impl<'tcx> Clean<Option<WherePredicate>> for\n     ty::OutlivesPredicate<ty::Region<'tcx>,ty::Region<'tcx>> {\n \n-    fn clean(&self, cx: &DocContext) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n \n         match (a, b) {\n@@ -1385,7 +1387,7 @@ impl<'tcx> Clean<Option<WherePredicate>> for\n }\n \n impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>> {\n-    fn clean(&self, cx: &DocContext) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(ref ty, ref lt) = *self;\n \n         match lt {\n@@ -1401,7 +1403,7 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n }\n \n impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> WherePredicate {\n         WherePredicate::EqPredicate {\n             lhs: self.projection_ty.clean(cx),\n             rhs: self.ty.clean(cx)\n@@ -1410,7 +1412,7 @@ impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n }\n \n impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Type {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Type {\n         let trait_ = match self.trait_ref(cx.tcx).clean(cx) {\n             GenericBound::TraitBound(t, _) => t.trait_,\n             GenericBound::Outlives(_) => panic!(\"cleaning a trait got a lifetime\"),\n@@ -1458,7 +1460,7 @@ impl GenericParamDef {\n }\n \n impl<'tcx> Clean<GenericParamDef> for ty::GenericParamDef {\n-    fn clean(&self, cx: &DocContext) -> GenericParamDef {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             ty::GenericParamDefKind::Lifetime => {\n                 (self.name.to_string(), GenericParamDefKind::Lifetime)\n@@ -1488,7 +1490,7 @@ impl<'tcx> Clean<GenericParamDef> for ty::GenericParamDef {\n }\n \n impl Clean<GenericParamDef> for hir::GenericParam {\n-    fn clean(&self, cx: &DocContext) -> GenericParamDef {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n                 let name = if self.bounds.len() > 0 {\n@@ -1538,7 +1540,7 @@ pub struct Generics {\n }\n \n impl Clean<Generics> for hir::Generics {\n-    fn clean(&self, cx: &DocContext) -> Generics {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Generics {\n         // Synthetic type-parameters are inserted after normal ones.\n         // In order for normal parameters to be able to refer to synthetic ones,\n         // scans them first.\n@@ -1608,7 +1610,7 @@ impl Clean<Generics> for hir::Generics {\n \n impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n                                     &'a Lrc<ty::GenericPredicates<'tcx>>) {\n-    fn clean(&self, cx: &DocContext) -> Generics {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Generics {\n         use self::WherePredicate as WP;\n \n         let (gens, preds) = *self;\n@@ -1689,7 +1691,7 @@ pub struct Method {\n }\n \n impl<'a> Clean<Method> for (&'a hir::MethodSig, &'a hir::Generics, hir::BodyId) {\n-    fn clean(&self, cx: &DocContext) -> Method {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Method {\n         let (generics, decl) = enter_impl_trait(cx, || {\n             (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx))\n         });\n@@ -1716,7 +1718,7 @@ pub struct Function {\n }\n \n impl Clean<Item> for doctree::Function {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let (generics, decl) = enter_impl_trait(cx, || {\n             (self.generics.clean(cx), (&self.decl, self.body).clean(cx))\n         });\n@@ -1788,7 +1790,7 @@ pub struct Arguments {\n }\n \n impl<'a> Clean<Arguments> for (&'a [hir::Ty], &'a [ast::Ident]) {\n-    fn clean(&self, cx: &DocContext) -> Arguments {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Arguments {\n         Arguments {\n             values: self.0.iter().enumerate().map(|(i, ty)| {\n                 let mut name = self.1.get(i).map(|ident| ident.to_string())\n@@ -1806,7 +1808,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], &'a [ast::Ident]) {\n }\n \n impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n-    fn clean(&self, cx: &DocContext) -> Arguments {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Arguments {\n         let body = cx.tcx.hir().body(self.1);\n \n         Arguments {\n@@ -1823,7 +1825,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n     where (&'a [hir::Ty], A): Clean<Arguments>\n {\n-    fn clean(&self, cx: &DocContext) -> FnDecl {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> FnDecl {\n         FnDecl {\n             inputs: (&self.0.inputs[..], self.1).clean(cx),\n             output: self.0.output.clean(cx),\n@@ -1834,7 +1836,7 @@ impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n }\n \n impl<'a, 'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n-    fn clean(&self, cx: &DocContext) -> FnDecl {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> FnDecl {\n         let (did, sig) = *self;\n         let mut names = if cx.tcx.hir().as_local_node_id(did).is_some() {\n             vec![].into_iter()\n@@ -1895,7 +1897,7 @@ pub enum FunctionRetTy {\n }\n \n impl Clean<FunctionRetTy> for hir::FunctionRetTy {\n-    fn clean(&self, cx: &DocContext) -> FunctionRetTy {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> FunctionRetTy {\n         match *self {\n             hir::Return(ref typ) => Return(typ.clean(cx)),\n             hir::DefaultReturn(..) => DefaultReturn,\n@@ -1924,7 +1926,7 @@ pub struct Trait {\n }\n \n impl Clean<Item> for doctree::Trait {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n         let is_spotlight = attrs.has_doc_flag(\"spotlight\");\n         Item {\n@@ -1955,7 +1957,7 @@ pub struct TraitAlias {\n }\n \n impl Clean<Item> for doctree::TraitAlias {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -1974,7 +1976,7 @@ impl Clean<Item> for doctree::TraitAlias {\n }\n \n impl Clean<bool> for hir::IsAuto {\n-    fn clean(&self, _: &DocContext) -> bool {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> bool {\n         match *self {\n             hir::IsAuto::Yes => true,\n             hir::IsAuto::No => false,\n@@ -1983,13 +1985,13 @@ impl Clean<bool> for hir::IsAuto {\n }\n \n impl Clean<Type> for hir::TraitRef {\n-    fn clean(&self, cx: &DocContext) -> Type {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Type {\n         resolve_type(cx, self.path.clean(cx), self.ref_id)\n     }\n }\n \n impl Clean<PolyTrait> for hir::PolyTraitRef {\n-    fn clean(&self, cx: &DocContext) -> PolyTrait {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> PolyTrait {\n         PolyTrait {\n             trait_: self.trait_ref.clean(cx),\n             generic_params: self.bound_generic_params.clean(cx)\n@@ -1998,7 +2000,7 @@ impl Clean<PolyTrait> for hir::PolyTraitRef {\n }\n \n impl Clean<Item> for hir::TraitItem {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let inner = match self.node {\n             hir::TraitItemKind::Const(ref ty, default) => {\n                 AssociatedConstItem(ty.clean(cx),\n@@ -2035,7 +2037,7 @@ impl Clean<Item> for hir::TraitItem {\n }\n \n impl Clean<Item> for hir::ImplItem {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let inner = match self.node {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n                 AssociatedConstItem(ty.clean(cx),\n@@ -2067,7 +2069,7 @@ impl Clean<Item> for hir::ImplItem {\n }\n \n impl<'tcx> Clean<Item> for ty::AssociatedItem {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let inner = match self.kind {\n             ty::AssociatedKind::Const => {\n                 let ty = cx.tcx.type_of(self.def_id);\n@@ -2385,7 +2387,7 @@ impl GetDefId for Type {\n     fn def_id(&self) -> Option<DefId> {\n         match *self {\n             ResolvedPath { did, .. } => Some(did),\n-            Primitive(p) => ::html::render::cache().primitive_locations.get(&p).cloned(),\n+            Primitive(p) => crate::html::render::cache().primitive_locations.get(&p).cloned(),\n             BorrowedRef { type_: box Generic(..), .. } =>\n                 Primitive(PrimitiveType::Reference).def_id(),\n             BorrowedRef { ref type_, .. } => type_.def_id(),\n@@ -2509,7 +2511,7 @@ impl From<ast::FloatTy> for PrimitiveType {\n }\n \n impl Clean<Type> for hir::Ty {\n-    fn clean(&self, cx: &DocContext) -> Type {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Type {\n         use rustc::hir::*;\n \n         match self.node {\n@@ -2708,7 +2710,7 @@ impl Clean<Type> for hir::Ty {\n }\n \n impl<'tcx> Clean<Type> for Ty<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Type {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Type {\n         match self.sty {\n             ty::Never => Never,\n             ty::Bool => Primitive(PrimitiveType::Bool),\n@@ -2903,7 +2905,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n }\n \n impl Clean<Item> for hir::StructField {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.ident.name).clean(cx),\n             attrs: self.attrs.clean(cx),\n@@ -2918,7 +2920,7 @@ impl Clean<Item> for hir::StructField {\n }\n \n impl<'tcx> Clean<Item> for ty::FieldDef {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.ident.name).clean(cx),\n             attrs: cx.tcx.get_attrs(self.did).clean(cx),\n@@ -2941,7 +2943,7 @@ pub enum Visibility {\n }\n \n impl Clean<Option<Visibility>> for hir::Visibility {\n-    fn clean(&self, cx: &DocContext) -> Option<Visibility> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<Visibility> {\n         Some(match self.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Inherited => Visibility::Inherited,\n@@ -2956,7 +2958,7 @@ impl Clean<Option<Visibility>> for hir::Visibility {\n }\n \n impl Clean<Option<Visibility>> for ty::Visibility {\n-    fn clean(&self, _: &DocContext) -> Option<Visibility> {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> Option<Visibility> {\n         Some(if *self == ty::Visibility::Public { Public } else { Inherited })\n     }\n }\n@@ -2978,7 +2980,7 @@ pub struct Union {\n }\n \n impl Clean<Item> for doctree::Struct {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -2998,7 +3000,7 @@ impl Clean<Item> for doctree::Struct {\n }\n \n impl Clean<Item> for doctree::Union {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3028,7 +3030,7 @@ pub struct VariantStruct {\n }\n \n impl Clean<VariantStruct> for ::rustc::hir::VariantData {\n-    fn clean(&self, cx: &DocContext) -> VariantStruct {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> VariantStruct {\n         VariantStruct {\n             struct_type: doctree::struct_type_from_def(self),\n             fields: self.fields().iter().map(|x| x.clean(cx)).collect(),\n@@ -3045,7 +3047,7 @@ pub struct Enum {\n }\n \n impl Clean<Item> for doctree::Enum {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3069,7 +3071,7 @@ pub struct Variant {\n }\n \n impl Clean<Item> for doctree::Variant {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3086,7 +3088,7 @@ impl Clean<Item> for doctree::Variant {\n }\n \n impl<'tcx> Clean<Item> for ty::VariantDef {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let kind = match self.ctor_kind {\n             CtorKind::Const => VariantKind::CLike,\n             CtorKind::Fn => {\n@@ -3134,7 +3136,7 @@ pub enum VariantKind {\n }\n \n impl Clean<VariantKind> for hir::VariantData {\n-    fn clean(&self, cx: &DocContext) -> VariantKind {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> VariantKind {\n         if self.is_struct() {\n             VariantKind::Struct(self.clean(cx))\n         } else if self.is_unit() {\n@@ -3165,7 +3167,7 @@ impl Span {\n }\n \n impl Clean<Span> for syntax_pos::Span {\n-    fn clean(&self, cx: &DocContext) -> Span {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Span {\n         if self.is_dummy() {\n             return Span::empty();\n         }\n@@ -3198,7 +3200,7 @@ impl Path {\n }\n \n impl Clean<Path> for hir::Path {\n-    fn clean(&self, cx: &DocContext) -> Path {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Path {\n         Path {\n             global: self.is_global(),\n             def: self.def,\n@@ -3221,7 +3223,7 @@ pub enum GenericArgs {\n }\n \n impl Clean<GenericArgs> for hir::GenericArgs {\n-    fn clean(&self, cx: &DocContext) -> GenericArgs {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericArgs {\n         if self.parenthesized {\n             let output = self.bindings[0].ty.clean(cx);\n             GenericArgs::Parenthesized {\n@@ -3263,7 +3265,7 @@ pub struct PathSegment {\n }\n \n impl Clean<PathSegment> for hir::PathSegment {\n-    fn clean(&self, cx: &DocContext) -> PathSegment {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> PathSegment {\n         PathSegment {\n             name: self.ident.name.clean(cx),\n             args: self.with_generic_args(|generic_args| generic_args.clean(cx))\n@@ -3335,21 +3337,21 @@ fn qpath_to_string(p: &hir::QPath) -> String {\n \n impl Clean<String> for Ident {\n     #[inline]\n-    fn clean(&self, cx: &DocContext) -> String {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> String {\n         self.name.clean(cx)\n     }\n }\n \n impl Clean<String> for ast::Name {\n     #[inline]\n-    fn clean(&self, _: &DocContext) -> String {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> String {\n         self.to_string()\n     }\n }\n \n impl Clean<String> for InternedString {\n     #[inline]\n-    fn clean(&self, _: &DocContext) -> String {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> String {\n         self.to_string()\n     }\n }\n@@ -3361,7 +3363,7 @@ pub struct Typedef {\n }\n \n impl Clean<Item> for doctree::Typedef {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3385,7 +3387,7 @@ pub struct Existential {\n }\n \n impl Clean<Item> for doctree::Existential {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3411,7 +3413,7 @@ pub struct BareFunctionDecl {\n }\n \n impl Clean<BareFunctionDecl> for hir::BareFnTy {\n-    fn clean(&self, cx: &DocContext) -> BareFunctionDecl {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, || {\n             (self.generic_params.clean(cx), (&*self.decl, &self.arg_names[..]).clean(cx))\n         });\n@@ -3435,7 +3437,7 @@ pub struct Static {\n }\n \n impl Clean<Item> for doctree::Static {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         debug!(\"cleaning static {}: {:?}\", self.name.clean(cx), self);\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3461,7 +3463,7 @@ pub struct Constant {\n }\n \n impl Clean<Item> for doctree::Constant {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3485,7 +3487,7 @@ pub enum Mutability {\n }\n \n impl Clean<Mutability> for hir::Mutability {\n-    fn clean(&self, _: &DocContext) -> Mutability {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> Mutability {\n         match self {\n             &hir::MutMutable => Mutable,\n             &hir::MutImmutable => Immutable,\n@@ -3500,7 +3502,7 @@ pub enum ImplPolarity {\n }\n \n impl Clean<ImplPolarity> for hir::ImplPolarity {\n-    fn clean(&self, _: &DocContext) -> ImplPolarity {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> ImplPolarity {\n         match self {\n             &hir::ImplPolarity::Positive => ImplPolarity::Positive,\n             &hir::ImplPolarity::Negative => ImplPolarity::Negative,\n@@ -3521,30 +3523,30 @@ pub struct Impl {\n     pub blanket_impl: Option<Type>,\n }\n \n-pub fn get_auto_traits_with_node_id(cx: &DocContext, id: ast::NodeId, name: String) -> Vec<Item> {\n+pub fn get_auto_traits_with_node_id(cx: &DocContext<'_, '_, '_>, id: ast::NodeId, name: String) -> Vec<Item> {\n     let finder = AutoTraitFinder::new(cx);\n     finder.get_with_node_id(id, name)\n }\n \n-pub fn get_auto_traits_with_def_id(cx: &DocContext, id: DefId) -> Vec<Item> {\n+pub fn get_auto_traits_with_def_id(cx: &DocContext<'_, '_, '_>, id: DefId) -> Vec<Item> {\n     let finder = AutoTraitFinder::new(cx);\n \n     finder.get_with_def_id(id)\n }\n \n-pub fn get_blanket_impls_with_node_id(cx: &DocContext, id: ast::NodeId, name: String) -> Vec<Item> {\n+pub fn get_blanket_impls_with_node_id(cx: &DocContext<'_, '_, '_>, id: ast::NodeId, name: String) -> Vec<Item> {\n     let finder = BlanketImplFinder::new(cx);\n     finder.get_with_node_id(id, name)\n }\n \n-pub fn get_blanket_impls_with_def_id(cx: &DocContext, id: DefId) -> Vec<Item> {\n+pub fn get_blanket_impls_with_def_id(cx: &DocContext<'_, '_, '_>, id: DefId) -> Vec<Item> {\n     let finder = BlanketImplFinder::new(cx);\n \n     finder.get_with_def_id(id)\n }\n \n impl Clean<Vec<Item>> for doctree::Impl {\n-    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<Item> {\n         let mut ret = Vec::new();\n         let trait_ = self.trait_.clean(cx);\n         let items = self.items.clean(cx);\n@@ -3586,7 +3588,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n     }\n }\n \n-fn build_deref_target_impls(cx: &DocContext,\n+fn build_deref_target_impls(cx: &DocContext<'_, '_, '_>,\n                             items: &[Item],\n                             ret: &mut Vec<Item>) {\n     use self::PrimitiveType::*;\n@@ -3644,7 +3646,7 @@ fn build_deref_target_impls(cx: &DocContext,\n }\n \n impl Clean<Vec<Item>> for doctree::ExternCrate {\n-    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<Item> {\n \n         let please_inline = self.vis.node.is_pub() && self.attrs.iter().any(|a| {\n             a.name() == \"doc\" && match a.meta_item_list() {\n@@ -3680,7 +3682,7 @@ impl Clean<Vec<Item>> for doctree::ExternCrate {\n }\n \n impl Clean<Vec<Item>> for doctree::Import {\n-    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<Item> {\n         // We consider inlining the documentation of `pub use` statements, but we\n         // forcefully don't inline if this is not public or if the\n         // #[doc(no_inline)] attribute is present.\n@@ -3754,7 +3756,7 @@ pub struct ImportSource {\n }\n \n impl Clean<Vec<Item>> for hir::ForeignMod {\n-    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<Item> {\n         let mut items = self.items.clean(cx);\n         for item in &mut items {\n             if let ForeignFunctionItem(ref mut f) = item.inner {\n@@ -3766,7 +3768,7 @@ impl Clean<Vec<Item>> for hir::ForeignMod {\n }\n \n impl Clean<Item> for hir::ForeignItem {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let inner = match self.node {\n             hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n                 let (generics, decl) = enter_impl_trait(cx, || {\n@@ -3811,11 +3813,11 @@ impl Clean<Item> for hir::ForeignItem {\n // Utilities\n \n pub trait ToSource {\n-    fn to_src(&self, cx: &DocContext) -> String;\n+    fn to_src(&self, cx: &DocContext<'_, '_, '_>) -> String;\n }\n \n impl ToSource for syntax_pos::Span {\n-    fn to_src(&self, cx: &DocContext) -> String {\n+    fn to_src(&self, cx: &DocContext<'_, '_, '_>) -> String {\n         debug!(\"converting span {:?} to snippet\", self.clean(cx));\n         let sn = match cx.sess().source_map().span_to_snippet(*self) {\n             Ok(x) => x,\n@@ -3862,7 +3864,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     }\n }\n \n-fn print_const(cx: &DocContext, n: ty::LazyConst) -> String {\n+fn print_const(cx: &DocContext<'_, '_, '_>, n: ty::LazyConst<'_>) -> String {\n     match n {\n         ty::LazyConst::Unevaluated(def_id, _) => {\n             if let Some(node_id) = cx.tcx.hir().as_local_node_id(def_id) {\n@@ -3884,12 +3886,12 @@ fn print_const(cx: &DocContext, n: ty::LazyConst) -> String {\n     }\n }\n \n-fn print_const_expr(cx: &DocContext, body: hir::BodyId) -> String {\n+fn print_const_expr(cx: &DocContext<'_, '_, '_>, body: hir::BodyId) -> String {\n     cx.tcx.hir().hir_to_pretty_string(body.hir_id)\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt\n-fn resolve_type(cx: &DocContext,\n+fn resolve_type(cx: &DocContext<'_, '_, '_>,\n                 path: Path,\n                 id: ast::NodeId) -> Type {\n     if id == ast::DUMMY_NODE_ID {\n@@ -3920,7 +3922,7 @@ fn resolve_type(cx: &DocContext,\n     ResolvedPath { path: path, typarams: None, did: did, is_generic: is_generic }\n }\n \n-pub fn register_def(cx: &DocContext, def: Def) -> DefId {\n+pub fn register_def(cx: &DocContext<'_, '_, '_>, def: Def) -> DefId {\n     debug!(\"register_def({:?})\", def);\n \n     let (did, kind) = match def {\n@@ -3955,7 +3957,7 @@ pub fn register_def(cx: &DocContext, def: Def) -> DefId {\n     did\n }\n \n-fn resolve_use_source(cx: &DocContext, path: Path) -> ImportSource {\n+fn resolve_use_source(cx: &DocContext<'_, '_, '_>, path: Path) -> ImportSource {\n     ImportSource {\n         did: if path.def.opt_def_id().is_none() {\n             None\n@@ -3973,7 +3975,7 @@ pub struct Macro {\n }\n \n impl Clean<Item> for doctree::Macro {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let name = self.name.clean(cx);\n         Item {\n             name: Some(name.clone()),\n@@ -4002,7 +4004,7 @@ pub struct ProcMacro {\n }\n \n impl Clean<Item> for doctree::ProcMacro {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -4036,7 +4038,7 @@ pub struct Deprecation {\n }\n \n impl Clean<Stability> for attr::Stability {\n-    fn clean(&self, _: &DocContext) -> Stability {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> Stability {\n         Stability {\n             level: stability::StabilityLevel::from_attr_level(&self.level),\n             feature: Some(self.feature.to_string()).filter(|f| !f.is_empty()),\n@@ -4063,13 +4065,13 @@ impl Clean<Stability> for attr::Stability {\n }\n \n impl<'a> Clean<Stability> for &'a attr::Stability {\n-    fn clean(&self, dc: &DocContext) -> Stability {\n+    fn clean(&self, dc: &DocContext<'_, '_, '_>) -> Stability {\n         (**self).clean(dc)\n     }\n }\n \n impl Clean<Deprecation> for attr::Deprecation {\n-    fn clean(&self, _: &DocContext) -> Deprecation {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> Deprecation {\n         Deprecation {\n             since: self.since.map(|s| s.to_string()).filter(|s| !s.is_empty()),\n             note: self.note.map(|n| n.to_string()).filter(|n| !n.is_empty()),\n@@ -4085,15 +4087,15 @@ pub struct TypeBinding {\n }\n \n impl Clean<TypeBinding> for hir::TypeBinding {\n-    fn clean(&self, cx: &DocContext) -> TypeBinding {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> TypeBinding {\n         TypeBinding {\n             name: self.ident.name.clean(cx),\n             ty: self.ty.clean(cx)\n         }\n     }\n }\n \n-pub fn def_id_to_path(cx: &DocContext, did: DefId, name: Option<String>) -> Vec<String> {\n+pub fn def_id_to_path(cx: &DocContext<'_, '_, '_>, did: DefId, name: Option<String>) -> Vec<String> {\n     let crate_name = name.unwrap_or_else(|| cx.tcx.crate_name(did.krate).to_string());\n     let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n         // extern blocks have an empty name\n@@ -4107,7 +4109,7 @@ pub fn def_id_to_path(cx: &DocContext, did: DefId, name: Option<String>) -> Vec<\n     once(crate_name).chain(relative).collect()\n }\n \n-pub fn enter_impl_trait<F, R>(cx: &DocContext, f: F) -> R\n+pub fn enter_impl_trait<F, R>(cx: &DocContext<'_, '_, '_>, f: F) -> R\n where\n     F: FnOnce() -> R,\n {\n@@ -4120,7 +4122,7 @@ where\n \n // Start of code copied from rust-clippy\n \n-pub fn path_to_def_local(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n+pub fn path_to_def_local(tcx: &TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n     let krate = tcx.hir().krate();\n     let mut items = krate.module.item_ids.clone();\n     let mut path_it = path.iter().peekable();\n@@ -4145,7 +4147,7 @@ pub fn path_to_def_local(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n     }\n }\n \n-pub fn path_to_def(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n+pub fn path_to_def(tcx: &TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n     let crates = tcx.crates();\n \n     let krate = crates\n@@ -4182,7 +4184,7 @@ pub fn path_to_def(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n     }\n }\n \n-pub fn get_path_for_type<F>(tcx: TyCtxt, def_id: DefId, def_ctor: F) -> hir::Path\n+pub fn get_path_for_type<F>(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, def_ctor: F) -> hir::Path\n where F: Fn(DefId) -> Def {\n     #[derive(Debug)]\n     struct AbsolutePathBuffer {"}, {"sha": "8614b72dffba7211d5d1f807f3484b6583146f7e", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -17,12 +17,12 @@ use std::collections::BTreeMap;\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n \n-use clean::GenericArgs as PP;\n-use clean::WherePredicate as WP;\n-use clean;\n-use core::DocContext;\n+use crate::clean::GenericArgs as PP;\n+use crate::clean::WherePredicate as WP;\n+use crate::clean;\n+use crate::core::DocContext;\n \n-pub fn where_clauses(cx: &DocContext, clauses: Vec<WP>) -> Vec<WP> {\n+pub fn where_clauses(cx: &DocContext<'_, '_, '_>, clauses: Vec<WP>) -> Vec<WP> {\n     // First, partition the where clause into its separate components\n     let mut params: BTreeMap<_, Vec<_>> = BTreeMap::new();\n     let mut lifetimes = Vec::new();\n@@ -141,7 +141,7 @@ fn ty_bounds(bounds: Vec<clean::GenericBound>) -> Vec<clean::GenericBound> {\n     bounds\n }\n \n-fn trait_is_same_or_supertrait(cx: &DocContext, child: DefId,\n+fn trait_is_same_or_supertrait(cx: &DocContext<'_, '_, '_>, child: DefId,\n                                trait_: DefId) -> bool {\n     if child == trait_ {\n         return true"}, {"sha": "e5caf7fdfa23591d9ba088ea9892ebfca96ce5e8", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -15,14 +15,14 @@ use rustc_driver;\n use rustc_target::spec::TargetTriple;\n use syntax::edition::Edition;\n \n-use core::new_handler;\n-use externalfiles::ExternalHtml;\n-use html;\n-use html::markdown::IdMap;\n-use html::static_files;\n-use opts;\n-use passes::{self, DefaultPassOption};\n-use theme;\n+use crate::core::new_handler;\n+use crate::externalfiles::ExternalHtml;\n+use crate::html;\n+use crate::html::{static_files};\n+use crate::html::markdown::{IdMap};\n+use crate::opts;\n+use crate::passes::{self, DefaultPassOption};\n+use crate::theme;\n \n /// Configuration options for rustdoc.\n #[derive(Clone)]\n@@ -95,11 +95,11 @@ pub struct Options {\n }\n \n impl fmt::Debug for Options {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         struct FmtExterns<'a>(&'a Externs);\n \n         impl<'a> fmt::Debug for FmtExterns<'a> {\n-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 f.debug_map()\n                     .entries(self.0.iter())\n                     .finish()\n@@ -204,7 +204,7 @@ impl Options {\n         nightly_options::check_nightly_options(&matches, &opts());\n \n         if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-            ::usage(\"rustdoc\");\n+            crate::usage(\"rustdoc\");\n             return Err(0);\n         } else if matches.opt_present(\"version\") {\n             rustc_driver::version(\"rustdoc\", &matches);"}, {"sha": "4f70751c90537899cb8ce6b3eec4812e9b617d01", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -33,12 +33,13 @@ use rustc_data_structures::sync::{self, Lrc};\n use std::rc::Rc;\n use std::sync::Arc;\n \n-use visit_ast::RustdocVisitor;\n-use config::{Options as RustdocOptions, RenderOptions};\n-use clean;\n-use clean::{get_path_for_type, Clean, MAX_DEF_ID, AttributesExt};\n-use html::render::RenderInfo;\n-use passes;\n+use crate::visit_ast::RustdocVisitor;\n+use crate::config::{Options as RustdocOptions, RenderOptions};\n+use crate::clean;\n+use crate::clean::{get_path_for_type, Clean, MAX_DEF_ID, AttributesExt};\n+use crate::html::render::RenderInfo;\n+\n+use crate::passes;\n \n pub use rustc::session::config::{Input, Options, CodegenOptions};\n pub use rustc::session::search_paths::SearchPath;"}, {"sha": "0378b12662da26fa5fd6ee525f7ae5d8b244d18a", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -2,8 +2,9 @@ use std::fs;\n use std::path::Path;\n use std::str;\n use errors;\n-use syntax::feature_gate::UnstableFeatures;\n-use html::markdown::{IdMap, ErrorCodes, Markdown};\n+use crate::syntax::feature_gate::UnstableFeatures;\n+use crate::html::markdown::{IdMap, ErrorCodes, Markdown};\n+\n use std::cell::RefCell;\n \n #[derive(Clone, Debug)]"}, {"sha": "cfa22bc27b7587ed99b94bd1b119240b6ccd385a", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -1,4 +1,4 @@\n-use clean::*;\n+use crate::clean::*;\n \n pub struct StripItem(pub Item);\n "}, {"sha": "182a2dd2e9c9f95858ff133ca0e63b25c6b97963", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -10,7 +10,7 @@ use std::fmt;\n pub struct Escape<'a>(pub &'a str);\n \n impl<'a> fmt::Display for Escape<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // Because the internet is always right, turns out there's not that many\n         // characters to escape: http://stackoverflow.com/questions/7381974\n         let Escape(s) = *self;"}, {"sha": "4463dad1c8a1f8de1e264ebad0909b3474e86084", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -12,10 +12,11 @@ use rustc::hir::def_id::DefId;\n use rustc_target::spec::abi::Abi;\n use rustc::hir;\n \n-use clean::{self, PrimitiveType};\n-use core::DocAccessLevels;\n-use html::item_type::ItemType;\n-use html::render::{self, cache, CURRENT_LOCATION_KEY};\n+use crate::clean::{self, PrimitiveType};\n+use crate::core::DocAccessLevels;\n+use crate::html::item_type::ItemType;\n+use crate::html::render::{self, cache, CURRENT_LOCATION_KEY};\n+\n \n /// Helper to render an optional visibility with a space after it (if the\n /// visibility is preset)\n@@ -42,7 +43,7 @@ pub struct RawMutableSpace(pub clean::Mutability);\n /// Wrapper struct for emitting type parameter bounds.\n pub struct GenericBounds<'a>(pub &'a [clean::GenericBound]);\n /// Wrapper struct for emitting a comma-separated list of items\n-pub struct CommaSep<'a, T: 'a>(pub &'a [T]);\n+pub struct CommaSep<'a, T>(pub &'a [T]);\n pub struct AbiSpace(pub Abi);\n \n /// Wrapper struct for properly emitting a function or method declaration.\n@@ -94,7 +95,7 @@ impl ConstnessSpace {\n }\n \n impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         for (i, item) in self.0.iter().enumerate() {\n             if i != 0 { write!(f, \", \")?; }\n             fmt::Display::fmt(item, f)?;\n@@ -104,7 +105,7 @@ impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n }\n \n impl<'a> fmt::Display for GenericBounds<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let &GenericBounds(bounds) = self;\n         for (i, bound) in bounds.iter().enumerate() {\n             if i > 0 {\n@@ -117,7 +118,7 @@ impl<'a> fmt::Display for GenericBounds<'a> {\n }\n \n impl fmt::Display for clean::GenericParamDef {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.kind {\n             clean::GenericParamDefKind::Lifetime => write!(f, \"{}\", self.name),\n             clean::GenericParamDefKind::Type { ref bounds, ref default, .. } => {\n@@ -156,7 +157,7 @@ impl fmt::Display for clean::GenericParamDef {\n }\n \n impl fmt::Display for clean::Generics {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let real_params = self.params\n             .iter()\n             .filter(|p| !p.is_synthetic_type_param())\n@@ -173,7 +174,7 @@ impl fmt::Display for clean::Generics {\n }\n \n impl<'a> fmt::Display for WhereClause<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let &WhereClause { gens, indent, end_newline } = self;\n         if gens.where_predicates.is_empty() {\n             return Ok(());\n@@ -252,14 +253,14 @@ impl<'a> fmt::Display for WhereClause<'a> {\n }\n \n impl fmt::Display for clean::Lifetime {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(self.get_ref())?;\n         Ok(())\n     }\n }\n \n impl fmt::Display for clean::PolyTrait {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if !self.generic_params.is_empty() {\n             if f.alternate() {\n                 write!(f, \"for<{:#}> \", CommaSep(&self.generic_params))?;\n@@ -276,7 +277,7 @@ impl fmt::Display for clean::PolyTrait {\n }\n \n impl fmt::Display for clean::GenericBound {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             clean::GenericBound::Outlives(ref lt) => {\n                 write!(f, \"{}\", *lt)\n@@ -297,7 +298,7 @@ impl fmt::Display for clean::GenericBound {\n }\n \n impl fmt::Display for clean::GenericArgs {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             clean::GenericArgs::AngleBracketed {\n                 ref lifetimes, ref types, ref bindings\n@@ -374,7 +375,7 @@ impl fmt::Display for clean::GenericArgs {\n }\n \n impl fmt::Display for clean::PathSegment {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.name)?;\n         if f.alternate() {\n             write!(f, \"{:#}\", self.args)\n@@ -385,7 +386,7 @@ impl fmt::Display for clean::PathSegment {\n }\n \n impl fmt::Display for clean::Path {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if self.global {\n             f.write_str(\"::\")?\n         }\n@@ -445,7 +446,7 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n \n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n-fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n+fn resolved_path(w: &mut fmt::Formatter<'_>, did: DefId, path: &clean::Path,\n                  print_all: bool, use_absolute: bool) -> fmt::Result {\n     let last = path.segments.last().unwrap();\n \n@@ -474,7 +475,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n     Ok(())\n }\n \n-fn primitive_link(f: &mut fmt::Formatter,\n+fn primitive_link(f: &mut fmt::Formatter<'_>,\n                   prim: clean::PrimitiveType,\n                   name: &str) -> fmt::Result {\n     let m = cache();\n@@ -519,7 +520,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n }\n \n /// Helper to render type parameters\n-fn tybounds(w: &mut fmt::Formatter,\n+fn tybounds(w: &mut fmt::Formatter<'_>,\n             typarams: &Option<Vec<clean::GenericBound>>) -> fmt::Result {\n     match *typarams {\n         Some(ref params) => {\n@@ -540,7 +541,7 @@ impl<'a> HRef<'a> {\n }\n \n impl<'a> fmt::Display for HRef<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match href(self.did) {\n             Some((url, shortty, fqp)) => if !f.alternate() {\n                 write!(f, \"<a class=\\\"{}\\\" href=\\\"{}\\\" title=\\\"{} {}\\\">{}</a>\",\n@@ -553,7 +554,7 @@ impl<'a> fmt::Display for HRef<'a> {\n     }\n }\n \n-fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt::Result {\n+fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) -> fmt::Result {\n     match *t {\n         clean::Generic(ref name) => {\n             f.write_str(name)\n@@ -745,13 +746,13 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n }\n \n impl fmt::Display for clean::Type {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt_type(self, f, false)\n     }\n }\n \n fn fmt_impl(i: &clean::Impl,\n-            f: &mut fmt::Formatter,\n+            f: &mut fmt::Formatter<'_>,\n             link_trait: bool,\n             use_absolute: bool) -> fmt::Result {\n     if f.alternate() {\n@@ -791,20 +792,20 @@ fn fmt_impl(i: &clean::Impl,\n }\n \n impl fmt::Display for clean::Impl {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt_impl(self, f, true, false)\n     }\n }\n \n // The difference from above is that trait is not hyperlinked.\n pub fn fmt_impl_for_trait_page(i: &clean::Impl,\n-                               f: &mut fmt::Formatter,\n+                               f: &mut fmt::Formatter<'_>,\n                                use_absolute: bool) -> fmt::Result {\n     fmt_impl(i, f, false, use_absolute)\n }\n \n impl fmt::Display for clean::Arguments {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         for (i, input) in self.values.iter().enumerate() {\n             if !input.name.is_empty() {\n                 write!(f, \"{}: \", input.name)?;\n@@ -821,7 +822,7 @@ impl fmt::Display for clean::Arguments {\n }\n \n impl fmt::Display for clean::FunctionRetTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             clean::Return(clean::Tuple(ref tys)) if tys.is_empty() => Ok(()),\n             clean::Return(ref ty) if f.alternate() => write!(f, \" -> {:#}\", ty),\n@@ -832,7 +833,7 @@ impl fmt::Display for clean::FunctionRetTy {\n }\n \n impl fmt::Display for clean::FnDecl {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if self.variadic {\n             if f.alternate() {\n                 write!(f, \"({args:#}, ...){arrow:#}\", args = self.inputs, arrow = self.output)\n@@ -850,7 +851,7 @@ impl fmt::Display for clean::FnDecl {\n }\n \n impl<'a> fmt::Display for Function<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let &Function { decl, header_len, indent, asyncness } = self;\n         let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n         let mut args = String::new();\n@@ -947,7 +948,7 @@ impl<'a> fmt::Display for Function<'a> {\n }\n \n impl<'a> fmt::Display for VisSpace<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self.get() {\n             Some(clean::Public) => f.write_str(\"pub \"),\n             Some(clean::Inherited) | None => Ok(()),\n@@ -967,7 +968,7 @@ impl<'a> fmt::Display for VisSpace<'a> {\n }\n \n impl fmt::Display for UnsafetySpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.get() {\n             hir::Unsafety::Unsafe => write!(f, \"unsafe \"),\n             hir::Unsafety::Normal => Ok(())\n@@ -976,7 +977,7 @@ impl fmt::Display for UnsafetySpace {\n }\n \n impl fmt::Display for ConstnessSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.get() {\n             hir::Constness::Const => write!(f, \"const \"),\n             hir::Constness::NotConst => Ok(())\n@@ -985,7 +986,7 @@ impl fmt::Display for ConstnessSpace {\n }\n \n impl fmt::Display for AsyncSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.0 {\n             hir::IsAsync::Async => write!(f, \"async \"),\n             hir::IsAsync::NotAsync => Ok(()),\n@@ -994,7 +995,7 @@ impl fmt::Display for AsyncSpace {\n }\n \n impl fmt::Display for clean::Import {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             clean::Import::Simple(ref name, ref src) => {\n                 if *name == src.path.last_name() {\n@@ -1015,7 +1016,7 @@ impl fmt::Display for clean::Import {\n }\n \n impl fmt::Display for clean::ImportSource {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.did {\n             Some(did) => resolved_path(f, did, &self.path, true, false),\n             _ => {\n@@ -1032,7 +1033,7 @@ impl fmt::Display for clean::ImportSource {\n }\n \n impl fmt::Display for clean::TypeBinding {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if f.alternate() {\n             write!(f, \"{} = {:#}\", self.name, self.ty)\n         } else {\n@@ -1042,7 +1043,7 @@ impl fmt::Display for clean::TypeBinding {\n }\n \n impl fmt::Display for MutableSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             MutableSpace(clean::Immutable) => Ok(()),\n             MutableSpace(clean::Mutable) => write!(f, \"mut \"),\n@@ -1051,7 +1052,7 @@ impl fmt::Display for MutableSpace {\n }\n \n impl fmt::Display for RawMutableSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             RawMutableSpace(clean::Immutable) => write!(f, \"const \"),\n             RawMutableSpace(clean::Mutable) => write!(f, \"mut \"),\n@@ -1060,7 +1061,7 @@ impl fmt::Display for RawMutableSpace {\n }\n \n impl fmt::Display for AbiSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let quot = if f.alternate() { \"\\\"\" } else { \"&quot;\" };\n         match self.0 {\n             Abi::Rust => Ok(()),"}, {"sha": "d66455f91ba1a2e3e127ebb4d39d0b458110f41b", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -5,7 +5,7 @@\n //!\n //! Use the `render_with_highlighting` to highlight some rust code.\n \n-use html::escape::Escape;\n+use crate::html::escape::Escape;\n \n use std::fmt::Display;\n use std::io;"}, {"sha": "353fa4ae8c999e9bbd74ecda52feb8c73b9109fa", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -2,7 +2,7 @@\n \n use std::fmt;\n use syntax::ext::base::MacroKind;\n-use clean;\n+use crate::clean;\n \n /// Item type. Corresponds to `clean::ItemEnum` variants.\n ///\n@@ -189,7 +189,7 @@ impl ItemType {\n }\n \n impl fmt::Display for ItemType {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.css_class().fmt(f)\n     }\n }\n@@ -211,7 +211,7 @@ impl NameSpace {\n }\n \n impl fmt::Display for NameSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.to_static_str().fmt(f)\n     }\n }"}, {"sha": "6ff3917a265ed9d096a89bc1a2810890d1baf979", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -2,9 +2,8 @@ use std::fmt;\n use std::io;\n use std::path::PathBuf;\n \n-use externalfiles::ExternalHtml;\n-\n-use html::render::SlashChecker;\n+use crate::externalfiles::ExternalHtml;\n+use crate::html::render::SlashChecker;\n \n #[derive(Clone)]\n pub struct Layout {\n@@ -29,7 +28,7 @@ pub struct Page<'a> {\n pub fn render<T: fmt::Display, S: fmt::Display>(\n     dst: &mut dyn io::Write,\n     layout: &Layout,\n-    page: &Page,\n+    page: &Page<'_>,\n     sidebar: &S,\n     t: &T,\n     css_file_extension: bool,"}, {"sha": "a70fe363ca69a493b61c9190bce1068ef2333b7c", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -29,9 +29,9 @@ use std::ops::Range;\n use std::str;\n use syntax::edition::Edition;\n \n-use html::toc::TocBuilder;\n-use html::highlight;\n-use test;\n+use crate::html::toc::TocBuilder;\n+use crate::html::highlight;\n+use crate::test;\n \n use pulldown_cmark::{html, Event, Tag, Parser};\n use pulldown_cmark::{Options, OPTION_ENABLE_FOOTNOTES, OPTION_ENABLE_TABLES};\n@@ -101,7 +101,7 @@ impl<'a> Line<'a> {\n // is done in the single # case. This inconsistency seems okay, if non-ideal. In\n // order to fix it we'd have to iterate to find the first non-# character, and\n // then reallocate to remove it; which would make us return a String.\n-fn map_line(s: &str) -> Line {\n+fn map_line(s: &str) -> Line<'_> {\n     let trimmed = s.trim();\n     if trimmed.starts_with(\"##\") {\n         Line::Shown(Cow::Owned(s.replacen(\"##\", \"#\", 1)))\n@@ -185,7 +185,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n             }\n         }\n         let lines = origtext.lines().filter_map(|l| map_line(l).for_html());\n-        let text = lines.collect::<Vec<Cow<str>>>().join(\"\\n\");\n+        let text = lines.collect::<Vec<Cow<'_, str>>>().join(\"\\n\");\n         PLAYGROUND.with(|play| {\n             // insert newline to clearly separate it from the\n             // previous block so we can shorten the html output\n@@ -196,7 +196,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n                 }\n                 let test = origtext.lines()\n                     .map(|l| map_line(l).for_code())\n-                    .collect::<Vec<Cow<str>>>().join(\"\\n\");\n+                    .collect::<Vec<Cow<'_, str>>>().join(\"\\n\");\n                 let krate = krate.as_ref().map(|s| &**s);\n                 let (test, _) = test::make_test(&test, krate, false,\n                                            &Default::default());\n@@ -386,7 +386,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> SummaryLine<'a, I> {\n     }\n }\n \n-fn check_if_allowed_tag(t: &Tag) -> bool {\n+fn check_if_allowed_tag(t: &Tag<'_>) -> bool {\n     match *t {\n         Tag::Paragraph\n         | Tag::Item\n@@ -523,7 +523,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n pub struct TestableCodeError(());\n \n impl fmt::Display for TestableCodeError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"invalid start of a new code block\")\n     }\n }\n@@ -569,7 +569,7 @@ pub fn find_testable_code<T: test::Tester>(\n                 }\n                 if let Some(offset) = offset {\n                     let lines = test_s.lines().map(|l| map_line(l).for_code());\n-                    let text = lines.collect::<Vec<Cow<str>>>().join(\"\\n\");\n+                    let text = lines.collect::<Vec<Cow<'_, str>>>().join(\"\\n\");\n                     nb_lines += doc[prev_offset..offset].lines().count();\n                     let line = tests.get_line() + (nb_lines - 1);\n                     tests.add_test(text, block_info, line);\n@@ -681,7 +681,7 @@ impl LangString {\n }\n \n impl<'a> fmt::Display for Markdown<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let Markdown(md, links, ref ids, codes) = *self;\n         let mut ids = ids.borrow_mut();\n \n@@ -714,7 +714,7 @@ impl<'a> fmt::Display for Markdown<'a> {\n }\n \n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let MarkdownWithToc(md, ref ids, codes) = *self;\n         let mut ids = ids.borrow_mut();\n \n@@ -742,7 +742,7 @@ impl<'a> fmt::Display for MarkdownWithToc<'a> {\n }\n \n impl<'a> fmt::Display for MarkdownHtml<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let MarkdownHtml(md, ref ids, codes) = *self;\n         let mut ids = ids.borrow_mut();\n \n@@ -772,7 +772,7 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n }\n \n impl<'a> fmt::Display for MarkdownSummaryLine<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let MarkdownSummaryLine(md, links) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }"}, {"sha": "6bbc0bc49d3dba4cf038a716798251d740b8436a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -55,18 +55,18 @@ use rustc::hir;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::flock;\n \n-use clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, Mutability};\n-use config::RenderOptions;\n-use doctree;\n-use fold::DocFolder;\n-use html::escape::Escape;\n-use html::format::{AsyncSpace, ConstnessSpace};\n-use html::format::{GenericBounds, WhereClause, href, AbiSpace};\n-use html::format::{VisSpace, Function, UnsafetySpace, MutableSpace};\n-use html::format::fmt_impl_for_trait_page;\n-use html::item_type::ItemType;\n-use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes, IdMap};\n-use html::{highlight, layout, static_files};\n+use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, Mutability};\n+use crate::config::RenderOptions;\n+use crate::doctree;\n+use crate::fold::DocFolder;\n+use crate::html::escape::Escape;\n+use crate::html::format::{AsyncSpace, ConstnessSpace};\n+use crate::html::format::{GenericBounds, WhereClause, href, AbiSpace};\n+use crate::html::format::{VisSpace, Function, UnsafetySpace, MutableSpace};\n+use crate::html::format::fmt_impl_for_trait_page;\n+use crate::html::item_type::ItemType;\n+use crate::html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes, IdMap};\n+use crate::html::{highlight, layout, static_files};\n \n use minifier;\n \n@@ -76,7 +76,7 @@ pub type NameDoc = (String, Option<String>);\n pub struct SlashChecker<'a>(pub &'a str);\n \n impl<'a> Display for SlashChecker<'a> {\n-    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n         if !self.0.ends_with(\"/\") && !self.0.is_empty() {\n             write!(f, \"{}/\", self.0)\n         } else {\n@@ -223,7 +223,7 @@ impl error::Error for Error {\n }\n \n impl Display for Error {\n-    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n         write!(f, \"\\\"{}\\\": {}\", self.file.display(), self.error)\n     }\n }\n@@ -367,7 +367,7 @@ pub struct Cache {\n #[derive(Default)]\n pub struct RenderInfo {\n     pub inlined: FxHashSet<DefId>,\n-    pub external_paths: ::core::ExternalPaths,\n+    pub external_paths: crate::core::ExternalPaths,\n     pub external_typarams: FxHashMap<DefId, String>,\n     pub exact_paths: FxHashMap<DefId, Vec<String>>,\n     pub access_levels: AccessLevels<DefId>,\n@@ -1130,7 +1130,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n             md_opts.output = cx.dst.clone();\n             md_opts.external_html = (*cx.shared).layout.external_html.clone();\n \n-            ::markdown::render(index_page, md_opts, diag);\n+            crate::markdown::render(index_page, md_opts, diag);\n         } else {\n             let dst = cx.dst.join(\"index.html\");\n             let mut w = BufWriter::new(try_err!(File::create(&dst), &dst));\n@@ -1808,7 +1808,7 @@ impl ItemEntry {\n }\n \n impl fmt::Display for ItemEntry {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"<a href='{}'>{}</a>\", self.url, Escape(&self.name))\n     }\n }\n@@ -1893,7 +1893,7 @@ impl AllTypes {\n     }\n }\n \n-fn print_entries(f: &mut fmt::Formatter, e: &FxHashSet<ItemEntry>, title: &str,\n+fn print_entries(f: &mut fmt::Formatter<'_>, e: &FxHashSet<ItemEntry>, title: &str,\n                  class: &str) -> fmt::Result {\n     if !e.is_empty() {\n         let mut e: Vec<&ItemEntry> = e.iter().collect();\n@@ -1908,7 +1908,7 @@ fn print_entries(f: &mut fmt::Formatter, e: &FxHashSet<ItemEntry>, title: &str,\n }\n \n impl fmt::Display for AllTypes {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f,\n \"<h1 class='fqn'>\\\n      <span class='out-of-band'>\\\n@@ -1965,7 +1965,7 @@ impl<'a> Settings<'a> {\n }\n \n impl<'a> fmt::Display for Settings<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f,\n \"<h1 class='fqn'>\\\n      <span class='in-band'>Rustdoc settings</span>\\\n@@ -2364,16 +2364,16 @@ impl<'a> Item<'a> {\n     }\n }\n \n-fn wrap_into_docblock<F>(w: &mut fmt::Formatter,\n+fn wrap_into_docblock<F>(w: &mut fmt::Formatter<'_>,\n                          f: F) -> fmt::Result\n-where F: Fn(&mut fmt::Formatter) -> fmt::Result {\n+where F: Fn(&mut fmt::Formatter<'_>) -> fmt::Result {\n     write!(w, \"<div class=\\\"docblock type-decl hidden-by-usual-hider\\\">\")?;\n     f(w)?;\n     write!(w, \"</div>\")\n }\n \n impl<'a> fmt::Display for Item<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         debug_assert!(!self.item.is_stripped());\n         // Write the breadcrumb trail header for the top\n         write!(fmt, \"<h1 class='fqn'><span class='out-of-band'>\")?;\n@@ -2516,7 +2516,7 @@ fn plain_summary_line_short(s: Option<&str>) -> String {\n     markdown::plain_summary_line_full(&line[..], true)\n }\n \n-fn document(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item) -> fmt::Result {\n+fn document(w: &mut fmt::Formatter<'_>, cx: &Context, item: &clean::Item) -> fmt::Result {\n     if let Some(ref name) = item.name {\n         info!(\"Documenting {}\", name);\n     }\n@@ -2526,7 +2526,7 @@ fn document(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item) -> fmt::Re\n }\n \n /// Render md_text as markdown.\n-fn render_markdown(w: &mut fmt::Formatter,\n+fn render_markdown(w: &mut fmt::Formatter<'_>,\n                    cx: &Context,\n                    md_text: &str,\n                    links: Vec<(String, String)>,\n@@ -2541,7 +2541,7 @@ fn render_markdown(w: &mut fmt::Formatter,\n            cx.codes))\n }\n \n-fn document_short(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item, link: AssocItemLink,\n+fn document_short(w: &mut fmt::Formatter<'_>, cx: &Context, item: &clean::Item, link: AssocItemLink<'_>,\n                   prefix: &str, is_hidden: bool) -> fmt::Result {\n     if let Some(s) = item.doc_value() {\n         let markdown = if s.contains('\\n') {\n@@ -2559,7 +2559,7 @@ fn document_short(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item, link\n     Ok(())\n }\n \n-fn document_full(w: &mut fmt::Formatter, item: &clean::Item,\n+fn document_full(w: &mut fmt::Formatter<'_>, item: &clean::Item,\n                  cx: &Context, prefix: &str, is_hidden: bool) -> fmt::Result {\n     if let Some(s) = cx.shared.maybe_collapsed_doc_value(item) {\n         debug!(\"Doc block: =====\\n{}\\n=====\", s);\n@@ -2572,7 +2572,7 @@ fn document_full(w: &mut fmt::Formatter, item: &clean::Item,\n     Ok(())\n }\n \n-fn document_stability(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item,\n+fn document_stability(w: &mut fmt::Formatter<'_>, cx: &Context, item: &clean::Item,\n                       is_hidden: bool) -> fmt::Result {\n     let stabilities = short_stability(item, cx);\n     if !stabilities.is_empty() {\n@@ -2589,7 +2589,7 @@ fn document_non_exhaustive_header(item: &clean::Item) -> &str {\n     if item.is_non_exhaustive() { \" (Non-exhaustive)\" } else { \"\" }\n }\n \n-fn document_non_exhaustive(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n+fn document_non_exhaustive(w: &mut fmt::Formatter<'_>, item: &clean::Item) -> fmt::Result {\n     if item.is_non_exhaustive() {\n         write!(w, \"<div class='docblock non-exhaustive non-exhaustive-{}'>\", {\n             if item.is_struct() { \"struct\" } else if item.is_enum() { \"enum\" } else { \"type\" }\n@@ -2637,7 +2637,7 @@ fn name_key(name: &str) -> (&str, u64, usize) {\n     }\n }\n \n-fn item_module(w: &mut fmt::Formatter, cx: &Context,\n+fn item_module(w: &mut fmt::Formatter<'_>, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n     document(w, cx, item)?;\n \n@@ -2741,7 +2741,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n         match myitem.inner {\n             clean::ExternCrateItem(ref name, ref src) => {\n-                use html::format::HRef;\n+                use crate::html::format::HRef;\n \n                 match *src {\n                     Some(ref src) => {\n@@ -2957,7 +2957,7 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n     stability\n }\n \n-fn item_constant(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_constant(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                  c: &clean::Constant) -> fmt::Result {\n     write!(w, \"<pre class='rust const'>\")?;\n     render_attributes(w, it)?;\n@@ -2969,7 +2969,7 @@ fn item_constant(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)\n }\n \n-fn item_static(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_static(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                s: &clean::Static) -> fmt::Result {\n     write!(w, \"<pre class='rust static'>\")?;\n     render_attributes(w, it)?;\n@@ -2982,7 +2982,7 @@ fn item_static(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)\n }\n \n-fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_function(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                  f: &clean::Function) -> fmt::Result {\n     let header_len = format!(\n         \"{}{}{}{}{:#}fn {}{:#}\",\n@@ -3016,7 +3016,7 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)\n }\n \n-fn render_implementor(cx: &Context, implementor: &Impl, w: &mut fmt::Formatter,\n+fn render_implementor(cx: &Context, implementor: &Impl, w: &mut fmt::Formatter<'_>,\n                       implementor_dups: &FxHashMap<&str, (DefId, bool)>) -> fmt::Result {\n     // If there's already another implementor that has the same abbridged name, use the\n     // full path, for example in `std::iter::ExactSizeIterator`\n@@ -3033,7 +3033,7 @@ fn render_implementor(cx: &Context, implementor: &Impl, w: &mut fmt::Formatter,\n     Ok(())\n }\n \n-fn render_impls(cx: &Context, w: &mut fmt::Formatter,\n+fn render_impls(cx: &Context, w: &mut fmt::Formatter<'_>,\n                 traits: &[&&Impl],\n                 containing_item: &clean::Item) -> fmt::Result {\n     for i in traits {\n@@ -3070,7 +3070,7 @@ fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl) -> Ordering {\n }\n \n fn item_trait(\n-    w: &mut fmt::Formatter,\n+    w: &mut fmt::Formatter<'_>,\n     cx: &Context,\n     it: &clean::Item,\n     t: &clean::Trait,\n@@ -3156,7 +3156,7 @@ fn item_trait(\n     document(w, cx, it)?;\n \n     fn write_small_section_header(\n-        w: &mut fmt::Formatter,\n+        w: &mut fmt::Formatter<'_>,\n         id: &str,\n         title: &str,\n         extra_content: &str,\n@@ -3167,11 +3167,11 @@ fn item_trait(\n             </h2>{2}\", id, title, extra_content)\n     }\n \n-    fn write_loading_content(w: &mut fmt::Formatter, extra_content: &str) -> fmt::Result {\n+    fn write_loading_content(w: &mut fmt::Formatter<'_>, extra_content: &str) -> fmt::Result {\n         write!(w, \"{}<span class='loading-content'>Loading content...</span>\", extra_content)\n     }\n \n-    fn trait_item(w: &mut fmt::Formatter, cx: &Context, m: &clean::Item, t: &clean::Item)\n+    fn trait_item(w: &mut fmt::Formatter<'_>, cx: &Context, m: &clean::Item, t: &clean::Item)\n                   -> fmt::Result {\n         let name = m.name.as_ref().unwrap();\n         let item_type = m.type_();\n@@ -3328,8 +3328,8 @@ fn item_trait(\n     Ok(())\n }\n \n-fn naive_assoc_href(it: &clean::Item, link: AssocItemLink) -> String {\n-    use html::item_type::ItemType::*;\n+fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>) -> String {\n+    use crate::html::item_type::ItemType::*;\n \n     let name = it.name.as_ref().unwrap();\n     let ty = match it.type_() {\n@@ -3347,11 +3347,11 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink) -> String {\n     }\n }\n \n-fn assoc_const(w: &mut fmt::Formatter,\n+fn assoc_const(w: &mut fmt::Formatter<'_>,\n                it: &clean::Item,\n                ty: &clean::Type,\n                _default: Option<&String>,\n-               link: AssocItemLink) -> fmt::Result {\n+               link: AssocItemLink<'_>) -> fmt::Result {\n     write!(w, \"{}const <a href='{}' class=\\\"constant\\\"><b>{}</b></a>: {}\",\n            VisSpace(&it.visibility),\n            naive_assoc_href(it, link),\n@@ -3363,7 +3363,7 @@ fn assoc_const(w: &mut fmt::Formatter,\n fn assoc_type<W: fmt::Write>(w: &mut W, it: &clean::Item,\n                              bounds: &[clean::GenericBound],\n                              default: Option<&clean::Type>,\n-                             link: AssocItemLink) -> fmt::Result {\n+                             link: AssocItemLink<'_>) -> fmt::Result {\n     write!(w, \"type <a href='{}' class=\\\"type\\\">{}</a>\",\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap())?;\n@@ -3389,22 +3389,22 @@ fn render_stability_since_raw<'a, T: fmt::Write>(\n     Ok(())\n }\n \n-fn render_stability_since(w: &mut fmt::Formatter,\n+fn render_stability_since(w: &mut fmt::Formatter<'_>,\n                           item: &clean::Item,\n                           containing_item: &clean::Item) -> fmt::Result {\n     render_stability_since_raw(w, item.stable_since(), containing_item.stable_since())\n }\n \n-fn render_assoc_item(w: &mut fmt::Formatter,\n+fn render_assoc_item(w: &mut fmt::Formatter<'_>,\n                      item: &clean::Item,\n-                     link: AssocItemLink,\n+                     link: AssocItemLink<'_>,\n                      parent: ItemType) -> fmt::Result {\n-    fn method(w: &mut fmt::Formatter,\n+    fn method(w: &mut fmt::Formatter<'_>,\n               meth: &clean::Item,\n               header: hir::FnHeader,\n               g: &clean::Generics,\n               d: &clean::FnDecl,\n-              link: AssocItemLink,\n+              link: AssocItemLink<'_>,\n               parent: ItemType)\n               -> fmt::Result {\n         let name = meth.name.as_ref().unwrap();\n@@ -3481,7 +3481,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n     }\n }\n \n-fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_struct(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                s: &clean::Struct) -> fmt::Result {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust struct'>\")?;\n@@ -3532,7 +3532,7 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_union(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_union(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                s: &clean::Union) -> fmt::Result {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust union'>\")?;\n@@ -3577,7 +3577,7 @@ fn item_union(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_enum(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust enum'>\")?;\n@@ -3666,7 +3666,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             write!(w, \"</code></span>\")?;\n             document(w, cx, variant)?;\n \n-            use clean::{Variant, VariantKind};\n+            use crate::clean::{Variant, VariantKind};\n             if let clean::VariantItem(Variant {\n                 kind: VariantKind::Struct(ref s)\n             }) = variant.inner {\n@@ -3678,7 +3678,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 write!(w, \"<h3>Fields of <b>{name}</b></h3><div>\",\n                        name = variant.name.as_ref().unwrap())?;\n                 for field in &s.fields {\n-                    use clean::StructFieldItem;\n+                    use crate::clean::StructFieldItem;\n                     if let StructFieldItem(ref ty) = field.inner {\n                         let id = cx.derive_id(format!(\"variant.{}.field.{}\",\n                                                    variant.name.as_ref().unwrap(),\n@@ -3741,7 +3741,7 @@ const ATTRIBUTE_WHITELIST: &'static [&'static str] = &[\n     \"non_exhaustive\"\n ];\n \n-fn render_attributes(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n+fn render_attributes(w: &mut fmt::Formatter<'_>, it: &clean::Item) -> fmt::Result {\n     let mut attrs = String::new();\n \n     for attr in &it.attrs.other_attrs {\n@@ -3759,7 +3759,7 @@ fn render_attributes(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     Ok(())\n }\n \n-fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n+fn render_struct(w: &mut fmt::Formatter<'_>, it: &clean::Item,\n                  g: Option<&clean::Generics>,\n                  ty: doctree::StructType,\n                  fields: &[clean::Item],\n@@ -3835,7 +3835,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n-fn render_union(w: &mut fmt::Formatter, it: &clean::Item,\n+fn render_union(w: &mut fmt::Formatter<'_>, it: &clean::Item,\n                 g: Option<&clean::Generics>,\n                 fields: &[clean::Item],\n                 tab: &str,\n@@ -3893,11 +3893,11 @@ enum RenderMode {\n     ForDeref { mut_: bool },\n }\n \n-fn render_assoc_items(w: &mut fmt::Formatter,\n+fn render_assoc_items(w: &mut fmt::Formatter<'_>,\n                       cx: &Context,\n                       containing_item: &clean::Item,\n                       it: DefId,\n-                      what: AssocItemRender) -> fmt::Result {\n+                      what: AssocItemRender<'_>) -> fmt::Result {\n     let c = cache();\n     let v = match c.impls.get(&it) {\n         Some(v) => v,\n@@ -3955,7 +3955,7 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n         struct RendererStruct<'a, 'b, 'c>(&'a Context, Vec<&'b &'b Impl>, &'c clean::Item);\n \n         impl<'a, 'b, 'c> fmt::Display for RendererStruct<'a, 'b, 'c> {\n-            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 render_impls(self.0, fmt, &self.1, self.2)\n             }\n         }\n@@ -3996,7 +3996,7 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n     Ok(())\n }\n \n-fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n+fn render_deref_methods(w: &mut fmt::Formatter<'_>, cx: &Context, impl_: &Impl,\n                         container_item: &clean::Item, deref_mut: bool) -> fmt::Result {\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n     let target = impl_.inner_impl().items.iter().filter_map(|item| {\n@@ -4107,7 +4107,7 @@ fn spotlight_decl(decl: &clean::FnDecl) -> Result<String, fmt::Error> {\n     Ok(out)\n }\n \n-fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLink,\n+fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n                render_mode: RenderMode, outer_version: Option<&str>,\n                show_def_docs: bool, use_absolute: Option<bool>) -> fmt::Result {\n     if render_mode == RenderMode::Normal {\n@@ -4149,8 +4149,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         }\n     }\n \n-    fn doc_impl_item(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item,\n-                     link: AssocItemLink, render_mode: RenderMode,\n+    fn doc_impl_item(w: &mut fmt::Formatter<'_>, cx: &Context, item: &clean::Item,\n+                     link: AssocItemLink<'_>, render_mode: RenderMode,\n                      is_default_item: bool, outer_version: Option<&str>,\n                      trait_: Option<&clean::Trait>, show_def_docs: bool) -> fmt::Result {\n         let item_type = item.type_();\n@@ -4264,7 +4264,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                       false, outer_version, trait_, show_def_docs)?;\n     }\n \n-    fn render_default_items(w: &mut fmt::Formatter,\n+    fn render_default_items(w: &mut fmt::Formatter<'_>,\n                             cx: &Context,\n                             t: &clean::Trait,\n                             i: &clean::Impl,\n@@ -4297,7 +4297,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n }\n \n fn item_existential(\n-    w: &mut fmt::Formatter,\n+    w: &mut fmt::Formatter<'_>,\n     cx: &Context,\n     it: &clean::Item,\n     t: &clean::Existential,\n@@ -4319,7 +4319,7 @@ fn item_existential(\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_trait_alias(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_trait_alias(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                     t: &clean::TraitAlias) -> fmt::Result {\n     write!(w, \"<pre class='rust trait-alias'>\")?;\n     render_attributes(w, it)?;\n@@ -4338,7 +4338,7 @@ fn item_trait_alias(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_typedef(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_typedef(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n     write!(w, \"<pre class='rust typedef'>\")?;\n     render_attributes(w, it)?;\n@@ -4357,7 +4357,7 @@ fn item_typedef(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_foreign_type(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item) -> fmt::Result {\n+fn item_foreign_type(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item) -> fmt::Result {\n     writeln!(w, \"<pre class='rust foreigntype'>extern {{\")?;\n     render_attributes(w, it)?;\n     write!(\n@@ -4373,7 +4373,7 @@ fn item_foreign_type(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item) ->\n }\n \n impl<'a> fmt::Display for Sidebar<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let cx = self.cx;\n         let it = self.item;\n         let parentlen = cx.current.len() - if it.is_mod() {1} else {0};\n@@ -4638,7 +4638,7 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n     out\n }\n \n-fn sidebar_struct(fmt: &mut fmt::Formatter, it: &clean::Item,\n+fn sidebar_struct(fmt: &mut fmt::Formatter<'_>, it: &clean::Item,\n                   s: &clean::Struct) -> fmt::Result {\n     let mut sidebar = String::new();\n     let fields = get_struct_fields_name(&s.fields);\n@@ -4675,7 +4675,7 @@ fn is_negative_impl(i: &clean::Impl) -> bool {\n     i.polarity == Some(clean::ImplPolarity::Negative)\n }\n \n-fn sidebar_trait(fmt: &mut fmt::Formatter, it: &clean::Item,\n+fn sidebar_trait(fmt: &mut fmt::Formatter<'_>, it: &clean::Item,\n                  t: &clean::Trait) -> fmt::Result {\n     let mut sidebar = String::new();\n \n@@ -4787,7 +4787,7 @@ fn sidebar_trait(fmt: &mut fmt::Formatter, it: &clean::Item,\n     write!(fmt, \"<div class=\\\"block items\\\">{}</div>\", sidebar)\n }\n \n-fn sidebar_primitive(fmt: &mut fmt::Formatter, it: &clean::Item,\n+fn sidebar_primitive(fmt: &mut fmt::Formatter<'_>, it: &clean::Item,\n                      _p: &clean::PrimitiveType) -> fmt::Result {\n     let sidebar = sidebar_assoc_items(it);\n \n@@ -4797,7 +4797,7 @@ fn sidebar_primitive(fmt: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n-fn sidebar_typedef(fmt: &mut fmt::Formatter, it: &clean::Item,\n+fn sidebar_typedef(fmt: &mut fmt::Formatter<'_>, it: &clean::Item,\n                    _t: &clean::Typedef) -> fmt::Result {\n     let sidebar = sidebar_assoc_items(it);\n \n@@ -4822,7 +4822,7 @@ fn get_struct_fields_name(fields: &[clean::Item]) -> String {\n           .collect()\n }\n \n-fn sidebar_union(fmt: &mut fmt::Formatter, it: &clean::Item,\n+fn sidebar_union(fmt: &mut fmt::Formatter<'_>, it: &clean::Item,\n                  u: &clean::Union) -> fmt::Result {\n     let mut sidebar = String::new();\n     let fields = get_struct_fields_name(&u.fields);\n@@ -4840,7 +4840,7 @@ fn sidebar_union(fmt: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n-fn sidebar_enum(fmt: &mut fmt::Formatter, it: &clean::Item,\n+fn sidebar_enum(fmt: &mut fmt::Formatter<'_>, it: &clean::Item,\n                 e: &clean::Enum) -> fmt::Result {\n     let mut sidebar = String::new();\n \n@@ -4895,7 +4895,7 @@ fn item_ty_to_strs(ty: &ItemType) -> (&'static str, &'static str) {\n     }\n }\n \n-fn sidebar_module(fmt: &mut fmt::Formatter, _it: &clean::Item,\n+fn sidebar_module(fmt: &mut fmt::Formatter<'_>, _it: &clean::Item,\n                   items: &[clean::Item]) -> fmt::Result {\n     let mut sidebar = String::new();\n \n@@ -4927,7 +4927,7 @@ fn sidebar_module(fmt: &mut fmt::Formatter, _it: &clean::Item,\n     Ok(())\n }\n \n-fn sidebar_foreign_type(fmt: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n+fn sidebar_foreign_type(fmt: &mut fmt::Formatter<'_>, it: &clean::Item) -> fmt::Result {\n     let sidebar = sidebar_assoc_items(it);\n     if !sidebar.is_empty() {\n         write!(fmt, \"<div class=\\\"block items\\\">{}</div>\", sidebar)?;\n@@ -4936,7 +4936,7 @@ fn sidebar_foreign_type(fmt: &mut fmt::Formatter, it: &clean::Item) -> fmt::Resu\n }\n \n impl<'a> fmt::Display for Source<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let Source(s) = *self;\n         let lines = s.lines().count();\n         let mut cols = 0;\n@@ -4956,7 +4956,7 @@ impl<'a> fmt::Display for Source<'a> {\n     }\n }\n \n-fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_macro(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n     wrap_into_docblock(w, |w| {\n         w.write_str(&highlight::render_with_highlighting(&t.source,\n@@ -4967,7 +4967,7 @@ fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)\n }\n \n-fn item_proc_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item, m: &clean::ProcMacro)\n+fn item_proc_macro(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item, m: &clean::ProcMacro)\n     -> fmt::Result\n {\n     let name = it.name.as_ref().expect(\"proc-macros always have names\");\n@@ -5000,14 +5000,14 @@ fn item_proc_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item, m: &c\n     document(w, cx, it)\n }\n \n-fn item_primitive(w: &mut fmt::Formatter, cx: &Context,\n+fn item_primitive(w: &mut fmt::Formatter<'_>, cx: &Context,\n                   it: &clean::Item,\n                   _p: &clean::PrimitiveType) -> fmt::Result {\n     document(w, cx, it)?;\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_keyword(w: &mut fmt::Formatter, cx: &Context,\n+fn item_keyword(w: &mut fmt::Formatter<'_>, cx: &Context,\n                 it: &clean::Item,\n                 _p: &str) -> fmt::Result {\n     document(w, cx, it)"}, {"sha": "409f2479ccc7c29317e2cbb83ac879789d3494ce", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -166,13 +166,13 @@ impl TocBuilder {\n }\n \n impl fmt::Debug for Toc {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(self, f)\n     }\n }\n \n impl fmt::Display for Toc {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(fmt, \"<ul>\")?;\n         for entry in &self.entries {\n             // recursively format this table of contents (the"}, {"sha": "5e9f9ee9f80af7e2dd81ffbf1a68fe22b333c7ef", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rust_2018_idioms)]\n+\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\")]\n \n@@ -17,7 +19,6 @@\n \n #![recursion_limit=\"256\"]\n \n-extern crate arena;\n extern crate getopts;\n extern crate env_logger;\n extern crate rustc;\n@@ -35,10 +36,6 @@ extern crate syntax_pos;\n extern crate test as testing;\n #[macro_use] extern crate log;\n extern crate rustc_errors as errors;\n-extern crate pulldown_cmark;\n-extern crate tempfile;\n-extern crate minifier;\n-extern crate parking_lot;\n \n extern crate serialize as rustc_serialize; // used by deriving\n "}, {"sha": "0014d9ceb5ba2b7f5af947e3894d3c6f13f7deb6", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -1,4 +1,3 @@\n-use std::default::Default;\n use std::fs::File;\n use std::io::prelude::*;\n use std::path::PathBuf;\n@@ -9,13 +8,12 @@ use testing;\n use syntax::source_map::DUMMY_SP;\n use syntax::feature_gate::UnstableFeatures;\n \n-use externalfiles::{LoadStringError, load_string};\n-\n-use config::{Options, RenderOptions};\n-use html::escape::Escape;\n-use html::markdown;\n-use html::markdown::{ErrorCodes, IdMap, Markdown, MarkdownWithToc, find_testable_code};\n-use test::{TestOptions, Collector};\n+use crate::externalfiles::{LoadStringError, load_string};\n+use crate::config::{Options, RenderOptions};\n+use crate::html::escape::Escape;\n+use crate::html::markdown;\n+use crate::html::markdown::{ErrorCodes, IdMap, Markdown, MarkdownWithToc, find_testable_code};\n+use crate::test::{TestOptions, Collector};\n \n /// Separate any lines at the start of the file that begin with `# ` or `%`.\n fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {"}, {"sha": "f960374370e043ef193d7706d4ad102f32d00a7c", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -4,17 +4,17 @@ use syntax::parse::{ParseSess, token};\n use syntax::source_map::FilePathMapping;\n use syntax_pos::FileName;\n \n-use clean;\n-use core::DocContext;\n-use fold::DocFolder;\n-use html::markdown::{self, RustCodeBlock};\n-use passes::Pass;\n+use crate::clean;\n+use crate::core::DocContext;\n+use crate::fold::DocFolder;\n+use crate::html::markdown::{self, RustCodeBlock};\n+use crate::passes::Pass;\n \n pub const CHECK_CODE_BLOCK_SYNTAX: Pass =\n     Pass::early(\"check-code-block-syntax\", check_code_block_syntax,\n                 \"validates syntax inside Rust code blocks\");\n \n-pub fn check_code_block_syntax(krate: clean::Crate, cx: &DocContext) -> clean::Crate {\n+pub fn check_code_block_syntax(krate: clean::Crate, cx: &DocContext<'_, '_, '_>) -> clean::Crate {\n     SyntaxChecker { cx }.fold_crate(krate)\n }\n "}, {"sha": "e5e60cbe717001e1f446673e515a9ca7955aa10b", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -1,7 +1,8 @@\n-use clean::{self, DocFragment, Item};\n-use fold;\n-use fold::DocFolder;\n-use passes::Pass;\n+use crate::clean::{self, DocFragment, Item};\n+use crate::fold;\n+use crate::fold::{DocFolder};\n+use crate::passes::Pass;\n+\n use std::mem::replace;\n \n pub const COLLAPSE_DOCS: Pass ="}, {"sha": "cf2c3aa484600244202163a533109c27daf88feb", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -10,19 +10,19 @@ use syntax_pos::DUMMY_SP;\n \n use std::ops::Range;\n \n-use core::DocContext;\n-use fold::DocFolder;\n-use html::markdown::markdown_links;\n+use crate::core::DocContext;\n+use crate::fold::DocFolder;\n+use crate::html::markdown::markdown_links;\n+use crate::clean::*;\n+use crate::passes::{look_for_tests, Pass};\n \n-use clean::*;\n-use passes::{look_for_tests, Pass};\n use super::span_of_attrs;\n \n pub const COLLECT_INTRA_DOC_LINKS: Pass =\n     Pass::early(\"collect-intra-doc-links\", collect_intra_doc_links,\n                 \"reads a crate's documentation to resolve intra-doc-links\");\n \n-pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext) -> Crate {\n+pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_, '_, '_>) -> Crate {\n     if !UnstableFeatures::from_environment().is_nightly_build() {\n         krate\n     } else {\n@@ -423,7 +423,7 @@ impl<'a, 'tcx, 'rcx> DocFolder for LinkCollector<'a, 'tcx, 'rcx> {\n }\n \n /// Resolves a string as a macro.\n-fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n+fn macro_resolve(cx: &DocContext<'_, '_, '_>, path_str: &str) -> Option<Def> {\n     use syntax::ext::base::{MacroKind, SyntaxExtension};\n     let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n     let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n@@ -451,7 +451,7 @@ fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n /// documentation attributes themselves. This is a little heavy-handed, so we display the markdown\n /// line containing the failure as a note as well.\n fn resolution_failure(\n-    cx: &DocContext,\n+    cx: &DocContext<'_, '_, '_>,\n     attrs: &Attributes,\n     path_str: &str,\n     dox: &str,\n@@ -493,7 +493,7 @@ fn resolution_failure(\n     diag.emit();\n }\n \n-fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n+fn ambiguity_error(cx: &DocContext<'_, '_, '_>, attrs: &Attributes,\n                    path_str: &str,\n                    article1: &str, kind1: &str, disambig1: &str,\n                    article2: &str, kind2: &str, disambig2: &str) {\n@@ -549,7 +549,7 @@ fn type_ns_kind(def: Def, path_str: &str) -> (&'static str, &'static str, String\n }\n \n /// Given an enum variant's def, return the def of its enum and the associated fragment.\n-fn handle_variant(cx: &DocContext, def: Def) -> Result<(Def, Option<String>), ()> {\n+fn handle_variant(cx: &DocContext<'_, '_, '_>, def: Def) -> Result<(Def, Option<String>), ()> {\n     use rustc::ty::DefIdTree;\n \n     let parent = if let Some(parent) = cx.tcx.parent(def.def_id()) {"}, {"sha": "903cce3bc032a3a6e6065a8176efe2e503310033", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -1,17 +1,16 @@\n-use clean::*;\n+use crate::clean::*;\n+use crate::core::DocContext;\n+use crate::fold::DocFolder;\n+use super::Pass;\n \n use rustc::util::nodemap::FxHashSet;\n use rustc::hir::def_id::DefId;\n \n-use super::Pass;\n-use core::DocContext;\n-use fold::DocFolder;\n-\n pub const COLLECT_TRAIT_IMPLS: Pass =\n     Pass::early(\"collect-trait-impls\", collect_trait_impls,\n                 \"retrieves trait impls for items in the crate\");\n \n-pub fn collect_trait_impls(krate: Crate, cx: &DocContext) -> Crate {\n+pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_, '_, '_>) -> Crate {\n     let mut synth = SyntheticImplCollector::new(cx);\n     let mut krate = synth.fold_crate(krate);\n "}, {"sha": "4d7fef7a76a9fe936dadc75ebb248692ed6af387", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -11,12 +11,10 @@ use syntax::ast::NodeId;\n use syntax_pos::{DUMMY_SP, Span};\n use std::ops::Range;\n \n-use clean::{self, GetDefId, Item};\n-use core::{DocContext, DocAccessLevels};\n-use fold;\n-use fold::StripItem;\n-\n-use html::markdown::{find_testable_code, ErrorCodes, LangString};\n+use crate::clean::{self, GetDefId, Item};\n+use crate::core::{DocContext, DocAccessLevels};\n+use crate::fold::{DocFolder, StripItem};\n+use crate::html::markdown::{find_testable_code, ErrorCodes, LangString};\n \n mod collapse_docs;\n pub use self::collapse_docs::COLLAPSE_DOCS;\n@@ -55,7 +53,7 @@ pub enum Pass {\n     /// traits and the like.\n     EarlyPass {\n         name: &'static str,\n-        pass: fn(clean::Crate, &DocContext) -> clean::Crate,\n+        pass: fn(clean::Crate, &DocContext<'_, '_, '_>) -> clean::Crate,\n         description: &'static str,\n     },\n     /// A \"late pass\" is run between crate cleaning and page generation.\n@@ -67,7 +65,7 @@ pub enum Pass {\n }\n \n impl fmt::Debug for Pass {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut dbg = match *self {\n             Pass::EarlyPass { .. } => f.debug_struct(\"EarlyPass\"),\n             Pass::LatePass { .. } => f.debug_struct(\"LatePass\"),\n@@ -83,7 +81,7 @@ impl fmt::Debug for Pass {\n impl Pass {\n     /// Constructs a new early pass.\n     pub const fn early(name: &'static str,\n-                       pass: fn(clean::Crate, &DocContext) -> clean::Crate,\n+                       pass: fn(clean::Crate, &DocContext<'_, '_, '_>) -> clean::Crate,\n                        description: &'static str) -> Pass {\n         Pass::EarlyPass { name, pass, description }\n     }\n@@ -112,7 +110,7 @@ impl Pass {\n     }\n \n     /// If this pass is an early pass, returns the pointer to its function.\n-    pub fn early_fn(self) -> Option<fn(clean::Crate, &DocContext) -> clean::Crate> {\n+    pub fn early_fn(self) -> Option<fn(clean::Crate, &DocContext<'_, '_, '_>) -> clean::Crate> {\n         match self {\n             Pass::EarlyPass { pass, .. } => Some(pass),\n             _ => None,\n@@ -196,7 +194,7 @@ struct Stripper<'a> {\n     update_retained: bool,\n }\n \n-impl<'a> fold::DocFolder for Stripper<'a> {\n+impl<'a> DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n             clean::StrippedItem(..) => {\n@@ -308,7 +306,7 @@ struct ImplStripper<'a> {\n     retained: &'a DefIdSet,\n }\n \n-impl<'a> fold::DocFolder for ImplStripper<'a> {\n+impl<'a> DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = i.inner {\n             // emptied none trait impls can be stripped\n@@ -345,7 +343,7 @@ impl<'a> fold::DocFolder for ImplStripper<'a> {\n \n // This stripper discards all private import statements (`use`, `extern crate`)\n struct ImportStripper;\n-impl fold::DocFolder for ImportStripper {\n+impl DocFolder for ImportStripper {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n             clean::ExternCrateItem(..) | clean::ImportItem(..)\n@@ -373,7 +371,7 @@ pub fn look_for_tests<'a, 'tcx: 'a, 'rcx: 'a>(\n         found_tests: usize,\n     }\n \n-    impl ::test::Tester for Tests {\n+    impl crate::test::Tester for Tests {\n         fn add_test(&mut self, _: String, _: LangString, _: usize) {\n             self.found_tests += 1;\n         }\n@@ -420,7 +418,7 @@ crate fn span_of_attrs(attrs: &clean::Attributes) -> Span {\n /// attributes are not all sugared doc comments. It's difficult to calculate the correct span in\n /// that case due to escaping and other source features.\n crate fn source_span_for_markdown_range(\n-    cx: &DocContext,\n+    cx: &DocContext<'_, '_, '_>,\n     markdown: &str,\n     md_range: &Range<usize>,\n     attrs: &clean::Attributes,"}, {"sha": "819d15f65e8ef33678d14946e7371ce57270c22b", "filename": "src/librustdoc/passes/private_items_doc_tests.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fprivate_items_doc_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fprivate_items_doc_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fprivate_items_doc_tests.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -1,9 +1,8 @@\n-use clean::*;\n+use crate::clean::*;\n+use crate::core::DocContext;\n+use crate::fold::DocFolder;\n+use crate::passes::{look_for_tests, Pass};\n \n-use core::DocContext;\n-use fold::DocFolder;\n-\n-use passes::{look_for_tests, Pass};\n \n pub const CHECK_PRIVATE_ITEMS_DOC_TESTS: Pass =\n     Pass::early(\"check-private-items-doc-tests\", check_private_items_doc_tests,\n@@ -21,7 +20,7 @@ impl<'a, 'tcx, 'rcx> PrivateItemDocTestLinter<'a, 'tcx, 'rcx> {\n     }\n }\n \n-pub fn check_private_items_doc_tests(krate: Crate, cx: &DocContext) -> Crate {\n+pub fn check_private_items_doc_tests(krate: Crate, cx: &DocContext<'_, '_, '_>) -> Crate {\n     let mut coll = PrivateItemDocTestLinter::new(cx);\n \n     coll.fold_crate(krate)"}, {"sha": "9ba0b2272869125acde15fbc77223ccf5067dedd", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -1,9 +1,9 @@\n use std::sync::Arc;\n \n-use clean::{Crate, Item};\n-use clean::cfg::Cfg;\n-use fold::DocFolder;\n-use passes::Pass;\n+use crate::clean::{Crate, Item};\n+use crate::clean::cfg::Cfg;\n+use crate::fold::DocFolder;\n+use crate::passes::Pass;\n \n pub const PROPAGATE_DOC_CFG: Pass =\n     Pass::late(\"propagate-doc-cfg\", propagate_doc_cfg,"}, {"sha": "b3d50e06816c5cc8d07b4d6fabeaefaed081a3d1", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -1,20 +1,18 @@\n use rustc::util::nodemap::DefIdSet;\n use std::mem;\n \n-use clean::{self, AttributesExt, NestedAttributesExt};\n-use clean::Item;\n-use core::DocContext;\n-use fold;\n-use fold::DocFolder;\n-use fold::StripItem;\n-use passes::{ImplStripper, Pass};\n+use crate::clean::{self, AttributesExt, NestedAttributesExt};\n+use crate::clean::Item;\n+use crate::core::DocContext;\n+use crate::fold::{DocFolder, StripItem};\n+use crate::passes::{ImplStripper, Pass};\n \n pub const STRIP_HIDDEN: Pass =\n     Pass::early(\"strip-hidden\", strip_hidden,\n                 \"strips all doc(hidden) items from the output\");\n \n /// Strip items marked `#[doc(hidden)]`\n-pub fn strip_hidden(krate: clean::Crate, _: &DocContext) -> clean::Crate {\n+pub fn strip_hidden(krate: clean::Crate, _: &DocContext<'_, '_, '_>) -> clean::Crate {\n     let mut retained = DefIdSet::default();\n \n     // strip all #[doc(hidden)] items\n@@ -35,7 +33,7 @@ struct Stripper<'a> {\n     update_retained: bool,\n }\n \n-impl<'a> fold::DocFolder for Stripper<'a> {\n+impl<'a> DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.attrs.lists(\"doc\").has_word(\"hidden\") {\n             debug!(\"strip_hidden: stripping {} {:?}\", i.type_(), i.name);"}, {"sha": "3af1403e8749cc251248a76091392534d17afefe", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -1,11 +1,11 @@\n-use clean;\n-use core::DocContext;\n-use fold::DocFolder;\n-use passes::{ImportStripper, Pass};\n+use crate::clean;\n+use crate::fold::{DocFolder};\n+use crate::core::DocContext;\n+use crate::passes::{ImportStripper, Pass};\n \n pub const STRIP_PRIV_IMPORTS: Pass = Pass::early(\"strip-priv-imports\", strip_priv_imports,\n      \"strips all private import statements (`use`, `extern crate`) from a crate\");\n \n-pub fn strip_priv_imports(krate: clean::Crate, _: &DocContext)  -> clean::Crate {\n+pub fn strip_priv_imports(krate: clean::Crate, _: &DocContext<'_, '_, '_>)  -> clean::Crate {\n     ImportStripper.fold_crate(krate)\n }"}, {"sha": "e553d792eb697329fe683bff733468cc988368d6", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -1,9 +1,9 @@\n use rustc::util::nodemap::DefIdSet;\n \n-use clean;\n-use core::DocContext;\n-use fold::DocFolder;\n-use passes::{ImplStripper, ImportStripper, Stripper, Pass};\n+use crate::clean;\n+use crate::fold::{DocFolder};\n+use crate::core::DocContext;\n+use crate::passes::{ImplStripper, ImportStripper, Stripper, Pass};\n \n pub const STRIP_PRIVATE: Pass =\n     Pass::early(\"strip-private\", strip_private,\n@@ -12,7 +12,7 @@ pub const STRIP_PRIVATE: Pass =\n \n /// Strip private items from the point of view of a crate or externally from a\n /// crate, specified by the `xcrate` flag.\n-pub fn strip_private(mut krate: clean::Crate, cx: &DocContext) -> clean::Crate {\n+pub fn strip_private(mut krate: clean::Crate, cx: &DocContext<'_, '_, '_>) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n     let mut retained = DefIdSet::default();\n     let access_levels = cx.renderinfo.borrow().access_levels.clone();"}, {"sha": "269e4cbe65f8bbb98a8307a9fd8cb3d1907e7d15", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -2,9 +2,9 @@ use std::cmp;\n use std::string::String;\n use std::usize;\n \n-use clean::{self, DocFragment, Item};\n-use fold::{self, DocFolder};\n-use passes::Pass;\n+use crate::clean::{self, DocFragment, Item};\n+use crate::fold::{self, DocFolder};\n+use crate::passes::Pass;\n \n pub const UNINDENT_COMMENTS: Pass =\n     Pass::late(\"unindent-comments\", unindent_comments,"}, {"sha": "3fdded6a4ab386fa0f7a1c93bc88bcc661fd9627", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -28,9 +28,9 @@ use std::process::Command;\n use std::str;\n use std::sync::{Arc, Mutex};\n \n-use clean::Attributes;\n-use config::Options;\n-use html::markdown::{self, ErrorCodes, LangString};\n+use crate::clean::Attributes;\n+use crate::config::Options;\n+use crate::html::markdown::{self, ErrorCodes, LangString};\n \n #[derive(Clone, Default)]\n pub struct TestOptions {"}, {"sha": "2428a823d0b39d81c6585f53c824b7ad9d2bedbb", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -14,9 +14,10 @@ use syntax_pos::{self, Span};\n \n use std::mem;\n \n-use core;\n-use clean::{self, AttributesExt, NestedAttributesExt, def_id_to_path};\n-use doctree::*;\n+use crate::core;\n+use crate::clean::{self, AttributesExt, NestedAttributesExt, def_id_to_path};\n+use crate::doctree::*;\n+\n \n // Looks to me like the first two of these are actually\n // output parameters, maybe only mutated once; perhaps\n@@ -268,7 +269,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                           om: &mut Module,\n                           please_inline: bool) -> bool {\n \n-        fn inherits_doc_hidden(cx: &core::DocContext, mut node: ast::NodeId) -> bool {\n+        fn inherits_doc_hidden(cx: &core::DocContext<'_, '_, '_>, mut node: ast::NodeId) -> bool {\n             while let Some(id) = cx.tcx.hir().get_enclosing_scope(node) {\n                 node = id;\n                 if cx.tcx.hir().attrs(node).lists(\"doc\").has_word(\"hidden\") {\n@@ -315,7 +316,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                         .insert(did, AccessLevel::Public);\n                 },\n                 Def::Mod(did) => if !self_is_hidden {\n-                    ::visit_lib::LibEmbargoVisitor::new(self.cx).visit_mod(did);\n+                    crate::visit_lib::LibEmbargoVisitor::new(self.cx).visit_mod(did);\n                 },\n                 _ => {},\n             }"}, {"sha": "f538c58c213ee203ec17d80336c04a4ee3809513", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=1932d7a52d8cdfdadbf165f2340de45e9e9ef9e2", "patch": "@@ -6,14 +6,14 @@ use rustc::util::nodemap::FxHashSet;\n \n use std::cell::RefMut;\n \n-use clean::{AttributesExt, NestedAttributesExt};\n+use crate::clean::{AttributesExt, NestedAttributesExt};\n \n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n \n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n pub struct LibEmbargoVisitor<'a, 'tcx: 'a, 'rcx: 'a> {\n-    cx: &'a ::core::DocContext<'a, 'tcx, 'rcx>,\n+    cx: &'a crate::core::DocContext<'a, 'tcx, 'rcx>,\n     // Accessibility levels for reachable nodes\n     access_levels: RefMut<'a, AccessLevels<DefId>>,\n     // Previous accessibility level, None means unreachable\n@@ -24,7 +24,7 @@ pub struct LibEmbargoVisitor<'a, 'tcx: 'a, 'rcx: 'a> {\n \n impl<'a, 'tcx, 'rcx> LibEmbargoVisitor<'a, 'tcx, 'rcx> {\n     pub fn new(\n-        cx: &'a ::core::DocContext<'a, 'tcx, 'rcx>\n+        cx: &'a crate::core::DocContext<'a, 'tcx, 'rcx>\n     ) -> LibEmbargoVisitor<'a, 'tcx, 'rcx> {\n         LibEmbargoVisitor {\n             cx,"}]}