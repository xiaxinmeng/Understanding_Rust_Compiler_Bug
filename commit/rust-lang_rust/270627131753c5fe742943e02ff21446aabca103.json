{"sha": "270627131753c5fe742943e02ff21446aabca103", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MDYyNzEzMTc1M2M1ZmU3NDI5NDNlMDJmZjIxNDQ2YWFiY2ExMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-25T21:13:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-25T21:13:55Z"}, "message": "auto merge of #6732 : Aatch/rust/atomic-types, r=brson\n\nThis pull request is more of an RFC than a finished implementation.\r\n\r\nIt adds some basic atomic types, with an interface modelled off of C++11's atomic types.\r\n\r\nIt also adds free functions that provide a slightly nicer interface for atomic operations, though they are unsafe because there isn't a way to be generic over \"word-sized\" types.\r\n\r\nSee also #5042", "tree": {"sha": "c82d64feffc692126df64dbadcdfe028244f8843", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c82d64feffc692126df64dbadcdfe028244f8843"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/270627131753c5fe742943e02ff21446aabca103", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/270627131753c5fe742943e02ff21446aabca103", "html_url": "https://github.com/rust-lang/rust/commit/270627131753c5fe742943e02ff21446aabca103", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/270627131753c5fe742943e02ff21446aabca103/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d37d038fef95408bffadc8701adcd7b5a663894", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d37d038fef95408bffadc8701adcd7b5a663894", "html_url": "https://github.com/rust-lang/rust/commit/9d37d038fef95408bffadc8701adcd7b5a663894"}, {"sha": "523360415cca24ac0cbd198804d797dd05c48559", "url": "https://api.github.com/repos/rust-lang/rust/commits/523360415cca24ac0cbd198804d797dd05c48559", "html_url": "https://github.com/rust-lang/rust/commit/523360415cca24ac0cbd198804d797dd05c48559"}], "stats": {"total": 344, "additions": 344, "deletions": 0}, "files": [{"sha": "09febfebaac02a86921bd98c1118a7d906a61e80", "filename": "src/libstd/unstable/atomics.rs", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/270627131753c5fe742943e02ff21446aabca103/src%2Flibstd%2Funstable%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270627131753c5fe742943e02ff21446aabca103/src%2Flibstd%2Funstable%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fatomics.rs?ref=270627131753c5fe742943e02ff21446aabca103", "patch": "@@ -0,0 +1,343 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Atomic types\n+ */\n+\n+use unstable::intrinsics;\n+use cast;\n+use option::{Option,Some,None};\n+\n+pub struct AtomicFlag {\n+    priv v:int\n+}\n+\n+pub struct AtomicBool {\n+    priv v:uint\n+}\n+\n+pub struct AtomicInt {\n+    priv v:int\n+}\n+\n+pub struct AtomicUint {\n+    priv v:uint\n+}\n+\n+pub struct AtomicPtr<T> {\n+    priv p:~T\n+}\n+\n+pub enum Ordering {\n+    Release,\n+    Acquire,\n+    SeqCst\n+}\n+\n+\n+impl AtomicFlag {\n+\n+    fn new() -> AtomicFlag {\n+        AtomicFlag { v: 0 }\n+    }\n+\n+    /**\n+     * Clears the atomic flag\n+     */\n+    #[inline(always)]\n+    fn clear(&mut self, order:Ordering) {\n+        unsafe {atomic_store(&mut self.v, 0, order)}\n+    }\n+\n+    #[inline(always)]\n+    /**\n+     * Sets the flag if it was previously unset, returns the previous value of the\n+     * flag.\n+     */\n+    fn test_and_set(&mut self, order:Ordering) -> bool {\n+        unsafe {atomic_compare_and_swap(&mut self.v, 0, 1, order) > 0}\n+    }\n+}\n+\n+impl AtomicBool {\n+    fn new(v:bool) -> AtomicBool {\n+        AtomicBool { v: if v { 1 } else { 0 } }\n+    }\n+\n+    #[inline(always)]\n+    fn load(&self, order:Ordering) -> bool {\n+        unsafe { atomic_load(&self.v, order) > 0 }\n+    }\n+\n+    #[inline(always)]\n+    fn store(&mut self, val:bool, order:Ordering) {\n+        let val = if val { 1 } else { 0 };\n+\n+        unsafe { atomic_store(&mut self.v, val, order); }\n+    }\n+\n+    #[inline(always)]\n+    fn swap(&mut self, val:bool, order:Ordering) -> bool {\n+        let val = if val { 1 } else { 0 };\n+\n+        unsafe { atomic_swap(&mut self.v, val, order) > 0}\n+    }\n+\n+    #[inline(always)]\n+    fn compare_and_swap(&mut self, old: bool, new: bool, order:Ordering) -> bool {\n+        let old = if old { 1 } else { 0 };\n+        let new = if new { 1 } else { 0 };\n+\n+        unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) > 0 }\n+    }\n+}\n+\n+impl AtomicInt {\n+    fn new(v:int) -> AtomicInt {\n+        AtomicInt { v:v }\n+    }\n+\n+    #[inline(always)]\n+    fn load(&self, order:Ordering) -> int {\n+        unsafe { atomic_load(&self.v, order) }\n+    }\n+\n+    #[inline(always)]\n+    fn store(&mut self, val:int, order:Ordering) {\n+        unsafe { atomic_store(&mut self.v, val, order); }\n+    }\n+\n+    #[inline(always)]\n+    fn swap(&mut self, val:int, order:Ordering) -> int {\n+        unsafe { atomic_swap(&mut self.v, val, order) }\n+    }\n+\n+    #[inline(always)]\n+    fn compare_and_swap(&mut self, old: int, new: int, order:Ordering) -> int {\n+        unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n+    }\n+\n+    #[inline(always)]\n+    fn fetch_add(&mut self, val:int, order:Ordering) -> int {\n+        unsafe { atomic_add(&mut self.v, val, order) }\n+    }\n+\n+    #[inline(always)]\n+    fn fetch_sub(&mut self, val:int, order:Ordering) -> int {\n+        unsafe { atomic_sub(&mut self.v, val, order) }\n+    }\n+}\n+\n+impl AtomicUint {\n+    fn new(v:uint) -> AtomicUint {\n+        AtomicUint { v:v }\n+    }\n+\n+    #[inline(always)]\n+    fn load(&self, order:Ordering) -> uint {\n+        unsafe { atomic_load(&self.v, order) }\n+    }\n+\n+    #[inline(always)]\n+    fn store(&mut self, val:uint, order:Ordering) {\n+        unsafe { atomic_store(&mut self.v, val, order); }\n+    }\n+\n+    #[inline(always)]\n+    fn swap(&mut self, val:uint, order:Ordering) -> uint {\n+        unsafe { atomic_swap(&mut self.v, val, order) }\n+    }\n+\n+    #[inline(always)]\n+    fn compare_and_swap(&mut self, old: uint, new: uint, order:Ordering) -> uint {\n+        unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n+    }\n+\n+    #[inline(always)]\n+    fn fetch_add(&mut self, val:uint, order:Ordering) -> uint {\n+        unsafe { atomic_add(&mut self.v, val, order) }\n+    }\n+\n+    #[inline(always)]\n+    fn fetch_sub(&mut self, val:uint, order:Ordering) -> uint {\n+        unsafe { atomic_sub(&mut self.v, val, order) }\n+    }\n+}\n+\n+impl<T> AtomicPtr<T> {\n+    fn new(p:~T) -> AtomicPtr<T> {\n+        AtomicPtr { p:p }\n+    }\n+\n+    /**\n+     * Atomically swaps the stored pointer with the one given.\n+     *\n+     * Returns None if the pointer stored has been taken\n+     */\n+    #[inline(always)]\n+    fn swap(&mut self, ptr:~T, order:Ordering) -> Option<~T> {\n+        unsafe {\n+            let p = atomic_swap(&mut self.p, ptr, order);\n+            let pv : &uint = cast::transmute(&p);\n+\n+            if *pv == 0 {\n+                None\n+            } else {\n+                Some(p)\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Atomically takes the stored pointer out.\n+     *\n+     * Returns None if it was already taken.\n+     */\n+    #[inline(always)]\n+    fn take(&mut self, order:Ordering) -> Option<~T> {\n+        unsafe { self.swap(cast::transmute(0), order) }\n+    }\n+\n+    /**\n+     * Atomically stores the given pointer, this will overwrite\n+     * and previous value stored.\n+     */\n+    #[inline(always)]\n+    fn give(&mut self, ptr:~T, order:Ordering) {\n+        let _ = self.swap(ptr, order);\n+    }\n+\n+    /**\n+     * Checks to see if the stored pointer has been taken.\n+     */\n+    fn taken(&self, order:Ordering) -> bool {\n+        unsafe {\n+            let p : ~T = atomic_load(&self.p, order);\n+\n+            let pv : &uint = cast::transmute(&p);\n+\n+            cast::forget(p);\n+            *pv == 0\n+        }\n+    }\n+}\n+\n+#[inline(always)]\n+pub unsafe fn atomic_store<T>(dst: &mut T, val: T, order:Ordering) {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    match order {\n+        Release => intrinsics::atomic_store_rel(dst, val),\n+        _       => intrinsics::atomic_store(dst, val)\n+    }\n+}\n+\n+#[inline(always)]\n+pub unsafe fn atomic_load<T>(dst: &T, order:Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_load_acq(dst),\n+        _       => intrinsics::atomic_load(dst)\n+    })\n+}\n+\n+#[inline(always)]\n+pub unsafe fn atomic_swap<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_xchg_acq(dst, val),\n+        Release => intrinsics::atomic_xchg_rel(dst, val),\n+        _       => intrinsics::atomic_xchg(dst, val)\n+    })\n+}\n+\n+#[inline(always)]\n+pub unsafe fn atomic_add<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_xadd_acq(dst, val),\n+        Release => intrinsics::atomic_xadd_rel(dst, val),\n+        _       => intrinsics::atomic_xadd(dst, val)\n+    })\n+}\n+\n+#[inline(always)]\n+pub unsafe fn atomic_sub<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_xsub_acq(dst, val),\n+        Release => intrinsics::atomic_xsub_rel(dst, val),\n+        _       => intrinsics::atomic_xsub(dst, val)\n+    })\n+}\n+\n+#[inline(always)]\n+pub unsafe fn atomic_compare_and_swap<T>(dst:&mut T, old:T, new:T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let old = cast::transmute(old);\n+    let new = cast::transmute(new);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n+        Release => intrinsics::atomic_cxchg_rel(dst, old, new),\n+        _       => intrinsics::atomic_cxchg(dst, old, new),\n+    })\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use option::*;\n+    use super::*;\n+\n+    #[test]\n+    fn flag() {\n+        let mut flg = AtomicFlag::new();\n+        assert!(!flg.test_and_set(SeqCst));\n+        assert!(flg.test_and_set(SeqCst));\n+\n+        flg.clear(SeqCst);\n+        assert!(!flg.test_and_set(SeqCst));\n+    }\n+\n+    #[test]\n+    fn pointer_swap() {\n+        let mut p = AtomicPtr::new(~1);\n+        let a = ~2;\n+\n+        let b = p.swap(a, SeqCst);\n+\n+        assert_eq!(b, Some(~1));\n+        assert_eq!(p.take(SeqCst), Some(~2));\n+    }\n+\n+    #[test]\n+    fn pointer_take() {\n+        let mut p = AtomicPtr::new(~1);\n+\n+        assert_eq!(p.take(SeqCst), Some(~1));\n+        assert_eq!(p.take(SeqCst), None);\n+        assert!(p.taken(SeqCst));\n+\n+        let p2 = ~2;\n+        p.give(p2, SeqCst);\n+\n+        assert_eq!(p.take(SeqCst), Some(~2));\n+    }\n+\n+}"}, {"sha": "afdc22a1c63e9c537bad3ddf13fc7895b23fb7a6", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/270627131753c5fe742943e02ff21446aabca103/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270627131753c5fe742943e02ff21446aabca103/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=270627131753c5fe742943e02ff21446aabca103", "patch": "@@ -25,6 +25,7 @@ pub mod extfmt;\n #[cfg(not(test))]\n pub mod lang;\n pub mod sync;\n+pub mod atomics;\n \n /**\n "}]}