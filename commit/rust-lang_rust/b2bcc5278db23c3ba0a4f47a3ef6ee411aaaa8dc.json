{"sha": "b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYmNjNTI3OGRiMjNjM2JhMGE0ZjQ3YTNlZjZlZTQxMWFhYWE4ZGM=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-09-05T22:41:18Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-09-09T22:42:20Z"}, "message": "Properly handle special cases (binaries, mod.rs)", "tree": {"sha": "a113b1ab197ca991144bb08d56cbde94d461f57b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a113b1ab197ca991144bb08d56cbde94d461f57b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc", "html_url": "https://github.com/rust-lang/rust/commit/b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "486c5c3285682408b125613475a34a0bc9a2c097", "url": "https://api.github.com/repos/rust-lang/rust/commits/486c5c3285682408b125613475a34a0bc9a2c097", "html_url": "https://github.com/rust-lang/rust/commit/486c5c3285682408b125613475a34a0bc9a2c097"}], "stats": {"total": 112, "additions": 60, "deletions": 52}, "files": [{"sha": "030b96829875da86bb1711ce1cb0052ef1d38d73", "filename": "crates/base_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc/crates%2Fbase_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc/crates%2Fbase_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Flib.rs?ref=b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc", "patch": "@@ -167,29 +167,7 @@ impl<T: SourceDatabaseExt> FileLoader for FileLoaderDelegate<&'_ T> {\n     }\n \n     fn possible_sudmobule_names(&self, module_file: FileId) -> Vec<String> {\n-        let module_files = &self.source_root(module_file).file_set;\n-        let possible_submodule_files = match module_files.file_name_and_extension(module_file) {\n-            Some((\"mod\", Some(\"rs\"))) | Some((\"lib\", Some(\"rs\"))) => {\n-                module_files.list_files_with_extensions(module_file, None)\n-            }\n-            // TODO kb for `src/bin/foo.rs`, we need to check for modules in `src/bin/`\n-            Some((directory_with_module_name, Some(\"rs\"))) => module_files\n-                .list_files_with_extensions(\n-                    module_file,\n-                    Some(&format!(\"../{}/\", directory_with_module_name)),\n-                ),\n-            // TODO kb also consider the case when there's no `../module_name.rs`, but `../module_name/mod.rs`\n-            _ => Vec::new(),\n-        };\n-\n-        possible_submodule_files\n-            .into_iter()\n-            .filter(|(_, extension)| extension == &Some(\"rs\"))\n-            .filter(|(file_name, _)| file_name != &\"mod\")\n-            .filter(|(file_name, _)| file_name != &\"lib\")\n-            .filter(|(file_name, _)| file_name != &\"main\")\n-            .map(|(file_name, _)| file_name.to_owned())\n-            .collect()\n+        self.source_root(module_file).file_set.possible_sudmobule_names(module_file)\n     }\n }\n "}, {"sha": "a8fe44083846879c5881030ea8715a4a03ed99fc", "filename": "crates/ide/src/completion/completion_context.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc", "patch": "@@ -1,7 +1,7 @@\n //! FIXME: write short doc here\n \n use base_db::{FileLoader, SourceDatabase};\n-use hir::{ModuleSource, Semantics, SemanticsScope, Type};\n+use hir::{Semantics, SemanticsScope, Type};\n use ide_db::RootDatabase;\n use syntax::{\n     algo::{find_covering_element, find_node_at_offset},\n@@ -123,11 +123,9 @@ impl<'a> CompletionContext<'a> {\n                     dbg!(mod_declaration_candidates);\n                     // TODO kb exlude existing children from the candidates\n                     let existing_children = current_module.children(db).collect::<Vec<_>>();\n-                    dbg!(existing_children);\n                     None::<Vec<String>>\n                 })\n                 .unwrap_or_default();\n-            dbg!(module_names_for_import);\n         };\n \n         let krate = sema.to_module_def(position.file_id).map(|m| m.krate());"}, {"sha": "cb65c17e037d2d9645698bb29cd09128ac7d9177", "filename": "crates/vfs/src/file_set.rs", "status": "modified", "additions": 58, "deletions": 26, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Ffile_set.rs?ref=b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc", "patch": "@@ -26,38 +26,70 @@ impl FileSet {\n         self.files.get(&path).copied()\n     }\n \n-    pub fn file_name_and_extension(&self, file: FileId) -> Option<(&str, Option<&str>)> {\n-        self.paths[&file].file_name_and_extension()\n-    }\n-\n-    pub fn list_files_with_extensions(\n-        &self,\n-        anchor: FileId,\n-        anchor_relative_path: Option<&str>,\n-    ) -> Vec<(&str, Option<&str>)> {\n-        let anchor_directory = {\n-            let path = self.paths[&anchor].clone();\n-            match anchor_relative_path {\n-                Some(anchor_relative_path) => path.join(anchor_relative_path),\n-                None => path.parent(),\n-            }\n+    pub fn possible_sudmobule_names(&self, module_file: FileId) -> Vec<String> {\n+        let directory_to_look_for_submodules = match self.get_directory_with_submodules(module_file)\n+        {\n+            Some(directory) => directory,\n+            None => return Vec::new(),\n         };\n-\n-        if let Some(anchor_directory) = anchor_directory {\n-            self.paths\n-                .iter()\n-                .filter_map(|(_, path)| {\n-                    if path.parent()? == anchor_directory {\n-                        path.file_name_and_extension()\n+        self.paths\n+            .iter()\n+            .filter_map(|(_, path)| {\n+                if path.parent()? == directory_to_look_for_submodules {\n+                    path.file_name_and_extension()\n+                } else {\n+                    None\n+                }\n+            })\n+            .filter_map(|file_name_and_extension| match file_name_and_extension {\n+                // TODO kb do not include the module file name itself, if present\n+                // TODO kb wrong resolution for nes\u0421\u043f\u0430ted non-file modules (mod tests {mod <|>)\n+                // TODO kb in src/bin when a module is included into another,\n+                // the included file gets \"moved\" into a directory below and now cannot add any other modules\n+                (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => None,\n+                (file_name, Some(\"rs\")) => Some(file_name.to_owned()),\n+                (subdirectory_name, None) => {\n+                    let mod_rs_path =\n+                        directory_to_look_for_submodules.join(subdirectory_name)?.join(\"mod.rs\")?;\n+                    if self.files.contains_key(&mod_rs_path) {\n+                        Some(subdirectory_name.to_owned())\n                     } else {\n                         None\n                     }\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n+                }\n+                _ => None,\n+            })\n+            .collect()\n+    }\n+\n+    fn get_directory_with_submodules(&self, module_file: FileId) -> Option<VfsPath> {\n+        let module_file_path = &self.paths[&module_file];\n+        let module_directory_path = module_file_path.parent()?;\n+        match module_file_path.file_name_and_extension() {\n+            Some((\"mod\", Some(\"rs\"))) | Some((\"lib\", Some(\"rs\"))) | Some((\"main\", Some(\"rs\"))) => {\n+                Some(module_directory_path)\n+            }\n+            Some((regular_rust_file_name, Some(\"rs\"))) => {\n+                if matches!(\n+                    (\n+                        module_directory_path\n+                            .parent()\n+                            .as_ref()\n+                            .and_then(|path| path.file_name_and_extension()),\n+                        module_directory_path.file_name_and_extension(),\n+                    ),\n+                    (Some((\"src\", None)), Some((\"bin\", None)))\n+                ) {\n+                    // files in /src/bin/ can import each other directly\n+                    Some(module_directory_path)\n+                } else {\n+                    module_directory_path.join(regular_rust_file_name)\n+                }\n+            }\n+            _ => None,\n         }\n     }\n+\n     pub fn insert(&mut self, file_id: FileId, path: VfsPath) {\n         self.files.insert(path.clone(), file_id);\n         self.paths.insert(file_id, path);"}]}