{"sha": "190adc0e193d9b7154b54b4800e2059acb72448b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MGFkYzBlMTkzZDliNzE1NGI1NGI0ODAwZTIwNTlhY2I3MjQ0OGI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-11-18T15:49:37Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-12-21T00:17:19Z"}, "message": "Properly check traits in type privacy", "tree": {"sha": "c7a7215f5a12b57449829329b3720c8411ef7266", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7a7215f5a12b57449829329b3720c8411ef7266"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/190adc0e193d9b7154b54b4800e2059acb72448b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/190adc0e193d9b7154b54b4800e2059acb72448b", "html_url": "https://github.com/rust-lang/rust/commit/190adc0e193d9b7154b54b4800e2059acb72448b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/190adc0e193d9b7154b54b4800e2059acb72448b/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53779ed5ec8077fd11d5ea9c3e0e1c404ee92c36", "url": "https://api.github.com/repos/rust-lang/rust/commits/53779ed5ec8077fd11d5ea9c3e0e1c404ee92c36", "html_url": "https://github.com/rust-lang/rust/commit/53779ed5ec8077fd11d5ea9c3e0e1c404ee92c36"}], "stats": {"total": 248, "additions": 155, "deletions": 93}, "files": [{"sha": "3a6fabc33ab5d7030fa3a56cbb71eb3dfef27b2b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/190adc0e193d9b7154b54b4800e2059acb72448b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190adc0e193d9b7154b54b4800e2059acb72448b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=190adc0e193d9b7154b54b4800e2059acb72448b", "patch": "@@ -258,8 +258,13 @@ impl Path {\n \n impl fmt::Debug for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"path({})\",\n-               print::to_string(print::NO_ANN, |s| s.print_path(self, false)))\n+        write!(f, \"path({})\", print::to_string(print::NO_ANN, |s| s.print_path(self, false)))\n+    }\n+}\n+\n+impl fmt::Display for Path {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", print::to_string(print::NO_ANN, |s| s.print_path(self, false)))\n     }\n }\n "}, {"sha": "906e584e0ecbcc5cb5020df9d226bd31e28167f1", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 59, "deletions": 29, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/190adc0e193d9b7154b54b4800e2059acb72448b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190adc0e193d9b7154b54b4800e2059acb72448b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=190adc0e193d9b7154b54b4800e2059acb72448b", "patch": "@@ -614,6 +614,7 @@ struct TypePrivacyVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     current_item: DefId,\n+    in_body: bool,\n     span: Span,\n     empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n@@ -671,10 +672,8 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n     // Take node ID of an expression or pattern and check its type for privacy.\n     fn check_expr_pat_type(&mut self, id: hir::HirId, span: Span) -> bool {\n         self.span = span;\n-        if let Some(ty) = self.tables.node_id_to_type_opt(id) {\n-            if ty.visit_with(self) {\n-                return true;\n-            }\n+        if self.tables.node_id_to_type(id).visit_with(self) {\n+            return true;\n         }\n         if self.tables.node_substs(id).visit_with(self) {\n             return true;\n@@ -688,6 +687,16 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n         }\n         false\n     }\n+\n+    fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n+        if !self.item_is_accessible(trait_ref.def_id) {\n+            let msg = format!(\"trait `{}` is private\", trait_ref);\n+            self.tcx.sess.span_err(self.span, &msg);\n+            return true;\n+        }\n+\n+        trait_ref.super_visit_with(self)\n+    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n@@ -699,16 +708,18 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let orig_tables = replace(&mut self.tables, self.tcx.body_tables(body));\n+        let orig_in_body = replace(&mut self.in_body, true);\n         let body = self.tcx.hir.body(body);\n         self.visit_body(body);\n         self.tables = orig_tables;\n+        self.in_body = orig_in_body;\n     }\n \n     fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty) {\n         self.span = hir_ty.span;\n-        if let Some(ty) = self.tables.node_id_to_type_opt(hir_ty.hir_id) {\n+        if self.in_body {\n             // Types in bodies.\n-            if ty.visit_with(self) {\n+            if self.tables.node_id_to_type(hir_ty.hir_id).visit_with(self) {\n                 return;\n             }\n         } else {\n@@ -724,10 +735,21 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef) {\n-        if !self.item_is_accessible(trait_ref.path.def.def_id()) {\n-            let msg = format!(\"trait `{:?}` is private\", trait_ref.path);\n-            self.tcx.sess.span_err(self.span, &msg);\n-            return;\n+        self.span = trait_ref.path.span;\n+        if !self.in_body {\n+            // Avoid calling `hir_trait_to_predicates` in bodies, it will ICE.\n+            // The traits' privacy in bodies is already checked as a part of trait object types.\n+            let (principal, projections) =\n+                rustc_typeck::hir_trait_to_predicates(self.tcx, trait_ref);\n+            if self.check_trait_ref(*principal.skip_binder()) {\n+                return;\n+            }\n+            for poly_predicate in projections {\n+                let tcx = self.tcx;\n+                if self.check_trait_ref(poly_predicate.skip_binder().projection_ty.trait_ref(tcx)) {\n+                    return;\n+                }\n+            }\n         }\n \n         intravisit::walk_trait_ref(self, trait_ref);\n@@ -760,19 +782,29 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n+    // Prohibit access to associated items with insufficient nominal visibility.\n     fn visit_qpath(&mut self, qpath: &'tcx hir::QPath, id: ast::NodeId, span: Span) {\n-        // Inherent associated constants don't have self type in substs,\n-        // we have to check it additionally.\n-        if let hir::QPath::TypeRelative(..) = *qpath {\n-            let hir_id = self.tcx.hir.node_to_hir_id(id);\n-            if let Some(def) = self.tables.type_dependent_defs().get(hir_id).cloned() {\n-                if let Some(assoc_item) = self.tcx.opt_associated_item(def.def_id()) {\n-                    if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n-                        if self.tcx.type_of(impl_def_id).visit_with(self) {\n-                            return;\n-                        }\n-                    }\n-                }\n+        let def = match *qpath {\n+            hir::QPath::Resolved(_, ref path) => match path.def {\n+                Def::Method(..) | Def::AssociatedConst(..) |\n+                Def::AssociatedTy(..) => Some(path.def),\n+                _ => None,\n+            }\n+            hir::QPath::TypeRelative(..) => {\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                self.tables.type_dependent_defs().get(hir_id).cloned()\n+            }\n+        };\n+        if let Some(def) = def {\n+            let def_id = def.def_id();\n+            if !self.item_is_accessible(def_id) {\n+                let name = match *qpath {\n+                    hir::QPath::Resolved(_, ref path) => format!(\"{}\", path),\n+                    hir::QPath::TypeRelative(_, ref segment) => segment.name.to_string(),\n+                };\n+                let msg = format!(\"{} `{}` is private\", def.kind_name(), name);\n+                self.tcx.sess.span_err(span, &msg);\n+                return;\n             }\n         }\n \n@@ -807,9 +839,11 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                                         item.id,\n                                         &mut self.tables,\n                                         self.empty_tables);\n+        let orig_in_body = replace(&mut self.in_body, false);\n         self.current_item = self.tcx.hir.local_def_id(item.id);\n         intravisit::walk_item(self, item);\n         self.tables = orig_tables;\n+        self.in_body = orig_in_body;\n         self.current_item = orig_current_item;\n     }\n \n@@ -869,13 +903,8 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             ty::TyProjection(ref proj) => {\n-                let trait_ref = proj.trait_ref(self.tcx);\n-                if !self.item_is_accessible(trait_ref.def_id) {\n-                    let msg = format!(\"trait `{}` is private\", trait_ref);\n-                    self.tcx.sess.span_err(self.span, &msg);\n-                    return true;\n-                }\n-                if trait_ref.super_visit_with(self) {\n+                let tcx = self.tcx;\n+                if self.check_trait_ref(proj.trait_ref(tcx)) {\n                     return true;\n                 }\n             }\n@@ -1629,6 +1658,7 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx,\n         tables: &empty_tables,\n         current_item: DefId::local(CRATE_DEF_INDEX),\n+        in_body: false,\n         span: krate.span,\n         empty_tables: &empty_tables,\n     };"}, {"sha": "cc79ae54c6bc8f0fbaf88c506565c53051d71f18", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 64, "deletions": 50, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/190adc0e193d9b7154b54b4800e2059acb72448b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190adc0e193d9b7154b54b4800e2059acb72448b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=190adc0e193d9b7154b54b4800e2059acb72448b", "patch": "@@ -347,13 +347,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    pub fn instantiate_poly_trait_ref(&self,\n-        ast_trait_ref: &hir::PolyTraitRef,\n+    pub(super) fn instantiate_poly_trait_ref_inner(&self,\n+        trait_ref: &hir::TraitRef,\n         self_ty: Ty<'tcx>,\n-        poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n+        poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>,\n+        speculative: bool)\n         -> ty::PolyTraitRef<'tcx>\n     {\n-        let trait_ref = &ast_trait_ref.trait_ref;\n         let trait_def_id = self.trait_def_id(trait_ref);\n \n         debug!(\"ast_path_to_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n@@ -371,7 +371,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             // specify type to assert that error was already reported in Err case:\n             let predicate: Result<_, ErrorReported> =\n                 self.ast_type_binding_to_poly_projection_predicate(trait_ref.ref_id, poly_trait_ref,\n-                                                                   binding);\n+                                                                   binding, speculative);\n             predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n         }));\n \n@@ -380,6 +380,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         poly_trait_ref\n     }\n \n+    pub fn instantiate_poly_trait_ref(&self,\n+        poly_trait_ref: &hir::PolyTraitRef,\n+        self_ty: Ty<'tcx>,\n+        poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n+        -> ty::PolyTraitRef<'tcx>\n+    {\n+        self.instantiate_poly_trait_ref_inner(&poly_trait_ref.trait_ref, self_ty,\n+                                              poly_projections, false)\n+    }\n+\n     fn ast_path_to_mono_trait_ref(&self,\n                                   span: Span,\n                                   trait_def_id: DefId,\n@@ -445,55 +455,59 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         &self,\n         ref_id: ast::NodeId,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n-        binding: &ConvertedBinding<'tcx>)\n+        binding: &ConvertedBinding<'tcx>,\n+        speculative: bool)\n         -> Result<ty::PolyProjectionPredicate<'tcx>, ErrorReported>\n     {\n         let tcx = self.tcx();\n \n-        // Given something like `U : SomeTrait<T=X>`, we want to produce a\n-        // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n-        // subtle in the event that `T` is defined in a supertrait of\n-        // `SomeTrait`, because in that case we need to upcast.\n-        //\n-        // That is, consider this case:\n-        //\n-        // ```\n-        // trait SubTrait : SuperTrait<int> { }\n-        // trait SuperTrait<A> { type T; }\n-        //\n-        // ... B : SubTrait<T=foo> ...\n-        // ```\n-        //\n-        // We want to produce `<B as SuperTrait<int>>::T == foo`.\n-\n-        // Find any late-bound regions declared in `ty` that are not\n-        // declared in the trait-ref. These are not wellformed.\n-        //\n-        // Example:\n-        //\n-        //     for<'a> <T as Iterator>::Item = &'a str // <-- 'a is bad\n-        //     for<'a> <T as FnMut<(&'a u32,)>>::Output = &'a str // <-- 'a is ok\n-        let late_bound_in_trait_ref = tcx.collect_constrained_late_bound_regions(&trait_ref);\n-        let late_bound_in_ty = tcx.collect_referenced_late_bound_regions(&ty::Binder(binding.ty));\n-        debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n-        debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n-        for br in late_bound_in_ty.difference(&late_bound_in_trait_ref) {\n-            let br_name = match *br {\n-                ty::BrNamed(_, name) => name,\n-                _ => {\n-                    span_bug!(\n-                        binding.span,\n-                        \"anonymous bound region {:?} in binding but not trait ref\",\n-                        br);\n-                }\n-            };\n-            struct_span_err!(tcx.sess,\n-                             binding.span,\n-                             E0582,\n-                             \"binding for associated type `{}` references lifetime `{}`, \\\n-                              which does not appear in the trait input types\",\n-                             binding.item_name, br_name)\n-                .emit();\n+        if !speculative {\n+            // Given something like `U : SomeTrait<T=X>`, we want to produce a\n+            // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n+            // subtle in the event that `T` is defined in a supertrait of\n+            // `SomeTrait`, because in that case we need to upcast.\n+            //\n+            // That is, consider this case:\n+            //\n+            // ```\n+            // trait SubTrait : SuperTrait<int> { }\n+            // trait SuperTrait<A> { type T; }\n+            //\n+            // ... B : SubTrait<T=foo> ...\n+            // ```\n+            //\n+            // We want to produce `<B as SuperTrait<int>>::T == foo`.\n+\n+            // Find any late-bound regions declared in `ty` that are not\n+            // declared in the trait-ref. These are not wellformed.\n+            //\n+            // Example:\n+            //\n+            //     for<'a> <T as Iterator>::Item = &'a str // <-- 'a is bad\n+            //     for<'a> <T as FnMut<(&'a u32,)>>::Output = &'a str // <-- 'a is ok\n+            let late_bound_in_trait_ref = tcx.collect_constrained_late_bound_regions(&trait_ref);\n+            let late_bound_in_ty =\n+                tcx.collect_referenced_late_bound_regions(&ty::Binder(binding.ty));\n+            debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n+            debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n+            for br in late_bound_in_ty.difference(&late_bound_in_trait_ref) {\n+                let br_name = match *br {\n+                    ty::BrNamed(_, name) => name,\n+                    _ => {\n+                        span_bug!(\n+                            binding.span,\n+                            \"anonymous bound region {:?} in binding but not trait ref\",\n+                            br);\n+                    }\n+                };\n+                struct_span_err!(tcx.sess,\n+                                binding.span,\n+                                E0582,\n+                                \"binding for associated type `{}` references lifetime `{}`, \\\n+                                which does not appear in the trait input types\",\n+                                binding.item_name, br_name)\n+                    .emit();\n+            }\n         }\n \n         let candidate = if self.trait_defines_associated_type_named(trait_ref.def_id(),"}, {"sha": "31f3b4e699afd65e861362c08f7cf1369cd11b89", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/190adc0e193d9b7154b54b4800e2059acb72448b/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190adc0e193d9b7154b54b4800e2059acb72448b/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=190adc0e193d9b7154b54b4800e2059acb72448b", "patch": "@@ -348,7 +348,22 @@ pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) ->\n     let env_node_id = tcx.hir.get_parent(hir_ty.id);\n     let env_def_id = tcx.hir.local_def_id(env_node_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n-    item_cx.to_ty(hir_ty)\n+    astconv::AstConv::ast_ty_to_ty(&item_cx, hir_ty)\n+}\n+\n+pub fn hir_trait_to_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_trait: &hir::TraitRef)\n+        -> (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>) {\n+    // In case there are any projections etc, find the \"environment\"\n+    // def-id that will be used to determine the traits/predicates in\n+    // scope.  This is derived from the enclosing item-like thing.\n+    let env_node_id = tcx.hir.get_parent(hir_trait.ref_id);\n+    let env_def_id = tcx.hir.local_def_id(env_node_id);\n+    let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n+    let mut projections = Vec::new();\n+    let principal = astconv::AstConv::instantiate_poly_trait_ref_inner(\n+        &item_cx, hir_trait, tcx.types.err, &mut projections, true\n+    );\n+    (principal, projections)\n }\n \n __build_diagnostic_array! { librustc_typeck, DIAGNOSTICS }"}, {"sha": "63cb6e82c259e0a88488b432b4d425db229bf041", "filename": "src/test/compile-fail/privacy/associated-item-privacy-inherent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/190adc0e193d9b7154b54b4800e2059acb72448b/src%2Ftest%2Fcompile-fail%2Fprivacy%2Fassociated-item-privacy-inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190adc0e193d9b7154b54b4800e2059acb72448b/src%2Ftest%2Fcompile-fail%2Fprivacy%2Fassociated-item-privacy-inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Fassociated-item-privacy-inherent.rs?ref=190adc0e193d9b7154b54b4800e2059acb72448b", "patch": "@@ -27,7 +27,7 @@ mod priv_nominal {\n         Pub.method();\n         //~^ ERROR type `for<'r> fn(&'r priv_nominal::Pub) {priv_nominal::Pub::method}` is private\n         Pub::CONST;\n-        //FIXME ERROR associated constant `CONST` is private\n+        //~^ ERROR associated constant `CONST` is private\n         // let _: Pub::AssocTy;\n         // pub type InSignatureTy = Pub::AssocTy;\n     }"}, {"sha": "bdc0c680a92bc161117743a3bd78179bb3219d33", "filename": "src/test/compile-fail/privacy/associated-item-privacy-trait.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/190adc0e193d9b7154b54b4800e2059acb72448b/src%2Ftest%2Fcompile-fail%2Fprivacy%2Fassociated-item-privacy-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190adc0e193d9b7154b54b4800e2059acb72448b/src%2Ftest%2Fcompile-fail%2Fprivacy%2Fassociated-item-privacy-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Fassociated-item-privacy-trait.rs?ref=190adc0e193d9b7154b54b4800e2059acb72448b", "patch": "@@ -31,17 +31,16 @@ mod priv_trait {\n         Pub.method();\n         //~^ ERROR type `for<'r> fn(&'r Self) {<Self as priv_trait::PrivTr>::method}` is private\n         <Pub as PrivTr>::CONST;\n-        //FIXME ERROR associated constant `path(PrivTr::CONST)` is private\n+        //~^ ERROR associated constant `PrivTr::CONST` is private\n         let _: <Pub as PrivTr>::AssocTy;\n         //~^ ERROR trait `priv_trait::PrivTr` is private\n         //~| ERROR trait `priv_trait::PrivTr` is private\n         pub type InSignatureTy = <Pub as PrivTr>::AssocTy;\n         //~^ ERROR trait `priv_trait::PrivTr` is private\n-        //~| ERROR trait `path(PrivTr)` is private\n         pub trait InSignatureTr: PrivTr {}\n-        //FIXME ERROR trait `priv_trait::PrivTr` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n         impl PrivTr for u8 {}\n-        //FIXME ERROR trait `priv_trait::PrivTr` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n     }\n }\n fn priv_trait() {\n@@ -142,7 +141,7 @@ mod priv_parent_substs {\n         pub type InSignatureTy2 = <Priv as PubTr<Pub>>::AssocTy;\n         //~^ ERROR type `priv_parent_substs::Priv` is private\n         impl PubTr for u8 {}\n-        //FIXME ERROR type `priv_parent_substs::Priv` is private\n+        //~^ ERROR type `priv_parent_substs::Priv` is private\n     }\n }\n fn priv_parent_substs() {"}, {"sha": "c25616c54354d9f0d856927e915e1f383f5c83ba", "filename": "src/test/compile-fail/privacy/associated-item-privacy-type-binding.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/190adc0e193d9b7154b54b4800e2059acb72448b/src%2Ftest%2Fcompile-fail%2Fprivacy%2Fassociated-item-privacy-type-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190adc0e193d9b7154b54b4800e2059acb72448b/src%2Ftest%2Fcompile-fail%2Fprivacy%2Fassociated-item-privacy-type-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Fassociated-item-privacy-type-binding.rs?ref=190adc0e193d9b7154b54b4800e2059acb72448b", "patch": "@@ -24,17 +24,16 @@ mod priv_trait {\n         type InSignatureTy2 = Box<PubTr<AssocTy = u8>>;\n         //~^ ERROR type `priv_trait::PubTr<AssocTy=u8> + 'static` is private\n         trait InSignatureTr2: PubTr<AssocTy = u8> {}\n-        //FIXME ERROR trait `priv_trait::PrivTr` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n     }\n     pub macro mac2() {\n         let _: Box<PrivTr<AssocTy = u8>>;\n         //~^ ERROR type `priv_trait::PrivTr<AssocTy=u8> + '<empty>` is private\n         //~| ERROR type `priv_trait::PrivTr<AssocTy=u8> + '<empty>` is private\n         type InSignatureTy1 = Box<PrivTr<AssocTy = u8>>;\n         //~^ ERROR type `priv_trait::PrivTr<AssocTy=u8> + 'static` is private\n-        //~| ERROR trait `path(PrivTr<AssocTy = u8>)` is private\n         trait InSignatureTr1: PrivTr<AssocTy = u8> {}\n-        //FIXME ERROR trait `priv_trait::PrivTr` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n     }\n }\n fn priv_trait1() {\n@@ -63,9 +62,9 @@ mod priv_parent_substs {\n         pub type InSignatureTy2 = Box<PubTr<AssocTy = u8>>;\n         //~^ ERROR type `priv_parent_substs::Priv` is private\n         trait InSignatureTr1: PubTrWithParam<AssocTy = u8> {}\n-        //FIXME ERROR type `priv_parent_substs::Priv` is private\n+        //~^ ERROR type `priv_parent_substs::Priv` is private\n         trait InSignatureTr2: PubTr<AssocTy = u8> {}\n-        //FIXME ERROR type `priv_parent_substs::Priv` is private\n+        //~^ ERROR type `priv_parent_substs::Priv` is private\n     }\n }\n fn priv_parent_substs() {"}]}