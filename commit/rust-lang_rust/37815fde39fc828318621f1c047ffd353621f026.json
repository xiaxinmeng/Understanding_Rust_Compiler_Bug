{"sha": "37815fde39fc828318621f1c047ffd353621f026", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3ODE1ZmRlMzlmYzgyODMxODYyMWYxYzA0N2ZmZDM1MzYyMWYwMjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-02-01T17:57:44Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-02-01T17:59:49Z"}, "message": "Add a notion of \"per-tree\" state", "tree": {"sha": "e722c0e18624b979751f52a3a27a8ea28dc83267", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e722c0e18624b979751f52a3a27a8ea28dc83267"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37815fde39fc828318621f1c047ffd353621f026", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37815fde39fc828318621f1c047ffd353621f026", "html_url": "https://github.com/rust-lang/rust/commit/37815fde39fc828318621f1c047ffd353621f026", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37815fde39fc828318621f1c047ffd353621f026/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c22cb5359fd2c9703e1c0db3a179b79c7cdb42cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c22cb5359fd2c9703e1c0db3a179b79c7cdb42cd", "html_url": "https://github.com/rust-lang/rust/commit/c22cb5359fd2c9703e1c0db3a179b79c7cdb42cd"}], "stats": {"total": 351, "additions": 237, "deletions": 114}, "files": [{"sha": "a656cb3126de7d0fbcf87121288b9c3ec12992a4", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 46, "deletions": 18, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/37815fde39fc828318621f1c047ffd353621f026/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37815fde39fc828318621f1c047ffd353621f026/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=37815fde39fc828318621f1c047ffd353621f026", "patch": "@@ -66,7 +66,7 @@ pub struct FulfillmentContext<'tcx> {\n \n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n-    predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n+    predicates: ObligationForest<PendingPredicateObligation<'tcx>, ()>,\n \n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n@@ -192,7 +192,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             obligation: obligation,\n             stalled_on: vec![]\n         };\n-        self.predicates.push_root(obligation);\n+        self.predicates.push_tree(obligation, ());\n     }\n \n     pub fn region_obligations(&self,\n@@ -278,10 +278,10 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             let outcome = {\n                 let region_obligations = &mut self.region_obligations;\n                 self.predicates.process_obligations(\n-                    |obligation, backtrace| process_predicate(selcx,\n-                                                              obligation,\n-                                                              backtrace,\n-                                                              region_obligations))\n+                    |obligation, _tree, backtrace| process_predicate(selcx,\n+                                                                     obligation,\n+                                                                     backtrace,\n+                                                                     region_obligations))\n             };\n \n             debug!(\"select_where_possible: outcome={:?}\", outcome);\n@@ -405,7 +405,7 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n         pending_obligation.stalled_on = vec![];\n     }\n \n-    let obligation = &pending_obligation.obligation;\n+    let obligation = &mut pending_obligation.obligation;\n \n     // If we exceed the recursion limit, take a moment to look for a\n     // cycle so we can give a better error report from here, where we\n@@ -417,18 +417,31 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n         }\n     }\n \n+    if obligation.predicate.has_infer_types() {\n+        obligation.predicate = selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n+    }\n+\n     match obligation.predicate {\n         ty::Predicate::Trait(ref data) => {\n+            if selcx.tcx().fulfilled_predicates.borrow().check_duplicate_trait(data) {\n+                return Ok(Some(vec![]));\n+            }\n+\n             if coinductive_match(selcx, obligation, data, &backtrace) {\n                 return Ok(Some(vec![]));\n             }\n \n             let trait_obligation = obligation.with(data.clone());\n             match selcx.select(&trait_obligation) {\n                 Ok(Some(vtable)) => {\n+                    info!(\"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n+                          data, obligation.recursion_depth);\n                     Ok(Some(vtable.nested_obligations()))\n                 }\n                 Ok(None) => {\n+                    info!(\"selecting trait `{:?}` at depth {} yielded Ok(None)\",\n+                          data, obligation.recursion_depth);\n+\n                     // This is a bit subtle: for the most part, the\n                     // only reason we can fail to make progress on\n                     // trait selection is because we don't have enough\n@@ -457,6 +470,8 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                     Ok(None)\n                 }\n                 Err(selection_err) => {\n+                    info!(\"selecting trait `{:?}` at depth {} yielded Err\",\n+                          data, obligation.recursion_depth);\n                     Err(CodeSelectionError(selection_err))\n                 }\n             }\n@@ -642,18 +657,28 @@ impl<'tcx> GlobalFulfilledPredicates<'tcx> {\n \n     pub fn check_duplicate(&self, key: &ty::Predicate<'tcx>) -> bool {\n         if let ty::Predicate::Trait(ref data) = *key {\n-            // For the global predicate registry, when we find a match, it\n-            // may have been computed by some other task, so we want to\n-            // add a read from the node corresponding to the predicate\n-            // processing to make sure we get the transitive dependencies.\n-            if self.set.contains(data) {\n-                debug_assert!(data.is_global());\n-                self.dep_graph.read(data.dep_node());\n-                return true;\n-            }\n+            self.check_duplicate_trait(data)\n+        } else {\n+            false\n         }\n+    }\n+\n+    pub fn check_duplicate_trait(&self, data: &ty::PolyTraitPredicate<'tcx>) -> bool {\n+        // For the global predicate registry, when we find a match, it\n+        // may have been computed by some other task, so we want to\n+        // add a read from the node corresponding to the predicate\n+        // processing to make sure we get the transitive dependencies.\n+        if self.set.contains(data) {\n+            debug_assert!(data.is_global());\n+            self.dep_graph.read(data.dep_node());\n+            debug!(\"check_duplicate: global predicate `{:?}` already proved elsewhere\", data);\n+\n+            info!(\"check_duplicate_trait hit: `{:?}`\", data);\n \n-        return false;\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     fn add_if_global(&mut self, key: &ty::Predicate<'tcx>) {\n@@ -663,7 +688,10 @@ impl<'tcx> GlobalFulfilledPredicates<'tcx> {\n             // already has the required read edges, so we don't need\n             // to add any more edges here.\n             if data.is_global() {\n-                self.set.insert(data.clone());\n+                if self.set.insert(data.clone()) {\n+                    debug!(\"add_if_global: global predicate `{:?}` added\", data);\n+                    info!(\"check_duplicate_trait entry: `{:?}`\", data);\n+                }\n             }\n         }\n     }"}, {"sha": "d76d7f6ba340e67c9e563594ed084378ce91cf09", "filename": "src/librustc_data_structures/obligation_forest/README.md", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/37815fde39fc828318621f1c047ffd353621f026/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/37815fde39fc828318621f1c047ffd353621f026/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md?ref=37815fde39fc828318621f1c047ffd353621f026", "patch": "@@ -9,15 +9,18 @@ place).\n `ObligationForest` supports two main public operations (there are a\n few others not discussed here):\n \n-1. Add a new root obligation (`push_root`).\n+1. Add a new root obligations (`push_tree`).\n 2. Process the pending obligations (`process_obligations`).\n \n When a new obligation `N` is added, it becomes the root of an\n-obligation tree. This tree is a singleton to start, so `N` is both the\n-root and the only leaf. Each time the `process_obligations` method is\n-called, it will invoke its callback with every pending obligation (so\n-that will include `N`, the first time). The callback shoud process the\n-obligation `O` that it is given and return one of three results:\n+obligation tree. This tree can also carry some per-tree state `T`,\n+which is given at the same time. This tree is a singleton to start, so\n+`N` is both the root and the only leaf. Each time the\n+`process_obligations` method is called, it will invoke its callback\n+with every pending obligation (so that will include `N`, the first\n+time). The callback also receives a (mutable) reference to the\n+per-tree state `T`. The callback should process the obligation `O`\n+that it is given and return one of three results:\n \n - `Ok(None)` -> ambiguous result. Obligation was neither a success\n   nor a failure. It is assumed that further attempts to process the"}, {"sha": "25a77adba2820b50e6e0db74913aba76fd32178d", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 98, "deletions": 49, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/37815fde39fc828318621f1c047ffd353621f026/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37815fde39fc828318621f1c047ffd353621f026/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=37815fde39fc828318621f1c047ffd353621f026", "patch": "@@ -19,11 +19,16 @@ use std::fmt::Debug;\n use std::mem;\n \n mod node_index;\n+use self::node_index::NodeIndex;\n+\n+mod tree_index;\n+use self::tree_index::TreeIndex;\n+\n \n #[cfg(test)]\n mod test;\n \n-pub struct ObligationForest<O> {\n+pub struct ObligationForest<O,T> {\n     /// The list of obligations. In between calls to\n     /// `process_obligations`, this list only contains nodes in the\n     /// `Pending` or `Success` state (with a non-zero number of\n@@ -37,19 +42,23 @@ pub struct ObligationForest<O> {\n     /// at a higher index than its parent. This is needed by the\n     /// backtrace iterator (which uses `split_at`).\n     nodes: Vec<Node<O>>,\n+    trees: Vec<Tree<T>>,\n     snapshots: Vec<usize>\n }\n \n pub struct Snapshot {\n     len: usize,\n }\n \n-pub use self::node_index::NodeIndex;\n+struct Tree<T> {\n+    root: NodeIndex,\n+    state: T,\n+}\n \n struct Node<O> {\n     state: NodeState<O>,\n     parent: Option<NodeIndex>,\n-    root: NodeIndex, // points to the root, which may be the current node\n+    tree: TreeIndex,\n }\n \n /// The state of one node in some tree within the forest. This\n@@ -99,9 +108,10 @@ pub struct Error<O,E> {\n     pub backtrace: Vec<O>,\n }\n \n-impl<O: Debug> ObligationForest<O> {\n-    pub fn new() -> ObligationForest<O> {\n+impl<O: Debug, T: Debug> ObligationForest<O, T> {\n+    pub fn new() -> ObligationForest<O, T> {\n         ObligationForest {\n+            trees: vec![],\n             nodes: vec![],\n             snapshots: vec![]\n         }\n@@ -114,30 +124,39 @@ impl<O: Debug> ObligationForest<O> {\n     }\n \n     pub fn start_snapshot(&mut self) -> Snapshot {\n-        self.snapshots.push(self.nodes.len());\n+        self.snapshots.push(self.trees.len());\n         Snapshot { len: self.snapshots.len() }\n     }\n \n     pub fn commit_snapshot(&mut self, snapshot: Snapshot) {\n         assert_eq!(snapshot.len, self.snapshots.len());\n-        let nodes_len = self.snapshots.pop().unwrap();\n-        assert!(self.nodes.len() >= nodes_len);\n+        let trees_len = self.snapshots.pop().unwrap();\n+        assert!(self.trees.len() >= trees_len);\n     }\n \n     pub fn rollback_snapshot(&mut self, snapshot: Snapshot) {\n         // Check that we are obeying stack discipline.\n         assert_eq!(snapshot.len, self.snapshots.len());\n-        let nodes_len = self.snapshots.pop().unwrap();\n+        let trees_len = self.snapshots.pop().unwrap();\n \n-        // The only action permitted while in a snapshot is to push\n-        // new root obligations. Because no processing will have been\n-        // done, those roots should still be in the pending state.\n-        debug_assert!(self.nodes[nodes_len..].iter().all(|n| match n.state {\n-            NodeState::Pending { .. } => true,\n-            _ => false,\n-        }));\n+        // If nothing happened in snapshot, done.\n+        if self.trees.len() == trees_len {\n+            return;\n+        }\n \n-        self.nodes.truncate(nodes_len);\n+        // Find root of first tree; because nothing can happen in a\n+        // snapshot but pushing trees, all nodes after that should be\n+        // roots of other trees as well\n+        let first_root_index = self.trees[trees_len].root.get();\n+        debug_assert!(\n+            self.nodes[first_root_index..]\n+                .iter()\n+                .zip(first_root_index..)\n+                .all(|(root, root_index)| self.trees[root.tree.get()].root.get() == root_index));\n+\n+        // Pop off tree/root pairs pushed during snapshot.\n+        self.trees.truncate(trees_len);\n+        self.nodes.truncate(first_root_index);\n     }\n \n     pub fn in_snapshot(&self) -> bool {\n@@ -147,9 +166,11 @@ impl<O: Debug> ObligationForest<O> {\n     /// Adds a new tree to the forest.\n     ///\n     /// This CAN be done during a snapshot.\n-    pub fn push_root(&mut self, obligation: O) {\n+    pub fn push_tree(&mut self, obligation: O, tree_state: T) {\n         let index = NodeIndex::new(self.nodes.len());\n-        self.nodes.push(Node::new(index, None, obligation));\n+        let tree = TreeIndex::new(self.trees.len());\n+        self.trees.push(Tree { root: index, state: tree_state });\n+        self.nodes.push(Node::new(tree, None, obligation));\n     }\n \n     /// Convert all remaining obligations to the given error.\n@@ -186,7 +207,7 @@ impl<O: Debug> ObligationForest<O> {\n     ///\n     /// This CANNOT be unrolled (presently, at least).\n     pub fn process_obligations<E,F>(&mut self, mut action: F) -> Outcome<O,E>\n-        where E: Debug, F: FnMut(&mut O, Backtrace<O>) -> Result<Option<Vec<O>>, E>\n+        where E: Debug, F: FnMut(&mut O, &mut T, Backtrace<O>) -> Result<Option<Vec<O>>, E>\n     {\n         debug!(\"process_obligations(len={})\", self.nodes.len());\n         assert!(!self.in_snapshot()); // cannot unroll this action\n@@ -210,15 +231,15 @@ impl<O: Debug> ObligationForest<O> {\n                    index, self.nodes[index].state);\n \n             let result = {\n-                let parent = self.nodes[index].parent;\n+                let Node { tree, parent, .. } = self.nodes[index];\n                 let (prefix, suffix) = self.nodes.split_at_mut(index);\n                 let backtrace = Backtrace::new(prefix, parent);\n                 match suffix[0].state {\n                     NodeState::Error |\n                     NodeState::Success { .. } =>\n                         continue,\n                     NodeState::Pending { ref mut obligation } =>\n-                        action(obligation, backtrace),\n+                        action(obligation, &mut self.trees[tree.get()].state, backtrace),\n                 }\n             };\n \n@@ -268,11 +289,11 @@ impl<O: Debug> ObligationForest<O> {\n             self.update_parent(index);\n         } else {\n             // create child work\n-            let root_index = self.nodes[index].root;\n+            let tree_index = self.nodes[index].tree;\n             let node_index = NodeIndex::new(index);\n             self.nodes.extend(\n                 children.into_iter()\n-                        .map(|o| Node::new(root_index, Some(node_index), o)));\n+                        .map(|o| Node::new(tree_index, Some(node_index), o)));\n         }\n \n         // change state from `Pending` to `Success`, temporarily swapping in `Error`\n@@ -311,8 +332,9 @@ impl<O: Debug> ObligationForest<O> {\n     /// skip the remaining obligations from a tree once some other\n     /// node in the tree is found to be in error.\n     fn inherit_error(&mut self, child: usize) {\n-        let root = self.nodes[child].root.get();\n-        if let NodeState::Error = self.nodes[root].state {\n+        let tree = self.nodes[child].tree;\n+        let root = self.trees[tree.get()].root;\n+        if let NodeState::Error = self.nodes[root.get()].state {\n             self.nodes[child].state = NodeState::Error;\n         }\n     }\n@@ -353,7 +375,8 @@ impl<O: Debug> ObligationForest<O> {\n     /// indices. Cannot be used during a transaction.\n     fn compress(&mut self) -> Vec<O> {\n         assert!(!self.in_snapshot()); // didn't write code to unroll this action\n-        let mut rewrites: Vec<_> = (0..self.nodes.len()).collect();\n+        let mut node_rewrites: Vec<_> = (0..self.nodes.len()).collect();\n+        let mut tree_rewrites: Vec<_> = (0..self.trees.len()).collect();\n \n         // Finish propagating error state. Note that in this case we\n         // only have to check immediate parents, rather than all\n@@ -366,55 +389,81 @@ impl<O: Debug> ObligationForest<O> {\n             }\n         }\n \n+        // Determine which trees to remove by checking if their root\n+        // is popped.\n+        let mut dead_trees = 0;\n+        let trees_len = self.trees.len();\n+        for i in 0..trees_len {\n+            let root_node = self.trees[i].root;\n+            if self.nodes[root_node.get()].is_popped() {\n+                dead_trees += 1;\n+            } else if dead_trees > 0 {\n+                self.trees.swap(i, i - dead_trees);\n+                tree_rewrites[i] -= dead_trees;\n+            }\n+        }\n+\n         // Now go through and move all nodes that are either\n         // successful or which have an error over into to the end of\n         // the list, preserving the relative order of the survivors\n         // (which is important for the `inherit_error` logic).\n-        let mut dead = 0;\n+        let mut dead_nodes = 0;\n         for i in 0..nodes_len {\n             if self.nodes[i].is_popped() {\n-                dead += 1;\n-            } else if dead > 0 {\n-                self.nodes.swap(i, i - dead);\n-                rewrites[i] -= dead;\n+                dead_nodes += 1;\n+            } else if dead_nodes > 0 {\n+                self.nodes.swap(i, i - dead_nodes);\n+                node_rewrites[i] -= dead_nodes;\n             }\n         }\n \n+        // No compression needed.\n+        if dead_nodes == 0 && dead_trees == 0 {\n+            return vec![];\n+        }\n+\n+        // Pop off the trees we killed.\n+        self.trees.truncate(trees_len - dead_trees);\n+\n         // Pop off all the nodes we killed and extract the success\n         // stories.\n         let successful =\n-            (0 .. dead).map(|_| self.nodes.pop().unwrap())\n-                       .flat_map(|node| match node.state {\n-                           NodeState::Error => None,\n-                           NodeState::Pending { .. } => unreachable!(),\n-                           NodeState::Success { obligation, num_incomplete_children } => {\n-                               assert_eq!(num_incomplete_children, 0);\n-                               Some(obligation)\n-                           }\n-                       })\n-                       .collect();\n-\n-        // Adjust the parent indices, since we compressed things.\n+            (0 .. dead_nodes)\n+            .map(|_| self.nodes.pop().unwrap())\n+            .flat_map(|node| match node.state {\n+                NodeState::Error => None,\n+                NodeState::Pending { .. } => unreachable!(),\n+                NodeState::Success { obligation, num_incomplete_children } => {\n+                    assert_eq!(num_incomplete_children, 0);\n+                    Some(obligation)\n+                }\n+            })\n+            .collect();\n+\n+        // Adjust the various indices, since we compressed things.\n+        for tree in &mut self.trees {\n+            tree.root = NodeIndex::new(node_rewrites[tree.root.get()]);\n+        }\n         for node in &mut self.nodes {\n             if let Some(ref mut index) = node.parent {\n-                let new_index = rewrites[index.get()];\n-                debug_assert!(new_index < (nodes_len - dead));\n+                let new_index = node_rewrites[index.get()];\n+                debug_assert!(new_index < (nodes_len - dead_nodes));\n                 *index = NodeIndex::new(new_index);\n             }\n \n-            node.root = NodeIndex::new(rewrites[node.root.get()]);\n+            node.tree = TreeIndex::new(tree_rewrites[node.tree.get()]);\n         }\n \n         successful\n     }\n }\n \n impl<O> Node<O> {\n-    fn new(root: NodeIndex, parent: Option<NodeIndex>, obligation: O) -> Node<O> {\n+    fn new(tree: TreeIndex, parent: Option<NodeIndex>, obligation: O) -> Node<O> {\n         Node {\n             parent: parent,\n             state: NodeState::Pending { obligation: obligation },\n-            root: root\n+            tree: tree,\n         }\n     }\n "}, {"sha": "9a0a4218d4593d662ad1cee5b6217366abf58ab7", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/37815fde39fc828318621f1c047ffd353621f026/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37815fde39fc828318621f1c047ffd353621f026/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=37815fde39fc828318621f1c047ffd353621f026", "patch": "@@ -13,22 +13,24 @@ use super::{ObligationForest, Outcome, Error};\n #[test]\n fn push_pop() {\n     let mut forest = ObligationForest::new();\n-    forest.push_root(\"A\");\n-    forest.push_root(\"B\");\n-    forest.push_root(\"C\");\n+    forest.push_tree(\"A\", \"A\");\n+    forest.push_tree(\"B\", \"B\");\n+    forest.push_tree(\"C\", \"C\");\n \n     // first round, B errors out, A has subtasks, and C completes, creating this:\n     //      A |-> A.1\n     //        |-> A.2\n     //        |-> A.3\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n-        match *obligation {\n-            \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n-            \"B\" => Err(\"B is for broken\"),\n-            \"C\" => Ok(Some(vec![])),\n-            _ => unreachable!(),\n-        }\n-    });\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n+            match *obligation {\n+                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n+                \"B\" => Err(\"B is for broken\"),\n+                \"C\" => Ok(Some(vec![])),\n+                _ => unreachable!(),\n+            }\n+        });\n     assert_eq!(ok, vec![\"C\"]);\n     assert_eq!(err, vec![Error {error: \"B is for broken\",\n                                 backtrace: vec![\"B\"]}]);\n@@ -39,9 +41,10 @@ fn push_pop() {\n     //        |-> A.3 |-> A.3.i\n     //      D |-> D.1\n     //        |-> D.2\n-    forest.push_root(\"D\");\n+    forest.push_tree(\"D\", \"D\");\n     let Outcome { completed: ok, errors: err, .. }: Outcome<&'static str, ()> =\n-        forest.process_obligations(|obligation, _| {\n+        forest.process_obligations(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A.1\" => Ok(None),\n                 \"A.2\" => Ok(None),\n@@ -58,26 +61,30 @@ fn push_pop() {\n     // propagates to A.3.i, but not D.1 or D.2.\n     //      D |-> D.1 |-> D.1.i\n     //        |-> D.2 |-> D.2.i\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n-        match *obligation {\n-            \"A.1\" => Ok(Some(vec![])),\n-            \"A.2\" => Err(\"A is for apple\"),\n-            \"D.1\" => Ok(Some(vec![\"D.1.i\"])),\n-            \"D.2\" => Ok(Some(vec![\"D.2.i\"])),\n-            _ => unreachable!(),\n-        }\n-    });\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n+            match *obligation {\n+                \"A.1\" => Ok(Some(vec![])),\n+                \"A.2\" => Err(\"A is for apple\"),\n+                \"D.1\" => Ok(Some(vec![\"D.1.i\"])),\n+                \"D.2\" => Ok(Some(vec![\"D.2.i\"])),\n+                _ => unreachable!(),\n+            }\n+        });\n     assert_eq!(ok, vec![\"A.1\"]);\n     assert_eq!(err, vec![Error { error: \"A is for apple\",\n                                  backtrace: vec![\"A.2\", \"A\"] }]);\n \n     // fourth round: error in D.1.i that should propagate to D.2.i\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n-        match *obligation {\n-            \"D.1.i\" => Err(\"D is for dumb\"),\n-            _ => panic!(\"unexpected obligation {:?}\", obligation),\n-        }\n-    });\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n+            match *obligation {\n+                \"D.1.i\" => Err(\"D is for dumb\"),\n+                _ => panic!(\"unexpected obligation {:?}\", obligation),\n+            }\n+        });\n     assert_eq!(ok, Vec::<&'static str>::new());\n     assert_eq!(err, vec![Error { error: \"D is for dumb\",\n                                  backtrace: vec![\"D.1.i\", \"D.1\", \"D\"] }]);\n@@ -94,10 +101,11 @@ fn push_pop() {\n #[test]\n fn success_in_grandchildren() {\n     let mut forest = ObligationForest::new();\n-    forest.push_root(\"A\");\n+    forest.push_tree(\"A\", \"A\");\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, _| {\n+        forest.process_obligations::<(),_>(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n                 _ => unreachable!(),\n@@ -107,7 +115,8 @@ fn success_in_grandchildren() {\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, _| {\n+        forest.process_obligations::<(),_>(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A.1\" => Ok(Some(vec![])),\n                 \"A.2\" => Ok(Some(vec![\"A.2.i\", \"A.2.ii\"])),\n@@ -119,7 +128,8 @@ fn success_in_grandchildren() {\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, _| {\n+        forest.process_obligations::<(),_>(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A.2.i\" => Ok(Some(vec![\"A.2.i.a\"])),\n                 \"A.2.ii\" => Ok(Some(vec![])),\n@@ -130,7 +140,8 @@ fn success_in_grandchildren() {\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, _| {\n+        forest.process_obligations::<(),_>(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A.2.i.a\" => Ok(Some(vec![])),\n                 _ => unreachable!(),\n@@ -140,7 +151,7 @@ fn success_in_grandchildren() {\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|_, _| unreachable!());\n+        forest.process_obligations::<(),_>(|_, _, _| unreachable!());\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n }\n@@ -150,9 +161,10 @@ fn to_errors_no_throw() {\n     // check that converting multiple children with common parent (A)\n     // only yields one of them (and does not panic, in particular).\n     let mut forest = ObligationForest::new();\n-    forest.push_root(\"A\");\n+    forest.push_tree(\"A\", \"A\");\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, _| {\n+        forest.process_obligations::<(),_>(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n                 _ => unreachable!(),\n@@ -168,10 +180,11 @@ fn to_errors_no_throw() {\n fn backtrace() {\n     // check that converting multiple children with common parent (A)\n     // only yields one of them (and does not panic, in particular).\n-    let mut forest: ObligationForest<&'static str> = ObligationForest::new();\n-    forest.push_root(\"A\");\n+    let mut forest = ObligationForest::new();\n+    forest.push_tree(\"A\", \"A\");\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, mut backtrace| {\n+        forest.process_obligations::<(),_>(|obligation, tree, mut backtrace| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             assert!(backtrace.next().is_none());\n             match *obligation {\n                 \"A\" => Ok(Some(vec![\"A.1\"])),\n@@ -181,7 +194,8 @@ fn backtrace() {\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, mut backtrace| {\n+        forest.process_obligations::<(),_>(|obligation, tree, mut backtrace| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             assert!(backtrace.next().unwrap() == &\"A\");\n             assert!(backtrace.next().is_none());\n             match *obligation {\n@@ -192,7 +206,8 @@ fn backtrace() {\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, mut backtrace| {\n+        forest.process_obligations::<(),_>(|obligation, tree, mut backtrace| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             assert!(backtrace.next().unwrap() == &\"A.1\");\n             assert!(backtrace.next().unwrap() == &\"A\");\n             assert!(backtrace.next().is_none());"}, {"sha": "a9f5483f45b3e24ad71340cb43df2a58e26f0f7a", "filename": "src/librustc_data_structures/obligation_forest/tree_index.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/37815fde39fc828318621f1c047ffd353621f026/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftree_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37815fde39fc828318621f1c047ffd353621f026/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftree_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftree_index.rs?ref=37815fde39fc828318621f1c047ffd353621f026", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::u32;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct TreeIndex {\n+    index: u32\n+}\n+\n+impl TreeIndex {\n+    pub fn new(value: usize) -> TreeIndex {\n+        assert!(value < (u32::MAX as usize));\n+        TreeIndex { index: value as u32 }\n+    }\n+\n+    pub fn get(self) -> usize {\n+        self.index as usize\n+    }\n+}\n+"}]}