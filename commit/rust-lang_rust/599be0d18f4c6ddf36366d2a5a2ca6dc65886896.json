{"sha": "599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5OWJlMGQxOGY0YzZkZGYzNjM2NmQyYTVhMmNhNmRjNjU4ODY4OTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-26T21:08:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-26T21:08:38Z"}, "message": "Auto merge of #43487 - Mark-Simulacrum:rollup, r=Mark-Simulacrum\n\nRollup of 10 pull requests\n\n- Successful merges: #42959, #43447, #43455, #43456, #43458, #43462, #43463, #43465, #43471, #43480\n- Failed merges:", "tree": {"sha": "b45698b672fa56662213f15740197fc32db9252f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b45698b672fa56662213f15740197fc32db9252f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "html_url": "https://github.com/rust-lang/rust/commit/599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d02fb3bcf42c05740a47fdfb0d9e5dd8ec24ff37", "url": "https://api.github.com/repos/rust-lang/rust/commits/d02fb3bcf42c05740a47fdfb0d9e5dd8ec24ff37", "html_url": "https://github.com/rust-lang/rust/commit/d02fb3bcf42c05740a47fdfb0d9e5dd8ec24ff37"}, {"sha": "959ebd6785b48360ac48e334a18b3abe66beef17", "url": "https://api.github.com/repos/rust-lang/rust/commits/959ebd6785b48360ac48e334a18b3abe66beef17", "html_url": "https://github.com/rust-lang/rust/commit/959ebd6785b48360ac48e334a18b3abe66beef17"}], "stats": {"total": 867, "additions": 631, "deletions": 236}, "files": [{"sha": "f8fd6710399a1a557155cb5be4922fe6a6f694c0", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -1 +1 @@\n-Subproject commit 81134a4dff811403b3b2f349b0c59a819f0fe0c1\n+Subproject commit f8fd6710399a1a557155cb5be4922fe6a6f694c0"}, {"sha": "efc59d2cbc86f9a586ccadcf8e78038b3c50fdca", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -892,7 +892,7 @@ pub unsafe trait Alloc {\n     {\n         let k = Layout::new::<T>();\n         if k.size() > 0 {\n-            unsafe { self.alloc(k).map(|p| Unique::new(p as *mut T)) }\n+            unsafe { self.alloc(k).map(|p| Unique::new_unchecked(p as *mut T)) }\n         } else {\n             Err(AllocErr::invalid_input(\"zero-sized type invalid for alloc_one\"))\n         }\n@@ -963,7 +963,7 @@ pub unsafe trait Alloc {\n                 unsafe {\n                     self.alloc(layout.clone())\n                         .map(|p| {\n-                            Unique::new(p as *mut T)\n+                            Unique::new_unchecked(p as *mut T)\n                         })\n                 }\n             }\n@@ -1012,7 +1012,7 @@ pub unsafe trait Alloc {\n         match (Layout::array::<T>(n_old), Layout::array::<T>(n_new), ptr.as_ptr()) {\n             (Some(ref k_old), Some(ref k_new), ptr) if k_old.size() > 0 && k_new.size() > 0 => {\n                 self.realloc(ptr as *mut u8, k_old.clone(), k_new.clone())\n-                    .map(|p|Unique::new(p as *mut T))\n+                    .map(|p|Unique::new_unchecked(p as *mut T))\n             }\n             _ => {\n                 Err(AllocErr::invalid_input(\"invalid layout for realloc_array\"))"}, {"sha": "9e3142519341777cca7803f8e663bdca417ef00c", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -280,7 +280,7 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUsize::new(1),\n             data: data,\n         };\n-        Arc { ptr: unsafe { Shared::new(Box::into_raw(x)) } }\n+        Arc { ptr: Shared::from(Box::into_unique(x)) }\n     }\n \n     /// Returns the contained value, if the `Arc` has exactly one strong reference.\n@@ -382,7 +382,7 @@ impl<T> Arc<T> {\n         // `data` field from the pointer.\n         let ptr = (ptr as *const u8).offset(-offset_of!(ArcInner<T>, data));\n         Arc {\n-            ptr: Shared::new(ptr as *mut u8 as *mut _),\n+            ptr: Shared::new_unchecked(ptr as *mut u8 as *mut _),\n         }\n     }\n }\n@@ -842,7 +842,7 @@ impl<T> Weak<T> {\n     pub fn new() -> Weak<T> {\n         unsafe {\n             Weak {\n-                ptr: Shared::new(Box::into_raw(box ArcInner {\n+                ptr: Shared::from(Box::into_unique(box ArcInner {\n                     strong: atomic::AtomicUsize::new(0),\n                     weak: atomic::AtomicUsize::new(1),\n                     data: uninitialized(),"}, {"sha": "6318d22059f96c09339337a9f32dd23453b1a96c", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -297,6 +297,37 @@ impl<T: ?Sized> Box<T> {\n     pub fn into_raw(b: Box<T>) -> *mut T {\n         unsafe { mem::transmute(b) }\n     }\n+\n+    /// Consumes the `Box`, returning the wrapped pointer as `Unique<T>`.\n+    ///\n+    /// After calling this function, the caller is responsible for the\n+    /// memory previously managed by the `Box`. In particular, the\n+    /// caller should properly destroy `T` and release the memory. The\n+    /// proper way to do so is to convert the raw pointer back into a\n+    /// `Box` with the [`Box::from_raw`] function.\n+    ///\n+    /// Note: this is an associated function, which means that you have\n+    /// to call it as `Box::into_unique(b)` instead of `b.into_unique()`. This\n+    /// is so that there is no conflict with a method on the inner type.\n+    ///\n+    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(unique)]\n+    ///\n+    /// fn main() {\n+    ///     let x = Box::new(5);\n+    ///     let ptr = Box::into_unique(x);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\",\n+               issue = \"27730\")]\n+    #[inline]\n+    pub fn into_unique(b: Box<T>) -> Unique<T> {\n+        unsafe { mem::transmute(b) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "06d3a113b947471989ad7a803cb77e490f9f5038", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -140,24 +140,22 @@ struct BoxedNode<K, V> {\n \n impl<K, V> BoxedNode<K, V> {\n     fn from_leaf(node: Box<LeafNode<K, V>>) -> Self {\n-        unsafe {\n-            BoxedNode { ptr: Unique::new(Box::into_raw(node)) }\n-        }\n+        BoxedNode { ptr: Box::into_unique(node) }\n     }\n \n     fn from_internal(node: Box<InternalNode<K, V>>) -> Self {\n         unsafe {\n-            BoxedNode { ptr: Unique::new(Box::into_raw(node) as *mut LeafNode<K, V>) }\n+            BoxedNode { ptr: Unique::new_unchecked(Box::into_raw(node) as *mut LeafNode<K, V>) }\n         }\n     }\n \n     unsafe fn from_ptr(ptr: NonZero<*const LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::new(ptr.get() as *mut LeafNode<K, V>) }\n+        BoxedNode { ptr: Unique::new_unchecked(ptr.get() as *mut LeafNode<K, V>) }\n     }\n \n     fn as_ptr(&self) -> NonZero<*const LeafNode<K, V>> {\n         unsafe {\n-            NonZero::new(self.ptr.as_ptr())\n+            NonZero::from(self.ptr.as_ref())\n         }\n     }\n }\n@@ -384,21 +382,19 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         >,\n         Self\n     > {\n-        if self.as_leaf().parent.is_null() {\n-            Err(self)\n-        } else {\n+        if let Some(non_zero) = NonZero::new(self.as_leaf().parent as *const LeafNode<K, V>) {\n             Ok(Handle {\n                 node: NodeRef {\n                     height: self.height + 1,\n-                    node: unsafe {\n-                        NonZero::new(self.as_leaf().parent as *mut LeafNode<K, V>)\n-                    },\n+                    node: non_zero,\n                     root: self.root,\n                     _marker: PhantomData\n                 },\n                 idx: self.as_leaf().parent_idx as usize,\n                 _marker: PhantomData\n             })\n+        } else {\n+            Err(self)\n         }\n     }\n "}, {"sha": "850dd6adcf0af08e3d8c033f500b1b577e53a397", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -157,7 +157,7 @@ impl<T> LinkedList<T> {\n         unsafe {\n             node.next = self.head;\n             node.prev = None;\n-            let node = Some(Shared::new(Box::into_raw(node)));\n+            let node = Some(Shared::from(Box::into_unique(node)));\n \n             match self.head {\n                 None => self.tail = node,\n@@ -192,7 +192,7 @@ impl<T> LinkedList<T> {\n         unsafe {\n             node.next = None;\n             node.prev = self.tail;\n-            let node = Some(Shared::new(Box::into_raw(node)));\n+            let node = Some(Shared::from(Box::into_unique(node)));\n \n             match self.tail {\n                 None => self.head = node,\n@@ -921,7 +921,7 @@ impl<'a, T> IterMut<'a, T> {\n                     Some(prev) => prev,\n                 };\n \n-                let node = Some(Shared::new(Box::into_raw(box Node {\n+                let node = Some(Shared::from(Box::into_unique(box Node {\n                     next: Some(head),\n                     prev: Some(prev),\n                     element: element,"}, {"sha": "ca55831220da6ba72530d9ffa7499b409a4c6c7f", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -104,7 +104,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             };\n \n             RawVec {\n-                ptr: Unique::new(ptr as *mut _),\n+                ptr: Unique::new_unchecked(ptr as *mut _),\n                 cap: cap,\n                 a: a,\n             }\n@@ -159,7 +159,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// If the ptr and capacity come from a RawVec created via `a`, then this is guaranteed.\n     pub unsafe fn from_raw_parts_in(ptr: *mut T, cap: usize, a: A) -> Self {\n         RawVec {\n-            ptr: Unique::new(ptr),\n+            ptr: Unique::new_unchecked(ptr),\n             cap: cap,\n             a: a,\n         }\n@@ -176,7 +176,7 @@ impl<T> RawVec<T, Heap> {\n     /// If the ptr and capacity come from a RawVec, then this is guaranteed.\n     pub unsafe fn from_raw_parts(ptr: *mut T, cap: usize) -> Self {\n         RawVec {\n-            ptr: Unique::new(ptr),\n+            ptr: Unique::new_unchecked(ptr),\n             cap: cap,\n             a: Heap,\n         }"}, {"sha": "a2184054b377ebddde035eeea2cf5c1f4eb7769b", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -303,18 +303,16 @@ impl<T> Rc<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> Rc<T> {\n-        unsafe {\n-            Rc {\n-                // there is an implicit weak pointer owned by all the strong\n-                // pointers, which ensures that the weak destructor never frees\n-                // the allocation while the strong destructor is running, even\n-                // if the weak pointer is stored inside the strong one.\n-                ptr: Shared::new(Box::into_raw(box RcBox {\n-                    strong: Cell::new(1),\n-                    weak: Cell::new(1),\n-                    value: value,\n-                })),\n-            }\n+        Rc {\n+            // there is an implicit weak pointer owned by all the strong\n+            // pointers, which ensures that the weak destructor never frees\n+            // the allocation while the strong destructor is running, even\n+            // if the weak pointer is stored inside the strong one.\n+            ptr: Shared::from(Box::into_unique(box RcBox {\n+                strong: Cell::new(1),\n+                weak: Cell::new(1),\n+                value: value,\n+            })),\n         }\n     }\n \n@@ -418,7 +416,7 @@ impl<T> Rc<T> {\n \n         let ptr = (ptr as *const u8).offset(-offset_of!(RcBox<T>, value));\n         Rc {\n-            ptr: Shared::new(ptr as *mut u8 as *mut _)\n+            ptr: Shared::new_unchecked(ptr as *mut u8 as *mut _)\n         }\n     }\n }\n@@ -443,7 +441,7 @@ impl Rc<str> {\n             // Combine the allocation address and the string length into a fat pointer to `RcBox`.\n             let rcbox_ptr: *mut RcBox<str> = mem::transmute([ptr as usize, value.len()]);\n             assert!(aligned_len * size_of::<usize>() == size_of_val(&*rcbox_ptr));\n-            Rc { ptr: Shared::new(rcbox_ptr) }\n+            Rc { ptr: Shared::new_unchecked(rcbox_ptr) }\n         }\n     }\n }\n@@ -476,7 +474,7 @@ impl<T> Rc<[T]> {\n             // Free the original allocation without freeing its (moved) contents.\n             box_free(Box::into_raw(value));\n \n-            Rc { ptr: Shared::new(ptr as *mut _) }\n+            Rc { ptr: Shared::new_unchecked(ptr as *mut _) }\n         }\n     }\n }\n@@ -1016,7 +1014,7 @@ impl<T> Weak<T> {\n     pub fn new() -> Weak<T> {\n         unsafe {\n             Weak {\n-                ptr: Shared::new(Box::into_raw(box RcBox {\n+                ptr: Shared::from(Box::into_unique(box RcBox {\n                     strong: Cell::new(0),\n                     weak: Cell::new(1),\n                     value: uninitialized(),"}, {"sha": "da47ca509832b95e5f9236f28e033def89ee930a", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -1126,7 +1126,7 @@ impl<T> Vec<T> {\n                 tail_start: end,\n                 tail_len: len - end,\n                 iter: range_slice.iter(),\n-                vec: Shared::new(self as *mut _),\n+                vec: Shared::from(self),\n             }\n         }\n     }\n@@ -1727,7 +1727,7 @@ impl<T> IntoIterator for Vec<T> {\n             let cap = self.buf.cap();\n             mem::forget(self);\n             IntoIter {\n-                buf: Shared::new(begin),\n+                buf: Shared::new_unchecked(begin),\n                 cap: cap,\n                 ptr: begin,\n                 end: end,\n@@ -1962,6 +1962,12 @@ impl<T> Vec<T> {\n \n }\n \n+/// Extend implementation that copies elements out of references before pushing them onto the Vec.\n+///\n+/// This implementation is specialized for slice iterators, where it uses [`copy_from_slice`] to\n+/// append the entire slice at once.\n+///\n+/// [`copy_from_slice`]: ../../std/primitive.slice.html#method.copy_from_slice\n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Copy> Extend<&'a T> for Vec<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {"}, {"sha": "fdd6c79ef2e9d74d8971033c588b7d0236cf76aa", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -893,7 +893,7 @@ impl<T> VecDeque<T> {\n         self.head = drain_tail;\n \n         Drain {\n-            deque: unsafe { Shared::new(self as *mut _) },\n+            deque: Shared::from(&mut *self),\n             after_tail: drain_head,\n             after_head: head,\n             iter: Iter {"}, {"sha": "3ff1068b93763581de7f71133b75bd8194eb1ea6", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 72, "deletions": 17, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -16,22 +16,48 @@\n use ops::CoerceUnsized;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n-pub unsafe trait Zeroable {}\n-\n-unsafe impl<T:?Sized> Zeroable for *const T {}\n-unsafe impl<T:?Sized> Zeroable for *mut T {}\n-unsafe impl Zeroable for isize {}\n-unsafe impl Zeroable for usize {}\n-unsafe impl Zeroable for i8 {}\n-unsafe impl Zeroable for u8 {}\n-unsafe impl Zeroable for i16 {}\n-unsafe impl Zeroable for u16 {}\n-unsafe impl Zeroable for i32 {}\n-unsafe impl Zeroable for u32 {}\n-unsafe impl Zeroable for i64 {}\n-unsafe impl Zeroable for u64 {}\n-unsafe impl Zeroable for i128 {}\n-unsafe impl Zeroable for u128 {}\n+pub unsafe trait Zeroable {\n+    /// Whether this value is zero\n+    fn is_zero(&self) -> bool;\n+}\n+\n+macro_rules! impl_zeroable_for_pointer_types {\n+    ( $( $Ptr: ty )+ ) => {\n+        $(\n+            /// For fat pointers to be considered \"zero\", only the \"data\" part needs to be null.\n+            unsafe impl<T: ?Sized> Zeroable for $Ptr {\n+                #[inline]\n+                fn is_zero(&self) -> bool {\n+                    // Cast because `is_null` is only available on thin pointers\n+                    (*self as *mut u8).is_null()\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+macro_rules! impl_zeroable_for_integer_types {\n+    ( $( $Int: ty )+ ) => {\n+        $(\n+            unsafe impl Zeroable for $Int {\n+                #[inline]\n+                fn is_zero(&self) -> bool {\n+                    *self == 0\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+impl_zeroable_for_pointer_types! {\n+    *const T\n+    *mut T\n+}\n+\n+impl_zeroable_for_integer_types! {\n+    usize u8 u16 u32 u64 u128\n+    isize i8 i16 i32 i64 i128\n+}\n \n /// A wrapper type for raw pointers and integers that will never be\n /// NULL or 0 that might allow certain optimizations.\n@@ -43,14 +69,43 @@ impl<T: Zeroable> NonZero<T> {\n     /// Creates an instance of NonZero with the provided value.\n     /// You must indeed ensure that the value is actually \"non-zero\".\n     #[inline]\n-    pub const unsafe fn new(inner: T) -> NonZero<T> {\n+    pub const unsafe fn new_unchecked(inner: T) -> Self {\n         NonZero(inner)\n     }\n \n+    /// Creates an instance of NonZero with the provided value.\n+    #[inline]\n+    pub fn new(inner: T) -> Option<Self> {\n+        if inner.is_zero() {\n+            None\n+        } else {\n+            Some(NonZero(inner))\n+        }\n+    }\n+\n     /// Gets the inner value.\n     pub fn get(self) -> T {\n         self.0\n     }\n }\n \n impl<T: Zeroable+CoerceUnsized<U>, U: Zeroable> CoerceUnsized<NonZero<U>> for NonZero<T> {}\n+\n+impl<'a, T: ?Sized> From<&'a mut T> for NonZero<*mut T> {\n+    fn from(reference: &'a mut T) -> Self {\n+        NonZero(reference)\n+    }\n+}\n+\n+impl<'a, T: ?Sized> From<&'a mut T> for NonZero<*const T> {\n+    fn from(reference: &'a mut T) -> Self {\n+        let ptr: *mut T = reference;\n+        NonZero(ptr)\n+    }\n+}\n+\n+impl<'a, T: ?Sized> From<&'a T> for NonZero<*const T> {\n+    fn from(reference: &'a T) -> Self {\n+        NonZero(reference)\n+    }\n+}"}, {"sha": "d533310625e5946cc6bcefad3a99e8bb6a1d49ec", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -2622,21 +2622,24 @@ try_from_both_bounded!(i32, u16, u8);\n try_from_both_bounded!(i64, u32, u16, u8);\n try_from_both_bounded!(i128, u64, u32, u16, u8);\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n-pub use self::ptr_try_from_impls::*;\n+// usize/isize\n+try_from_unbounded!(usize, usize);\n+try_from_upper_bounded!(usize, isize);\n+try_from_lower_bounded!(isize, usize);\n+try_from_unbounded!(isize, isize);\n \n #[cfg(target_pointer_width = \"16\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n     use convert::TryFrom;\n \n     try_from_upper_bounded!(usize, u8);\n-    try_from_unbounded!(usize, usize, u16, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, isize);\n+    try_from_unbounded!(usize, u16, u32, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16);\n     try_from_unbounded!(usize, i32, i64, i128);\n \n     try_from_both_bounded!(isize, u8);\n-    try_from_lower_bounded!(isize, usize, u16, u32, u64, u128);\n+    try_from_lower_bounded!(isize, u16, u32, u64, u128);\n     try_from_both_bounded!(isize, i8);\n     try_from_unbounded!(isize, i16, i32, i64, i128);\n \n@@ -2657,12 +2660,12 @@ mod ptr_try_from_impls {\n     use convert::TryFrom;\n \n     try_from_upper_bounded!(usize, u8, u16);\n-    try_from_unbounded!(usize, usize, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32, isize);\n+    try_from_unbounded!(usize, u32, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16, i32);\n     try_from_unbounded!(usize, i64, i128);\n \n     try_from_both_bounded!(isize, u8, u16);\n-    try_from_lower_bounded!(isize, usize, u32, u64, u128);\n+    try_from_lower_bounded!(isize, u32, u64, u128);\n     try_from_both_bounded!(isize, i8, i16);\n     try_from_unbounded!(isize, i32, i64, i128);\n \n@@ -2683,12 +2686,12 @@ mod ptr_try_from_impls {\n     use convert::TryFrom;\n \n     try_from_upper_bounded!(usize, u8, u16, u32);\n-    try_from_unbounded!(usize, usize, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32, i64, isize);\n+    try_from_unbounded!(usize, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n     try_from_unbounded!(usize, i128);\n \n     try_from_both_bounded!(isize, u8, u16, u32);\n-    try_from_lower_bounded!(isize, usize, u64, u128);\n+    try_from_lower_bounded!(isize, u64, u128);\n     try_from_both_bounded!(isize, i8, i16, i32);\n     try_from_unbounded!(isize, i64, i128);\n "}, {"sha": "60cf1a2053068862dacfe63bb2d434034fecb621", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 54, "deletions": 8, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -16,6 +16,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use convert::From;\n use intrinsics;\n use ops::CoerceUnsized;\n use fmt;\n@@ -1098,7 +1099,7 @@ impl<T: Sized> Unique<T> {\n     pub fn empty() -> Self {\n         unsafe {\n             let ptr = mem::align_of::<T>() as *mut T;\n-            Unique::new(ptr)\n+            Unique::new_unchecked(ptr)\n         }\n     }\n }\n@@ -1110,8 +1111,13 @@ impl<T: ?Sized> Unique<T> {\n     /// # Safety\n     ///\n     /// `ptr` must be non-null.\n-    pub const unsafe fn new(ptr: *mut T) -> Unique<T> {\n-        Unique { pointer: NonZero::new(ptr), _marker: PhantomData }\n+    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n+        Unique { pointer: NonZero::new_unchecked(ptr), _marker: PhantomData }\n+    }\n+\n+    /// Creates a new `Unique` if `ptr` is non-null.\n+    pub fn new(ptr: *mut T) -> Option<Self> {\n+        NonZero::new(ptr as *const T).map(|nz| Unique { pointer: nz, _marker: PhantomData })\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n@@ -1138,14 +1144,14 @@ impl<T: ?Sized> Unique<T> {\n     }\n }\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n+#[unstable(feature = \"unique\", issue = \"27730\")]\n impl<T: ?Sized> Clone for Unique<T> {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n+#[unstable(feature = \"unique\", issue = \"27730\")]\n impl<T: ?Sized> Copy for Unique<T> { }\n \n #[unstable(feature = \"unique\", issue = \"27730\")]\n@@ -1158,6 +1164,20 @@ impl<T: ?Sized> fmt::Pointer for Unique<T> {\n     }\n }\n \n+#[unstable(feature = \"unique\", issue = \"27730\")]\n+impl<'a, T: ?Sized> From<&'a mut T> for Unique<T> {\n+    fn from(reference: &'a mut T) -> Self {\n+        Unique { pointer: NonZero::from(reference), _marker: PhantomData }\n+    }\n+}\n+\n+#[unstable(feature = \"unique\", issue = \"27730\")]\n+impl<'a, T: ?Sized> From<&'a T> for Unique<T> {\n+    fn from(reference: &'a T) -> Self {\n+        Unique { pointer: NonZero::from(reference), _marker: PhantomData }\n+    }\n+}\n+\n /// A wrapper around a raw `*mut T` that indicates that the possessor\n /// of this wrapper has shared ownership of the referent. Useful for\n /// building abstractions like `Rc<T>`, `Arc<T>`, or doubly-linked lists, which\n@@ -1212,7 +1232,7 @@ impl<T: Sized> Shared<T> {\n     pub fn empty() -> Self {\n         unsafe {\n             let ptr = mem::align_of::<T>() as *mut T;\n-            Shared::new(ptr)\n+            Shared::new_unchecked(ptr)\n         }\n     }\n }\n@@ -1224,8 +1244,13 @@ impl<T: ?Sized> Shared<T> {\n     /// # Safety\n     ///\n     /// `ptr` must be non-null.\n-    pub unsafe fn new(ptr: *mut T) -> Self {\n-        Shared { pointer: NonZero::new(ptr), _marker: PhantomData }\n+    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n+        Shared { pointer: NonZero::new_unchecked(ptr), _marker: PhantomData }\n+    }\n+\n+    /// Creates a new `Shared` if `ptr` is non-null.\n+    pub fn new(ptr: *mut T) -> Option<Self> {\n+        NonZero::new(ptr as *const T).map(|nz| Shared { pointer: nz, _marker: PhantomData })\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n@@ -1278,3 +1303,24 @@ impl<T: ?Sized> fmt::Pointer for Shared<T> {\n         fmt::Pointer::fmt(&self.as_ptr(), f)\n     }\n }\n+\n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<T: ?Sized> From<Unique<T>> for Shared<T> {\n+    fn from(unique: Unique<T>) -> Self {\n+        Shared { pointer: unique.pointer, _marker: PhantomData }\n+    }\n+}\n+\n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<'a, T: ?Sized> From<&'a mut T> for Shared<T> {\n+    fn from(reference: &'a mut T) -> Self {\n+        Shared { pointer: NonZero::from(reference), _marker: PhantomData }\n+    }\n+}\n+\n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<'a, T: ?Sized> From<&'a T> for Shared<T> {\n+    fn from(reference: &'a T) -> Self {\n+        Shared { pointer: NonZero::from(reference), _marker: PhantomData }\n+    }\n+}"}, {"sha": "a795dd575043dd883d2f1e00576eca63cecbc570", "filename": "src/libcore/tests/nonzero.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnonzero.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -16,7 +16,7 @@ use std::mem::size_of;\n #[test]\n fn test_create_nonzero_instance() {\n     let _a = unsafe {\n-        NonZero::new(21)\n+        NonZero::new_unchecked(21)\n     };\n }\n \n@@ -28,14 +28,14 @@ fn test_size_nonzero_in_option() {\n #[test]\n fn test_match_on_nonzero_option() {\n     let a = Some(unsafe {\n-        NonZero::new(42)\n+        NonZero::new_unchecked(42)\n     });\n     match a {\n         Some(val) => assert_eq!(val.get(), 42),\n         None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n     }\n \n-    match unsafe { Some(NonZero::new(43)) } {\n+    match unsafe { Some(NonZero::new_unchecked(43)) } {\n         Some(val) => assert_eq!(val.get(), 43),\n         None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n     }"}, {"sha": "046b81e19f70d441ad67bb44905fdd9c826beb2a", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -279,7 +279,7 @@ test_impl_try_from_always_ok! { test_try_u64u64, u64, u64 }\n test_impl_try_from_always_ok! { test_try_u64u128, u64, u128 }\n test_impl_try_from_always_ok! { test_try_u64i128, u64, i128 }\n \n-test_impl_try_from_always_ok! { test_try_u128, u128, u128 }\n+test_impl_try_from_always_ok! { test_try_u128u128, u128, u128 }\n \n test_impl_try_from_always_ok! { test_try_i8i8, i8, i8 }\n test_impl_try_from_always_ok! { test_try_i8i16, i8, i16 }\n@@ -301,8 +301,12 @@ test_impl_try_from_always_ok! { test_try_i64i128, i64, i128 }\n \n test_impl_try_from_always_ok! { test_try_i128i128, i128, i128 }\n \n+test_impl_try_from_always_ok! { test_try_usizeusize, usize, usize }\n+test_impl_try_from_always_ok! { test_try_isizeisize, isize, isize }\n+\n assume_usize_width! {\n     test_impl_try_from_always_ok! { test_try_u8usize, u8, usize }\n+    test_impl_try_from_always_ok! { test_try_u8isize, u8, isize }\n     test_impl_try_from_always_ok! { test_try_i8isize, i8, isize }\n \n     test_impl_try_from_always_ok! { test_try_u16usize, u16, usize }\n@@ -317,19 +321,27 @@ assume_usize_width! {\n \n     cfg_block!(\n         #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_always_ok! { test_try_u16usize, u16, usize }\n-            test_impl_try_from_always_ok! { test_try_i16isize, i16, isize }\n+            test_impl_try_from_always_ok! { test_try_usizeu16, usize, u16 }\n+            test_impl_try_from_always_ok! { test_try_isizei16, isize, i16 }\n+            test_impl_try_from_always_ok! { test_try_usizeu32, usize, u32 }\n+            test_impl_try_from_always_ok! { test_try_usizei32, usize, i32 }\n+            test_impl_try_from_always_ok! { test_try_isizei32, isize, i32 }\n+            test_impl_try_from_always_ok! { test_try_usizei64, usize, i64 }\n         }\n \n         #[cfg(target_pointer_width = \"32\")] {\n+            test_impl_try_from_always_ok! { test_try_u16isize, u16, isize }\n             test_impl_try_from_always_ok! { test_try_usizeu32, usize, u32 }\n             test_impl_try_from_always_ok! { test_try_isizei32, isize, i32 }\n             test_impl_try_from_always_ok! { test_try_u32usize, u32, usize }\n             test_impl_try_from_always_ok! { test_try_i32isize, i32, isize }\n+            test_impl_try_from_always_ok! { test_try_usizei64, usize, i64 }\n         }\n \n         #[cfg(target_pointer_width = \"64\")] {\n+            test_impl_try_from_always_ok! { test_try_u16isize, u16, isize }\n             test_impl_try_from_always_ok! { test_try_u32usize, u32, usize }\n+            test_impl_try_from_always_ok! { test_try_u32isize, u32, isize }\n             test_impl_try_from_always_ok! { test_try_i32isize, i32, isize }\n             test_impl_try_from_always_ok! { test_try_u64usize, u64, usize }\n             test_impl_try_from_always_ok! { test_try_i64isize, i64, isize }\n@@ -451,8 +463,8 @@ assume_usize_width! {\n \n     cfg_block!(\n         #[cfg(target_pointer_width = \"16\")] {\n+            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u16isize, u16, isize }\n             test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32isize, u32, isize }\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32isize, u64, isize }\n         }\n \n         #[cfg(target_pointer_width = \"32\")] {"}, {"sha": "c2d53840f8f570e572c6fc48ba5114bb4fb577b8", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -167,7 +167,7 @@ fn test_set_memory() {\n #[test]\n fn test_unsized_unique() {\n     let xs: &[i32] = &[1, 2, 3];\n-    let ptr = unsafe { Unique::new(xs as *const [i32] as *mut [i32]) };\n+    let ptr = unsafe { Unique::new_unchecked(xs as *const [i32] as *mut [i32]) };\n     let ys = unsafe { ptr.as_ref() };\n     let zs: &[i32] = &[1, 2, 3];\n     assert!(ys == zs);"}, {"sha": "d78e17ce03cef91e9c2f61f5a31b592102ceb3df", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -1208,13 +1208,13 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     BorrowKind::Mut | BorrowKind::Unique => \"mut \",\n                 };\n \n-                // When identifying regions, add trailing space if\n-                // necessary.\n-                let region = if ppaux::identify_regions() {\n+                // When printing regions, add trailing space if necessary.\n+                let region = if ppaux::verbose() || ppaux::identify_regions() {\n                     let mut region = format!(\"{}\", region);\n                     if region.len() > 0 { region.push(' '); }\n                     region\n                 } else {\n+                    // Do not even print 'static\n                     \"\".to_owned()\n                 };\n                 write!(fmt, \"&{}{}{:?}\", region, kind_str, lv)"}, {"sha": "e2881ac9b798e81ccf56db8b9aac588cc2608eb9", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n         let ptr = ty as *const _ as usize;\n         Kind {\n             ptr: unsafe {\n-                NonZero::new(ptr | TYPE_TAG)\n+                NonZero::new_unchecked(ptr | TYPE_TAG)\n             },\n             marker: PhantomData\n         }\n@@ -62,7 +62,7 @@ impl<'tcx> From<ty::Region<'tcx>> for Kind<'tcx> {\n         let ptr = r as *const _ as usize;\n         Kind {\n             ptr: unsafe {\n-                NonZero::new(ptr | REGION_TAG)\n+                NonZero::new_unchecked(ptr | REGION_TAG)\n             },\n             marker: PhantomData\n         }"}, {"sha": "ced73e9e4262767cd4f740200b8116b7ae876ccd", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -146,7 +146,7 @@ impl<A: Array> ArrayVec<A> {\n                 tail_start: end,\n                 tail_len: len - end,\n                 iter: range_slice.iter(),\n-                array_vec: Shared::new(self as *mut _),\n+                array_vec: Shared::from(self),\n             }\n         }\n     }"}, {"sha": "5adeef1ab3a6db5487265ac25fa444b3af8192a2", "filename": "src/librustc_data_structures/blake2b.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_data_structures%2Fblake2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_data_structures%2Fblake2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fblake2b.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -23,6 +23,7 @@\n use std::mem;\n use std::slice;\n \n+#[repr(C)]\n pub struct Blake2bCtx {\n     b: [u8; 128],\n     h: [u64; 8],"}, {"sha": "a72cc6b57eade5fa6c0ed07ff28d02581fd91860", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -19,7 +19,7 @@ pub struct NodeIndex {\n impl NodeIndex {\n     pub fn new(value: usize) -> NodeIndex {\n         assert!(value < (u32::MAX as usize));\n-        unsafe { NodeIndex { index: NonZero::new((value as u32) + 1) } }\n+        NodeIndex { index: NonZero::new((value as u32) + 1).unwrap() }\n     }\n \n     pub fn get(self) -> usize {"}, {"sha": "fbf977b98f901b2f47bcb0c5418318efd65e2662", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -42,7 +42,7 @@ pub(crate) mod indexes {\n \n             impl Idx for $Index {\n                 fn new(idx: usize) -> Self {\n-                    unsafe { $Index(NonZero::new(idx + 1)) }\n+                    $Index(NonZero::new(idx + 1).unwrap())\n                 }\n                 fn index(self) -> usize {\n                     self.0.get() - 1"}, {"sha": "a061484b5c4a51032018e2fa7fa5324a9b030c75", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -35,6 +35,7 @@ use syntax::attr;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::codemap::respan;\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::hygiene::Mark;\n@@ -119,22 +120,24 @@ impl<'a> Resolver<'a> {\n                                  .unwrap()\n                                  .1\n                                  .iter()\n-                                 .map(|seg| seg.identifier)\n+                                 .map(|seg| respan(seg.span, seg.identifier))\n                                  .collect()\n                     }\n \n                     ViewPathGlob(ref module_ident_path) |\n                     ViewPathList(ref module_ident_path, _) => {\n                         module_ident_path.segments\n                                          .iter()\n-                                         .map(|seg| seg.identifier)\n+                                         .map(|seg| respan(seg.span, seg.identifier))\n                                          .collect()\n                     }\n                 };\n \n                 // This can be removed once warning cycle #36888 is complete.\n-                if module_path.len() >= 2 && module_path[0].name == keywords::CrateRoot.name() &&\n-                   token::Ident(module_path[1]).is_path_segment_keyword() {\n+                if module_path.len() >= 2 &&\n+                    module_path[0].node.name == keywords::CrateRoot.name() &&\n+                    token::Ident(module_path[1].node).is_path_segment_keyword()\n+                {\n                     module_path.remove(0);\n                 }\n \n@@ -202,10 +205,13 @@ impl<'a> Resolver<'a> {\n                             let (module_path, ident, rename, type_ns_only) = {\n                                 if node.name.name != keywords::SelfValue.name() {\n                                     let rename = node.rename.unwrap_or(node.name);\n-                                    (module_path.clone(), node.name, rename, false)\n+                                    (module_path.clone(),\n+                                     respan(source_item.span, node.name),\n+                                     rename,\n+                                     false)\n                                 } else {\n                                     let ident = *module_path.last().unwrap();\n-                                    if ident.name == keywords::CrateRoot.name() {\n+                                    if ident.node.name == keywords::CrateRoot.name() {\n                                         resolve_error(\n                                             self,\n                                             source_item.span,\n@@ -215,13 +221,13 @@ impl<'a> Resolver<'a> {\n                                         continue;\n                                     }\n                                     let module_path = module_path.split_last().unwrap().1;\n-                                    let rename = node.rename.unwrap_or(ident);\n+                                    let rename = node.rename.unwrap_or(ident.node);\n                                     (module_path.to_vec(), ident, rename, true)\n                                 }\n                             };\n                             let subclass = SingleImport {\n                                 target: rename,\n-                                source: ident,\n+                                source: ident.node,\n                                 result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n                                 type_ns_only: type_ns_only,\n                             };"}, {"sha": "88013b45a05a4ac9f07cff84bd6efb4ec68546b9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 80, "deletions": 61, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -43,6 +43,7 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n+use syntax::codemap::{dummy_spanned, respan};\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, SpannedIdent, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n@@ -147,7 +148,7 @@ enum ResolutionError<'a> {\n     /// error E0431: `self` import can only appear in an import list with a non-empty prefix\n     SelfImportOnlyInImportListWithNonEmptyPrefix,\n     /// error E0432: unresolved import\n-    UnresolvedImport(Option<(&'a str, &'a str)>),\n+    UnresolvedImport(Option<(Span, &'a str, &'a str)>),\n     /// error E0433: failed to resolve\n     FailedToResolve(&'a str),\n     /// error E0434: can't capture dynamic environment in a fn item\n@@ -295,12 +296,12 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                               non-empty prefix\")\n         }\n         ResolutionError::UnresolvedImport(name) => {\n-            let msg = match name {\n-                Some((n, _)) => format!(\"unresolved import `{}`\", n),\n-                None => \"unresolved import\".to_owned(),\n+            let (span, msg) = match name {\n+                Some((sp, n, _)) => (sp, format!(\"unresolved import `{}`\", n)),\n+                None => (span, \"unresolved import\".to_owned()),\n             };\n             let mut err = struct_span_err!(resolver.session, span, E0432, \"{}\", msg);\n-            if let Some((_, p)) = name {\n+            if let Some((_, _, p)) = name {\n                 err.span_label(span, p);\n             }\n             err\n@@ -823,7 +824,7 @@ enum PathResult<'a> {\n     Module(Module<'a>),\n     NonModule(PathResolution),\n     Indeterminate,\n-    Failed(String, bool /* is the error from the last segment? */),\n+    Failed(Span, String, bool /* is the error from the last segment? */),\n }\n \n enum ModuleKind {\n@@ -1282,19 +1283,21 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool) {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         let hir::Path { ref segments, span, ref mut def } = *path;\n-        let path: Vec<_> = segments.iter().map(|seg| Ident::with_empty_ctxt(seg.name)).collect();\n+        let path: Vec<SpannedIdent> = segments.iter()\n+            .map(|seg| respan(span, Ident::with_empty_ctxt(seg.name)))\n+            .collect();\n         match self.resolve_path(&path, Some(namespace), true, span) {\n             PathResult::Module(module) => *def = module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 *def = path_res.base_def(),\n             PathResult::NonModule(..) => match self.resolve_path(&path, None, true, span) {\n-                PathResult::Failed(msg, _) => {\n+                PathResult::Failed(span, msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n                 _ => {}\n             },\n             PathResult::Indeterminate => unreachable!(),\n-            PathResult::Failed(msg, _) => {\n+            PathResult::Failed(span, msg, _) => {\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n             }\n         }\n@@ -1916,7 +1919,9 @@ impl<'a> Resolver<'a> {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n-            let path: Vec<_> = trait_ref.path.segments.iter().map(|seg| seg.identifier).collect();\n+            let path: Vec<_> = trait_ref.path.segments.iter()\n+                .map(|seg| respan(seg.span, seg.identifier))\n+                .collect();\n             let def = self.smart_resolve_path_fragment(trait_ref.ref_id,\n                                                        None,\n                                                        &path,\n@@ -2341,15 +2346,17 @@ impl<'a> Resolver<'a> {\n                           path: &Path,\n                           source: PathSource)\n                           -> PathResolution {\n-        let segments = &path.segments.iter().map(|seg| seg.identifier).collect::<Vec<_>>();\n+        let segments = &path.segments.iter()\n+            .map(|seg| respan(seg.span, seg.identifier))\n+            .collect::<Vec<_>>();\n         let ident_span = path.segments.last().map_or(path.span, |seg| seg.span);\n         self.smart_resolve_path_fragment(id, qself, segments, path.span, ident_span, source)\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n                                    id: NodeId,\n                                    qself: Option<&QSelf>,\n-                                   path: &[Ident],\n+                                   path: &[SpannedIdent],\n                                    span: Span,\n                                    ident_span: Span,\n                                    source: PathSource)\n@@ -2368,10 +2375,11 @@ impl<'a> Resolver<'a> {\n                 (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n                  format!(\"not a {}\", expected), span)\n             } else {\n-                let item_str = path[path.len() - 1];\n+                let item_str = path[path.len() - 1].node;\n+                let item_span = path[path.len() - 1].span;\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n                     (format!(\"\"), format!(\"this scope\"))\n-                } else if path.len() == 2 && path[0].name == keywords::CrateRoot.name() {\n+                } else if path.len() == 2 && path[0].node.name == keywords::CrateRoot.name() {\n                     (format!(\"\"), format!(\"the crate root\"))\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n@@ -2382,7 +2390,7 @@ impl<'a> Resolver<'a> {\n                     (mod_prefix, format!(\"`{}`\", names_to_string(mod_path)))\n                 };\n                 (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n-                 format!(\"not found in {}\", mod_str), ident_span)\n+                 format!(\"not found in {}\", mod_str), item_span)\n             };\n             let mut err = this.session.struct_span_err_with_code(base_span, &base_msg, code);\n \n@@ -2403,15 +2411,15 @@ impl<'a> Resolver<'a> {\n \n             // Try to lookup the name in more relaxed fashion for better error reporting.\n             let ident = *path.last().unwrap();\n-            let candidates = this.lookup_import_candidates(ident.name, ns, is_expected);\n+            let candidates = this.lookup_import_candidates(ident.node.name, ns, is_expected);\n             if !candidates.is_empty() {\n                 let mut module_span = this.current_module.span;\n                 module_span.hi = module_span.lo;\n                 // Report import candidates as help and proceed searching for labels.\n                 show_candidates(&mut err, module_span, &candidates, def.is_some());\n             } else if is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n                 let enum_candidates =\n-                    this.lookup_import_candidates(ident.name, ns, is_enum_variant);\n+                    this.lookup_import_candidates(ident.node.name, ns, is_enum_variant);\n                 let mut enum_candidates = enum_candidates.iter()\n                     .map(|suggestion| import_candidate_to_paths(&suggestion)).collect::<Vec<_>>();\n                 enum_candidates.sort();\n@@ -2429,8 +2437,8 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             if path.len() == 1 && this.self_type_is_available(span) {\n-                if let Some(candidate) = this.lookup_assoc_candidate(ident, ns, is_expected) {\n-                    let self_is_available = this.self_value_is_available(path[0].ctxt, span);\n+                if let Some(candidate) = this.lookup_assoc_candidate(ident.node, ns, is_expected) {\n+                    let self_is_available = this.self_value_is_available(path[0].node.ctxt, span);\n                     match candidate {\n                         AssocSuggestion::Field => {\n                             err.span_suggestion(span, \"try\",\n@@ -2546,7 +2554,7 @@ impl<'a> Resolver<'a> {\n                 // or `<T>::A::B`. If `B` should be resolved in value namespace then\n                 // it needs to be added to the trait map.\n                 if ns == ValueNS {\n-                    let item_name = *path.last().unwrap();\n+                    let item_name = path.last().unwrap().node;\n                     let traits = self.get_traits_containing_item(item_name, ns);\n                     self.trait_map.insert(id, traits);\n                 }\n@@ -2613,7 +2621,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_qpath_anywhere(&mut self,\n                               id: NodeId,\n                               qself: Option<&QSelf>,\n-                              path: &[Ident],\n+                              path: &[SpannedIdent],\n                               primary_ns: Namespace,\n                               span: Span,\n                               defer_to_typeck: bool,\n@@ -2633,9 +2641,10 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n         }\n-        let is_global = self.global_macros.get(&path[0].name).cloned()\n+        let is_global = self.global_macros.get(&path[0].node.name).cloned()\n             .map(|binding| binding.get_macro(self).kind() == MacroKind::Bang).unwrap_or(false);\n-        if primary_ns != MacroNS && (is_global || self.macro_names.contains(&path[0].modern())) {\n+        if primary_ns != MacroNS && (is_global ||\n+                                     self.macro_names.contains(&path[0].node.modern())) {\n             // Return some dummy definition, it's enough for error reporting.\n             return Some(\n                 PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))\n@@ -2648,7 +2657,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_qpath(&mut self,\n                      id: NodeId,\n                      qself: Option<&QSelf>,\n-                     path: &[Ident],\n+                     path: &[SpannedIdent],\n                      ns: Namespace,\n                      span: Span,\n                      global_by_default: bool)\n@@ -2688,8 +2697,9 @@ impl<'a> Resolver<'a> {\n             // The same fallback is used when `a` resolves to nothing.\n             PathResult::Module(..) | PathResult::Failed(..)\n                     if (ns == TypeNS || path.len() > 1) &&\n-                       self.primitive_type_table.primitive_types.contains_key(&path[0].name) => {\n-                let prim = self.primitive_type_table.primitive_types[&path[0].name];\n+                       self.primitive_type_table.primitive_types\n+                           .contains_key(&path[0].node.name) => {\n+                let prim = self.primitive_type_table.primitive_types[&path[0].node.name];\n                 match prim {\n                     TyUint(UintTy::U128) | TyInt(IntTy::I128) => {\n                         if !self.session.features.borrow().i128_type {\n@@ -2704,7 +2714,7 @@ impl<'a> Resolver<'a> {\n                 PathResolution::with_unresolved_segments(Def::PrimTy(prim), path.len() - 1)\n             }\n             PathResult::Module(module) => PathResolution::new(module.def().unwrap()),\n-            PathResult::Failed(msg, false) => {\n+            PathResult::Failed(span, msg, false) => {\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 err_path_resolution()\n             }\n@@ -2713,8 +2723,8 @@ impl<'a> Resolver<'a> {\n         };\n \n         if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n-           path[0].name != keywords::CrateRoot.name() &&\n-           path[0].name != keywords::DollarCrate.name() {\n+           path[0].node.name != keywords::CrateRoot.name() &&\n+           path[0].node.name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path(&[*path.last().unwrap()], Some(ns), false, span) {\n                     PathResult::NonModule(path_res) => path_res.base_def(),\n@@ -2732,7 +2742,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_path(&mut self,\n-                    path: &[Ident],\n+                    path: &[SpannedIdent],\n                     opt_ns: Option<Namespace>, // `None` indicates a module path\n                     record_used: bool,\n                     path_span: Span)\n@@ -2741,15 +2751,16 @@ impl<'a> Resolver<'a> {\n         let mut allow_super = true;\n \n         for (i, &ident) in path.iter().enumerate() {\n+            debug!(\"resolve_path ident {} {:?}\", i, ident);\n             let is_last = i == path.len() - 1;\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n \n-            if i == 0 && ns == TypeNS && ident.name == keywords::SelfValue.name() {\n-                let mut ctxt = ident.ctxt.modern();\n+            if i == 0 && ns == TypeNS && ident.node.name == keywords::SelfValue.name() {\n+                let mut ctxt = ident.node.ctxt.modern();\n                 module = Some(self.resolve_self(&mut ctxt, self.current_module));\n                 continue\n-            } else if allow_super && ns == TypeNS && ident.name == keywords::Super.name() {\n-                let mut ctxt = ident.ctxt.modern();\n+            } else if allow_super && ns == TypeNS && ident.node.name == keywords::Super.name() {\n+                let mut ctxt = ident.node.ctxt.modern();\n                 let self_module = match i {\n                     0 => self.resolve_self(&mut ctxt, self.current_module),\n                     _ => module.unwrap(),\n@@ -2759,26 +2770,26 @@ impl<'a> Resolver<'a> {\n                     continue\n                 } else {\n                     let msg = \"There are too many initial `super`s.\".to_string();\n-                    return PathResult::Failed(msg, false);\n+                    return PathResult::Failed(ident.span, msg, false);\n                 }\n             }\n             allow_super = false;\n \n-            if i == 0 && ns == TypeNS && ident.name == keywords::CrateRoot.name() {\n-                module = Some(self.resolve_crate_root(ident.ctxt.modern()));\n+            if i == 0 && ns == TypeNS && ident.node.name == keywords::CrateRoot.name() {\n+                module = Some(self.resolve_crate_root(ident.node.ctxt.modern()));\n                 continue\n-            } else if i == 0 && ns == TypeNS && ident.name == keywords::DollarCrate.name() {\n-                module = Some(self.resolve_crate_root(ident.ctxt));\n+            } else if i == 0 && ns == TypeNS && ident.node.name == keywords::DollarCrate.name() {\n+                module = Some(self.resolve_crate_root(ident.node.ctxt));\n                 continue\n             }\n \n             let binding = if let Some(module) = module {\n-                self.resolve_ident_in_module(module, ident, ns, false, record_used, path_span)\n+                self.resolve_ident_in_module(module, ident.node, ns, false, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n-                self.resolve_lexical_macro_path_segment(ident, ns, record_used, path_span)\n+                self.resolve_lexical_macro_path_segment(ident.node, ns, record_used, path_span)\n                     .map(MacroBinding::binding)\n             } else {\n-                match self.resolve_ident_in_lexical_scope(ident, ns, record_used, path_span) {\n+                match self.resolve_ident_in_lexical_scope(ident.node, ns, record_used, path_span) {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n                     Some(LexicalScopeBinding::Def(def))\n                             if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) => {\n@@ -2803,7 +2814,9 @@ impl<'a> Resolver<'a> {\n                             def, path.len() - i - 1\n                         ));\n                     } else {\n-                        return PathResult::Failed(format!(\"Not a module `{}`\", ident), is_last);\n+                        return PathResult::Failed(ident.span,\n+                                                  format!(\"Not a module `{}`\", ident.node),\n+                                                  is_last);\n                     }\n                 }\n                 Err(Undetermined) => return PathResult::Indeterminate,\n@@ -2818,19 +2831,19 @@ impl<'a> Resolver<'a> {\n                     let msg = if module.and_then(ModuleData::def) == self.graph_root.def() {\n                         let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n                         let mut candidates =\n-                            self.lookup_import_candidates(ident.name, TypeNS, is_mod);\n+                            self.lookup_import_candidates(ident.node.name, TypeNS, is_mod);\n                         candidates.sort_by_key(|c| (c.path.segments.len(), c.path.to_string()));\n                         if let Some(candidate) = candidates.get(0) {\n                             format!(\"Did you mean `{}`?\", candidate.path)\n                         } else {\n-                            format!(\"Maybe a missing `extern crate {};`?\", ident)\n+                            format!(\"Maybe a missing `extern crate {};`?\", ident.node)\n                         }\n                     } else if i == 0 {\n-                        format!(\"Use of undeclared type or module `{}`\", ident)\n+                        format!(\"Use of undeclared type or module `{}`\", ident.node)\n                     } else {\n-                        format!(\"Could not find `{}` in `{}`\", ident, path[i - 1])\n+                        format!(\"Could not find `{}` in `{}`\", ident.node, path[i - 1].node)\n                     };\n-                    return PathResult::Failed(msg, is_last);\n+                    return PathResult::Failed(ident.span, msg, is_last);\n                 }\n             }\n         }\n@@ -2850,8 +2863,7 @@ impl<'a> Resolver<'a> {\n         // An invalid forward use of a type parameter from a previous default.\n         if let ForwardTyParamBanRibKind = self.ribs[ns][rib_index].kind {\n             if record_used {\n-                resolve_error(self, span,\n-                        ResolutionError::ForwardDeclaredTyParam);\n+                resolve_error(self, span, ResolutionError::ForwardDeclaredTyParam);\n             }\n             assert_eq!(def, Def::Err);\n             return Def::Err;\n@@ -3021,7 +3033,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn lookup_typo_candidate<FilterFn>(&mut self,\n-                                       path: &[Ident],\n+                                       path: &[SpannedIdent],\n                                        ns: Namespace,\n                                        filter_fn: FilterFn,\n                                        span: Span)\n@@ -3082,7 +3094,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let name = path[path.len() - 1].name;\n+        let name = path[path.len() - 1].node.name;\n         // Make sure error reporting is deterministic.\n         names.sort_by_key(|name| name.as_str());\n         match find_best_match_for_name(names.iter(), &name.as_str(), None) {\n@@ -3620,27 +3632,31 @@ fn is_struct_like(def: Def) -> bool {\n     }\n }\n \n-fn is_self_type(path: &[Ident], namespace: Namespace) -> bool {\n-    namespace == TypeNS && path.len() == 1 && path[0].name == keywords::SelfType.name()\n+fn is_self_type(path: &[SpannedIdent], namespace: Namespace) -> bool {\n+    namespace == TypeNS && path.len() == 1 && path[0].node.name == keywords::SelfType.name()\n }\n \n-fn is_self_value(path: &[Ident], namespace: Namespace) -> bool {\n-    namespace == ValueNS && path.len() == 1 && path[0].name == keywords::SelfValue.name()\n+fn is_self_value(path: &[SpannedIdent], namespace: Namespace) -> bool {\n+    namespace == ValueNS && path.len() == 1 && path[0].node.name == keywords::SelfValue.name()\n }\n \n-fn names_to_string(idents: &[Ident]) -> String {\n+fn names_to_string(idents: &[SpannedIdent]) -> String {\n     let mut result = String::new();\n-    for (i, ident) in idents.iter().filter(|i| i.name != keywords::CrateRoot.name()).enumerate() {\n+    for (i, ident) in idents.iter()\n+                            .filter(|i| i.node.name != keywords::CrateRoot.name())\n+                            .enumerate() {\n         if i > 0 {\n             result.push_str(\"::\");\n         }\n-        result.push_str(&ident.name.as_str());\n+        result.push_str(&ident.node.name.as_str());\n     }\n     result\n }\n \n fn path_names_to_string(path: &Path) -> String {\n-    names_to_string(&path.segments.iter().map(|seg| seg.identifier).collect::<Vec<_>>())\n+    names_to_string(&path.segments.iter()\n+                        .map(|seg| respan(seg.span, seg.identifier))\n+                        .collect::<Vec<_>>())\n }\n \n /// Get the path for an enum and the variant from an `ImportSuggestion` for an enum variant.\n@@ -3708,7 +3724,10 @@ fn module_to_string(module: Module) -> String {\n     if names.is_empty() {\n         return \"???\".to_string();\n     }\n-    names_to_string(&names.into_iter().rev().collect::<Vec<_>>())\n+    names_to_string(&names.into_iter()\n+                        .rev()\n+                        .map(|n| dummy_spanned(n))\n+                        .collect::<Vec<_>>())\n }\n \n fn err_path_resolution() -> PathResolution {"}, {"sha": "18ec2b3cc1b9a9fd6946bc856baad60e0d65b9b3", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -19,6 +19,7 @@ use rustc::hir::map::{self, DefCollector};\n use rustc::{ty, lint};\n use syntax::ast::{self, Name, Ident};\n use syntax::attr::{self, HasAttrs};\n+use syntax::codemap::respan;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Annotatable, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n@@ -393,7 +394,7 @@ impl<'a> Resolver<'a> {\n             return Err(Determinacy::Determined);\n         }\n \n-        let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n+        let path: Vec<_> = segments.iter().map(|seg| respan(seg.span, seg.identifier)).collect();\n         let invocation = self.invocations[&scope];\n         self.current_module = invocation.module.get();\n \n@@ -418,16 +419,19 @@ impl<'a> Resolver<'a> {\n                     Err(Determinacy::Determined)\n                 },\n             };\n+            let path = path.iter().map(|p| p.node).collect::<Vec<_>>();\n             self.current_module.nearest_item_scope().macro_resolutions.borrow_mut()\n                 .push((path.into_boxed_slice(), span));\n             return def;\n         }\n \n-        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, path[0], false);\n+        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope,\n+                                                          path[0].node,\n+                                                          false);\n         let result = if let Some(MacroBinding::Legacy(binding)) = legacy_resolution {\n             Ok(Def::Macro(binding.def_id, MacroKind::Bang))\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, false, span) {\n+            match self.resolve_lexical_macro_path_segment(path[0].node, MacroNS, false, span) {\n                 Ok(binding) => Ok(binding.binding().def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n                 Err(_) => {\n@@ -438,7 +442,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         self.current_module.nearest_item_scope().legacy_macro_resolutions.borrow_mut()\n-            .push((scope, path[0], span, kind));\n+            .push((scope, path[0].node, span, kind));\n \n         result\n     }\n@@ -576,9 +580,10 @@ impl<'a> Resolver<'a> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n-            match self.resolve_path(path, Some(MacroNS), true, span) {\n+            let path = path.iter().map(|p| respan(span, *p)).collect::<Vec<_>>();\n+            match self.resolve_path(&path, Some(MacroNS), true, span) {\n                 PathResult::NonModule(_) => {},\n-                PathResult::Failed(msg, _) => {\n+                PathResult::Failed(span, msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n                 _ => unreachable!(),\n@@ -652,7 +657,7 @@ impl<'a> Resolver<'a> {\n                 }\n             };\n             let ident = Ident::from_str(name);\n-            self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro, span)\n+            self.lookup_typo_candidate(&vec![respan(span, ident)], MacroNS, is_macro, span)\n         });\n \n         if let Some(suggestion) = suggestion {"}, {"sha": "5e799b14f209c9071d06b043e8cbdfa1d1e4aa0f", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -21,9 +21,9 @@ use rustc::ty;\n use rustc::lint::builtin::PUB_USE_OF_PRIVATE_EXTERN_CRATE;\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::*;\n-use rustc::util::nodemap::FxHashMap;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n-use syntax::ast::{Ident, NodeId};\n+use syntax::ast::{Ident, SpannedIdent, NodeId};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n use syntax::parse::token;\n@@ -57,7 +57,7 @@ pub enum ImportDirectiveSubclass<'a> {\n pub struct ImportDirective<'a> {\n     pub id: NodeId,\n     pub parent: Module<'a>,\n-    pub module_path: Vec<Ident>,\n+    pub module_path: Vec<SpannedIdent>,\n     pub imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n     pub subclass: ImportDirectiveSubclass<'a>,\n     pub span: Span,\n@@ -256,7 +256,7 @@ impl<'a> Resolver<'a> {\n \n     // Add an import directive to the current module.\n     pub fn add_import_directive(&mut self,\n-                                module_path: Vec<Ident>,\n+                                module_path: Vec<SpannedIdent>,\n                                 subclass: ImportDirectiveSubclass<'a>,\n                                 span: Span,\n                                 id: NodeId,\n@@ -478,9 +478,10 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n \n         let mut errors = false;\n+        let mut seen_spans = FxHashSet();\n         for i in 0 .. self.determined_imports.len() {\n             let import = self.determined_imports[i];\n-            if let Some(err) = self.finalize_import(import) {\n+            if let Some((span, err)) = self.finalize_import(import) {\n                 errors = true;\n \n                 if let SingleImport { source, ref result, .. } = import.subclass {\n@@ -496,9 +497,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 // If the error is a single failed import then create a \"fake\" import\n                 // resolution for it so that later resolve stages won't complain.\n                 self.import_dummy_binding(import);\n-                let path = import_path_to_string(&import.module_path, &import.subclass);\n-                let error = ResolutionError::UnresolvedImport(Some((&path, &err)));\n-                resolve_error(self.resolver, import.span, error);\n+                if !seen_spans.contains(&span) {\n+                    let path = import_path_to_string(&import.module_path[..],\n+                                                     &import.subclass,\n+                                                     span);\n+                    let error = ResolutionError::UnresolvedImport(Some((span, &path, &err)));\n+                    resolve_error(self.resolver, span, error);\n+                    seen_spans.insert(span);\n+                }\n             }\n         }\n \n@@ -516,7 +522,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               names_to_string(&directive.module_path),\n+               names_to_string(&directive.module_path[..]),\n                module_to_string(self.current_module));\n \n         self.current_module = directive.parent;\n@@ -528,7 +534,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             // For better failure detection, pretend that the import will not define any names\n             // while resolving its module path.\n             directive.vis.set(ty::Visibility::Invisible);\n-            let result = self.resolve_path(&directive.module_path, None, false, directive.span);\n+            let result = self.resolve_path(&directive.module_path[..], None, false, directive.span);\n             directive.vis.set(vis);\n \n             match result {\n@@ -593,23 +599,25 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     }\n \n     // If appropriate, returns an error to report.\n-    fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> Option<String> {\n+    fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> Option<(Span, String)> {\n         self.current_module = directive.parent;\n \n         let ImportDirective { ref module_path, span, .. } = *directive;\n         let module_result = self.resolve_path(&module_path, None, true, span);\n         let module = match module_result {\n             PathResult::Module(module) => module,\n-            PathResult::Failed(msg, _) => {\n+            PathResult::Failed(span, msg, _) => {\n                 let (mut self_path, mut self_result) = (module_path.clone(), None);\n-                if !self_path.is_empty() && !token::Ident(self_path[0]).is_path_segment_keyword() {\n-                    self_path[0].name = keywords::SelfValue.name();\n+                if !self_path.is_empty() &&\n+                    !token::Ident(self_path[0].node).is_path_segment_keyword()\n+                {\n+                    self_path[0].node.name = keywords::SelfValue.name();\n                     self_result = Some(self.resolve_path(&self_path, None, false, span));\n                 }\n                 return if let Some(PathResult::Module(..)) = self_result {\n-                    Some(format!(\"Did you mean `{}`?\", names_to_string(&self_path)))\n+                    Some((span, format!(\"Did you mean `{}`?\", names_to_string(&self_path[..]))))\n                 } else {\n-                    Some(msg)\n+                    Some((span, msg))\n                 };\n             },\n             _ => return None,\n@@ -619,7 +627,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             SingleImport { source, ref result, type_ns_only, .. } => (source, result, type_ns_only),\n             GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n                 // Importing a module into itself is not allowed.\n-                return Some(\"Cannot glob-import a module into itself.\".to_string());\n+                return Some((directive.span,\n+                             \"Cannot glob-import a module into itself.\".to_string()));\n             }\n             GlobImport { is_prelude, ref max_vis } => {\n                 if !is_prelude &&\n@@ -708,7 +717,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 } else {\n                     format!(\"no `{}` in `{}`{}\", ident, module_str, lev_suggestion)\n                 };\n-                Some(msg)\n+                Some((span, msg))\n             } else {\n                 // `resolve_ident_in_module` reported a privacy error.\n                 self.import_dummy_binding(directive);\n@@ -888,16 +897,24 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     }\n }\n \n-fn import_path_to_string(names: &[Ident], subclass: &ImportDirectiveSubclass) -> String {\n-    let global = !names.is_empty() && names[0].name == keywords::CrateRoot.name();\n-    let names = if global { &names[1..] } else { names };\n-    if names.is_empty() {\n-        import_directive_subclass_to_string(subclass)\n+fn import_path_to_string(names: &[SpannedIdent],\n+                         subclass: &ImportDirectiveSubclass,\n+                         span: Span) -> String {\n+    let pos = names.iter()\n+        .position(|p| span == p.span && p.node.name != keywords::CrateRoot.name());\n+    let global = !names.is_empty() && names[0].node.name == keywords::CrateRoot.name();\n+    if let Some(pos) = pos {\n+        let names = if global { &names[1..pos + 1] } else { &names[..pos + 1] };\n+        names_to_string(names)\n     } else {\n-        (format!(\"{}::{}\",\n-                 names_to_string(names),\n-                 import_directive_subclass_to_string(subclass)))\n-            .to_string()\n+        let names = if global { &names[1..] } else { names };\n+        if names.is_empty() {\n+            import_directive_subclass_to_string(subclass)\n+        } else {\n+            (format!(\"{}::{}\",\n+                     names_to_string(names),\n+                     import_directive_subclass_to_string(subclass)))\n+        }\n     }\n }\n "}, {"sha": "0b5c2db171d65d2d912d52591dd704cb38c6dd34", "filename": "src/libstd/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -45,6 +45,7 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=socket\");\n         println!(\"cargo:rustc-link-lib=posix4\");\n         println!(\"cargo:rustc-link-lib=pthread\");\n+        println!(\"cargo:rustc-link-lib=resolv\");\n     } else if target.contains(\"apple-darwin\") {\n         println!(\"cargo:rustc-link-lib=System\");\n "}, {"sha": "3844690860b5a7aa9e6e15658ab2352f308231eb", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -44,7 +44,7 @@ impl TaggedHashUintPtr {\n     #[inline]\n     unsafe fn new(ptr: *mut HashUint) -> Self {\n         debug_assert!(ptr as usize & 1 == 0 || ptr as usize == EMPTY as usize);\n-        TaggedHashUintPtr(Unique::new(ptr))\n+        TaggedHashUintPtr(Unique::new_unchecked(ptr))\n     }\n \n     #[inline]\n@@ -56,7 +56,7 @@ impl TaggedHashUintPtr {\n             } else {\n                 usize_ptr &= !1;\n             }\n-            self.0 = Unique::new(usize_ptr as *mut HashUint)\n+            self.0 = Unique::new_unchecked(usize_ptr as *mut HashUint)\n         }\n     }\n \n@@ -877,7 +877,7 @@ impl<K, V> RawTable<K, V> {\n                 elems_left: elems_left,\n                 marker: marker::PhantomData,\n             },\n-            table: unsafe { Shared::new(self) },\n+            table: Shared::from(self),\n             marker: marker::PhantomData,\n         }\n     }"}, {"sha": "2ae62f8c3e0ac5412b86faebe604df41a3c1c7a2", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -413,7 +413,7 @@ impl Builder {\n ///   *by value* from the thread where it is spawned to the new thread. Its\n ///   return value will need to be passed from the new thread to the thread\n ///   where it is `join`ed.\n-///   As a reminder, the [`Send`] marker trait, expresses that it is safe to be\n+///   As a reminder, the [`Send`] marker trait expresses that it is safe to be\n ///   passed from thread to thread. [`Sync`] expresses that it is safe to have a\n ///   reference be passed from thread to thread.\n ///"}, {"sha": "2cd84d202ffc989b62ffab9c5750eccbe8d5304a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -2243,9 +2243,9 @@ impl<'a> Parser<'a> {\n                         attrs);\n                 }\n                 if self.is_catch_expr() {\n+                    let lo = self.span;\n                     assert!(self.eat_keyword(keywords::Do));\n                     assert!(self.eat_keyword(keywords::Catch));\n-                    let lo = self.prev_span;\n                     return self.parse_catch_expr(lo, attrs);\n                 }\n                 if self.eat_keyword(keywords::Return) {"}, {"sha": "ac96279d614670de0cd3435fafa310e7ae934d70", "filename": "src/test/compile-fail/dollar-crate-is-keyword-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -13,7 +13,7 @@ mod a {}\n macro_rules! m {\n     () => {\n         use a::$crate; //~ ERROR unresolved import `a::$crate`\n-        use a::$crate::b; //~ ERROR unresolved import `a::$crate::b`\n+        use a::$crate::b; //~ ERROR unresolved import `a::$crate`\n         type A = a::$crate; //~ ERROR cannot find type `$crate` in module `a`\n     }\n }"}, {"sha": "c4bd9ff1e2abeae6b1b475e00f705ad19fa110b9", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use baz::zed::bar; //~ ERROR unresolved import `baz::zed::bar` [E0432]\n+use baz::zed::bar; //~ ERROR unresolved import `baz::zed` [E0432]\n                    //~^ Could not find `zed` in `baz`\n \n mod baz {}"}, {"sha": "f8a68264339b93da003a9a2510f897b3cf1c6a0b", "filename": "src/test/compile-fail/issue-1697.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -10,7 +10,7 @@\n \n // Testing that we don't fail abnormally after hitting the errors\n \n-use unresolved::*; //~ ERROR unresolved import `unresolved::*` [E0432]\n+use unresolved::*; //~ ERROR unresolved import `unresolved` [E0432]\n                    //~^ Maybe a missing `extern crate unresolved;`?\n \n fn main() {}"}, {"sha": "0b1afd75ca935703bb96999e56fc88359d2aef99", "filename": "src/test/compile-fail/issue-30560.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fissue-30560.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fissue-30560.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30560.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -10,10 +10,10 @@\n \n type Alias = ();\n use Alias::*;\n-//~^ ERROR unresolved import `Alias::*` [E0432]\n+//~^ ERROR unresolved import `Alias` [E0432]\n //~| Not a module `Alias`\n use std::io::Result::*;\n-//~^ ERROR unresolved import `std::io::Result::*` [E0432]\n+//~^ ERROR unresolved import `std::io::Result` [E0432]\n //~| Not a module `Result`\n \n trait T {}"}, {"sha": "b7dbaf20ecae1fccd5b98236d1b8eac978305fba", "filename": "src/test/compile-fail/issue-33464.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fissue-33464.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fissue-33464.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-33464.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -11,13 +11,10 @@\n // Make sure that the spans of import errors are correct.\n \n use abc::one_el;\n-//~^ ERROR 13:5: 13:16\n+//~^ ERROR 13:5: 13:8\n use abc::{a, bbb, cccccc};\n-//~^ ERROR 15:11: 15:12\n-//~^^ ERROR 15:14: 15:17\n-//~^^^ ERROR 15:19: 15:25\n+//~^ ERROR 15:5: 15:8\n use a_very_long_name::{el, el2};\n-//~^ ERROR 19:24: 19:26\n-//~^^ ERROR 19:28: 19:31\n+//~^ ERROR 17:5: 17:21\n \n fn main() {}"}, {"sha": "bc78d20745a54b96064a6e45cf0a04f2a201257f", "filename": "src/test/compile-fail/issue-33504.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fissue-33504.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fissue-33504.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-33504.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Shadowing a unit-like enum in a closure\n+\n+struct Test;\n+\n+fn main() {\n+    || {\n+        let Test = 1; //~ ERROR let bindings cannot shadow unit structs\n+    };\n+}"}, {"sha": "96ba1c8399786351ed976afc3c2d5ddcc0d2e847", "filename": "src/test/compile-fail/issue-39211.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fissue-39211.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fissue-39211.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39211.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+trait VecN {\n+    const DIM: usize;\n+}\n+trait Mat {\n+    type Row: VecN;\n+}\n+\n+fn m<M: Mat>() {\n+    let a = [3; M::Row::DIM]; //~ ERROR associated type `Row` not found for `M`\n+}\n+fn main() {\n+}"}, {"sha": "099513484480bacb86d884462b41290c28126999", "filename": "src/test/compile-fail/resolve_self_super_hint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fresolve_self_super_hint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fresolve_self_super_hint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve_self_super_hint.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -13,19 +13,19 @@\n mod a {\n     extern crate alloc;\n     use alloc::HashMap;\n-    //~^ ERROR unresolved import `alloc::HashMap` [E0432]\n+    //~^ ERROR unresolved import `alloc` [E0432]\n     //~| Did you mean `self::alloc`?\n     mod b {\n         use alloc::HashMap;\n-        //~^ ERROR unresolved import `alloc::HashMap` [E0432]\n+        //~^ ERROR unresolved import `alloc` [E0432]\n         //~| Did you mean `a::alloc`?\n         mod c {\n             use alloc::HashMap;\n-            //~^ ERROR unresolved import `alloc::HashMap` [E0432]\n+            //~^ ERROR unresolved import `alloc` [E0432]\n             //~| Did you mean `a::alloc`?\n             mod d {\n                 use alloc::HashMap;\n-                //~^ ERROR unresolved import `alloc::HashMap` [E0432]\n+                //~^ ERROR unresolved import `alloc` [E0432]\n                 //~| Did you mean `a::alloc`?\n             }\n         }"}, {"sha": "4db673e2006f5fb0315e2f7aa034a18b67ec5eb6", "filename": "src/test/compile-fail/super-at-top-level.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::f; //~ ERROR unresolved import `super::f` [E0432]\n+use super::f; //~ ERROR unresolved import `super` [E0432]\n               //~^ There are too many initial `super`s.\n \n fn main() {"}, {"sha": "a3eeb6de96bda1f9867a1d6d9c13510571f76bdb", "filename": "src/test/compile-fail/unresolved-import.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-tidy-linelength\n \n-use foo::bar; //~ ERROR unresolved import `foo::bar` [E0432]\n+use foo::bar; //~ ERROR unresolved import `foo` [E0432]\n               //~^ Maybe a missing `extern crate foo;`?\n \n use bar::Baz as x; //~ ERROR unresolved import `bar::Baz` [E0432]\n@@ -41,7 +41,7 @@ mod m {\n         MyVariant\n     }\n \n-    use MyEnum::*; //~ ERROR unresolved import `MyEnum::*` [E0432]\n+    use MyEnum::*; //~ ERROR unresolved import `MyEnum` [E0432]\n                    //~^ Did you mean `self::MyEnum`?\n }\n \n@@ -50,7 +50,7 @@ mod items {\n         Variant\n     }\n \n-    use Enum::*; //~ ERROR unresolved import `Enum::*` [E0432]\n+    use Enum::*; //~ ERROR unresolved import `Enum` [E0432]\n                  //~^ Did you mean `self::Enum`?\n \n     fn item() {}"}, {"sha": "3848b6814d9a52411d12a57e4aea0e5301660be9", "filename": "src/test/compile-fail/use-from-trait-xc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -22,13 +22,13 @@ use use_from_trait_xc::Trait::CONST;\n //~^ ERROR `CONST` is not directly importable\n \n use use_from_trait_xc::Foo::new; //~ ERROR struct `Foo` is private\n-//~^ ERROR unresolved import `use_from_trait_xc::Foo::new`\n+//~^ ERROR unresolved import `use_from_trait_xc::Foo`\n \n use use_from_trait_xc::Foo::C; //~ ERROR struct `Foo` is private\n-//~^ ERROR unresolved import `use_from_trait_xc::Foo::C`\n+//~^ ERROR unresolved import `use_from_trait_xc::Foo`\n \n use use_from_trait_xc::Bar::new as bnew;\n-//~^ ERROR unresolved import `use_from_trait_xc::Bar::new`\n+//~^ ERROR unresolved import `use_from_trait_xc::Bar`\n \n use use_from_trait_xc::Baz::new as baznew;\n //~^ ERROR unresolved import `use_from_trait_xc::Baz::new`"}, {"sha": "29db949acd04a5379283f28f2d6e7647c9937313", "filename": "src/test/compile-fail/use-from-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -17,11 +17,11 @@ use Trait::C;\n //~^ ERROR `C` is not directly importable\n \n use Foo::new;\n-//~^ ERROR unresolved import `Foo::new` [E0432]\n+//~^ ERROR unresolved import `Foo` [E0432]\n //~| Not a module `Foo`\n \n use Foo::C2;\n-//~^ ERROR unresolved import `Foo::C2` [E0432]\n+//~^ ERROR unresolved import `Foo` [E0432]\n //~| Not a module `Foo`\n \n pub trait Trait {"}, {"sha": "275e5ff1da6ff50193604ca68abbea342ab1b57d", "filename": "src/test/compile-fail/use-mod-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fuse-mod-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fcompile-fail%2Fuse-mod-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-mod-4.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use foo::self; //~ ERROR unresolved import `foo::self`\n+use foo::self; //~ ERROR unresolved import `foo`\n //~^ ERROR `self` imports are only allowed within a { } list\n \n use std::mem::self;"}, {"sha": "a77175975f9412ed3d7057f8da719e89e970d7a9", "filename": "src/test/run-fail/issue-29798.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Frun-fail%2Fissue-29798.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Frun-fail%2Fissue-29798.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-29798.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:index out of bounds: the len is 5 but the index is 5\n+\n+#![feature(const_fn)]\n+const fn test(x: usize) -> i32 {\n+    [42;5][x]\n+}\n+\n+fn main () {\n+    let _ = test(5);\n+}"}, {"sha": "aa13d6fad47c9f188bf4e855438559467caa99ec", "filename": "src/test/run-pass/issue-23433.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Frun-pass%2Fissue-23433.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Frun-pass%2Fissue-23433.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23433.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -16,7 +16,7 @@ use std::ptr::Unique;\n \n fn main() {\n     let mut a = [0u8; 5];\n-    let b: Option<Unique<[u8]>> = unsafe { Some(Unique::new(&mut a)) };\n+    let b: Option<Unique<[u8]>> = Some(Unique::from(&mut a));\n     match b {\n         Some(_) => println!(\"Got `Some`\"),\n         None => panic!(\"Unexpected `None`\"),"}, {"sha": "b586abc29e243a2f3a8fa5382aba03b13c1af75c", "filename": "src/test/run-pass/issue-29516.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Frun-pass%2Fissue-29516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Frun-pass%2Fissue-29516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29516.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+\n+trait NotSame {}\n+impl NotSame for .. {}\n+impl<A> !NotSame for (A, A) {}\n+\n+trait OneOfEach {}\n+\n+impl<A> OneOfEach for (A,) {}\n+\n+impl<A, B> OneOfEach for (A, B)\n+where\n+    (B,): OneOfEach,\n+    (A, B): NotSame,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "eda4ebb7132a8fe6098d087d9709de7ba8403be8", "filename": "src/test/run-pass/issue-34780.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Frun-pass%2Fissue-34780.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Frun-pass%2Fissue-34780.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-34780.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+use std::marker::PhantomData;\n+\n+trait Tr<'a> {\n+    const C: PhantomData<&'a u8> = PhantomData::<&'a u8>;\n+}\n+\n+fn main() {}"}, {"sha": "9f94be271eeb6ea505dfda80dc4dbfaefd1d548b", "filename": "src/test/run-pass/issue-39467.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Frun-pass%2Fissue-39467.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Frun-pass%2Fissue-39467.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-39467.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! expr { () => { () } }\n+\n+enum A {}\n+\n+impl A {\n+    const A: () = expr!();\n+}\n+\n+fn main() {}"}, {"sha": "f90696e3cdf16b1d120e0306de6a625cabc3c5be", "filename": "src/test/run-pass/issue-39720.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Frun-pass%2Fissue-39720.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Frun-pass%2Fissue-39720.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-39720.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(C)]\n+#[repr(simd)]\n+#[derive(Copy, Clone, Debug)]\n+pub struct char3(pub i8, pub i8, pub i8);\n+\n+#[repr(C)]\n+#[repr(simd)]\n+#[derive(Copy, Clone, Debug)]\n+pub struct short3(pub i16, pub i16, pub i16);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_cast<T, U>(x: T) -> U;\n+}\n+\n+fn main() {\n+    let cast: short3 = unsafe { simd_cast(char3(10, -3, -9)) };\n+\n+    println!(\"{:?}\", cast);\n+}"}, {"sha": "a2935b73596c3e50d7e131fd15169403222d113c", "filename": "src/test/rustdoc/issue-19181.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Frustdoc%2Fissue-19181.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Frustdoc%2Fissue-19181.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-19181.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:--test\n+\n+// rustdoc should not panic when target crate has compilation errors\n+\n+fn main() { 0 }"}, {"sha": "5c3bb66d83a87728a273db0d2b72d91435b2eed7", "filename": "src/test/ui/macros/macro_path_as_generic_bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -2,7 +2,7 @@ error[E0433]: failed to resolve. Use of undeclared type or module `m`\n   --> $DIR/macro_path_as_generic_bound.rs:17:6\n    |\n 17 | foo!(m::m2::A);\n-   |      ^^^^^^^^ Use of undeclared type or module `m`\n+   |      ^ Use of undeclared type or module `m`\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "5052c59a39dcfcfa2989e48f0b11fff0279bad88", "filename": "src/test/ui/print_type_sizes/nullable.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -42,7 +42,7 @@ impl Default for EmbeddedDiscr {\n }\n \n #[derive(Default)]\n-pub struct IndirectNonZero<T: Zeroable> {\n+pub struct IndirectNonZero<T: Zeroable + One> {\n     pre: u8,\n     nested: NestedNonZero<T>,\n     post: u16,\n@@ -54,14 +54,20 @@ pub struct NestedNonZero<T: Zeroable> {\n     post: u16,\n }\n \n-impl<T: Zeroable+Default> Default for NestedNonZero<T> {\n+impl<T: Zeroable+One> Default for NestedNonZero<T> {\n     fn default() -> Self {\n-        unsafe {\n-            NestedNonZero { pre: 0, val: NonZero::new(Default::default()), post: 0 }\n-        }\n+        NestedNonZero { pre: 0, val: NonZero::new(T::one()).unwrap(), post: 0 }\n     }\n }\n \n+pub trait One {\n+    fn one() -> Self;\n+}\n+\n+impl One for u32 {\n+    fn one() -> Self { 1 }\n+}\n+\n pub fn main() {\n     let _x: MyOption<NonZero<u32>> = Default::default();\n     let _y: EmbeddedDiscr = Default::default();"}, {"sha": "3d45a94d531c178c80f460052106fbb99aa0e41f", "filename": "src/test/ui/span/non-existing-module-import.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fui%2Fspan%2Fnon-existing-module-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fui%2Fspan%2Fnon-existing-module-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fnon-existing-module-import.rs?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::bar::{foo1, foo2};\n+\n+fn main() {}"}, {"sha": "93339576f49043a3eff3ed62252e1f87fb65b566", "filename": "src/test/ui/span/non-existing-module-import.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fui%2Fspan%2Fnon-existing-module-import.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/599be0d18f4c6ddf36366d2a5a2ca6dc65886896/src%2Ftest%2Fui%2Fspan%2Fnon-existing-module-import.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fnon-existing-module-import.stderr?ref=599be0d18f4c6ddf36366d2a5a2ca6dc65886896", "patch": "@@ -0,0 +1,8 @@\n+error[E0432]: unresolved import `std::bar`\n+  --> $DIR/non-existing-module-import.rs:11:10\n+   |\n+11 | use std::bar::{foo1, foo2};\n+   |          ^^^ Could not find `bar` in `std`\n+\n+error: aborting due to previous error\n+"}]}