{"sha": "83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "node_id": "C_kwDOAAsO6NoAKDgzZDNiNzZhYzI2ZjU5MmI0YWE3ZjA5YzEyYzg4NmU4M2E5ZmM0MDQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-12T06:25:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-12T06:25:47Z"}, "message": "Rollup merge of #106097 - mejrs:mir_build2, r=oli-obk\n\nMigrate mir_build diagnostics 2 of 3\n\nThe first three commits are fairly boring, however I've made some changes to the output of the match checking diagnostics.", "tree": {"sha": "35f01b840673dfd3b52f45c9ca179ce2520c23a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35f01b840673dfd3b52f45c9ca179ce2520c23a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjv6frCRBK7hj4Ov3rIwAAaBYIADCi6q+Y1PiaK1tmN0oxgOSr\n0CZQPqKc9T/6AmSaPEELftWc4LN5V3JO3rufEjGuxFrKo/yI8gds/X45sWIJayJY\nQzWivfb3jGWYr7wA3yH/wZSalusfkQbCt1itoJmYC87Iw8XTeuGs+gGMcIBShlQR\nC9mXHaSbYMBOBGtfNSEDX3iUz/lYBpqILBbVAFc76DK7Spm+HvtVC6VEJagoqV6l\nnZDceRHqdbatGDCZl8X9xk+MbopuCsgOmyvg0WYUnQ2Byc30BBsTHO6yaoA35YDH\nO0iyXGyQCMZzEG7j/K9SAj/P+MR+68A0c/iHZ0VzdZ2pMYhJAJ6GloqXUKHVvuI=\n=MhQr\n-----END PGP SIGNATURE-----\n", "payload": "tree 35f01b840673dfd3b52f45c9ca179ce2520c23a4\nparent 2e17a5d4060c86b1e2dc707a605b06ebfc0ed20a\nparent 372ac9c1a29820f4393ba59eb49f81959bca2926\nauthor Michael Goulet <michael@errs.io> 1673504747 -0800\ncommitter GitHub <noreply@github.com> 1673504747 -0800\n\nRollup merge of #106097 - mejrs:mir_build2, r=oli-obk\n\nMigrate mir_build diagnostics 2 of 3\n\nThe first three commits are fairly boring, however I've made some changes to the output of the match checking diagnostics.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "html_url": "https://github.com/rust-lang/rust/commit/83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e17a5d4060c86b1e2dc707a605b06ebfc0ed20a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e17a5d4060c86b1e2dc707a605b06ebfc0ed20a", "html_url": "https://github.com/rust-lang/rust/commit/2e17a5d4060c86b1e2dc707a605b06ebfc0ed20a"}, {"sha": "372ac9c1a29820f4393ba59eb49f81959bca2926", "url": "https://api.github.com/repos/rust-lang/rust/commits/372ac9c1a29820f4393ba59eb49f81959bca2926", "html_url": "https://github.com/rust-lang/rust/commit/372ac9c1a29820f4393ba59eb49f81959bca2926"}], "stats": {"total": 1052, "additions": 566, "deletions": 486}, "files": [{"sha": "a082c0b61fa7ed293b873b9e054f7f9e1481957e", "filename": "compiler/rustc_error_messages/locales/en-US/mir_build.ftl", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -303,3 +303,64 @@ mir_build_multiple_mut_borrows = cannot borrow value as mutable more than once a\n     .mutable_borrow = another mutable borrow, by `{$name_mut}`, occurs here\n     .immutable_borrow = also borrowed as immutable, by `{$name_immut}`, here\n     .moved = also moved into `{$name_moved}` here\n+\n+mir_build_union_pattern = cannot use unions in constant patterns\n+\n+mir_build_type_not_structural =\n+     to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+mir_build_unsized_pattern = cannot use unsized non-slice type `{$non_sm_ty}` in constant patterns\n+\n+mir_build_invalid_pattern = `{$non_sm_ty}` cannot be used in patterns\n+\n+mir_build_float_pattern = floating-point types cannot be used in patterns\n+\n+mir_build_pointer_pattern = function pointers and unsized pointers in patterns behave unpredictably and should not be relied upon. See https://github.com/rust-lang/rust/issues/70861 for details.\n+\n+mir_build_indirect_structural_match =\n+    to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+mir_build_nontrivial_structural_match =\n+    to use a constant of type `{$non_sm_ty}` in a pattern, the constant's initializer must be trivial or `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+mir_build_overlapping_range_endpoints = multiple patterns overlap on their endpoints\n+    .range = ... with this range\n+    .note = you likely meant to write mutually exclusive ranges\n+\n+mir_build_non_exhaustive_omitted_pattern = some variants are not matched explicitly\n+    .help = ensure that all variants are matched explicitly by adding the suggested match arms\n+    .note = the matched value is of type `{$scrut_ty}` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+mir_build_uncovered = {$count ->\n+        [1] pattern `{$witness_1}`\n+        [2] patterns `{$witness_1}` and `{$witness_2}`\n+        [3] patterns `{$witness_1}`, `{$witness_2}` and `{$witness_3}`\n+        *[other] patterns `{$witness_1}`, `{$witness_2}`, `{$witness_3}` and {$remainder} more\n+    } not covered\n+\n+mir_build_pattern_not_covered = refutable pattern in {$origin}\n+    .pattern_ty = the matched value is of type `{$pattern_ty}`\n+\n+mir_build_inform_irrefutable = `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+\n+mir_build_more_information = for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+\n+mir_build_res_defined_here = {$res} defined here\n+\n+mir_build_adt_defined_here = `{$ty}` defined here\n+\n+mir_build_variant_defined_here = not covered\n+\n+mir_build_interpreted_as_const = introduce a variable instead\n+\n+mir_build_confused = missing patterns are not covered because `{$variable}` is interpreted as {$article} {$res} pattern, not a new variable\n+\n+mir_build_suggest_if_let = you might want to use `if let` to ignore the {$count ->\n+        [one] variant that isn't\n+        *[other] variants that aren't\n+    } matched\n+\n+mir_build_suggest_let_else = you might want to use `let else` to handle the {$count ->\n+        [one] variant that isn't\n+        *[other] variants that aren't\n+    } matched"}, {"sha": "5f320708c8416944466a25137159b95386baee11", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -9,6 +9,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/thir.html\n \n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::RangeEnd;\n@@ -575,6 +576,12 @@ impl<'tcx> Pat<'tcx> {\n     }\n }\n \n+impl<'tcx> IntoDiagnosticArg for Pat<'tcx> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        format!(\"{}\", self).into_diagnostic_arg()\n+    }\n+}\n+\n #[derive(Clone, Debug, HashStable)]\n pub struct Ascription<'tcx> {\n     pub annotation: CanonicalUserTypeAnnotation<'tcx>,"}, {"sha": "06523b0a1de84cb658fc3e410bb4d61837eeeec9", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 225, "deletions": 1, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,9 +1,13 @@\n+use crate::thir::pattern::deconstruct_pat::DeconstructedPat;\n use crate::thir::pattern::MatchCheckCtxt;\n use rustc_errors::Handler;\n use rustc_errors::{\n-    error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, MultiSpan,\n+    error_code, AddToDiagnostic, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+    IntoDiagnostic, MultiSpan, SubdiagnosticMessage,\n };\n+use rustc_hir::def::Res;\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n+use rustc_middle::thir::Pat;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::{symbol::Ident, Span};\n \n@@ -624,3 +628,223 @@ pub enum MultipleMutBorrowOccurence {\n         name_moved: Ident,\n     },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_union_pattern)]\n+pub struct UnionPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_type_not_structural)]\n+pub struct TypeNotStructural<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_invalid_pattern)]\n+pub struct InvalidPattern<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_unsized_pattern)]\n+pub struct UnsizedPattern<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_float_pattern)]\n+pub struct FloatPattern;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_pointer_pattern)]\n+pub struct PointerPattern;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_indirect_structural_match)]\n+pub struct IndirectStructuralMatch<'tcx> {\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_nontrivial_structural_match)]\n+pub struct NontrivialStructuralMatch<'tcx> {\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_overlapping_range_endpoints)]\n+#[note]\n+pub struct OverlappingRangeEndpoints<'tcx> {\n+    #[label(range)]\n+    pub range: Span,\n+    #[subdiagnostic]\n+    pub overlap: Vec<Overlap<'tcx>>,\n+}\n+\n+pub struct Overlap<'tcx> {\n+    pub span: Span,\n+    pub range: Pat<'tcx>,\n+}\n+\n+impl<'tcx> AddToDiagnostic for Overlap<'tcx> {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        let Overlap { span, range } = self;\n+\n+        // FIXME(mejrs) unfortunately `#[derive(LintDiagnostic)]`\n+        // does not support `#[subdiagnostic(eager)]`...\n+        let message = format!(\"this range overlaps on `{range}`...\");\n+        diag.span_label(span, message);\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_non_exhaustive_omitted_pattern)]\n+#[help]\n+#[note]\n+pub(crate) struct NonExhaustiveOmittedPattern<'tcx> {\n+    pub scrut_ty: Ty<'tcx>,\n+    #[subdiagnostic]\n+    pub uncovered: Uncovered<'tcx>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(mir_build_uncovered)]\n+pub(crate) struct Uncovered<'tcx> {\n+    #[primary_span]\n+    span: Span,\n+    count: usize,\n+    witness_1: Pat<'tcx>,\n+    witness_2: Pat<'tcx>,\n+    witness_3: Pat<'tcx>,\n+    remainder: usize,\n+}\n+\n+impl<'tcx> Uncovered<'tcx> {\n+    pub fn new<'p>(\n+        span: Span,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n+    ) -> Self {\n+        let witness_1 = witnesses.get(0).unwrap().to_pat(cx);\n+        Self {\n+            span,\n+            count: witnesses.len(),\n+            // Substitute dummy values if witnesses is smaller than 3. These will never be read.\n+            witness_2: witnesses.get(1).map(|w| w.to_pat(cx)).unwrap_or_else(|| witness_1.clone()),\n+            witness_3: witnesses.get(2).map(|w| w.to_pat(cx)).unwrap_or_else(|| witness_1.clone()),\n+            witness_1,\n+            remainder: witnesses.len().saturating_sub(3),\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_pattern_not_covered, code = \"E0005\")]\n+pub(crate) struct PatternNotCovered<'s, 'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub origin: &'s str,\n+    #[subdiagnostic]\n+    pub uncovered: Uncovered<'tcx>,\n+    #[subdiagnostic]\n+    pub inform: Option<Inform>,\n+    #[subdiagnostic]\n+    pub interpreted_as_const: Option<InterpretedAsConst>,\n+    #[subdiagnostic]\n+    pub adt_defined_here: Option<AdtDefinedHere<'tcx>>,\n+    #[note(pattern_ty)]\n+    pub _p: (),\n+    pub pattern_ty: Ty<'tcx>,\n+    #[subdiagnostic]\n+    pub let_suggestion: Option<SuggestLet>,\n+    #[subdiagnostic]\n+    pub res_defined_here: Option<ResDefinedHere>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(mir_build_inform_irrefutable)]\n+#[note(mir_build_more_information)]\n+pub struct Inform;\n+\n+pub struct AdtDefinedHere<'tcx> {\n+    pub adt_def_span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub variants: Vec<Variant>,\n+}\n+\n+pub struct Variant {\n+    pub span: Span,\n+}\n+\n+impl<'tcx> AddToDiagnostic for AdtDefinedHere<'tcx> {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        diag.set_arg(\"ty\", self.ty);\n+        let mut spans = MultiSpan::from(self.adt_def_span);\n+\n+        for Variant { span } in self.variants {\n+            spans.push_span_label(span, rustc_errors::fluent::mir_build_variant_defined_here);\n+        }\n+\n+        diag.span_note(spans, rustc_errors::fluent::mir_build_adt_defined_here);\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(mir_build_res_defined_here)]\n+pub struct ResDefinedHere {\n+    #[primary_span]\n+    pub def_span: Span,\n+    pub res: Res,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    mir_build_interpreted_as_const,\n+    code = \"{variable}_var\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+#[label(mir_build_confused)]\n+pub struct InterpretedAsConst {\n+    #[primary_span]\n+    pub span: Span,\n+    pub article: &'static str,\n+    pub variable: String,\n+    pub res: Res,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestLet {\n+    #[multipart_suggestion(mir_build_suggest_if_let, applicability = \"has-placeholders\")]\n+    If {\n+        #[suggestion_part(code = \"if \")]\n+        start_span: Span,\n+        #[suggestion_part(code = \" {{ todo!() }}\")]\n+        semi_span: Span,\n+        count: usize,\n+    },\n+    #[suggestion(\n+        mir_build_suggest_let_else,\n+        code = \" else {{ todo!() }}\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    Else {\n+        #[primary_span]\n+        end_span: Span,\n+        count: usize,\n+    },\n+}"}, {"sha": "fb7ae6f1d242412e8e72197107f2214969a54e50", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -10,6 +10,7 @@\n #![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(once_cell)]\n+#![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "e13c0662ef85f17cb45edb3bd2f7dd26820e7256", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 59, "deletions": 132, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -9,8 +9,7 @@ use crate::errors::*;\n use rustc_arena::TypedArena;\n use rustc_ast::Mutability;\n use rustc_errors::{\n-    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n-    MultiSpan,\n+    struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::*;\n@@ -378,8 +377,8 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n \n         let pattern = self.lower_pattern(&mut cx, pat, &mut false);\n         let pattern_ty = pattern.ty();\n-        let arms = vec![MatchArm { pat: pattern, hir_id: pat.hir_id, has_guard: false }];\n-        let report = compute_match_usefulness(&cx, &arms, pat.hir_id, pattern_ty);\n+        let arm = MatchArm { pat: pattern, hir_id: pat.hir_id, has_guard: false };\n+        let report = compute_match_usefulness(&cx, &[arm], pat.hir_id, pattern_ty);\n \n         // Note: we ignore whether the pattern is unreachable (i.e. whether the type is empty). We\n         // only care about exhaustiveness here.\n@@ -390,145 +389,73 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             return;\n         }\n \n-        let joined_patterns = joined_uncovered_patterns(&cx, &witnesses);\n-\n-        let mut bindings = vec![];\n-\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            pat.span,\n-            E0005,\n-            \"refutable pattern in {}: {} not covered\",\n-            origin,\n-            joined_patterns\n-        );\n-        let suggest_if_let = match &pat.kind {\n-            hir::PatKind::Path(hir::QPath::Resolved(None, path))\n-                if path.segments.len() == 1 && path.segments[0].args.is_none() =>\n+        let (inform, interpreted_as_const, res_defined_here,let_suggestion) =\n+            if let hir::PatKind::Path(hir::QPath::Resolved(\n+                None,\n+                hir::Path {\n+                    segments: &[hir::PathSegment { args: None, res, ident, .. }],\n+                    ..\n+                },\n+            )) = &pat.kind\n             {\n-                const_not_var(&mut err, cx.tcx, pat, path);\n-                false\n-            }\n-            _ => {\n-                pat.walk(&mut |pat: &hir::Pat<'_>| {\n-                    match pat.kind {\n-                        hir::PatKind::Binding(_, _, ident, _) => {\n-                            bindings.push(ident);\n+                (\n+                    None,\n+                    Some(InterpretedAsConst {\n+                        span: pat.span,\n+                        article: res.article(),\n+                        variable: ident.to_string().to_lowercase(),\n+                        res,\n+                    }),\n+                    try {\n+                        ResDefinedHere {\n+                            def_span: cx.tcx.hir().res_span(res)?,\n+                            res,\n                         }\n-                        _ => {}\n+                    },\n+                    None,\n+                )\n+            } else if let Some(span) = sp && self.tcx.sess.source_map().is_span_accessible(span) {\n+                let mut bindings = vec![];\n+                pat.walk_always(&mut |pat: &hir::Pat<'_>| {\n+                    if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n+                        bindings.push(ident);\n                     }\n-                    true\n                 });\n-\n-                err.span_label(pat.span, pattern_not_covered_label(&witnesses, &joined_patterns));\n-                true\n-            }\n-        };\n-\n-        if let (Some(span), true) = (sp, suggest_if_let) {\n-            err.note(\n-                \"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n-                 an `enum` with only one variant\",\n-            );\n-            if self.tcx.sess.source_map().is_span_accessible(span) {\n                 let semi_span = span.shrink_to_hi().with_lo(span.hi() - BytePos(1));\n                 let start_span = span.shrink_to_lo();\n                 let end_span = semi_span.shrink_to_lo();\n-                err.multipart_suggestion(\n-                    &format!(\n-                        \"you might want to use `if let` to ignore the variant{} that {} matched\",\n-                        pluralize!(witnesses.len()),\n-                        match witnesses.len() {\n-                            1 => \"isn't\",\n-                            _ => \"aren't\",\n-                        },\n-                    ),\n-                    vec![\n-                        match &bindings[..] {\n-                            [] => (start_span, \"if \".to_string()),\n-                            [binding] => (start_span, format!(\"let {} = if \", binding)),\n-                            bindings => (\n-                                start_span,\n-                                format!(\n-                                    \"let ({}) = if \",\n-                                    bindings\n-                                        .iter()\n-                                        .map(|ident| ident.to_string())\n-                                        .collect::<Vec<_>>()\n-                                        .join(\", \")\n-                                ),\n-                            ),\n-                        },\n-                        match &bindings[..] {\n-                            [] => (semi_span, \" { todo!() }\".to_string()),\n-                            [binding] => {\n-                                (end_span, format!(\" {{ {} }} else {{ todo!() }}\", binding))\n-                            }\n-                            bindings => (\n-                                end_span,\n-                                format!(\n-                                    \" {{ ({}) }} else {{ todo!() }}\",\n-                                    bindings\n-                                        .iter()\n-                                        .map(|ident| ident.to_string())\n-                                        .collect::<Vec<_>>()\n-                                        .join(\", \")\n-                                ),\n-                            ),\n-                        },\n-                    ],\n-                    Applicability::HasPlaceholders,\n-                );\n-                if !bindings.is_empty() {\n-                    err.span_suggestion_verbose(\n-                        semi_span.shrink_to_lo(),\n-                        &format!(\n-                            \"alternatively, you might want to use \\\n-                             let else to handle the variant{} that {} matched\",\n-                            pluralize!(witnesses.len()),\n-                            match witnesses.len() {\n-                                1 => \"isn't\",\n-                                _ => \"aren't\",\n-                            },\n-                        ),\n-                        \" else { todo!() }\",\n-                        Applicability::HasPlaceholders,\n-                    );\n-                }\n-            }\n-            err.note(\n-                \"for more information, visit \\\n-                 https://doc.rust-lang.org/book/ch18-02-refutability.html\",\n-            );\n-        }\n+                let count = witnesses.len();\n \n-        adt_defined_here(&cx, &mut err, pattern_ty, &witnesses);\n-        err.note(&format!(\"the matched value is of type `{}`\", pattern_ty));\n-        err.emit();\n-    }\n-}\n+                let let_suggestion = if bindings.is_empty() {SuggestLet::If{start_span, semi_span, count}} else{ SuggestLet::Else{end_span, count }};\n+                (sp.map(|_|Inform), None, None, Some(let_suggestion))\n+            } else{\n+                (sp.map(|_|Inform), None, None,  None)\n+            };\n \n-/// A path pattern was interpreted as a constant, not a new variable.\n-/// This caused an irrefutable match failure in e.g. `let`.\n-fn const_not_var(err: &mut Diagnostic, tcx: TyCtxt<'_>, pat: &Pat<'_>, path: &hir::Path<'_>) {\n-    let descr = path.res.descr();\n-    err.span_label(\n-        pat.span,\n-        format!(\"interpreted as {} {} pattern, not a new variable\", path.res.article(), descr,),\n-    );\n+        let adt_defined_here = try {\n+            let ty = pattern_ty.peel_refs();\n+            let ty::Adt(def, _) = ty.kind() else { None? };\n+            let adt_def_span = cx.tcx.hir().get_if_local(def.did())?.ident()?.span;\n+            let mut variants = vec![];\n \n-    err.span_suggestion(\n-        pat.span,\n-        \"introduce a variable instead\",\n-        format!(\"{}_var\", path.segments[0].ident).to_lowercase(),\n-        // Cannot use `MachineApplicable` as it's not really *always* correct\n-        // because there may be such an identifier in scope or the user maybe\n-        // really wanted to match against the constant. This is quite unlikely however.\n-        Applicability::MaybeIncorrect,\n-    );\n+            for span in maybe_point_at_variant(&cx, *def, witnesses.iter().take(5)) {\n+                variants.push(Variant { span });\n+            }\n+            AdtDefinedHere { adt_def_span, ty, variants }\n+        };\n \n-    if let Some(span) = tcx.hir().res_span(path.res) {\n-        err.span_label(span, format!(\"{} defined here\", descr));\n+        self.tcx.sess.emit_err(PatternNotCovered {\n+            span: pat.span,\n+            origin,\n+            uncovered: Uncovered::new(pat.span, &cx, witnesses),\n+            inform,\n+            interpreted_as_const,\n+            _p: (),\n+            pattern_ty,\n+            let_suggestion,\n+            res_defined_here,\n+            adt_defined_here,\n+        });\n     }\n }\n "}, {"sha": "7f3519945c3fed4ea3ba3ea29da636dd456c5e02", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 51, "deletions": 137, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,11 +1,9 @@\n-use rustc_errors::DelayDm;\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::mir::{self, Field};\n use rustc_middle::thir::{FieldPat, Pat, PatKind};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_span::Span;\n use rustc_trait_selection::traits::predicate_for_trait_def;\n@@ -15,6 +13,10 @@ use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligation};\n use std::cell::Cell;\n \n use super::PatCtxt;\n+use crate::errors::{\n+    FloatPattern, IndirectStructuralMatch, InvalidPattern, NontrivialStructuralMatch,\n+    PointerPattern, TypeNotStructural, UnionPattern, UnsizedPattern,\n+};\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// Converts an evaluated constant to a pattern (if possible).\n@@ -105,47 +107,6 @@ impl<'tcx> ConstToPat<'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn adt_derive_msg(&self, adt_def: AdtDef<'tcx>) -> String {\n-        let path = self.tcx().def_path_str(adt_def.did());\n-        format!(\n-            \"to use a constant of type `{}` in a pattern, \\\n-            `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-            path, path,\n-        )\n-    }\n-\n-    fn search_for_structural_match_violation(&self, ty: Ty<'tcx>) -> Option<String> {\n-        traits::search_for_structural_match_violation(self.span, self.tcx(), ty).map(|non_sm_ty| {\n-            with_no_trimmed_paths!(match non_sm_ty.kind() {\n-                ty::Adt(adt, _) => self.adt_derive_msg(*adt),\n-                ty::Dynamic(..) => {\n-                    \"trait objects cannot be used in patterns\".to_string()\n-                }\n-                ty::Alias(ty::Opaque, ..) => {\n-                    \"opaque types cannot be used in patterns\".to_string()\n-                }\n-                ty::Closure(..) => {\n-                    \"closures cannot be used in patterns\".to_string()\n-                }\n-                ty::Generator(..) | ty::GeneratorWitness(..) => {\n-                    \"generators cannot be used in patterns\".to_string()\n-                }\n-                ty::Float(..) => {\n-                    \"floating-point numbers cannot be used in patterns\".to_string()\n-                }\n-                ty::FnPtr(..) => {\n-                    \"function pointers cannot be used in patterns\".to_string()\n-                }\n-                ty::RawPtr(..) => {\n-                    \"raw pointers cannot be used in patterns\".to_string()\n-                }\n-                _ => {\n-                    bug!(\"use of a value of `{non_sm_ty}` inside a pattern\")\n-                }\n-            })\n-        })\n-    }\n-\n     fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {\n         ty.is_structural_eq_shallow(self.infcx.tcx)\n     }\n@@ -176,7 +137,8 @@ impl<'tcx> ConstToPat<'tcx> {\n             // If we were able to successfully convert the const to some pat,\n             // double-check that all types in the const implement `Structural`.\n \n-            let structural = self.search_for_structural_match_violation(cv.ty());\n+            let structural =\n+                traits::search_for_structural_match_violation(self.span, self.tcx(), cv.ty());\n             debug!(\n                 \"search_for_structural_match_violation cv.ty: {:?} returned: {:?}\",\n                 cv.ty(),\n@@ -194,17 +156,18 @@ impl<'tcx> ConstToPat<'tcx> {\n                 return inlined_const_as_pat;\n             }\n \n-            if let Some(msg) = structural {\n+            if let Some(non_sm_ty) = structural {\n                 if !self.type_may_have_partial_eq_impl(cv.ty()) {\n-                    // span_fatal avoids ICE from resolution of non-existent method (rare case).\n-                    self.tcx().sess.span_fatal(self.span, &msg);\n+                    // fatal avoids ICE from resolution of non-existent method (rare case).\n+                    self.tcx()\n+                        .sess\n+                        .emit_fatal(TypeNotStructural { span: self.span, non_sm_ty: non_sm_ty });\n                 } else if mir_structural_match_violation && !self.saw_const_match_lint.get() {\n-                    self.tcx().struct_span_lint_hir(\n+                    self.tcx().emit_spanned_lint(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         self.id,\n                         self.span,\n-                        msg,\n-                        |lint| lint,\n+                        IndirectStructuralMatch { non_sm_ty },\n                     );\n                 } else {\n                     debug!(\n@@ -278,42 +241,34 @@ impl<'tcx> ConstToPat<'tcx> {\n         let kind = match cv.ty().kind() {\n             ty::Float(_) => {\n                 if self.include_lint_checks {\n-                    tcx.struct_span_lint_hir(\n+                    tcx.emit_spanned_lint(\n                         lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                         id,\n                         span,\n-                        \"floating-point types cannot be used in patterns\",\n-                        |lint| lint,\n+                        FloatPattern,\n                     );\n                 }\n                 PatKind::Constant { value: cv }\n             }\n             ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 self.saw_const_match_error.set(true);\n-                let msg = \"cannot use unions in constant patterns\";\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(span, msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(span, msg);\n-                }\n+                let err = UnionPattern { span };\n+                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n             ty::Adt(..)\n                 if !self.type_may_have_partial_eq_impl(cv.ty())\n                     // FIXME(#73448): Find a way to bring const qualification into parity with\n                     // `search_for_structural_match_violation` and then remove this condition.\n-                    && self.search_for_structural_match_violation(cv.ty()).is_some() =>\n+\n+                    // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n+                    // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n+                    && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, cv.ty()) =>\n             {\n-                // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n-                // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-                let msg = self.search_for_structural_match_violation(cv.ty()).unwrap();\n                 self.saw_const_match_error.set(true);\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(self.span, &msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(self.span, &msg);\n-                }\n+                let err = TypeNotStructural { span, non_sm_ty };\n+                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n             // If the type is not structurally comparable, just emit the constant directly,\n@@ -331,19 +286,11 @@ impl<'tcx> ConstToPat<'tcx> {\n                     && !self.saw_const_match_lint.get()\n                 {\n                     self.saw_const_match_lint.set(true);\n-                    tcx.struct_span_lint_hir(\n+                    tcx.emit_spanned_lint(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         id,\n                         span,\n-                        DelayDm(|| {\n-                            format!(\n-                                \"to use a constant of type `{}` in a pattern, \\\n-                                 `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                                cv.ty(),\n-                                cv.ty(),\n-                            )\n-                        }),\n-                        |lint| lint,\n+                        IndirectStructuralMatch { non_sm_ty: cv.ty() },\n                     );\n                 }\n                 // Since we are behind a reference, we can just bubble the error up so we get a\n@@ -357,18 +304,9 @@ impl<'tcx> ConstToPat<'tcx> {\n                     adt_def,\n                     cv.ty()\n                 );\n-                let path = tcx.def_path_str(adt_def.did());\n-                let msg = format!(\n-                    \"to use a constant of type `{}` in a pattern, \\\n-                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                    path, path,\n-                );\n                 self.saw_const_match_error.set(true);\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(span, &msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(span, &msg);\n-                }\n+                let err = TypeNotStructural { span, non_sm_ty: cv.ty() };\n+                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n@@ -401,12 +339,8 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // These are not allowed and will error elsewhere anyway.\n                 ty::Dynamic(..) => {\n                     self.saw_const_match_error.set(true);\n-                    let msg = format!(\"`{}` cannot be used in patterns\", cv.ty());\n-                    if self.include_lint_checks {\n-                        tcx.sess.span_err(span, &msg);\n-                    } else {\n-                        tcx.sess.delay_span_bug(span, &msg);\n-                    }\n+                    let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n+                    tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                     PatKind::Wild\n                 }\n                 // `&str` is represented as `ConstValue::Slice`, let's keep using this\n@@ -471,32 +405,26 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // this pattern to a `PartialEq::eq` comparison and `PartialEq::eq` takes a\n                 // reference. This makes the rest of the matching logic simpler as it doesn't have\n                 // to figure out how to get a reference again.\n-                ty::Adt(adt_def, _) if !self.type_marked_structural(*pointee_ty) => {\n+                ty::Adt(_, _) if !self.type_marked_structural(*pointee_ty) => {\n                     if self.behind_reference.get() {\n                         if self.include_lint_checks\n                             && !self.saw_const_match_error.get()\n                             && !self.saw_const_match_lint.get()\n                         {\n-                            self.saw_const_match_lint.set(true);\n-                            let msg = self.adt_derive_msg(adt_def);\n-                            self.tcx().struct_span_lint_hir(\n+                           self.saw_const_match_lint.set(true);\n+                           tcx.emit_spanned_lint(\n                                 lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                                 self.id,\n-                                self.span,\n-                                msg,\n-                                |lint| lint,\n+                                span,\n+                                IndirectStructuralMatch { non_sm_ty: *pointee_ty },\n                             );\n                         }\n                         PatKind::Constant { value: cv }\n                     } else {\n                         if !self.saw_const_match_error.get() {\n                             self.saw_const_match_error.set(true);\n-                            let msg = self.adt_derive_msg(adt_def);\n-                            if self.include_lint_checks {\n-                                tcx.sess.span_err(span, &msg);\n-                            } else {\n-                                tcx.sess.delay_span_bug(span, &msg);\n-                            }\n+                            let err = TypeNotStructural { span, non_sm_ty: *pointee_ty };\n+                            tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                         }\n                         PatKind::Wild\n                     }\n@@ -508,12 +436,10 @@ impl<'tcx> ConstToPat<'tcx> {\n                     if !pointee_ty.is_sized(tcx, param_env) {\n                         // `tcx.deref_mir_constant()` below will ICE with an unsized type\n                         // (except slices, which are handled in a separate arm above).\n-                        let msg = format!(\"cannot use unsized non-slice type `{}` in constant patterns\", pointee_ty);\n-                        if self.include_lint_checks {\n-                            tcx.sess.span_err(span, &msg);\n-                        } else {\n-                            tcx.sess.delay_span_bug(span, &msg);\n-                        }\n+\n+                        let err = UnsizedPattern { span, non_sm_ty: *pointee_ty };\n+                        tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+\n                         PatKind::Wild\n                     } else {\n                         let old = self.behind_reference.replace(true);\n@@ -545,27 +471,19 @@ impl<'tcx> ConstToPat<'tcx> {\n                     && !self.saw_const_match_lint.get()\n                 {\n                     self.saw_const_match_lint.set(true);\n-                    let msg = \"function pointers and unsized pointers in patterns behave \\\n-                        unpredictably and should not be relied upon. \\\n-                        See https://github.com/rust-lang/rust/issues/70861 for details.\";\n-                    tcx.struct_span_lint_hir(\n+                    tcx.emit_spanned_lint(\n                         lint::builtin::POINTER_STRUCTURAL_MATCH,\n                         id,\n                         span,\n-                        msg,\n-                        |lint| lint,\n+                        PointerPattern\n                     );\n                 }\n                 PatKind::Constant { value: cv }\n             }\n             _ => {\n                 self.saw_const_match_error.set(true);\n-                let msg = format!(\"`{}` cannot be used in patterns\", cv.ty());\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(span, &msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(span, &msg);\n-                }\n+                let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n+                    tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n         };\n@@ -576,21 +494,17 @@ impl<'tcx> ConstToPat<'tcx> {\n             && mir_structural_match_violation\n             // FIXME(#73448): Find a way to bring const qualification into parity with\n             // `search_for_structural_match_violation` and then remove this condition.\n-            && self.search_for_structural_match_violation(cv.ty()).is_some()\n-        {\n-            self.saw_const_match_lint.set(true);\n+\n             // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n             // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-            let msg = self.search_for_structural_match_violation(cv.ty()).unwrap().replace(\n-                \"in a pattern,\",\n-                \"in a pattern, the constant's initializer must be trivial or\",\n-            );\n-            tcx.struct_span_lint_hir(\n+            && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, cv.ty())\n+        {\n+            self.saw_const_match_lint.set(true);\n+            tcx.emit_spanned_lint(\n                 lint::builtin::NONTRIVIAL_STRUCTURAL_MATCH,\n                 id,\n                 span,\n-                msg,\n-                |lint| lint,\n+                NontrivialStructuralMatch {non_sm_ty}\n             );\n         }\n "}, {"sha": "17b3c475f83c78a3d4711e65092859da5d5d147b", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -67,6 +67,7 @@ use self::SliceKind::*;\n \n use super::compare_const_vals;\n use super::usefulness::{MatchCheckCtxt, PatCtxt};\n+use crate::errors::{Overlap, OverlappingRangeEndpoints};\n \n /// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n fn expand_or_pat<'p, 'tcx>(pat: &'p Pat<'tcx>) -> Vec<&'p Pat<'tcx>> {\n@@ -96,7 +97,7 @@ fn expand_or_pat<'p, 'tcx>(pat: &'p Pat<'tcx>) -> Vec<&'p Pat<'tcx>> {\n /// `IntRange` is never used to encode an empty range or a \"range\" that wraps\n /// around the (offset) space: i.e., `range.lo <= range.hi`.\n #[derive(Clone, PartialEq, Eq)]\n-pub(super) struct IntRange {\n+pub(crate) struct IntRange {\n     range: RangeInclusive<u128>,\n     /// Keeps the bias used for encoding the range. It depends on the type of the range and\n     /// possibly the pointer size of the current architecture. The algorithm ensures we never\n@@ -284,32 +285,21 @@ impl IntRange {\n             return;\n         }\n \n-        let overlaps: Vec<_> = pats\n+        let overlap: Vec<_> = pats\n             .filter_map(|pat| Some((pat.ctor().as_int_range()?, pat.span())))\n             .filter(|(range, _)| self.suspicious_intersection(range))\n-            .map(|(range, span)| (self.intersection(&range).unwrap(), span))\n+            .map(|(range, span)| Overlap {\n+                range: self.intersection(&range).unwrap().to_pat(pcx.cx.tcx, pcx.ty),\n+                span,\n+            })\n             .collect();\n \n-        if !overlaps.is_empty() {\n-            pcx.cx.tcx.struct_span_lint_hir(\n+        if !overlap.is_empty() {\n+            pcx.cx.tcx.emit_spanned_lint(\n                 lint::builtin::OVERLAPPING_RANGE_ENDPOINTS,\n                 hir_id,\n                 pcx.span,\n-                \"multiple patterns overlap on their endpoints\",\n-                |lint| {\n-                    for (int_range, span) in overlaps {\n-                        lint.span_label(\n-                            span,\n-                            &format!(\n-                                \"this range overlaps on `{}`...\",\n-                                int_range.to_pat(pcx.cx.tcx, pcx.ty)\n-                            ),\n-                        );\n-                    }\n-                    lint.span_label(pcx.span, \"... with this range\");\n-                    lint.note(\"you likely meant to write mutually exclusive ranges\");\n-                    lint\n-                },\n+                OverlappingRangeEndpoints { overlap, range: pcx.span },\n             );\n         }\n     }"}, {"sha": "3a6ef87c9c662d393768c1c8f82ea6c95925d1a4", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -2,7 +2,7 @@\n \n mod check_match;\n mod const_to_pat;\n-mod deconstruct_pat;\n+pub(crate) mod deconstruct_pat;\n mod usefulness;\n \n pub(crate) use self::check_match::check_match;"}, {"sha": "be66d0d476513992b4009fef5d85ba354ba4b82a", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -291,9 +291,8 @@\n \n use self::ArmType::*;\n use self::Usefulness::*;\n-\n-use super::check_match::{joined_uncovered_patterns, pattern_not_covered_label};\n use super::deconstruct_pat::{Constructor, DeconstructedPat, Fields, SplitWildcard};\n+use crate::errors::{NonExhaustiveOmittedPattern, Uncovered};\n \n use rustc_data_structures::captures::Captures;\n \n@@ -743,31 +742,6 @@ impl<'p, 'tcx> Witness<'p, 'tcx> {\n     }\n }\n \n-/// Report that a match of a `non_exhaustive` enum marked with `non_exhaustive_omitted_patterns`\n-/// is not exhaustive enough.\n-///\n-/// NB: The partner lint for structs lives in `compiler/rustc_hir_analysis/src/check/pat.rs`.\n-fn lint_non_exhaustive_omitted_patterns<'p, 'tcx>(\n-    cx: &MatchCheckCtxt<'p, 'tcx>,\n-    scrut_ty: Ty<'tcx>,\n-    sp: Span,\n-    hir_id: HirId,\n-    witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n-) {\n-    cx.tcx.struct_span_lint_hir(NON_EXHAUSTIVE_OMITTED_PATTERNS, hir_id, sp, \"some variants are not matched explicitly\", |lint| {\n-        let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n-        lint.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n-        lint.help(\n-            \"ensure that all variants are matched explicitly by adding the suggested match arms\",\n-        );\n-        lint.note(&format!(\n-            \"the matched value is of type `{}` and the `non_exhaustive_omitted_patterns` attribute was found\",\n-            scrut_ty,\n-        ));\n-        lint\n-    });\n-}\n-\n /// Algorithm from <http://moscova.inria.fr/~maranget/papers/warn/index.html>.\n /// The algorithm from the paper has been modified to correctly handle empty\n /// types. The changes are:\n@@ -913,7 +887,19 @@ fn is_useful<'p, 'tcx>(\n                         .collect::<Vec<_>>()\n                 };\n \n-                lint_non_exhaustive_omitted_patterns(pcx.cx, pcx.ty, pcx.span, hir_id, patterns);\n+                // Report that a match of a `non_exhaustive` enum marked with `non_exhaustive_omitted_patterns`\n+                // is not exhaustive enough.\n+                //\n+                // NB: The partner lint for structs lives in `compiler/rustc_hir_analysis/src/check/pat.rs`.\n+                cx.tcx.emit_spanned_lint(\n+                    NON_EXHAUSTIVE_OMITTED_PATTERNS,\n+                    hir_id,\n+                    pcx.span,\n+                    NonExhaustiveOmittedPattern {\n+                        scrut_ty: pcx.ty,\n+                        uncovered: Uncovered::new(pcx.span, pcx.cx, patterns),\n+                    },\n+                );\n             }\n \n             ret.extend(usefulness);"}, {"sha": "1caf1617e213cb198ad9cbf82e80804013bbd664", "filename": "tests/ui/consts/const-match-check.eval1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:25:15\n    |\n LL |     A = { let 0 = 0; 0 },"}, {"sha": "f038ba1c8ed859314c4aa4140e4018cce0bba1c7", "filename": "tests/ui/consts/const-match-check.eval2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:31:24\n    |\n LL |     let x: [i32; { let 0 = 0; 0 }] = [];"}, {"sha": "b1921f8a41e48db0560471f059b83b6114ab9ec5", "filename": "tests/ui/consts/const-match-check.matchck.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:4:22\n    |\n LL | const X: i32 = { let 0 = 0; 0 };\n@@ -12,7 +12,7 @@ help: you might want to use `if let` to ignore the variants that aren't matched\n LL | const X: i32 = { if let 0 = 0 { todo!() } 0 };\n    |                  ++           ~~~~~~~~~~~\n \n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:8:23\n    |\n LL | static Y: i32 = { let 0 = 0; 0 };\n@@ -26,7 +26,7 @@ help: you might want to use `if let` to ignore the variants that aren't matched\n LL | static Y: i32 = { if let 0 = 0 { todo!() } 0 };\n    |                   ++           ~~~~~~~~~~~\n \n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:13:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n@@ -40,7 +40,7 @@ help: you might want to use `if let` to ignore the variants that aren't matched\n LL |     const X: i32 = { if let 0 = 0 { todo!() } 0 };\n    |                      ++           ~~~~~~~~~~~\n \n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:19:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };"}, {"sha": "61bdf57ffdb9445890321d9ff29c25f2f114bc59", "filename": "tests/ui/consts/const-pattern-irrefutable.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -9,8 +9,20 @@ use foo::d;\n const a: u8 = 2;\n \n fn main() {\n-    let a = 4; //~ ERROR refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX\n-    let c = 4; //~ ERROR refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX\n-    let d = 4; //~ ERROR refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX\n+    let a = 4;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+    //~| missing patterns are not covered because `a` is interpreted as a constant pattern, not a new variable\n+    //~| HELP introduce a variable instead\n+    let c = 4;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+    //~| missing patterns are not covered because `c` is interpreted as a constant pattern, not a new variable\n+    //~| HELP introduce a variable instead\n+    let d = 4;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+    //~| missing patterns are not covered because `d` is interpreted as a constant pattern, not a new variable\n+    //~| HELP introduce a variable instead\n     fn f() {} // Check that the `NOTE`s still work with an item here (cf. issue #35115).\n }"}, {"sha": "c156ea1610c4fca77bd67d1364f8c57981bc4306", "filename": "tests/ui/consts/const-pattern-irrefutable.stderr", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-pattern-irrefutable.rs:12:9\n    |\n LL | const a: u8 = 2;\n@@ -7,35 +7,38 @@ LL | const a: u8 = 2;\n LL |     let a = 4;\n    |         ^\n    |         |\n-   |         interpreted as a constant pattern, not a new variable\n+   |         patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+   |         missing patterns are not covered because `a` is interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `a_var`\n    |\n    = note: the matched value is of type `u8`\n \n-error[E0005]: refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n-  --> $DIR/const-pattern-irrefutable.rs:13:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/const-pattern-irrefutable.rs:17:9\n    |\n LL |     pub const b: u8 = 2;\n    |     --------------- constant defined here\n ...\n LL |     let c = 4;\n    |         ^\n    |         |\n-   |         interpreted as a constant pattern, not a new variable\n+   |         patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+   |         missing patterns are not covered because `c` is interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `c_var`\n    |\n    = note: the matched value is of type `u8`\n \n-error[E0005]: refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n-  --> $DIR/const-pattern-irrefutable.rs:14:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/const-pattern-irrefutable.rs:22:9\n    |\n LL |     pub const d: u8 = 2;\n    |     --------------- constant defined here\n ...\n LL |     let d = 4;\n    |         ^\n    |         |\n-   |         interpreted as a constant pattern, not a new variable\n+   |         patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+   |         missing patterns are not covered because `d` is interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `d_var`\n    |\n    = note: the matched value is of type `u8`"}, {"sha": "d6119028f5b59dff801ad06b757fdf1d670944f8", "filename": "tests/ui/consts/const_let_refutable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst_let_refutable.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in function argument: `&[]`, `&[_]` and `&[_, _, _, ..]` not covered\n+error[E0005]: refutable pattern in function argument\n   --> $DIR/const_let_refutable.rs:3:16\n    |\n LL | const fn slice(&[a, b]: &[i32]) -> i32 {"}, {"sha": "fd93346101d846778efb629f929afc4d99c25012", "filename": "tests/ui/empty/empty-never-array.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fempty%2Fempty-never-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fempty%2Fempty-never-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty%2Fempty-never-array.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -8,7 +8,8 @@ enum Helper<T, U> {\n \n fn transmute<T, U>(t: T) -> U {\n     let Helper::U(u) = Helper::T(t, []);\n-    //~^ ERROR refutable pattern in local binding: `Helper::T(_, _)` not covered\n+    //~^ ERROR refutable pattern in local binding\n+    //~| `Helper::T(_, _)` not covered\n     u\n }\n "}, {"sha": "a488e484b2bf8f49825d47d269396ce8bc797b93", "filename": "tests/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty%2Fempty-never-array.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `Helper::T(_, _)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/empty-never-array.rs:10:9\n    |\n LL |     let Helper::U(u) = Helper::T(t, []);\n@@ -7,18 +7,14 @@ LL |     let Helper::U(u) = Helper::T(t, []);\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Helper<T, U>` defined here\n-  --> $DIR/empty-never-array.rs:4:5\n+  --> $DIR/empty-never-array.rs:3:6\n    |\n LL | enum Helper<T, U> {\n-   |      ------\n+   |      ^^^^^^\n LL |     T(T, [!; 0]),\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `Helper<T, U>`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let u = if let Helper::U(u) = Helper::T(t, []) { u } else { todo!() };\n-   |     ++++++++++                                     ++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Helper::U(u) = Helper::T(t, []) else { todo!() };\n    |                                         ++++++++++++++++"}, {"sha": "4692b66413dff8f24a3bb4b86654ef41e789a0b0", "filename": "tests/ui/error-codes/E0005.stderr", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Ferror-codes%2FE0005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Ferror-codes%2FE0005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0005.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,22 +1,13 @@\n-error[E0005]: refutable pattern in local binding: `None` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/E0005.rs:3:9\n    |\n LL |     let Some(y) = x;\n    |         ^^^^^^^ pattern `None` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n-note: `Option<i32>` defined here\n-  --> $SRC_DIR/core/src/option.rs:LL:COL\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-   = note: not covered\n    = note: the matched value is of type `Option<i32>`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let y = if let Some(y) = x { y } else { todo!() };\n-   |     ++++++++++                 ++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Some(y) = x else { todo!() };\n    |                     ++++++++++++++++"}, {"sha": "293028f5f68b12cd5f827b01de66b333404dd714", "filename": "tests/ui/error-codes/E0297.stderr", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Ferror-codes%2FE0297.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Ferror-codes%2FE0297.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0297.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,14 +1,9 @@\n-error[E0005]: refutable pattern in `for` loop binding: `None` not covered\n+error[E0005]: refutable pattern in `for` loop binding\n   --> $DIR/E0297.rs:4:9\n    |\n LL |     for Some(x) in xs {}\n    |         ^^^^^^^ pattern `None` not covered\n    |\n-note: `Option<i32>` defined here\n-  --> $SRC_DIR/core/src/option.rs:LL:COL\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-   = note: not covered\n    = note: the matched value is of type `Option<i32>`\n \n error: aborting due to previous error"}, {"sha": "49e7ab6082c820b69d988e837fc929f349dd3117", "filename": "tests/ui/feature-gates/feature-gate-exhaustive-patterns.stderr", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,22 +1,13 @@\n-error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/feature-gate-exhaustive-patterns.rs:8:9\n    |\n LL |     let Ok(_x) = foo();\n    |         ^^^^^^ pattern `Err(_)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n-note: `Result<u32, !>` defined here\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-   = note: not covered\n    = note: the matched value is of type `Result<u32, !>`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let _x = if let Ok(_x) = foo() { _x } else { todo!() };\n-   |     +++++++++++                    +++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Ok(_x) = foo() else { todo!() };\n    |                        ++++++++++++++++"}, {"sha": "49a82a6769dce5f6fe2c7524223dc0d90605089a", "filename": "tests/ui/for/for-loop-refutable-pattern-error-message.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in `for` loop binding: `&i32::MIN..=0_i32` and `&2_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in `for` loop binding\n   --> $DIR/for-loop-refutable-pattern-error-message.rs:2:9\n    |\n LL |     for &1 in [1].iter() {}"}, {"sha": "23b266bef1d91d373d4519178c27330f2a559602", "filename": "tests/ui/issues/issue-15381.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fissues%2Fissue-15381.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fissues%2Fissue-15381.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-15381.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -2,7 +2,8 @@ fn main() {\n     let values: Vec<u8> = vec![1,2,3,4,5,6,7,8];\n \n     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n-        //~^ ERROR refutable pattern in `for` loop binding: `&[]`, `&[_]`, `&[_, _]` and 1 more not\n+        //~^ ERROR refutable pattern in `for` loop binding\n+        //~| patterns `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n         println!(\"y={}\", y);\n     }\n }"}, {"sha": "085958411ccb963ce490835fcaf5cc08e0077887", "filename": "tests/ui/issues/issue-15381.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fissues%2Fissue-15381.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fissues%2Fissue-15381.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-15381.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in `for` loop binding: `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n+error[E0005]: refutable pattern in `for` loop binding\n   --> $DIR/issue-15381.rs:4:9\n    |\n LL |     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {"}, {"sha": "40c7c1d1067ffad535a6dc11dc2895325357f6e7", "filename": "tests/ui/never_type/exhaustive_patterns.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fnever_type%2Fexhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fnever_type%2Fexhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_type%2Fexhaustive_patterns.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `Either::B(_)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/exhaustive_patterns.rs:20:9\n    |\n LL |     let Either::A(()) = foo();\n@@ -7,13 +7,13 @@ LL |     let Either::A(()) = foo();\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Either<(), !>` defined here\n-  --> $DIR/exhaustive_patterns.rs:12:5\n+  --> $DIR/exhaustive_patterns.rs:10:6\n    |\n LL | enum Either<A, B> {\n-   |      ------\n+   |      ^^^^^^\n LL |     A(A),\n LL |     B(inner::Wrapper<B>),\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `Either<(), !>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "4adcf4feee90d6dfbe705a71497b30f27d5090ae", "filename": "tests/ui/or-patterns/issue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `3_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/issue-69875-should-have-been-expanded-earlier-non-exhaustive.rs:2:10\n    |\n LL |     let (0 | (1 | 2)) = 0;"}, {"sha": "82414f0418bb21e0dc8795f8e70fa570d024a2ce", "filename": "tests/ui/pattern/usefulness/issue-31561.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -6,5 +6,6 @@ enum Thing {\n \n fn main() {\n     let Thing::Foo(y) = Thing::Foo(1);\n-    //~^ ERROR refutable pattern in local binding: `Thing::Bar` and `Thing::Baz` not covered\n+    //~^ ERROR refutable pattern in local binding\n+    //~| `Thing::Bar` and `Thing::Baz` not covered\n }"}, {"sha": "5367de5e513c739a42a2f2ea98f30c658565be39", "filename": "tests/ui/pattern/usefulness/issue-31561.stderr", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `Thing::Bar` and `Thing::Baz` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/issue-31561.rs:8:9\n    |\n LL |     let Thing::Foo(y) = Thing::Foo(1);\n@@ -7,21 +7,17 @@ LL |     let Thing::Foo(y) = Thing::Foo(1);\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Thing` defined here\n-  --> $DIR/issue-31561.rs:3:5\n+  --> $DIR/issue-31561.rs:1:6\n    |\n LL | enum Thing {\n-   |      -----\n+   |      ^^^^^\n LL |     Foo(u8),\n LL |     Bar,\n-   |     ^^^ not covered\n+   |     --- not covered\n LL |     Baz\n-   |     ^^^ not covered\n+   |     --- not covered\n    = note: the matched value is of type `Thing`\n-help: you might want to use `if let` to ignore the variants that aren't matched\n-   |\n-LL |     let y = if let Thing::Foo(y) = Thing::Foo(1) { y } else { todo!() };\n-   |     ++++++++++                                   ++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variants that aren't matched\n+help: you might want to use `let else` to handle the variants that aren't matched\n    |\n LL |     let Thing::Foo(y) = Thing::Foo(1) else { todo!() };\n    |                                       ++++++++++++++++"}, {"sha": "5145f769075d9b86403e3cf1f340e9888e156466", "filename": "tests/ui/pattern/usefulness/non-exhaustive-defined-here.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -15,9 +15,6 @@ enum E {\n     //~^ NOTE `E` defined here\n     //~| NOTE `E` defined here\n     //~| NOTE `E` defined here\n-    //~| NOTE `E` defined here\n-    //~| NOTE `E` defined here\n-    //~| NOTE `E` defined here\n     //~| NOTE  not covered\n     //~| NOTE  not covered\n     //~| NOTE  not covered\n@@ -41,37 +38,41 @@ fn by_val(e: E) {\n         E::A => {}\n     }\n \n-    let E::A = e; //~ ERROR refutable pattern in local binding: `E::B` and `E::C` not covered\n-    //~^ NOTE patterns `E::B` and `E::C` not covered\n+    let E::A = e;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `E::B` and `E::C` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n     //~| NOTE the matched value is of type `E`\n }\n \n fn by_ref_once(e: &E) {\n-    match e { //~ ERROR non-exhaustive patterns: `&E::B` and `&E::C` not covered\n-    //~^ NOTE patterns `&E::B` and `&E::C` not covered\n+    match e {\n+    //~^ ERROR non-exhaustive patterns\n+    //~| patterns `&E::B` and `&E::C` not covered\n     //~| NOTE the matched value is of type `&E`\n         E::A => {}\n     }\n \n-    let E::A = e; //~ ERROR refutable pattern in local binding: `&E::B` and `&E::C` not covered\n-    //~^ NOTE patterns `&E::B` and `&E::C` not covered\n+    let E::A = e;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `&E::B` and `&E::C` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n     //~| NOTE the matched value is of type `&E`\n }\n \n fn by_ref_thrice(e: & &mut &E) {\n-    match e { //~ ERROR non-exhaustive patterns: `&&mut &E::B` and `&&mut &E::C` not covered\n-    //~^ NOTE patterns `&&mut &E::B` and `&&mut &E::C` not covered\n+    match e {\n+    //~^ ERROR non-exhaustive patterns\n+    //~| patterns `&&mut &E::B` and `&&mut &E::C` not covered\n     //~| NOTE the matched value is of type `&&mut &E`\n         E::A => {}\n     }\n \n     let E::A = e;\n-    //~^ ERROR refutable pattern in local binding: `&&mut &E::B` and `&&mut &E::C` not covered\n-    //~| NOTE patterns `&&mut &E::B` and `&&mut &E::C` not covered\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `&&mut &E::B` and `&&mut &E::C` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n     //~| NOTE the matched value is of type `&&mut &E`\n@@ -83,20 +84,21 @@ enum Opt {\n     Some(u8),\n     None,\n     //~^ NOTE `Opt` defined here\n-    //~| NOTE `Opt` defined here\n     //~| NOTE not covered\n     //~| NOTE not covered\n }\n \n fn ref_pat(e: Opt) {\n-    match e {//~ ERROR non-exhaustive patterns: `Opt::None` not covered\n-        //~^ NOTE pattern `Opt::None` not covered\n+    match e {\n+        //~^ ERROR non-exhaustive patterns\n+        //~| pattern `Opt::None` not covered\n         //~| NOTE the matched value is of type `Opt`\n         Opt::Some(ref _x) => {}\n     }\n \n-    let Opt::Some(ref _x) = e; //~ ERROR refutable pattern in local binding: `Opt::None` not covered\n-    //~^ NOTE the matched value is of type `Opt`\n+    let Opt::Some(ref _x) = e;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| NOTE the matched value is of type `Opt`\n     //~| NOTE pattern `Opt::None` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "769d4070fb587fb56d31f2c2a74f775584bae7a0", "filename": "tests/ui/pattern/usefulness/non-exhaustive-defined-here.stderr", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,5 +1,5 @@\n error[E0004]: non-exhaustive patterns: `E::B` and `E::C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:38:11\n+  --> $DIR/non-exhaustive-defined-here.rs:35:11\n    |\n LL |     match e1 {\n    |           ^^ patterns `E::B` and `E::C` not covered\n@@ -22,33 +22,33 @@ LL ~         E::A => {}\n LL +         E::B | E::C => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `E::B` and `E::C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:44:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/non-exhaustive-defined-here.rs:41:9\n    |\n LL |     let E::A = e;\n    |         ^^^^ patterns `E::B` and `E::C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `E` defined here\n-  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+  --> $DIR/non-exhaustive-defined-here.rs:6:6\n    |\n LL | enum E {\n-   |      -\n+   |      ^\n ...\n LL |     B,\n-   |     ^ not covered\n+   |     - not covered\n ...\n LL |     C\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `E`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n LL |     if let E::A = e { todo!() }\n    |     ++              ~~~~~~~~~~~\n \n error[E0004]: non-exhaustive patterns: `&E::B` and `&E::C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:52:11\n+  --> $DIR/non-exhaustive-defined-here.rs:50:11\n    |\n LL |     match e {\n    |           ^ patterns `&E::B` and `&E::C` not covered\n@@ -71,25 +71,25 @@ LL ~         E::A => {}\n LL +         &E::B | &E::C => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `&E::B` and `&E::C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:58:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/non-exhaustive-defined-here.rs:57:9\n    |\n LL |     let E::A = e;\n    |         ^^^^ patterns `&E::B` and `&E::C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `E` defined here\n-  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+  --> $DIR/non-exhaustive-defined-here.rs:6:6\n    |\n LL | enum E {\n-   |      -\n+   |      ^\n ...\n LL |     B,\n-   |     ^ not covered\n+   |     - not covered\n ...\n LL |     C\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `&E`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n@@ -120,25 +120,25 @@ LL ~         E::A => {}\n LL +         &&mut &E::B | &&mut &E::C => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `&&mut &E::B` and `&&mut &E::C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:72:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/non-exhaustive-defined-here.rs:73:9\n    |\n LL |     let E::A = e;\n    |         ^^^^ patterns `&&mut &E::B` and `&&mut &E::C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `E` defined here\n-  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+  --> $DIR/non-exhaustive-defined-here.rs:6:6\n    |\n LL | enum E {\n-   |      -\n+   |      ^\n ...\n LL |     B,\n-   |     ^ not covered\n+   |     - not covered\n ...\n LL |     C\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `&&mut &E`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n@@ -152,7 +152,7 @@ LL |     match e {\n    |           ^ pattern `Opt::None` not covered\n    |\n note: `Opt` defined here\n-  --> $DIR/non-exhaustive-defined-here.rs:84:5\n+  --> $DIR/non-exhaustive-defined-here.rs:85:5\n    |\n LL | enum Opt {\n    |      ---\n@@ -166,28 +166,24 @@ LL ~         Opt::Some(ref _x) => {}\n LL +         Opt::None => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `Opt::None` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:98:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/non-exhaustive-defined-here.rs:99:9\n    |\n LL |     let Opt::Some(ref _x) = e;\n    |         ^^^^^^^^^^^^^^^^^ pattern `Opt::None` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Opt` defined here\n-  --> $DIR/non-exhaustive-defined-here.rs:84:5\n+  --> $DIR/non-exhaustive-defined-here.rs:81:6\n    |\n LL | enum Opt {\n-   |      ---\n+   |      ^^^\n ...\n LL |     None,\n-   |     ^^^^ not covered\n+   |     ---- not covered\n    = note: the matched value is of type `Opt`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let _x = if let Opt::Some(ref _x) = e { _x } else { todo!() };\n-   |     +++++++++++                           +++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Opt::Some(ref _x) = e else { todo!() };\n    |                               ++++++++++++++++"}, {"sha": "7a3e991d59317d3e6fcc3f8d5e93c96cff67441f", "filename": "tests/ui/pattern/usefulness/refutable-pattern-errors.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,7 +1,9 @@\n fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n-//~^ ERROR refutable pattern in function argument: `(_, _)` not covered\n+//~^ ERROR refutable pattern in function argument\n+//~| `(_, _)` not covered\n \n fn main() {\n     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n-    //~^ ERROR refutable pattern in local binding: `(i32::MIN..=0_i32, _)` and `(2_i32..=i32::MAX, _)` not covered\n+    //~^ ERROR refutable pattern in local binding\n+    //~| `(i32::MIN..=0_i32, _)` and `(2_i32..=i32::MAX, _)` not covered\n }"}, {"sha": "c518de47740dd89d5c9c30fdf2ce02c02fe0170f", "filename": "tests/ui/pattern/usefulness/refutable-pattern-errors.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,13 +1,13 @@\n-error[E0005]: refutable pattern in function argument: `(_, _)` not covered\n+error[E0005]: refutable pattern in function argument\n   --> $DIR/refutable-pattern-errors.rs:1:9\n    |\n LL | fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n    |         ^^^^^^^^^^^^^^^^^^^^^ pattern `(_, _)` not covered\n    |\n    = note: the matched value is of type `(isize, (Option<isize>, isize))`\n \n-error[E0005]: refutable pattern in local binding: `(i32::MIN..=0_i32, _)` and `(2_i32..=i32::MAX, _)` not covered\n-  --> $DIR/refutable-pattern-errors.rs:5:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/refutable-pattern-errors.rs:6:9\n    |\n LL |     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n    |         ^^^^^^^^^^^^^^^^^^^^^ patterns `(i32::MIN..=0_i32, _)` and `(2_i32..=i32::MAX, _)` not covered"}, {"sha": "17dc38ab25d92ff229b805d6e19e73ce074f6203", "filename": "tests/ui/pattern/usefulness/refutable-pattern-in-fn-arg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,5 +1,6 @@\n fn main() {\n     let f = |3: isize| println!(\"hello\");\n-    //~^ ERROR refutable pattern in function argument: `_` not covered\n+    //~^ ERROR refutable pattern in function argument\n+    //~| `_` not covered\n     f(4);\n }"}, {"sha": "55f0b2319fb7fc4ce6eec9d5883efbd69de8d0b1", "filename": "tests/ui/pattern/usefulness/refutable-pattern-in-fn-arg.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in function argument: `_` not covered\n+error[E0005]: refutable pattern in function argument\n   --> $DIR/refutable-pattern-in-fn-arg.rs:2:14\n    |\n LL |     let f = |3: isize| println!(\"hello\");"}, {"sha": "1b4d80d90571c31ac7b30f341799b060f1db71b1", "filename": "tests/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,22 +1,13 @@\n-error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/recursive-types-are-not-uninhabited.rs:6:9\n    |\n LL |     let Ok(x) = res;\n    |         ^^^^^ pattern `Err(_)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n-note: `Result<u32, &R<'_>>` defined here\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-   = note: not covered\n    = note: the matched value is of type `Result<u32, &R<'_>>`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let x = if let Ok(x) = res { x } else { todo!() };\n-   |     ++++++++++                 ++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Ok(x) = res else { todo!() };\n    |                     ++++++++++++++++"}, {"sha": "15f08486f0f0ebe2c921ea9333d62d486b7807c2", "filename": "tests/ui/suggestions/const-pat-non-exaustive-let-new-var.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,7 +1,8 @@\n fn main() {\n     let A = 3;\n-    //~^ ERROR refutable pattern in local binding: `i32::MIN..=1_i32` and\n-    //~| interpreted as a constant pattern, not a new variable\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `i32::MIN..=1_i32` and `3_i32..=i32::MAX` not covered\n+    //~| missing patterns are not covered because `a` is interpreted as a constant pattern, not a new variable\n     //~| HELP introduce a variable instead\n     //~| SUGGESTION a_var\n "}, {"sha": "1c1cab25fbfaf83250add6707af512d0952b0a51", "filename": "tests/ui/suggestions/const-pat-non-exaustive-let-new-var.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,10 +1,11 @@\n-error[E0005]: refutable pattern in local binding: `i32::MIN..=1_i32` and `3_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-pat-non-exaustive-let-new-var.rs:2:9\n    |\n LL |     let A = 3;\n    |         ^\n    |         |\n-   |         interpreted as a constant pattern, not a new variable\n+   |         patterns `i32::MIN..=1_i32` and `3_i32..=i32::MAX` not covered\n+   |         missing patterns are not covered because `a` is interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `a_var`\n ...\n LL |     const A: i32 = 2;"}, {"sha": "4b001aca2d1c7c4c7832514f9ca8fd2524db96fb", "filename": "tests/ui/uninhabited/uninhabited-irrefutable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -24,5 +24,7 @@ enum Foo {\n \n fn main() {\n     let x: Foo = Foo::D(123, 456);\n-    let Foo::D(_y, _z) = x; //~ ERROR refutable pattern in local binding: `Foo::A(_)` not covered\n+    let Foo::D(_y, _z) = x;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| `Foo::A(_)` not covered\n }"}, {"sha": "8cafea555c172490dd1c0c9ddb3c7ed5e1549ad0", "filename": "tests/ui/uninhabited/uninhabited-irrefutable.stderr", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `Foo::A(_)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/uninhabited-irrefutable.rs:27:9\n    |\n LL |     let Foo::D(_y, _z) = x;\n@@ -7,18 +7,14 @@ LL |     let Foo::D(_y, _z) = x;\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Foo` defined here\n-  --> $DIR/uninhabited-irrefutable.rs:19:5\n+  --> $DIR/uninhabited-irrefutable.rs:18:6\n    |\n LL | enum Foo {\n-   |      ---\n+   |      ^^^\n LL |     A(foo::SecretlyEmpty),\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `Foo`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let (_y, _z) = if let Foo::D(_y, _z) = x { (_y, _z) } else { todo!() };\n-   |     +++++++++++++++++                        +++++++++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Foo::D(_y, _z) = x else { todo!() };\n    |                            ++++++++++++++++"}, {"sha": "466d7f2eadb92c1fea2fa453567dd943b99188e4", "filename": "tests/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83d3b76ac26f592b4aa7f09c12c886e83a9fc404/tests%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=83d3b76ac26f592b4aa7f09c12c886e83a9fc404", "patch": "@@ -95,25 +95,16 @@ LL ~         Ok(x) => x,\n LL ~         Err(_) => todo!(),\n    |\n \n-error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/uninhabited-matches-feature-gated.rs:37:9\n    |\n LL |     let Ok(x) = x;\n    |         ^^^^^ pattern `Err(_)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n-note: `Result<u32, Void>` defined here\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-   = note: not covered\n    = note: the matched value is of type `Result<u32, Void>`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let x = if let Ok(x) = x { x } else { todo!() };\n-   |     ++++++++++               ++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Ok(x) = x else { todo!() };\n    |                   ++++++++++++++++"}]}