{"sha": "c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYjE1Y2M2ZWQzN2U2MjZiMmI1YjMyNGJiYjBmZGJmNjY4ODY1MGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-27T21:54:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-27T21:54:49Z"}, "message": "Auto merge of #77242 - ecstatic-morse:dataflow-switch-int, r=jonas-schievink\n\nReplace `discriminant_switch_effect` with more general version\n\n#68528 added a new edge-specific effect for `SwitchInt` terminators, `discriminant_switch_effect`, to the dataflow framework. While this accomplished the short-term goal of making drop elaboration more precise, it wasn't really useful in other contexts: It only supported `SwitchInt`s on the discriminant of an `enum` and did not allow effects to be applied along the \"otherwise\" branch. In const-propagation, for example, arbitrary edge-specific effects for the targets of a `SwitchInt` can be used to remember the value a `match` scrutinee must have in each arm.\n\nThis PR replaces `discriminant_switch_effect` with a more general `switch_int_edge_effects` method. The new method has a slightly different interface from the other edge-specific effect methods (e.g. `call_return_effect`). This divergence is explained in the new method's documentation, and reading the changes to the various dataflow impls as well as `direction.rs` should further clarify things. This PR should not change behavior.", "tree": {"sha": "40d073b31ffb947789422da4d64c2b2db39e0d1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40d073b31ffb947789422da4d64c2b2db39e0d1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a", "html_url": "https://github.com/rust-lang/rust/commit/c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f7a1cbfd3b55daee191247770627afab09eece2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f7a1cbfd3b55daee191247770627afab09eece2", "html_url": "https://github.com/rust-lang/rust/commit/7f7a1cbfd3b55daee191247770627afab09eece2"}, {"sha": "c0cd1b0a26a2d1ebc82c23764f8017a30e145f58", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0cd1b0a26a2d1ebc82c23764f8017a30e145f58", "html_url": "https://github.com/rust-lang/rust/commit/c0cd1b0a26a2d1ebc82c23764f8017a30e145f58"}], "stats": {"total": 360, "additions": 228, "deletions": 132}, "files": [{"sha": "ca2bb6e0bf7e91582c7157ee81c295ead9098779", "filename": "compiler/rustc_mir/src/dataflow/framework/direction.rs", "status": "modified", "additions": 68, "deletions": 78, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs?ref=c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a", "patch": "@@ -1,10 +1,10 @@\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{self, BasicBlock, Location};\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n use std::ops::RangeInclusive;\n \n use super::visitor::{ResultsVisitable, ResultsVisitor};\n-use super::{Analysis, Effect, EffectIndex, GenKillAnalysis, GenKillSet};\n+use super::{Analysis, Effect, EffectIndex, GenKillAnalysis, GenKillSet, SwitchIntTarget};\n \n pub trait Direction {\n     fn is_forward() -> bool;\n@@ -425,8 +425,8 @@ impl Direction for Forward {\n \n     fn join_state_into_successors_of<A>(\n         analysis: &A,\n-        tcx: TyCtxt<'tcx>,\n-        body: &mir::Body<'tcx>,\n+        _tcx: TyCtxt<'tcx>,\n+        _body: &mir::Body<'tcx>,\n         dead_unwinds: Option<&BitSet<BasicBlock>>,\n         exit_state: &mut A::Domain,\n         (bb, bb_data): (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n@@ -489,88 +489,78 @@ impl Direction for Forward {\n             }\n \n             SwitchInt { ref targets, ref values, ref discr, switch_ty: _ } => {\n-                let enum_ = discr\n-                    .place()\n-                    .and_then(|discr| switch_on_enum_discriminant(tcx, &body, bb_data, discr));\n-                match enum_ {\n-                    // If this is a switch on an enum discriminant, a custom effect may be applied\n-                    // along each outgoing edge.\n-                    Some((enum_place, enum_def)) => {\n-                        // MIR building adds discriminants to the `values` array in the same order as they\n-                        // are yielded by `AdtDef::discriminants`. We rely on this to match each\n-                        // discriminant in `values` to its corresponding variant in linear time.\n-                        let mut tmp = analysis.bottom_value(body);\n-                        let mut discriminants = enum_def.discriminants(tcx);\n-                        for (value, target) in values.iter().zip(targets.iter().copied()) {\n-                            let (variant_idx, _) =\n-                                discriminants.find(|&(_, discr)| discr.val == *value).expect(\n-                                    \"Order of `AdtDef::discriminants` differed \\\n-                                         from that of `SwitchInt::values`\",\n-                                );\n-\n-                            tmp.clone_from(exit_state);\n-                            analysis.apply_discriminant_switch_effect(\n-                                &mut tmp,\n-                                bb,\n-                                enum_place,\n-                                enum_def,\n-                                variant_idx,\n-                            );\n-                            propagate(target, &tmp);\n-                        }\n-\n-                        // Move out of `tmp` so we don't accidentally use it below.\n-                        std::mem::drop(tmp);\n-\n-                        // Propagate dataflow state along the \"otherwise\" edge.\n-                        let otherwise = targets.last().copied().unwrap();\n-                        propagate(otherwise, exit_state)\n-                    }\n-\n-                    // Otherwise, it's just a normal `SwitchInt`, and every successor sees the same\n-                    // exit state.\n-                    None => {\n-                        for target in targets.iter().copied() {\n-                            propagate(target, exit_state);\n-                        }\n+                let mut applier = SwitchIntEdgeEffectApplier {\n+                    exit_state,\n+                    targets: targets.as_ref(),\n+                    values: values.as_ref(),\n+                    propagate,\n+                    effects_applied: false,\n+                };\n+\n+                analysis.apply_switch_int_edge_effects(bb, discr, &mut applier);\n+\n+                let SwitchIntEdgeEffectApplier {\n+                    exit_state, mut propagate, effects_applied, ..\n+                } = applier;\n+\n+                if !effects_applied {\n+                    for &target in targets.iter() {\n+                        propagate(target, exit_state);\n                     }\n                 }\n             }\n         }\n     }\n }\n \n-/// Inspect a `SwitchInt`-terminated basic block to see if the condition of that `SwitchInt` is\n-/// an enum discriminant.\n-///\n-/// We expect such blocks to have a call to `discriminant` as their last statement like so:\n-///   _42 = discriminant(_1)\n-///   SwitchInt(_42, ..)\n-///\n-/// If the basic block matches this pattern, this function returns the place corresponding to the\n-/// enum (`_1` in the example above) as well as the `AdtDef` of that enum.\n-fn switch_on_enum_discriminant(\n-    tcx: TyCtxt<'tcx>,\n-    body: &'mir mir::Body<'tcx>,\n-    block: &'mir mir::BasicBlockData<'tcx>,\n-    switch_on: mir::Place<'tcx>,\n-) -> Option<(mir::Place<'tcx>, &'tcx ty::AdtDef)> {\n-    match block.statements.last().map(|stmt| &stmt.kind) {\n-        Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(discriminated))))\n-            if *lhs == switch_on =>\n-        {\n-            match &discriminated.ty(body, tcx).ty.kind() {\n-                ty::Adt(def, _) => Some((*discriminated, def)),\n-\n-                // `Rvalue::Discriminant` is also used to get the active yield point for a\n-                // generator, but we do not need edge-specific effects in that case. This may\n-                // change in the future.\n-                ty::Generator(..) => None,\n-\n-                t => bug!(\"`discriminant` called on unexpected type {:?}\", t),\n-            }\n+struct SwitchIntEdgeEffectApplier<'a, D, F> {\n+    exit_state: &'a mut D,\n+    values: &'a [u128],\n+    targets: &'a [BasicBlock],\n+    propagate: F,\n+\n+    effects_applied: bool,\n+}\n+\n+impl<D, F> super::SwitchIntEdgeEffects<D> for SwitchIntEdgeEffectApplier<'_, D, F>\n+where\n+    D: Clone,\n+    F: FnMut(BasicBlock, &D),\n+{\n+    fn apply(&mut self, mut apply_edge_effect: impl FnMut(&mut D, SwitchIntTarget)) {\n+        assert!(!self.effects_applied);\n+\n+        let mut tmp = None;\n+        for (&value, &target) in self.values.iter().zip(self.targets.iter()) {\n+            let tmp = opt_clone_from_or_clone(&mut tmp, self.exit_state);\n+            apply_edge_effect(tmp, SwitchIntTarget { value: Some(value), target });\n+            (self.propagate)(target, tmp);\n         }\n \n-        _ => None,\n+        // Once we get to the final, \"otherwise\" branch, there is no need to preserve `exit_state`,\n+        // so pass it directly to `apply_edge_effect` to save a clone of the dataflow state.\n+        let otherwise = self.targets.last().copied().unwrap();\n+        apply_edge_effect(self.exit_state, SwitchIntTarget { value: None, target: otherwise });\n+        (self.propagate)(otherwise, self.exit_state);\n+\n+        self.effects_applied = true;\n+    }\n+}\n+\n+/// An analogue of `Option::get_or_insert_with` that stores a clone of `val` into `opt`, but uses\n+/// the more efficient `clone_from` if `opt` was `Some`.\n+///\n+/// Returns a mutable reference to the new clone that resides in `opt`.\n+//\n+// FIXME: Figure out how to express this using `Option::clone_from`, or maybe lift it into the\n+// standard library?\n+fn opt_clone_from_or_clone<T: Clone>(opt: &'a mut Option<T>, val: &T) -> &'a mut T {\n+    if opt.is_some() {\n+        let ret = opt.as_mut().unwrap();\n+        ret.clone_from(val);\n+        ret\n+    } else {\n+        *opt = Some(val.clone());\n+        opt.as_mut().unwrap()\n     }\n }"}, {"sha": "65c159e6a72a9da89bf5cbaf480cc34dfc5e5ec2", "filename": "compiler/rustc_mir/src/dataflow/framework/mod.rs", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs?ref=c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a", "patch": "@@ -37,8 +37,7 @@ use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, BasicBlock, Location};\n-use rustc_middle::ty::{self, TyCtxt};\n-use rustc_target::abi::VariantIdx;\n+use rustc_middle::ty::TyCtxt;\n \n mod cursor;\n mod direction;\n@@ -152,6 +151,8 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     ) {\n     }\n \n+    /* Edge-specific effects */\n+\n     /// Updates the current dataflow state with the effect of a successful return from a `Call`\n     /// terminator.\n     ///\n@@ -183,20 +184,28 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// Updates the current dataflow state with the effect of taking a particular branch in a\n     /// `SwitchInt` terminator.\n     ///\n-    /// Much like `apply_call_return_effect`, this effect is only propagated along a single\n-    /// outgoing edge from this basic block.\n+    /// Unlike the other edge-specific effects, which are allowed to mutate `Self::Domain`\n+    /// directly, overriders of this method must pass a callback to\n+    /// `SwitchIntEdgeEffects::apply`. The callback will be run once for each outgoing edge and\n+    /// will have access to the dataflow state that will be propagated along that edge.\n+    ///\n+    /// This interface is somewhat more complex than the other visitor-like \"effect\" methods.\n+    /// However, it is both more ergonomic\u2014callers don't need to recompute or cache information\n+    /// about a given `SwitchInt` terminator for each one of its edges\u2014and more efficient\u2014the\n+    /// engine doesn't need to clone the exit state for a block unless\n+    /// `SwitchIntEdgeEffects::apply` is actually called.\n     ///\n     /// FIXME: This class of effects is not supported for backward dataflow analyses.\n-    fn apply_discriminant_switch_effect(\n+    fn apply_switch_int_edge_effects(\n         &self,\n-        _state: &mut Self::Domain,\n         _block: BasicBlock,\n-        _enum_place: mir::Place<'tcx>,\n-        _adt: &ty::AdtDef,\n-        _variant: VariantIdx,\n+        _discr: &mir::Operand<'tcx>,\n+        _apply_edge_effects: &mut impl SwitchIntEdgeEffects<Self::Domain>,\n     ) {\n     }\n \n+    /* Extension methods */\n+\n     /// Creates an `Engine` to find the fixpoint for this dataflow problem.\n     ///\n     /// You shouldn't need to override this outside this module, since the combination of the\n@@ -267,6 +276,8 @@ pub trait GenKillAnalysis<'tcx>: Analysis<'tcx> {\n     ) {\n     }\n \n+    /* Edge-specific effects */\n+\n     /// See `Analysis::apply_call_return_effect`.\n     fn call_return_effect(\n         &self,\n@@ -286,14 +297,12 @@ pub trait GenKillAnalysis<'tcx>: Analysis<'tcx> {\n     ) {\n     }\n \n-    /// See `Analysis::apply_discriminant_switch_effect`.\n-    fn discriminant_switch_effect(\n+    /// See `Analysis::apply_switch_int_edge_effects`.\n+    fn switch_int_edge_effects<G: GenKill<Self::Idx>>(\n         &self,\n-        _state: &mut impl GenKill<Self::Idx>,\n         _block: BasicBlock,\n-        _enum_place: mir::Place<'tcx>,\n-        _adt: &ty::AdtDef,\n-        _variant: VariantIdx,\n+        _discr: &mir::Operand<'tcx>,\n+        _edge_effects: &mut impl SwitchIntEdgeEffects<G>,\n     ) {\n     }\n }\n@@ -339,6 +348,8 @@ where\n         self.before_terminator_effect(state, terminator, location);\n     }\n \n+    /* Edge-specific effects */\n+\n     fn apply_call_return_effect(\n         &self,\n         state: &mut A::Domain,\n@@ -359,17 +370,17 @@ where\n         self.yield_resume_effect(state, resume_block, resume_place);\n     }\n \n-    fn apply_discriminant_switch_effect(\n+    fn apply_switch_int_edge_effects(\n         &self,\n-        state: &mut A::Domain,\n         block: BasicBlock,\n-        enum_place: mir::Place<'tcx>,\n-        adt: &ty::AdtDef,\n-        variant: VariantIdx,\n+        discr: &mir::Operand<'tcx>,\n+        edge_effects: &mut impl SwitchIntEdgeEffects<A::Domain>,\n     ) {\n-        self.discriminant_switch_effect(state, block, enum_place, adt, variant);\n+        self.switch_int_edge_effects(block, discr, edge_effects);\n     }\n \n+    /* Extension methods */\n+\n     fn into_engine(\n         self,\n         tcx: TyCtxt<'tcx>,\n@@ -531,5 +542,17 @@ impl EffectIndex {\n     }\n }\n \n+pub struct SwitchIntTarget {\n+    pub value: Option<u128>,\n+    pub target: BasicBlock,\n+}\n+\n+/// A type that records the edge-specific effects for a `SwitchInt` terminator.\n+pub trait SwitchIntEdgeEffects<D> {\n+    /// Calls `apply_edge_effect` for each outgoing edge from a `SwitchInt` terminator and\n+    /// records the results.\n+    fn apply(&mut self, apply_edge_effect: impl FnMut(&mut D, SwitchIntTarget));\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "d4b9600f766f8b7583aebd961b74859633ba364f", "filename": "compiler/rustc_mir/src/dataflow/impls/mod.rs", "status": "modified", "additions": 116, "deletions": 33, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs?ref=c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a", "patch": "@@ -6,7 +6,6 @@ use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, Body, Location};\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_target::abi::VariantIdx;\n \n use super::MoveDataParamEnv;\n \n@@ -19,6 +18,7 @@ use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;\n use super::on_lookup_result_bits;\n use crate::dataflow::drop_flag_effects;\n+use crate::dataflow::framework::SwitchIntEdgeEffects;\n \n mod borrowed_locals;\n pub(super) mod borrows;\n@@ -352,24 +352,46 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeInitializedPlaces<'_, 'tcx> {\n         );\n     }\n \n-    fn discriminant_switch_effect(\n+    fn switch_int_edge_effects<G: GenKill<Self::Idx>>(\n         &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        _block: mir::BasicBlock,\n-        enum_place: mir::Place<'tcx>,\n-        _adt: &ty::AdtDef,\n-        variant: VariantIdx,\n+        block: mir::BasicBlock,\n+        discr: &mir::Operand<'tcx>,\n+        edge_effects: &mut impl SwitchIntEdgeEffects<G>,\n     ) {\n-        // Kill all move paths that correspond to variants we know to be inactive along this\n-        // particular outgoing edge of a `SwitchInt`.\n-        drop_flag_effects::on_all_inactive_variants(\n-            self.tcx,\n-            self.body,\n-            self.move_data(),\n-            enum_place,\n-            variant,\n-            |mpi| trans.kill(mpi),\n-        );\n+        let enum_ = discr.place().and_then(|discr| {\n+            switch_on_enum_discriminant(self.tcx, &self.body, &self.body[block], discr)\n+        });\n+\n+        let (enum_place, enum_def) = match enum_ {\n+            Some(x) => x,\n+            None => return,\n+        };\n+\n+        let mut discriminants = enum_def.discriminants(self.tcx);\n+        edge_effects.apply(|trans, edge| {\n+            let value = match edge.value {\n+                Some(x) => x,\n+                None => return,\n+            };\n+\n+            // MIR building adds discriminants to the `values` array in the same order as they\n+            // are yielded by `AdtDef::discriminants`. We rely on this to match each\n+            // discriminant in `values` to its corresponding variant in linear time.\n+            let (variant, _) = discriminants\n+                .find(|&(_, discr)| discr.val == value)\n+                .expect(\"Order of `AdtDef::discriminants` differed from `SwitchInt::values`\");\n+\n+            // Kill all move paths that correspond to variants we know to be inactive along this\n+            // particular outgoing edge of a `SwitchInt`.\n+            drop_flag_effects::on_all_inactive_variants(\n+                self.tcx,\n+                self.body,\n+                self.move_data(),\n+                enum_place,\n+                variant,\n+                |mpi| trans.kill(mpi),\n+            );\n+        });\n     }\n }\n \n@@ -441,28 +463,50 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n         );\n     }\n \n-    fn discriminant_switch_effect(\n+    fn switch_int_edge_effects<G: GenKill<Self::Idx>>(\n         &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        _block: mir::BasicBlock,\n-        enum_place: mir::Place<'tcx>,\n-        _adt: &ty::AdtDef,\n-        variant: VariantIdx,\n+        block: mir::BasicBlock,\n+        discr: &mir::Operand<'tcx>,\n+        edge_effects: &mut impl SwitchIntEdgeEffects<G>,\n     ) {\n         if !self.mark_inactive_variants_as_uninit {\n             return;\n         }\n \n-        // Mark all move paths that correspond to variants other than this one as maybe\n-        // uninitialized (in reality, they are *definitely* uninitialized).\n-        drop_flag_effects::on_all_inactive_variants(\n-            self.tcx,\n-            self.body,\n-            self.move_data(),\n-            enum_place,\n-            variant,\n-            |mpi| trans.gen(mpi),\n-        );\n+        let enum_ = discr.place().and_then(|discr| {\n+            switch_on_enum_discriminant(self.tcx, &self.body, &self.body[block], discr)\n+        });\n+\n+        let (enum_place, enum_def) = match enum_ {\n+            Some(x) => x,\n+            None => return,\n+        };\n+\n+        let mut discriminants = enum_def.discriminants(self.tcx);\n+        edge_effects.apply(|trans, edge| {\n+            let value = match edge.value {\n+                Some(x) => x,\n+                None => return,\n+            };\n+\n+            // MIR building adds discriminants to the `values` array in the same order as they\n+            // are yielded by `AdtDef::discriminants`. We rely on this to match each\n+            // discriminant in `values` to its corresponding variant in linear time.\n+            let (variant, _) = discriminants\n+                .find(|&(_, discr)| discr.val == value)\n+                .expect(\"Order of `AdtDef::discriminants` differed from `SwitchInt::values`\");\n+\n+            // Mark all move paths that correspond to variants other than this one as maybe\n+            // uninitialized (in reality, they are *definitely* uninitialized).\n+            drop_flag_effects::on_all_inactive_variants(\n+                self.tcx,\n+                self.body,\n+                self.move_data(),\n+                enum_place,\n+                variant,\n+                |mpi| trans.gen(mpi),\n+            );\n+        });\n     }\n }\n \n@@ -624,3 +668,42 @@ impl<'tcx> GenKillAnalysis<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n         }\n     }\n }\n+\n+/// Inspect a `SwitchInt`-terminated basic block to see if the condition of that `SwitchInt` is\n+/// an enum discriminant.\n+///\n+/// We expect such blocks to have a call to `discriminant` as their last statement like so:\n+///\n+/// ```text\n+/// ...\n+/// _42 = discriminant(_1)\n+/// SwitchInt(_42, ..)\n+/// ```\n+///\n+/// If the basic block matches this pattern, this function returns the place corresponding to the\n+/// enum (`_1` in the example above) as well as the `AdtDef` of that enum.\n+fn switch_on_enum_discriminant(\n+    tcx: TyCtxt<'tcx>,\n+    body: &'mir mir::Body<'tcx>,\n+    block: &'mir mir::BasicBlockData<'tcx>,\n+    switch_on: mir::Place<'tcx>,\n+) -> Option<(mir::Place<'tcx>, &'tcx ty::AdtDef)> {\n+    match block.statements.last().map(|stmt| &stmt.kind) {\n+        Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(discriminated))))\n+            if *lhs == switch_on =>\n+        {\n+            match &discriminated.ty(body, tcx).ty.kind() {\n+                ty::Adt(def, _) => Some((*discriminated, def)),\n+\n+                // `Rvalue::Discriminant` is also used to get the active yield point for a\n+                // generator, but we do not need edge-specific effects in that case. This may\n+                // change in the future.\n+                ty::Generator(..) => None,\n+\n+                t => bug!(\"`discriminant` called on unexpected type {:?}\", t),\n+            }\n+        }\n+\n+        _ => None,\n+    }\n+}"}]}