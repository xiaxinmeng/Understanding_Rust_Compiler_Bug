{"sha": "8d1bb0e7488855f40175d38c035bad1c546da97b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMWJiMGU3NDg4ODU1ZjQwMTc1ZDM4YzAzNWJhZDFjNTQ2ZGE5N2I=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-18T01:13:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-18T01:13:44Z"}, "message": "Rollup merge of #74441 - eddyb:zlib-on-nixos, r=nagisa\n\nbootstrap.py: patch RPATH on NixOS to handle the new zlib dependency.\n\nThis is a stop-gap until #74420 is resolved (assuming we'll patch beta to statically link zlib).\n\nHowever, I've been meaning to rewrite the NixOS support we have in `bootstrap.py` for a while now, and had to in order to cleanly add zlib as a dependency (the second commit is a relatively small delta in functionality, compared to the first).\n\nPreviously, we would extract the `ld-linux.so` path from the output of `ldd /run/current-system/sw/bin/sh`, which assumes a lot. On top of that we didn't use any symlinks, which meant if the user ran  GC (`nix-collect-garbage`), e.g. after updating their system, their `stage0` binaries would suddenly be broken (i.e. referring to files that no longer exist).\nWe were also using `patchelf` directly, assuming it can be found in `$PATH` (which is not necessarily true).\n\nMy new approach relies on using `nix-build` to get the following \"derivations\" (packages, more or less):\n* `stdenv.cc.bintools`, which has a `nix-support/dynamic-linker` file containing the path to `ld-linux.so`\n  * reading this file is [the canonical way to run `patchelf --set-interpreter`](https://github.com/NixOS/nixpkgs/search?l=Nix&q=%22--set-interpreter+%24%28cat+%24NIX_CC%2Fnix-support%2Fdynamic-linker%29%22)\n* `patchelf` (so that the user doesn't need to have it installed)\n* `zlib`, for the `libz.so` dependency of `libLLVM-*.so` (until #74420 is resolved, presumably)\n\nThis is closer to how software is built on Nix, but I've tried to keep it as simple as possible (and not add e.g. a `stage0.nix` file).\nSymlinks to each of those dependencies are kept in `stage0/.nix-deps`, which prevents GC from invalidating `stage0` binaries.\n\nr? @nagisa cc @Mark-Simulacrum @oli-obk @davidtwco", "tree": {"sha": "2a0f06de6119a76ee4ca8b16222a4bf8934a1538", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a0f06de6119a76ee4ca8b16222a4bf8934a1538"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d1bb0e7488855f40175d38c035bad1c546da97b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfEkzICRBK7hj4Ov3rIwAAdHIIAITTSefimysfHXA1GJLJ7kTW\nzm2rwVWCExB+gv/qJ3vN0arNiWOqA4+ElT8YEBGkPcbQLOaK6H/XlS7+Uk7h1dq0\n3ak4yVB+RjOMBfcD9DsosJlU60ESj/oJ2gtYeUcwjauyvj8/P3dU2ANZqi9N0PkI\nP+77RrOAFrL67yc0aWS/x2aQNs75DlN8BwTsUXG1kyj1hr61PruMcP4CUBUnLNr0\n9dYG26vBe1p28ZqAUlZbD6S8pBLOrX42QIwdgsLDz6foVlYyrGRdsKDPSxKhbzNd\nIvj2gUJUmkX4iH1/3peuluzN/X50F8VZ/7pywkHQi+BENVqRp/VNePSqa7AY3Bs=\n=exIu\n-----END PGP SIGNATURE-----\n", "payload": "tree 2a0f06de6119a76ee4ca8b16222a4bf8934a1538\nparent 7b66c6678c107b4b391a8561c375e8ffad0f52e2\nparent b5076fbb9669bd8e29ad58160a2d60ddd6813df7\nauthor Manish Goregaokar <manishsmail@gmail.com> 1595034824 -0700\ncommitter GitHub <noreply@github.com> 1595034824 -0700\n\nRollup merge of #74441 - eddyb:zlib-on-nixos, r=nagisa\n\nbootstrap.py: patch RPATH on NixOS to handle the new zlib dependency.\n\nThis is a stop-gap until #74420 is resolved (assuming we'll patch beta to statically link zlib).\n\nHowever, I've been meaning to rewrite the NixOS support we have in `bootstrap.py` for a while now, and had to in order to cleanly add zlib as a dependency (the second commit is a relatively small delta in functionality, compared to the first).\n\nPreviously, we would extract the `ld-linux.so` path from the output of `ldd /run/current-system/sw/bin/sh`, which assumes a lot. On top of that we didn't use any symlinks, which meant if the user ran  GC (`nix-collect-garbage`), e.g. after updating their system, their `stage0` binaries would suddenly be broken (i.e. referring to files that no longer exist).\nWe were also using `patchelf` directly, assuming it can be found in `$PATH` (which is not necessarily true).\n\nMy new approach relies on using `nix-build` to get the following \"derivations\" (packages, more or less):\n* `stdenv.cc.bintools`, which has a `nix-support/dynamic-linker` file containing the path to `ld-linux.so`\n  * reading this file is [the canonical way to run `patchelf --set-interpreter`](https://github.com/NixOS/nixpkgs/search?l=Nix&q=%22--set-interpreter+%24%28cat+%24NIX_CC%2Fnix-support%2Fdynamic-linker%29%22)\n* `patchelf` (so that the user doesn't need to have it installed)\n* `zlib`, for the `libz.so` dependency of `libLLVM-*.so` (until #74420 is resolved, presumably)\n\nThis is closer to how software is built on Nix, but I've tried to keep it as simple as possible (and not add e.g. a `stage0.nix` file).\nSymlinks to each of those dependencies are kept in `stage0/.nix-deps`, which prevents GC from invalidating `stage0` binaries.\n\nr? @nagisa cc @Mark-Simulacrum @oli-obk @davidtwco\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d1bb0e7488855f40175d38c035bad1c546da97b", "html_url": "https://github.com/rust-lang/rust/commit/8d1bb0e7488855f40175d38c035bad1c546da97b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d1bb0e7488855f40175d38c035bad1c546da97b/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b66c6678c107b4b391a8561c375e8ffad0f52e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b66c6678c107b4b391a8561c375e8ffad0f52e2", "html_url": "https://github.com/rust-lang/rust/commit/7b66c6678c107b4b391a8561c375e8ffad0f52e2"}, {"sha": "b5076fbb9669bd8e29ad58160a2d60ddd6813df7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5076fbb9669bd8e29ad58160a2d60ddd6813df7", "html_url": "https://github.com/rust-lang/rust/commit/b5076fbb9669bd8e29ad58160a2d60ddd6813df7"}], "stats": {"total": 104, "additions": 66, "deletions": 38}, "files": [{"sha": "c3f1bac177de7dd6695196a0b12cc2ca69048cc5", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 66, "deletions": 38, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/8d1bb0e7488855f40175d38c035bad1c546da97b/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/8d1bb0e7488855f40175d38c035bad1c546da97b/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=8d1bb0e7488855f40175d38c035bad1c546da97b", "patch": "@@ -349,6 +349,7 @@ def __init__(self):\n         self.use_vendored_sources = ''\n         self.verbose = False\n         self.git_version = None\n+        self.nix_deps_dir = None\n \n     def download_stage0(self):\n         \"\"\"Fetch the build system for Rust, written in Rust\n@@ -388,8 +389,12 @@ def support_xz():\n             filename = \"rustc-{}-{}{}\".format(rustc_channel, self.build,\n                                               tarball_suffix)\n             self._download_stage0_helper(filename, \"rustc\", tarball_suffix)\n-            self.fix_executable(\"{}/bin/rustc\".format(self.bin_root()))\n-            self.fix_executable(\"{}/bin/rustdoc\".format(self.bin_root()))\n+            self.fix_bin_or_dylib(\"{}/bin/rustc\".format(self.bin_root()))\n+            self.fix_bin_or_dylib(\"{}/bin/rustdoc\".format(self.bin_root()))\n+            lib_dir = \"{}/lib\".format(self.bin_root())\n+            for lib in os.listdir(lib_dir):\n+                if lib.endswith(\".so\"):\n+                    self.fix_bin_or_dylib(\"{}/{}\".format(lib_dir, lib))\n             with output(self.rustc_stamp()) as rust_stamp:\n                 rust_stamp.write(self.date)\n \n@@ -408,7 +413,7 @@ def support_xz():\n             filename = \"cargo-{}-{}{}\".format(cargo_channel, self.build,\n                                               tarball_suffix)\n             self._download_stage0_helper(filename, \"cargo\", tarball_suffix)\n-            self.fix_executable(\"{}/bin/cargo\".format(self.bin_root()))\n+            self.fix_bin_or_dylib(\"{}/bin/cargo\".format(self.bin_root()))\n             with output(self.cargo_stamp()) as cargo_stamp:\n                 cargo_stamp.write(self.date)\n \n@@ -421,8 +426,8 @@ def support_xz():\n                 [channel, date] = rustfmt_channel.split('-', 1)\n                 filename = \"rustfmt-{}-{}{}\".format(channel, self.build, tarball_suffix)\n                 self._download_stage0_helper(filename, \"rustfmt-preview\", tarball_suffix, date)\n-                self.fix_executable(\"{}/bin/rustfmt\".format(self.bin_root()))\n-                self.fix_executable(\"{}/bin/cargo-fmt\".format(self.bin_root()))\n+                self.fix_bin_or_dylib(\"{}/bin/rustfmt\".format(self.bin_root()))\n+                self.fix_bin_or_dylib(\"{}/bin/cargo-fmt\".format(self.bin_root()))\n                 with output(self.rustfmt_stamp()) as rustfmt_stamp:\n                     rustfmt_stamp.write(self.date + self.rustfmt_channel)\n \n@@ -440,12 +445,12 @@ def _download_stage0_helper(self, filename, pattern, tarball_suffix, date=None):\n             get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n         unpack(tarball, tarball_suffix, self.bin_root(), match=pattern, verbose=self.verbose)\n \n-    @staticmethod\n-    def fix_executable(fname):\n-        \"\"\"Modifies the interpreter section of 'fname' to fix the dynamic linker\n+    def fix_bin_or_dylib(self, fname):\n+        \"\"\"Modifies the interpreter section of 'fname' to fix the dynamic linker,\n+        or the RPATH section, to fix the dynamic library search path\n \n         This method is only required on NixOS and uses the PatchELF utility to\n-        change the dynamic linker of ELF executables.\n+        change the interpreter/RPATH of ELF executables.\n \n         Please see https://nixos.org/patchelf.html for more information\n         \"\"\"\n@@ -472,38 +477,61 @@ def fix_executable(fname):\n         nix_os_msg = \"info: you seem to be running NixOS. Attempting to patch\"\n         print(nix_os_msg, fname)\n \n-        try:\n-            interpreter = subprocess.check_output(\n-                [\"patchelf\", \"--print-interpreter\", fname])\n-            interpreter = interpreter.strip().decode(default_encoding)\n-        except subprocess.CalledProcessError as reason:\n-            print(\"warning: failed to call patchelf:\", reason)\n-            return\n-\n-        loader = interpreter.split(\"/\")[-1]\n-\n-        try:\n-            ldd_output = subprocess.check_output(\n-                ['ldd', '/run/current-system/sw/bin/sh'])\n-            ldd_output = ldd_output.strip().decode(default_encoding)\n-        except subprocess.CalledProcessError as reason:\n-            print(\"warning: unable to call ldd:\", reason)\n-            return\n-\n-        for line in ldd_output.splitlines():\n-            libname = line.split()[0]\n-            if libname.endswith(loader):\n-                loader_path = libname[:len(libname) - len(loader)]\n-                break\n+        # Only build `stage0/.nix-deps` once.\n+        nix_deps_dir = self.nix_deps_dir\n+        if not nix_deps_dir:\n+            nix_deps_dir = \"{}/.nix-deps\".format(self.bin_root())\n+            if not os.path.exists(nix_deps_dir):\n+                os.makedirs(nix_deps_dir)\n+\n+            nix_deps = [\n+                # Needed for the path of `ld-linux.so` (via `nix-support/dynamic-linker`).\n+                \"stdenv.cc.bintools\",\n+\n+                # Needed as a system dependency of `libLLVM-*.so`.\n+                \"zlib\",\n+\n+                # Needed for patching ELF binaries (see doc comment above).\n+                \"patchelf\",\n+            ]\n+\n+            # Run `nix-build` to \"build\" each dependency (which will likely reuse\n+            # the existing `/nix/store` copy, or at most download a pre-built copy).\n+            # Importantly, we don't rely on `nix-build` printing the `/nix/store`\n+            # path on stdout, but use `-o` to symlink it into `stage0/.nix-deps/$dep`,\n+            # ensuring garbage collection will never remove the `/nix/store` path\n+            # (which would break our patched binaries that hardcode those paths).\n+            for dep in nix_deps:\n+                try:\n+                    subprocess.check_output([\n+                        \"nix-build\", \"<nixpkgs>\",\n+                        \"-A\", dep,\n+                        \"-o\", \"{}/{}\".format(nix_deps_dir, dep),\n+                    ])\n+                except subprocess.CalledProcessError as reason:\n+                    print(\"warning: failed to call nix-build:\", reason)\n+                    return\n+\n+            self.nix_deps_dir = nix_deps_dir\n+\n+        patchelf = \"{}/patchelf/bin/patchelf\".format(nix_deps_dir)\n+\n+        if fname.endswith(\".so\"):\n+            # Dynamic library, patch RPATH to point to system dependencies.\n+            dylib_deps = [\"zlib\"]\n+            rpath_entries = [\n+                # Relative default, all binary and dynamic libraries we ship\n+                # appear to have this (even when `../lib` is redundant).\n+                \"$ORIGIN/../lib\",\n+            ] + [\"{}/{}/lib\".format(nix_deps_dir, dep) for dep in dylib_deps]\n+            patchelf_args = [\"--set-rpath\", \":\".join(rpath_entries)]\n         else:\n-            print(\"warning: unable to find the path to the dynamic linker\")\n-            return\n-\n-        correct_interpreter = loader_path + loader\n+            bintools_dir = \"{}/stdenv.cc.bintools\".format(nix_deps_dir)\n+            with open(\"{}/nix-support/dynamic-linker\".format(bintools_dir)) as dynamic_linker:\n+                patchelf_args = [\"--set-interpreter\", dynamic_linker.read().rstrip()]\n \n         try:\n-            subprocess.check_output(\n-                [\"patchelf\", \"--set-interpreter\", correct_interpreter, fname])\n+            subprocess.check_output([patchelf] + patchelf_args + [fname])\n         except subprocess.CalledProcessError as reason:\n             print(\"warning: failed to call patchelf:\", reason)\n             return"}]}