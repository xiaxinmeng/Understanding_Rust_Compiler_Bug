{"sha": "1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNmU5OGMwYzJiZDZiNzM2ZmM2YmVmOWJjMWZiOGUzNGQyNGU0ODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-25T04:56:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-25T04:56:50Z"}, "message": "auto merge of #12991 : alexcrichton/rust/sync-chan, r=brson\n\nThis commit contains an implementation of synchronous, bounded channels for\r\nRust. This is an implementation of the proposal made last January [1]. These\r\nchannels are built on mutexes, and currently focus on a working implementation\r\nrather than speed. Receivers for sync channels have select() implemented for\r\nthem, but there is currently no implementation of select() for sync senders.\r\n\r\nRust will continue to provide both synchronous and asynchronous channels as part\r\nof the standard distribution, there is no intent to remove asynchronous\r\nchannels. This flavor of channels is meant to provide an alternative to\r\nasynchronous channels because like green tasks, asynchronous channels are not\r\nappropriate for all situations.\r\n\r\n[1] - https://mail.mozilla.org/pipermail/rust-dev/2014-January/007924.html", "tree": {"sha": "3e85ccd4d544a76031847cddb3009bf477d9159a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e85ccd4d544a76031847cddb3009bf477d9159a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488", "html_url": "https://github.com/rust-lang/rust/commit/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "html_url": "https://github.com/rust-lang/rust/commit/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455"}, {"sha": "56cae9b3c0a49ff39f14570301db43008e810695", "url": "https://api.github.com/repos/rust-lang/rust/commits/56cae9b3c0a49ff39f14570301db43008e810695", "html_url": "https://github.com/rust-lang/rust/commit/56cae9b3c0a49ff39f14570301db43008e810695"}], "stats": {"total": 1344, "additions": 1229, "deletions": 115}, "files": [{"sha": "94e3d5ce2d3f643df023db8b3bb6647aecd0e45a", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 696, "deletions": 2, "changes": 698, "blob_url": "https://github.com/rust-lang/rust/blob/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488", "patch": "@@ -280,6 +280,7 @@ mod select;\n mod oneshot;\n mod stream;\n mod shared;\n+mod sync;\n \n // Use a power of 2 to allow LLVM to optimize to something that's not a\n // division, this is hit pretty regularly.\n@@ -301,15 +302,23 @@ pub struct Messages<'a, T> {\n     priv rx: &'a Receiver<T>\n }\n \n-/// The sending-half of Rust's channel type. This half can only be owned by one\n-/// task\n+/// The sending-half of Rust's asynchronous channel type. This half can only be\n+/// owned by one task, but it can be cloned to send to other tasks.\n pub struct Sender<T> {\n     priv inner: Flavor<T>,\n     priv sends: Cell<uint>,\n     // can't share in an arc\n     priv marker: marker::NoShare,\n }\n \n+/// The sending-half of Rust's synchronous channel type. This half can only be\n+/// owned by one task, but it can be cloned to send to other tasks.\n+pub struct SyncSender<T> {\n+    priv inner: UnsafeArc<sync::Packet<T>>,\n+    // can't share in an arc\n+    priv marker: marker::NoShare,\n+}\n+\n /// This enumeration is the list of the possible reasons that try_recv could not\n /// return data when called.\n #[deriving(Eq, Clone, Show)]\n@@ -324,10 +333,31 @@ pub enum TryRecvResult<T> {\n     Data(T),\n }\n \n+/// This enumeration is the list of the possible outcomes for the\n+/// `SyncSender::try_send` method.\n+#[deriving(Eq, Clone, Show)]\n+pub enum TrySendResult<T> {\n+    /// The data was successfully sent along the channel. This either means that\n+    /// it was buffered in the channel, or handed off to a receiver. In either\n+    /// case, the callee no longer has ownership of the data.\n+    Sent,\n+    /// The data could not be sent on the channel because it would require that\n+    /// the callee block to send the data.\n+    ///\n+    /// If this is a buffered channel, then the buffer is full at this time. If\n+    /// this is not a buffered channel, then there is no receiver available to\n+    /// acquire the data.\n+    Full(T),\n+    /// This channel's receiving half has disconnected, so the data could not be\n+    /// sent. The data is returned back to the callee in this case.\n+    RecvDisconnected(T),\n+}\n+\n enum Flavor<T> {\n     Oneshot(UnsafeArc<oneshot::Packet<T>>),\n     Stream(UnsafeArc<stream::Packet<T>>),\n     Shared(UnsafeArc<shared::Packet<T>>),\n+    Sync(UnsafeArc<sync::Packet<T>>),\n }\n \n /// Creates a new channel, returning the sender/receiver halves. All data sent\n@@ -338,6 +368,46 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n     (Sender::my_new(Oneshot(b)), Receiver::my_new(Oneshot(a)))\n }\n \n+/// Creates a new synchronous, bounded channel.\n+///\n+/// Like asynchronous channels, the `Receiver` will block until a message\n+/// becomes available. These channels differ greatly in the semantics of the\n+/// sender from asynchronous channels, however.\n+///\n+/// This channel has an internal buffer on which messages will be queued. When\n+/// the internal buffer becomes full, future sends will *block* waiting for the\n+/// buffer to open up. Note that a buffer size of 0 is valid, in which case this\n+/// becomes  \"rendezvous channel\" where each send will not return until a recv\n+/// is paired with it.\n+///\n+/// As with asynchronous channels, all senders will fail in `send` if the\n+/// `Receiver` has been destroyed.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let (tx, rx) = sync_channel(1);\n+///\n+/// // this returns immediately\n+/// tx.send(1);\n+///\n+/// spawn(proc() {\n+///     // this will block until the previous message has been received\n+///     tx.send(2);\n+/// });\n+///\n+/// assert_eq!(rx.recv(), 1);\n+/// assert_eq!(rx.recv(), 2);\n+/// ```\n+pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n+    let (a, b) = UnsafeArc::new2(sync::Packet::new(bound));\n+    (SyncSender::new(a), Receiver::my_new(Sync(b)))\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Sender\n+////////////////////////////////////////////////////////////////////////////////\n+\n impl<T: Send> Sender<T> {\n     fn my_new(inner: Flavor<T>) -> Sender<T> {\n         Sender { inner: inner, sends: Cell::new(0), marker: marker::NoShare }\n@@ -422,6 +492,7 @@ impl<T: Send> Sender<T> {\n             }\n             Stream(ref p) => return unsafe { (*p.get()).send(t) },\n             Shared(ref p) => return unsafe { (*p.get()).send(t) },\n+            Sync(..) => unreachable!(),\n         };\n \n         unsafe {\n@@ -453,6 +524,7 @@ impl<T: Send> Clone for Sender<T> {\n                 unsafe { (*p.get()).clone_chan(); }\n                 return Sender::my_new(Shared(p.clone()));\n             }\n+            Sync(..) => unreachable!(),\n         };\n \n         unsafe {\n@@ -472,10 +544,100 @@ impl<T: Send> Drop for Sender<T> {\n             Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n             Stream(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n             Shared(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n+            Sync(..) => unreachable!(),\n         }\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// SyncSender\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl<T: Send> SyncSender<T> {\n+    fn new(inner: UnsafeArc<sync::Packet<T>>) -> SyncSender<T> {\n+        SyncSender { inner: inner, marker: marker::NoShare }\n+    }\n+\n+    /// Sends a value on this synchronous channel.\n+    ///\n+    /// This function will *block* until space in the internal buffer becomes\n+    /// available or a receiver is available to hand off the message to.\n+    ///\n+    /// Note that a successful send does *not* guarantee that the receiver will\n+    /// ever see the data if there is a buffer on this channel. Messages may be\n+    /// enqueued in the internal buffer for the receiver to receive at a later\n+    /// time. If the buffer size is 0, however, it can be guaranteed that the\n+    /// receiver has indeed received the data if this function returns success.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Similarly to `Sender::send`, this function will fail if the\n+    /// corresponding `Receiver` for this channel has disconnected. This\n+    /// behavior is used to propagate failure among tasks.\n+    ///\n+    /// If failure is not desired, you can achieve the same semantics with the\n+    /// `SyncSender::send_opt` method which will not fail if the receiver\n+    /// disconnects.\n+    pub fn send(&self, t: T) {\n+        if self.send_opt(t).is_some() {\n+            fail!(\"sending on a closed channel\");\n+        }\n+    }\n+\n+    /// Send a value on a channel, returning it back if the receiver\n+    /// disconnected\n+    ///\n+    /// This method will *block* to send the value `t` on the channel, but if\n+    /// the value could not be sent due to the receiver disconnecting, the value\n+    /// is returned back to the callee. This function is similar to `try_send`,\n+    /// except that it will block if the channel is currently full.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function cannot fail.\n+    pub fn send_opt(&self, t: T) -> Option<T> {\n+        match unsafe { (*self.inner.get()).send(t) } {\n+            Ok(()) => None,\n+            Err(t) => Some(t),\n+        }\n+    }\n+\n+    /// Attempts to send a value on this channel without blocking.\n+    ///\n+    /// This method semantically differs from `Sender::try_send` because it can\n+    /// fail if the receiver has not disconnected yet. If the buffer on this\n+    /// channel is full, this function will immediately return the data back to\n+    /// the callee.\n+    ///\n+    /// See `SyncSender::send` for notes about guarantees of whether the\n+    /// receiver has received the data or not if this function is successful.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function cannot fail\n+    pub fn try_send(&self, t: T) -> TrySendResult<T> {\n+        unsafe { (*self.inner.get()).try_send(t) }\n+    }\n+}\n+\n+impl<T: Send> Clone for SyncSender<T> {\n+    fn clone(&self) -> SyncSender<T> {\n+        unsafe { (*self.inner.get()).clone_chan(); }\n+        return SyncSender::new(self.inner.clone());\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T: Send> Drop for SyncSender<T> {\n+    fn drop(&mut self) {\n+        unsafe { (*self.inner.get()).drop_chan(); }\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Receiver\n+////////////////////////////////////////////////////////////////////////////////\n+\n impl<T: Send> Receiver<T> {\n     fn my_new(inner: Flavor<T>) -> Receiver<T> {\n         Receiver { inner: inner, receives: Cell::new(0), marker: marker::NoShare }\n@@ -554,6 +716,13 @@ impl<T: Send> Receiver<T> {\n                         Err(shared::Disconnected) => return Disconnected,\n                     }\n                 }\n+                Sync(ref p) => {\n+                    match unsafe { (*p.get()).try_recv() } {\n+                        Ok(t) => return Data(t),\n+                        Err(sync::Empty) => return Empty,\n+                        Err(sync::Disconnected) => return Disconnected,\n+                    }\n+                }\n             };\n             unsafe {\n                 mem::swap(&mut cast::transmute_mut(self).inner,\n@@ -600,6 +769,7 @@ impl<T: Send> Receiver<T> {\n                         Err(shared::Disconnected) => return None,\n                     }\n                 }\n+                Sync(ref p) => return unsafe { (*p.get()).recv() }\n             };\n             unsafe {\n                 mem::swap(&mut cast::transmute_mut(self).inner,\n@@ -634,6 +804,9 @@ impl<T: Send> select::Packet for Receiver<T> {\n                 Shared(ref p) => {\n                     return unsafe { (*p.get()).can_recv() };\n                 }\n+                Sync(ref p) => {\n+                    return unsafe { (*p.get()).can_recv() };\n+                }\n             };\n             unsafe {\n                 mem::swap(&mut cast::transmute_mut(self).inner,\n@@ -662,6 +835,9 @@ impl<T: Send> select::Packet for Receiver<T> {\n                 Shared(ref p) => {\n                     return unsafe { (*p.get()).start_selection(task) };\n                 }\n+                Sync(ref p) => {\n+                    return unsafe { (*p.get()).start_selection(task) };\n+                }\n             };\n             task = t;\n             unsafe {\n@@ -682,6 +858,9 @@ impl<T: Send> select::Packet for Receiver<T> {\n                 Shared(ref p) => return unsafe {\n                     (*p.get()).abort_selection(was_upgrade)\n                 },\n+                Sync(ref p) => return unsafe {\n+                    (*p.get()).abort_selection()\n+                },\n             };\n             let mut new_port = match result { Ok(b) => return b, Err(p) => p };\n             was_upgrade = true;\n@@ -704,6 +883,7 @@ impl<T: Send> Drop for Receiver<T> {\n             Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },\n             Stream(ref mut p) => unsafe { (*p.get()).drop_port(); },\n             Shared(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Sync(ref mut p) => unsafe { (*p.get()).drop_port(); },\n         }\n     }\n }\n@@ -1243,3 +1423,517 @@ mod test {\n         pdone.recv();\n     })\n }\n+\n+#[cfg(test)]\n+mod sync_tests {\n+    use prelude::*;\n+    use os;\n+\n+    pub fn stress_factor() -> uint {\n+        match os::getenv(\"RUST_TEST_STRESS\") {\n+            Some(val) => from_str::<uint>(val).unwrap(),\n+            None => 1,\n+        }\n+    }\n+\n+    test!(fn smoke() {\n+        let (tx, rx) = sync_channel(1);\n+        tx.send(1);\n+        assert_eq!(rx.recv(), 1);\n+    })\n+\n+    test!(fn drop_full() {\n+        let (tx, _rx) = sync_channel(1);\n+        tx.send(~1);\n+    })\n+\n+    test!(fn smoke_shared() {\n+        let (tx, rx) = sync_channel(1);\n+        tx.send(1);\n+        assert_eq!(rx.recv(), 1);\n+        let tx = tx.clone();\n+        tx.send(1);\n+        assert_eq!(rx.recv(), 1);\n+    })\n+\n+    test!(fn smoke_threads() {\n+        let (tx, rx) = sync_channel(0);\n+        spawn(proc() {\n+            tx.send(1);\n+        });\n+        assert_eq!(rx.recv(), 1);\n+    })\n+\n+    test!(fn smoke_port_gone() {\n+        let (tx, rx) = sync_channel(0);\n+        drop(rx);\n+        tx.send(1);\n+    } #[should_fail])\n+\n+    test!(fn smoke_shared_port_gone2() {\n+        let (tx, rx) = sync_channel(0);\n+        drop(rx);\n+        let tx2 = tx.clone();\n+        drop(tx);\n+        tx2.send(1);\n+    } #[should_fail])\n+\n+    test!(fn port_gone_concurrent() {\n+        let (tx, rx) = sync_channel(0);\n+        spawn(proc() {\n+            rx.recv();\n+        });\n+        loop { tx.send(1) }\n+    } #[should_fail])\n+\n+    test!(fn port_gone_concurrent_shared() {\n+        let (tx, rx) = sync_channel(0);\n+        let tx2 = tx.clone();\n+        spawn(proc() {\n+            rx.recv();\n+        });\n+        loop {\n+            tx.send(1);\n+            tx2.send(1);\n+        }\n+    } #[should_fail])\n+\n+    test!(fn smoke_chan_gone() {\n+        let (tx, rx) = sync_channel::<int>(0);\n+        drop(tx);\n+        rx.recv();\n+    } #[should_fail])\n+\n+    test!(fn smoke_chan_gone_shared() {\n+        let (tx, rx) = sync_channel::<()>(0);\n+        let tx2 = tx.clone();\n+        drop(tx);\n+        drop(tx2);\n+        rx.recv();\n+    } #[should_fail])\n+\n+    test!(fn chan_gone_concurrent() {\n+        let (tx, rx) = sync_channel(0);\n+        spawn(proc() {\n+            tx.send(1);\n+            tx.send(1);\n+        });\n+        loop { rx.recv(); }\n+    } #[should_fail])\n+\n+    test!(fn stress() {\n+        let (tx, rx) = sync_channel(0);\n+        spawn(proc() {\n+            for _ in range(0, 10000) { tx.send(1); }\n+        });\n+        for _ in range(0, 10000) {\n+            assert_eq!(rx.recv(), 1);\n+        }\n+    })\n+\n+    test!(fn stress_shared() {\n+        static AMT: uint = 1000;\n+        static NTHREADS: uint = 8;\n+        let (tx, rx) = sync_channel::<int>(0);\n+        let (dtx, drx) = sync_channel::<()>(0);\n+\n+        spawn(proc() {\n+            for _ in range(0, AMT * NTHREADS) {\n+                assert_eq!(rx.recv(), 1);\n+            }\n+            match rx.try_recv() {\n+                Data(..) => fail!(),\n+                _ => {}\n+            }\n+            dtx.send(());\n+        });\n+\n+        for _ in range(0, NTHREADS) {\n+            let tx = tx.clone();\n+            spawn(proc() {\n+                for _ in range(0, AMT) { tx.send(1); }\n+            });\n+        }\n+        drop(tx);\n+        drx.recv();\n+    })\n+\n+    test!(fn oneshot_single_thread_close_port_first() {\n+        // Simple test of closing without sending\n+        let (_tx, rx) = sync_channel::<int>(0);\n+        drop(rx);\n+    })\n+\n+    test!(fn oneshot_single_thread_close_chan_first() {\n+        // Simple test of closing without sending\n+        let (tx, _rx) = sync_channel::<int>(0);\n+        drop(tx);\n+    })\n+\n+    test!(fn oneshot_single_thread_send_port_close() {\n+        // Testing that the sender cleans up the payload if receiver is closed\n+        let (tx, rx) = sync_channel::<~int>(0);\n+        drop(rx);\n+        tx.send(~0);\n+    } #[should_fail])\n+\n+    test!(fn oneshot_single_thread_recv_chan_close() {\n+        // Receiving on a closed chan will fail\n+        let res = task::try(proc() {\n+            let (tx, rx) = sync_channel::<int>(0);\n+            drop(tx);\n+            rx.recv();\n+        });\n+        // What is our res?\n+        assert!(res.is_err());\n+    })\n+\n+    test!(fn oneshot_single_thread_send_then_recv() {\n+        let (tx, rx) = sync_channel::<~int>(1);\n+        tx.send(~10);\n+        assert!(rx.recv() == ~10);\n+    })\n+\n+    test!(fn oneshot_single_thread_try_send_open() {\n+        let (tx, rx) = sync_channel::<int>(1);\n+        assert_eq!(tx.try_send(10), Sent);\n+        assert!(rx.recv() == 10);\n+    })\n+\n+    test!(fn oneshot_single_thread_try_send_closed() {\n+        let (tx, rx) = sync_channel::<int>(0);\n+        drop(rx);\n+        assert_eq!(tx.try_send(10), RecvDisconnected(10));\n+    })\n+\n+    test!(fn oneshot_single_thread_try_send_closed2() {\n+        let (tx, _rx) = sync_channel::<int>(0);\n+        assert_eq!(tx.try_send(10), Full(10));\n+    })\n+\n+    test!(fn oneshot_single_thread_try_recv_open() {\n+        let (tx, rx) = sync_channel::<int>(1);\n+        tx.send(10);\n+        assert!(rx.recv_opt() == Some(10));\n+    })\n+\n+    test!(fn oneshot_single_thread_try_recv_closed() {\n+        let (tx, rx) = sync_channel::<int>(0);\n+        drop(tx);\n+        assert!(rx.recv_opt() == None);\n+    })\n+\n+    test!(fn oneshot_single_thread_peek_data() {\n+        let (tx, rx) = sync_channel::<int>(1);\n+        assert_eq!(rx.try_recv(), Empty)\n+        tx.send(10);\n+        assert_eq!(rx.try_recv(), Data(10));\n+    })\n+\n+    test!(fn oneshot_single_thread_peek_close() {\n+        let (tx, rx) = sync_channel::<int>(0);\n+        drop(tx);\n+        assert_eq!(rx.try_recv(), Disconnected);\n+        assert_eq!(rx.try_recv(), Disconnected);\n+    })\n+\n+    test!(fn oneshot_single_thread_peek_open() {\n+        let (_tx, rx) = sync_channel::<int>(0);\n+        assert_eq!(rx.try_recv(), Empty);\n+    })\n+\n+    test!(fn oneshot_multi_task_recv_then_send() {\n+        let (tx, rx) = sync_channel::<~int>(0);\n+        spawn(proc() {\n+            assert!(rx.recv() == ~10);\n+        });\n+\n+        tx.send(~10);\n+    })\n+\n+    test!(fn oneshot_multi_task_recv_then_close() {\n+        let (tx, rx) = sync_channel::<~int>(0);\n+        spawn(proc() {\n+            drop(tx);\n+        });\n+        let res = task::try(proc() {\n+            assert!(rx.recv() == ~10);\n+        });\n+        assert!(res.is_err());\n+    })\n+\n+    test!(fn oneshot_multi_thread_close_stress() {\n+        for _ in range(0, stress_factor()) {\n+            let (tx, rx) = sync_channel::<int>(0);\n+            spawn(proc() {\n+                drop(rx);\n+            });\n+            drop(tx);\n+        }\n+    })\n+\n+    test!(fn oneshot_multi_thread_send_close_stress() {\n+        for _ in range(0, stress_factor()) {\n+            let (tx, rx) = sync_channel::<int>(0);\n+            spawn(proc() {\n+                drop(rx);\n+            });\n+            let _ = task::try(proc() {\n+                tx.send(1);\n+            });\n+        }\n+    })\n+\n+    test!(fn oneshot_multi_thread_recv_close_stress() {\n+        for _ in range(0, stress_factor()) {\n+            let (tx, rx) = sync_channel::<int>(0);\n+            spawn(proc() {\n+                let res = task::try(proc() {\n+                    rx.recv();\n+                });\n+                assert!(res.is_err());\n+            });\n+            spawn(proc() {\n+                spawn(proc() {\n+                    drop(tx);\n+                });\n+            });\n+        }\n+    })\n+\n+    test!(fn oneshot_multi_thread_send_recv_stress() {\n+        for _ in range(0, stress_factor()) {\n+            let (tx, rx) = sync_channel(0);\n+            spawn(proc() {\n+                tx.send(~10);\n+            });\n+            spawn(proc() {\n+                assert!(rx.recv() == ~10);\n+            });\n+        }\n+    })\n+\n+    test!(fn stream_send_recv_stress() {\n+        for _ in range(0, stress_factor()) {\n+            let (tx, rx) = sync_channel(0);\n+\n+            send(tx, 0);\n+            recv(rx, 0);\n+\n+            fn send(tx: SyncSender<~int>, i: int) {\n+                if i == 10 { return }\n+\n+                spawn(proc() {\n+                    tx.send(~i);\n+                    send(tx, i + 1);\n+                });\n+            }\n+\n+            fn recv(rx: Receiver<~int>, i: int) {\n+                if i == 10 { return }\n+\n+                spawn(proc() {\n+                    assert!(rx.recv() == ~i);\n+                    recv(rx, i + 1);\n+                });\n+            }\n+        }\n+    })\n+\n+    test!(fn recv_a_lot() {\n+        // Regression test that we don't run out of stack in scheduler context\n+        let (tx, rx) = sync_channel(10000);\n+        for _ in range(0, 10000) { tx.send(()); }\n+        for _ in range(0, 10000) { rx.recv(); }\n+    })\n+\n+    test!(fn shared_chan_stress() {\n+        let (tx, rx) = sync_channel(0);\n+        let total = stress_factor() + 100;\n+        for _ in range(0, total) {\n+            let tx = tx.clone();\n+            spawn(proc() {\n+                tx.send(());\n+            });\n+        }\n+\n+        for _ in range(0, total) {\n+            rx.recv();\n+        }\n+    })\n+\n+    test!(fn test_nested_recv_iter() {\n+        let (tx, rx) = sync_channel::<int>(0);\n+        let (total_tx, total_rx) = sync_channel::<int>(0);\n+\n+        spawn(proc() {\n+            let mut acc = 0;\n+            for x in rx.iter() {\n+                acc += x;\n+            }\n+            total_tx.send(acc);\n+        });\n+\n+        tx.send(3);\n+        tx.send(1);\n+        tx.send(2);\n+        drop(tx);\n+        assert_eq!(total_rx.recv(), 6);\n+    })\n+\n+    test!(fn test_recv_iter_break() {\n+        let (tx, rx) = sync_channel::<int>(0);\n+        let (count_tx, count_rx) = sync_channel(0);\n+\n+        spawn(proc() {\n+            let mut count = 0;\n+            for x in rx.iter() {\n+                if count >= 3 {\n+                    break;\n+                } else {\n+                    count += x;\n+                }\n+            }\n+            count_tx.send(count);\n+        });\n+\n+        tx.send(2);\n+        tx.send(2);\n+        tx.send(2);\n+        tx.try_send(2);\n+        drop(tx);\n+        assert_eq!(count_rx.recv(), 4);\n+    })\n+\n+    test!(fn try_recv_states() {\n+        let (tx1, rx1) = sync_channel::<int>(1);\n+        let (tx2, rx2) = sync_channel::<()>(1);\n+        let (tx3, rx3) = sync_channel::<()>(1);\n+        spawn(proc() {\n+            rx2.recv();\n+            tx1.send(1);\n+            tx3.send(());\n+            rx2.recv();\n+            drop(tx1);\n+            tx3.send(());\n+        });\n+\n+        assert_eq!(rx1.try_recv(), Empty);\n+        tx2.send(());\n+        rx3.recv();\n+        assert_eq!(rx1.try_recv(), Data(1));\n+        assert_eq!(rx1.try_recv(), Empty);\n+        tx2.send(());\n+        rx3.recv();\n+        assert_eq!(rx1.try_recv(), Disconnected);\n+    })\n+\n+    // This bug used to end up in a livelock inside of the Receiver destructor\n+    // because the internal state of the Shared packet was corrupted\n+    test!(fn destroy_upgraded_shared_port_when_sender_still_active() {\n+        let (tx, rx) = sync_channel(0);\n+        let (tx2, rx2) = sync_channel(0);\n+        spawn(proc() {\n+            rx.recv(); // wait on a oneshot\n+            drop(rx);  // destroy a shared\n+            tx2.send(());\n+        });\n+        // make sure the other task has gone to sleep\n+        for _ in range(0, 5000) { task::deschedule(); }\n+\n+        // upgrade to a shared chan and send a message\n+        let t = tx.clone();\n+        drop(tx);\n+        t.send(());\n+\n+        // wait for the child task to exit before we exit\n+        rx2.recv();\n+    })\n+\n+    test!(fn try_recvs_off_the_runtime() {\n+        use std::rt::thread::Thread;\n+\n+        let (tx, rx) = sync_channel(0);\n+        let (cdone, pdone) = channel();\n+        let t = Thread::start(proc() {\n+            let mut hits = 0;\n+            while hits < 10 {\n+                match rx.try_recv() {\n+                    Data(()) => { hits += 1; }\n+                    Empty => { Thread::yield_now(); }\n+                    Disconnected => return,\n+                }\n+            }\n+            cdone.send(());\n+        });\n+        for _ in range(0, 10) {\n+            tx.send(());\n+        }\n+        t.join();\n+        pdone.recv();\n+    })\n+\n+    test!(fn send_opt1() {\n+        let (tx, rx) = sync_channel(0);\n+        spawn(proc() { rx.recv(); });\n+        assert_eq!(tx.send_opt(1), None);\n+    })\n+\n+    test!(fn send_opt2() {\n+        let (tx, rx) = sync_channel(0);\n+        spawn(proc() { drop(rx); });\n+        assert_eq!(tx.send_opt(1), Some(1));\n+    })\n+\n+    test!(fn send_opt3() {\n+        let (tx, rx) = sync_channel(1);\n+        assert_eq!(tx.send_opt(1), None);\n+        spawn(proc() { drop(rx); });\n+        assert_eq!(tx.send_opt(1), Some(1));\n+    })\n+\n+    test!(fn send_opt4() {\n+        let (tx, rx) = sync_channel(0);\n+        let tx2 = tx.clone();\n+        let (done, donerx) = channel();\n+        let done2 = done.clone();\n+        spawn(proc() {\n+            assert_eq!(tx.send_opt(1), Some(1));\n+            done.send(());\n+        });\n+        spawn(proc() {\n+            assert_eq!(tx2.send_opt(2), Some(2));\n+            done2.send(());\n+        });\n+        drop(rx);\n+        donerx.recv();\n+        donerx.recv();\n+    })\n+\n+    test!(fn try_send1() {\n+        let (tx, _rx) = sync_channel(0);\n+        assert_eq!(tx.try_send(1), Full(1));\n+    })\n+\n+    test!(fn try_send2() {\n+        let (tx, _rx) = sync_channel(1);\n+        assert_eq!(tx.try_send(1), Sent);\n+        assert_eq!(tx.try_send(1), Full(1));\n+    })\n+\n+    test!(fn try_send3() {\n+        let (tx, rx) = sync_channel(1);\n+        assert_eq!(tx.try_send(1), Sent);\n+        drop(rx);\n+        assert_eq!(tx.try_send(1), RecvDisconnected(1));\n+    })\n+\n+    test!(fn try_send4() {\n+        let (tx, rx) = sync_channel(0);\n+        spawn(proc() {\n+            for _ in range(0, 1000) { task::deschedule(); }\n+            assert_eq!(tx.try_send(1), Sent);\n+        });\n+        assert_eq!(rx.recv(), 1);\n+    })\n+}"}, {"sha": "1b2e79e02b4187ebb1b97cef5f9c2dad19772e0b", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488", "patch": "@@ -648,4 +648,40 @@ mod test {\n         tx1.send(());\n         rx2.recv();\n     })\n+\n+    test!(fn sync1() {\n+        let (tx, rx) = sync_channel(1);\n+        tx.send(1);\n+        select! {\n+            n = rx.recv() => { assert_eq!(n, 1); }\n+        }\n+    })\n+\n+    test!(fn sync2() {\n+        let (tx, rx) = sync_channel(0);\n+        spawn(proc() {\n+            for _ in range(0, 100) { task::deschedule() }\n+            tx.send(1);\n+        });\n+        select! {\n+            n = rx.recv() => { assert_eq!(n, 1); }\n+        }\n+    })\n+\n+    test!(fn sync3() {\n+        let (tx1, rx1) = sync_channel(0);\n+        let (tx2, rx2) = channel();\n+        spawn(proc() { tx1.send(1); });\n+        spawn(proc() { tx2.send(2); });\n+        select! {\n+            n = rx1.recv() => {\n+                assert_eq!(n, 1);\n+                assert_eq!(rx2.recv(), 2);\n+            },\n+            n = rx2.recv() => {\n+                assert_eq!(n, 2);\n+                assert_eq!(rx1.recv(), 1);\n+            }\n+        }\n+    })\n }"}, {"sha": "b3591dad274b231de227fef8dda0d887ddaeb287", "filename": "src/libstd/comm/sync.rs", "status": "added", "additions": 485, "deletions": 0, "changes": 485, "blob_url": "https://github.com/rust-lang/rust/blob/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488", "patch": "@@ -0,0 +1,485 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Synchronous channels/ports\n+///\n+/// This channel implementation differs significantly from the asynchronous\n+/// implementations found next to it (oneshot/stream/share). This is an\n+/// implementation of a synchronous, bounded buffer channel.\n+///\n+/// Each channel is created with some amount of backing buffer, and sends will\n+/// *block* until buffer space becomes available. A buffer size of 0 is valid,\n+/// which means that every successful send is paired with a successful recv.\n+///\n+/// This flavor of channels defines a new `send_opt` method for channels which\n+/// is the method by which a message is sent but the task does not fail if it\n+/// cannot be delivered.\n+///\n+/// Another major difference is that send() will *always* return back the data\n+/// if it couldn't be sent. This is because it is deterministically known when\n+/// the data is received and when it is not received.\n+///\n+/// Implementation-wise, it can all be summed up with \"use a mutex plus some\n+/// logic\". The mutex used here is an OS native mutex, meaning that no user code\n+/// is run inside of the mutex (to prevent context switching). This\n+/// implementation shares almost all code for the buffered and unbuffered cases\n+/// of a synchronous channel. There are a few branches for the unbuffered case,\n+/// but they're mostly just relevant to blocking senders.\n+\n+use cast;\n+use container::Container;\n+use iter::Iterator;\n+use kinds::Send;\n+use mem;\n+use ops::Drop;\n+use option::{Some, None, Option};\n+use ptr::RawPtr;\n+use result::{Result, Ok, Err};\n+use rt::local::Local;\n+use rt::task::{Task, BlockedTask};\n+use sync::atomics;\n+use ty::Unsafe;\n+use unstable::mutex::{NativeMutex, LockGuard};\n+use vec::Vec;\n+\n+pub struct Packet<T> {\n+    /// Only field outside of the mutex. Just done for kicks, but mainly because\n+    /// the other shared channel already had the code implemented\n+    channels: atomics::AtomicUint,\n+\n+    /// The state field is protected by this mutex\n+    lock: NativeMutex,\n+    state: Unsafe<State<T>>,\n+}\n+\n+struct State<T> {\n+    disconnected: bool, // Is the channel disconnected yet?\n+    queue: Queue,       // queue of senders waiting to send data\n+    blocker: Blocker,   // currently blocked task on this channel\n+    buf: Buffer<T>,     // storage for buffered messages\n+    cap: uint,          // capacity of this channel\n+\n+    /// A curious flag used to indicate whether a sender failed or succeeded in\n+    /// blocking. This is used to transmit information back to the task that it\n+    /// must dequeue its message from the buffer because it was not received.\n+    /// This is only relevant in the 0-buffer case. This obviously cannot be\n+    /// safely constructed, but it's guaranteed to always have a valid pointer\n+    /// value.\n+    canceled: Option<&'static mut bool>,\n+}\n+\n+/// Possible flavors of tasks who can be blocked on this channel.\n+enum Blocker {\n+    BlockedSender(BlockedTask),\n+    BlockedReceiver(BlockedTask),\n+    NoneBlocked\n+}\n+\n+/// Simple queue for threading tasks together. Nodes are stack-allocated, so\n+/// this structure is not safe at all\n+struct Queue {\n+    head: *mut Node,\n+    tail: *mut Node,\n+}\n+\n+struct Node {\n+    task: Option<BlockedTask>,\n+    next: *mut Node,\n+}\n+\n+/// A simple ring-buffer\n+struct Buffer<T> {\n+    buf: Vec<Option<T>>,\n+    start: uint,\n+    size: uint,\n+}\n+\n+#[deriving(Show)]\n+pub enum Failure {\n+    Empty,\n+    Disconnected,\n+}\n+\n+/// Atomically blocks the current task, placing it into `slot`, unlocking `lock`\n+/// in the meantime. This re-locks the mutex upon returning.\n+fn wait(slot: &mut Blocker, f: fn(BlockedTask) -> Blocker,\n+        lock: &NativeMutex) {\n+    let me: ~Task = Local::take();\n+    me.deschedule(1, |task| {\n+        match mem::replace(slot, f(task)) {\n+            NoneBlocked => {}\n+            _ => unreachable!(),\n+        }\n+        unsafe { lock.unlock_noguard(); }\n+        Ok(())\n+    });\n+    unsafe { lock.lock_noguard(); }\n+}\n+\n+/// Wakes up a task, dropping the lock at the correct time\n+fn wakeup(task: BlockedTask, guard: LockGuard) {\n+    // We need to be careful to wake up the waiting task *outside* of the mutex\n+    // in case it incurs a context switch.\n+    mem::drop(guard);\n+    task.wake().map(|t| t.reawaken());\n+}\n+\n+impl<T: Send> Packet<T> {\n+    pub fn new(cap: uint) -> Packet<T> {\n+        Packet {\n+            channels: atomics::AtomicUint::new(1),\n+            lock: unsafe { NativeMutex::new() },\n+            state: Unsafe::new(State {\n+                disconnected: false,\n+                blocker: NoneBlocked,\n+                cap: cap,\n+                canceled: None,\n+                queue: Queue {\n+                    head: 0 as *mut Node,\n+                    tail: 0 as *mut Node,\n+                },\n+                buf: Buffer {\n+                    buf: Vec::from_fn(cap + if cap == 0 {1} else {0}, |_| None),\n+                    start: 0,\n+                    size: 0,\n+                },\n+            }),\n+        }\n+    }\n+\n+    // Locks this channel, returning a guard for the state and the mutable state\n+    // itself. Care should be taken to ensure that the state does not escape the\n+    // guard!\n+    //\n+    // Note that we're ok promoting an & reference to an &mut reference because\n+    // the lock ensures that we're the only ones in the world with a pointer to\n+    // the state.\n+    fn lock<'a>(&'a self) -> (LockGuard<'a>, &'a mut State<T>) {\n+        unsafe {\n+            let guard = self.lock.lock();\n+            (guard, &mut *self.state.get())\n+        }\n+    }\n+\n+    pub fn send(&self, t: T) -> Result<(), T> {\n+        let (guard, state) = self.lock();\n+\n+        // wait for a slot to become available, and enqueue the data\n+        while !state.disconnected && state.buf.size() == state.buf.cap() {\n+            state.queue.enqueue(&self.lock);\n+        }\n+        if state.disconnected { return Err(t) }\n+        state.buf.enqueue(t);\n+\n+        match mem::replace(&mut state.blocker, NoneBlocked) {\n+            // if our capacity is 0, then we need to wait for a receiver to be\n+            // available to take our data. After waiting, we check again to make\n+            // sure the port didn't go away in the meantime. If it did, we need\n+            // to hand back our data.\n+            NoneBlocked if state.cap == 0 => {\n+                let mut canceled = false;\n+                assert!(state.canceled.is_none());\n+                state.canceled = Some(unsafe { cast::transmute(&mut canceled) });\n+                wait(&mut state.blocker, BlockedSender, &self.lock);\n+                if canceled {Err(state.buf.dequeue())} else {Ok(())}\n+            }\n+\n+            // success, we buffered some data\n+            NoneBlocked => Ok(()),\n+\n+            // success, someone's about to receive our buffered data.\n+            BlockedReceiver(task) => { wakeup(task, guard); Ok(()) }\n+\n+            BlockedSender(..) => fail!(\"lolwut\"),\n+        }\n+    }\n+\n+    pub fn try_send(&self, t: T) -> super::TrySendResult<T> {\n+        let (guard, state) = self.lock();\n+        if state.disconnected {\n+            super::RecvDisconnected(t)\n+        } else if state.buf.size() == state.buf.cap() {\n+            super::Full(t)\n+        } else if state.cap == 0 {\n+            // With capacity 0, even though we have buffer space we can't\n+            // transfer the data unless there's a receiver waiting.\n+            match mem::replace(&mut state.blocker, NoneBlocked) {\n+                NoneBlocked => super::Full(t),\n+                BlockedSender(..) => unreachable!(),\n+                BlockedReceiver(task) => {\n+                    state.buf.enqueue(t);\n+                    wakeup(task, guard);\n+                    super::Sent\n+                }\n+            }\n+        } else {\n+            // If the buffer has some space and the capacity isn't 0, then we\n+            // just enqueue the data for later retrieval.\n+            assert!(state.buf.size() < state.buf.cap());\n+            state.buf.enqueue(t);\n+            super::Sent\n+        }\n+    }\n+\n+    // Receives a message from this channel\n+    //\n+    // When reading this, remember that there can only ever be one receiver at\n+    // time.\n+    pub fn recv(&self) -> Option<T> {\n+        let (guard, state) = self.lock();\n+\n+        // Wait for the buffer to have something in it. No need for a while loop\n+        // because we're the only receiver.\n+        let mut waited = false;\n+        if !state.disconnected && state.buf.size() == 0 {\n+            wait(&mut state.blocker, BlockedReceiver, &self.lock);\n+            waited = true;\n+        }\n+        if state.disconnected && state.buf.size() == 0 { return None }\n+\n+        // Pick up the data, wake up our neighbors, and carry on\n+        assert!(state.buf.size() > 0);\n+        let ret = state.buf.dequeue();\n+        self.wakeup_senders(waited, guard, state);\n+        return Some(ret);\n+    }\n+\n+    pub fn try_recv(&self) -> Result<T, Failure> {\n+        let (guard, state) = self.lock();\n+\n+        // Easy cases first\n+        if state.disconnected { return Err(Disconnected) }\n+        if state.buf.size() == 0 { return Err(Empty) }\n+\n+        // Be sure to wake up neighbors\n+        let ret = Ok(state.buf.dequeue());\n+        self.wakeup_senders(false, guard, state);\n+\n+        return ret;\n+    }\n+\n+    // Wake up pending senders after some data has been received\n+    //\n+    // * `waited` - flag if the receiver blocked to receive some data, or if it\n+    //              just picked up some data on the way out\n+    // * `guard` - the lock guard that is held over this channel's lock\n+    fn wakeup_senders(&self, waited: bool,\n+                      guard: LockGuard,\n+                      state: &mut State<T>) {\n+        let pending_sender1: Option<BlockedTask> = state.queue.dequeue();\n+\n+        // If this is a no-buffer channel (cap == 0), then if we didn't wait we\n+        // need to ACK the sender. If we waited, then the sender waking us up\n+        // was already the ACK.\n+        let pending_sender2 = if state.cap == 0 && !waited {\n+            match mem::replace(&mut state.blocker, NoneBlocked) {\n+                NoneBlocked => None,\n+                BlockedReceiver(..) => unreachable!(),\n+                BlockedSender(task) => {\n+                    state.canceled.take();\n+                    Some(task)\n+                }\n+            }\n+        } else {\n+            None\n+        };\n+        mem::drop((state, guard));\n+\n+        // only outside of the lock do we wake up the pending tasks\n+        pending_sender1.map(|t| t.wake().map(|t| t.reawaken()));\n+        pending_sender2.map(|t| t.wake().map(|t| t.reawaken()));\n+    }\n+\n+    // Prepares this shared packet for a channel clone, essentially just bumping\n+    // a refcount.\n+    pub fn clone_chan(&self) {\n+        self.channels.fetch_add(1, atomics::SeqCst);\n+    }\n+\n+    pub fn drop_chan(&self) {\n+        // Only flag the channel as disconnected if we're the last channel\n+        match self.channels.fetch_sub(1, atomics::SeqCst) {\n+            1 => {}\n+            _ => return\n+        }\n+\n+        // Not much to do other than wake up a receiver if one's there\n+        let (guard, state) = self.lock();\n+        if state.disconnected { return }\n+        state.disconnected = true;\n+        match mem::replace(&mut state.blocker, NoneBlocked) {\n+            NoneBlocked => {}\n+            BlockedSender(..) => unreachable!(),\n+            BlockedReceiver(task) => wakeup(task, guard),\n+        }\n+    }\n+\n+    pub fn drop_port(&self) {\n+        let (guard, state) = self.lock();\n+\n+        if state.disconnected { return }\n+        state.disconnected = true;\n+\n+        // If the capacity is 0, then the sender may want its data back after\n+        // we're disconnected. Otherwise it's now our responsibility to destroy\n+        // the buffered data. As with many other portions of this code, this\n+        // needs to be careful to destroy the data *outside* of the lock to\n+        // prevent deadlock.\n+        let _data = if state.cap != 0 {\n+            mem::replace(&mut state.buf.buf, Vec::new())\n+        } else {\n+            Vec::new()\n+        };\n+        let mut queue = mem::replace(&mut state.queue, Queue {\n+            head: 0 as *mut Node,\n+            tail: 0 as *mut Node,\n+        });\n+\n+        let waiter = match mem::replace(&mut state.blocker, NoneBlocked) {\n+            NoneBlocked => None,\n+            BlockedSender(task) => {\n+                *state.canceled.take_unwrap() = true;\n+                Some(task)\n+            }\n+            BlockedReceiver(..) => unreachable!(),\n+        };\n+        mem::drop((state, guard));\n+\n+        loop {\n+            match queue.dequeue() {\n+                Some(task) => { task.wake().map(|t| t.reawaken()); }\n+                None => break,\n+            }\n+        }\n+        waiter.map(|t| t.wake().map(|t| t.reawaken()));\n+    }\n+\n+    ////////////////////////////////////////////////////////////////////////////\n+    // select implementation\n+    ////////////////////////////////////////////////////////////////////////////\n+\n+    // If Ok, the value is whether this port has data, if Err, then the upgraded\n+    // port needs to be checked instead of this one.\n+    pub fn can_recv(&self) -> bool {\n+        let (_g, state) = self.lock();\n+        state.disconnected || state.buf.size() > 0\n+    }\n+\n+    // Attempts to start selection on this port. This can either succeed or fail\n+    // because there is data waiting.\n+    pub fn start_selection(&self, task: BlockedTask) -> Result<(), BlockedTask>{\n+        let (_g, state) = self.lock();\n+        if state.disconnected || state.buf.size() > 0 {\n+            Err(task)\n+        } else {\n+            match mem::replace(&mut state.blocker, BlockedReceiver(task)) {\n+                NoneBlocked => {}\n+                BlockedSender(..) => unreachable!(),\n+                BlockedReceiver(..) => unreachable!(),\n+            }\n+            Ok(())\n+        }\n+    }\n+\n+    // Remove a previous selecting task from this port. This ensures that the\n+    // blocked task will no longer be visible to any other threads.\n+    //\n+    // The return value indicates whether there's data on this port.\n+    pub fn abort_selection(&self) -> bool {\n+        let (_g, state) = self.lock();\n+        match mem::replace(&mut state.blocker, NoneBlocked) {\n+            NoneBlocked => true,\n+            BlockedSender(task) => {\n+                state.blocker = BlockedSender(task);\n+                true\n+            }\n+            BlockedReceiver(task) => { task.trash(); false }\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T: Send> Drop for Packet<T> {\n+    fn drop(&mut self) {\n+        assert_eq!(self.channels.load(atomics::SeqCst), 0);\n+        let (_g, state) = self.lock();\n+        assert!(state.queue.dequeue().is_none());\n+        assert!(state.canceled.is_none());\n+    }\n+}\n+\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Buffer, a simple ring buffer backed by Vec<T>\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl<T> Buffer<T> {\n+    fn enqueue(&mut self, t: T) {\n+        let pos = (self.start + self.size) % self.buf.len();\n+        self.size += 1;\n+        let prev = mem::replace(self.buf.get_mut(pos), Some(t));\n+        assert!(prev.is_none());\n+    }\n+\n+    fn dequeue(&mut self) -> T {\n+        let start = self.start;\n+        self.size -= 1;\n+        self.start = (self.start + 1) % self.buf.len();\n+        self.buf.get_mut(start).take_unwrap()\n+    }\n+\n+    fn size(&self) -> uint { self.size }\n+    fn cap(&self) -> uint { self.buf.len() }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Queue, a simple queue to enqueue tasks with (stack-allocated nodes)\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl Queue {\n+    fn enqueue(&mut self, lock: &NativeMutex) {\n+        let task: ~Task = Local::take();\n+        let mut node = Node {\n+            task: None,\n+            next: 0 as *mut Node,\n+        };\n+        task.deschedule(1, |task| {\n+            node.task = Some(task);\n+            if self.tail.is_null() {\n+                self.head = &mut node as *mut Node;\n+                self.tail = &mut node as *mut Node;\n+            } else {\n+                unsafe {\n+                    (*self.tail).next = &mut node as *mut Node;\n+                    self.tail = &mut node as *mut Node;\n+                }\n+            }\n+            unsafe { lock.unlock_noguard(); }\n+            Ok(())\n+        });\n+        unsafe { lock.lock_noguard(); }\n+        assert!(node.next.is_null());\n+    }\n+\n+    fn dequeue(&mut self) -> Option<BlockedTask> {\n+        if self.head.is_null() {\n+            return None\n+        }\n+        let node = self.head;\n+        self.head = unsafe { (*node).next };\n+        if self.head.is_null() {\n+            self.tail = 0 as *mut Node;\n+        }\n+        unsafe {\n+            (*node).next = 0 as *mut Node;\n+            Some((*node).task.take_unwrap())\n+        }\n+    }\n+}"}, {"sha": "e66aa8c004617ff12fad8363049cd8202259f434", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488", "patch": "@@ -1282,10 +1282,10 @@ mod test {\n     }\n \n     iotest!(fn binary_file() {\n-        use rand::{Rng, task_rng};\n+        use rand::{StdRng, Rng};\n \n         let mut bytes = [0, ..1024];\n-        task_rng().fill_bytes(bytes);\n+        StdRng::new().fill_bytes(bytes);\n \n         let tmpdir = tmpdir();\n "}, {"sha": "a42ee80b53a51959276599b4e1028f1c1d2392b7", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488", "patch": "@@ -62,7 +62,7 @@ pub use slice::{Vector, VectorVector, CloneableVector, ImmutableVector};\n pub use vec::Vec;\n \n // Reexported runtime types\n-pub use comm::{channel, Sender, Receiver};\n+pub use comm::{sync_channel, channel, SyncSender, Sender, Receiver};\n pub use task::spawn;\n \n // Reexported statics"}, {"sha": "328de69691436112b77edae3a67f5df3e28e2310", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488", "patch": "@@ -69,6 +69,7 @@ mod imp {\n     use iter::Iterator;\n     use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     use mem;\n+    #[cfg(not(test))] use ptr::RawPtr;\n \n     static mut global_args_ptr: uint = 0;\n     static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;"}, {"sha": "ededc69c5a15b58350b3b25b99ab829917469d87", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488", "patch": "@@ -433,8 +433,8 @@ mod test {\n \n     #[test]\n     fn rng() {\n-        use rand::{Rng, task_rng};\n-        let mut r = task_rng();\n+        use rand::{StdRng, Rng};\n+        let mut r = StdRng::new();\n         let _ = r.next_u32();\n     }\n "}, {"sha": "6f5ef067e891a4f8bd0e0ca3a4f37137e10a1492", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488", "patch": "@@ -580,9 +580,9 @@ mod test {\n     fn smoke_cond() {\n         static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n-            let mut guard = lock.lock();\n+            let guard = lock.lock();\n             let t = Thread::start(proc() {\n-                let mut guard = lock.lock();\n+                let guard = lock.lock();\n                 guard.signal();\n             });\n             guard.wait();"}, {"sha": "5809fca9682e6f920a94e5149d300a459d0d4835", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488", "patch": "@@ -1355,13 +1355,8 @@ impl<T> Drop for MoveItems<T> {\n \n #[cfg(test)]\n mod tests {\n-    use super::Vec;\n-    use iter::{Iterator, range, Extendable};\n-    use mem::{drop, size_of};\n-    use ops::Drop;\n-    use option::{Some, None};\n-    use container::Container;\n-    use slice::{Vector, MutableVector, ImmutableVector};\n+    use prelude::*;\n+    use mem::size_of;\n \n     #[test]\n     fn test_small_vec_struct() {"}, {"sha": "628f6459badf9bf2a0361592ac465274a5cc4500", "filename": "src/libsync/comm.rs", "status": "modified", "additions": 1, "deletions": 98, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibsync%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibsync%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm.rs?ref=1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488", "patch": "@@ -51,54 +51,9 @@ impl<S:Send,R:Send> DuplexStream<S, R> {\n     }\n }\n \n-/// An extension of `pipes::stream` that provides synchronous message sending.\n-pub struct SyncSender<S> { priv duplex_stream: DuplexStream<S, ()> }\n-/// An extension of `pipes::stream` that acknowledges each message received.\n-pub struct SyncReceiver<R> { priv duplex_stream: DuplexStream<(), R> }\n-\n-impl<S: Send> SyncSender<S> {\n-    pub fn send(&self, val: S) {\n-        assert!(self.try_send(val), \"SyncSender.send: receiving port closed\");\n-    }\n-\n-    /// Sends a message, or report if the receiver has closed the connection\n-    /// before receiving.\n-    pub fn try_send(&self, val: S) -> bool {\n-        self.duplex_stream.try_send(val) && self.duplex_stream.recv_opt().is_some()\n-    }\n-}\n-\n-impl<R: Send> SyncReceiver<R> {\n-    pub fn recv(&self) -> R {\n-        self.recv_opt().expect(\"SyncReceiver.recv: sending channel closed\")\n-    }\n-\n-    pub fn recv_opt(&self) -> Option<R> {\n-        self.duplex_stream.recv_opt().map(|val| {\n-            self.duplex_stream.try_send(());\n-            val\n-        })\n-    }\n-\n-    pub fn try_recv(&self) -> comm::TryRecvResult<R> {\n-        match self.duplex_stream.try_recv() {\n-            comm::Data(t) => { self.duplex_stream.try_send(()); comm::Data(t) }\n-            state => state,\n-        }\n-    }\n-}\n-\n-/// Creates a stream whose channel, upon sending a message, blocks until the\n-/// message is received.\n-pub fn rendezvous<T: Send>() -> (SyncReceiver<T>, SyncSender<T>) {\n-    let (chan_stream, port_stream) = duplex();\n-    (SyncReceiver { duplex_stream: port_stream },\n-     SyncSender { duplex_stream: chan_stream })\n-}\n-\n #[cfg(test)]\n mod test {\n-    use comm::{duplex, rendezvous};\n+    use comm::{duplex};\n \n \n     #[test]\n@@ -111,56 +66,4 @@ mod test {\n         assert!(left.recv() == 123);\n         assert!(right.recv() == ~\"abc\");\n     }\n-\n-    #[test]\n-    pub fn basic_rendezvous_test() {\n-        let (port, chan) = rendezvous();\n-\n-        spawn(proc() {\n-            chan.send(\"abc\");\n-        });\n-\n-        assert!(port.recv() == \"abc\");\n-    }\n-\n-    #[test]\n-    fn recv_a_lot() {\n-        // Rendezvous streams should be able to handle any number of messages being sent\n-        let (port, chan) = rendezvous();\n-        spawn(proc() {\n-            for _ in range(0, 10000) { chan.send(()); }\n-        });\n-        for _ in range(0, 10000) { port.recv(); }\n-    }\n-\n-    #[test]\n-    fn send_and_fail_and_try_recv() {\n-        let (port, chan) = rendezvous();\n-        spawn(proc() {\n-            chan.duplex_stream.send(()); // Can't access this field outside this module\n-            fail!()\n-        });\n-        port.recv()\n-    }\n-\n-    #[test]\n-    fn try_send_and_recv_then_fail_before_ack() {\n-        let (port, chan) = rendezvous();\n-        spawn(proc() {\n-            port.duplex_stream.recv();\n-            fail!()\n-        });\n-        chan.try_send(());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn send_and_recv_then_fail_before_ack() {\n-        let (port, chan) = rendezvous();\n-        spawn(proc() {\n-            port.duplex_stream.recv();\n-            fail!()\n-        });\n-        chan.send(());\n-    }\n }"}, {"sha": "4df644e3b23c12025e5958cd49468433c6783496", "filename": "src/libsync/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibsync%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488/src%2Flibsync%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flib.rs?ref=1e6e98c0c2bd6b736fc6bef9bc1fb8e34d24e488", "patch": "@@ -25,7 +25,7 @@\n #[cfg(test)]\n #[phase(syntax, link)] extern crate log;\n \n-pub use comm::{DuplexStream, SyncSender, SyncReceiver, rendezvous, duplex};\n+pub use comm::{DuplexStream, duplex};\n pub use task_pool::TaskPool;\n pub use future::Future;\n pub use arc::{Arc, Weak};"}]}