{"sha": "b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZjM3NTU0YmY5ZjJiNTVmYTZiYTZiYThlOGVhZjE4MjYzMDFiNGU=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-11T04:13:16Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-17T02:56:31Z"}, "message": "impl char", "tree": {"sha": "b1aa2ad44a4102c50b4c2e7b0c8d517e06bfb3b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1aa2ad44a4102c50b4c2e7b0c8d517e06bfb3b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e", "html_url": "https://github.com/rust-lang/rust/commit/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/comments", "author": null, "committer": null, "parents": [{"sha": "85707398809f8b56afc471f228bd4d0137ce0a32", "url": "https://api.github.com/repos/rust-lang/rust/commits/85707398809f8b56afc471f228bd4d0137ce0a32", "html_url": "https://github.com/rust-lang/rust/commit/85707398809f8b56afc471f228bd4d0137ce0a32"}], "stats": {"total": 382, "additions": 381, "deletions": 1}, "files": [{"sha": "dd23bcbaf81b95d928f52e1bcbcbad97dc49fbd8", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e", "patch": "@@ -166,7 +166,6 @@ mod prelude {\n \n     // from other crates.\n     pub use alloc::boxed::Box;\n-    pub use unicode::char::CharExt;\n \n     // from collections.\n     pub use borrow::IntoCow;"}, {"sha": "fa24e9fd5afc57184dd8b29e5922c6b58880db9d", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e", "patch": "@@ -16,7 +16,10 @@ use self::ExponentFormat::*;\n use self::SignificantDigits::*;\n use self::SignFormat::*;\n \n+#[cfg(stage0)]\n use char::{self, CharExt};\n+#[cfg(not(stage0))]\n+use char;\n use num::{self, Int, Float, ToPrimitive};\n use num::FpCategory as Fp;\n use ops::FnMut;"}, {"sha": "711faa98bd92e18bc502796b7051795860e4e44b", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e", "patch": "@@ -251,6 +251,7 @@ pub use self::FileMode::*;\n pub use self::FileAccess::*;\n pub use self::IoErrorKind::*;\n \n+#[cfg(stage0)]\n use char::CharExt;\n use default::Default;\n use error::Error;"}, {"sha": "1387d531001be9fedcbe682163fdaaba4879b458", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e", "patch": "@@ -15,6 +15,7 @@\n use self::PathPrefix::*;\n \n use ascii::AsciiExt;\n+#[cfg(stage0)]\n use char::CharExt;\n use clone::Clone;\n use cmp::{Ordering, Eq, Ord, PartialEq, PartialOrd};"}, {"sha": "29c779df4d275bdaaccca7173e02439439e1ce83", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e", "patch": "@@ -159,6 +159,7 @@ mod platform {\n     use core::prelude::*;\n     use ascii::*;\n \n+    #[cfg(stage0)]\n     use char::CharExt as UnicodeCharExt;\n     use super::{os_str_as_u8_slice, u8_slice_as_os_str, Prefix};\n     use ffi::OsStr;"}, {"sha": "b244f7858523116c8fabb852bc6c36182db4fa86", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e", "patch": "@@ -25,6 +25,7 @@\n // Reexported types and traits\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use boxed::Box;\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use char::CharExt;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "56bc0389b74658e698088076363cd94b45115b9c", "filename": "src/libunicode/char.rs", "status": "modified", "additions": 372, "deletions": 0, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibunicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibunicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fchar.rs?ref=b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e", "patch": "@@ -41,6 +41,7 @@ pub use normalize::{decompose_canonical, decompose_compatible, compose};\n pub use tables::normalization::canonical_combining_class;\n pub use tables::UNICODE_VERSION;\n \n+#[cfg(stage0)]\n /// Functionality for manipulating `char`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait CharExt {\n@@ -374,6 +375,7 @@ pub trait CharExt {\n     fn width(self, is_cjk: bool) -> Option<usize>;\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CharExt for char {\n     fn is_digit(self, radix: u32) -> bool { C::is_digit(self, radix) }\n@@ -467,3 +469,373 @@ impl Iterator for ToUppercase {\n     type Item = char;\n     fn next(&mut self) -> Option<char> { self.0.take() }\n }\n+\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[lang = \"char\"]\n+impl char {\n+    /// Checks if a `char` parses as a numeric digit in the given radix.\n+    ///\n+    /// Compared to `is_numeric()`, this function only recognizes the characters\n+    /// `0-9`, `a-z` and `A-Z`.\n+    ///\n+    /// # Return value\n+    ///\n+    /// Returns `true` if `c` is a valid digit under `radix`, and `false`\n+    /// otherwise.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if given a radix > 36.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let c = '1';\n+    ///\n+    /// assert!(c.is_digit(10));\n+    ///\n+    /// assert!('f'.is_digit(16));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_digit(self, radix: u32) -> bool { C::is_digit(self, radix) }\n+\n+    /// Converts a character to the corresponding digit.\n+    ///\n+    /// # Return value\n+    ///\n+    /// If `c` is between '0' and '9', the corresponding value between 0 and\n+    /// 9. If `c` is 'a' or 'A', 10. If `c` is 'b' or 'B', 11, etc. Returns\n+    /// none if the character does not refer to a digit in the given radix.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if given a radix outside the range [0..36].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let c = '1';\n+    ///\n+    /// assert_eq!(c.to_digit(10), Some(1));\n+    ///\n+    /// assert_eq!('f'.to_digit(16), Some(15));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn to_digit(self, radix: u32) -> Option<u32> { C::to_digit(self, radix) }\n+\n+    /// Returns an iterator that yields the hexadecimal Unicode escape of a\n+    /// character, as `char`s.\n+    ///\n+    /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n+    /// where `NNNN` is the shortest hexadecimal representation of the code\n+    /// point.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// for i in '\u2764'.escape_unicode() {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// \\\n+    /// u\n+    /// {\n+    /// 2\n+    /// 7\n+    /// 6\n+    /// 4\n+    /// }\n+    /// ```\n+    ///\n+    /// Collecting into a `String`:\n+    ///\n+    /// ```\n+    /// let heart: String = '\u2764'.escape_unicode().collect();\n+    ///\n+    /// assert_eq!(heart, r\"\\u{2764}\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn escape_unicode(self) -> EscapeUnicode { C::escape_unicode(self) }\n+\n+    /// Returns an iterator that yields the 'default' ASCII and\n+    /// C++11-like literal escape of a character, as `char`s.\n+    ///\n+    /// The default is chosen with a bias toward producing literals that are\n+    /// legal in a variety of languages, including C++11 and similar C-family\n+    /// languages. The exact rules are:\n+    ///\n+    /// * Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n+    /// * Single-quote, double-quote and backslash chars are backslash-\n+    ///   escaped.\n+    /// * Any other chars in the range [0x20,0x7e] are not escaped.\n+    /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// for i in '\"'.escape_default() {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// \\\n+    /// \"\n+    /// ```\n+    ///\n+    /// Collecting into a `String`:\n+    ///\n+    /// ```\n+    /// let quote: String = '\"'.escape_default().collect();\n+    ///\n+    /// assert_eq!(quote, \"\\\\\\\"\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn escape_default(self) -> EscapeDefault { C::escape_default(self) }\n+\n+    /// Returns the number of bytes this character would need if encoded in\n+    /// UTF-8.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let n = '\u00df'.len_utf8();\n+    ///\n+    /// assert_eq!(n, 2);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn len_utf8(self) -> usize { C::len_utf8(self) }\n+\n+    /// Returns the number of 16-bit code units this character would need if\n+    /// encoded in UTF-16.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let n = '\u00df'.len_utf16();\n+    ///\n+    /// assert_eq!(n, 1);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn len_utf16(self) -> usize { C::len_utf16(self) }\n+\n+    /// Encodes this character as UTF-8 into the provided byte buffer, and then\n+    /// returns the number of bytes written.\n+    ///\n+    /// If the buffer is not large enough, nothing will be written into it and a\n+    /// `None` will be returned. A buffer of length four is large enough to\n+    /// encode any `char`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// In both of these examples, '\u00df' takes two bytes to encode.\n+    ///\n+    /// ```\n+    /// let mut b = [0; 2];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, Some(2));\n+    /// ```\n+    ///\n+    /// A buffer that's too small:\n+    ///\n+    /// ```\n+    /// let mut b = [0; 1];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, None);\n+    /// ```\n+    #[unstable(feature = \"unicode\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n+    pub fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> { C::encode_utf8(self, dst) }\n+\n+    /// Encodes this character as UTF-16 into the provided `u16` buffer, and\n+    /// then returns the number of `u16`s written.\n+    ///\n+    /// If the buffer is not large enough, nothing will be written into it and a\n+    /// `None` will be returned. A buffer of length 2 is large enough to encode\n+    /// any `char`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// In both of these examples, '\u00df' takes one `u16` to encode.\n+    ///\n+    /// ```\n+    /// let mut b = [0; 1];\n+    ///\n+    /// let result = '\u00df'.encode_utf16(&mut b);\n+    ///\n+    /// assert_eq!(result, Some(1));\n+    /// ```\n+    ///\n+    /// A buffer that's too small:\n+    ///\n+    /// ```\n+    /// let mut b = [0; 0];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, None);\n+    /// ```\n+    #[unstable(feature = \"unicode\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n+    pub fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> { C::encode_utf16(self, dst) }\n+\n+    /// Returns whether the specified character is considered a Unicode\n+    /// alphabetic code point.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_alphabetic(self) -> bool {\n+        match self {\n+            'a' ... 'z' | 'A' ... 'Z' => true,\n+            c if c > '\\x7f' => derived_property::Alphabetic(c),\n+            _ => false\n+        }\n+    }\n+\n+    /// Returns whether the specified character satisfies the 'XID_Start'\n+    /// Unicode property.\n+    ///\n+    /// 'XID_Start' is a Unicode Derived Property specified in\n+    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n+    /// mostly similar to ID_Start but modified for closure under NFKx.\n+    #[unstable(feature = \"unicode\",\n+               reason = \"mainly needed for compiler internals\")]\n+    pub fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n+\n+    /// Returns whether the specified `char` satisfies the 'XID_Continue'\n+    /// Unicode property.\n+    ///\n+    /// 'XID_Continue' is a Unicode Derived Property specified in\n+    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n+    /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n+    #[unstable(feature = \"unicode\",\n+               reason = \"mainly needed for compiler internals\")]\n+    pub fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n+\n+    /// Indicates whether a character is in lowercase.\n+    ///\n+    /// This is defined according to the terms of the Unicode Derived Core\n+    /// Property `Lowercase`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_lowercase(self) -> bool {\n+        match self {\n+            'a' ... 'z' => true,\n+            c if c > '\\x7f' => derived_property::Lowercase(c),\n+            _ => false\n+        }\n+    }\n+\n+    /// Indicates whether a character is in uppercase.\n+    ///\n+    /// This is defined according to the terms of the Unicode Derived Core\n+    /// Property `Uppercase`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_uppercase(self) -> bool {\n+        match self {\n+            'A' ... 'Z' => true,\n+            c if c > '\\x7f' => derived_property::Uppercase(c),\n+            _ => false\n+        }\n+    }\n+\n+    /// Indicates whether a character is whitespace.\n+    ///\n+    /// Whitespace is defined in terms of the Unicode Property `White_Space`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_whitespace(self) -> bool {\n+        match self {\n+            ' ' | '\\x09' ... '\\x0d' => true,\n+            c if c > '\\x7f' => property::White_Space(c),\n+            _ => false\n+        }\n+    }\n+\n+    /// Indicates whether a character is alphanumeric.\n+    ///\n+    /// Alphanumericness is defined in terms of the Unicode General Categories\n+    /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_alphanumeric(self) -> bool {\n+        self.is_alphabetic() || self.is_numeric()\n+    }\n+\n+    /// Indicates whether a character is a control code point.\n+    ///\n+    /// Control code points are defined in terms of the Unicode General\n+    /// Category `Cc`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_control(self) -> bool { general_category::Cc(self) }\n+\n+    /// Indicates whether the character is numeric (Nd, Nl, or No).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_numeric(self) -> bool {\n+        match self {\n+            '0' ... '9' => true,\n+            c if c > '\\x7f' => general_category::N(c),\n+            _ => false\n+        }\n+    }\n+\n+    /// Converts a character to its lowercase equivalent.\n+    ///\n+    /// The case-folding performed is the common or simple mapping. See\n+    /// `to_uppercase()` for references and more information.\n+    ///\n+    /// # Return value\n+    ///\n+    /// Returns an iterator which yields the characters corresponding to the\n+    /// lowercase equivalent of the character. If no conversion is possible then\n+    /// the input character is returned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn to_lowercase(self) -> ToLowercase {\n+        ToLowercase(Some(conversions::to_lower(self)))\n+    }\n+\n+    /// Converts a character to its uppercase equivalent.\n+    ///\n+    /// The case-folding performed is the common or simple mapping: it maps\n+    /// one Unicode codepoint to its uppercase equivalent according to the\n+    /// Unicode database [1]. The additional [`SpecialCasing.txt`] is not yet\n+    /// considered here, but the iterator returned will soon support this form\n+    /// of case folding.\n+    ///\n+    /// A full reference can be found here [2].\n+    ///\n+    /// # Return value\n+    ///\n+    /// Returns an iterator which yields the characters corresponding to the\n+    /// uppercase equivalent of the character. If no conversion is possible then\n+    /// the input character is returned.\n+    ///\n+    /// [1]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+    ///\n+    /// [`SpecialCasing`.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n+    ///\n+    /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn to_uppercase(self) -> ToUppercase {\n+        ToUppercase(Some(conversions::to_upper(self)))\n+    }\n+\n+    /// Returns this character's displayed width in columns, or `None` if it is a\n+    /// control character other than `'\\x00'`.\n+    ///\n+    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n+    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n+    /// In CJK contexts, `is_cjk` should be `true`, else it should be `false`.\n+    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n+    /// recommends that these characters be treated as 1 column (i.e.,\n+    /// `is_cjk` = `false`) if the context cannot be reliably determined.\n+    #[unstable(feature = \"unicode\",\n+               reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n+    pub fn width(self, is_cjk: bool) -> Option<usize> { charwidth::width(self, is_cjk) }\n+}"}, {"sha": "a09c0cb3bd6306a6d3ce68f4530b26cdda8cfae9", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e", "patch": "@@ -24,6 +24,7 @@\n #![cfg_attr(stage0, feature(custom_attribute))]\n #![crate_name = \"unicode\"]\n #![unstable(feature = \"unicode\")]\n+#![feature(lang_items)]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]"}, {"sha": "6a80f3bc2c189a215a917df662e24247238f6e23", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e", "patch": "@@ -26,6 +26,7 @@ use core::num::Int;\n use core::slice;\n use core::str::Split;\n \n+#[cfg(stage0)]\n use char::CharExt as UCharExt; // conflicts with core::prelude::CharExt\n use tables::grapheme::GraphemeCat;\n "}]}