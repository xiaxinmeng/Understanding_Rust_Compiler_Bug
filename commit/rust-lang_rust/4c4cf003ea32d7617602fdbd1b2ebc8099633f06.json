{"sha": "4c4cf003ea32d7617602fdbd1b2ebc8099633f06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjNGNmMDAzZWEzMmQ3NjE3NjAyZmRiZDFiMmViYzgwOTk2MzNmMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-26T09:04:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-26T09:04:50Z"}, "message": "auto merge of #8031 : graydon/rust/emacs-mode-rewrite, r=catamorphism\n\nThe previous mode did a lot of very manual char-at-a-time parsing and was quite fragile and difficult to maintain. I talked to Marijn and he suggested I'd have better luck just rewriting it from scratch. This is the result of that effort; it seems to be faster, a bit easier on the eyes and more-or-less as well behaved when indenting. The algorithm is a bit different I suspect (it was hard to tell the previous one) but I tried to keep it simple and pleasant-looking.", "tree": {"sha": "79bf7ac8a64d327fa74bbfd1573a50236197098b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79bf7ac8a64d327fa74bbfd1573a50236197098b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c4cf003ea32d7617602fdbd1b2ebc8099633f06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c4cf003ea32d7617602fdbd1b2ebc8099633f06", "html_url": "https://github.com/rust-lang/rust/commit/4c4cf003ea32d7617602fdbd1b2ebc8099633f06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c4cf003ea32d7617602fdbd1b2ebc8099633f06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5109ce691c5b8cc6c4ef189bec33e9131e2899bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5109ce691c5b8cc6c4ef189bec33e9131e2899bf", "html_url": "https://github.com/rust-lang/rust/commit/5109ce691c5b8cc6c4ef189bec33e9131e2899bf"}, {"sha": "581b3db3b3f6a932f3a1d99167b3b1910f76beb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/581b3db3b3f6a932f3a1d99167b3b1910f76beb1", "html_url": "https://github.com/rust-lang/rust/commit/581b3db3b3f6a932f3a1d99167b3b1910f76beb1"}], "stats": {"total": 766, "additions": 209, "deletions": 557}, "files": [{"sha": "c79e7a9719bdc697324d7252d91838259ff6df95", "filename": "src/etc/emacs/Makefile", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5109ce691c5b8cc6c4ef189bec33e9131e2899bf/src%2Fetc%2Femacs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/5109ce691c5b8cc6c4ef189bec33e9131e2899bf/src%2Fetc%2Femacs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2FMakefile?ref=5109ce691c5b8cc6c4ef189bec33e9131e2899bf", "patch": "@@ -1,14 +0,0 @@\n-E=@echo\n-TEMP=temp.el\n-\n-EMACS ?= emacs\n-\n-all: $(TEMP)\n-\t$(EMACS) -batch -q -no-site-file -l ./$(TEMP) -f rustmode-compile\n-\trm -f $(TEMP)\n-$(TEMP):\n-\t$(E) '(setq load-path (cons \".\" load-path))' >> $(TEMP)\n-\t$(E) '(defun rustmode-compile () (mapcar (lambda (x) (byte-compile-file x))' >> $(TEMP)\n-\t$(E) ' (list \"cm-mode.el\" \"rust-mode.el\")))' >> $(TEMP)\n-clean:\n-\trm -f *.elc $(TEMP)"}, {"sha": "508ac7f1af27fc1eb98ced2f2004dd192485302a", "filename": "src/etc/emacs/README.md", "status": "modified", "additions": 2, "deletions": 33, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4c4cf003ea32d7617602fdbd1b2ebc8099633f06/src%2Fetc%2Femacs%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4c4cf003ea32d7617602fdbd1b2ebc8099633f06/src%2Fetc%2Femacs%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2FREADME.md?ref=4c4cf003ea32d7617602fdbd1b2ebc8099633f06", "patch": "@@ -13,21 +13,8 @@ file:\n     (add-to-list 'load-path \"/path/to/rust-mode/\")\n     (require 'rust-mode)\n \n-Make sure you byte-compile the .el files first, or the mode will be\n-painfully slow. There is an included `Makefile` which will do it for\n-you, so in the simplest case you can just run `make` and everything\n-should Just Work.\n-\n-If for some reason that doesn't work, you can byte compile manually,\n-by pasting this in your `*scratch*` buffer, moving the cursor below\n-it, and pressing `C-j`:\n-\n-    (progn\n-      (byte-compile-file \"/path/to/rust-mode/cm-mode.el\" t)\n-      (byte-compile-file \"/path/to/rust-mode/rust-mode.el\" t))\n-\n-Rust mode will automatically be associated with .rs and .rc files. To\n-enable it explicitly, do `M-x rust-mode`.\n+Rust mode will automatically be associated with .rs files. To enable it\n+explicitly, do `M-x rust-mode`.\n \n ### package.el installation via Marmalade or MELPA\n \n@@ -67,24 +54,6 @@ should upgrade in order to support installation from multiple sources.\n The ELPA archive is deprecated and no longer accepting new packages,\n so the version there (1.7.1) is very outdated.\n \n-#### Important\n-\n-In order to have cm-mode properly initialized after compilation prior\n-to rust-mode.el compilation you will need to add these `advices` to\n-your init file or if you are a melpa user install the `melpa` package.\n-\n-```lisp\n-(defadvice package-download-tar\n-  (after package-download-tar-initialize activate compile)\n-  \"initialize the package after compilation\"\n-  (package-initialize))\n-\n-(defadvice package-download-single\n-  (after package-download-single-initialize activate compile)\n-  \"initialize the package after compilation\"\n-  (package-initialize))\n-```\n-\n #### Install rust-mode\n \n From there you can install rust-mode or any other modes by choosing"}, {"sha": "0303f994172cb617b72410fa7239c8ab1c67b5bb", "filename": "src/etc/emacs/cm-mode.el", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/5109ce691c5b8cc6c4ef189bec33e9131e2899bf/src%2Fetc%2Femacs%2Fcm-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/5109ce691c5b8cc6c4ef189bec33e9131e2899bf/src%2Fetc%2Femacs%2Fcm-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Fcm-mode.el?ref=5109ce691c5b8cc6c4ef189bec33e9131e2899bf", "patch": "@@ -1,194 +0,0 @@\n-;;; cm-mode.el --- Wrapper for CodeMirror-style Emacs modes\n-\n-;; Version: 0.1.0\n-;; Author: Mozilla\n-;; Url: https://github.com/mozilla/rust\n-;; Highlighting is done by running a stateful parser (with first-class\n-;; state object) over the buffer, line by line, using the output to\n-;; add 'face properties, and storing the parser state at the end of\n-;; each line. Indentation is done based on the parser state at the\n-;; start of the line.\n-\n-(eval-when-compile (require 'cl))\n-\n-;; Mode data structure\n-\n-(defun make-cm-mode (token &optional start-state copy-state\n-                           compare-state indent)\n-  (vector token\n-          (or start-state (lambda () 'null))\n-          (or copy-state 'cm-default-copy-state)\n-          (or compare-state 'eq)\n-          indent))\n-(defmacro cm-mode-token (x) `(aref ,x 0))\n-(defmacro cm-mode-start-state (x) `(aref ,x 1))\n-(defmacro cm-mode-copy-state (x) `(aref ,x 2))\n-(defmacro cm-mode-compare-state (x) `(aref ,x 3))\n-(defmacro cm-mode-indent (x) `(aref ,x 4))\n-\n-(defvar cm-cur-mode nil)\n-(defvar cm-worklist nil)\n-\n-(defun cm-default-copy-state (state)\n-  (if (consp state) (copy-sequence state) state))\n-\n-(defun cm-clear-work-items (from to)\n-  (let ((prev-cons nil)\n-        (rem cm-worklist))\n-    (while rem\n-      (let ((pos (marker-position (car rem))))\n-        (cond ((or (< pos from) (> pos to)) (setf prev-cons rem))\n-              (prev-cons (setf (cdr prev-cons) (cdr rem)))\n-              (t (setf cm-worklist (cdr rem))))\n-        (setf rem (cdr rem))))))\n-\n-(defun cm-min-worklist-item ()\n-  (let ((rest cm-worklist) (min most-positive-fixnum))\n-    (while rest\n-      (let ((pos (marker-position (car rest))))\n-        (when (< pos min) (setf min pos)))\n-      (setf rest (cdr rest)))\n-    min))\n-\n-;; Indentation\n-\n-(defun cm-indent ()\n-  (let (indent-pos)\n-    (save-excursion\n-      (beginning-of-line)\n-      (let* ((buf (current-buffer))\n-             (state (cm-preserve-state buf 'cm-state-for-point))\n-             (old-indent (current-indentation)))\n-        (back-to-indentation)\n-        (setf indent-pos (point))\n-        (let ((new-indent (funcall (cm-mode-indent cm-cur-mode) state)))\n-          (unless (= old-indent new-indent)\n-            (indent-line-to new-indent)\n-            (setf indent-pos (point))\n-            (beginning-of-line)\n-            (cm-preserve-state buf\n-             (lambda ()\n-               (cm-highlight-line state)\n-               (when (< (point) (point-max))\n-                 (put-text-property (point) (+ (point) 1) 'cm-parse-state state))))))))\n-    (when (< (point) indent-pos)\n-      (goto-char indent-pos))))\n-\n-(defun cm-backtrack-to-state ()\n-  (let ((backtracked 0)\n-        (min-indent most-positive-fixnum)\n-        min-indented)\n-    (loop\n-     (when (= (point) (point-min))\n-       (return (funcall (cm-mode-start-state cm-cur-mode))))\n-     (let ((st (get-text-property (- (point) 1) 'cm-parse-state)))\n-       (when (and st (save-excursion\n-                       (backward-char)\n-                       (beginning-of-line)\n-                       (not (looking-at \"[\t ]*$\"))))\n-         (return (funcall (cm-mode-copy-state cm-cur-mode) st))))\n-     (let ((i (current-indentation)))\n-       (when (< i min-indent)\n-         (setf min-indent i min-indented (point))))\n-     (when (> (incf backtracked) 30)\n-       (goto-char min-indented)\n-       (return (funcall (cm-mode-start-state cm-cur-mode))))\n-     (forward-line -1))))\n-\n-(defun cm-state-for-point ()\n-  (let ((pos (point))\n-        (state (cm-backtrack-to-state)))\n-    (while (< (point) pos)\n-      (cm-highlight-line state)\n-      (put-text-property (point) (+ (point) 1) 'cm-parse-state\n-                         (funcall (cm-mode-copy-state cm-cur-mode) state))\n-      (forward-char))\n-    state))\n-\n-;; Highlighting\n-\n-(defun cm-highlight-line (state)\n-  (let ((eol (point-at-eol)))\n-    (remove-text-properties (point) eol '(face))\n-    (loop\n-     (let ((p (point)))\n-       (when (= p eol) (return))\n-       (let ((style (funcall (cm-mode-token cm-cur-mode) state)))\n-         (when (= p (point)) (print (point)) (error \"Nothing consumed.\"))\n-         (when (> p eol) (error \"Parser moved past EOL\"))\n-         (when style\n-           (put-text-property p (point) 'face style)))))))\n-\n-(defun cm-find-state-before-point ()\n-  (loop\n-   (beginning-of-line)\n-   (when (= (point) 1)\n-     (return (funcall (cm-mode-start-state cm-cur-mode))))\n-   (let ((cur (get-text-property (- (point) 1) 'cm-parse-state)))\n-     (when cur (return (funcall (cm-mode-copy-state cm-cur-mode) cur))))\n-   (backward-char)))\n-\n-(defun cm-schedule-work (delay)\n-  (run-with-idle-timer delay nil 'cm-preserve-state (current-buffer) 'cm-do-some-work))\n-\n-(defun cm-preserve-state (buffer f &rest args)\n-  (with-current-buffer buffer\n-    (let ((modified (buffer-modified-p))\n-          (buffer-undo-list t)\n-          (inhibit-read-only t)\n-          (inhibit-point-motion-hooks t)\n-          (inhibit-modification-hooks t))\n-      (unwind-protect (apply f args)\n-        (unless modified\n-          (restore-buffer-modified-p nil))))))\n-\n-(defun cm-do-some-work-inner ()\n-  (let ((end-time (time-add (current-time) (list 0 0 500)))\n-        (quitting nil))\n-    (while (and (not quitting) cm-worklist)\n-      (goto-char (cm-min-worklist-item))\n-      (let ((state (cm-find-state-before-point))\n-            (startpos (point))\n-            (timer-idle-list nil))\n-        (loop\n-         (cm-highlight-line state)\n-         (when (= (point) (point-max)) (return))\n-         (let ((old (get-text-property (point) 'cm-parse-state)))\n-           (when (and old (funcall (cm-mode-compare-state cm-cur-mode) state old))\n-             (return))\n-           (put-text-property (point) (+ (point) 1) 'cm-parse-state\n-                              (funcall (cm-mode-copy-state cm-cur-mode) state)))\n-         (when (or (let ((timer-idle-list nil)) (input-pending-p))\n-                   (time-less-p end-time (current-time)))\n-           (setf quitting t) (return))\n-         (forward-char))\n-        (cm-clear-work-items startpos (point)))\n-      (when quitting\n-        (push (copy-marker (+ (point) 1)) cm-worklist)\n-        (cm-schedule-work 0.05)))))\n-\n-(defun cm-do-some-work ()\n-  (save-excursion\n-    (condition-case cnd (cm-do-some-work-inner)\n-      (error (print cnd) (error cnd)))))\n-\n-(defun cm-after-change-function (from to oldlen)\n-  (cm-preserve-state (current-buffer) 'remove-text-properties from to '(cm-parse-state))\n-  (push (copy-marker from) cm-worklist)\n-  (cm-schedule-work 0.2))\n-\n-;; Entry function\n-\n-;;;###autoload\n-(defun cm-mode (mode)\n-  (set (make-local-variable 'cm-cur-mode) mode)\n-  (set (make-local-variable 'cm-worklist) (list (copy-marker 1)))\n-  (when (cm-mode-indent mode)\n-    (set (make-local-variable 'indent-line-function) 'cm-indent))\n-  (add-hook 'after-change-functions 'cm-after-change-function t t)\n-  (add-hook 'after-revert-hook (lambda () (cm-after-change-function 1 (point-max) nil)) t t)\n-  (cm-schedule-work 0.05))\n-\n-(provide 'cm-mode)\n-\n-;;; cm-mode.el ends here"}, {"sha": "106cdbfd5f426b55ef99307ea8bf5b4cd0dd84ff", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 207, "deletions": 316, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/4c4cf003ea32d7617602fdbd1b2ebc8099633f06/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/4c4cf003ea32d7617602fdbd1b2ebc8099633f06/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=4c4cf003ea32d7617602fdbd1b2ebc8099633f06", "patch": "@@ -1,331 +1,222 @@\n ;;; rust-mode.el --- A major emacs mode for editing Rust source code\n \n-;; Version: 0.1.0\n+;; Version: 0.2.0\n ;; Author: Mozilla\n-;; Package-Requires: ((cm-mode \"0.1.0\"))\n ;; Url: https://github.com/mozilla/rust\n \n-(require 'cm-mode)\n-(require 'cc-mode)\n (eval-when-compile (require 'cl))\n \n-(defun rust-electric-brace (arg)\n-  (interactive \"*P\")\n-  (self-insert-command (prefix-numeric-value arg))\n-  (when (and c-electric-flag\n-             (not (member (get-text-property (point) 'face)\n-                          '(font-lock-comment-face font-lock-string-face))))\n-    (cm-indent)))\n-\n-(defcustom rust-capitalized-idents-are-types t\n-  \"If non-nil, capitalized identifiers will be treated as types for the purposes of font-lock mode\"\n-  :type 'boolean\n-  :require 'rust-mode\n-  :group 'rust-mode)\n-\n-(defcustom rust-indent-unit 4\n-  \"Amount of offset per level of indentation\"\n-  :type 'integer\n-  :require 'rust-mode\n-  :group 'rust-mode)\n-\n-(defvar rust-syntax-table (let ((table (make-syntax-table)))\n-                            (c-populate-syntax-table table)\n-                            table))\n-\n-(defun make-rust-state ()\n-  (vector 'rust-token-base\n-          (list (vector 'top (- rust-indent-unit) nil nil nil))\n-          0\n-          nil))\n-(defmacro rust-state-tokenize (x) `(aref ,x 0))\n-(defmacro rust-state-context (x) `(aref ,x 1))\n-(defmacro rust-state-indent (x) `(aref ,x 2))\n-(defmacro rust-state-last-token (x) `(aref ,x 3))\n-\n-(defmacro rust-context-type (x) `(aref ,x 0))\n-(defmacro rust-context-indent (x) `(aref ,x 1))\n-(defmacro rust-context-column (x) `(aref ,x 2))\n-(defmacro rust-context-align (x) `(aref ,x 3))\n-(defmacro rust-context-info (x) `(aref ,x 4))\n-\n-(defun rust-push-context (st type &optional align-column auto-align)\n-  (let ((ctx (vector type (rust-state-indent st) align-column\n-                     (if align-column (if auto-align t 'unset) nil) nil)))\n-    (push ctx (rust-state-context st))\n-    ctx))\n-(defun rust-pop-context (st)\n-  (let ((old (pop (rust-state-context st))))\n-    (setf (rust-state-indent st) (rust-context-indent old))\n-    old))\n-(defun rust-dup-context (st)\n-  (let* ((list (rust-state-context st))\n-         (dup (copy-sequence (car list))))\n-    (setf (rust-state-context st) (cons dup (cdr list)))\n-    dup))\n-\n-(defvar rust-operator-chars \"-+/%=<>!*&|@~^\")\n-(defvar rust-punc-chars \"()[].,{}:;\")\n-(defvar rust-value-keywords\n-  (let ((table (make-hash-table :test 'equal)))\n-    (dolist (word '(\"mod\" \"const\" \"class\" \"type\"\n-                    \"trait\" \"struct\" \"fn\" \"enum\"\n-                    \"impl\"))\n-      (puthash word 'def table))\n-    (dolist (word '(\"as\" \"break\"\n-                    \"copy\" \"do\" \"drop\" \"else\"\n-                    \"extern\" \"for\" \"if\" \"let\" \"log\"\n-                    \"loop\" \"once\" \"priv\" \"pub\" \"pure\"\n-                    \"ref\" \"return\" \"static\" \"unsafe\" \"use\"\n-                    \"while\" \"while\"\n-                    \"assert\"\n-                    \"mut\"))\n-      (puthash word t table))\n-    (puthash \"match\" 'alt table)\n-    (dolist (word '(\"self\" \"true\" \"false\")) (puthash word 'atom table))\n+;; Syntax definitions and helpers\n+(defvar rust-mode-syntax-table\n+  (let ((table (make-syntax-table)))\n+\n+    ;; Operators\n+    (loop for i in '(?+ ?- ?* ?/ ?& ?| ?^ ?! ?< ?> ?~ ?@)\n+          do (modify-syntax-entry i \".\" table))\n+\n+    ;; Strings\n+    (modify-syntax-entry ?\\\" \"\\\"\" table)\n+    (modify-syntax-entry ?\\\\ \"\\\\\" table)\n+\n+    ;; _ is a word-char\n+    (modify-syntax-entry ?_ \"w\" table)\n+\n+    ;; Comments\n+    (modify-syntax-entry ?/  \". 124b\" table)\n+    (modify-syntax-entry ?*  \". 23\"   table)\n+    (modify-syntax-entry ?\\n \"> b\"    table)\n+    (modify-syntax-entry ?\\^m \"> b\"   table)\n+\n     table))\n-;; FIXME type-context keywords\n-\n-(defvar rust-tcat nil \"Kludge for multiple returns without consing\")\n-\n-(defmacro rust-eat-re (re)\n-  `(when (looking-at ,re) (goto-char (match-end 0)) t))\n-\n-(defvar rust-char-table\n-  (let ((table (make-char-table 'syntax-table)))\n-    (macrolet ((def (range &rest body)\n-                    `(let ((--b (lambda (st) ,@body)))\n-                       ,@(mapcar (lambda (elt)\n-\t                           (if (consp elt)\n-                                       `(loop for ch from ,(car elt) to ,(cdr elt) collect\n-                                              (set-char-table-range table ch --b))\n-                                     `(set-char-table-range table ',elt --b)))\n-                                 (if (consp range) range (list range))))))\n-      (def t (forward-char) nil)\n-      (def (32 ?\\t) (skip-chars-forward \" \\t\") nil)\n-      (def ?\\\" (forward-char)\n-           (rust-push-context st 'string (current-column) t)\n-           (setf (rust-state-tokenize st) 'rust-token-string)\n-           (rust-token-string st))\n-      (def ?\\' (rust-single-quote))\n-      (def ?/ (forward-char)\n-           (case (char-after)\n-             (?/ (end-of-line) 'font-lock-comment-face)\n-             (?* (forward-char)\n-                 (rust-push-context st 'comment)\n-                 (setf (rust-state-tokenize st) 'rust-token-comment)\n-                 (rust-token-comment st))\n-             (t (skip-chars-forward rust-operator-chars) (setf rust-tcat 'op) nil)))\n-      (def ?# (forward-char)\n-           (cond ((eq (char-after) ?\\[) (forward-char) (setf rust-tcat 'open-attr))\n-                 ((rust-eat-re \"[a-z_]+\") (setf rust-tcat 'macro)))\n-           'font-lock-preprocessor-face)\n-      (def ((?a . ?z) (?A . ?Z) ?_)\n-           (rust-token-identifier))\n-      (def ((?0 . ?9))\n-           (rust-eat-re \"0x[0-9a-fA-F_]+\\\\|0b[01_]+\\\\|[0-9_]+\\\\(\\\\.[0-9_]+\\\\)?\\\\(e[+\\\\-]?[0-9_]+\\\\)?\")\n-           (setf rust-tcat 'atom)\n-           (rust-eat-re \"[iuf][0-9_]*\")\n-           'font-lock-constant-face)\n-      (def ?. (forward-char)\n-           (cond ((rust-eat-re \"[0-9]+\\\\(e[+\\\\-]?[0-9]+\\\\)?\")\n-                  (setf rust-tcat 'atom)\n-                  (rust-eat-re \"f[0-9]+\")\n-                  'font-lock-constant-face)\n-                 (t (setf rust-tcat (char-before)) nil)))\n-      (def (?\\( ?\\) ?\\[ ?\\] ?\\{ ?\\} ?: ?\\; ?,)\n-           (forward-char)\n-           (setf rust-tcat (char-before)) nil)\n-      (def ?|\n-           (skip-chars-forward rust-operator-chars)\n-           (setf rust-tcat 'pipe) nil)\n-      (def (?+ ?- ?% ?= ?< ?> ?! ?* ?& ?@ ?~)\n-           (skip-chars-forward rust-operator-chars)\n-           (setf rust-tcat 'op) nil)\n-      table)))\n-\n-(defun rust-token-identifier ()\n-  (rust-eat-re \"[a-zA-Z_][a-zA-Z0-9_]*\")\n-  (setf rust-tcat 'ident)\n-  (if (and (eq (char-after) ?:) (eq (char-after (+ (point) 1)) ?:)\n-           (not (eq (char-after (+ (point) 2)) ?:)))\n-      (progn (forward-char 2) 'font-lock-builtin-face)\n-    (match-string 0)))\n-\n-(defun rust-single-quote ()\n-  (forward-char)\n-  (setf rust-tcat 'atom)\n-  ; Is this a lifetime?\n-  (if (or (looking-at \"[a-zA-Z_]$\")\n-          (looking-at \"[a-zA-Z_][^']\"))\n-      ; If what we see is 'abc, use font-lock-builtin-face:\n-      (progn (rust-eat-re \"[a-zA-Z_][a-zA-Z_0-9]*\")\n-             'font-lock-builtin-face)\n-    ; Otherwise, handle as a character constant:\n-    (let ((is-escape (eq (char-after) ?\\\\))\n-          (start (point)))\n-      (if (not (rust-eat-until-unescaped ?\\'))\n-          'font-lock-warning-face\n-        (if (or is-escape (= (point) (+ start 2)))\n-            'font-lock-string-face 'font-lock-warning-face)))))\n-\n-(defun rust-token-base (st)\n-  (funcall (char-table-range rust-char-table (char-after)) st))\n-\n-(defun rust-eat-until-unescaped (ch)\n-  (let (escaped)\n-    (loop\n-     (let ((cur (char-after)))\n-       (when (or (eq cur ?\\n) (not cur)) (return nil))\n-       (forward-char)\n-       (when (and (eq cur ch) (not escaped)) (return t))\n-       (setf escaped (and (not escaped) (eq cur ?\\\\)))))))\n-\n-(defun rust-token-string (st)\n-  (setf rust-tcat 'atom)\n-  (cond ((rust-eat-until-unescaped ?\\\")\n-         (setf (rust-state-tokenize st) 'rust-token-base)\n-         (rust-pop-context st))\n-        (t (let ((align (eq (char-before) ?\\\\)))\n-             (unless (eq align (rust-context-align (car (rust-state-context st))))\n-               (setf (rust-context-align (rust-dup-context st)) align)))))\n-  'font-lock-string-face)\n-\n-(defun rust-token-comment (st)\n-  (let ((eol (point-at-eol)))\n-    (loop\n-     (unless (re-search-forward \"\\\\(/\\\\*\\\\)\\\\|\\\\(\\\\*/\\\\)\" eol t)\n-       (goto-char eol)\n-       (return))\n-     (if (match-beginning 1)\n-         (push (car (rust-state-context st)) (rust-state-context st))\n-       (rust-pop-context st)\n-       (unless (eq (rust-context-type (car (rust-state-context st))) 'comment)\n-         (setf (rust-state-tokenize st) 'rust-token-base)\n-         (return))))\n-    'font-lock-comment-face))\n-\n-(defun rust-next-block-info (st)\n-  (dolist (cx (rust-state-context st))\n-    (when (eq (rust-context-type cx) ?\\}) (return (rust-context-info cx)))))\n-\n-(defun rust-is-capitalized (string)\n-  (let ((case-fold-search nil))\n-    (string-match-p \"[A-Z]\" string)))\n-\n-(defun rust-token (st)\n-  (let ((cx (car (rust-state-context st))))\n-    (when (bolp)\n-      (setf (rust-state-indent st) (current-indentation))\n-      (when (eq (rust-context-align cx) 'unset)\n-        (setf (rust-context-align cx) nil)))\n-    (setf rust-tcat nil)\n-    (let* ((tok (funcall (rust-state-tokenize st) st))\n-           (tok-id (or tok rust-tcat))\n-           (cur-cx (rust-context-type cx))\n-           (cx-info (rust-context-info cx)))\n-      (when (stringp tok)\n-        (setf tok-id (gethash tok rust-value-keywords nil))\n-        (setf tok (cond ((eq tok-id 'atom) 'font-lock-constant-face)\n-                        (tok-id 'font-lock-keyword-face)\n-                        ((equal (rust-state-last-token st) 'def) 'font-lock-function-name-face)\n-                        ((and rust-capitalized-idents-are-types\n-                              (rust-is-capitalized tok)) 'font-lock-type-face)\n-                        (t nil))))\n-      (when rust-tcat\n-        (when (eq (rust-context-align cx) 'unset)\n-          (setf (rust-context-align cx) t))\n-        (when (eq cx-info 'alt-1)\n-          (setf cx (rust-dup-context st))\n-          (setf (rust-context-info cx) 'alt-2))\n-        (when (and (eq rust-tcat 'pipe) (eq (rust-state-last-token st) ?{))\n-          (setf cx (rust-dup-context st))\n-          (setf (rust-context-info cx) 'block))\n-        (case rust-tcat\n-          ((?\\; ?,) (when (eq cur-cx 'statement) (rust-pop-context st)))\n-          (?\\{\n-           (when (and (eq cur-cx 'statement) (not (member cx-info '(alt-1 alt-2))))\n-             (rust-pop-context st))\n-           (when (eq cx-info 'alt-2)\n-             (setf cx (rust-dup-context st))\n-             (setf (rust-context-info cx) nil))\n-           (let ((next-info (rust-next-block-info st))\n-                 (newcx (rust-push-context st ?\\} (current-column))))\n-             (cond ((eq cx-info 'alt-2) (setf (rust-context-info newcx) 'alt-outer))\n-                   ((eq next-info 'alt-outer) (setf (rust-context-info newcx) 'alt-inner)))))\n-          ((?\\[ open-attr)\n-           (let ((newcx (rust-push-context st ?\\] (current-column))))\n-             (when (eq rust-tcat 'open-attr)\n-               (setf (rust-context-info newcx) 'attr))))\n-          (?\\( (rust-push-context st ?\\) (current-column))\n-               (when (eq (rust-context-info cx) 'attr)\n-                 (setf (rust-context-info (car (rust-state-context st))) 'attr)))\n-          (?\\} (when (eq cur-cx 'statement) (rust-pop-context st))\n-               (when (eq (rust-context-type (car (rust-state-context st))) ?})\n-                 (rust-pop-context st))\n-               (setf cx (car (rust-state-context st)))\n-               (when (and (eq (rust-context-type cx) 'statement)\n-                          (not (eq (rust-context-info cx) 'alt-2)))\n-                 (rust-pop-context st)))\n-          (t (cond ((eq cur-cx rust-tcat)\n-                    (when (eq (rust-context-info (rust-pop-context st)) 'attr)\n-                      (setf tok 'font-lock-preprocessor-face)\n-                      (when (eq (rust-context-type (car (rust-state-context st))) 'statement)\n-                        (rust-pop-context st))))\n-                   ((or (and (eq cur-cx ?\\}) (not (eq (rust-context-info cx) 'alt-outer)))\n-                        (eq cur-cx 'top))\n-                    (rust-push-context st 'statement)))))\n-        (setf (rust-state-last-token st) tok-id))\n-      (setf cx (car (rust-state-context st)))\n-      (when (and (eq tok-id 'alt) (eq (rust-context-type cx) 'statement))\n-        (setf (rust-context-info cx) 'alt-1))\n-      (when (and (eq (rust-state-last-token st) 'pipe)\n-                 (eq (rust-next-block-info st) 'block) (eolp))\n-        (when (eq (rust-context-type cx) 'statement) (rust-pop-context st))\n-        (setf cx (rust-dup-context st)\n-              (rust-context-info cx) nil\n-              (rust-context-align cx) nil))\n-      (if (eq (rust-context-info cx) 'attr)\n-          'font-lock-preprocessor-face\n-        tok))))\n-\n-(defun rust-indent (st)\n-  (let ((cx (car (rust-state-context st)))\n-        (parent (cadr (rust-state-context st))))\n-    (when (and (eq (rust-context-type cx) 'statement)\n-               (or (eq (char-after) ?\\}) (looking-at \"with \\\\|{[ \t]*$\")))\n-      (setf cx parent parent (caddr (rust-state-context st))))\n-    (let* ((tp (rust-context-type cx))\n-           (closing (eq tp (char-after)))\n-           (unit rust-indent-unit)\n-           (base (if (and (eq tp 'statement) parent (rust-context-align parent))\n-                     (rust-context-column parent) (rust-context-indent cx))))\n-      (cond ((eq tp 'comment) base)\n-            ((eq tp 'string) (if (rust-context-align cx) (rust-context-column cx) 0))\n-            ((eq tp 'statement) (+ base (if (eq (char-after) ?\\}) 0 unit)))\n-            ((eq (rust-context-align cx) t) (+ (rust-context-column cx) (if closing -1 0)))\n-            (t (+ base (if closing 0 unit)))))))\n+\n+(defun rust-paren-level () (nth 0 (syntax-ppss)))\n+(defun rust-in-str-or-cmnt () (nth 8 (syntax-ppss)))\n+(defun rust-rewind-past-str-cmnt () (goto-char (nth 8 (syntax-ppss))))\n+(defun rust-rewind-irrelevant ()\n+  (let ((starting (point)))\n+    (skip-chars-backward \"[:space:]\\n\")\n+    (if (looking-back \"\\\\*/\") (backward-char))\n+    (if (rust-in-str-or-cmnt)\n+        (rust-rewind-past-str-cmnt))\n+    (if (/= starting (point))\n+        (rust-rewind-irrelevant))))\n+\n+(defun rust-mode-indent-line ()\n+  (interactive)\n+  (let ((indent\n+         (save-excursion\n+           (back-to-indentation)\n+           (let ((level (rust-paren-level)))\n+             (cond\n+              ;; A function return type is 1 level indented\n+              ((looking-at \"->\") (* default-tab-width (+ level 1)))\n+\n+              ;; A closing brace is 1 level unindended\n+              ((looking-at \"}\") (* default-tab-width (- level 1)))\n+\n+              ;; If we're in any other token-tree / sexp, then:\n+              ;;  - [ or ( means line up with the opening token\n+              ;;  - { means indent to either nesting-level * tab width,\n+              ;;    or one further indent from that if either current line\n+              ;;    begins with 'else', or previous line didn't end in\n+              ;;    semi, comma or brace, and wasn't an attribute. PHEW.\n+              ((> level 0)\n+               (let ((pt (point)))\n+                 (rust-rewind-irrelevant)\n+                 (backward-up-list)\n+                 (if (looking-at \"[[(]\")\n+                     (+ 1 (current-column))\n+                   (progn\n+                     (goto-char pt)\n+                     (back-to-indentation)\n+                     (if (looking-at \"\\\\<else\\\\>\")\n+                         (* default-tab-width (+ 1 level))\n+                       (progn\n+                         (goto-char pt)\n+                         (beginning-of-line)\n+                         (rust-rewind-irrelevant)\n+                         (end-of-line)\n+                         (if (looking-back \"[{};,]\")\n+                             (* default-tab-width level)\n+                           (back-to-indentation)\n+                           (if (looking-at \"#\")\n+                               (* default-tab-width level)\n+                             (* default-tab-width (+ 1 level))))))))))\n+\n+              ;; Otherwise we're in a column-zero definition\n+              (t 0))))))\n+    (cond\n+     ;; If we're to the left of the indentation, reindent and jump to it.\n+     ((<= (current-column) indent)\n+      (indent-line-to indent))\n+\n+     ;; We're to the right; if it needs indent, do so but save excursion.\n+     ((not (eq (current-indentation) indent))\n+      (save-excursion (indent-line-to indent))))))\n+\n+\n+;; Font-locking definitions and helpers\n+(defconst rust-mode-keywords\n+  '(\"as\"\n+    \"break\"\n+    \"do\"\n+    \"else\" \"enum\" \"extern\"\n+    \"false\" \"fn\" \"for\"\n+    \"if\" \"impl\"\n+    \"let\" \"loop\"\n+    \"match\" \"mod\" \"mut\"\n+    \"priv\" \"pub\"\n+    \"ref\" \"return\"\n+    \"self\" \"static\" \"struct\" \"super\"\n+    \"true\" \"trait\" \"type\"\n+    \"unsafe\" \"use\"\n+    \"while\"))\n+\n+(defconst rust-special-types\n+  '(\"u8\" \"i8\"\n+    \"u16\" \"i16\"\n+    \"u32\" \"i32\"\n+    \"u64\" \"i64\"\n+\n+    \"f32\" \"f64\"\n+    \"float\" \"int\" \"uint\"\n+    \"bool\"\n+    \"str\" \"char\"))\n+\n+(defconst rust-re-ident \"[[:word:][:multibyte:]_][[:word:][:multibyte:]_[:digit:]]*\")\n+(defconst rust-re-CamelCase \"[[:upper:]][[:word:][:multibyte:]_[:digit:]]*\")\n+(defun rust-re-word (inner) (concat \"\\\\<\" inner \"\\\\>\"))\n+(defun rust-re-grab (inner) (concat \"\\\\(\" inner \"\\\\)\"))\n+(defun rust-re-grabword (inner) (rust-re-grab (rust-re-word inner)))\n+(defun rust-re-item-def (itype)\n+  (concat (rust-re-word itype) \"[[:space:]]+\" (rust-re-grab rust-re-ident)))\n+\n+(defvar rust-mode-font-lock-keywords\n+  (append\n+   `(\n+     ;; Keywords proper\n+     (,(regexp-opt rust-mode-keywords 'words) . font-lock-keyword-face)\n+\n+     ;; Special types\n+     (,(regexp-opt rust-special-types 'words) . font-lock-type-face)\n+\n+     ;; Attributes like `#[bar(baz)]`\n+     (,(rust-re-grab (concat \"#\\\\[\" rust-re-ident \"[^]]*\\\\]\"))\n+      1 font-lock-preprocessor-face)\n+\n+     ;; Syntax extension invocations like `foo!`, highlight including the !\n+     (,(concat (rust-re-grab (concat rust-re-ident \"!\")) \"[({[:space:]]\")\n+      1 font-lock-preprocessor-face)\n+\n+     ;; Field names like `foo:`, highlight excluding the :\n+     (,(concat (rust-re-grab rust-re-ident) \":[^:]\") 1 font-lock-variable-name-face)\n+\n+     ;; Module names like `foo::`, highlight including the ::\n+     (,(rust-re-grab (concat rust-re-ident \"::\")) 1 font-lock-type-face)\n+\n+     ;; Lifetimes like `'foo`\n+     (,(concat \"'\" (rust-re-grab rust-re-ident) \"[^']\") 1 font-lock-variable-name-face)\n+\n+     ;; Character constants, since they're not treated as strings\n+     ;; in order to have sufficient leeway to parse 'lifetime above.\n+     (,(rust-re-grab \"'[^']'\") 1 font-lock-string-face)\n+     (,(rust-re-grab \"'\\\\\\\\[nrt]'\") 1 font-lock-string-face)\n+     (,(rust-re-grab \"'\\\\\\\\x[[:xdigit:]]\\\\{2\\\\}'\") 1 font-lock-string-face)\n+     (,(rust-re-grab \"'\\\\\\\\u[[:xdigit:]]\\\\{4\\\\}'\") 1 font-lock-string-face)\n+     (,(rust-re-grab \"'\\\\\\\\U[[:xdigit:]]\\\\{8\\\\}'\") 1 font-lock-string-face)\n+\n+     ;; CamelCase Means Type Or Constructor\n+     (,(rust-re-grabword rust-re-CamelCase) 1 font-lock-type-face)\n+     )\n+\n+   ;; Item definitions\n+   (loop for (item . face) in\n+\n+         '((\"enum\" . font-lock-type-face)\n+           (\"struct\" . font-lock-type-face)\n+           (\"type\" . font-lock-type-face)\n+           (\"mod\" . font-lock-type-face)\n+           (\"use\" . font-lock-type-face)\n+           (\"fn\" . font-lock-function-name-face)\n+           (\"static\" . font-lock-constant-face))\n+\n+         collect `(,(rust-re-item-def item) 1 ,face))))\n+\n+\n+;; For compatibility with Emacs < 24, derive conditionally\n+(defalias 'rust-parent-mode\n+  (if (fboundp 'prog-mode) 'prog-mode 'fundamental-mode))\n+\n \n ;;;###autoload\n-(define-derived-mode rust-mode fundamental-mode \"Rust\"\n-  \"Major mode for editing Rust source files.\"\n-  (set-syntax-table rust-syntax-table)\n-  (setq major-mode 'rust-mode mode-name \"Rust\")\n-  (run-hooks 'rust-mode-hook)\n-  (set (make-local-variable 'indent-tabs-mode) nil)\n-  (let ((par \"[ \t]*\\\\(//+\\\\|\\\\**\\\\)[ \t]*$\"))\n-    (set (make-local-variable 'paragraph-start) par)\n-    (set (make-local-variable 'paragraph-separate) par))\n-  (set (make-local-variable 'comment-start) \"//\")\n-  (cm-mode (make-cm-mode 'rust-token 'make-rust-state 'copy-sequence 'equal 'rust-indent)))\n-\n-(define-key rust-mode-map \"}\" 'rust-electric-brace)\n-(define-key rust-mode-map \"{\" 'rust-electric-brace)\n+(define-derived-mode rust-mode rust-parent-mode \"Rust\"\n+  \"Major mode for Rust code.\"\n+\n+  ;; Basic syntax\n+  (set-syntax-table rust-mode-syntax-table)\n+\n+  ;; Indentation\n+  (set (make-local-variable 'indent-line-function)\n+       'rust-mode-indent-line)\n+\n+  ;; Fonts\n+  (set (make-local-variable 'font-lock-defaults)\n+       '(rust-mode-font-lock-keywords nil nil nil nil))\n+\n+  ;; Misc\n+  (set (make-local-variable 'comment-start) \"// \")\n+  (set (make-local-variable 'comment-end)   \"\")\n+  (set (make-local-variable 'indent-tabs-mode) nil))\n+\n \n ;;;###autoload\n-(progn\n-  (add-to-list 'auto-mode-alist '(\"\\\\.rs$\" . rust-mode))\n-  (add-to-list 'auto-mode-alist '(\"\\\\.rc$\" . rust-mode)))\n+(add-to-list 'auto-mode-alist '(\"\\\\.rs$\" . rust-mode))\n+\n+(defun rust-mode-reload ()\n+  (interactive)\n+  (unload-feature 'rust-mode)\n+  (require 'rust-mode)\n+  (rust-mode))\n \n (provide 'rust-mode)\n "}]}