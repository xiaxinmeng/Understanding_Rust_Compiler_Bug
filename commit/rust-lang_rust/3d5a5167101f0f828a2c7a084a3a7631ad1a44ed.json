{"sha": "3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "node_id": "C_kwDOAAsO6NoAKDNkNWE1MTY3MTAxZjBmODI4YTJjN2EwODRhM2E3NjMxYWQxYTQ0ZWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-07T21:06:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-07T21:06:36Z"}, "message": "Auto merge of #2878 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "2ba1f523436ad377f806a1ba2f131277deac45e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ba1f523436ad377f806a1ba2f131277deac45e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "html_url": "https://github.com/rust-lang/rust/commit/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd9df18792cd13b25a54406ef60e3b32ac358272", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd9df18792cd13b25a54406ef60e3b32ac358272", "html_url": "https://github.com/rust-lang/rust/commit/dd9df18792cd13b25a54406ef60e3b32ac358272"}, {"sha": "e476f7ac36e4c77acc158aa7f7d2edc18b5b16fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e476f7ac36e4c77acc158aa7f7d2edc18b5b16fa", "html_url": "https://github.com/rust-lang/rust/commit/e476f7ac36e4c77acc158aa7f7d2edc18b5b16fa"}], "stats": {"total": 9546, "additions": 6509, "deletions": 3037}, "files": [{"sha": "2d8980fcd1a0d89d7163f1f631c099bbaa821647", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -42,24 +42,20 @@ jobs:\n       TOOLSTATE_REPO: \"https://github.com/rust-lang-nursery/rust-toolstate\"\n       CACHE_DOMAIN: ci-caches.rust-lang.org\n     if: \"github.event_name == 'pull_request'\"\n-    continue-on-error: \"${{ matrix.tidy }}\"\n+    continue-on-error: \"${{ matrix.name == 'mingw-check-tidy' }}\"\n     strategy:\n       matrix:\n         include:\n           - name: mingw-check\n-            tidy: false\n             os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: mingw-check-tidy\n-            tidy: true\n             os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-llvm-14\n-            tidy: false\n             os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-tools\n-            tidy: false\n             os: ubuntu-20.04-16core-64gb\n             env: {}\n     timeout-minutes: 600\n@@ -98,9 +94,6 @@ jobs:\n       - name: show the current environment\n         run: src/ci/scripts/dump-environment.sh\n         if: success() && !env.SKIP_JOB\n-      - name: install awscli\n-        run: src/ci/scripts/install-awscli.sh\n-        if: success() && !env.SKIP_JOB\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n         if: success() && !env.SKIP_JOB\n@@ -170,6 +163,7 @@ jobs:\n       TOOLSTATE_PUBLISH: 1\n       CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZI5DHEBFL\n       ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZN24CBO55\n+      AWS_REGION: us-west-1\n       CACHE_DOMAIN: ci-caches.rust-lang.org\n     if: \"github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n     strategy:\n@@ -521,9 +515,6 @@ jobs:\n       - name: show the current environment\n         run: src/ci/scripts/dump-environment.sh\n         if: success() && !env.SKIP_JOB\n-      - name: install awscli\n-        run: src/ci/scripts/install-awscli.sh\n-        if: success() && !env.SKIP_JOB\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n         if: success() && !env.SKIP_JOB\n@@ -593,6 +584,7 @@ jobs:\n       TOOLSTATE_PUBLISH: 1\n       CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZI5DHEBFL\n       ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZN24CBO55\n+      AWS_REGION: us-west-1\n       CACHE_DOMAIN: ci-caches.rust-lang.org\n     if: \"github.event_name == 'push' && (github.ref == 'refs/heads/try' || github.ref == 'refs/heads/try-perf') && github.repository == 'rust-lang-ci/rust'\"\n     strategy:\n@@ -637,9 +629,6 @@ jobs:\n       - name: show the current environment\n         run: src/ci/scripts/dump-environment.sh\n         if: success() && !env.SKIP_JOB\n-      - name: install awscli\n-        run: src/ci/scripts/install-awscli.sh\n-        if: success() && !env.SKIP_JOB\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n         if: success() && !env.SKIP_JOB\n@@ -706,6 +695,7 @@ jobs:\n       TOOLSTATE_PUBLISH: 1\n       CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZI5DHEBFL\n       ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZN24CBO55\n+      AWS_REGION: us-west-1\n       CACHE_DOMAIN: ci-caches.rust-lang.org\n     if: \"github.event_name == 'push' && github.ref == 'refs/heads/master' && github.repository == 'rust-lang-ci/rust'\"\n     steps:"}, {"sha": "724587a4a71c10f9898d0070177dea75a0619699", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -577,7 +577,7 @@ checksum = \"8a2dd5a6fe8c6e3502f568a6353e5273bbb15193ad9a89e457b9970798efbea1\"\n \n [[package]]\n name = \"clippy\"\n-version = \"0.1.70\"\n+version = \"0.1.71\"\n dependencies = [\n  \"clap 4.2.1\",\n  \"clippy_lints\",\n@@ -619,7 +619,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy_lints\"\n-version = \"0.1.70\"\n+version = \"0.1.71\"\n dependencies = [\n  \"arrayvec\",\n  \"cargo_metadata 0.15.3\",\n@@ -643,7 +643,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy_utils\"\n-version = \"0.1.70\"\n+version = \"0.1.71\"\n dependencies = [\n  \"arrayvec\",\n  \"if_chain\",\n@@ -969,7 +969,7 @@ checksum = \"a0afaad2b26fa326569eb264b1363e8ae3357618c43982b3f285f0774ce76b69\"\n \n [[package]]\n name = \"declare_clippy_lint\"\n-version = \"0.1.70\"\n+version = \"0.1.71\"\n dependencies = [\n  \"itertools\",\n  \"quote\","}, {"sha": "3d97d9b489508a8004023841fe3d921bf89260b9", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 51, "deletions": 20, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -729,42 +729,73 @@ pub trait LayoutCalculator {\n             align = align.max(AbiAndPrefAlign::new(repr_align));\n         }\n \n-        let optimize = !repr.inhibit_union_abi_opt();\n+        // If all the non-ZST fields have the same ABI and union ABI optimizations aren't\n+        // disabled, we can use that common ABI for the union as a whole.\n+        struct AbiMismatch;\n+        let mut common_non_zst_abi_and_align = if repr.inhibit_union_abi_opt() {\n+            // Can't optimize\n+            Err(AbiMismatch)\n+        } else {\n+            Ok(None)\n+        };\n+\n         let mut size = Size::ZERO;\n-        let mut abi = Abi::Aggregate { sized: true };\n         let only_variant = &variants[FIRST_VARIANT];\n         for field in only_variant {\n             assert!(field.0.is_sized());\n+\n             align = align.max(field.align());\n+            size = cmp::max(size, field.size());\n \n-            // If all non-ZST fields have the same ABI, forward this ABI\n-            if optimize && !field.0.is_zst() {\n+            if field.0.is_zst() {\n+                // Nothing more to do for ZST fields\n+                continue;\n+            }\n+\n+            if let Ok(common) = common_non_zst_abi_and_align {\n                 // Discard valid range information and allow undef\n-                let field_abi = match field.abi() {\n-                    Abi::Scalar(x) => Abi::Scalar(x.to_union()),\n-                    Abi::ScalarPair(x, y) => Abi::ScalarPair(x.to_union(), y.to_union()),\n-                    Abi::Vector { element: x, count } => {\n-                        Abi::Vector { element: x.to_union(), count }\n-                    }\n-                    Abi::Uninhabited | Abi::Aggregate { .. } => Abi::Aggregate { sized: true },\n-                };\n+                let field_abi = field.abi().to_union();\n \n-                if size == Size::ZERO {\n-                    // first non ZST: initialize 'abi'\n-                    abi = field_abi;\n-                } else if abi != field_abi {\n-                    // different fields have different ABI: reset to Aggregate\n-                    abi = Abi::Aggregate { sized: true };\n+                if let Some((common_abi, common_align)) = common {\n+                    if common_abi != field_abi {\n+                        // Different fields have different ABI: disable opt\n+                        common_non_zst_abi_and_align = Err(AbiMismatch);\n+                    } else {\n+                        // Fields with the same non-Aggregate ABI should also\n+                        // have the same alignment\n+                        if !matches!(common_abi, Abi::Aggregate { .. }) {\n+                            assert_eq!(\n+                                common_align,\n+                                field.align().abi,\n+                                \"non-Aggregate field with matching ABI but differing alignment\"\n+                            );\n+                        }\n+                    }\n+                } else {\n+                    // First non-ZST field: record its ABI and alignment\n+                    common_non_zst_abi_and_align = Ok(Some((field_abi, field.align().abi)));\n                 }\n             }\n-\n-            size = cmp::max(size, field.size());\n         }\n \n         if let Some(pack) = repr.pack {\n             align = align.min(AbiAndPrefAlign::new(pack));\n         }\n \n+        // If all non-ZST fields have the same ABI, we may forward that ABI\n+        // for the union as a whole, unless otherwise inhibited.\n+        let abi = match common_non_zst_abi_and_align {\n+            Err(AbiMismatch) | Ok(None) => Abi::Aggregate { sized: true },\n+            Ok(Some((abi, _))) => {\n+                if abi.inherent_align(dl).map(|a| a.abi) != Some(align.abi) {\n+                    // Mismatched alignment (e.g. union is #[repr(packed)]): disable opt\n+                    Abi::Aggregate { sized: true }\n+                } else {\n+                    abi\n+                }\n+            }\n+        };\n+\n         Some(LayoutS {\n             variants: Variants::Single { index: FIRST_VARIANT },\n             fields: FieldsShape::Union(NonZeroUsize::new(only_variant.len())?),"}, {"sha": "43db66a3c2869fa7834369165923c7cba20b1a28", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1272,6 +1272,50 @@ impl Abi {\n     pub fn is_scalar(&self) -> bool {\n         matches!(*self, Abi::Scalar(_))\n     }\n+\n+    /// Returns the fixed alignment of this ABI, if any is mandated.\n+    pub fn inherent_align<C: HasDataLayout>(&self, cx: &C) -> Option<AbiAndPrefAlign> {\n+        Some(match *self {\n+            Abi::Scalar(s) => s.align(cx),\n+            Abi::ScalarPair(s1, s2) => s1.align(cx).max(s2.align(cx)),\n+            Abi::Vector { element, count } => {\n+                cx.data_layout().vector_align(element.size(cx) * count)\n+            }\n+            Abi::Uninhabited | Abi::Aggregate { .. } => return None,\n+        })\n+    }\n+\n+    /// Returns the fixed size of this ABI, if any is mandated.\n+    pub fn inherent_size<C: HasDataLayout>(&self, cx: &C) -> Option<Size> {\n+        Some(match *self {\n+            Abi::Scalar(s) => {\n+                // No padding in scalars.\n+                s.size(cx)\n+            }\n+            Abi::ScalarPair(s1, s2) => {\n+                // May have some padding between the pair.\n+                let field2_offset = s1.size(cx).align_to(s2.align(cx).abi);\n+                (field2_offset + s2.size(cx)).align_to(self.inherent_align(cx)?.abi)\n+            }\n+            Abi::Vector { element, count } => {\n+                // No padding in vectors, except possibly for trailing padding\n+                // to make the size a multiple of align (e.g. for vectors of size 3).\n+                (element.size(cx) * count).align_to(self.inherent_align(cx)?.abi)\n+            }\n+            Abi::Uninhabited | Abi::Aggregate { .. } => return None,\n+        })\n+    }\n+\n+    /// Discard validity range information and allow undef.\n+    pub fn to_union(&self) -> Self {\n+        assert!(self.is_sized());\n+        match *self {\n+            Abi::Scalar(s) => Abi::Scalar(s.to_union()),\n+            Abi::ScalarPair(s1, s2) => Abi::ScalarPair(s1.to_union(), s2.to_union()),\n+            Abi::Vector { element, count } => Abi::Vector { element: element.to_union(), count },\n+            Abi::Uninhabited | Abi::Aggregate { .. } => Abi::Aggregate { sized: true },\n+        }\n+    }\n }\n \n #[derive(PartialEq, Eq, Hash, Clone, Debug)]"}, {"sha": "e3ac8a8784a7cd7e8b840f3a66bafb92ba9235ee", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1821,6 +1821,8 @@ pub enum LitKind {\n     /// A byte string (`b\"foo\"`). Not stored as a symbol because it might be\n     /// non-utf8, and symbols only allow utf8 strings.\n     ByteStr(Lrc<[u8]>, StrStyle),\n+    /// A C String (`c\"foo\"`). Guaranteed to only have `\\0` at the end.\n+    CStr(Lrc<[u8]>, StrStyle),\n     /// A byte char (`b'f'`).\n     Byte(u8),\n     /// A character literal (`'a'`).\n@@ -1875,6 +1877,7 @@ impl LitKind {\n             // unsuffixed variants\n             LitKind::Str(..)\n             | LitKind::ByteStr(..)\n+            | LitKind::CStr(..)\n             | LitKind::Byte(..)\n             | LitKind::Char(..)\n             | LitKind::Int(_, LitIntType::Unsuffixed)"}, {"sha": "42b843482a32b386ff9bf374fd342360cebff71d", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -74,6 +74,8 @@ pub enum LitKind {\n     StrRaw(u8), // raw string delimited by `n` hash symbols\n     ByteStr,\n     ByteStrRaw(u8), // raw byte string delimited by `n` hash symbols\n+    CStr,\n+    CStrRaw(u8),\n     Err,\n }\n \n@@ -141,6 +143,10 @@ impl fmt::Display for Lit {\n                 delim = \"#\".repeat(n as usize),\n                 string = symbol\n             )?,\n+            CStr => write!(f, \"c\\\"{symbol}\\\"\")?,\n+            CStrRaw(n) => {\n+                write!(f, \"cr{delim}\\\"{symbol}\\\"{delim}\", delim = \"#\".repeat(n as usize))?\n+            }\n             Integer | Float | Bool | Err => write!(f, \"{symbol}\")?,\n         }\n \n@@ -170,6 +176,7 @@ impl LitKind {\n             Float => \"float\",\n             Str | StrRaw(..) => \"string\",\n             ByteStr | ByteStrRaw(..) => \"byte string\",\n+            CStr | CStrRaw(..) => \"C string\",\n             Err => \"error\",\n         }\n     }"}, {"sha": "15a54fe13d0b78153b915778e412b270099ee9fa", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -2,9 +2,13 @@\n \n use crate::ast::{self, LitKind, MetaItemLit, StrStyle};\n use crate::token::{self, Token};\n-use rustc_lexer::unescape::{byte_from_char, unescape_byte, unescape_char, unescape_literal, Mode};\n+use rustc_lexer::unescape::{\n+    byte_from_char, unescape_byte, unescape_c_string, unescape_char, unescape_literal, CStrUnit,\n+    Mode,\n+};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n+use std::ops::Range;\n use std::{ascii, fmt, str};\n \n // Escapes a string, represented as a symbol. Reuses the original symbol,\n@@ -35,6 +39,7 @@ pub enum LitError {\n     InvalidFloatSuffix,\n     NonDecimalFloat(u32),\n     IntTooLarge(u32),\n+    NulInCStr(Range<usize>),\n }\n \n impl LitKind {\n@@ -158,6 +163,52 @@ impl LitKind {\n \n                 LitKind::ByteStr(bytes.into(), StrStyle::Raw(n))\n             }\n+            token::CStr => {\n+                let s = symbol.as_str();\n+                let mut buf = Vec::with_capacity(s.len());\n+                let mut error = Ok(());\n+                unescape_c_string(s, Mode::CStr, &mut |span, c| match c {\n+                    Ok(CStrUnit::Byte(0) | CStrUnit::Char('\\0')) => {\n+                        error = Err(LitError::NulInCStr(span));\n+                    }\n+                    Ok(CStrUnit::Byte(b)) => buf.push(b),\n+                    Ok(CStrUnit::Char(c)) if c.len_utf8() == 1 => buf.push(c as u8),\n+                    Ok(CStrUnit::Char(c)) => {\n+                        buf.extend_from_slice(c.encode_utf8(&mut [0; 4]).as_bytes())\n+                    }\n+                    Err(err) => {\n+                        if err.is_fatal() {\n+                            error = Err(LitError::LexerError);\n+                        }\n+                    }\n+                });\n+                error?;\n+                buf.push(0);\n+                LitKind::CStr(buf.into(), StrStyle::Cooked)\n+            }\n+            token::CStrRaw(n) => {\n+                let s = symbol.as_str();\n+                let mut buf = Vec::with_capacity(s.len());\n+                let mut error = Ok(());\n+                unescape_c_string(s, Mode::RawCStr, &mut |span, c| match c {\n+                    Ok(CStrUnit::Byte(0) | CStrUnit::Char('\\0')) => {\n+                        error = Err(LitError::NulInCStr(span));\n+                    }\n+                    Ok(CStrUnit::Byte(b)) => buf.push(b),\n+                    Ok(CStrUnit::Char(c)) if c.len_utf8() == 1 => buf.push(c as u8),\n+                    Ok(CStrUnit::Char(c)) => {\n+                        buf.extend_from_slice(c.encode_utf8(&mut [0; 4]).as_bytes())\n+                    }\n+                    Err(err) => {\n+                        if err.is_fatal() {\n+                            error = Err(LitError::LexerError);\n+                        }\n+                    }\n+                });\n+                error?;\n+                buf.push(0);\n+                LitKind::CStr(buf.into(), StrStyle::Raw(n))\n+            }\n             token::Err => LitKind::Err,\n         })\n     }\n@@ -191,6 +242,14 @@ impl fmt::Display for LitKind {\n                     string = symbol\n                 )?;\n             }\n+            LitKind::CStr(ref bytes, StrStyle::Cooked) => {\n+                write!(f, \"c\\\"{}\\\"\", escape_byte_str_symbol(bytes))?\n+            }\n+            LitKind::CStr(ref bytes, StrStyle::Raw(n)) => {\n+                // This can only be valid UTF-8.\n+                let symbol = str::from_utf8(bytes).unwrap();\n+                write!(f, \"cr{delim}\\\"{symbol}\\\"{delim}\", delim = \"#\".repeat(n as usize),)?;\n+            }\n             LitKind::Int(n, ty) => {\n                 write!(f, \"{n}\")?;\n                 match ty {\n@@ -237,6 +296,8 @@ impl MetaItemLit {\n             LitKind::Str(_, ast::StrStyle::Raw(n)) => token::StrRaw(n),\n             LitKind::ByteStr(_, ast::StrStyle::Cooked) => token::ByteStr,\n             LitKind::ByteStr(_, ast::StrStyle::Raw(n)) => token::ByteStrRaw(n),\n+            LitKind::CStr(_, ast::StrStyle::Cooked) => token::CStr,\n+            LitKind::CStr(_, ast::StrStyle::Raw(n)) => token::CStrRaw(n),\n             LitKind::Byte(_) => token::Byte,\n             LitKind::Char(_) => token::Char,\n             LitKind::Int(..) => token::Integer,"}, {"sha": "b960671bf6e158aa21bab70859d8d32128b288d5", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -572,6 +572,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n             }\n         };\n     }\n+    gate_all!(c_str_literals, \"`c\\\"..\\\"` literals are experimental\");\n     gate_all!(\n         if_let_guard,\n         \"`if let` guards are experimental\","}, {"sha": "3f80728a2606b64280820c1ba80b2dfe45b06a57", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -210,6 +210,10 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n         token::ByteStrRaw(n) => {\n             format!(\"br{delim}\\\"{string}\\\"{delim}\", delim = \"#\".repeat(n as usize), string = symbol)\n         }\n+        token::CStr => format!(\"c\\\"{symbol}\\\"\"),\n+        token::CStrRaw(n) => {\n+            format!(\"cr{delim}\\\"{symbol}\\\"{delim}\", delim = \"#\".repeat(n as usize))\n+        }\n         token::Integer | token::Float | token::Bool | token::Err => symbol.to_string(),\n     };\n "}, {"sha": "2a3092d3c7b348fb1c834cf0382e9e721d01d761", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -5,6 +5,7 @@ use rustc_ast::{Attribute, LitKind, MetaItem, MetaItemKind, MetaItemLit, NestedM\n use rustc_ast_pretty::pprust;\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n use rustc_macros::HashStable_Generic;\n+use rustc_session::config::ExpectedValues;\n use rustc_session::lint::builtin::UNEXPECTED_CFGS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::{feature_err, ParseSess};\n@@ -581,32 +582,32 @@ pub fn cfg_matches(\n ) -> bool {\n     eval_condition(cfg, sess, features, &mut |cfg| {\n         try_gate_cfg(cfg.name, cfg.span, sess, features);\n-        if let Some(names_valid) = &sess.check_config.names_valid {\n-            if !names_valid.contains(&cfg.name) {\n+        match sess.check_config.expecteds.get(&cfg.name) {\n+            Some(ExpectedValues::Some(values)) if !values.contains(&cfg.value) => {\n                 sess.buffer_lint_with_diagnostic(\n                     UNEXPECTED_CFGS,\n                     cfg.span,\n                     lint_node_id,\n-                    \"unexpected `cfg` condition name\",\n-                    BuiltinLintDiagnostics::UnexpectedCfg((cfg.name, cfg.name_span), None),\n+                    \"unexpected `cfg` condition value\",\n+                    BuiltinLintDiagnostics::UnexpectedCfgValue(\n+                        (cfg.name, cfg.name_span),\n+                        cfg.value.map(|v| (v, cfg.value_span.unwrap())),\n+                    ),\n                 );\n             }\n-        }\n-        if let Some(value) = cfg.value {\n-            if let Some(values) = &sess.check_config.values_valid.get(&cfg.name) {\n-                if !values.contains(&value) {\n-                    sess.buffer_lint_with_diagnostic(\n-                        UNEXPECTED_CFGS,\n-                        cfg.span,\n-                        lint_node_id,\n-                        \"unexpected `cfg` condition value\",\n-                        BuiltinLintDiagnostics::UnexpectedCfg(\n-                            (cfg.name, cfg.name_span),\n-                            cfg.value_span.map(|vs| (value, vs)),\n-                        ),\n-                    );\n-                }\n+            None if sess.check_config.exhaustive_names => {\n+                sess.buffer_lint_with_diagnostic(\n+                    UNEXPECTED_CFGS,\n+                    cfg.span,\n+                    lint_node_id,\n+                    \"unexpected `cfg` condition name\",\n+                    BuiltinLintDiagnostics::UnexpectedCfgName(\n+                        (cfg.name, cfg.name_span),\n+                        cfg.value.map(|v| (v, cfg.value_span.unwrap())),\n+                    ),\n+                );\n             }\n+            _ => { /* not unexpected */ }\n         }\n         sess.config.contains(&(cfg.name, cfg.value))\n     })"}, {"sha": "50e88ae2eeeded88a87001354979231f75cc6792", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -32,6 +32,10 @@ pub fn expand_concat(\n                 Ok(ast::LitKind::Bool(b)) => {\n                     accumulator.push_str(&b.to_string());\n                 }\n+                Ok(ast::LitKind::CStr(..)) => {\n+                    cx.span_err(e.span, \"cannot concatenate a C string literal\");\n+                    has_errors = true;\n+                }\n                 Ok(ast::LitKind::Byte(..) | ast::LitKind::ByteStr(..)) => {\n                     cx.emit_err(errors::ConcatBytestr { span: e.span });\n                     has_errors = true;"}, {"sha": "5ef35af0a059ad4cd12a7b6e71cde3dcc2bfea6f", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -18,6 +18,11 @@ fn invalid_type_err(\n     };\n     let snippet = cx.sess.source_map().span_to_snippet(span).ok();\n     match ast::LitKind::from_token_lit(token_lit) {\n+        Ok(ast::LitKind::CStr(_, _)) => {\n+            // FIXME(c_str_literals): should concatenation of C string literals\n+            // include the null bytes in the end?\n+            cx.span_err(span, \"cannot concatenate C string literals\");\n+        }\n         Ok(ast::LitKind::Char(_)) => {\n             let sugg =\n                 snippet.map(|snippet| ConcatBytesInvalidSuggestion::CharLit { span, snippet });"}, {"sha": "d77634741fb885694ac3e10801172273454ff73d", "filename": "compiler/rustc_codegen_llvm/messages.ftl", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fmessages.ftl?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -24,7 +24,7 @@ codegen_llvm_error_writing_def_file =\n     Error writing .DEF file: {$error}\n \n codegen_llvm_error_calling_dlltool =\n-    Error calling dlltool: {$error}\n+    Error calling dlltool '{$dlltool_path}': {$error}\n \n codegen_llvm_dlltool_fail_import_library =\n     Dlltool could not create import library: {$stdout}\n@@ -82,7 +82,7 @@ codegen_llvm_prepare_thin_lto_module_with_llvm_err = failed to prepare thin LTO\n codegen_llvm_parse_bitcode = failed to parse bitcode for LTO module\n codegen_llvm_parse_bitcode_with_llvm_err = failed to parse bitcode for LTO module: {$llvm_err}\n \n-codegen_llvm_from_llvm_optimization_diag = {$filename}:{$line}:{$column} {$pass_name}: {$message}\n+codegen_llvm_from_llvm_optimization_diag = {$filename}:{$line}:{$column} {$pass_name} ({$kind}): {$message}\n codegen_llvm_from_llvm_diag = {$message}\n \n codegen_llvm_write_bytecode = failed to write bytecode to {$path}: {$err}"}, {"sha": "70bcbf92f383a0f2f5ec9b9ddbb5fe3321e9209a", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -238,7 +238,9 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                 InlineAsmArch::Hexagon => {}\n                 InlineAsmArch::LoongArch64 => {}\n                 InlineAsmArch::Mips | InlineAsmArch::Mips64 => {}\n-                InlineAsmArch::S390x => {}\n+                InlineAsmArch::S390x => {\n+                    constraints.push(\"~{cc}\".to_string());\n+                }\n                 InlineAsmArch::SpirV => {}\n                 InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {}\n                 InlineAsmArch::Bpf => {}"}, {"sha": "a6416e9540cc00933121e54e8c02bab24aeda1bc", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -198,7 +198,7 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n                 \"arm\" => (\"arm\", \"--32\"),\n                 _ => panic!(\"unsupported arch {}\", sess.target.arch),\n             };\n-            let result = std::process::Command::new(dlltool)\n+            let result = std::process::Command::new(&dlltool)\n                 .args([\n                     \"-d\",\n                     def_file_path.to_str().unwrap(),\n@@ -218,9 +218,13 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n \n             match result {\n                 Err(e) => {\n-                    sess.emit_fatal(ErrorCallingDllTool { error: e });\n+                    sess.emit_fatal(ErrorCallingDllTool {\n+                        dlltool_path: dlltool.to_string_lossy(),\n+                        error: e,\n+                    });\n                 }\n-                Ok(output) if !output.status.success() => {\n+                // dlltool returns '0' on failure, so check for error output instead.\n+                Ok(output) if !output.stderr.is_empty() => {\n                     sess.emit_fatal(DlltoolFailImportLibrary {\n                         stdout: String::from_utf8_lossy(&output.stdout),\n                         stderr: String::from_utf8_lossy(&output.stderr),\n@@ -431,7 +435,7 @@ fn string_to_io_error(s: String) -> io::Error {\n \n fn find_binutils_dlltool(sess: &Session) -> OsString {\n     assert!(sess.target.options.is_like_windows && !sess.target.options.is_like_msvc);\n-    if let Some(dlltool_path) = &sess.opts.unstable_opts.dlltool {\n+    if let Some(dlltool_path) = &sess.opts.cg.dlltool {\n         return dlltool_path.clone().into_os_string();\n     }\n "}, {"sha": "ca2eab28f872b26680425aec92eada7a3d64053f", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -31,6 +31,7 @@ use rustc_span::symbol::sym;\n use rustc_span::InnerSpan;\n use rustc_target::spec::{CodeModel, RelocModel, SanitizerSet, SplitDebuginfo};\n \n+use crate::llvm::diagnostic::OptimizationDiagnosticKind;\n use libc::{c_char, c_int, c_uint, c_void, size_t};\n use std::ffi::CString;\n use std::fs;\n@@ -363,6 +364,15 @@ unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void\n                     line: opt.line,\n                     column: opt.column,\n                     pass_name: &opt.pass_name,\n+                    kind: match opt.kind {\n+                        OptimizationDiagnosticKind::OptimizationRemark => \"success\",\n+                        OptimizationDiagnosticKind::OptimizationMissed\n+                        | OptimizationDiagnosticKind::OptimizationFailure => \"missed\",\n+                        OptimizationDiagnosticKind::OptimizationAnalysis\n+                        | OptimizationDiagnosticKind::OptimizationAnalysisFPCommute\n+                        | OptimizationDiagnosticKind::OptimizationAnalysisAliasing => \"analysis\",\n+                        OptimizationDiagnosticKind::OptimizationRemarkOther => \"other\",\n+                    },\n                     message: &opt.message,\n                 });\n             }"}, {"sha": "b138b0c0e70a17205b7f4c5b3628370f0b6065b1", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 51, "deletions": 34, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -322,7 +322,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let tcx = self.tcx;\n \n         let def_id = instance.def_id();\n-        let containing_scope = get_containing_scope(self, instance);\n+        let (containing_scope, is_method) = get_containing_scope(self, instance);\n         let span = tcx.def_span(def_id);\n         let loc = self.lookup_debug_loc(span.lo());\n         let file_metadata = file_metadata(self, &loc.file);\n@@ -378,8 +378,29 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             }\n         }\n \n-        unsafe {\n-            return llvm::LLVMRustDIBuilderCreateFunction(\n+        // When we're adding a method to a type DIE, we only want a DW_AT_declaration there, because\n+        // LLVM LTO can't unify type definitions when a child DIE is a full subprogram definition.\n+        // When we use this `decl` below, the subprogram definition gets created at the CU level\n+        // with a DW_AT_specification pointing back to the type's declaration.\n+        let decl = is_method.then(|| unsafe {\n+            llvm::LLVMRustDIBuilderCreateMethod(\n+                DIB(self),\n+                containing_scope,\n+                name.as_ptr().cast(),\n+                name.len(),\n+                linkage_name.as_ptr().cast(),\n+                linkage_name.len(),\n+                file_metadata,\n+                loc.line,\n+                function_type_metadata,\n+                flags,\n+                spflags & !DISPFlags::SPFlagDefinition,\n+                template_parameters,\n+            )\n+        });\n+\n+        return unsafe {\n+            llvm::LLVMRustDIBuilderCreateFunction(\n                 DIB(self),\n                 containing_scope,\n                 name.as_ptr().cast(),\n@@ -394,9 +415,9 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 spflags,\n                 maybe_definition_llfn,\n                 template_parameters,\n-                None,\n-            );\n-        }\n+                decl,\n+            )\n+        };\n \n         fn get_function_signature<'ll, 'tcx>(\n             cx: &CodegenCx<'ll, 'tcx>,\n@@ -493,14 +514,16 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             names\n         }\n \n+        /// Returns a scope, plus `true` if that's a type scope for \"class\" methods,\n+        /// otherwise `false` for plain namespace scopes.\n         fn get_containing_scope<'ll, 'tcx>(\n             cx: &CodegenCx<'ll, 'tcx>,\n             instance: Instance<'tcx>,\n-        ) -> &'ll DIScope {\n+        ) -> (&'ll DIScope, bool) {\n             // First, let's see if this is a method within an inherent impl. Because\n             // if yes, we want to make the result subroutine DIE a child of the\n             // subroutine's self-type.\n-            let self_type = cx.tcx.impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n+            if let Some(impl_def_id) = cx.tcx.impl_of_method(instance.def_id()) {\n                 // If the method does *not* belong to a trait, proceed\n                 if cx.tcx.trait_id_of_impl(impl_def_id).is_none() {\n                     let impl_self_ty = cx.tcx.subst_and_normalize_erasing_regions(\n@@ -511,39 +534,33 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n                     // Only \"class\" methods are generally understood by LLVM,\n                     // so avoid methods on other types (e.g., `<*mut T>::null`).\n-                    match impl_self_ty.kind() {\n-                        ty::Adt(def, ..) if !def.is_box() => {\n-                            // Again, only create type information if full debuginfo is enabled\n-                            if cx.sess().opts.debuginfo == DebugInfo::Full\n-                                && !impl_self_ty.has_param()\n-                            {\n-                                Some(type_di_node(cx, impl_self_ty))\n-                            } else {\n-                                Some(namespace::item_namespace(cx, def.did()))\n-                            }\n+                    if let ty::Adt(def, ..) = impl_self_ty.kind() && !def.is_box() {\n+                        // Again, only create type information if full debuginfo is enabled\n+                        if cx.sess().opts.debuginfo == DebugInfo::Full && !impl_self_ty.has_param()\n+                        {\n+                            return (type_di_node(cx, impl_self_ty), true);\n+                        } else {\n+                            return (namespace::item_namespace(cx, def.did()), false);\n                         }\n-                        _ => None,\n                     }\n                 } else {\n                     // For trait method impls we still use the \"parallel namespace\"\n                     // strategy\n-                    None\n                 }\n-            });\n+            }\n \n-            self_type.unwrap_or_else(|| {\n-                namespace::item_namespace(\n-                    cx,\n-                    DefId {\n-                        krate: instance.def_id().krate,\n-                        index: cx\n-                            .tcx\n-                            .def_key(instance.def_id())\n-                            .parent\n-                            .expect(\"get_containing_scope: missing parent?\"),\n-                    },\n-                )\n-            })\n+            let scope = namespace::item_namespace(\n+                cx,\n+                DefId {\n+                    krate: instance.def_id().krate,\n+                    index: cx\n+                        .tcx\n+                        .def_key(instance.def_id())\n+                        .parent\n+                        .expect(\"get_containing_scope: missing parent?\"),\n+                },\n+            );\n+            (scope, false)\n         }\n     }\n "}, {"sha": "6a9173ab450a312fe1393ab0e1b2419820b438ae", "filename": "compiler/rustc_codegen_llvm/src/errors.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -67,7 +67,8 @@ pub(crate) struct ErrorWritingDEFFile {\n \n #[derive(Diagnostic)]\n #[diag(codegen_llvm_error_calling_dlltool)]\n-pub(crate) struct ErrorCallingDllTool {\n+pub(crate) struct ErrorCallingDllTool<'a> {\n+    pub dlltool_path: Cow<'a, str>,\n     pub error: std::io::Error,\n }\n \n@@ -195,6 +196,7 @@ pub(crate) struct FromLlvmOptimizationDiag<'a> {\n     pub line: std::ffi::c_uint,\n     pub column: std::ffi::c_uint,\n     pub pass_name: &'a str,\n+    pub kind: &'a str,\n     pub message: &'a str,\n }\n "}, {"sha": "61365e6dc4b0e93f9fae086bc674dbfeb482de06", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1987,6 +1987,21 @@ extern \"C\" {\n         Decl: Option<&'a DIDescriptor>,\n     ) -> &'a DISubprogram;\n \n+    pub fn LLVMRustDIBuilderCreateMethod<'a>(\n+        Builder: &DIBuilder<'a>,\n+        Scope: &'a DIDescriptor,\n+        Name: *const c_char,\n+        NameLen: size_t,\n+        LinkageName: *const c_char,\n+        LinkageNameLen: size_t,\n+        File: &'a DIFile,\n+        LineNo: c_uint,\n+        Ty: &'a DIType,\n+        Flags: DIFlags,\n+        SPFlags: DISPFlags,\n+        TParam: &'a DIArray,\n+    ) -> &'a DISubprogram;\n+\n     pub fn LLVMRustDIBuilderCreateBasicType<'a>(\n         Builder: &DIBuilder<'a>,\n         Name: *const c_char,\n@@ -2249,7 +2264,7 @@ extern \"C\" {\n \n     pub fn LLVMRustHasFeature(T: &TargetMachine, s: *const c_char) -> bool;\n \n-    pub fn LLVMRustPrintTargetCPUs(T: &TargetMachine);\n+    pub fn LLVMRustPrintTargetCPUs(T: &TargetMachine, cpu: *const c_char);\n     pub fn LLVMRustGetTargetFeaturesCount(T: &TargetMachine) -> size_t;\n     pub fn LLVMRustGetTargetFeature(\n         T: &TargetMachine,"}, {"sha": "2fbdab9f8ce03af6e514205d5651a0f76dd9b55a", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -329,7 +329,14 @@ pub(crate) fn print(req: PrintRequest, sess: &Session) {\n     require_inited();\n     let tm = create_informational_target_machine(sess);\n     match req {\n-        PrintRequest::TargetCPUs => unsafe { llvm::LLVMRustPrintTargetCPUs(tm) },\n+        PrintRequest::TargetCPUs => {\n+            // SAFETY generate a C compatible string from a byte slice to pass\n+            // the target CPU name into LLVM, the lifetime of the reference is\n+            // at least as long as the C function\n+            let cpu_cstring = CString::new(handle_native(sess.target.cpu.as_ref()))\n+                .unwrap_or_else(|e| bug!(\"failed to convert to cstring: {}\", e));\n+            unsafe { llvm::LLVMRustPrintTargetCPUs(tm, cpu_cstring.as_ptr()) };\n+        }\n         PrintRequest::TargetFeatures => print_target_features(sess, tm),\n         _ => bug!(\"rustc_codegen_llvm can't handle print request: {:?}\", req),\n     }"}, {"sha": "c323372bda42d98206a4a7c1c74d9c12c95cafe3", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1821,9 +1821,15 @@ impl SharedEmitterMain {\n                         let source = sess\n                             .source_map()\n                             .new_source_file(FileName::inline_asm_source_code(&buffer), buffer);\n-                        let source_span = Span::with_root_ctxt(source.start_pos, source.end_pos);\n-                        let spans: Vec<_> =\n-                            spans.iter().map(|sp| source_span.from_inner(*sp)).collect();\n+                        let spans: Vec<_> = spans\n+                            .iter()\n+                            .map(|sp| {\n+                                Span::with_root_ctxt(\n+                                    source.normalized_byte_pos(sp.start as u32),\n+                                    source.normalized_byte_pos(sp.end as u32),\n+                                )\n+                            })\n+                            .collect();\n                         err.span_note(spans, \"instantiated into assembly here\");\n                     }\n "}, {"sha": "8dae5dab4297204ab261777e64bf0a785b1c5f12", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -592,15 +592,6 @@ fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n \n fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n     use rustc_ast::{LitIntType, LitKind, MetaItemLit};\n-    if !tcx.features().raw_dylib && tcx.sess.target.arch == \"x86\" {\n-        feature_err(\n-            &tcx.sess.parse_sess,\n-            sym::raw_dylib,\n-            attr.span,\n-            \"`#[link_ordinal]` is unstable on x86\",\n-        )\n-        .emit();\n-    }\n     let meta_item_list = attr.meta_item_list();\n     let meta_item_list = meta_item_list.as_deref();\n     let sole_meta_list = match meta_item_list {"}, {"sha": "9efbb34b515b6679ba83015e9c3ee01ce4619fa5", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -2,6 +2,7 @@ use super::place::PlaceRef;\n use super::{FunctionCx, LocalRef};\n \n use crate::base;\n+use crate::common::TypeKind;\n use crate::glue;\n use crate::traits::*;\n use crate::MemFlags;\n@@ -236,19 +237,47 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n         };\n \n         match (&mut val, field.abi) {\n-            (OperandValue::Immediate(llval), _) => {\n+            (\n+                OperandValue::Immediate(llval),\n+                Abi::Scalar(_) | Abi::ScalarPair(..) | Abi::Vector { .. },\n+            ) => {\n                 // Bools in union fields needs to be truncated.\n                 *llval = bx.to_immediate(*llval, field);\n                 // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-                *llval = bx.bitcast(*llval, bx.cx().immediate_backend_type(field));\n+                let ty = bx.cx().immediate_backend_type(field);\n+                if bx.type_kind(ty) == TypeKind::Pointer {\n+                    *llval = bx.pointercast(*llval, ty);\n+                }\n             }\n             (OperandValue::Pair(a, b), Abi::ScalarPair(a_abi, b_abi)) => {\n                 // Bools in union fields needs to be truncated.\n                 *a = bx.to_immediate_scalar(*a, a_abi);\n                 *b = bx.to_immediate_scalar(*b, b_abi);\n                 // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-                *a = bx.bitcast(*a, bx.cx().scalar_pair_element_backend_type(field, 0, true));\n-                *b = bx.bitcast(*b, bx.cx().scalar_pair_element_backend_type(field, 1, true));\n+                let a_ty = bx.cx().scalar_pair_element_backend_type(field, 0, true);\n+                let b_ty = bx.cx().scalar_pair_element_backend_type(field, 1, true);\n+                if bx.type_kind(a_ty) == TypeKind::Pointer {\n+                    *a = bx.pointercast(*a, a_ty);\n+                }\n+                if bx.type_kind(b_ty) == TypeKind::Pointer {\n+                    *b = bx.pointercast(*b, b_ty);\n+                }\n+            }\n+            // Newtype vector of array, e.g. #[repr(simd)] struct S([i32; 4]);\n+            (OperandValue::Immediate(llval), Abi::Aggregate { sized: true }) => {\n+                assert!(matches!(self.layout.abi, Abi::Vector { .. }));\n+\n+                let llty = bx.cx().backend_type(self.layout);\n+                let llfield_ty = bx.cx().backend_type(field);\n+\n+                // Can't bitcast an aggregate, so round trip through memory.\n+                let lltemp = bx.alloca(llfield_ty, field.align.abi);\n+                let llptr = bx.pointercast(lltemp, bx.cx().type_ptr_to(llty));\n+                bx.store(*llval, llptr, field.align.abi);\n+                *llval = bx.load(llfield_ty, lltemp, field.align.abi);\n+            }\n+            (OperandValue::Immediate(_), Abi::Uninhabited | Abi::Aggregate { sized: false }) => {\n+                bug!()\n             }\n             (OperandValue::Pair(..), _) => bug!(),\n             (OperandValue::Ref(..), _) => bug!(),"}, {"sha": "405f3d5b66d423c224c4e0e48e2bd1b9c8fc9ee6", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 58, "deletions": 46, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -25,7 +25,7 @@ use rustc_data_structures::profiling::{\n use rustc_data_structures::sync::SeqCst;\n use rustc_errors::registry::{InvalidErrorCode, Registry};\n use rustc_errors::{\n-    DiagnosticMessage, ErrorGuaranteed, PResult, SubdiagnosticMessage, TerminalUrl,\n+    DiagnosticMessage, ErrorGuaranteed, Handler, PResult, SubdiagnosticMessage, TerminalUrl,\n };\n use rustc_feature::find_gated_cfg;\n use rustc_fluent_macro::fluent_messages;\n@@ -55,7 +55,7 @@ use std::panic::{self, catch_unwind};\n use std::path::PathBuf;\n use std::process::{self, Command, Stdio};\n use std::str;\n-use std::sync::LazyLock;\n+use std::sync::OnceLock;\n use std::time::Instant;\n \n // This import blocks the use of panicking `print` and `println` in all the code\n@@ -119,7 +119,7 @@ pub const EXIT_SUCCESS: i32 = 0;\n /// Exit status code used for compilation failures and invalid flags.\n pub const EXIT_FAILURE: i32 = 1;\n \n-const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust/issues/new\\\n+pub const DEFAULT_BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust/issues/new\\\n     ?labels=C-bug%2C+I-ICE%2C+T-compiler&template=ice.md\";\n \n const ICE_REPORT_COMPILER_FLAGS: &[&str] = &[\"-Z\", \"-C\", \"--crate-type\"];\n@@ -1178,6 +1178,7 @@ fn extra_compiler_flags() -> Option<(Vec<String>, bool)> {\n pub fn catch_fatal_errors<F: FnOnce() -> R, R>(f: F) -> Result<R, ErrorGuaranteed> {\n     catch_unwind(panic::AssertUnwindSafe(f)).map_err(|value| {\n         if value.is::<rustc_errors::FatalErrorMarker>() {\n+            #[allow(deprecated)]\n             ErrorGuaranteed::unchecked_claim_error_was_emitted()\n         } else {\n             panic::resume_unwind(value);\n@@ -1195,43 +1196,66 @@ pub fn catch_with_exit_code(f: impl FnOnce() -> interface::Result<()>) -> i32 {\n     }\n }\n \n-static DEFAULT_HOOK: LazyLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> =\n-    LazyLock::new(|| {\n-        let hook = panic::take_hook();\n-        panic::set_hook(Box::new(|info| {\n-            // If the error was caused by a broken pipe then this is not a bug.\n-            // Write the error and return immediately. See #98700.\n-            #[cfg(windows)]\n-            if let Some(msg) = info.payload().downcast_ref::<String>() {\n-                if msg.starts_with(\"failed printing to stdout: \") && msg.ends_with(\"(os error 232)\")\n-                {\n-                    early_error_no_abort(ErrorOutputType::default(), &msg);\n-                    return;\n-                }\n-            };\n+/// Stores the default panic hook, from before [`install_ice_hook`] was called.\n+static DEFAULT_HOOK: OnceLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> =\n+    OnceLock::new();\n+\n+/// Installs a panic hook that will print the ICE message on unexpected panics.\n+///\n+/// The hook is intended to be useable even by external tools. You can pass a custom\n+/// `bug_report_url`, or report arbitrary info in `extra_info`. Note that `extra_info` is called in\n+/// a context where *the thread is currently panicking*, so it must not panic or the process will\n+/// abort.\n+///\n+/// If you have no extra info to report, pass the empty closure `|_| ()` as the argument to\n+/// extra_info.\n+///\n+/// A custom rustc driver can skip calling this to set up a custom ICE hook.\n+pub fn install_ice_hook(bug_report_url: &'static str, extra_info: fn(&Handler)) {\n+    // If the user has not explicitly overridden \"RUST_BACKTRACE\", then produce\n+    // full backtraces. When a compiler ICE happens, we want to gather\n+    // as much information as possible to present in the issue opened\n+    // by the user. Compiler developers and other rustc users can\n+    // opt in to less-verbose backtraces by manually setting \"RUST_BACKTRACE\"\n+    // (e.g. `RUST_BACKTRACE=1`)\n+    if std::env::var(\"RUST_BACKTRACE\").is_err() {\n+        std::env::set_var(\"RUST_BACKTRACE\", \"full\");\n+    }\n \n-            // Invoke the default handler, which prints the actual panic message and optionally a backtrace\n-            // Don't do this for delayed bugs, which already emit their own more useful backtrace.\n-            if !info.payload().is::<rustc_errors::DelayedBugPanic>() {\n-                (*DEFAULT_HOOK)(info);\n+    let default_hook = DEFAULT_HOOK.get_or_init(panic::take_hook);\n \n-                // Separate the output with an empty line\n-                eprintln!();\n+    panic::set_hook(Box::new(move |info| {\n+        // If the error was caused by a broken pipe then this is not a bug.\n+        // Write the error and return immediately. See #98700.\n+        #[cfg(windows)]\n+        if let Some(msg) = info.payload().downcast_ref::<String>() {\n+            if msg.starts_with(\"failed printing to stdout: \") && msg.ends_with(\"(os error 232)\") {\n+                early_error_no_abort(ErrorOutputType::default(), &msg);\n+                return;\n             }\n+        };\n \n-            // Print the ICE message\n-            report_ice(info, BUG_REPORT_URL);\n-        }));\n-        hook\n-    });\n+        // Invoke the default handler, which prints the actual panic message and optionally a backtrace\n+        // Don't do this for delayed bugs, which already emit their own more useful backtrace.\n+        if !info.payload().is::<rustc_errors::DelayedBugPanic>() {\n+            (*default_hook)(info);\n+\n+            // Separate the output with an empty line\n+            eprintln!();\n+        }\n+\n+        // Print the ICE message\n+        report_ice(info, bug_report_url, extra_info);\n+    }));\n+}\n \n /// Prints the ICE message, including query stack, but without backtrace.\n ///\n /// The message will point the user at `bug_report_url` to report the ICE.\n ///\n /// When `install_ice_hook` is called, this function will be called as the panic\n /// hook.\n-pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n+pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str, extra_info: fn(&Handler)) {\n     let fallback_bundle =\n         rustc_errors::fallback_fluent_bundle(crate::DEFAULT_LOCALE_RESOURCES.to_vec(), false);\n     let emitter = Box::new(rustc_errors::emitter::EmitterWriter::stderr(\n@@ -1276,29 +1300,17 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n \n     interface::try_print_query_stack(&handler, num_frames);\n \n+    // We don't trust this callback not to panic itself, so run it at the end after we're sure we've\n+    // printed all the relevant info.\n+    extra_info(&handler);\n+\n     #[cfg(windows)]\n     if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n         // Trigger a debugger if we crashed during bootstrap\n         unsafe { windows::Win32::System::Diagnostics::Debug::DebugBreak() };\n     }\n }\n \n-/// Installs a panic hook that will print the ICE message on unexpected panics.\n-///\n-/// A custom rustc driver can skip calling this to set up a custom ICE hook.\n-pub fn install_ice_hook() {\n-    // If the user has not explicitly overridden \"RUST_BACKTRACE\", then produce\n-    // full backtraces. When a compiler ICE happens, we want to gather\n-    // as much information as possible to present in the issue opened\n-    // by the user. Compiler developers and other rustc users can\n-    // opt in to less-verbose backtraces by manually setting \"RUST_BACKTRACE\"\n-    // (e.g. `RUST_BACKTRACE=1`)\n-    if std::env::var(\"RUST_BACKTRACE\").is_err() {\n-        std::env::set_var(\"RUST_BACKTRACE\", \"full\");\n-    }\n-    LazyLock::force(&DEFAULT_HOOK);\n-}\n-\n /// This allows tools to enable rust logging without having to magically match rustc's\n /// tracing crate version.\n pub fn init_rustc_env_logger() {\n@@ -1369,7 +1381,7 @@ pub fn main() -> ! {\n     init_rustc_env_logger();\n     signal_handler::install();\n     let mut callbacks = TimePassesCallbacks::default();\n-    install_ice_hook();\n+    install_ice_hook(DEFAULT_BUG_REPORT_URL, |_| ());\n     let exit_code = catch_with_exit_code(|| {\n         let args = env::args_os()\n             .enumerate()"}, {"sha": "a721e746ecd70c13b7c293248858bc2b030e4eed", "filename": "compiler/rustc_error_codes/src/error_codes/E0726.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0726.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0726.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0726.md?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -25,8 +25,8 @@ block_on(future);\n \n Specify desired lifetime of parameter `content` or indicate the anonymous\n lifetime like `content: Content<'_>`. The anonymous lifetime tells the Rust\n-compiler that `content` is only needed until create function is done with\n-it's execution.\n+compiler that `content` is only needed until the `create` function is done with\n+its execution.\n \n The `implicit elision` meaning the omission of suggested lifetime that is\n `pub async fn create<'a>(content: Content<'a>) {}` is not allowed here as"}, {"sha": "ef528d87cb227cdb22c038cfe74423196ebdf87f", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -192,6 +192,7 @@ impl EmissionGuarantee for ErrorGuaranteed {\n                      became non-error ({:?}), after original `.emit()`\",\n                     db.inner.diagnostic.level,\n                 );\n+                #[allow(deprecated)]\n                 ErrorGuaranteed::unchecked_claim_error_was_emitted()\n             }\n         }"}, {"sha": "fcbd9a53b48b74ba5bd073df11ed81150b063af4", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1069,26 +1069,29 @@ impl Handler {\n     }\n \n     pub fn has_errors(&self) -> Option<ErrorGuaranteed> {\n-        self.inner.borrow().has_errors().then(ErrorGuaranteed::unchecked_claim_error_was_emitted)\n+        self.inner.borrow().has_errors().then(|| {\n+            #[allow(deprecated)]\n+            ErrorGuaranteed::unchecked_claim_error_was_emitted()\n+        })\n     }\n \n     pub fn has_errors_or_lint_errors(&self) -> Option<ErrorGuaranteed> {\n-        self.inner\n-            .borrow()\n-            .has_errors_or_lint_errors()\n-            .then(ErrorGuaranteed::unchecked_claim_error_was_emitted)\n+        self.inner.borrow().has_errors_or_lint_errors().then(|| {\n+            #[allow(deprecated)]\n+            ErrorGuaranteed::unchecked_claim_error_was_emitted()\n+        })\n     }\n     pub fn has_errors_or_delayed_span_bugs(&self) -> Option<ErrorGuaranteed> {\n-        self.inner\n-            .borrow()\n-            .has_errors_or_delayed_span_bugs()\n-            .then(ErrorGuaranteed::unchecked_claim_error_was_emitted)\n+        self.inner.borrow().has_errors_or_delayed_span_bugs().then(|| {\n+            #[allow(deprecated)]\n+            ErrorGuaranteed::unchecked_claim_error_was_emitted()\n+        })\n     }\n     pub fn is_compilation_going_to_fail(&self) -> Option<ErrorGuaranteed> {\n-        self.inner\n-            .borrow()\n-            .is_compilation_going_to_fail()\n-            .then(ErrorGuaranteed::unchecked_claim_error_was_emitted)\n+        self.inner.borrow().is_compilation_going_to_fail().then(|| {\n+            #[allow(deprecated)]\n+            ErrorGuaranteed::unchecked_claim_error_was_emitted()\n+        })\n     }\n \n     pub fn print_error_count(&self, registry: &Registry) {\n@@ -1333,6 +1336,7 @@ impl HandlerInner {\n                 .push(DelayedDiagnostic::with_backtrace(diagnostic.clone(), backtrace));\n \n             if !self.flags.report_delayed_bugs {\n+                #[allow(deprecated)]\n                 return Some(ErrorGuaranteed::unchecked_claim_error_was_emitted());\n             }\n         }\n@@ -1411,7 +1415,10 @@ impl HandlerInner {\n                     self.bump_err_count();\n                 }\n \n-                guaranteed = Some(ErrorGuaranteed::unchecked_claim_error_was_emitted());\n+                #[allow(deprecated)]\n+                {\n+                    guaranteed = Some(ErrorGuaranteed::unchecked_claim_error_was_emitted());\n+                }\n             } else {\n                 self.bump_warn_count();\n             }"}, {"sha": "891e84a2f3071d8cdbf26f2425f18f19d069b5b3", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -61,6 +61,8 @@ impl FromInternal<token::LitKind> for LitKind {\n             token::StrRaw(n) => LitKind::StrRaw(n),\n             token::ByteStr => LitKind::ByteStr,\n             token::ByteStrRaw(n) => LitKind::ByteStrRaw(n),\n+            token::CStr => LitKind::CStr,\n+            token::CStrRaw(n) => LitKind::CStrRaw(n),\n             token::Err => LitKind::Err,\n             token::Bool => unreachable!(),\n         }\n@@ -78,6 +80,8 @@ impl ToInternal<token::LitKind> for LitKind {\n             LitKind::StrRaw(n) => token::StrRaw(n),\n             LitKind::ByteStr => token::ByteStr,\n             LitKind::ByteStrRaw(n) => token::ByteStrRaw(n),\n+            LitKind::CStr => token::CStr,\n+            LitKind::CStrRaw(n) => token::CStrRaw(n),\n             LitKind::Err => token::Err,\n         }\n     }\n@@ -436,6 +440,8 @@ impl server::FreeFunctions for Rustc<'_, '_> {\n                 | token::LitKind::StrRaw(_)\n                 | token::LitKind::ByteStr\n                 | token::LitKind::ByteStrRaw(_)\n+                | token::LitKind::CStr\n+                | token::LitKind::CStrRaw(_)\n                 | token::LitKind::Err => return Err(()),\n                 token::LitKind::Integer | token::LitKind::Float => {}\n             }"}, {"sha": "5b2e4d15dfebe7804c04d43a1c2452f525859a1e", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -280,6 +280,8 @@ declare_features! (\n     (accepted, pub_restricted, \"1.18.0\", Some(32409), None),\n     /// Allows use of the postfix `?` operator in expressions.\n     (accepted, question_mark, \"1.13.0\", Some(31436), None),\n+    /// Allows the use of raw-dylibs (RFC 2627).\n+    (accepted, raw_dylib, \"CURRENT_RUSTC_VERSION\", Some(58713), None),\n     /// Allows keywords to be escaped for use as identifiers.\n     (accepted, raw_identifiers, \"1.30.0\", Some(48589), None),\n     /// Allows relaxing the coherence rules such that"}, {"sha": "27d30c315af048e511ab151fa01d798cb3f1a823", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -313,6 +313,8 @@ declare_features! (\n     (active, async_closure, \"1.37.0\", Some(62290), None),\n     /// Allows async functions to be declared, implemented, and used in traits.\n     (active, async_fn_in_trait, \"1.66.0\", Some(91611), None),\n+    /// Allows `c\"foo\"` literals.\n+    (active, c_str_literals, \"CURRENT_RUSTC_VERSION\", Some(105723), None),\n     /// Treat `extern \"C\"` function as nounwind.\n     (active, c_unwind, \"1.52.0\", Some(74990), None),\n     /// Allows using C-variadics.\n@@ -487,8 +489,6 @@ declare_features! (\n     (active, precise_pointer_size_matching, \"1.32.0\", Some(56354), None),\n     /// Allows macro attributes on expressions, statements and non-inline modules.\n     (active, proc_macro_hygiene, \"1.30.0\", Some(54727), None),\n-    /// Allows the use of raw-dylibs (RFC 2627).\n-    (active, raw_dylib, \"1.65.0\", Some(58713), None),\n     /// Allows `&raw const $place_expr` and `&raw mut $place_expr` expressions.\n     (active, raw_ref_op, \"1.41.0\", Some(64490), None),\n     /// Allows using the `#[register_tool]` attribute."}, {"sha": "1f08befb180c9e0a7246f517aff913f856d47af9", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -333,6 +333,7 @@ language_item_table! {\n     RangeTo,                 sym::RangeTo,             range_to_struct,            Target::Struct,         GenericRequirement::None;\n \n     String,                  sym::String,              string,                     Target::Struct,         GenericRequirement::None;\n+    CStr,                    sym::CStr,                c_str,                      Target::Struct,         GenericRequirement::None;\n }\n \n pub enum GenericRequirement {"}, {"sha": "3b42b0fe246647013a990b1d3ac00f8fb8c42aca", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -192,7 +192,11 @@ hir_analysis_return_type_notation_equality_bound =\n     return type notation is not allowed to use type equality\n \n hir_analysis_return_type_notation_missing_method =\n-    cannot find associated function `{$assoc_name}` in trait `{$trait_name}`\n+    cannot find associated function `{$assoc_name}` for `{$ty_name}`\n+\n+hir_analysis_return_type_notation_conflicting_bound =\n+    ambiguous associated function `{$assoc_name}` for `{$ty_name}`\n+    .note = `{$assoc_name}` is declared in two supertraits: `{$first_bound}` and `{$second_bound}`\n \n hir_analysis_placeholder_not_allowed_item_signatures = the placeholder `_` is not allowed within types on item signatures for {$kind}\n     .label = not allowed in type signatures"}, {"sha": "5ee0cf94360196cece83143ddd4c4d94cf648560", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1062,7 +1062,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     /// Convert the bounds in `ast_bounds` that refer to traits which define an associated type\n     /// named `assoc_name` into ty::Bounds. Ignore the rest.\n-    pub(crate) fn compute_bounds_that_match_assoc_type(\n+    pub(crate) fn compute_bounds_that_match_assoc_item(\n         &self,\n         param_ty: Ty<'tcx>,\n         ast_bounds: &[hir::GenericBound<'_>],\n@@ -1073,7 +1073,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         for ast_bound in ast_bounds {\n             if let Some(trait_ref) = ast_bound.trait_ref()\n                 && let Some(trait_did) = trait_ref.trait_def_id()\n-                && self.tcx().trait_may_define_assoc_type(trait_did, assoc_name)\n+                && self.tcx().trait_may_define_assoc_item(trait_did, assoc_name)\n             {\n                 result.push(ast_bound.clone());\n             }\n@@ -1141,11 +1141,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ) {\n                 trait_ref\n             } else {\n-                return Err(tcx.sess.emit_err(crate::errors::ReturnTypeNotationMissingMethod {\n-                    span: binding.span,\n-                    trait_name: tcx.item_name(trait_ref.def_id()),\n-                    assoc_name: binding.item_name.name,\n-                }));\n+                self.one_bound_for_assoc_method(\n+                    traits::supertraits(tcx, trait_ref),\n+                    trait_ref.print_only_trait_path(),\n+                    binding.item_name,\n+                    path_span,\n+                )?\n             }\n         } else if self.trait_defines_associated_item_named(\n             trait_ref.def_id(),\n@@ -1946,7 +1947,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let param_name = tcx.hir().ty_param_name(ty_param_def_id);\n         self.one_bound_for_assoc_type(\n             || {\n-                traits::transitive_bounds_that_define_assoc_type(\n+                traits::transitive_bounds_that_define_assoc_item(\n                     tcx,\n                     predicates.iter().filter_map(|(p, _)| {\n                         Some(p.to_opt_poly_trait_pred()?.map_bound(|t| t.trait_ref))\n@@ -2081,6 +2082,46 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Ok(bound)\n     }\n \n+    #[instrument(level = \"debug\", skip(self, all_candidates, ty_name), ret)]\n+    fn one_bound_for_assoc_method(\n+        &self,\n+        all_candidates: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+        ty_name: impl Display,\n+        assoc_name: Ident,\n+        span: Span,\n+    ) -> Result<ty::PolyTraitRef<'tcx>, ErrorGuaranteed> {\n+        let mut matching_candidates = all_candidates.filter(|r| {\n+            self.trait_defines_associated_item_named(r.def_id(), ty::AssocKind::Fn, assoc_name)\n+        });\n+\n+        let candidate = match matching_candidates.next() {\n+            Some(candidate) => candidate,\n+            None => {\n+                return Err(self.tcx().sess.emit_err(\n+                    crate::errors::ReturnTypeNotationMissingMethod {\n+                        span,\n+                        ty_name: ty_name.to_string(),\n+                        assoc_name: assoc_name.name,\n+                    },\n+                ));\n+            }\n+        };\n+\n+        if let Some(conflicting_candidate) = matching_candidates.next() {\n+            return Err(self.tcx().sess.emit_err(\n+                crate::errors::ReturnTypeNotationConflictingBound {\n+                    span,\n+                    ty_name: ty_name.to_string(),\n+                    assoc_name: assoc_name.name,\n+                    first_bound: candidate.print_only_trait_path(),\n+                    second_bound: conflicting_candidate.print_only_trait_path(),\n+                },\n+            ));\n+        }\n+\n+        Ok(candidate)\n+    }\n+\n     // Create a type from a path to an associated type or to an enum variant.\n     // For a path `A::B::C::D`, `qself_ty` and `qself_def` are the type and def for `A::B::C`\n     // and item_segment is the path segment for `D`. We return a type and a def for"}, {"sha": "5ba1ca1c807bce908450ca87d5c4b7d87ddc1e0e", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 91, "deletions": 233, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,12 +1,14 @@\n // FIXME(@lcnr): Move this module out of `rustc_hir_analysis`.\n //\n // We don't do any drop checking during hir typeck.\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, ErrorGuaranteed};\n-use rustc_middle::ty::error::TypeError;\n-use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::infer::{RegionResolutionError, TyCtxtInferExt};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::util::IgnoreRegions;\n-use rustc_middle::ty::{self, Predicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_trait_selection::traits::{self, ObligationCtxt};\n \n use crate::errors;\n use crate::hir::def_id::{DefId, LocalDefId};\n@@ -43,21 +45,20 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n         }\n     }\n     let dtor_self_type = tcx.type_of(drop_impl_did).subst_identity();\n-    let dtor_predicates = tcx.predicates_of(drop_impl_did);\n     match dtor_self_type.kind() {\n-        ty::Adt(adt_def, self_to_impl_substs) => {\n+        ty::Adt(adt_def, adt_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(\n                 tcx,\n                 drop_impl_did.expect_local(),\n                 adt_def.did(),\n-                self_to_impl_substs,\n+                adt_to_impl_substs,\n             )?;\n \n             ensure_drop_predicates_are_implied_by_item_defn(\n                 tcx,\n-                dtor_predicates,\n+                drop_impl_did.expect_local(),\n                 adt_def.did().expect_local(),\n-                self_to_impl_substs,\n+                adt_to_impl_substs,\n             )\n         }\n         _ => {\n@@ -78,9 +79,9 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     drop_impl_did: LocalDefId,\n     self_type_did: DefId,\n-    drop_impl_substs: SubstsRef<'tcx>,\n+    adt_to_impl_substs: SubstsRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n-    let Err(arg) = tcx.uses_unique_generic_params(drop_impl_substs, IgnoreRegions::No) else {\n+    let Err(arg) = tcx.uses_unique_generic_params(adt_to_impl_substs, IgnoreRegions::No) else {\n         return Ok(())\n     };\n \n@@ -111,237 +112,94 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n /// implied by assuming the predicates attached to self_type_did.\n fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    dtor_predicates: ty::GenericPredicates<'tcx>,\n-    self_type_did: LocalDefId,\n-    self_to_impl_substs: SubstsRef<'tcx>,\n+    drop_impl_def_id: LocalDefId,\n+    adt_def_id: LocalDefId,\n+    adt_to_impl_substs: SubstsRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n-    let mut result = Ok(());\n-\n-    // Here is an example, analogous to that from\n-    // `compare_impl_method`.\n-    //\n-    // Consider a struct type:\n-    //\n-    //     struct Type<'c, 'b:'c, 'a> {\n-    //         x: &'a Contents            // (contents are irrelevant;\n-    //         y: &'c Cell<&'b Contents>, //  only the bounds matter for our purposes.)\n-    //     }\n-    //\n-    // and a Drop impl:\n-    //\n-    //     impl<'z, 'y:'z, 'x:'y> Drop for P<'z, 'y, 'x> {\n-    //         fn drop(&mut self) { self.y.set(self.x); } // (only legal if 'x: 'y)\n-    //     }\n-    //\n-    // We start out with self_to_impl_substs, that maps the generic\n-    // parameters of Type to that of the Drop impl.\n+    let infcx = tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+\n+    // Take the param-env of the adt and substitute the substs that show up in\n+    // the implementation's self type. This gives us the assumptions that the\n+    // self ty of the implementation is allowed to know just from it being a\n+    // well-formed adt, since that's all we're allowed to assume while proving\n+    // the Drop implementation is not specialized.\n     //\n-    //     self_to_impl_substs = {'c => 'z, 'b => 'y, 'a => 'x}\n-    //\n-    // Applying this to the predicates (i.e., assumptions) provided by the item\n-    // definition yields the instantiated assumptions:\n-    //\n-    //     ['y : 'z]\n-    //\n-    // We then check all of the predicates of the Drop impl:\n-    //\n-    //     ['y:'z, 'x:'y]\n-    //\n-    // and ensure each is in the list of instantiated\n-    // assumptions. Here, `'y:'z` is present, but `'x:'y` is\n-    // absent. So we report an error that the Drop impl injected a\n-    // predicate that is not present on the struct definition.\n-\n-    // We can assume the predicates attached to struct/enum definition\n-    // hold.\n-    let generic_assumptions = tcx.predicates_of(self_type_did);\n-\n-    let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n-    let assumptions_in_impl_context = assumptions_in_impl_context.predicates;\n-\n-    debug!(?assumptions_in_impl_context, ?dtor_predicates.predicates);\n-\n-    let self_param_env = tcx.param_env(self_type_did);\n-\n-    // An earlier version of this code attempted to do this checking\n-    // via the traits::fulfill machinery. However, it ran into trouble\n-    // since the fulfill machinery merely turns outlives-predicates\n-    // 'a:'b and T:'b into region inference constraints. It is simpler\n-    // just to look for all the predicates directly.\n-\n-    assert_eq!(dtor_predicates.parent, None);\n-    for &(predicate, predicate_sp) in dtor_predicates.predicates {\n-        // (We do not need to worry about deep analysis of type\n-        // expressions etc because the Drop impls are already forced\n-        // to take on a structure that is roughly an alpha-renaming of\n-        // the generic parameters of the item definition.)\n-\n-        // This path now just checks *all* predicates via an instantiation of\n-        // the `SimpleEqRelation`, which simply forwards to the `relate` machinery\n-        // after taking care of anonymizing late bound regions.\n-        //\n-        // However, it may be more efficient in the future to batch\n-        // the analysis together via the fulfill (see comment above regarding\n-        // the usage of the fulfill machinery), rather than the\n-        // repeated `.iter().any(..)` calls.\n+    // We don't need to normalize this param-env or anything, since we're only\n+    // substituting it with free params, so no additional param-env normalization\n+    // can occur on top of what has been done in the param_env query itself.\n+    let param_env = ty::EarlyBinder(tcx.param_env(adt_def_id))\n+        .subst(tcx, adt_to_impl_substs)\n+        .with_constness(tcx.constness(drop_impl_def_id));\n+\n+    for (pred, span) in tcx.predicates_of(drop_impl_def_id).instantiate_identity(tcx) {\n+        let normalize_cause = traits::ObligationCause::misc(span, adt_def_id);\n+        let pred = ocx.normalize(&normalize_cause, param_env, pred);\n+        let cause = traits::ObligationCause::new(span, adt_def_id, traits::DropImpl);\n+        ocx.register_obligation(traits::Obligation::new(tcx, cause, param_env, pred));\n+    }\n \n-        // This closure is a more robust way to check `Predicate` equality\n-        // than simple `==` checks (which were the previous implementation).\n-        // It relies on `ty::relate` for `TraitPredicate`, `ProjectionPredicate`,\n-        // `ConstEvaluatable` and `TypeOutlives` (which implement the Relate trait),\n-        // while delegating on simple equality for the other `Predicate`.\n-        // This implementation solves (Issue #59497) and (Issue #58311).\n-        // It is unclear to me at the moment whether the approach based on `relate`\n-        // could be extended easily also to the other `Predicate`.\n-        let predicate_matches_closure = |p: Predicate<'tcx>| {\n-            let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n-            let predicate = predicate.kind();\n-            let p = p.kind();\n-            match (predicate.skip_binder(), p.skip_binder()) {\n-                (\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(a)),\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(b)),\n-                ) => relator.relate(predicate.rebind(a), p.rebind(b)).is_ok(),\n-                (\n-                    ty::PredicateKind::Clause(ty::Clause::Projection(a)),\n-                    ty::PredicateKind::Clause(ty::Clause::Projection(b)),\n-                ) => relator.relate(predicate.rebind(a), p.rebind(b)).is_ok(),\n-                (\n-                    ty::PredicateKind::ConstEvaluatable(a),\n-                    ty::PredicateKind::ConstEvaluatable(b),\n-                ) => relator.relate(predicate.rebind(a), predicate.rebind(b)).is_ok(),\n-                (\n-                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n-                        ty_a,\n-                        lt_a,\n-                    ))),\n-                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n-                        ty_b,\n-                        lt_b,\n-                    ))),\n-                ) => {\n-                    relator.relate(predicate.rebind(ty_a), p.rebind(ty_b)).is_ok()\n-                        && relator.relate(predicate.rebind(lt_a), p.rebind(lt_b)).is_ok()\n-                }\n-                (ty::PredicateKind::WellFormed(arg_a), ty::PredicateKind::WellFormed(arg_b)) => {\n-                    relator.relate(predicate.rebind(arg_a), p.rebind(arg_b)).is_ok()\n-                }\n-                _ => predicate == p,\n+    // All of the custom error reporting logic is to preserve parity with the old\n+    // error messages.\n+    //\n+    // They can probably get removed with better treatment of the new `DropImpl`\n+    // obligation cause code, and perhaps some custom logic in `report_region_errors`.\n+\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        let mut guar = None;\n+        let mut root_predicates = FxHashSet::default();\n+        for error in errors {\n+            let root_predicate = error.root_obligation.predicate;\n+            if root_predicates.insert(root_predicate) {\n+                let item_span = tcx.def_span(adt_def_id);\n+                let self_descr = tcx.def_descr(adt_def_id.to_def_id());\n+                guar = Some(\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        error.root_obligation.cause.span,\n+                        E0367,\n+                        \"`Drop` impl requires `{root_predicate}` \\\n+                        but the {self_descr} it is implemented for does not\",\n+                    )\n+                    .span_note(item_span, \"the implementor must specify the same requirement\")\n+                    .emit(),\n+                );\n             }\n-        };\n-\n-        if !assumptions_in_impl_context.iter().copied().any(predicate_matches_closure) {\n-            let item_span = tcx.def_span(self_type_did);\n-            let self_descr = tcx.def_descr(self_type_did.to_def_id());\n-            let reported = struct_span_err!(\n-                tcx.sess,\n-                predicate_sp,\n-                E0367,\n-                \"`Drop` impl requires `{predicate}` but the {self_descr} it is implemented for does not\",\n-            )\n-            .span_note(item_span, \"the implementor must specify the same requirement\")\n-            .emit();\n-            result = Err(reported);\n         }\n+        return Err(guar.unwrap());\n     }\n \n-    result\n-}\n-\n-/// This is an implementation of the [`TypeRelation`] trait with the\n-/// aim of simply comparing for equality (without side-effects).\n-///\n-/// It is not intended to be used anywhere else other than here.\n-pub(crate) struct SimpleEqRelation<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-impl<'tcx> SimpleEqRelation<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> SimpleEqRelation<'tcx> {\n-        SimpleEqRelation { tcx, param_env }\n-    }\n-}\n-\n-impl<'tcx> TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-        self.param_env\n-    }\n-\n-    fn tag(&self) -> &'static str {\n-        \"dropck::SimpleEqRelation\"\n-    }\n-\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        _: ty::Variance,\n-        _info: ty::VarianceDiagInfo<'tcx>,\n-        a: T,\n-        b: T,\n-    ) -> RelateResult<'tcx, T> {\n-        // Here we ignore variance because we require drop impl's types\n-        // to be *exactly* the same as to the ones in the struct definition.\n-        self.relate(a, b)\n-    }\n-\n-    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"SimpleEqRelation::tys(a={:?}, b={:?})\", a, b);\n-        ty::relate::super_relate_tys(self, a, b)\n-    }\n-\n-    fn regions(\n-        &mut self,\n-        a: ty::Region<'tcx>,\n-        b: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        debug!(\"SimpleEqRelation::regions(a={:?}, b={:?})\", a, b);\n-\n-        // We can just equate the regions because LBRs have been\n-        // already anonymized.\n-        if a == b {\n-            Ok(a)\n-        } else {\n-            // I'm not sure is this `TypeError` is the right one, but\n-            // it should not matter as it won't be checked (the dropck\n-            // will emit its own, more informative and higher-level errors\n-            // in case anything goes wrong).\n-            Err(TypeError::RegionsPlaceholderMismatch)\n+    let errors = ocx.infcx.resolve_regions(&OutlivesEnvironment::new(param_env));\n+    if !errors.is_empty() {\n+        let mut guar = None;\n+        for error in errors {\n+            let item_span = tcx.def_span(adt_def_id);\n+            let self_descr = tcx.def_descr(adt_def_id.to_def_id());\n+            let outlives = match error {\n+                RegionResolutionError::ConcreteFailure(_, a, b) => format!(\"{b}: {a}\"),\n+                RegionResolutionError::GenericBoundFailure(_, generic, r) => {\n+                    format!(\"{generic}: {r}\")\n+                }\n+                RegionResolutionError::SubSupConflict(_, _, _, a, _, b, _) => format!(\"{b}: {a}\"),\n+                RegionResolutionError::UpperBoundUniverseConflict(a, _, _, _, b) => {\n+                    format!(\"{b}: {a}\", a = tcx.mk_re_var(a))\n+                }\n+            };\n+            guar = Some(\n+                struct_span_err!(\n+                    tcx.sess,\n+                    error.origin().span(),\n+                    E0367,\n+                    \"`Drop` impl requires `{outlives}` \\\n+                    but the {self_descr} it is implemented for does not\",\n+                )\n+                .span_note(item_span, \"the implementor must specify the same requirement\")\n+                .emit(),\n+            );\n         }\n+        return Err(guar.unwrap());\n     }\n \n-    fn consts(\n-        &mut self,\n-        a: ty::Const<'tcx>,\n-        b: ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n-        debug!(\"SimpleEqRelation::consts(a={:?}, b={:?})\", a, b);\n-        ty::relate::super_relate_consts(self, a, b)\n-    }\n-\n-    fn binders<T>(\n-        &mut self,\n-        a: ty::Binder<'tcx, T>,\n-        b: ty::Binder<'tcx, T>,\n-    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n-    where\n-        T: Relate<'tcx>,\n-    {\n-        debug!(\"SimpleEqRelation::binders({:?}: {:?}\", a, b);\n-\n-        // Anonymizing the LBRs is necessary to solve (Issue #59497).\n-        // After we do so, it should be totally fine to skip the binders.\n-        let anon_a = self.tcx.anonymize_bound_vars(a);\n-        let anon_b = self.tcx.anonymize_bound_vars(b);\n-        self.relate(anon_a.skip_binder(), anon_b.skip_binder())?;\n-\n-        Ok(a)\n-    }\n+    Ok(())\n }"}, {"sha": "b65817ee95e92e7aa437e570689416786f9985e7", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -64,8 +64,8 @@ pub fn provide(providers: &mut Providers) {\n         explicit_predicates_of: predicates_of::explicit_predicates_of,\n         super_predicates_of: predicates_of::super_predicates_of,\n         implied_predicates_of: predicates_of::implied_predicates_of,\n-        super_predicates_that_define_assoc_type:\n-            predicates_of::super_predicates_that_define_assoc_type,\n+        super_predicates_that_define_assoc_item:\n+            predicates_of::super_predicates_that_define_assoc_item,\n         trait_explicit_predicates_and_bounds: predicates_of::trait_explicit_predicates_and_bounds,\n         type_param_predicates: predicates_of::type_param_predicates,\n         trait_def,"}, {"sha": "6c06957d1ee12722ade8b4ef8446b856e6fa840e", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -565,7 +565,7 @@ pub(super) fn super_predicates_of(\n     implied_predicates_with_filter(tcx, trait_def_id.to_def_id(), PredicateFilter::SelfOnly)\n }\n \n-pub(super) fn super_predicates_that_define_assoc_type(\n+pub(super) fn super_predicates_that_define_assoc_item(\n     tcx: TyCtxt<'_>,\n     (trait_def_id, assoc_name): (DefId, Ident),\n ) -> ty::GenericPredicates<'_> {\n@@ -640,7 +640,7 @@ pub(super) fn implied_predicates_with_filter(\n         ),\n         PredicateFilter::SelfThatDefines(assoc_name) => (\n             // Convert the bounds that follow the colon (or equal) that reference the associated name\n-            icx.astconv().compute_bounds_that_match_assoc_type(self_param_ty, bounds, assoc_name),\n+            icx.astconv().compute_bounds_that_match_assoc_item(self_param_ty, bounds, assoc_name),\n             // Include where clause bounds for `Self` that reference the associated name\n             icx.type_parameter_bounds_in_generics(\n                 generics,\n@@ -819,7 +819,7 @@ impl<'tcx> ItemCtxt<'tcx> {\n             hir::GenericBound::Trait(poly_trait_ref, _) => {\n                 let trait_ref = &poly_trait_ref.trait_ref;\n                 if let Some(trait_did) = trait_ref.trait_def_id() {\n-                    self.tcx.trait_may_define_assoc_type(trait_did, assoc_name)\n+                    self.tcx.trait_may_define_assoc_item(trait_did, assoc_name)\n                 } else {\n                     false\n                 }"}, {"sha": "ab0dd01ce3aed72bf385a12fe496a8236885ce5a", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1652,27 +1652,28 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n             if binding.gen_args.parenthesized == hir::GenericArgsParentheses::ReturnTypeNotation {\n                 let bound_vars = if let Some(type_def_id) = type_def_id\n                     && self.tcx.def_kind(type_def_id) == DefKind::Trait\n-                    // FIXME(return_type_notation): We could bound supertrait methods.\n-                    && let Some(assoc_fn) = self\n-                        .tcx\n-                        .associated_items(type_def_id)\n-                        .find_by_name_and_kind(self.tcx, binding.ident, ty::AssocKind::Fn, type_def_id)\n+                    && let Some((mut bound_vars, assoc_fn)) =\n+                        BoundVarContext::supertrait_hrtb_vars(\n+                            self.tcx,\n+                            type_def_id,\n+                            binding.ident,\n+                            ty::AssocKind::Fn,\n+                        )\n                 {\n-                    self.tcx\n-                        .generics_of(assoc_fn.def_id)\n-                        .params\n-                        .iter()\n-                        .map(|param| match param.kind {\n+                    bound_vars.extend(self.tcx.generics_of(assoc_fn.def_id).params.iter().map(\n+                        |param| match param.kind {\n                             ty::GenericParamDefKind::Lifetime => ty::BoundVariableKind::Region(\n                                 ty::BoundRegionKind::BrNamed(param.def_id, param.name),\n                             ),\n                             ty::GenericParamDefKind::Type { .. } => ty::BoundVariableKind::Ty(\n                                 ty::BoundTyKind::Param(param.def_id, param.name),\n                             ),\n                             ty::GenericParamDefKind::Const { .. } => ty::BoundVariableKind::Const,\n-                        })\n-                        .chain(self.tcx.fn_sig(assoc_fn.def_id).subst_identity().bound_vars())\n-                        .collect()\n+                        },\n+                    ));\n+                    bound_vars\n+                        .extend(self.tcx.fn_sig(assoc_fn.def_id).subst_identity().bound_vars());\n+                    bound_vars\n                 } else {\n                     self.tcx.sess.delay_span_bug(\n                         binding.ident.span,\n@@ -1689,8 +1690,13 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                     });\n                 });\n             } else if let Some(type_def_id) = type_def_id {\n-                let bound_vars =\n-                    BoundVarContext::supertrait_hrtb_vars(self.tcx, type_def_id, binding.ident);\n+                let bound_vars = BoundVarContext::supertrait_hrtb_vars(\n+                    self.tcx,\n+                    type_def_id,\n+                    binding.ident,\n+                    ty::AssocKind::Type,\n+                )\n+                .map(|(bound_vars, _)| bound_vars);\n                 self.with(scope, |this| {\n                     let scope = Scope::Supertrait {\n                         bound_vars: bound_vars.unwrap_or_default(),\n@@ -1720,11 +1726,15 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         assoc_name: Ident,\n-    ) -> Option<Vec<ty::BoundVariableKind>> {\n-        let trait_defines_associated_type_named = |trait_def_id: DefId| {\n-            tcx.associated_items(trait_def_id)\n-                .find_by_name_and_kind(tcx, assoc_name, ty::AssocKind::Type, trait_def_id)\n-                .is_some()\n+        assoc_kind: ty::AssocKind,\n+    ) -> Option<(Vec<ty::BoundVariableKind>, &'tcx ty::AssocItem)> {\n+        let trait_defines_associated_item_named = |trait_def_id: DefId| {\n+            tcx.associated_items(trait_def_id).find_by_name_and_kind(\n+                tcx,\n+                assoc_name,\n+                assoc_kind,\n+                trait_def_id,\n+            )\n         };\n \n         use smallvec::{smallvec, SmallVec};\n@@ -1742,10 +1752,10 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                 _ => break None,\n             }\n \n-            if trait_defines_associated_type_named(def_id) {\n-                break Some(bound_vars.into_iter().collect());\n+            if let Some(assoc_item) = trait_defines_associated_item_named(def_id) {\n+                break Some((bound_vars.into_iter().collect(), assoc_item));\n             }\n-            let predicates = tcx.super_predicates_that_define_assoc_type((def_id, assoc_name));\n+            let predicates = tcx.super_predicates_that_define_assoc_item((def_id, assoc_name));\n             let obligations = predicates.predicates.iter().filter_map(|&(pred, _)| {\n                 let bound_predicate = pred.kind();\n                 match bound_predicate.skip_binder() {"}, {"sha": "379a88538a9219582b81683f348c217f215aa12d", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -6,7 +6,7 @@ use rustc_errors::{\n     MultiSpan,\n };\n use rustc_macros::{Diagnostic, Subdiagnostic};\n-use rustc_middle::ty::Ty;\n+use rustc_middle::ty::{self, print::TraitRefPrintOnlyTraitPath, Ty};\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n #[derive(Diagnostic)]\n@@ -512,10 +512,22 @@ pub(crate) struct ReturnTypeNotationEqualityBound {\n pub(crate) struct ReturnTypeNotationMissingMethod {\n     #[primary_span]\n     pub span: Span,\n-    pub trait_name: Symbol,\n+    pub ty_name: String,\n     pub assoc_name: Symbol,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_return_type_notation_conflicting_bound)]\n+#[note]\n+pub(crate) struct ReturnTypeNotationConflictingBound<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty_name: String,\n+    pub assoc_name: Symbol,\n+    pub first_bound: ty::Binder<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+    pub second_bound: ty::Binder<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(hir_analysis_placeholder_not_allowed_item_signatures, code = \"E0121\")]\n pub(crate) struct PlaceholderNotAllowedItemSignatures {\n@@ -657,7 +669,6 @@ pub enum ImplNotMarkedDefault {\n     #[note]\n     Err {\n         #[primary_span]\n-        #[label]\n         span: Span,\n         cname: Symbol,\n         ident: Symbol,"}, {"sha": "9e78e6acba54b206e76eb19af794b1af0a5bcbfc", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -854,9 +854,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let result = self\n             .resolve_fully_qualified_call(span, item_name, ty.normalized, qself.span, hir_id)\n             .or_else(|error| {\n+                let guar = self\n+                    .tcx\n+                    .sess\n+                    .delay_span_bug(span, \"method resolution should've emitted an error\");\n                 let result = match error {\n                     method::MethodError::PrivateMatch(kind, def_id, _) => Ok((kind, def_id)),\n-                    _ => Err(ErrorGuaranteed::unchecked_claim_error_was_emitted()),\n+                    _ => Err(guar),\n                 };\n \n                 // If we have a path like `MyTrait::missing_method`, then don't register"}, {"sha": "4b8fc7303a20c0bb0adaa42303f4e4fbdd8f74fb", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1300,6 +1300,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 opt_ty.unwrap_or_else(|| self.next_float_var())\n             }\n             ast::LitKind::Bool(_) => tcx.types.bool,\n+            ast::LitKind::CStr(_, _) => tcx.mk_imm_ref(\n+                tcx.lifetimes.re_static,\n+                tcx.type_of(tcx.require_lang_item(hir::LangItem::CStr, Some(lit.span)))\n+                    .skip_binder(),\n+            ),\n             ast::LitKind::Err => tcx.ty_error_misc(),\n         }\n     }"}, {"sha": "2a51439b0a973d8e791bd722cc2058e86d58242a", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -73,6 +73,8 @@ impl<'tcx> InferCtxt<'tcx> {\n         R: ObligationEmittingRelation<'tcx>,\n     {\n         let a_is_expected = relation.a_is_expected();\n+        debug_assert!(!a.has_escaping_bound_vars());\n+        debug_assert!(!b.has_escaping_bound_vars());\n \n         match (a.kind(), b.kind()) {\n             // Relate integral variables to other types\n@@ -163,6 +165,8 @@ impl<'tcx> InferCtxt<'tcx> {\n         R: ObligationEmittingRelation<'tcx>,\n     {\n         debug!(\"{}.consts({:?}, {:?})\", relation.tag(), a, b);\n+        debug_assert!(!a.has_escaping_bound_vars());\n+        debug_assert!(!b.has_escaping_bound_vars());\n         if a == b {\n             return Ok(a);\n         }\n@@ -238,22 +242,12 @@ impl<'tcx> InferCtxt<'tcx> {\n             (_, ty::ConstKind::Infer(InferConst::Var(vid))) => {\n                 return self.unify_const_variable(vid, a);\n             }\n-            (ty::ConstKind::Unevaluated(..), _) if self.tcx.lazy_normalization() => {\n-                // FIXME(#59490): Need to remove the leak check to accommodate\n-                // escaping bound variables here.\n-                if !a.has_escaping_bound_vars() && !b.has_escaping_bound_vars() {\n-                    relation.register_const_equate_obligation(a, b);\n-                }\n+            (ty::ConstKind::Unevaluated(..), _) | (_, ty::ConstKind::Unevaluated(..))\n+                if self.tcx.lazy_normalization() =>\n+            {\n+                relation.register_const_equate_obligation(a, b);\n                 return Ok(b);\n             }\n-            (_, ty::ConstKind::Unevaluated(..)) if self.tcx.lazy_normalization() => {\n-                // FIXME(#59490): Need to remove the leak check to accommodate\n-                // escaping bound variables here.\n-                if !a.has_escaping_bound_vars() && !b.has_escaping_bound_vars() {\n-                    relation.register_const_equate_obligation(a, b);\n-                }\n-                return Ok(a);\n-            }\n             _ => {}\n         }\n "}, {"sha": "8482ae2aa38c81f7645036c9d044aac9513ac020", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -102,6 +102,17 @@ pub enum RegionResolutionError<'tcx> {\n     ),\n }\n \n+impl<'tcx> RegionResolutionError<'tcx> {\n+    pub fn origin(&self) -> &SubregionOrigin<'tcx> {\n+        match self {\n+            RegionResolutionError::ConcreteFailure(origin, _, _)\n+            | RegionResolutionError::GenericBoundFailure(origin, _, _)\n+            | RegionResolutionError::SubSupConflict(_, _, origin, _, _, _, _)\n+            | RegionResolutionError::UpperBoundUniverseConflict(_, _, _, origin, _) => origin,\n+        }\n+    }\n+}\n+\n struct RegionAndOrigin<'tcx> {\n     region: Region<'tcx>,\n     origin: SubregionOrigin<'tcx>,"}, {"sha": "74a78f38024e0309eb1029147caf64d996e93abd", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -380,11 +380,11 @@ pub fn transitive_bounds<'tcx>(\n }\n \n /// A specialized variant of `elaborate` that only elaborates trait references that may\n-/// define the given associated type `assoc_name`. It uses the\n-/// `super_predicates_that_define_assoc_type` query to avoid enumerating super-predicates that\n+/// define the given associated item with the name `assoc_name`. It uses the\n+/// `super_predicates_that_define_assoc_item` query to avoid enumerating super-predicates that\n /// aren't related to `assoc_item`. This is used when resolving types like `Self::Item` or\n /// `T::Item` and helps to avoid cycle errors (see e.g. #35237).\n-pub fn transitive_bounds_that_define_assoc_type<'tcx>(\n+pub fn transitive_bounds_that_define_assoc_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n     assoc_name: Ident,\n@@ -397,7 +397,7 @@ pub fn transitive_bounds_that_define_assoc_type<'tcx>(\n             let anon_trait_ref = tcx.anonymize_bound_vars(trait_ref);\n             if visited.insert(anon_trait_ref) {\n                 let super_predicates =\n-                    tcx.super_predicates_that_define_assoc_type((trait_ref.def_id(), assoc_name));\n+                    tcx.super_predicates_that_define_assoc_item((trait_ref.def_id(), assoc_name));\n                 for (super_predicate, _) in super_predicates.predicates {\n                     let subst_predicate = super_predicate.subst_supertrait(tcx, &trait_ref);\n                     if let Some(binder) = subst_predicate.to_opt_poly_trait_pred() {"}, {"sha": "9d9f4ee13f402dc9c6374b8ca20cbd6b65e86204", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 48, "deletions": 28, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -9,11 +9,12 @@ use rustc_data_structures::OnDrop;\n use rustc_errors::registry::Registry;\n use rustc_errors::{ErrorGuaranteed, Handler};\n use rustc_lint::LintStore;\n-use rustc_middle::ty;\n+use rustc_middle::{bug, ty};\n use rustc_parse::maybe_new_parser_from_source_str;\n use rustc_query_impl::QueryCtxt;\n use rustc_query_system::query::print_query_stack;\n-use rustc_session::config::{self, CheckCfg, ErrorOutputType, Input, OutputFilenames};\n+use rustc_session::config::{self, ErrorOutputType, Input, OutputFilenames};\n+use rustc_session::config::{CheckCfg, ExpectedValues};\n use rustc_session::lint;\n use rustc_session::parse::{CrateConfig, ParseSess};\n use rustc_session::Session;\n@@ -121,9 +122,9 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String\n /// Converts strings provided as `--check-cfg [specs]` into a `CheckCfg`.\n pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n     rustc_span::create_default_session_if_not_set_then(move |_| {\n-        let mut cfg = CheckCfg::default();\n+        let mut check_cfg = CheckCfg::default();\n \n-        'specs: for s in specs {\n+        for s in specs {\n             let sess = ParseSess::with_silent_emitter(Some(format!(\n                 \"this error occurred on the command line: `--check-cfg={s}`\"\n             )));\n@@ -137,76 +138,95 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                             concat!(\"invalid `--check-cfg` argument: `{}` (\", $reason, \")\"),\n                             s\n                         ),\n-                    );\n+                    )\n                 };\n             }\n \n+            let expected_error = || {\n+                error!(\n+                    \"expected `names(name1, name2, ... nameN)` or \\\n+                        `values(name, \\\"value1\\\", \\\"value2\\\", ... \\\"valueN\\\")`\"\n+                )\n+            };\n+\n             match maybe_new_parser_from_source_str(&sess, filename, s.to_string()) {\n                 Ok(mut parser) => match parser.parse_meta_item() {\n                     Ok(meta_item) if parser.token == token::Eof => {\n                         if let Some(args) = meta_item.meta_item_list() {\n                             if meta_item.has_name(sym::names) {\n-                                let names_valid =\n-                                    cfg.names_valid.get_or_insert_with(|| FxHashSet::default());\n+                                check_cfg.exhaustive_names = true;\n                                 for arg in args {\n                                     if arg.is_word() && arg.ident().is_some() {\n                                         let ident = arg.ident().expect(\"multi-segment cfg key\");\n-                                        names_valid.insert(ident.name.to_string());\n+                                        check_cfg\n+                                            .expecteds\n+                                            .entry(ident.name.to_string())\n+                                            .or_insert(ExpectedValues::Any);\n                                     } else {\n                                         error!(\"`names()` arguments must be simple identifiers\");\n                                     }\n                                 }\n-                                continue 'specs;\n                             } else if meta_item.has_name(sym::values) {\n                                 if let Some((name, values)) = args.split_first() {\n                                     if name.is_word() && name.ident().is_some() {\n                                         let ident = name.ident().expect(\"multi-segment cfg key\");\n-                                        let ident_values = cfg\n-                                            .values_valid\n+                                        let expected_values = check_cfg\n+                                            .expecteds\n                                             .entry(ident.name.to_string())\n-                                            .or_insert_with(|| FxHashSet::default());\n+                                            .or_insert_with(|| {\n+                                                ExpectedValues::Some(FxHashSet::default())\n+                                            });\n+\n+                                        let ExpectedValues::Some(expected_values) = expected_values else {\n+                                            bug!(\"shoudn't be possible\")\n+                                        };\n \n                                         for val in values {\n                                             if let Some(LitKind::Str(s, _)) =\n                                                 val.lit().map(|lit| &lit.kind)\n                                             {\n-                                                ident_values.insert(s.to_string());\n+                                                expected_values.insert(Some(s.to_string()));\n                                             } else {\n                                                 error!(\n                                                     \"`values()` arguments must be string literals\"\n                                                 );\n                                             }\n                                         }\n \n-                                        continue 'specs;\n+                                        if values.is_empty() {\n+                                            expected_values.insert(None);\n+                                        }\n                                     } else {\n                                         error!(\n                                             \"`values()` first argument must be a simple identifier\"\n                                         );\n                                     }\n                                 } else if args.is_empty() {\n-                                    cfg.well_known_values = true;\n-                                    continue 'specs;\n+                                    check_cfg.exhaustive_values = true;\n+                                } else {\n+                                    expected_error();\n                                 }\n+                            } else {\n+                                expected_error();\n                             }\n+                        } else {\n+                            expected_error();\n                         }\n                     }\n-                    Ok(..) => {}\n-                    Err(err) => err.cancel(),\n+                    Ok(..) => expected_error(),\n+                    Err(err) => {\n+                        err.cancel();\n+                        expected_error();\n+                    }\n                 },\n-                Err(errs) => drop(errs),\n+                Err(errs) => {\n+                    drop(errs);\n+                    expected_error();\n+                }\n             }\n-\n-            error!(\n-                \"expected `names(name1, name2, ... nameN)` or \\\n-                `values(name, \\\"value1\\\", \\\"value2\\\", ... \\\"valueN\\\")`\"\n-            );\n         }\n \n-        if let Some(names_valid) = &mut cfg.names_valid {\n-            names_valid.extend(cfg.values_valid.keys().cloned());\n-        }\n-        cfg\n+        check_cfg\n     })\n }\n "}, {"sha": "1bae771e373d466e3bc1ca09ef7bd74d04049fa0", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -69,6 +69,7 @@ where\n         is_private_dep: false,\n         add_prelude: true,\n         nounused_dep: false,\n+        force: false,\n     }\n }\n \n@@ -547,6 +548,7 @@ fn test_codegen_options_tracking_hash() {\n     untracked!(ar, String::from(\"abc\"));\n     untracked!(codegen_units, Some(42));\n     untracked!(default_linker_libraries, true);\n+    untracked!(dlltool, Some(PathBuf::from(\"custom_dlltool.exe\")));\n     untracked!(extra_filename, String::from(\"extra-filename\"));\n     untracked!(incremental, Some(String::from(\"abc\")));\n     // `link_arg` is omitted because it just forwards to `link_args`.\n@@ -651,7 +653,6 @@ fn test_unstable_options_tracking_hash() {\n     untracked!(assert_incr_state, Some(String::from(\"loaded\")));\n     untracked!(deduplicate_diagnostics, false);\n     untracked!(dep_tasks, true);\n-    untracked!(dlltool, Some(PathBuf::from(\"custom_dlltool.exe\")));\n     untracked!(dont_buffer_diagnostics, true);\n     untracked!(dump_dep_graph, true);\n     untracked!(dump_drop_tracking_cfg, Some(\"cfg.dot\".to_string()));"}, {"sha": "c07dc19a0ac3ac2916caa6ff8d55ba81667bd294", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 57, "deletions": 33, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -186,12 +186,16 @@ pub enum LiteralKind {\n     Str { terminated: bool },\n     /// \"b\"abc\"\", \"b\"abc\"\n     ByteStr { terminated: bool },\n+    /// `c\"abc\"`, `c\"abc`\n+    CStr { terminated: bool },\n     /// \"r\"abc\"\", \"r#\"abc\"#\", \"r####\"ab\"###\"c\"####\", \"r#\"a\". `None` indicates\n     /// an invalid literal.\n     RawStr { n_hashes: Option<u8> },\n     /// \"br\"abc\"\", \"br#\"abc\"#\", \"br####\"ab\"###\"c\"####\", \"br#\"a\". `None`\n     /// indicates an invalid literal.\n     RawByteStr { n_hashes: Option<u8> },\n+    /// `cr\"abc\"`, \"cr#\"abc\"#\", `cr#\"a`. `None` indicates an invalid literal.\n+    RawCStr { n_hashes: Option<u8> },\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n@@ -357,39 +361,18 @@ impl Cursor<'_> {\n             },\n \n             // Byte literal, byte string literal, raw byte string literal or identifier.\n-            'b' => match (self.first(), self.second()) {\n-                ('\\'', _) => {\n-                    self.bump();\n-                    let terminated = self.single_quoted_string();\n-                    let suffix_start = self.pos_within_token();\n-                    if terminated {\n-                        self.eat_literal_suffix();\n-                    }\n-                    let kind = Byte { terminated };\n-                    Literal { kind, suffix_start }\n-                }\n-                ('\"', _) => {\n-                    self.bump();\n-                    let terminated = self.double_quoted_string();\n-                    let suffix_start = self.pos_within_token();\n-                    if terminated {\n-                        self.eat_literal_suffix();\n-                    }\n-                    let kind = ByteStr { terminated };\n-                    Literal { kind, suffix_start }\n-                }\n-                ('r', '\"') | ('r', '#') => {\n-                    self.bump();\n-                    let res = self.raw_double_quoted_string(2);\n-                    let suffix_start = self.pos_within_token();\n-                    if res.is_ok() {\n-                        self.eat_literal_suffix();\n-                    }\n-                    let kind = RawByteStr { n_hashes: res.ok() };\n-                    Literal { kind, suffix_start }\n-                }\n-                _ => self.ident_or_unknown_prefix(),\n-            },\n+            'b' => self.c_or_byte_string(\n+                |terminated| ByteStr { terminated },\n+                |n_hashes| RawByteStr { n_hashes },\n+                Some(|terminated| Byte { terminated }),\n+            ),\n+\n+            // c-string literal, raw c-string literal or identifier.\n+            'c' => self.c_or_byte_string(\n+                |terminated| CStr { terminated },\n+                |n_hashes| RawCStr { n_hashes },\n+                None,\n+            ),\n \n             // Identifier (this should be checked after other variant that can\n             // start as identifier).\n@@ -553,6 +536,47 @@ impl Cursor<'_> {\n         }\n     }\n \n+    fn c_or_byte_string(\n+        &mut self,\n+        mk_kind: impl FnOnce(bool) -> LiteralKind,\n+        mk_kind_raw: impl FnOnce(Option<u8>) -> LiteralKind,\n+        single_quoted: Option<fn(bool) -> LiteralKind>,\n+    ) -> TokenKind {\n+        match (self.first(), self.second(), single_quoted) {\n+            ('\\'', _, Some(mk_kind)) => {\n+                self.bump();\n+                let terminated = self.single_quoted_string();\n+                let suffix_start = self.pos_within_token();\n+                if terminated {\n+                    self.eat_literal_suffix();\n+                }\n+                let kind = mk_kind(terminated);\n+                Literal { kind, suffix_start }\n+            }\n+            ('\"', _, _) => {\n+                self.bump();\n+                let terminated = self.double_quoted_string();\n+                let suffix_start = self.pos_within_token();\n+                if terminated {\n+                    self.eat_literal_suffix();\n+                }\n+                let kind = mk_kind(terminated);\n+                Literal { kind, suffix_start }\n+            }\n+            ('r', '\"', _) | ('r', '#', _) => {\n+                self.bump();\n+                let res = self.raw_double_quoted_string(2);\n+                let suffix_start = self.pos_within_token();\n+                if res.is_ok() {\n+                    self.eat_literal_suffix();\n+                }\n+                let kind = mk_kind_raw(res.ok());\n+                Literal { kind, suffix_start }\n+            }\n+            _ => self.ident_or_unknown_prefix(),\n+        }\n+    }\n+\n     fn number(&mut self, first_digit: char) -> LiteralKind {\n         debug_assert!('0' <= self.prev() && self.prev() <= '9');\n         let mut base = Base::Decimal;"}, {"sha": "c9ad54d8d980609d15416e4bdcda83df88b3b3c5", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 176, "deletions": 102, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -86,10 +86,45 @@ where\n             let res = unescape_char_or_byte(&mut chars, mode == Mode::Byte);\n             callback(0..(src.len() - chars.as_str().len()), res);\n         }\n-        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(src, mode == Mode::ByteStr, callback),\n+        Mode::Str | Mode::ByteStr => unescape_str_common(src, mode, callback),\n+\n         Mode::RawStr | Mode::RawByteStr => {\n             unescape_raw_str_or_raw_byte_str(src, mode == Mode::RawByteStr, callback)\n         }\n+        Mode::CStr | Mode::RawCStr => unreachable!(),\n+    }\n+}\n+\n+/// A unit within CStr. Must not be a nul character.\n+pub enum CStrUnit {\n+    Byte(u8),\n+    Char(char),\n+}\n+\n+impl From<u8> for CStrUnit {\n+    fn from(value: u8) -> Self {\n+        CStrUnit::Byte(value)\n+    }\n+}\n+\n+impl From<char> for CStrUnit {\n+    fn from(value: char) -> Self {\n+        CStrUnit::Char(value)\n+    }\n+}\n+\n+pub fn unescape_c_string<F>(src: &str, mode: Mode, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, Result<CStrUnit, EscapeError>),\n+{\n+    if mode == Mode::RawCStr {\n+        unescape_raw_str_or_raw_byte_str(\n+            src,\n+            mode.characters_should_be_ascii(),\n+            &mut |r, result| callback(r, result.map(CStrUnit::Char)),\n+        );\n+    } else {\n+        unescape_str_common(src, mode, callback);\n     }\n }\n \n@@ -114,34 +149,69 @@ pub enum Mode {\n     ByteStr,\n     RawStr,\n     RawByteStr,\n+    CStr,\n+    RawCStr,\n }\n \n impl Mode {\n     pub fn in_double_quotes(self) -> bool {\n         match self {\n-            Mode::Str | Mode::ByteStr | Mode::RawStr | Mode::RawByteStr => true,\n+            Mode::Str\n+            | Mode::ByteStr\n+            | Mode::RawStr\n+            | Mode::RawByteStr\n+            | Mode::CStr\n+            | Mode::RawCStr => true,\n             Mode::Char | Mode::Byte => false,\n         }\n     }\n \n-    pub fn is_byte(self) -> bool {\n+    /// Non-byte literals should have `\\xXX` escapes that are within the ASCII range.\n+    pub fn ascii_escapes_should_be_ascii(self) -> bool {\n+        match self {\n+            Mode::Char | Mode::Str | Mode::RawStr => true,\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr | Mode::CStr | Mode::RawCStr => false,\n+        }\n+    }\n+\n+    /// Whether characters within the literal must be within the ASCII range\n+    pub fn characters_should_be_ascii(self) -> bool {\n+        match self {\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n+            Mode::Char | Mode::Str | Mode::RawStr | Mode::CStr | Mode::RawCStr => false,\n+        }\n+    }\n+\n+    /// Byte literals do not allow unicode escape.\n+    pub fn is_unicode_escape_disallowed(self) -> bool {\n         match self {\n             Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n-            Mode::Char | Mode::Str | Mode::RawStr => false,\n+            Mode::Char | Mode::Str | Mode::RawStr | Mode::CStr | Mode::RawCStr => false,\n+        }\n+    }\n+\n+    pub fn prefix_noraw(self) -> &'static str {\n+        match self {\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr => \"b\",\n+            Mode::CStr | Mode::RawCStr => \"c\",\n+            Mode::Char | Mode::Str | Mode::RawStr => \"\",\n         }\n     }\n }\n \n-fn scan_escape(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n+fn scan_escape<T: From<u8> + From<char>>(\n+    chars: &mut Chars<'_>,\n+    mode: Mode,\n+) -> Result<T, EscapeError> {\n     // Previous character was '\\\\', unescape what follows.\n     let res = match chars.next().ok_or(EscapeError::LoneSlash)? {\n-        '\"' => '\"',\n-        'n' => '\\n',\n-        'r' => '\\r',\n-        't' => '\\t',\n-        '\\\\' => '\\\\',\n-        '\\'' => '\\'',\n-        '0' => '\\0',\n+        '\"' => b'\"',\n+        'n' => b'\\n',\n+        'r' => b'\\r',\n+        't' => b'\\t',\n+        '\\\\' => b'\\\\',\n+        '\\'' => b'\\'',\n+        '0' => b'\\0',\n \n         'x' => {\n             // Parse hexadecimal character code.\n@@ -154,76 +224,78 @@ fn scan_escape(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError\n \n             let value = hi * 16 + lo;\n \n-            // For a non-byte literal verify that it is within ASCII range.\n-            if !is_byte && !is_ascii(value) {\n+            if mode.ascii_escapes_should_be_ascii() && !is_ascii(value) {\n                 return Err(EscapeError::OutOfRangeHexEscape);\n             }\n-            let value = value as u8;\n \n-            value as char\n+            value as u8\n         }\n \n-        'u' => {\n-            // We've parsed '\\u', now we have to parse '{..}'.\n+        'u' => return scan_unicode(chars, mode.is_unicode_escape_disallowed()).map(Into::into),\n+        _ => return Err(EscapeError::InvalidEscape),\n+    };\n+    Ok(res.into())\n+}\n+\n+fn scan_unicode(\n+    chars: &mut Chars<'_>,\n+    is_unicode_escape_disallowed: bool,\n+) -> Result<char, EscapeError> {\n+    // We've parsed '\\u', now we have to parse '{..}'.\n \n-            if chars.next() != Some('{') {\n-                return Err(EscapeError::NoBraceInUnicodeEscape);\n-            }\n+    if chars.next() != Some('{') {\n+        return Err(EscapeError::NoBraceInUnicodeEscape);\n+    }\n \n-            // First character must be a hexadecimal digit.\n-            let mut n_digits = 1;\n-            let mut value: u32 = match chars.next().ok_or(EscapeError::UnclosedUnicodeEscape)? {\n-                '_' => return Err(EscapeError::LeadingUnderscoreUnicodeEscape),\n-                '}' => return Err(EscapeError::EmptyUnicodeEscape),\n-                c => c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?,\n-            };\n-\n-            // First character is valid, now parse the rest of the number\n-            // and closing brace.\n-            loop {\n-                match chars.next() {\n-                    None => return Err(EscapeError::UnclosedUnicodeEscape),\n-                    Some('_') => continue,\n-                    Some('}') => {\n-                        if n_digits > 6 {\n-                            return Err(EscapeError::OverlongUnicodeEscape);\n-                        }\n-\n-                        // Incorrect syntax has higher priority for error reporting\n-                        // than unallowed value for a literal.\n-                        if is_byte {\n-                            return Err(EscapeError::UnicodeEscapeInByte);\n-                        }\n-\n-                        break std::char::from_u32(value).ok_or_else(|| {\n-                            if value > 0x10FFFF {\n-                                EscapeError::OutOfRangeUnicodeEscape\n-                            } else {\n-                                EscapeError::LoneSurrogateUnicodeEscape\n-                            }\n-                        })?;\n-                    }\n-                    Some(c) => {\n-                        let digit: u32 =\n-                            c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?;\n-                        n_digits += 1;\n-                        if n_digits > 6 {\n-                            // Stop updating value since we're sure that it's incorrect already.\n-                            continue;\n-                        }\n-                        value = value * 16 + digit;\n+    // First character must be a hexadecimal digit.\n+    let mut n_digits = 1;\n+    let mut value: u32 = match chars.next().ok_or(EscapeError::UnclosedUnicodeEscape)? {\n+        '_' => return Err(EscapeError::LeadingUnderscoreUnicodeEscape),\n+        '}' => return Err(EscapeError::EmptyUnicodeEscape),\n+        c => c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?,\n+    };\n+\n+    // First character is valid, now parse the rest of the number\n+    // and closing brace.\n+    loop {\n+        match chars.next() {\n+            None => return Err(EscapeError::UnclosedUnicodeEscape),\n+            Some('_') => continue,\n+            Some('}') => {\n+                if n_digits > 6 {\n+                    return Err(EscapeError::OverlongUnicodeEscape);\n+                }\n+\n+                // Incorrect syntax has higher priority for error reporting\n+                // than unallowed value for a literal.\n+                if is_unicode_escape_disallowed {\n+                    return Err(EscapeError::UnicodeEscapeInByte);\n+                }\n+\n+                break std::char::from_u32(value).ok_or_else(|| {\n+                    if value > 0x10FFFF {\n+                        EscapeError::OutOfRangeUnicodeEscape\n+                    } else {\n+                        EscapeError::LoneSurrogateUnicodeEscape\n                     }\n-                };\n+                });\n             }\n-        }\n-        _ => return Err(EscapeError::InvalidEscape),\n-    };\n-    Ok(res)\n+            Some(c) => {\n+                let digit: u32 = c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?;\n+                n_digits += 1;\n+                if n_digits > 6 {\n+                    // Stop updating value since we're sure that it's incorrect already.\n+                    continue;\n+                }\n+                value = value * 16 + digit;\n+            }\n+        };\n+    }\n }\n \n #[inline]\n-fn ascii_check(c: char, is_byte: bool) -> Result<char, EscapeError> {\n-    if is_byte && !c.is_ascii() {\n+fn ascii_check(c: char, characters_should_be_ascii: bool) -> Result<char, EscapeError> {\n+    if characters_should_be_ascii && !c.is_ascii() {\n         // Byte literal can't be a non-ascii character.\n         Err(EscapeError::NonAsciiCharInByte)\n     } else {\n@@ -234,7 +306,7 @@ fn ascii_check(c: char, is_byte: bool) -> Result<char, EscapeError> {\n fn unescape_char_or_byte(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n     let c = chars.next().ok_or(EscapeError::ZeroChars)?;\n     let res = match c {\n-        '\\\\' => scan_escape(chars, is_byte),\n+        '\\\\' => scan_escape(chars, if is_byte { Mode::Byte } else { Mode::Char }),\n         '\\n' | '\\t' | '\\'' => Err(EscapeError::EscapeOnlyChar),\n         '\\r' => Err(EscapeError::BareCarriageReturn),\n         _ => ascii_check(c, is_byte),\n@@ -247,9 +319,9 @@ fn unescape_char_or_byte(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, E\n \n /// Takes a contents of a string literal (without quotes) and produces a\n /// sequence of escaped characters or errors.\n-fn unescape_str_or_byte_str<F>(src: &str, is_byte: bool, callback: &mut F)\n+fn unescape_str_common<F, T: From<u8> + From<char>>(src: &str, mode: Mode, callback: &mut F)\n where\n-    F: FnMut(Range<usize>, Result<char, EscapeError>),\n+    F: FnMut(Range<usize>, Result<T, EscapeError>),\n {\n     let mut chars = src.chars();\n \n@@ -266,47 +338,49 @@ where\n                         // if unescaped '\\' character is followed by '\\n'.\n                         // For details see [Rust language reference]\n                         // (https://doc.rust-lang.org/reference/tokens.html#string-literals).\n-                        skip_ascii_whitespace(&mut chars, start, callback);\n+                        skip_ascii_whitespace(&mut chars, start, &mut |range, err| {\n+                            callback(range, Err(err))\n+                        });\n                         continue;\n                     }\n-                    _ => scan_escape(&mut chars, is_byte),\n+                    _ => scan_escape::<T>(&mut chars, mode),\n                 }\n             }\n-            '\\n' => Ok('\\n'),\n-            '\\t' => Ok('\\t'),\n+            '\\n' => Ok(b'\\n'.into()),\n+            '\\t' => Ok(b'\\t'.into()),\n             '\"' => Err(EscapeError::EscapeOnlyChar),\n             '\\r' => Err(EscapeError::BareCarriageReturn),\n-            _ => ascii_check(c, is_byte),\n+            _ => ascii_check(c, mode.characters_should_be_ascii()).map(Into::into),\n         };\n         let end = src.len() - chars.as_str().len();\n-        callback(start..end, res);\n+        callback(start..end, res.map(Into::into));\n     }\n+}\n \n-    fn skip_ascii_whitespace<F>(chars: &mut Chars<'_>, start: usize, callback: &mut F)\n-    where\n-        F: FnMut(Range<usize>, Result<char, EscapeError>),\n-    {\n-        let tail = chars.as_str();\n-        let first_non_space = tail\n-            .bytes()\n-            .position(|b| b != b' ' && b != b'\\t' && b != b'\\n' && b != b'\\r')\n-            .unwrap_or(tail.len());\n-        if tail[1..first_non_space].contains('\\n') {\n-            // The +1 accounts for the escaping slash.\n-            let end = start + first_non_space + 1;\n-            callback(start..end, Err(EscapeError::MultipleSkippedLinesWarning));\n-        }\n-        let tail = &tail[first_non_space..];\n-        if let Some(c) = tail.chars().nth(0) {\n-            if c.is_whitespace() {\n-                // For error reporting, we would like the span to contain the character that was not\n-                // skipped. The +1 is necessary to account for the leading \\ that started the escape.\n-                let end = start + first_non_space + c.len_utf8() + 1;\n-                callback(start..end, Err(EscapeError::UnskippedWhitespaceWarning));\n-            }\n+fn skip_ascii_whitespace<F>(chars: &mut Chars<'_>, start: usize, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, EscapeError),\n+{\n+    let tail = chars.as_str();\n+    let first_non_space = tail\n+        .bytes()\n+        .position(|b| b != b' ' && b != b'\\t' && b != b'\\n' && b != b'\\r')\n+        .unwrap_or(tail.len());\n+    if tail[1..first_non_space].contains('\\n') {\n+        // The +1 accounts for the escaping slash.\n+        let end = start + first_non_space + 1;\n+        callback(start..end, EscapeError::MultipleSkippedLinesWarning);\n+    }\n+    let tail = &tail[first_non_space..];\n+    if let Some(c) = tail.chars().nth(0) {\n+        if c.is_whitespace() {\n+            // For error reporting, we would like the span to contain the character that was not\n+            // skipped. The +1 is necessary to account for the leading \\ that started the escape.\n+            let end = start + first_non_space + c.len_utf8() + 1;\n+            callback(start..end, EscapeError::UnskippedWhitespaceWarning);\n         }\n-        *chars = tail.chars();\n     }\n+    *chars = tail.chars();\n }\n \n /// Takes a contents of a string literal (without quotes) and produces a"}, {"sha": "0b7a704eb57dbbbcb56dc3ac074f425c71695b59", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 16, "deletions": 36, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -63,6 +63,7 @@ use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt, VariantDef};\n+use rustc_session::config::ExpectedValues;\n use rustc_session::lint::{BuiltinLintDiagnostics, FutureIncompatibilityReason};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n@@ -116,8 +117,7 @@ impl EarlyLintPass for WhileTrue {\n     #[inline]\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         if let ast::ExprKind::While(cond, _, label) = &e.kind\n-            && let cond = pierce_parens(cond)\n-            && let ast::ExprKind::Lit(token_lit) = cond.kind\n+            && let ast::ExprKind::Lit(token_lit) = pierce_parens(cond).kind\n             && let token::Lit { kind: token::Bool, symbol: kw::True, .. } = token_lit\n             && !cond.span.from_expansion()\n         {\n@@ -546,32 +546,13 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n-        match it.kind {\n-            hir::ItemKind::Trait(..) => {\n-                // Issue #11592: traits are always considered exported, even when private.\n-                if cx.tcx.visibility(it.owner_id)\n-                    == ty::Visibility::Restricted(\n-                        cx.tcx.parent_module_from_def_id(it.owner_id.def_id).to_def_id(),\n-                    )\n-                {\n-                    return;\n-                }\n-            }\n-            hir::ItemKind::TyAlias(..)\n-            | hir::ItemKind::Fn(..)\n-            | hir::ItemKind::Macro(..)\n-            | hir::ItemKind::Mod(..)\n-            | hir::ItemKind::Enum(..)\n-            | hir::ItemKind::Struct(..)\n-            | hir::ItemKind::Union(..)\n-            | hir::ItemKind::Const(..)\n-            | hir::ItemKind::Static(..) => {}\n-\n-            _ => return,\n-        };\n+        // Previously the Impl and Use types have been excluded from missing docs,\n+        // so we will continue to exclude them for compatibility\n+        if let hir::ItemKind::Impl(..) | hir::ItemKind::Use(..) = it.kind {\n+            return;\n+        }\n \n         let (article, desc) = cx.tcx.article_and_description(it.owner_id.to_def_id());\n-\n         self.check_missing_docs_attrs(cx, it.owner_id.def_id, article, desc);\n     }\n \n@@ -3306,16 +3287,15 @@ impl EarlyLintPass for UnexpectedCfgs {\n         let cfg = &cx.sess().parse_sess.config;\n         let check_cfg = &cx.sess().parse_sess.check_config;\n         for &(name, value) in cfg {\n-            if let Some(names_valid) = &check_cfg.names_valid && !names_valid.contains(&name){\n-                cx.emit_lint(UNEXPECTED_CFGS, BuiltinUnexpectedCliConfigName {\n-                    name,\n-                });\n-            }\n-            if let Some(value) = value && let Some(values) = check_cfg.values_valid.get(&name) && !values.contains(&value) {\n-                cx.emit_lint(\n-                    UNEXPECTED_CFGS,\n-                    BuiltinUnexpectedCliConfigValue { name, value },\n-                );\n+            match check_cfg.expecteds.get(&name) {\n+                Some(ExpectedValues::Some(values)) if !values.contains(&value) => {\n+                    let value = value.unwrap_or(kw::Empty);\n+                    cx.emit_lint(UNEXPECTED_CFGS, BuiltinUnexpectedCliConfigValue { name, value });\n+                }\n+                None if check_cfg.exhaustive_names => {\n+                    cx.emit_lint(UNEXPECTED_CFGS, BuiltinUnexpectedCliConfigName { name });\n+                }\n+                _ => { /* expected */ }\n             }\n         }\n     }"}, {"sha": "53d7cf74cde53db24caf9e5dd05b71b97eae28f3", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 54, "deletions": 16, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -36,6 +36,7 @@ use rustc_middle::middle::stability;\n use rustc_middle::ty::layout::{LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, print::Printer, subst::GenericArg, RegisteredTools, Ty, TyCtxt};\n+use rustc_session::config::ExpectedValues;\n use rustc_session::lint::{BuiltinLintDiagnostics, LintExpectationId};\n use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId};\n use rustc_session::Session;\n@@ -768,22 +769,52 @@ pub trait LintContext: Sized {\n                     db.help(help);\n                     db.note(\"see the asm section of Rust By Example <https://doc.rust-lang.org/nightly/rust-by-example/unsafe/asm.html#labels> for more information\");\n                 },\n-                BuiltinLintDiagnostics::UnexpectedCfg((name, name_span), None) => {\n-                    let Some(names_valid) = &sess.parse_sess.check_config.names_valid else {\n-                        bug!(\"it shouldn't be possible to have a diagnostic on a name if name checking is not enabled\");\n-                    };\n-                    let possibilities: Vec<Symbol> = names_valid.iter().map(|s| *s).collect();\n+                BuiltinLintDiagnostics::UnexpectedCfgName((name, name_span), value) => {\n+                    let possibilities: Vec<Symbol> = sess.parse_sess.check_config.expecteds.keys().map(|s| *s).collect();\n \n                     // Suggest the most probable if we found one\n                     if let Some(best_match) = find_best_match_for_name(&possibilities, name, None) {\n-                        db.span_suggestion(name_span, \"did you mean\", best_match, Applicability::MaybeIncorrect);\n+                        if let Some(ExpectedValues::Some(best_match_values)) =\n+                            sess.parse_sess.check_config.expecteds.get(&best_match) {\n+                            let mut possibilities = best_match_values.iter()\n+                                .flatten()\n+                                .map(Symbol::as_str)\n+                                .collect::<Vec<_>>();\n+                            possibilities.sort();\n+\n+                            if let Some((value, value_span)) = value {\n+                                if best_match_values.contains(&Some(value)) {\n+                                    db.span_suggestion(name_span, \"there is a config with a similar name and value\", best_match, Applicability::MaybeIncorrect);\n+                                } else if best_match_values.contains(&None) {\n+                                    db.span_suggestion(name_span.to(value_span), \"there is a config with a similar name and no value\", best_match, Applicability::MaybeIncorrect);\n+                                } else if let Some(first_value) = possibilities.first() {\n+                                    db.span_suggestion(name_span.to(value_span), \"there is a config with a similar name and different values\", format!(\"{best_match} = \\\"{first_value}\\\"\"), Applicability::MaybeIncorrect);\n+                                } else {\n+                                    db.span_suggestion(name_span.to(value_span), \"there is a config with a similar name and different values\", best_match, Applicability::MaybeIncorrect);\n+                                };\n+                            } else {\n+                                db.span_suggestion(name_span, \"there is a config with a similar name\", best_match, Applicability::MaybeIncorrect);\n+                            }\n+\n+                            if !possibilities.is_empty() {\n+                                let possibilities = possibilities.join(\"`, `\");\n+                                db.help(format!(\"expected values for `{best_match}` are: `{possibilities}`\"));\n+                            }\n+                        } else {\n+                            db.span_suggestion(name_span, \"there is a config with a similar name\", best_match, Applicability::MaybeIncorrect);\n+                        }\n                     }\n                 },\n-                BuiltinLintDiagnostics::UnexpectedCfg((name, name_span), Some((value, value_span))) => {\n-                    let Some(values) = &sess.parse_sess.check_config.values_valid.get(&name) else {\n+                BuiltinLintDiagnostics::UnexpectedCfgValue((name, name_span), value) => {\n+                    let Some(ExpectedValues::Some(values)) = &sess.parse_sess.check_config.expecteds.get(&name) else {\n                         bug!(\"it shouldn't be possible to have a diagnostic on a value whose name is not in values\");\n                     };\n-                    let possibilities: Vec<Symbol> = values.iter().map(|&s| s).collect();\n+                    let mut have_none_possibility = false;\n+                    let possibilities: Vec<Symbol> = values.iter()\n+                        .inspect(|a| have_none_possibility |= a.is_none())\n+                        .copied()\n+                        .flatten()\n+                        .collect();\n \n                     // Show the full list if all possible values for a given name, but don't do it\n                     // for names as the possibilities could be very long\n@@ -792,17 +823,24 @@ pub trait LintContext: Sized {\n                             let mut possibilities = possibilities.iter().map(Symbol::as_str).collect::<Vec<_>>();\n                             possibilities.sort();\n \n-                            let possibilities = possibilities.join(\", \");\n-                            db.note(format!(\"expected values for `{name}` are: {possibilities}\"));\n+                            let possibilities = possibilities.join(\"`, `\");\n+                            let none = if have_none_possibility { \"(none), \" } else { \"\" };\n+\n+                            db.note(format!(\"expected values for `{name}` are: {none}`{possibilities}`\"));\n                         }\n \n-                        // Suggest the most probable if we found one\n-                        if let Some(best_match) = find_best_match_for_name(&possibilities, value, None) {\n-                            db.span_suggestion(value_span, \"did you mean\", format!(\"\\\"{best_match}\\\"\"), Applicability::MaybeIncorrect);\n+                        if let Some((value, value_span)) = value {\n+                            // Suggest the most probable if we found one\n+                            if let Some(best_match) = find_best_match_for_name(&possibilities, value, None) {\n+                                db.span_suggestion(value_span, \"there is a expected value with a similar name\", format!(\"\\\"{best_match}\\\"\"), Applicability::MaybeIncorrect);\n+\n+                            }\n+                        } else if let &[first_possibility] = &possibilities[..] {\n+                            db.span_suggestion(name_span.shrink_to_hi(), \"specify a config value\", format!(\" = \\\"{first_possibility}\\\"\"), Applicability::MaybeIncorrect);\n                         }\n-                    } else {\n+                    } else if have_none_possibility {\n                         db.note(format!(\"no expected value for `{name}`\"));\n-                        if name != sym::feature {\n+                        if let Some((_value, value_span)) = value {\n                             db.span_suggestion(name_span.shrink_to_hi().to(value_span), \"remove the value\", \"\", Applicability::MaybeIncorrect);\n                         }\n                     }"}, {"sha": "0082aaa4a388448aff2698952e741f85854db5b8", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -478,8 +478,10 @@ impl EarlyLintPass for Diagnostics {\n         }\n         if !segments.iter().all(|(name, args)| {\n             let arg = match name.as_str() {\n-                \"struct_span_err\" | \"span_note\" | \"span_label\" | \"span_help\" => &args[1],\n-                \"note\" | \"help\" => &args[0],\n+                \"struct_span_err\" | \"span_note\" | \"span_label\" | \"span_help\" if args.len() == 2 => {\n+                    &args[1]\n+                }\n+                \"note\" | \"help\" if args.len() == 1 => &args[0],\n                 _ => {\n                     return false;\n                 }"}, {"sha": "e27e322db88581a27bb1b917804510ed43877b5c", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -496,7 +496,8 @@ pub enum BuiltinLintDiagnostics {\n     BreakWithLabelAndLoop(Span),\n     NamedAsmLabel(String),\n     UnicodeTextFlow(Span, String),\n-    UnexpectedCfg((Symbol, Span), Option<(Symbol, Span)>),\n+    UnexpectedCfgName((Symbol, Span), Option<(Symbol, Span)>),\n+    UnexpectedCfgValue((Symbol, Span), Option<(Symbol, Span)>),\n     DeprecatedWhereclauseLocation(Span, String),\n     SingleUseLifetime {\n         /// Span of the parameter which declares this lifetime."}, {"sha": "5ec3b95225d178195da9c7ae99871da8f4e3a090", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -297,7 +297,6 @@ static Reloc::Model fromRust(LLVMRustRelocModel RustReloc) {\n   report_fatal_error(\"Bad RelocModel.\");\n }\n \n-#ifdef LLVM_RUSTLLVM\n /// getLongestEntryLength - Return the length of the longest entry in the table.\n template<typename KV>\n static size_t getLongestEntryLength(ArrayRef<KV> Table) {\n@@ -307,56 +306,68 @@ static size_t getLongestEntryLength(ArrayRef<KV> Table) {\n   return MaxLen;\n }\n \n-extern \"C\" void LLVMRustPrintTargetCPUs(LLVMTargetMachineRef TM) {\n+extern \"C\" void LLVMRustPrintTargetCPUs(LLVMTargetMachineRef TM, const char* TargetCPU) {\n   const TargetMachine *Target = unwrap(TM);\n   const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n   const Triple::ArchType HostArch = Triple(sys::getDefaultTargetTriple()).getArch();\n   const Triple::ArchType TargetArch = Target->getTargetTriple().getArch();\n+\n+#if LLVM_VERSION_GE(17, 0)\n+  const ArrayRef<SubtargetSubTypeKV> CPUTable = MCInfo->getAllProcessorDescriptions();\n+#elif defined(LLVM_RUSTLLVM)\n   const ArrayRef<SubtargetSubTypeKV> CPUTable = MCInfo->getCPUTable();\n+#else\n+  printf(\"Full target CPU help is not supported by this LLVM version.\\n\\n\");\n+  SubtargetSubTypeKV TargetCPUKV = { TargetCPU, {{}}, {{}} };\n+  const ArrayRef<SubtargetSubTypeKV> CPUTable = TargetCPUKV;\n+#endif\n   unsigned MaxCPULen = getLongestEntryLength(CPUTable);\n \n   printf(\"Available CPUs for this target:\\n\");\n   // Don't print the \"native\" entry when the user specifies --target with a\n   // different arch since that could be wrong or misleading.\n   if (HostArch == TargetArch) {\n+    MaxCPULen = std::max(MaxCPULen, (unsigned) std::strlen(\"native\"));\n     const StringRef HostCPU = sys::getHostCPUName();\n     printf(\"    %-*s - Select the CPU of the current host (currently %.*s).\\n\",\n       MaxCPULen, \"native\", (int)HostCPU.size(), HostCPU.data());\n   }\n-  for (auto &CPU : CPUTable)\n-    printf(\"    %-*s\\n\", MaxCPULen, CPU.Key);\n-  printf(\"\\n\");\n+  for (auto &CPU : CPUTable) {\n+    // Compare cpu against current target to label the default\n+    if (strcmp(CPU.Key, TargetCPU) == 0) {\n+      printf(\"    %-*s - This is the default target CPU\"\n+      \" for the current build target (currently %s).\",\n+        MaxCPULen, CPU.Key, Target->getTargetTriple().str().c_str());\n+    }\n+    else {\n+      printf(\"    %-*s\", MaxCPULen, CPU.Key);\n+    }\n+    printf(\"\\n\");\n+  }\n }\n \n extern \"C\" size_t LLVMRustGetTargetFeaturesCount(LLVMTargetMachineRef TM) {\n+#ifdef LLVM_RUSTLLVM\n   const TargetMachine *Target = unwrap(TM);\n   const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n   const ArrayRef<SubtargetFeatureKV> FeatTable = MCInfo->getFeatureTable();\n   return FeatTable.size();\n+#else\n+  return 0;\n+#endif\n }\n \n extern \"C\" void LLVMRustGetTargetFeature(LLVMTargetMachineRef TM, size_t Index,\n                                          const char** Feature, const char** Desc) {\n+#ifdef LLVM_RUSTLLVM\n   const TargetMachine *Target = unwrap(TM);\n   const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n   const ArrayRef<SubtargetFeatureKV> FeatTable = MCInfo->getFeatureTable();\n   const SubtargetFeatureKV Feat = FeatTable[Index];\n   *Feature = Feat.Key;\n   *Desc = Feat.Desc;\n-}\n-\n-#else\n-\n-extern \"C\" void LLVMRustPrintTargetCPUs(LLVMTargetMachineRef) {\n-  printf(\"Target CPU help is not supported by this LLVM version.\\n\\n\");\n-}\n-\n-extern \"C\" size_t LLVMRustGetTargetFeaturesCount(LLVMTargetMachineRef) {\n-  return 0;\n-}\n-\n-extern \"C\" void LLVMRustGetTargetFeature(LLVMTargetMachineRef, const char**, const char**) {}\n #endif\n+}\n \n extern \"C\" const char* LLVMRustGetHostCPUName(size_t *len) {\n   StringRef Name = sys::getHostCPUName();"}, {"sha": "49acd71b3e106a9d8d4604def4782cdba908dd06", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -831,6 +831,28 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFunction(\n   return wrap(Sub);\n }\n \n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateMethod(\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n+    const char *LinkageName, size_t LinkageNameLen,\n+    LLVMMetadataRef File, unsigned LineNo,\n+    LLVMMetadataRef Ty, LLVMRustDIFlags Flags,\n+    LLVMRustDISPFlags SPFlags, LLVMMetadataRef TParam) {\n+  DITemplateParameterArray TParams =\n+      DITemplateParameterArray(unwrap<MDTuple>(TParam));\n+  DISubprogram::DISPFlags llvmSPFlags = fromRust(SPFlags);\n+  DINode::DIFlags llvmFlags = fromRust(Flags);\n+  DISubprogram *Sub = Builder->createMethod(\n+      unwrapDI<DIScope>(Scope),\n+      StringRef(Name, NameLen),\n+      StringRef(LinkageName, LinkageNameLen),\n+      unwrapDI<DIFile>(File), LineNo,\n+      unwrapDI<DISubroutineType>(Ty),\n+      0, 0, nullptr, // VTable params aren't used\n+      llvmFlags, llvmSPFlags, TParams);\n+  return wrap(Sub);\n+}\n+\n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateBasicType(\n     LLVMRustDIBuilderRef Builder, const char *Name, size_t NameLen,\n     uint64_t SizeInBits, unsigned Encoding) {"}, {"sha": "e6e7d25773e672c6d298d05612dda54a72f266fa", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -865,6 +865,17 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         }\n     }\n \n+    fn inject_forced_externs(&mut self) {\n+        for (name, entry) in self.sess.opts.externs.iter() {\n+            if entry.force {\n+                let name_interned = Symbol::intern(name);\n+                if !self.used_extern_options.contains(&name_interned) {\n+                    self.resolve_crate(name_interned, DUMMY_SP, CrateDepKind::Explicit);\n+                }\n+            }\n+        }\n+    }\n+\n     fn inject_dependency_if(\n         &self,\n         krate: CrateNum,\n@@ -913,7 +924,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n                 // Don't worry about pathless `--extern foo` sysroot references\n                 continue;\n             }\n-            if entry.nounused_dep {\n+            if entry.nounused_dep || entry.force {\n                 // We're not worried about this one\n                 continue;\n             }\n@@ -942,6 +953,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n     }\n \n     pub fn postprocess(&mut self, krate: &ast::Crate) {\n+        self.inject_forced_externs();\n         self.inject_profiler_runtime(krate);\n         self.inject_allocator_crate(krate);\n         self.inject_panic_runtime(krate);"}, {"sha": "c83c47e722bf0fd00e3e0eb20e1c34dcb52fe4fa", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -161,14 +161,6 @@ impl<'tcx> Collector<'tcx> {\n                             \"raw-dylib\" => {\n                                 if !sess.target.is_like_windows {\n                                     sess.emit_err(errors::FrameworkOnlyWindows { span });\n-                                } else if !features.raw_dylib && sess.target.arch == \"x86\" {\n-                                    feature_err(\n-                                        &sess.parse_sess,\n-                                        sym::raw_dylib,\n-                                        span,\n-                                        \"link kind `raw-dylib` is unstable on x86\",\n-                                    )\n-                                    .emit();\n                                 }\n                                 NativeLibKind::RawDylib\n                             }\n@@ -251,16 +243,6 @@ impl<'tcx> Collector<'tcx> {\n                                 continue;\n                             }\n                         };\n-                        if !features.raw_dylib {\n-                            let span = item.name_value_literal_span().unwrap();\n-                            feature_err(\n-                                &sess.parse_sess,\n-                                sym::raw_dylib,\n-                                span,\n-                                \"import name type is unstable\",\n-                            )\n-                            .emit();\n-                        }\n                         import_name_type = Some((link_import_name_type, item.span()));\n                     }\n                     _ => {"}, {"sha": "aeb6a1601fc24fe611ee656c5b287c2eeee20ae4", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -64,14 +64,26 @@ impl EffectiveVisibility {\n         self.at_level(level).is_public()\n     }\n \n-    pub fn from_vis(vis: Visibility) -> EffectiveVisibility {\n+    pub const fn from_vis(vis: Visibility) -> EffectiveVisibility {\n         EffectiveVisibility {\n             direct: vis,\n             reexported: vis,\n             reachable: vis,\n             reachable_through_impl_trait: vis,\n         }\n     }\n+\n+    #[must_use]\n+    pub fn min(mut self, lhs: EffectiveVisibility, tcx: TyCtxt<'_>) -> Self {\n+        for l in Level::all_levels() {\n+            let rhs_vis = self.at_level_mut(l);\n+            let lhs_vis = *lhs.at_level(l);\n+            if rhs_vis.is_at_least(lhs_vis, tcx) {\n+                *rhs_vis = lhs_vis;\n+            };\n+        }\n+        self\n+    }\n }\n \n /// Holds a map of effective visibilities for reachable HIR nodes.\n@@ -137,24 +149,6 @@ impl EffectiveVisibilities {\n         };\n     }\n \n-    pub fn set_public_at_level(\n-        &mut self,\n-        id: LocalDefId,\n-        lazy_private_vis: impl FnOnce() -> Visibility,\n-        level: Level,\n-    ) {\n-        let mut effective_vis = self\n-            .effective_vis(id)\n-            .copied()\n-            .unwrap_or_else(|| EffectiveVisibility::from_vis(lazy_private_vis()));\n-        for l in Level::all_levels() {\n-            if l <= level {\n-                *effective_vis.at_level_mut(l) = Visibility::Public;\n-            }\n-        }\n-        self.map.insert(id, effective_vis);\n-    }\n-\n     pub fn check_invariants(&self, tcx: TyCtxt<'_>, early: bool) {\n         if !cfg!(debug_assertions) {\n             return;\n@@ -219,7 +213,7 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n     pub fn update(\n         &mut self,\n         id: Id,\n-        nominal_vis: Visibility,\n+        nominal_vis: Option<Visibility>,\n         lazy_private_vis: impl FnOnce() -> Visibility,\n         inherited_effective_vis: EffectiveVisibility,\n         level: Level,\n@@ -243,12 +237,11 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n                 if !(inherited_effective_vis_at_prev_level == inherited_effective_vis_at_level\n                     && level != l)\n                 {\n-                    calculated_effective_vis =\n-                        if nominal_vis.is_at_least(inherited_effective_vis_at_level, tcx) {\n-                            inherited_effective_vis_at_level\n-                        } else {\n-                            nominal_vis\n-                        };\n+                    calculated_effective_vis = if let Some(nominal_vis) = nominal_vis && !nominal_vis.is_at_least(inherited_effective_vis_at_level, tcx) {\n+                        nominal_vis\n+                    } else {\n+                        inherited_effective_vis_at_level\n+                    }\n                 }\n                 // effective visibility can't be decreased at next update call for the\n                 // same id"}, {"sha": "b425c7600ac688912bdd4363ede77d9e8f624695", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -569,7 +569,7 @@ rustc_queries! {\n     /// returns the full set of predicates. If `Some<Ident>`, then the query returns only the\n     /// subset of super-predicates that reference traits that define the given associated type.\n     /// This is used to avoid cycles in resolving types like `T::Item`.\n-    query super_predicates_that_define_assoc_type(key: (DefId, rustc_span::symbol::Ident)) -> ty::GenericPredicates<'tcx> {\n+    query super_predicates_that_define_assoc_item(key: (DefId, rustc_span::symbol::Ident)) -> ty::GenericPredicates<'tcx> {\n         desc { |tcx| \"computing the super traits of `{}` with associated type name `{}`\",\n             tcx.def_path_str(key.0),\n             key.1"}, {"sha": "8366567c2c3649c15ebaf372f145ee53631bcac9", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -444,6 +444,10 @@ pub enum ObligationCauseCode<'tcx> {\n     AscribeUserTypeProvePredicate(Span),\n \n     RustCall,\n+\n+    /// Obligations to prove that a `std::ops::Drop` impl is not stronger than\n+    /// the ADT it's being implemented for.\n+    DropImpl,\n }\n \n /// The 'location' at which we try to perform HIR-based wf checking."}, {"sha": "a2e248e45ca7373861c05bc740bcf3384e38fb95", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1567,11 +1567,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Given the def_id of a Trait `trait_def_id` and the name of an associated item `assoc_name`\n     /// returns true if the `trait_def_id` defines an associated item of name `assoc_name`.\n-    pub fn trait_may_define_assoc_type(self, trait_def_id: DefId, assoc_name: Ident) -> bool {\n+    pub fn trait_may_define_assoc_item(self, trait_def_id: DefId, assoc_name: Ident) -> bool {\n         self.super_traits_of(trait_def_id).any(|trait_did| {\n             self.associated_items(trait_did)\n-                .find_by_name_and_kind(self, assoc_name, ty::AssocKind::Type, trait_did)\n-                .is_some()\n+                .filter_by_name_unhygienic(assoc_name.name)\n+                .any(|item| self.hygienic_eq(assoc_name, item.ident(self), trait_did))\n         })\n     }\n "}, {"sha": "6c8f4af7594349904aa07aae527ecc493b44adab", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -385,7 +385,7 @@ impl<'tcx> Instance<'tcx> {\n     /// couldn't complete due to errors elsewhere - this is distinct\n     /// from `Ok(None)` to avoid misleading diagnostics when an error\n     /// has already been/will be emitted, for the original cause\n-    #[instrument(level = \"debug\", skip(tcx))]\n+    #[instrument(level = \"debug\", skip(tcx), ret)]\n     pub fn resolve(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,"}, {"sha": "b7e780b94efee759e6298eff4ae101e1ccfda075", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -2633,6 +2633,12 @@ macro_rules! define_print_and_forward_display {\n #[derive(Copy, Clone, TypeFoldable, TypeVisitable, Lift)]\n pub struct TraitRefPrintOnlyTraitPath<'tcx>(ty::TraitRef<'tcx>);\n \n+impl<'tcx> rustc_errors::IntoDiagnosticArg for TraitRefPrintOnlyTraitPath<'tcx> {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        self.to_string().into_diagnostic_arg()\n+    }\n+}\n+\n impl<'tcx> fmt::Debug for TraitRefPrintOnlyTraitPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(self, f)"}, {"sha": "59549435233c53dad8d2cc84caa85dc35ed927a3", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -146,6 +146,12 @@ pub(crate) fn lit_to_mir_constant<'tcx>(\n             let id = tcx.allocate_bytes(data);\n             ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n         }\n+        (ast::LitKind::CStr(data, _), ty::Ref(_, inner_ty, _)) if matches!(inner_ty.kind(), ty::Adt(def, _) if Some(def.did()) == tcx.lang_items().c_str()) =>\n+        {\n+            let allocation = Allocation::from_bytes_byte_aligned_immutable(data as &[u8]);\n+            let allocation = tcx.mk_const_alloc(allocation);\n+            ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n+        }\n         (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n             ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))\n         }"}, {"sha": "51e904890028a0e3a2d955e586af76d0344ff6d1", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 60, "deletions": 3, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,3 +1,5 @@\n+use std::ops::Range;\n+\n use crate::errors;\n use crate::lexer::unicode_chars::UNICODE_ARRAY;\n use crate::make_unclosed_delims_error;\n@@ -6,7 +8,7 @@ use rustc_ast::token::{self, CommentKind, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::util::unicode::contains_text_flow_control_chars;\n use rustc_errors::{error_code, Applicability, Diagnostic, DiagnosticBuilder, StashKey};\n-use rustc_lexer::unescape::{self, Mode};\n+use rustc_lexer::unescape::{self, EscapeError, Mode};\n use rustc_lexer::Cursor;\n use rustc_lexer::{Base, DocStyle, RawStrError};\n use rustc_session::lint::builtin::{\n@@ -204,6 +206,9 @@ impl<'a> StringReader<'a> {\n                 rustc_lexer::TokenKind::Literal { kind, suffix_start } => {\n                     let suffix_start = start + BytePos(suffix_start);\n                     let (kind, symbol) = self.cook_lexer_literal(start, suffix_start, kind);\n+                    if let token::LitKind::CStr | token::LitKind::CStrRaw(_) = kind {\n+                        self.sess.gated_spans.gate(sym::c_str_literals, self.mk_sp(start, self.pos));\n+                    }\n                     let suffix = if suffix_start < self.pos {\n                         let string = self.str_from(suffix_start);\n                         if string == \"_\" {\n@@ -415,6 +420,16 @@ impl<'a> StringReader<'a> {\n                 }\n                 self.cook_quoted(token::ByteStr, Mode::ByteStr, start, end, 2, 1) // b\" \"\n             }\n+            rustc_lexer::LiteralKind::CStr { terminated } => {\n+                if !terminated {\n+                    self.sess.span_diagnostic.span_fatal_with_code(\n+                        self.mk_sp(start + BytePos(1), end),\n+                        \"unterminated C string\",\n+                        error_code!(E0767),\n+                    )\n+                }\n+                self.cook_c_string(token::CStr, Mode::CStr, start, end, 2, 1) // c\" \"\n+            }\n             rustc_lexer::LiteralKind::RawStr { n_hashes } => {\n                 if let Some(n_hashes) = n_hashes {\n                     let n = u32::from(n_hashes);\n@@ -433,6 +448,15 @@ impl<'a> StringReader<'a> {\n                     self.report_raw_str_error(start, 2);\n                 }\n             }\n+            rustc_lexer::LiteralKind::RawCStr { n_hashes } => {\n+                if let Some(n_hashes) = n_hashes {\n+                    let n = u32::from(n_hashes);\n+                    let kind = token::CStrRaw(n_hashes);\n+                    self.cook_c_string(kind, Mode::RawCStr, start, end, 3 + n, 1 + n) // cr##\" \"##\n+                } else {\n+                    self.report_raw_str_error(start, 2);\n+                }\n+            }\n             rustc_lexer::LiteralKind::Int { base, empty_int } => {\n                 if empty_int {\n                     let span = self.mk_sp(start, end);\n@@ -648,20 +672,21 @@ impl<'a> StringReader<'a> {\n         self.sess.emit_fatal(errors::TooManyHashes { span: self.mk_sp(start, self.pos), num });\n     }\n \n-    fn cook_quoted(\n+    fn cook_common(\n         &self,\n         kind: token::LitKind,\n         mode: Mode,\n         start: BytePos,\n         end: BytePos,\n         prefix_len: u32,\n         postfix_len: u32,\n+        unescape: fn(&str, Mode, &mut dyn FnMut(Range<usize>, Result<(), EscapeError>)),\n     ) -> (token::LitKind, Symbol) {\n         let mut has_fatal_err = false;\n         let content_start = start + BytePos(prefix_len);\n         let content_end = end - BytePos(postfix_len);\n         let lit_content = self.str_from_to(content_start, content_end);\n-        unescape::unescape_literal(lit_content, mode, &mut |range, result| {\n+        unescape(lit_content, mode, &mut |range, result| {\n             // Here we only check for errors. The actual unescaping is done later.\n             if let Err(err) = result {\n                 let span_with_quotes = self.mk_sp(start, end);\n@@ -692,6 +717,38 @@ impl<'a> StringReader<'a> {\n             (token::Err, self.symbol_from_to(start, end))\n         }\n     }\n+\n+    fn cook_quoted(\n+        &self,\n+        kind: token::LitKind,\n+        mode: Mode,\n+        start: BytePos,\n+        end: BytePos,\n+        prefix_len: u32,\n+        postfix_len: u32,\n+    ) -> (token::LitKind, Symbol) {\n+        self.cook_common(kind, mode, start, end, prefix_len, postfix_len, |src, mode, callback| {\n+            unescape::unescape_literal(src, mode, &mut |span, result| {\n+                callback(span, result.map(drop))\n+            })\n+        })\n+    }\n+\n+    fn cook_c_string(\n+        &self,\n+        kind: token::LitKind,\n+        mode: Mode,\n+        start: BytePos,\n+        end: BytePos,\n+        prefix_len: u32,\n+        postfix_len: u32,\n+    ) -> (token::LitKind, Symbol) {\n+        self.cook_common(kind, mode, start, end, prefix_len, postfix_len, |src, mode, callback| {\n+            unescape::unescape_c_string(src, mode, &mut |span, result| {\n+                callback(span, result.map(drop))\n+            })\n+        })\n+    }\n }\n \n pub fn nfc_normalize(string: &str) -> Symbol {"}, {"sha": "eb9625f923ab95e46771d7123d2f71a0c3c01476", "filename": "compiler/rustc_parse/src/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -78,8 +78,7 @@ pub(crate) fn emit_unescape_error(\n                 }\n             };\n             let sugg = sugg.unwrap_or_else(|| {\n-                let is_byte = mode.is_byte();\n-                let prefix = if is_byte { \"b\" } else { \"\" };\n+                let prefix = mode.prefix_noraw();\n                 let mut escaped = String::with_capacity(lit.len());\n                 let mut chrs = lit.chars().peekable();\n                 while let Some(first) = chrs.next() {\n@@ -97,7 +96,11 @@ pub(crate) fn emit_unescape_error(\n                     };\n                 }\n                 let sugg = format!(\"{prefix}\\\"{escaped}\\\"\");\n-                MoreThanOneCharSugg::Quotes { span: span_with_quotes, is_byte, sugg }\n+                MoreThanOneCharSugg::Quotes {\n+                    span: span_with_quotes,\n+                    is_byte: mode == Mode::Byte,\n+                    sugg,\n+                }\n             });\n             handler.emit_err(UnescapeError::MoreThanOneChar {\n                 span: span_with_quotes,\n@@ -112,7 +115,7 @@ pub(crate) fn emit_unescape_error(\n                 char_span,\n                 escaped_sugg: c.escape_default().to_string(),\n                 escaped_msg: escaped_char(c),\n-                byte: mode.is_byte(),\n+                byte: mode == Mode::Byte,\n             });\n         }\n         EscapeError::BareCarriageReturn => {\n@@ -126,12 +129,15 @@ pub(crate) fn emit_unescape_error(\n         EscapeError::InvalidEscape => {\n             let (c, span) = last_char();\n \n-            let label =\n-                if mode.is_byte() { \"unknown byte escape\" } else { \"unknown character escape\" };\n+            let label = if mode == Mode::Byte || mode == Mode::ByteStr {\n+                \"unknown byte escape\"\n+            } else {\n+                \"unknown character escape\"\n+            };\n             let ec = escaped_char(c);\n             let mut diag = handler.struct_span_err(span, format!(\"{}: `{}`\", label, ec));\n             diag.span_label(span, label);\n-            if c == '{' || c == '}' && !mode.is_byte() {\n+            if c == '{' || c == '}' && matches!(mode, Mode::Str | Mode::RawStr) {\n                 diag.help(\n                     \"if used in a formatting string, curly braces are escaped with `{{` and `}}`\",\n                 );\n@@ -141,7 +147,7 @@ pub(crate) fn emit_unescape_error(\n                      version control settings\",\n                 );\n             } else {\n-                if !mode.is_byte() {\n+                if mode == Mode::Str || mode == Mode::Char {\n                     diag.span_suggestion(\n                         span_with_quotes,\n                         \"if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\","}, {"sha": "018eddea4b06b96f25eef8e0da21859eef5257e4", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1448,8 +1448,19 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_expr_path_start(&mut self) -> PResult<'a, P<Expr>> {\n+        let maybe_eq_tok = self.prev_token.clone();\n         let (qself, path) = if self.eat_lt() {\n-            let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+            let lt_span = self.prev_token.span;\n+            let (qself, path) = self.parse_qpath(PathStyle::Expr).map_err(|mut err| {\n+                // Suggests using '<=' if there is an error parsing qpath when the previous token\n+                // is an '=' token. Only emits suggestion if the '<' token and '=' token are\n+                // directly adjacent (i.e. '=<')\n+                if maybe_eq_tok.kind == TokenKind::Eq && maybe_eq_tok.span.hi() == lt_span.lo() {\n+                    let eq_lt = maybe_eq_tok.span.to(lt_span);\n+                    err.span_suggestion(eq_lt, \"did you mean\", \"<=\", Applicability::Unspecified);\n+                }\n+                err\n+            })?;\n             (Some(qself), path)\n         } else {\n             (None, self.parse_path(PathStyle::Expr)?)\n@@ -1870,6 +1881,7 @@ impl<'a> Parser<'a> {\n         let recovered = self.recover_after_dot();\n         let token = recovered.as_ref().unwrap_or(&self.token);\n         let span = token.span;\n+\n         token::Lit::from_token(token).map(|token_lit| {\n             self.bump();\n             (token_lit, span)"}, {"sha": "b738ce35ada8039a58a0b30786b4fd188496d3f4", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 154, "deletions": 117, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -25,7 +25,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{AssocItemKind, HirIdSet, ItemId, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::privacy::{EffectiveVisibilities, Level};\n+use rustc_middle::middle::privacy::{EffectiveVisibilities, EffectiveVisibility, Level};\n use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::InternalSubsts;\n@@ -38,7 +38,7 @@ use rustc_span::Span;\n \n use std::marker::PhantomData;\n use std::ops::ControlFlow;\n-use std::{cmp, fmt, mem};\n+use std::{fmt, mem};\n \n use errors::{\n     FieldIsPrivate, FieldIsPrivateLabel, FromPrivateDependencyInPublicInterface, InPublicInterface,\n@@ -375,8 +375,9 @@ impl VisibilityLike for ty::Visibility {\n         min(find.tcx.local_visibility(def_id), find.min, find.tcx)\n     }\n }\n-impl VisibilityLike for Option<Level> {\n-    const MAX: Self = Some(Level::Direct);\n+\n+impl VisibilityLike for Option<EffectiveVisibility> {\n+    const MAX: Self = Some(EffectiveVisibility::from_vis(ty::Visibility::Public));\n     // Type inference is very smart sometimes.\n     // It can make an impl reachable even some components of its type or trait are unreachable.\n     // E.g. methods of `impl ReachableTrait<UnreachableTy> for ReachableTy<UnreachableTy> { ... }`\n@@ -388,7 +389,13 @@ impl VisibilityLike for Option<Level> {\n     // (which require reaching the `DefId`s in them).\n     const SHALLOW: bool = true;\n     fn new_min(find: &FindMin<'_, '_, Self>, def_id: LocalDefId) -> Self {\n-        cmp::min(find.effective_visibilities.public_at_level(def_id), find.min)\n+        if let Some(min) = find.min {\n+            return find\n+                .effective_visibilities\n+                .effective_vis(def_id)\n+                .map(|eff_vis| min.min(*eff_vis, find.tcx));\n+        }\n+        None\n     }\n }\n \n@@ -414,49 +421,79 @@ struct EmbargoVisitor<'tcx> {\n     ///     n::p::f()\n     /// }\n     macro_reachable: FxHashSet<(LocalDefId, LocalDefId)>,\n-    /// Previous visibility level; `None` means unreachable.\n-    prev_level: Option<Level>,\n     /// Has something changed in the level map?\n     changed: bool,\n }\n \n struct ReachEverythingInTheInterfaceVisitor<'a, 'tcx> {\n-    level: Option<Level>,\n+    effective_vis: Option<EffectiveVisibility>,\n     item_def_id: LocalDefId,\n     ev: &'a mut EmbargoVisitor<'tcx>,\n+    level: Level,\n }\n \n impl<'tcx> EmbargoVisitor<'tcx> {\n-    fn get(&self, def_id: LocalDefId) -> Option<Level> {\n-        self.effective_visibilities.public_at_level(def_id)\n-    }\n-\n-    /// Updates node level and returns the updated level.\n-    fn update(&mut self, def_id: LocalDefId, level: Option<Level>) -> Option<Level> {\n-        let old_level = self.get(def_id);\n-        // Visibility levels can only grow.\n-        if level > old_level {\n-            self.effective_visibilities.set_public_at_level(\n-                def_id,\n-                || ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id)),\n-                level.unwrap(),\n-            );\n-            self.changed = true;\n-            level\n-        } else {\n-            old_level\n+    fn get(&self, def_id: LocalDefId) -> Option<EffectiveVisibility> {\n+        self.effective_visibilities.effective_vis(def_id).copied()\n+    }\n+\n+    // Updates node effective visibility.\n+    fn update(\n+        &mut self,\n+        def_id: LocalDefId,\n+        inherited_effective_vis: Option<EffectiveVisibility>,\n+        level: Level,\n+    ) {\n+        let nominal_vis = self.tcx.local_visibility(def_id);\n+        self.update_eff_vis(def_id, inherited_effective_vis, Some(nominal_vis), level);\n+    }\n+\n+    fn update_eff_vis(\n+        &mut self,\n+        def_id: LocalDefId,\n+        inherited_effective_vis: Option<EffectiveVisibility>,\n+        nominal_vis: Option<ty::Visibility>,\n+        level: Level,\n+    ) {\n+        if let Some(inherited_effective_vis) = inherited_effective_vis {\n+            let private_vis =\n+                ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id));\n+            if Some(private_vis) != nominal_vis {\n+                self.changed |= self.effective_visibilities.update(\n+                    def_id,\n+                    nominal_vis,\n+                    || private_vis,\n+                    inherited_effective_vis,\n+                    level,\n+                    self.tcx,\n+                );\n+            }\n         }\n     }\n \n     fn reach(\n         &mut self,\n         def_id: LocalDefId,\n-        level: Option<Level>,\n+        effective_vis: Option<EffectiveVisibility>,\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n-            level: cmp::min(level, Some(Level::Reachable)),\n+            effective_vis,\n             item_def_id: def_id,\n             ev: self,\n+            level: Level::Reachable,\n+        }\n+    }\n+\n+    fn reach_through_impl_trait(\n+        &mut self,\n+        def_id: LocalDefId,\n+        effective_vis: Option<EffectiveVisibility>,\n+    ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n+        ReachEverythingInTheInterfaceVisitor {\n+            effective_vis,\n+            item_def_id: def_id,\n+            ev: self,\n+            level: Level::ReachableThroughImplTrait,\n         }\n     }\n \n@@ -477,16 +514,18 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             return;\n         }\n \n-        if self.get(local_def_id).is_none() {\n+        if self.effective_visibilities.public_at_level(local_def_id).is_none() {\n             return;\n         }\n \n         // Since we are starting from an externally visible module,\n         // all the parents in the loop below are also guaranteed to be modules.\n         let mut module_def_id = macro_module_def_id;\n+        let macro_ev = self.get(local_def_id);\n+        assert!(macro_ev.is_some());\n         loop {\n             let changed_reachability =\n-                self.update_macro_reachable(module_def_id, macro_module_def_id);\n+                self.update_macro_reachable(module_def_id, macro_module_def_id, macro_ev);\n             if changed_reachability || module_def_id == CRATE_DEF_ID {\n                 break;\n             }\n@@ -500,21 +539,33 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         &mut self,\n         module_def_id: LocalDefId,\n         defining_mod: LocalDefId,\n+        macro_ev: Option<EffectiveVisibility>,\n     ) -> bool {\n         if self.macro_reachable.insert((module_def_id, defining_mod)) {\n-            self.update_macro_reachable_mod(module_def_id, defining_mod);\n+            self.update_macro_reachable_mod(module_def_id, defining_mod, macro_ev);\n             true\n         } else {\n             false\n         }\n     }\n \n-    fn update_macro_reachable_mod(&mut self, module_def_id: LocalDefId, defining_mod: LocalDefId) {\n+    fn update_macro_reachable_mod(\n+        &mut self,\n+        module_def_id: LocalDefId,\n+        defining_mod: LocalDefId,\n+        macro_ev: Option<EffectiveVisibility>,\n+    ) {\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in module.item_ids {\n             let def_kind = self.tcx.def_kind(item_id.owner_id);\n             let vis = self.tcx.local_visibility(item_id.owner_id.def_id);\n-            self.update_macro_reachable_def(item_id.owner_id.def_id, def_kind, vis, defining_mod);\n+            self.update_macro_reachable_def(\n+                item_id.owner_id.def_id,\n+                def_kind,\n+                vis,\n+                defining_mod,\n+                macro_ev,\n+            );\n         }\n         for child in self.tcx.module_children_local(module_def_id) {\n             // FIXME: Use module children for the logic above too.\n@@ -523,7 +574,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n                 && let Res::Def(def_kind, def_id) = child.res\n                 && let Some(def_id) = def_id.as_local() {\n                 let vis = self.tcx.local_visibility(def_id);\n-                self.update_macro_reachable_def(def_id, def_kind, vis, defining_mod);\n+                self.update_macro_reachable_def(def_id, def_kind, vis, defining_mod, macro_ev);\n             }\n         }\n     }\n@@ -534,16 +585,14 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         def_kind: DefKind,\n         vis: ty::Visibility,\n         module: LocalDefId,\n+        macro_ev: Option<EffectiveVisibility>,\n     ) {\n-        let level = Some(Level::Reachable);\n-        if vis.is_public() {\n-            self.update(def_id, level);\n-        }\n+        self.update(def_id, macro_ev, Level::Reachable);\n         match def_kind {\n             // No type privacy, so can be directly marked as reachable.\n             DefKind::Const | DefKind::Static(_) | DefKind::TraitAlias | DefKind::TyAlias => {\n                 if vis.is_accessible_from(module, self.tcx) {\n-                    self.update(def_id, level);\n+                    self.update(def_id, macro_ev, Level::Reachable);\n                 }\n             }\n \n@@ -555,7 +604,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n                 let item = self.tcx.hir().expect_item(def_id);\n                 if let hir::ItemKind::Macro(MacroDef { macro_rules: false, .. }, _) = item.kind {\n                     if vis.is_accessible_from(module, self.tcx) {\n-                        self.update(def_id, level);\n+                        self.update(def_id, macro_ev, Level::Reachable);\n                     }\n                 }\n             }\n@@ -566,26 +615,24 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             // the module, however may be reachable.\n             DefKind::Mod => {\n                 if vis.is_accessible_from(module, self.tcx) {\n-                    self.update_macro_reachable(def_id, module);\n+                    self.update_macro_reachable(def_id, module, macro_ev);\n                 }\n             }\n \n             DefKind::Struct | DefKind::Union => {\n                 // While structs and unions have type privacy, their fields do not.\n-                if vis.is_public() {\n-                    let item = self.tcx.hir().expect_item(def_id);\n-                    if let hir::ItemKind::Struct(ref struct_def, _)\n-                    | hir::ItemKind::Union(ref struct_def, _) = item.kind\n-                    {\n-                        for field in struct_def.fields() {\n-                            let field_vis = self.tcx.local_visibility(field.def_id);\n-                            if field_vis.is_accessible_from(module, self.tcx) {\n-                                self.reach(field.def_id, level).ty();\n-                            }\n+                let item = self.tcx.hir().expect_item(def_id);\n+                if let hir::ItemKind::Struct(ref struct_def, _)\n+                | hir::ItemKind::Union(ref struct_def, _) = item.kind\n+                {\n+                    for field in struct_def.fields() {\n+                        let field_vis = self.tcx.local_visibility(field.def_id);\n+                        if field_vis.is_accessible_from(module, self.tcx) {\n+                            self.reach(field.def_id, macro_ev).ty();\n                         }\n-                    } else {\n-                        bug!(\"item {:?} with DefKind {:?}\", item, def_kind);\n                     }\n+                } else {\n+                    bug!(\"item {:?} with DefKind {:?}\", item, def_kind);\n                 }\n             }\n \n@@ -629,14 +676,16 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let item_level = match item.kind {\n+        let item_ev = match item.kind {\n             hir::ItemKind::Impl { .. } => {\n-                let impl_level = Option::<Level>::of_impl(\n+                let impl_ev = Option::<EffectiveVisibility>::of_impl(\n                     item.owner_id.def_id,\n                     self.tcx,\n                     &self.effective_visibilities,\n                 );\n-                self.update(item.owner_id.def_id, impl_level)\n+\n+                self.update_eff_vis(item.owner_id.def_id, impl_ev, None, Level::Direct);\n+                impl_ev\n             }\n             _ => self.get(item.owner_id.def_id),\n         };\n@@ -645,48 +694,40 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         match item.kind {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in def.variants {\n-                    let variant_level = self.update(variant.def_id, item_level);\n+                    self.update(variant.def_id, item_ev, Level::Reachable);\n+                    let variant_ev = self.get(variant.def_id);\n                     if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n-                        self.update(ctor_def_id, item_level);\n+                        self.update(ctor_def_id, variant_ev, Level::Reachable);\n                     }\n                     for field in variant.data.fields() {\n-                        self.update(field.def_id, variant_level);\n+                        self.update(field.def_id, variant_ev, Level::Reachable);\n                     }\n                 }\n             }\n             hir::ItemKind::Impl(ref impl_) => {\n                 for impl_item_ref in impl_.items {\n-                    if impl_.of_trait.is_some()\n-                        || self.tcx.visibility(impl_item_ref.id.owner_id).is_public()\n-                    {\n-                        self.update(impl_item_ref.id.owner_id.def_id, item_level);\n-                    }\n+                    self.update(impl_item_ref.id.owner_id.def_id, item_ev, Level::Direct);\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n-                    self.update(trait_item_ref.id.owner_id.def_id, item_level);\n+                    self.update(trait_item_ref.id.owner_id.def_id, item_ev, Level::Reachable);\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n                 if let Some(ctor_def_id) = def.ctor_def_id() {\n-                    self.update(ctor_def_id, item_level);\n+                    self.update(ctor_def_id, item_ev, Level::Reachable);\n                 }\n                 for field in def.fields() {\n-                    let vis = self.tcx.visibility(field.def_id);\n-                    if vis.is_public() {\n-                        self.update(field.def_id, item_level);\n-                    }\n+                    self.update(field.def_id, item_ev, Level::Reachable);\n                 }\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 self.update_reachability_from_macro(item.owner_id.def_id, macro_def);\n             }\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    if self.tcx.visibility(foreign_item.id.owner_id).is_public() {\n-                        self.update(foreign_item.id.owner_id.def_id, item_level);\n-                    }\n+                    self.update(foreign_item.id.owner_id.def_id, item_ev, Level::Reachable);\n                 }\n             }\n \n@@ -721,26 +762,30 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     // FIXME: This is some serious pessimization intended to workaround deficiencies\n                     // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n                     // reachable if they are returned via `impl Trait`, even from private functions.\n-                    let exist_level = cmp::max(item_level, Some(Level::ReachableThroughImplTrait));\n-                    self.reach(item.owner_id.def_id, exist_level).generics().predicates().ty();\n+                    let exist_ev = Some(EffectiveVisibility::from_vis(ty::Visibility::Public));\n+                    self.reach_through_impl_trait(item.owner_id.def_id, exist_ev)\n+                        .generics()\n+                        .predicates()\n+                        .ty();\n                 }\n             }\n             // Visit everything.\n             hir::ItemKind::Const(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n-                if item_level.is_some() {\n-                    self.reach(item.owner_id.def_id, item_level).generics().predicates().ty();\n+                if item_ev.is_some() {\n+                    self.reach(item.owner_id.def_id, item_ev).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n-                if item_level.is_some() {\n-                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n+                if item_ev.is_some() {\n+                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n                         let tcx = self.tcx;\n-                        let mut reach = self.reach(trait_item_ref.id.owner_id.def_id, item_level);\n+                        let mut reach = self.reach(trait_item_ref.id.owner_id.def_id, item_ev);\n+\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == AssocItemKind::Type\n@@ -754,23 +799,24 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                if item_level.is_some() {\n-                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n+                if item_ev.is_some() {\n+                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n-                if item_level.is_some() {\n-                    self.reach(item.owner_id.def_id, item_level)\n+                if item_ev.is_some() {\n+                    self.reach(item.owner_id.def_id, item_ev)\n                         .generics()\n                         .predicates()\n                         .ty()\n                         .trait_ref();\n \n                     for impl_item_ref in impl_.items {\n-                        let impl_item_level = self.get(impl_item_ref.id.owner_id.def_id);\n-                        if impl_item_level.is_some() {\n-                            self.reach(impl_item_ref.id.owner_id.def_id, impl_item_level)\n+                        let impl_item_ev = self.get(impl_item_ref.id.owner_id.def_id);\n+\n+                        if impl_item_ev.is_some() {\n+                            self.reach(impl_item_ref.id.owner_id.def_id, impl_item_ev)\n                                 .generics()\n                                 .predicates()\n                                 .ty();\n@@ -781,33 +827,33 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n \n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n-                if item_level.is_some() {\n-                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n+                if item_ev.is_some() {\n+                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                 }\n                 for variant in def.variants {\n-                    let variant_level = self.get(variant.def_id);\n-                    if variant_level.is_some() {\n+                    let variant_ev = self.get(variant.def_id);\n+                    if variant_ev.is_some() {\n                         for field in variant.data.fields() {\n-                            self.reach(field.def_id, variant_level).ty();\n+                            self.reach(field.def_id, variant_ev).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n-                        self.reach(item.owner_id.def_id, variant_level).ty();\n+                        self.reach(item.owner_id.def_id, variant_ev).ty();\n                     }\n                     if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n-                        let ctor_level = self.get(ctor_def_id);\n-                        if ctor_level.is_some() {\n-                            self.reach(item.owner_id.def_id, ctor_level).ty();\n+                        let ctor_ev = self.get(ctor_def_id);\n+                        if ctor_ev.is_some() {\n+                            self.reach(item.owner_id.def_id, ctor_ev).ty();\n                         }\n                     }\n                 }\n             }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    let foreign_item_level = self.get(foreign_item.id.owner_id.def_id);\n-                    if foreign_item_level.is_some() {\n-                        self.reach(foreign_item.id.owner_id.def_id, foreign_item_level)\n+                    let foreign_item_ev = self.get(foreign_item.id.owner_id.def_id);\n+                    if foreign_item_ev.is_some() {\n+                        self.reach(foreign_item.id.owner_id.def_id, foreign_item_ev)\n                             .generics()\n                             .predicates()\n                             .ty();\n@@ -816,36 +862,32 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                if item_level.is_some() {\n-                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n+                if item_ev.is_some() {\n+                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                     for field in struct_def.fields() {\n-                        let field_level = self.get(field.def_id);\n-                        if field_level.is_some() {\n-                            self.reach(field.def_id, field_level).ty();\n+                        let field_ev = self.get(field.def_id);\n+                        if field_ev.is_some() {\n+                            self.reach(field.def_id, field_ev).ty();\n                         }\n                     }\n                 }\n                 if let Some(ctor_def_id) = struct_def.ctor_def_id() {\n-                    let ctor_level = self.get(ctor_def_id);\n-                    if ctor_level.is_some() {\n-                        self.reach(item.owner_id.def_id, ctor_level).ty();\n+                    let ctor_ev = self.get(ctor_def_id);\n+                    if ctor_ev.is_some() {\n+                        self.reach(item.owner_id.def_id, ctor_ev).ty();\n                     }\n                 }\n             }\n         }\n \n-        let orig_level = mem::replace(&mut self.prev_level, item_level);\n         intravisit::walk_item(self, item);\n-        self.prev_level = orig_level;\n     }\n \n     fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n         // Blocks can have public items, for example impls, but they always\n         // start as completely private regardless of publicity of a function,\n         // constant, type, field, etc., in which this block resides.\n-        let orig_level = mem::replace(&mut self.prev_level, None);\n         intravisit::walk_block(self, b);\n-        self.prev_level = orig_level;\n     }\n }\n \n@@ -899,11 +941,7 @@ impl<'tcx> DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx>\n         _descr: &dyn fmt::Display,\n     ) -> ControlFlow<Self::BreakTy> {\n         if let Some(def_id) = def_id.as_local() {\n-            if let (ty::Visibility::Public, _) | (_, Some(Level::ReachableThroughImplTrait)) =\n-                (self.tcx().visibility(def_id.to_def_id()), self.level)\n-            {\n-                self.ev.update(def_id, self.level);\n-            }\n+            self.ev.update_eff_vis(def_id, self.effective_vis, None, self.level);\n         }\n         ControlFlow::Continue(())\n     }\n@@ -2131,7 +2169,6 @@ fn effective_visibilities(tcx: TyCtxt<'_>, (): ()) -> &EffectiveVisibilities {\n         tcx,\n         effective_visibilities: tcx.resolutions(()).effective_visibilities.clone(),\n         macro_reachable: Default::default(),\n-        prev_level: Some(Level::Direct),\n         changed: false,\n     };\n "}, {"sha": "7393bdb388a56e8c57db275de99a4e4b0e2701be", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -199,7 +199,7 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         let tcx = self.r.tcx;\n         self.changed |= self.import_effective_visibilities.update(\n             binding,\n-            nominal_vis,\n+            Some(nominal_vis),\n             || cheap_private_vis.unwrap_or_else(|| self.r.private_vis_import(binding)),\n             inherited_eff_vis,\n             parent_id.level(),\n@@ -213,7 +213,7 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         let tcx = self.r.tcx;\n         self.changed |= self.def_effective_visibilities.update(\n             def_id,\n-            nominal_vis,\n+            Some(nominal_vis),\n             || cheap_private_vis.unwrap_or_else(|| self.r.private_vis_def(def_id)),\n             inherited_eff_vis,\n             parent_id.level(),"}, {"sha": "a8fe560d1a760b51693f7ed8dc26089c66c476ac", "filename": "compiler/rustc_session/messages.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_session%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_session%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fmessages.ftl?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -101,3 +101,5 @@ session_invalid_int_literal_width = invalid width `{$width}` for integer literal\n     .help = valid widths are 8, 16, 32, 64 and 128\n \n session_optimization_fuel_exhausted = optimization-fuel-exhausted: {$msg}\n+\n+session_nul_in_c_str = null characters in C string literals are not supported"}, {"sha": "d80cc0aa043743981f1f2798c216c8abb2747296", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 142, "deletions": 109, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -518,6 +518,12 @@ pub struct ExternEntry {\n     /// `--extern nounused:std=/path/to/lib/libstd.rlib`. This is used to\n     /// suppress `unused-crate-dependencies` warnings.\n     pub nounused_dep: bool,\n+    /// If the extern entry is not referenced in the crate, force it to be resolved anyway.\n+    ///\n+    /// Allows a dependency satisfying, for instance, a missing panic handler to be injected\n+    /// without modifying source:\n+    /// `--extern force:extras=/path/to/lib/libstd.rlib`\n+    pub force: bool,\n }\n \n #[derive(Clone, Debug)]\n@@ -556,7 +562,13 @@ impl Externs {\n \n impl ExternEntry {\n     fn new(location: ExternLocation) -> ExternEntry {\n-        ExternEntry { location, is_private_dep: false, add_prelude: false, nounused_dep: false }\n+        ExternEntry {\n+            location,\n+            is_private_dep: false,\n+            add_prelude: false,\n+            nounused_dep: false,\n+            force: false,\n+        }\n     }\n \n     pub fn files(&self) -> Option<impl Iterator<Item = &CanonicalizedPath>> {\n@@ -1064,37 +1076,76 @@ pub fn to_crate_config(cfg: FxHashSet<(String, Option<String>)>) -> CrateConfig\n \n /// The parsed `--check-cfg` options\n pub struct CheckCfg<T = String> {\n-    /// The set of all `names()`, if None no name checking is performed\n-    pub names_valid: Option<FxHashSet<T>>,\n+    /// Is well known names activated\n+    pub exhaustive_names: bool,\n     /// Is well known values activated\n-    pub well_known_values: bool,\n-    /// The set of all `values()`\n-    pub values_valid: FxHashMap<T, FxHashSet<T>>,\n+    pub exhaustive_values: bool,\n+    /// All the expected values for a config name\n+    pub expecteds: FxHashMap<T, ExpectedValues<T>>,\n }\n \n impl<T> Default for CheckCfg<T> {\n     fn default() -> Self {\n         CheckCfg {\n-            names_valid: Default::default(),\n-            values_valid: Default::default(),\n-            well_known_values: false,\n+            exhaustive_names: false,\n+            exhaustive_values: false,\n+            expecteds: FxHashMap::default(),\n         }\n     }\n }\n \n impl<T> CheckCfg<T> {\n-    fn map_data<O: Eq + Hash>(&self, f: impl Fn(&T) -> O) -> CheckCfg<O> {\n+    fn map_data<O: Eq + Hash>(self, f: impl Fn(T) -> O) -> CheckCfg<O> {\n         CheckCfg {\n-            names_valid: self\n-                .names_valid\n-                .as_ref()\n-                .map(|names_valid| names_valid.iter().map(|a| f(a)).collect()),\n-            values_valid: self\n-                .values_valid\n-                .iter()\n-                .map(|(a, b)| (f(a), b.iter().map(|b| f(b)).collect()))\n+            exhaustive_names: self.exhaustive_names,\n+            exhaustive_values: self.exhaustive_values,\n+            expecteds: self\n+                .expecteds\n+                .into_iter()\n+                .map(|(name, values)| {\n+                    (\n+                        f(name),\n+                        match values {\n+                            ExpectedValues::Some(values) => ExpectedValues::Some(\n+                                values.into_iter().map(|b| b.map(|b| f(b))).collect(),\n+                            ),\n+                            ExpectedValues::Any => ExpectedValues::Any,\n+                        },\n+                    )\n+                })\n                 .collect(),\n-            well_known_values: self.well_known_values,\n+        }\n+    }\n+}\n+\n+pub enum ExpectedValues<T> {\n+    Some(FxHashSet<Option<T>>),\n+    Any,\n+}\n+\n+impl<T: Eq + Hash> ExpectedValues<T> {\n+    fn insert(&mut self, value: T) -> bool {\n+        match self {\n+            ExpectedValues::Some(expecteds) => expecteds.insert(Some(value)),\n+            ExpectedValues::Any => false,\n+        }\n+    }\n+}\n+\n+impl<T: Eq + Hash> Extend<T> for ExpectedValues<T> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+        match self {\n+            ExpectedValues::Some(expecteds) => expecteds.extend(iter.into_iter().map(Some)),\n+            ExpectedValues::Any => {}\n+        }\n+    }\n+}\n+\n+impl<'a, T: Eq + Hash + Copy + 'a> Extend<&'a T> for ExpectedValues<T> {\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n+        match self {\n+            ExpectedValues::Some(expecteds) => expecteds.extend(iter.into_iter().map(|a| Some(*a))),\n+            ExpectedValues::Any => {}\n         }\n     }\n }\n@@ -1103,58 +1154,27 @@ impl<T> CheckCfg<T> {\n /// `rustc_interface::interface::Config` accepts this in the compiler configuration,\n /// but the symbol interner is not yet set up then, so we must convert it later.\n pub fn to_crate_check_config(cfg: CheckCfg) -> CrateCheckConfig {\n-    cfg.map_data(|s| Symbol::intern(s))\n+    cfg.map_data(|s| Symbol::intern(&s))\n }\n \n impl CrateCheckConfig {\n-    /// Fills a `CrateCheckConfig` with well-known configuration names.\n-    fn fill_well_known_names(&mut self) {\n-        // NOTE: This should be kept in sync with `default_configuration` and\n-        // `fill_well_known_values`\n-        const WELL_KNOWN_NAMES: &[Symbol] = &[\n-            // rustc\n-            sym::unix,\n-            sym::windows,\n-            sym::target_os,\n-            sym::target_family,\n-            sym::target_arch,\n-            sym::target_endian,\n-            sym::target_pointer_width,\n-            sym::target_env,\n-            sym::target_abi,\n-            sym::target_vendor,\n-            sym::target_thread_local,\n-            sym::target_has_atomic_load_store,\n-            sym::target_has_atomic,\n-            sym::target_has_atomic_equal_alignment,\n-            sym::target_feature,\n-            sym::panic,\n-            sym::sanitize,\n-            sym::debug_assertions,\n-            sym::proc_macro,\n-            sym::test,\n-            sym::feature,\n-            // rustdoc\n-            sym::doc,\n-            sym::doctest,\n-            // miri\n-            sym::miri,\n-        ];\n-\n-        // We only insert well-known names if `names()` was activated\n-        if let Some(names_valid) = &mut self.names_valid {\n-            names_valid.extend(WELL_KNOWN_NAMES);\n-        }\n-    }\n-\n-    /// Fills a `CrateCheckConfig` with well-known configuration values.\n-    fn fill_well_known_values(&mut self, current_target: &Target) {\n-        if !self.well_known_values {\n+    pub fn fill_well_known(&mut self, current_target: &Target) {\n+        if !self.exhaustive_values && !self.exhaustive_names {\n             return;\n         }\n \n-        // NOTE: This should be kept in sync with `default_configuration` and\n-        // `fill_well_known_names`\n+        let no_values = || {\n+            let mut values = FxHashSet::default();\n+            values.insert(None);\n+            ExpectedValues::Some(values)\n+        };\n+\n+        let empty_values = || {\n+            let values = FxHashSet::default();\n+            ExpectedValues::Some(values)\n+        };\n+\n+        // NOTE: This should be kept in sync with `default_configuration`\n \n         let panic_values = &PanicStrategy::all();\n \n@@ -1174,6 +1194,9 @@ impl CrateCheckConfig {\n         // Unknown possible values:\n         //  - `feature`\n         //  - `target_feature`\n+        for name in [sym::feature, sym::target_feature] {\n+            self.expecteds.entry(name).or_insert(ExpectedValues::Any);\n+        }\n \n         // No-values\n         for name in [\n@@ -1187,20 +1210,23 @@ impl CrateCheckConfig {\n             sym::debug_assertions,\n             sym::target_thread_local,\n         ] {\n-            self.values_valid.entry(name).or_default();\n+            self.expecteds.entry(name).or_insert_with(no_values);\n         }\n \n         // Pre-defined values\n-        self.values_valid.entry(sym::panic).or_default().extend(panic_values);\n-        self.values_valid.entry(sym::sanitize).or_default().extend(sanitize_values);\n-        self.values_valid.entry(sym::target_has_atomic).or_default().extend(atomic_values);\n-        self.values_valid\n+        self.expecteds.entry(sym::panic).or_insert_with(empty_values).extend(panic_values);\n+        self.expecteds.entry(sym::sanitize).or_insert_with(empty_values).extend(sanitize_values);\n+        self.expecteds\n+            .entry(sym::target_has_atomic)\n+            .or_insert_with(no_values)\n+            .extend(atomic_values);\n+        self.expecteds\n             .entry(sym::target_has_atomic_load_store)\n-            .or_default()\n+            .or_insert_with(no_values)\n             .extend(atomic_values);\n-        self.values_valid\n+        self.expecteds\n             .entry(sym::target_has_atomic_equal_alignment)\n-            .or_default()\n+            .or_insert_with(no_values)\n             .extend(atomic_values);\n \n         // Target specific values\n@@ -1218,47 +1244,50 @@ impl CrateCheckConfig {\n \n             // Initialize (if not already initialized)\n             for &e in VALUES {\n-                self.values_valid.entry(e).or_default();\n+                let entry = self.expecteds.entry(e);\n+                if !self.exhaustive_values {\n+                    entry.or_insert(ExpectedValues::Any);\n+                } else {\n+                    entry.or_insert_with(empty_values);\n+                }\n             }\n \n-            // Get all values map at once otherwise it would be costly.\n-            // (8 values * 220 targets ~= 1760 times, at the time of writing this comment).\n-            let [\n-                values_target_os,\n-                values_target_family,\n-                values_target_arch,\n-                values_target_endian,\n-                values_target_env,\n-                values_target_abi,\n-                values_target_vendor,\n-                values_target_pointer_width,\n-            ] = self\n-                .values_valid\n-                .get_many_mut(VALUES)\n-                .expect(\"unable to get all the check-cfg values buckets\");\n-\n-            for target in TARGETS\n-                .iter()\n-                .map(|target| Target::expect_builtin(&TargetTriple::from_triple(target)))\n-                .chain(iter::once(current_target.clone()))\n-            {\n-                values_target_os.insert(Symbol::intern(&target.options.os));\n-                values_target_family\n-                    .extend(target.options.families.iter().map(|family| Symbol::intern(family)));\n-                values_target_arch.insert(Symbol::intern(&target.arch));\n-                values_target_endian.insert(Symbol::intern(target.options.endian.as_str()));\n-                values_target_env.insert(Symbol::intern(&target.options.env));\n-                values_target_abi.insert(Symbol::intern(&target.options.abi));\n-                values_target_vendor.insert(Symbol::intern(&target.options.vendor));\n-                values_target_pointer_width.insert(sym::integer(target.pointer_width));\n+            if self.exhaustive_values {\n+                // Get all values map at once otherwise it would be costly.\n+                // (8 values * 220 targets ~= 1760 times, at the time of writing this comment).\n+                let [\n+                    values_target_os,\n+                    values_target_family,\n+                    values_target_arch,\n+                    values_target_endian,\n+                    values_target_env,\n+                    values_target_abi,\n+                    values_target_vendor,\n+                    values_target_pointer_width,\n+                ] = self\n+                    .expecteds\n+                    .get_many_mut(VALUES)\n+                    .expect(\"unable to get all the check-cfg values buckets\");\n+\n+                for target in TARGETS\n+                    .iter()\n+                    .map(|target| Target::expect_builtin(&TargetTriple::from_triple(target)))\n+                    .chain(iter::once(current_target.clone()))\n+                {\n+                    values_target_os.insert(Symbol::intern(&target.options.os));\n+                    values_target_family.extend(\n+                        target.options.families.iter().map(|family| Symbol::intern(family)),\n+                    );\n+                    values_target_arch.insert(Symbol::intern(&target.arch));\n+                    values_target_endian.insert(Symbol::intern(target.options.endian.as_str()));\n+                    values_target_env.insert(Symbol::intern(&target.options.env));\n+                    values_target_abi.insert(Symbol::intern(&target.options.abi));\n+                    values_target_vendor.insert(Symbol::intern(&target.options.vendor));\n+                    values_target_pointer_width.insert(sym::integer(target.pointer_width));\n+                }\n             }\n         }\n     }\n-\n-    pub fn fill_well_known(&mut self, current_target: &Target) {\n-        self.fill_well_known_names();\n-        self.fill_well_known_values(current_target);\n-    }\n }\n \n pub fn build_configuration(sess: &Session, mut user_cfg: CrateConfig) -> CrateConfig {\n@@ -2244,6 +2273,7 @@ pub fn parse_externs(\n         let mut is_private_dep = false;\n         let mut add_prelude = true;\n         let mut nounused_dep = false;\n+        let mut force = false;\n         if let Some(opts) = options {\n             if !is_unstable_enabled {\n                 early_error(\n@@ -2266,6 +2296,7 @@ pub fn parse_externs(\n                         }\n                     }\n                     \"nounused\" => nounused_dep = true,\n+                    \"force\" => force = true,\n                     _ => early_error(error_format, &format!(\"unknown --extern option `{opt}`\")),\n                 }\n             }\n@@ -2276,6 +2307,8 @@ pub fn parse_externs(\n         entry.is_private_dep |= is_private_dep;\n         // likewise `nounused`\n         entry.nounused_dep |= nounused_dep;\n+        // and `force`\n+        entry.force |= force;\n         // If any flag is missing `noprelude`, then add to the prelude.\n         entry.add_prelude |= add_prelude;\n     }"}, {"sha": "546c0fa8e03e358484e7b59c2c9fd84fab47c37e", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::token;\n use rustc_ast::util::literal::LitError;\n use rustc_errors::{error_code, DiagnosticMessage, EmissionGuarantee, IntoDiagnostic, MultiSpan};\n use rustc_macros::Diagnostic;\n-use rustc_span::{Span, Symbol};\n+use rustc_span::{BytePos, Span, Symbol};\n use rustc_target::spec::{SplitDebuginfo, StackProtector, TargetTriple};\n \n #[derive(Diagnostic)]\n@@ -323,6 +323,13 @@ pub(crate) struct BinaryFloatLiteralNotSupported {\n     pub span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(session_nul_in_c_str)]\n+pub(crate) struct NulInCStr {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span: Span) {\n     // Checks if `s` looks like i32 or u1234 etc.\n     fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n@@ -401,6 +408,12 @@ pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span:\n             };\n             sess.emit_err(IntLiteralTooLarge { span, limit });\n         }\n+        LitError::NulInCStr(range) => {\n+            let lo = BytePos(span.lo().0 + range.start as u32 + 2);\n+            let hi = BytePos(span.lo().0 + range.end as u32 + 2);\n+            let span = span.with_lo(lo).with_hi(hi);\n+            sess.emit_err(NulInCStr { span });\n+        }\n     }\n }\n "}, {"sha": "243da98c3c28a3038d74c2c6e56269b21f05db21", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1235,6 +1235,8 @@ options! {\n         line-tables-only, limited, or full; default: 0)\"),\n     default_linker_libraries: bool = (false, parse_bool, [UNTRACKED],\n         \"allow the linker to link its default libraries (default: no)\"),\n+    dlltool: Option<PathBuf> = (None, parse_opt_pathbuf, [UNTRACKED],\n+        \"import library generation tool (ignored except when targeting windows-gnu)\"),\n     embed_bitcode: bool = (true, parse_bool, [TRACKED],\n         \"emit bitcode in rlibs (default: yes)\"),\n     extra_filename: String = (String::new(), parse_string, [UNTRACKED],\n@@ -1391,8 +1393,6 @@ options! {\n         (default: no)\"),\n     diagnostic_width: Option<usize> = (None, parse_opt_number, [UNTRACKED],\n         \"set the current output width for diagnostic truncation\"),\n-    dlltool: Option<PathBuf> = (None, parse_opt_pathbuf, [UNTRACKED],\n-        \"import library generation tool (windows-gnu only)\"),\n     dont_buffer_diagnostics: bool = (false, parse_bool, [UNTRACKED],\n         \"emit diagnostics rather than buffering (breaks NLL error downgrading, sorting) \\\n         (default: no)\"),"}, {"sha": "7bbab34c69a383d83010232751ff14a05aabd872", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1744,6 +1744,28 @@ impl SourceFile {\n         BytePos::from_u32(pos.0 - self.start_pos.0 + diff)\n     }\n \n+    /// Calculates a normalized byte position from a byte offset relative to the\n+    /// start of the file.\n+    ///\n+    /// When we get an inline assembler error from LLVM during codegen, we\n+    /// import the expanded assembly code as a new `SourceFile`, which can then\n+    /// be used for error reporting with spans. However the byte offsets given\n+    /// to us by LLVM are relative to the start of the original buffer, not the\n+    /// normalized one. Hence we need to convert those offsets to the normalized\n+    /// form when constructing spans.\n+    pub fn normalized_byte_pos(&self, offset: u32) -> BytePos {\n+        let diff = match self\n+            .normalized_pos\n+            .binary_search_by(|np| (np.pos.0 + np.diff).cmp(&(self.start_pos.0 + offset)))\n+        {\n+            Ok(i) => self.normalized_pos[i].diff,\n+            Err(i) if i == 0 => 0,\n+            Err(i) => self.normalized_pos[i - 1].diff,\n+        };\n+\n+        BytePos::from_u32(self.start_pos.0 + offset - diff)\n+    }\n+\n     /// Converts an absolute `BytePos` to a `CharPos` relative to the `SourceFile`.\n     pub fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n         // The number of extra bytes due to multibyte chars in the `SourceFile`.\n@@ -2199,6 +2221,7 @@ pub struct ErrorGuaranteed(());\n impl ErrorGuaranteed {\n     /// To be used only if you really know what you are doing... ideally, we would find a way to\n     /// eliminate all calls to this method.\n+    #[deprecated = \"`Session::delay_span_bug` should be preferred over this function\"]\n     pub fn unchecked_claim_error_was_emitted() -> Self {\n         ErrorGuaranteed(())\n     }"}, {"sha": "b97ec6c684b493d4df3d6f702199b7acd5b80b2b", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -441,6 +441,7 @@ symbols! {\n         bridge,\n         bswap,\n         c_str,\n+        c_str_literals,\n         c_unwind,\n         c_variadic,\n         c_void,\n@@ -1206,6 +1207,7 @@ symbols! {\n         require,\n         residual,\n         result,\n+        resume,\n         return_position_impl_trait_in_trait,\n         return_type_notation,\n         rhs,"}, {"sha": "705966f52370e4326dc7f9cb76d1fab22f6bedc2", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -839,6 +839,7 @@ pub enum InlineAsmClobberAbi {\n     AArch64,\n     AArch64NoX18,\n     RiscV,\n+    LoongArch,\n }\n \n impl InlineAsmClobberAbi {\n@@ -880,6 +881,10 @@ impl InlineAsmClobberAbi {\n                 \"C\" | \"system\" | \"efiapi\" => Ok(InlineAsmClobberAbi::RiscV),\n                 _ => Err(&[\"C\", \"system\", \"efiapi\"]),\n             },\n+            InlineAsmArch::LoongArch64 => match name {\n+                \"C\" | \"system\" | \"efiapi\" => Ok(InlineAsmClobberAbi::LoongArch),\n+                _ => Err(&[\"C\", \"system\", \"efiapi\"]),\n+            },\n             _ => Err(&[]),\n         }\n     }\n@@ -1022,6 +1027,21 @@ impl InlineAsmClobberAbi {\n                     v24, v25, v26, v27, v28, v29, v30, v31,\n                 }\n             },\n+            InlineAsmClobberAbi::LoongArch => clobbered_regs! {\n+                LoongArch LoongArchInlineAsmReg {\n+                    // ra\n+                    r1,\n+                    // a0-a7\n+                    r4, r5, r6, r7, r8, r9, r10, r11,\n+                    // t0-t8\n+                    r12, r13, r14, r15, r16, r17, r18, r19, r20,\n+                    // fa0-fa7\n+                    f0, f1, f2, f3, f4, f5, f6, f7,\n+                    // ft0-ft15\n+                    f8, f9, f10, f11, f12, f13, f14, f15,\n+                    f16, f17, f18, f19, f20, f21, f22, f23,\n+                }\n+            },\n         }\n     }\n }"}, {"sha": "7e1dba4ed2626da668a5b97471ac9858477ec44e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/method_chain.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/dd9df18792cd13b25a54406ef60e3b32ac358272/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9df18792cd13b25a54406ef60e3b32ac358272/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs?ref=dd9df18792cd13b25a54406ef60e3b32ac358272", "patch": "@@ -1,102 +0,0 @@\n-use crate::infer::InferCtxt;\n-\n-use rustc_infer::infer::ObligationEmittingRelation;\n-use rustc_infer::traits::PredicateObligations;\n-use rustc_middle::ty::error::TypeError;\n-use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n-\n-pub struct CollectAllMismatches<'a, 'tcx> {\n-    pub infcx: &'a InferCtxt<'tcx>,\n-    pub param_env: ty::ParamEnv<'tcx>,\n-    pub errors: Vec<TypeError<'tcx>>,\n-}\n-\n-impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n-    fn tag(&self) -> &'static str {\n-        \"CollectAllMismatches\"\n-    }\n-\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-        self.param_env\n-    }\n-\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        _: ty::Variance,\n-        _: ty::VarianceDiagInfo<'tcx>,\n-        a: T,\n-        b: T,\n-    ) -> RelateResult<'tcx, T> {\n-        self.relate(a, b)\n-    }\n-\n-    fn regions(\n-        &mut self,\n-        a: ty::Region<'tcx>,\n-        _b: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        Ok(a)\n-    }\n-\n-    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        self.infcx.probe(|_| {\n-            if a.is_ty_var() || b.is_ty_var() {\n-                Ok(a)\n-            } else {\n-                self.infcx.super_combine_tys(self, a, b).or_else(|e| {\n-                    self.errors.push(e);\n-                    Ok(a)\n-                })\n-            }\n-        })\n-    }\n-\n-    fn consts(\n-        &mut self,\n-        a: ty::Const<'tcx>,\n-        b: ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n-        self.infcx.probe(|_| {\n-            if a.is_ct_infer() || b.is_ct_infer() {\n-                Ok(a)\n-            } else {\n-                relate::super_relate_consts(self, a, b) // could do something similar here for constants!\n-            }\n-        })\n-    }\n-\n-    fn binders<T: Relate<'tcx>>(\n-        &mut self,\n-        a: ty::Binder<'tcx, T>,\n-        b: ty::Binder<'tcx, T>,\n-    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>> {\n-        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n-    }\n-}\n-\n-impl<'tcx> ObligationEmittingRelation<'tcx> for CollectAllMismatches<'_, 'tcx> {\n-    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n-        // FIXME(deferred_projection_equality): We really should get rid of this relation.\n-        ty::AliasRelationDirection::Equate\n-    }\n-\n-    fn register_obligations(&mut self, _obligations: PredicateObligations<'tcx>) {\n-        // FIXME(deferred_projection_equality)\n-    }\n-\n-    fn register_predicates(\n-        &mut self,\n-        _obligations: impl IntoIterator<Item: ty::ToPredicate<'tcx>>,\n-    ) {\n-        // FIXME(deferred_projection_equality)\n-    }\n-}"}, {"sha": "afb64da8b61738966ee1171e5b2f96c8e004c054", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,5 +1,4 @@\n mod ambiguity;\n-pub mod method_chain;\n pub mod on_unimplemented;\n pub mod suggestions;\n \n@@ -559,6 +558,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             suggest_increasing_limit,\n             |err| {\n                 self.note_obligation_cause_code(\n+                    obligation.cause.body_id,\n                     err,\n                     predicate,\n                     obligation.param_env,\n@@ -1431,6 +1431,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 | ObligationCauseCode::ExprItemObligation(..) = code\n                 {\n                     self.note_obligation_cause_code(\n+                        error.obligation.cause.body_id,\n                         &mut diag,\n                         error.obligation.predicate,\n                         error.obligation.param_env,\n@@ -2544,6 +2545,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         // message, and fall back to regular note otherwise.\n         if !self.maybe_note_obligation_cause_for_async_await(err, obligation) {\n             self.note_obligation_cause_code(\n+                obligation.cause.body_id,\n                 err,\n                 obligation.predicate,\n                 obligation.param_env,"}, {"sha": "53bf38c0a340fddfd5d4b7d643af6fff5e9a096f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -25,10 +25,9 @@ use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n use rustc_hir::{Expr, HirId};\n use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{InferOk, LateBoundRegionConversionTime};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk, LateBoundRegionConversionTime};\n use rustc_middle::hir::map;\n use rustc_middle::ty::error::TypeError::{self, Sorts};\n-use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind,\n     GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, InternalSubsts,\n@@ -39,9 +38,9 @@ use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{BytePos, DesugaringKind, ExpnKind, MacroKind, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n+use std::iter;\n use std::ops::Deref;\n \n-use super::method_chain::CollectAllMismatches;\n use super::InferCtxtPrivExt;\n use crate::infer::InferCtxtExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -319,6 +318,7 @@ pub trait TypeErrCtxtExt<'tcx> {\n \n     fn note_obligation_cause_code<T>(\n         &self,\n+        body_id: LocalDefId,\n         err: &mut Diagnostic,\n         predicate: T,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -359,8 +359,9 @@ pub trait TypeErrCtxtExt<'tcx> {\n     );\n     fn note_function_argument_obligation(\n         &self,\n-        arg_hir_id: HirId,\n+        body_id: LocalDefId,\n         err: &mut Diagnostic,\n+        arg_hir_id: HirId,\n         parent_code: &ObligationCauseCode<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         predicate: ty::Predicate<'tcx>,\n@@ -2742,6 +2743,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         // bound that introduced the obligation (e.g. `T: Send`).\n         debug!(?next_code);\n         self.note_obligation_cause_code(\n+            obligation.cause.body_id,\n             err,\n             obligation.predicate,\n             obligation.param_env,\n@@ -2753,6 +2755,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n     fn note_obligation_cause_code<T>(\n         &self,\n+        body_id: LocalDefId,\n         err: &mut Diagnostic,\n         predicate: T,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -2790,7 +2793,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             | ObligationCauseCode::LetElse\n             | ObligationCauseCode::BinOp { .. }\n             | ObligationCauseCode::AscribeUserTypeProvePredicate(..)\n-            | ObligationCauseCode::RustCall => {}\n+            | ObligationCauseCode::RustCall\n+            | ObligationCauseCode::DropImpl => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }\n@@ -3152,6 +3156,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     // #74711: avoid a stack overflow\n                     ensure_sufficient_stack(|| {\n                         self.note_obligation_cause_code(\n+                            body_id,\n                             err,\n                             parent_predicate,\n                             param_env,\n@@ -3163,6 +3168,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 } else {\n                     ensure_sufficient_stack(|| {\n                         self.note_obligation_cause_code(\n+                            body_id,\n                             err,\n                             parent_predicate,\n                             param_env,\n@@ -3292,6 +3298,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // #74711: avoid a stack overflow\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n+                        body_id,\n                         err,\n                         parent_predicate,\n                         param_env,\n@@ -3307,6 +3314,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // #74711: avoid a stack overflow\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n+                        body_id,\n                         err,\n                         parent_predicate,\n                         param_env,\n@@ -3323,15 +3331,17 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ..\n             } => {\n                 self.note_function_argument_obligation(\n-                    arg_hir_id,\n+                    body_id,\n                     err,\n+                    arg_hir_id,\n                     parent_code,\n                     param_env,\n                     predicate,\n                     call_hir_id,\n                 );\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n+                        body_id,\n                         err,\n                         predicate,\n                         param_env,\n@@ -3553,8 +3563,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     }\n     fn note_function_argument_obligation(\n         &self,\n-        arg_hir_id: HirId,\n+        body_id: LocalDefId,\n         err: &mut Diagnostic,\n+        arg_hir_id: HirId,\n         parent_code: &ObligationCauseCode<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         failed_pred: ty::Predicate<'tcx>,\n@@ -3587,7 +3598,6 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             // to an associated type (as seen from `trait_pred`) in the predicate. Like in\n             // trait_pred `S: Sum<<Self as Iterator>::Item>` and predicate `i32: Sum<&()>`\n             let mut type_diffs = vec![];\n-\n             if let ObligationCauseCode::ExprBindingObligation(def_id, _, _, idx) = parent_code.deref()\n                 && let Some(node_substs) = typeck_results.node_substs_opt(call_hir_id)\n                 && let where_clauses = self.tcx.predicates_of(def_id).instantiate(self.tcx, node_substs)\n@@ -3596,14 +3606,26 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 if let Some(where_pred) = where_pred.to_opt_poly_trait_pred()\n                     && let Some(failed_pred) = failed_pred.to_opt_poly_trait_pred()\n                 {\n-                    let mut c = CollectAllMismatches {\n-                        infcx: self.infcx,\n-                        param_env,\n-                        errors: vec![],\n+                    let where_pred = self.instantiate_binder_with_placeholders(where_pred);\n+                    let failed_pred = self.instantiate_binder_with_fresh_vars(\n+                        expr.span,\n+                        LateBoundRegionConversionTime::FnCall,\n+                        failed_pred\n+                    );\n+\n+                    let zipped =\n+                        iter::zip(where_pred.trait_ref.substs, failed_pred.trait_ref.substs);\n+                    for (expected, actual) in zipped {\n+                        self.probe(|_| {\n+                            match self\n+                                .at(&ObligationCause::misc(expr.span, body_id), param_env)\n+                                .eq(DefineOpaqueTypes::No, expected, actual)\n+                            {\n+                                Ok(_) => (), // We ignore nested obligations here for now.\n+                                Err(err) => type_diffs.push(err),\n+                            }\n+                        })\n                     };\n-                    if let Ok(_) = c.relate(where_pred, failed_pred) {\n-                        type_diffs = c.errors;\n-                    }\n                 } else if let Some(where_pred) = where_pred.to_opt_poly_projection_pred()\n                     && let Some(failed_pred) = failed_pred.to_opt_poly_projection_pred()\n                     && let Some(found) = failed_pred.skip_binder().term.ty()"}, {"sha": "d8e5725d3cafaa438640fa1aaa6137347c4480eb", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -62,7 +62,7 @@ pub use self::util::elaborate;\n pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n pub use self::util::{get_vtable_index_of_object_method, impl_item_is_final, upcast_choices};\n pub use self::util::{\n-    supertrait_def_ids, supertraits, transitive_bounds, transitive_bounds_that_define_assoc_type,\n+    supertrait_def_ids, supertraits, transitive_bounds, transitive_bounds_that_define_assoc_item,\n     SupertraitDefIds,\n };\n "}, {"sha": "b10aaad5f2af41fdc5a5e38ce2db87c639b6c091", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 71, "deletions": 13, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -177,15 +177,55 @@ fn resolve_associated_item<'tcx>(\n \n             Some(ty::Instance::new(leaf_def.item.def_id, substs))\n         }\n-        traits::ImplSource::Generator(generator_data) => Some(Instance {\n-            def: ty::InstanceDef::Item(generator_data.generator_def_id),\n-            substs: generator_data.substs,\n-        }),\n-        traits::ImplSource::Future(future_data) => Some(Instance {\n-            def: ty::InstanceDef::Item(future_data.generator_def_id),\n-            substs: future_data.substs,\n-        }),\n+        traits::ImplSource::Generator(generator_data) => {\n+            if cfg!(debug_assertions) && tcx.item_name(trait_item_id) != sym::resume {\n+                // For compiler developers who'd like to add new items to `Generator`,\n+                // you either need to generate a shim body, or perhaps return\n+                // `InstanceDef::Item` pointing to a trait default method body if\n+                // it is given a default implementation by the trait.\n+                span_bug!(\n+                    tcx.def_span(generator_data.generator_def_id),\n+                    \"no definition for `{trait_ref}::{}` for built-in generator type\",\n+                    tcx.item_name(trait_item_id)\n+                )\n+            }\n+            Some(Instance {\n+                def: ty::InstanceDef::Item(generator_data.generator_def_id),\n+                substs: generator_data.substs,\n+            })\n+        }\n+        traits::ImplSource::Future(future_data) => {\n+            if cfg!(debug_assertions) && tcx.item_name(trait_item_id) != sym::poll {\n+                // For compiler developers who'd like to add new items to `Future`,\n+                // you either need to generate a shim body, or perhaps return\n+                // `InstanceDef::Item` pointing to a trait default method body if\n+                // it is given a default implementation by the trait.\n+                span_bug!(\n+                    tcx.def_span(future_data.generator_def_id),\n+                    \"no definition for `{trait_ref}::{}` for built-in async generator type\",\n+                    tcx.item_name(trait_item_id)\n+                )\n+            }\n+            Some(Instance {\n+                def: ty::InstanceDef::Item(future_data.generator_def_id),\n+                substs: future_data.substs,\n+            })\n+        }\n         traits::ImplSource::Closure(closure_data) => {\n+            if cfg!(debug_assertions)\n+                && ![sym::call, sym::call_mut, sym::call_once]\n+                    .contains(&tcx.item_name(trait_item_id))\n+            {\n+                // For compiler developers who'd like to add new items to `Fn`/`FnMut`/`FnOnce`,\n+                // you either need to generate a shim body, or perhaps return\n+                // `InstanceDef::Item` pointing to a trait default method body if\n+                // it is given a default implementation by the trait.\n+                span_bug!(\n+                    tcx.def_span(closure_data.closure_def_id),\n+                    \"no definition for `{trait_ref}::{}` for built-in closure type\",\n+                    tcx.item_name(trait_item_id)\n+                )\n+            }\n             let trait_closure_kind = tcx.fn_trait_kind_from_def_id(trait_id).unwrap();\n             Instance::resolve_closure(\n                 tcx,\n@@ -195,11 +235,29 @@ fn resolve_associated_item<'tcx>(\n             )\n         }\n         traits::ImplSource::FnPointer(ref data) => match data.fn_ty.kind() {\n-            ty::FnDef(..) | ty::FnPtr(..) => Some(Instance {\n-                def: ty::InstanceDef::FnPtrShim(trait_item_id, data.fn_ty),\n-                substs: rcvr_substs,\n-            }),\n-            _ => None,\n+            ty::FnDef(..) | ty::FnPtr(..) => {\n+                if cfg!(debug_assertions)\n+                    && ![sym::call, sym::call_mut, sym::call_once]\n+                        .contains(&tcx.item_name(trait_item_id))\n+                {\n+                    // For compiler developers who'd like to add new items to `Fn`/`FnMut`/`FnOnce`,\n+                    // you either need to generate a shim body, or perhaps return\n+                    // `InstanceDef::Item` pointing to a trait default method body if\n+                    // it is given a default implementation by the trait.\n+                    bug!(\n+                        \"no definition for `{trait_ref}::{}` for built-in fn type\",\n+                        tcx.item_name(trait_item_id)\n+                    )\n+                }\n+                Some(Instance {\n+                    def: ty::InstanceDef::FnPtrShim(trait_item_id, data.fn_ty),\n+                    substs: rcvr_substs,\n+                })\n+            }\n+            _ => bug!(\n+                \"no built-in definition for `{trait_ref}::{}` for non-fn type\",\n+                tcx.item_name(trait_item_id)\n+            ),\n         },\n         traits::ImplSource::Object(ref data) => {\n             traits::get_vtable_index_of_object_method(tcx, data, trait_item_id).map(|index| {"}, {"sha": "c4a4cda68016dccc8599902bd48bd682d5ccb5ca", "filename": "compiler/rustc_ty_utils/src/layout_sanity_check.rs", "status": "modified", "additions": 40, "deletions": 54, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -4,7 +4,7 @@ use rustc_middle::ty::{\n };\n use rustc_target::abi::*;\n \n-use std::cmp;\n+use std::assert_matches::assert_matches;\n \n /// Enforce some basic invariants on layouts.\n pub(super) fn sanity_check_layout<'tcx>(\n@@ -68,21 +68,31 @@ pub(super) fn sanity_check_layout<'tcx>(\n     }\n \n     fn check_layout_abi<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLayout<'tcx>) {\n+        // Verify the ABI mandated alignment and size.\n+        let align = layout.abi.inherent_align(cx).map(|align| align.abi);\n+        let size = layout.abi.inherent_size(cx);\n+        let Some((align, size)) = align.zip(size) else {\n+            assert_matches!(\n+                layout.layout.abi(),\n+                Abi::Uninhabited | Abi::Aggregate { .. },\n+                \"ABI unexpectedly missing alignment and/or size in {layout:#?}\"\n+            );\n+            return\n+        };\n+        assert_eq!(\n+            layout.layout.align().abi,\n+            align,\n+            \"alignment mismatch between ABI and layout in {layout:#?}\"\n+        );\n+        assert_eq!(\n+            layout.layout.size(),\n+            size,\n+            \"size mismatch between ABI and layout in {layout:#?}\"\n+        );\n+\n+        // Verify per-ABI invariants\n         match layout.layout.abi() {\n-            Abi::Scalar(scalar) => {\n-                // No padding in scalars.\n-                let size = scalar.size(cx);\n-                let align = scalar.align(cx).abi;\n-                assert_eq!(\n-                    layout.layout.size(),\n-                    size,\n-                    \"size mismatch between ABI and layout in {layout:#?}\"\n-                );\n-                assert_eq!(\n-                    layout.layout.align().abi,\n-                    align,\n-                    \"alignment mismatch between ABI and layout in {layout:#?}\"\n-                );\n+            Abi::Scalar(_) => {\n                 // Check that this matches the underlying field.\n                 let inner = skip_newtypes(cx, layout);\n                 assert!(\n@@ -135,24 +145,6 @@ pub(super) fn sanity_check_layout<'tcx>(\n                 }\n             }\n             Abi::ScalarPair(scalar1, scalar2) => {\n-                // Sanity-check scalar pairs. Computing the expected size and alignment is a bit of work.\n-                let size1 = scalar1.size(cx);\n-                let align1 = scalar1.align(cx).abi;\n-                let size2 = scalar2.size(cx);\n-                let align2 = scalar2.align(cx).abi;\n-                let align = cmp::max(align1, align2);\n-                let field2_offset = size1.align_to(align2);\n-                let size = (field2_offset + size2).align_to(align);\n-                assert_eq!(\n-                    layout.layout.size(),\n-                    size,\n-                    \"size mismatch between ABI and layout in {layout:#?}\"\n-                );\n-                assert_eq!(\n-                    layout.layout.align().abi,\n-                    align,\n-                    \"alignment mismatch between ABI and layout in {layout:#?}\",\n-                );\n                 // Check that the underlying pair of fields matches.\n                 let inner = skip_newtypes(cx, layout);\n                 assert!(\n@@ -189,8 +181,9 @@ pub(super) fn sanity_check_layout<'tcx>(\n                         \"`ScalarPair` layout for type with less than two non-ZST fields: {inner:#?}\"\n                     )\n                 });\n-                assert!(\n-                    fields.next().is_none(),\n+                assert_matches!(\n+                    fields.next(),\n+                    None,\n                     \"`ScalarPair` layout for type with at least three non-ZST fields: {inner:#?}\"\n                 );\n                 // The fields might be in opposite order.\n@@ -200,6 +193,10 @@ pub(super) fn sanity_check_layout<'tcx>(\n                     (offset2, field2, offset1, field1)\n                 };\n                 // The fields should be at the right offset, and match the `scalar` layout.\n+                let size1 = scalar1.size(cx);\n+                let align1 = scalar1.align(cx).abi;\n+                let size2 = scalar2.size(cx);\n+                let align2 = scalar2.align(cx).abi;\n                 assert_eq!(\n                     offset1,\n                     Size::ZERO,\n@@ -213,10 +210,12 @@ pub(super) fn sanity_check_layout<'tcx>(\n                     field1.align.abi, align1,\n                     \"`ScalarPair` first field with bad align in {inner:#?}\",\n                 );\n-                assert!(\n-                    matches!(field1.abi, Abi::Scalar(_)),\n+                assert_matches!(\n+                    field1.abi,\n+                    Abi::Scalar(_),\n                     \"`ScalarPair` first field with bad ABI in {inner:#?}\",\n                 );\n+                let field2_offset = size1.align_to(align2);\n                 assert_eq!(\n                     offset2, field2_offset,\n                     \"`ScalarPair` second field at bad offset in {inner:#?}\",\n@@ -229,27 +228,14 @@ pub(super) fn sanity_check_layout<'tcx>(\n                     field2.align.abi, align2,\n                     \"`ScalarPair` second field with bad align in {inner:#?}\",\n                 );\n-                assert!(\n-                    matches!(field2.abi, Abi::Scalar(_)),\n+                assert_matches!(\n+                    field2.abi,\n+                    Abi::Scalar(_),\n                     \"`ScalarPair` second field with bad ABI in {inner:#?}\",\n                 );\n             }\n-            Abi::Vector { count, element } => {\n-                // No padding in vectors, except possibly for trailing padding to make the size a multiple of align.\n-                let size = element.size(cx) * count;\n-                let align = cx.data_layout().vector_align(size).abi;\n-                let size = size.align_to(align); // needed e.g. for vectors of size 3\n+            Abi::Vector { element, .. } => {\n                 assert!(align >= element.align(cx).abi); // just sanity-checking `vector_align`.\n-                assert_eq!(\n-                    layout.layout.size(),\n-                    size,\n-                    \"size mismatch between ABI and layout in {layout:#?}\"\n-                );\n-                assert_eq!(\n-                    layout.layout.align().abi,\n-                    align,\n-                    \"alignment mismatch between ABI and layout in {layout:#?}\"\n-                );\n                 // FIXME: Do some kind of check of the inner type, like for Scalar and ScalarPair.\n             }\n             Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check."}, {"sha": "73a2f6af579a6321d95c50fdfcdbdf0637a84e2e", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -5,6 +5,7 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(assert_matches)]\n #![feature(iterator_try_collect)]\n #![feature(let_chains)]\n #![feature(never_type)]"}, {"sha": "2daef82d6f1ddcd77194dd4ebba92fe6a3cd432c", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -3079,8 +3079,8 @@ impl<'a, K, V, A> CursorMut<'a, K, V, A> {\n                 unsafe { self.root.reborrow() }\n                     .as_mut()?\n                     .borrow_mut()\n-                    .first_leaf_edge()\n-                    .next_kv()\n+                    .last_leaf_edge()\n+                    .next_back_kv()\n                     .ok()?\n                     .into_kv_valmut()\n             }"}, {"sha": "7ecffe3eef2d5ac05032713132825dcd0d1f0579", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -8,6 +8,7 @@ use crate::testing::crash_test::{CrashTestDummy, Panic};\n use crate::testing::ord_chaos::{Cyclic3, Governed, Governor};\n use crate::testing::rng::DeterministicRng;\n use crate::vec::Vec;\n+use core::assert_matches::assert_matches;\n use std::cmp::Ordering;\n use std::iter;\n use std::mem;\n@@ -2448,3 +2449,21 @@ fn test_cursor_mut_insert_after_4() {\n     let mut cur = map.upper_bound_mut(Bound::Included(&2));\n     cur.insert_after(4, 'd');\n }\n+\n+#[test]\n+fn cursor_peek_prev_agrees_with_cursor_mut() {\n+    let mut map = BTreeMap::from([(1, 1), (2, 2), (3, 3)]);\n+\n+    let cursor = map.lower_bound(Bound::Excluded(&3));\n+    assert!(cursor.key().is_none());\n+\n+    let prev = cursor.peek_prev();\n+    assert_matches!(prev, Some((&3, _)));\n+\n+    // Shadow names so the two parts of this test match.\n+    let mut cursor = map.lower_bound_mut(Bound::Excluded(&3));\n+    assert!(cursor.key().is_none());\n+\n+    let prev = cursor.peek_prev();\n+    assert_matches!(prev, Some((&3, _)));\n+}"}, {"sha": "3fea9a44049fb1e4a45d76a66417d40251eeb71c", "filename": "library/core/src/array/ascii.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Farray%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Farray%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fascii.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -4,10 +4,23 @@ use crate::ascii;\n impl<const N: usize> [u8; N] {\n     /// Converts this array of bytes into a array of ASCII characters,\n     /// or returns `None` if any of the characters is non-ASCII.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_char)]\n+    /// #![feature(const_option)]\n+    ///\n+    /// const HEX_DIGITS: [std::ascii::Char; 16] =\n+    ///     *b\"0123456789abcdef\".as_ascii().unwrap();\n+    ///\n+    /// assert_eq!(HEX_DIGITS[1].as_str(), \"1\");\n+    /// assert_eq!(HEX_DIGITS[10].as_str(), \"a\");\n+    /// ```\n     #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n     #[must_use]\n     #[inline]\n-    pub fn as_ascii(&self) -> Option<&[ascii::Char; N]> {\n+    pub const fn as_ascii(&self) -> Option<&[ascii::Char; N]> {\n         if self.is_ascii() {\n             // SAFETY: Just checked that it's ASCII\n             Some(unsafe { self.as_ascii_unchecked() })"}, {"sha": "07b11814f965f63b15f99265a37eb1000da87b51", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -79,9 +79,9 @@ use crate::str;\n ///\n /// [str]: prim@str \"str\"\n #[derive(Hash)]\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"CStr\")]\n #[stable(feature = \"core_c_str\", since = \"1.64.0\")]\n #[rustc_has_incoherent_inherent_impls]\n+#[cfg_attr(not(bootstrap), lang = \"CStr\")]\n // FIXME:\n // `fn from` in `impl From<&CStr> for Box<CStr>` current implementation relies\n // on `CStr` being layout-compatible with `[u8]`."}, {"sha": "2568aaf34f3fbe1dd098e7d9e5445e9dd01affa0", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -310,6 +310,7 @@ where\n /// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n /// this type.\n #[derive(Clone, Debug)]\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n struct FlattenCompat<I, U> {\n     iter: Fuse<I>,\n     frontiter: Option<U>,\n@@ -463,6 +464,7 @@ where\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n impl<I, U> Iterator for FlattenCompat<I, U>\n where\n     I: Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n@@ -577,6 +579,7 @@ where\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n where\n     I: DoubleEndedIterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n@@ -646,20 +649,23 @@ where\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<const N: usize, I, T> TrustedLen\n     for FlattenCompat<I, <[T; N] as IntoIterator>::IntoIter>\n where\n     I: TrustedLen<Item = [T; N]>,\n {\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, const N: usize, I, T> TrustedLen\n     for FlattenCompat<I, <&'a [T; N] as IntoIterator>::IntoIter>\n where\n     I: TrustedLen<Item = &'a [T; N]>,\n {\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, const N: usize, I, T> TrustedLen\n     for FlattenCompat<I, <&'a mut [T; N] as IntoIterator>::IntoIter>\n where"}, {"sha": "3abf66dbe29085283cfab8a68942668f54839401", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -150,6 +150,7 @@\n #![feature(const_slice_from_raw_parts_mut)]\n #![feature(const_slice_from_ref)]\n #![feature(const_slice_index)]\n+#![feature(const_slice_is_ascii)]\n #![feature(const_slice_ptr_len)]\n #![feature(const_slice_split_at_mut)]\n #![feature(const_str_from_utf8_unchecked_mut)]"}, {"sha": "d09a24b4b1d5be860affd89ff50d62ca38f34046", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1287,7 +1287,7 @@ impl<T, const N: usize> MaybeUninit<[T; N]> {\n     #[inline]\n     pub const fn transpose(self) -> [MaybeUninit<T>; N] {\n         // SAFETY: T and MaybeUninit<T> have the same layout\n-        unsafe { super::transmute_copy(&ManuallyDrop::new(self)) }\n+        unsafe { intrinsics::transmute_unchecked(self) }\n     }\n }\n \n@@ -1307,6 +1307,6 @@ impl<T, const N: usize> [MaybeUninit<T>; N] {\n     #[inline]\n     pub const fn transpose(self) -> MaybeUninit<[T; N]> {\n         // SAFETY: T and MaybeUninit<T> have the same layout\n-        unsafe { super::transmute_copy(&ManuallyDrop::new(self)) }\n+        unsafe { intrinsics::transmute_unchecked(self) }\n     }\n }"}, {"sha": "8396aecf947a1a1d2b73073447f460849387cfff", "filename": "library/core/src/net/socket_addr.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Fnet%2Fsocket_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Fnet%2Fsocket_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnet%2Fsocket_addr.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -122,6 +122,7 @@ impl SocketAddr {\n     #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n     #[must_use]\n     #[rustc_const_stable(feature = \"const_socketaddr\", since = \"1.69.0\")]\n+    #[inline]\n     pub const fn new(ip: IpAddr, port: u16) -> SocketAddr {\n         match ip {\n             IpAddr::V4(a) => SocketAddr::V4(SocketAddrV4::new(a, port)),\n@@ -142,6 +143,7 @@ impl SocketAddr {\n     #[must_use]\n     #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n     #[rustc_const_stable(feature = \"const_socketaddr\", since = \"1.69.0\")]\n+    #[inline]\n     pub const fn ip(&self) -> IpAddr {\n         match *self {\n             SocketAddr::V4(ref a) => IpAddr::V4(*a.ip()),\n@@ -161,6 +163,7 @@ impl SocketAddr {\n     /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn set_ip(&mut self, new_ip: IpAddr) {\n         // `match (*self, new_ip)` would have us mutate a copy of self only to throw it away.\n         match (self, new_ip) {\n@@ -183,6 +186,7 @@ impl SocketAddr {\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_socketaddr\", since = \"1.69.0\")]\n+    #[inline]\n     pub const fn port(&self) -> u16 {\n         match *self {\n             SocketAddr::V4(ref a) => a.port(),\n@@ -202,6 +206,7 @@ impl SocketAddr {\n     /// assert_eq!(socket.port(), 1025);\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn set_port(&mut self, new_port: u16) {\n         match *self {\n             SocketAddr::V4(ref mut a) => a.set_port(new_port),\n@@ -227,6 +232,7 @@ impl SocketAddr {\n     #[must_use]\n     #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n     #[rustc_const_stable(feature = \"const_socketaddr\", since = \"1.69.0\")]\n+    #[inline]\n     pub const fn is_ipv4(&self) -> bool {\n         matches!(*self, SocketAddr::V4(_))\n     }\n@@ -249,6 +255,7 @@ impl SocketAddr {\n     #[must_use]\n     #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n     #[rustc_const_stable(feature = \"const_socketaddr\", since = \"1.69.0\")]\n+    #[inline]\n     pub const fn is_ipv6(&self) -> bool {\n         matches!(*self, SocketAddr::V6(_))\n     }\n@@ -269,6 +276,7 @@ impl SocketAddrV4 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n     #[rustc_const_stable(feature = \"const_socketaddr\", since = \"1.69.0\")]\n+    #[inline]\n     pub const fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4 {\n         SocketAddrV4 { ip, port }\n     }\n@@ -286,6 +294,7 @@ impl SocketAddrV4 {\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_socketaddr\", since = \"1.69.0\")]\n+    #[inline]\n     pub const fn ip(&self) -> &Ipv4Addr {\n         &self.ip\n     }\n@@ -302,6 +311,7 @@ impl SocketAddrV4 {\n     /// assert_eq!(socket.ip(), &Ipv4Addr::new(192, 168, 0, 1));\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn set_ip(&mut self, new_ip: Ipv4Addr) {\n         self.ip = new_ip;\n     }\n@@ -319,6 +329,7 @@ impl SocketAddrV4 {\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_socketaddr\", since = \"1.69.0\")]\n+    #[inline]\n     pub const fn port(&self) -> u16 {\n         self.port\n     }\n@@ -335,6 +346,7 @@ impl SocketAddrV4 {\n     /// assert_eq!(socket.port(), 4242);\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn set_port(&mut self, new_port: u16) {\n         self.port = new_port;\n     }\n@@ -360,6 +372,7 @@ impl SocketAddrV6 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n     #[rustc_const_stable(feature = \"const_socketaddr\", since = \"1.69.0\")]\n+    #[inline]\n     pub const fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32) -> SocketAddrV6 {\n         SocketAddrV6 { ip, port, flowinfo, scope_id }\n     }\n@@ -377,6 +390,7 @@ impl SocketAddrV6 {\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_socketaddr\", since = \"1.69.0\")]\n+    #[inline]\n     pub const fn ip(&self) -> &Ipv6Addr {\n         &self.ip\n     }\n@@ -393,6 +407,7 @@ impl SocketAddrV6 {\n     /// assert_eq!(socket.ip(), &Ipv6Addr::new(76, 45, 0, 0, 0, 0, 0, 0));\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn set_ip(&mut self, new_ip: Ipv6Addr) {\n         self.ip = new_ip;\n     }\n@@ -410,6 +425,7 @@ impl SocketAddrV6 {\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_socketaddr\", since = \"1.69.0\")]\n+    #[inline]\n     pub const fn port(&self) -> u16 {\n         self.port\n     }\n@@ -426,6 +442,7 @@ impl SocketAddrV6 {\n     /// assert_eq!(socket.port(), 4242);\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn set_port(&mut self, new_port: u16) {\n         self.port = new_port;\n     }\n@@ -453,6 +470,7 @@ impl SocketAddrV6 {\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_socketaddr\", since = \"1.69.0\")]\n+    #[inline]\n     pub const fn flowinfo(&self) -> u32 {\n         self.flowinfo\n     }\n@@ -471,6 +489,7 @@ impl SocketAddrV6 {\n     /// assert_eq!(socket.flowinfo(), 56);\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn set_flowinfo(&mut self, new_flowinfo: u32) {\n         self.flowinfo = new_flowinfo;\n     }\n@@ -493,6 +512,7 @@ impl SocketAddrV6 {\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_socketaddr\", since = \"1.69.0\")]\n+    #[inline]\n     pub const fn scope_id(&self) -> u32 {\n         self.scope_id\n     }\n@@ -511,6 +531,7 @@ impl SocketAddrV6 {\n     /// assert_eq!(socket.scope_id(), 42);\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn set_scope_id(&mut self, new_scope_id: u32) {\n         self.scope_id = new_scope_id;\n     }\n@@ -519,6 +540,7 @@ impl SocketAddrV6 {\n #[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n impl From<SocketAddrV4> for SocketAddr {\n     /// Converts a [`SocketAddrV4`] into a [`SocketAddr::V4`].\n+    #[inline]\n     fn from(sock4: SocketAddrV4) -> SocketAddr {\n         SocketAddr::V4(sock4)\n     }\n@@ -527,6 +549,7 @@ impl From<SocketAddrV4> for SocketAddr {\n #[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n impl From<SocketAddrV6> for SocketAddr {\n     /// Converts a [`SocketAddrV6`] into a [`SocketAddr::V6`].\n+    #[inline]\n     fn from(sock6: SocketAddrV6) -> SocketAddr {\n         SocketAddr::V6(sock6)\n     }\n@@ -624,27 +647,31 @@ impl fmt::Debug for SocketAddrV6 {\n \n #[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n impl PartialOrd for SocketAddrV4 {\n+    #[inline]\n     fn partial_cmp(&self, other: &SocketAddrV4) -> Option<Ordering> {\n         Some(self.cmp(other))\n     }\n }\n \n #[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n impl PartialOrd for SocketAddrV6 {\n+    #[inline]\n     fn partial_cmp(&self, other: &SocketAddrV6) -> Option<Ordering> {\n         Some(self.cmp(other))\n     }\n }\n \n #[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n impl Ord for SocketAddrV4 {\n+    #[inline]\n     fn cmp(&self, other: &SocketAddrV4) -> Ordering {\n         self.ip().cmp(other.ip()).then(self.port().cmp(&other.port()))\n     }\n }\n \n #[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n impl Ord for SocketAddrV6 {\n+    #[inline]\n     fn cmp(&self, other: &SocketAddrV6) -> Ordering {\n         self.ip().cmp(other.ip()).then(self.port().cmp(&other.port()))\n     }"}, {"sha": "ec1ef3cf43d12645113f03f1baff4f7a427d189b", "filename": "library/core/src/option.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1641,10 +1641,8 @@ impl<T> Option<T> {\n     where\n         F: FnOnce() -> T,\n     {\n-        if let None = *self {\n-            // the compiler isn't smart enough to know that we are not dropping a `T`\n-            // here and wants us to ensure `T` can be dropped at compile time.\n-            mem::forget(mem::replace(self, Some(f())))\n+        if let None = self {\n+            *self = Some(f());\n         }\n \n         // SAFETY: a `None` variant for `self` would have been replaced by a `Some`"}, {"sha": "f3311f76a7f0663c6c58e811aa4c9c1319ba871d", "filename": "library/core/src/slice/ascii.rs", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -10,9 +10,10 @@ use crate::ops;\n impl [u8] {\n     /// Checks if all bytes in this slice are within the ASCII range.\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[rustc_const_unstable(feature = \"const_slice_is_ascii\", issue = \"111090\")]\n     #[must_use]\n     #[inline]\n-    pub fn is_ascii(&self) -> bool {\n+    pub const fn is_ascii(&self) -> bool {\n         is_ascii(self)\n     }\n \n@@ -21,7 +22,7 @@ impl [u8] {\n     #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n     #[must_use]\n     #[inline]\n-    pub fn as_ascii(&self) -> Option<&[ascii::Char]> {\n+    pub const fn as_ascii(&self) -> Option<&[ascii::Char]> {\n         if self.is_ascii() {\n             // SAFETY: Just checked that it's ASCII\n             Some(unsafe { self.as_ascii_unchecked() })\n@@ -262,11 +263,29 @@ impl<'a> fmt::Debug for EscapeAscii<'a> {\n /// Returns `true` if any byte in the word `v` is nonascii (>= 128). Snarfed\n /// from `../str/mod.rs`, which does something similar for utf8 validation.\n #[inline]\n-fn contains_nonascii(v: usize) -> bool {\n+const fn contains_nonascii(v: usize) -> bool {\n     const NONASCII_MASK: usize = usize::repeat_u8(0x80);\n     (NONASCII_MASK & v) != 0\n }\n \n+/// ASCII test *without* the chunk-at-a-time optimizations.\n+///\n+/// This is carefully structured to produce nice small code -- it's smaller in\n+/// `-O` than what the \"obvious\" ways produces under `-C opt-level=s`.  If you\n+/// touch it, be sure to run (and update if needed) the assembly test.\n+#[unstable(feature = \"str_internals\", issue = \"none\")]\n+#[doc(hidden)]\n+#[inline]\n+pub const fn is_ascii_simple(mut bytes: &[u8]) -> bool {\n+    while let [rest @ .., last] = bytes {\n+        if !last.is_ascii() {\n+            break;\n+        }\n+        bytes = rest;\n+    }\n+    bytes.is_empty()\n+}\n+\n /// Optimized ASCII test that will use usize-at-a-time operations instead of\n /// byte-at-a-time operations (when possible).\n ///\n@@ -280,7 +299,7 @@ fn contains_nonascii(v: usize) -> bool {\n /// If any of these loads produces something for which `contains_nonascii`\n /// (above) returns true, then we know the answer is false.\n #[inline]\n-fn is_ascii(s: &[u8]) -> bool {\n+const fn is_ascii(s: &[u8]) -> bool {\n     const USIZE_SIZE: usize = mem::size_of::<usize>();\n \n     let len = s.len();\n@@ -292,7 +311,7 @@ fn is_ascii(s: &[u8]) -> bool {\n     // We also do this for architectures where `size_of::<usize>()` isn't\n     // sufficient alignment for `usize`, because it's a weird edge case.\n     if len < USIZE_SIZE || len < align_offset || USIZE_SIZE < mem::align_of::<usize>() {\n-        return s.iter().all(|b| b.is_ascii());\n+        return is_ascii_simple(s);\n     }\n \n     // We always read the first word unaligned, which means `align_offset` is\n@@ -321,18 +340,26 @@ fn is_ascii(s: &[u8]) -> bool {\n     // Paranoia check about alignment, since we're about to do a bunch of\n     // unaligned loads. In practice this should be impossible barring a bug in\n     // `align_offset` though.\n-    debug_assert_eq!(word_ptr.addr() % mem::align_of::<usize>(), 0);\n+    // While this method is allowed to spuriously fail in CTFE, if it doesn't\n+    // have alignment information it should have given a `usize::MAX` for\n+    // `align_offset` earlier, sending things through the scalar path instead of\n+    // this one, so this check should pass if it's reachable.\n+    debug_assert!(word_ptr.is_aligned_to(mem::align_of::<usize>()));\n \n     // Read subsequent words until the last aligned word, excluding the last\n     // aligned word by itself to be done in tail check later, to ensure that\n     // tail is always one `usize` at most to extra branch `byte_pos == len`.\n     while byte_pos < len - USIZE_SIZE {\n-        debug_assert!(\n-            // Sanity check that the read is in bounds\n-            (word_ptr.addr() + USIZE_SIZE) <= start.addr().wrapping_add(len) &&\n-            // And that our assumptions about `byte_pos` hold.\n-            (word_ptr.addr() - start.addr()) == byte_pos\n-        );\n+        // Sanity check that the read is in bounds\n+        debug_assert!(byte_pos + USIZE_SIZE <= len);\n+        // And that our assumptions about `byte_pos` hold.\n+        debug_assert!(matches!(\n+            word_ptr.cast::<u8>().guaranteed_eq(start.wrapping_add(byte_pos)),\n+            // These are from the same allocation, so will hopefully always be\n+            // known to match even in CTFE, but if it refuses to compare them\n+            // that's ok since it's just a debug check anyway.\n+            None | Some(true),\n+        ));\n \n         // SAFETY: We know `word_ptr` is properly aligned (because of\n         // `align_offset`), and we know that we have enough bytes between `word_ptr` and the end"}, {"sha": "4c891ba550f3c840a1f876c1177d62d7d61bc260", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -44,6 +44,10 @@ mod raw;\n mod rotate;\n mod specialize;\n \n+#[unstable(feature = \"str_internals\", issue = \"none\")]\n+#[doc(hidden)]\n+pub use ascii::is_ascii_simple;\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use iter::{Chunks, ChunksMut, Windows};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "ef05b25fdd06ce4df659a78b1eab3a0652ffd8b9", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -2358,9 +2358,10 @@ impl str {\n     /// assert!(!non_ascii.is_ascii());\n     /// ```\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[rustc_const_unstable(feature = \"const_slice_is_ascii\", issue = \"111090\")]\n     #[must_use]\n     #[inline]\n-    pub fn is_ascii(&self) -> bool {\n+    pub const fn is_ascii(&self) -> bool {\n         // We can treat each byte as character here: all multibyte characters\n         // start with a byte that is not in the ASCII range, so we will stop\n         // there already.\n@@ -2372,7 +2373,7 @@ impl str {\n     #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n     #[must_use]\n     #[inline]\n-    pub fn as_ascii(&self) -> Option<&[ascii::Char]> {\n+    pub const fn as_ascii(&self) -> Option<&[ascii::Char]> {\n         // Like in `is_ascii`, we can work on the bytes directly.\n         self.as_bytes().as_ascii()\n     }"}, {"sha": "172e5fccb61aa60d1b603434f7fbc06c81dafb32", "filename": "library/core/src/tuple.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fcore%2Fsrc%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftuple.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,7 +1,6 @@\n // See src/libstd/primitive_docs.rs for documentation.\n \n use crate::cmp::Ordering::{self, *};\n-use crate::mem::transmute;\n \n // Recursive macro for implementing n-ary tuple functions and operations\n //\n@@ -142,16 +141,13 @@ macro_rules! maybe_tuple_doc {\n #[inline]\n const fn ordering_is_some(c: Option<Ordering>, x: Ordering) -> bool {\n     // FIXME: Just use `==` once that's const-stable on `Option`s.\n-    // This isn't using `match` because that optimizes worse due to\n-    // making a two-step check (`Some` *then* the inner value).\n-\n-    // SAFETY: There's no public guarantee for `Option<Ordering>`,\n-    // but we're core so we know that it's definitely a byte.\n-    unsafe {\n-        let c: i8 = transmute(c);\n-        let x: i8 = transmute(Some(x));\n-        c == x\n-    }\n+    // This is mapping `None` to 2 and then doing the comparison afterwards\n+    // because it optimizes better (`None::<Ordering>` is represented as 2).\n+    x as i8\n+        == match c {\n+            Some(c) => c as i8,\n+            None => 2,\n+        }\n }\n \n // Constructs an expression that performs a lexical ordering using method `$rel`."}, {"sha": "caecda1bc63fdcb132d4ad040dc485858dfa5487", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -337,6 +337,8 @@ pub enum LitKind {\n     StrRaw(u8),\n     ByteStr,\n     ByteStrRaw(u8),\n+    CStr,\n+    CStrRaw(u8),\n     Err,\n }\n \n@@ -350,6 +352,8 @@ rpc_encode_decode!(\n         StrRaw(n),\n         ByteStr,\n         ByteStrRaw(n),\n+        CStr,\n+        CStrRaw(n),\n         Err,\n     }\n );"}, {"sha": "5440d85df4adff59d441487998d4c2b96fdb9b8a", "filename": "library/std/src/sys/hermit/time.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -40,11 +40,7 @@ impl Timespec {\n     }\n \n     fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n-        let mut secs = other\n-            .as_secs()\n-            .try_into() // <- target type would be `libc::time_t`\n-            .ok()\n-            .and_then(|secs| self.t.tv_sec.checked_add(secs))?;\n+        let mut secs = self.tv_sec.checked_add_unsigned(other.as_secs())?;\n \n         // Nano calculations can't overflow because nanos are <1B which fit\n         // in a u32.\n@@ -57,11 +53,7 @@ impl Timespec {\n     }\n \n     fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n-        let mut secs = other\n-            .as_secs()\n-            .try_into() // <- target type would be `libc::time_t`\n-            .ok()\n-            .and_then(|secs| self.t.tv_sec.checked_sub(secs))?;\n+        let mut secs = self.tv_sec.checked_sub_unsigned(other.as_secs())?;\n \n         // Similar to above, nanos can't overflow.\n         let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;"}, {"sha": "8a063b65dac50357ba3002236f4b4c1cef23afee", "filename": "library/std/src/sys/sgx/abi/entry.S", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fentry.S", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fentry.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fentry.S?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -26,7 +26,7 @@ IMAGE_BASE:\n .Lxsave_clear:\n .org .+24\n .Lxsave_mxcsr:\n-    .short 0x1f80\n+    .short 0x1fbf\n \n /*  We can store a bunch of data in the gap between MXCSR and the XSAVE header */\n \n@@ -178,6 +178,7 @@ sgx_entry:\n     mov $-1, %rax\n     mov $-1, %rdx\n     xrstor .Lxsave_clear(%rip)\n+    lfence\n     mov %r10, %rdx\n \n /*  check if returning from usercall */\n@@ -311,6 +312,9 @@ usercall:\n     movq $0,%gs:tcsls_last_rsp\n /*  restore callee-saved state, cf. \"save\" above */\n     mov %r11,%rsp\n+    /* MCDT mitigation requires an lfence after ldmxcsr _before_ any of the affected  */\n+    /* vector instructions is used. We omit the lfence here as one is required before */\n+    /* the jmp instruction anyway. */\n     ldmxcsr (%rsp)\n     fldcw 4(%rsp)\n     add $8, %rsp"}, {"sha": "f83f1644fe854483629bde2c4fbefed46c07ec15", "filename": "library/std/src/sys/solid/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ftime.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -47,10 +47,10 @@ impl SystemTime {\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n-        Some(SystemTime(self.0.checked_add(other.as_secs().try_into().ok()?)?))\n+        Some(SystemTime(self.0.checked_add_unsigned(other.as_secs())?))\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n-        Some(SystemTime(self.0.checked_sub(other.as_secs().try_into().ok()?)?))\n+        Some(SystemTime(self.0.checked_sub_unsigned(other.as_secs())?))\n     }\n }"}, {"sha": "7307d9b2c86166983d1f9bf555cc6e7cc3d62e18", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -326,6 +326,25 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n         } else if #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"netbsd\"))] {\n             use crate::ptr;\n \n+            #[cfg(target_os = \"freebsd\")]\n+            {\n+                let mut set: libc::cpuset_t = unsafe { mem::zeroed() };\n+                unsafe {\n+                    if libc::cpuset_getaffinity(\n+                        libc::CPU_LEVEL_WHICH,\n+                        libc::CPU_WHICH_PID,\n+                        -1,\n+                        mem::size_of::<libc::cpuset_t>(),\n+                        &mut set,\n+                    ) == 0 {\n+                        let count = libc::CPU_COUNT(&set) as usize;\n+                        if count > 0 {\n+                            return Ok(NonZeroUsize::new_unchecked(count));\n+                        }\n+                    }\n+                }\n+            }\n+\n             let mut cpus: libc::c_uint = 0;\n             let mut cpus_size = crate::mem::size_of_val(&cpus);\n "}, {"sha": "a9fbc7ab108a4653fa7d90a9f352d78a1b6ee983", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -113,11 +113,7 @@ impl Timespec {\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n-        let mut secs = other\n-            .as_secs()\n-            .try_into() // <- target type would be `i64`\n-            .ok()\n-            .and_then(|secs| self.tv_sec.checked_add(secs))?;\n+        let mut secs = self.tv_sec.checked_add_unsigned(other.as_secs())?;\n \n         // Nano calculations can't overflow because nanos are <1B which fit\n         // in a u32.\n@@ -126,23 +122,19 @@ impl Timespec {\n             nsec -= NSEC_PER_SEC as u32;\n             secs = secs.checked_add(1)?;\n         }\n-        Some(Timespec::new(secs, nsec as i64))\n+        Some(Timespec::new(secs, nsec.into()))\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n-        let mut secs = other\n-            .as_secs()\n-            .try_into() // <- target type would be `i64`\n-            .ok()\n-            .and_then(|secs| self.tv_sec.checked_sub(secs))?;\n+        let mut secs = self.tv_sec.checked_sub_unsigned(other.as_secs())?;\n \n         // Similar to above, nanos can't overflow.\n         let mut nsec = self.tv_nsec.0 as i32 - other.subsec_nanos() as i32;\n         if nsec < 0 {\n             nsec += NSEC_PER_SEC as i32;\n             secs = secs.checked_sub(1)?;\n         }\n-        Some(Timespec::new(secs, nsec as i64))\n+        Some(Timespec::new(secs, nsec.into()))\n     }\n \n     #[allow(dead_code)]"}, {"sha": "6ed84806e6d375bab02359daee0b19bc7d8c05ae", "filename": "library/std/src/time/tests.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,4 +1,5 @@\n use super::{Duration, Instant, SystemTime, UNIX_EPOCH};\n+use core::fmt::Debug;\n #[cfg(not(target_arch = \"wasm32\"))]\n use test::{black_box, Bencher};\n \n@@ -201,6 +202,32 @@ fn since_epoch() {\n     assert!(a < hundred_twenty_years);\n }\n \n+#[test]\n+fn big_math() {\n+    // Check that the same result occurs when adding/subtracting each duration one at a time as when\n+    // adding/subtracting them all at once.\n+    #[track_caller]\n+    fn check<T: Eq + Copy + Debug>(start: Option<T>, op: impl Fn(&T, Duration) -> Option<T>) {\n+        const DURATIONS: [Duration; 2] =\n+            [Duration::from_secs(i64::MAX as _), Duration::from_secs(50)];\n+        if let Some(start) = start {\n+            assert_eq!(\n+                op(&start, DURATIONS.into_iter().sum()),\n+                DURATIONS.into_iter().try_fold(start, |t, d| op(&t, d))\n+            )\n+        }\n+    }\n+\n+    check(SystemTime::UNIX_EPOCH.checked_sub(Duration::from_secs(100)), SystemTime::checked_add);\n+    check(SystemTime::UNIX_EPOCH.checked_add(Duration::from_secs(100)), SystemTime::checked_sub);\n+\n+    let instant = Instant::now();\n+    check(instant.checked_sub(Duration::from_secs(100)), Instant::checked_add);\n+    check(instant.checked_sub(Duration::from_secs(i64::MAX as _)), Instant::checked_add);\n+    check(instant.checked_add(Duration::from_secs(100)), Instant::checked_sub);\n+    check(instant.checked_add(Duration::from_secs(i64::MAX as _)), Instant::checked_sub);\n+}\n+\n macro_rules! bench_instant_threaded {\n     ($bench_name:ident, $thread_count:expr) => {\n         #[bench]"}, {"sha": "dfe6bb7f0572e82b8bd7751051bd0235960bc2d3", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 70, "deletions": 22, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -11,6 +11,12 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"anstyle\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"41ed9a86bf92ae6580e0a31281f65a1b1d867c0cc68d5346e2ae128dddfa6a7d\"\n+\n [[package]]\n name = \"autocfg\"\n version = \"1.1.0\"\n@@ -38,10 +44,10 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper\",\n  \"cc\",\n+ \"clap\",\n  \"cmake\",\n  \"fd-lock\",\n  \"filetime\",\n- \"getopts\",\n  \"hex\",\n  \"ignore\",\n  \"is-terminal\",\n@@ -91,6 +97,46 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n+[[package]]\n+name = \"clap\"\n+version = \"4.2.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"956ac1f6381d8d82ab4684768f89c0ea3afe66925ceadb4eeb3fc452ffc55d62\"\n+dependencies = [\n+ \"clap_builder\",\n+ \"clap_derive\",\n+ \"once_cell\",\n+]\n+\n+[[package]]\n+name = \"clap_builder\"\n+version = \"4.2.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"84080e799e54cff944f4b4a4b0e71630b0e0443b25b985175c7dddc1a859b749\"\n+dependencies = [\n+ \"anstyle\",\n+ \"bitflags\",\n+ \"clap_lex\",\n+]\n+\n+[[package]]\n+name = \"clap_derive\"\n+version = \"4.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3f9644cd56d6b87dbe899ef8b053e331c0637664e9e21a33dfcdc36093f5c5c4\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn 2.0.15\",\n+]\n+\n+[[package]]\n+name = \"clap_lex\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8a2dd5a6fe8c6e3502f568a6353e5273bbb15193ad9a89e457b9970798efbea1\"\n+\n [[package]]\n name = \"cmake\"\n version = \"0.1.48\"\n@@ -175,7 +221,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f877be4f7c9f246b183111634f75baa039715e3f46ce860677d3b19a69fb229c\"\n dependencies = [\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -260,15 +306,6 @@ dependencies = [\n  \"version_check\",\n ]\n \n-[[package]]\n-name = \"getopts\"\n-version = \"0.2.21\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"14dbbfd5c71d70241ecf9e6f13737f7b5ce823821063188d7e46c41d371eebd5\"\n-dependencies = [\n- \"unicode-width\",\n-]\n-\n [[package]]\n name = \"globset\"\n version = \"0.4.8\"\n@@ -282,6 +319,12 @@ dependencies = [\n  \"regex\",\n ]\n \n+[[package]]\n+name = \"heck\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8\"\n+\n [[package]]\n name = \"hermit-abi\"\n version = \"0.1.19\"\n@@ -486,18 +529,18 @@ dependencies = [\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.46\"\n+version = \"1.0.56\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"94e2ef8dbfc347b10c094890f778ee2e36ca9bb4262e86dc99cd217e35f3470b\"\n+checksum = \"2b63bdb0cd06f1f4dedf69b254734f9b45af66e4a031e42a7480257d9898b435\"\n dependencies = [\n  \"unicode-ident\",\n ]\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.18\"\n+version = \"1.0.26\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a1feb54ed693b93a84e14094943b84b7c4eae204c512b7ccb95ab0c66d278ad1\"\n+checksum = \"4424af4bf778aae2051a77b60283332f386554255d722233d09fbfc7e30da2fc\"\n dependencies = [\n  \"proc-macro2\",\n ]\n@@ -606,7 +649,7 @@ checksum = \"1f26faba0c3959972377d3b2d306ee9f71faee9714294e41bb777f83f88578be\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -642,6 +685,17 @@ dependencies = [\n  \"unicode-ident\",\n ]\n \n+[[package]]\n+name = \"syn\"\n+version = \"2.0.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a34fcf3e8b60f57e6a14301a2e916d323af98b0ea63c599441eec8558660c822\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-ident\",\n+]\n+\n [[package]]\n name = \"sysinfo\"\n version = \"0.26.7\"\n@@ -707,12 +761,6 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d22af068fba1eb5edcb4aea19d382b2a3deb4c8f9d475c589b6ada9e0fd493ee\"\n \n-[[package]]\n-name = \"unicode-width\"\n-version = \"0.1.9\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3ed742d4ea2bd1176e236172c8429aaf54486e7ac098db29ffe6529e0ce50973\"\n-\n [[package]]\n name = \"version_check\"\n version = \"0.9.4\""}, {"sha": "fd5eb740630ab743b1b5569304657c81ed7bc8cd", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -34,7 +34,6 @@ is-terminal = \"0.4\"\n build_helper = { path = \"../tools/build_helper\" }\n cmake = \"0.1.38\"\n filetime = \"0.2\"\n-getopts = \"0.2.19\"\n cc = \"1.0.69\"\n libc = \"0.2\"\n hex = \"0.4\"\n@@ -56,6 +55,7 @@ walkdir = \"2\"\n \n # Dependencies needed by the build-metrics feature\n sysinfo = { version = \"0.26.0\", optional = true }\n+clap = { version = \"4.2.4\", default-features = false, features = [\"std\", \"usage\", \"help\", \"derive\", \"error-context\"] }\n \n # Solaris doesn't support flock() and thus fd-lock is not option now\n [target.'cfg(not(target_os = \"solaris\"))'.dependencies]\n@@ -86,6 +86,7 @@ build-metrics = [\"sysinfo\"]\n # dependencies, only bootstrap itself.\n [profile.dev]\n debug = 0\n+\n [profile.dev.package]\n # Only use debuginfo=1 to further reduce compile times.\n bootstrap.debug = 1"}, {"sha": "1267c0be7193eb324bd79616bf8b7e4f74a743fa", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -33,6 +33,7 @@ pub use crate::Compiler;\n // - use std::lazy for `Lazy`\n // - use std::cell for `OnceCell`\n // Once they get stabilized and reach beta.\n+use clap::ValueEnum;\n use once_cell::sync::{Lazy, OnceCell};\n \n pub struct Builder<'a> {\n@@ -576,19 +577,24 @@ impl<'a> ShouldRun<'a> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, ValueEnum)]\n pub enum Kind {\n+    #[clap(alias = \"b\")]\n     Build,\n+    #[clap(alias = \"c\")]\n     Check,\n     Clippy,\n     Fix,\n     Format,\n+    #[clap(alias = \"t\")]\n     Test,\n     Bench,\n+    #[clap(alias = \"d\")]\n     Doc,\n     Clean,\n     Dist,\n     Install,\n+    #[clap(alias = \"r\")]\n     Run,\n     Setup,\n     Suggest,\n@@ -887,18 +893,19 @@ impl<'a> Builder<'a> {\n     }\n \n     pub fn new(build: &Build) -> Builder<'_> {\n+        let paths = &build.config.paths;\n         let (kind, paths) = match build.config.cmd {\n-            Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n-            Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n-            Subcommand::Clippy { ref paths, .. } => (Kind::Clippy, &paths[..]),\n-            Subcommand::Fix { ref paths } => (Kind::Fix, &paths[..]),\n-            Subcommand::Doc { ref paths, .. } => (Kind::Doc, &paths[..]),\n-            Subcommand::Test { ref paths, .. } => (Kind::Test, &paths[..]),\n-            Subcommand::Bench { ref paths, .. } => (Kind::Bench, &paths[..]),\n-            Subcommand::Dist { ref paths } => (Kind::Dist, &paths[..]),\n-            Subcommand::Install { ref paths } => (Kind::Install, &paths[..]),\n-            Subcommand::Run { ref paths, .. } => (Kind::Run, &paths[..]),\n-            Subcommand::Clean { ref paths, .. } => (Kind::Clean, &paths[..]),\n+            Subcommand::Build => (Kind::Build, &paths[..]),\n+            Subcommand::Check { .. } => (Kind::Check, &paths[..]),\n+            Subcommand::Clippy { .. } => (Kind::Clippy, &paths[..]),\n+            Subcommand::Fix => (Kind::Fix, &paths[..]),\n+            Subcommand::Doc { .. } => (Kind::Doc, &paths[..]),\n+            Subcommand::Test { .. } => (Kind::Test, &paths[..]),\n+            Subcommand::Bench { .. } => (Kind::Bench, &paths[..]),\n+            Subcommand::Dist => (Kind::Dist, &paths[..]),\n+            Subcommand::Install => (Kind::Install, &paths[..]),\n+            Subcommand::Run { .. } => (Kind::Run, &paths[..]),\n+            Subcommand::Clean { .. } => (Kind::Clean, &paths[..]),\n             Subcommand::Format { .. } => (Kind::Format, &[][..]),\n             Subcommand::Suggest { .. } => (Kind::Suggest, &[][..]),\n             Subcommand::Setup { profile: ref path } => ("}, {"sha": "c32fe59bbf0697de8b84637983b2eca1434c737d", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -236,7 +236,7 @@ mod defaults {\n     fn doc_default() {\n         let mut config = configure(\"doc\", &[\"A\"], &[\"A\"]);\n         config.compiler_docs = true;\n-        config.cmd = Subcommand::Doc { paths: Vec::new(), open: false, json: false };\n+        config.cmd = Subcommand::Doc { open: false, json: false };\n         let mut cache = run_build(&[], config);\n         let a = TargetSelection::from_user(\"A\");\n \n@@ -545,19 +545,21 @@ mod dist {\n     fn test_with_no_doc_stage0() {\n         let mut config = configure(&[\"A\"], &[\"A\"]);\n         config.stage = 0;\n+        config.paths = vec![\"library/std\".into()];\n         config.cmd = Subcommand::Test {\n-            paths: vec![\"library/std\".into()],\n             test_args: vec![],\n             rustc_args: vec![],\n-            fail_fast: true,\n-            doc_tests: DocTests::No,\n+            no_fail_fast: false,\n+            no_doc: true,\n+            doc: false,\n             bless: false,\n             force_rerun: false,\n             compare_mode: None,\n             rustfix_coverage: false,\n             pass: None,\n             run: None,\n             only_modified: false,\n+            skip: vec![],\n         };\n \n         let build = Build::new(config);\n@@ -587,7 +589,7 @@ mod dist {\n     fn doc_ci() {\n         let mut config = configure(&[\"A\"], &[\"A\"]);\n         config.compiler_docs = true;\n-        config.cmd = Subcommand::Doc { paths: Vec::new(), open: false, json: false };\n+        config.cmd = Subcommand::Doc { open: false, json: false };\n         let build = Build::new(config);\n         let mut builder = Builder::new(&build);\n         builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), &[]);\n@@ -616,11 +618,12 @@ mod dist {\n         // Behavior of `x.py test` doing various documentation tests.\n         let mut config = configure(&[\"A\"], &[\"A\"]);\n         config.cmd = Subcommand::Test {\n-            paths: vec![],\n             test_args: vec![],\n             rustc_args: vec![],\n-            fail_fast: true,\n-            doc_tests: DocTests::Yes,\n+            no_fail_fast: false,\n+            doc: true,\n+            no_doc: false,\n+            skip: vec![],\n             bless: false,\n             force_rerun: false,\n             compare_mode: None,"}, {"sha": "b11be96cefe628ec5596e6c9470c8316f45dc666", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -20,15 +20,7 @@ fn args(builder: &Builder<'_>) -> Vec<String> {\n         arr.iter().copied().map(String::from)\n     }\n \n-    if let Subcommand::Clippy {\n-        fix,\n-        clippy_lint_allow,\n-        clippy_lint_deny,\n-        clippy_lint_warn,\n-        clippy_lint_forbid,\n-        ..\n-    } = &builder.config.cmd\n-    {\n+    if let Subcommand::Clippy { fix, allow, deny, warn, forbid, .. } = &builder.config.cmd {\n         // disable the most spammy clippy lints\n         let ignored_lints = vec![\n             \"many_single_char_names\", // there are a lot in stdarch\n@@ -53,10 +45,10 @@ fn args(builder: &Builder<'_>) -> Vec<String> {\n         args.extend(strings(&[\"--\", \"--cap-lints\", \"warn\"]));\n         args.extend(ignored_lints.iter().map(|lint| format!(\"-Aclippy::{}\", lint)));\n         let mut clippy_lint_levels: Vec<String> = Vec::new();\n-        clippy_lint_allow.iter().for_each(|v| clippy_lint_levels.push(format!(\"-A{}\", v)));\n-        clippy_lint_deny.iter().for_each(|v| clippy_lint_levels.push(format!(\"-D{}\", v)));\n-        clippy_lint_warn.iter().for_each(|v| clippy_lint_levels.push(format!(\"-W{}\", v)));\n-        clippy_lint_forbid.iter().for_each(|v| clippy_lint_levels.push(format!(\"-F{}\", v)));\n+        allow.iter().for_each(|v| clippy_lint_levels.push(format!(\"-A{}\", v)));\n+        deny.iter().for_each(|v| clippy_lint_levels.push(format!(\"-D{}\", v)));\n+        warn.iter().for_each(|v| clippy_lint_levels.push(format!(\"-W{}\", v)));\n+        forbid.iter().for_each(|v| clippy_lint_levels.push(format!(\"-F{}\", v)));\n         args.extend(clippy_lint_levels);\n         args.extend(builder.config.free_args.clone());\n         args"}, {"sha": "f4e97d7dfed284c6260be2e1320bf12647ec1c71", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -21,7 +21,7 @@ use crate::cache::{Interned, INTERNER};\n use crate::cc_detect::{ndk_compiler, Language};\n use crate::channel::{self, GitInfo};\n pub use crate::flags::Subcommand;\n-use crate::flags::{Color, Flags};\n+use crate::flags::{Color, Flags, Warnings};\n use crate::util::{exe, output, t};\n use once_cell::sync::OnceCell;\n use serde::{Deserialize, Deserializer};\n@@ -237,6 +237,8 @@ pub struct Config {\n     initial_rustfmt: RefCell<RustfmtState>,\n     #[cfg(test)]\n     pub initial_rustfmt: RefCell<RustfmtState>,\n+\n+    pub paths: Vec<PathBuf>,\n }\n \n #[derive(Default, Deserialize, Clone)]\n@@ -376,6 +378,16 @@ pub struct TargetSelection {\n     file: Option<Interned<String>>,\n }\n \n+/// Newtype over `Vec<TargetSelection>` so we can implement custom parsing logic\n+#[derive(Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub struct TargetSelectionList(Vec<TargetSelection>);\n+\n+pub fn target_selection_list(s: &str) -> Result<TargetSelectionList, String> {\n+    Ok(TargetSelectionList(\n+        s.split(\",\").filter(|s| !s.is_empty()).map(TargetSelection::from_user).collect(),\n+    ))\n+}\n+\n impl TargetSelection {\n     pub fn from_user(selection: &str) -> Self {\n         let path = Path::new(selection);\n@@ -871,26 +883,24 @@ impl Config {\n     }\n \n     fn parse_inner<'a>(args: &[String], get_toml: impl 'a + Fn(&Path) -> TomlConfig) -> Config {\n-        let flags = Flags::parse(&args);\n+        let mut flags = Flags::parse(&args);\n         let mut config = Config::default_opts();\n \n         // Set flags.\n+        config.paths = std::mem::take(&mut flags.paths);\n         config.exclude = flags.exclude.into_iter().map(|path| TaskPath::parse(path)).collect();\n         config.include_default_paths = flags.include_default_paths;\n         config.rustc_error_format = flags.rustc_error_format;\n         config.json_output = flags.json_output;\n         config.on_fail = flags.on_fail;\n-        config.jobs = flags.jobs.map(threads_from_config);\n+        config.jobs = Some(threads_from_config(flags.jobs as u32));\n         config.cmd = flags.cmd;\n         config.incremental = flags.incremental;\n         config.dry_run = if flags.dry_run { DryRun::UserSelected } else { DryRun::Disabled };\n         config.keep_stage = flags.keep_stage;\n         config.keep_stage_std = flags.keep_stage_std;\n         config.color = flags.color;\n-        config.free_args = flags.free_args.clone().unwrap_or_default();\n-        if let Some(value) = flags.deny_warnings {\n-            config.deny_warnings = value;\n-        }\n+        config.free_args = std::mem::take(&mut flags.free_args);\n         config.llvm_profile_use = flags.llvm_profile_use;\n         config.llvm_profile_generate = flags.llvm_profile_generate;\n         config.llvm_bolt_profile_generate = flags.llvm_bolt_profile_generate;\n@@ -1021,14 +1031,14 @@ impl Config {\n             config.out = dir;\n         }\n \n-        config.hosts = if let Some(arg_host) = flags.host {\n+        config.hosts = if let Some(TargetSelectionList(arg_host)) = flags.host {\n             arg_host\n         } else if let Some(file_host) = build.host {\n             file_host.iter().map(|h| TargetSelection::from_user(h)).collect()\n         } else {\n             vec![config.build]\n         };\n-        config.targets = if let Some(arg_target) = flags.target {\n+        config.targets = if let Some(TargetSelectionList(arg_target)) = flags.target {\n             arg_target\n         } else if let Some(file_target) = build.target {\n             file_target.iter().map(|h| TargetSelection::from_user(h)).collect()\n@@ -1064,7 +1074,7 @@ impl Config {\n         set(&mut config.print_step_rusage, build.print_step_rusage);\n         set(&mut config.patch_binaries_for_nix, build.patch_binaries_for_nix);\n \n-        config.verbose = cmp::max(config.verbose, flags.verbose);\n+        config.verbose = cmp::max(config.verbose, flags.verbose as usize);\n \n         if let Some(install) = toml.install {\n             config.prefix = install.prefix.map(PathBuf::from);\n@@ -1137,7 +1147,14 @@ impl Config {\n             config.rustc_default_linker = rust.default_linker;\n             config.musl_root = rust.musl_root.map(PathBuf::from);\n             config.save_toolstates = rust.save_toolstates.map(PathBuf::from);\n-            set(&mut config.deny_warnings, flags.deny_warnings.or(rust.deny_warnings));\n+            set(\n+                &mut config.deny_warnings,\n+                match flags.warnings {\n+                    Warnings::Deny => Some(true),\n+                    Warnings::Warn => Some(false),\n+                    Warnings::Default => rust.deny_warnings,\n+                },\n+            );\n             set(&mut config.backtrace_on_ice, rust.backtrace_on_ice);\n             set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n             config.rust_thin_lto_import_instr_limit = rust.thin_lto_import_instr_limit;"}, {"sha": "d913ca295e29db58233ae9fbcb0b833105757301", "filename": "src/bootstrap/config/tests.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig%2Ftests.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,4 +1,5 @@\n-use super::{Config, TomlConfig};\n+use super::{Config, Flags, TomlConfig};\n+use clap::CommandFactory;\n use std::{env, path::Path};\n \n fn toml(config: &str) -> impl '_ + Fn(&Path) -> TomlConfig {\n@@ -88,3 +89,8 @@ fn detect_src_and_out() {\n         test(parse(\"build.build-dir = \\\"/tmp\\\"\"), build_dir);\n     }\n }\n+\n+#[test]\n+fn clap_verify() {\n+    Flags::command().debug_assert();\n+}"}, {"sha": "c79a1bf9563c2c55812f407720934325ad9b14f2", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 336, "deletions": 659, "changes": 995, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -5,724 +5,409 @@\n \n use std::path::PathBuf;\n \n-use getopts::Options;\n+use clap::{Parser, ValueEnum};\n \n use crate::builder::{Builder, Kind};\n-use crate::config::{Config, TargetSelection};\n+use crate::config::{target_selection_list, Config, TargetSelectionList};\n use crate::setup::Profile;\n-use crate::util::t;\n use crate::{Build, DocTests};\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Default, Debug, ValueEnum)]\n pub enum Color {\n     Always,\n     Never,\n+    #[default]\n     Auto,\n }\n \n-impl Default for Color {\n-    fn default() -> Self {\n-        Self::Auto\n-    }\n-}\n-\n-impl std::str::FromStr for Color {\n-    type Err = ();\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s.to_lowercase().as_str() {\n-            \"always\" => Ok(Self::Always),\n-            \"never\" => Ok(Self::Never),\n-            \"auto\" => Ok(Self::Auto),\n-            _ => Err(()),\n-        }\n-    }\n+/// Whether to deny warnings, emit them as warnings, or use the default behavior\n+#[derive(Copy, Clone, Default, Debug, ValueEnum)]\n+pub enum Warnings {\n+    Deny,\n+    Warn,\n+    #[default]\n+    Default,\n }\n \n /// Deserialized version of all flags for this compile.\n+#[derive(Debug, Parser)]\n+#[clap(\n+    override_usage = \"x.py <subcommand> [options] [<paths>...]\",\n+    disable_help_subcommand(true),\n+    about = \"\",\n+    next_line_help(false)\n+)]\n pub struct Flags {\n-    pub verbose: usize, // number of -v args; each extra -v after the first is passed to Cargo\n-    pub on_fail: Option<String>,\n-    pub stage: Option<u32>,\n-    pub keep_stage: Vec<u32>,\n-    pub keep_stage_std: Vec<u32>,\n+    #[command(subcommand)]\n+    pub cmd: Subcommand,\n \n-    pub host: Option<Vec<TargetSelection>>,\n-    pub target: Option<Vec<TargetSelection>>,\n+    #[arg(global(true), short, long, action = clap::ArgAction::Count)]\n+    /// use verbose output (-vv for very verbose)\n+    pub verbose: u8, // each extra -v after the first is passed to Cargo\n+    #[arg(global(true), short, long)]\n+    /// use incremental compilation\n+    pub incremental: bool,\n+    #[arg(global(true), long, value_hint = clap::ValueHint::FilePath, value_name = \"FILE\")]\n+    /// TOML configuration file for build\n     pub config: Option<PathBuf>,\n+    #[arg(global(true), long, value_hint = clap::ValueHint::DirPath, value_name = \"DIR\")]\n+    /// Build directory, overrides `build.build-dir` in `config.toml`\n     pub build_dir: Option<PathBuf>,\n-    pub jobs: Option<u32>,\n-    pub cmd: Subcommand,\n-    pub incremental: bool,\n+\n+    #[arg(global(true), long, value_name = \"BUILD\")]\n+    /// build target of the stage0 compiler\n+    pub build: Option<String>,\n+\n+    #[arg(global(true), long, value_name = \"HOST\", value_parser = target_selection_list)]\n+    /// host targets to build\n+    pub host: Option<TargetSelectionList>,\n+\n+    #[arg(global(true), long, value_name = \"TARGET\", value_parser = target_selection_list)]\n+    /// target targets to build\n+    pub target: Option<TargetSelectionList>,\n+\n+    #[arg(global(true), long, value_name = \"PATH\")]\n+    /// build paths to exclude\n     pub exclude: Vec<PathBuf>,\n+    #[arg(global(true), long)]\n+    /// include default paths in addition to the provided ones\n     pub include_default_paths: bool,\n+\n+    #[arg(global(true), long)]\n     pub rustc_error_format: Option<String>,\n-    pub json_output: bool,\n+\n+    #[arg(global(true), long, value_hint = clap::ValueHint::CommandString, value_name = \"CMD\")]\n+    /// command to run on failure\n+    pub on_fail: Option<String>,\n+    #[arg(global(true), long)]\n+    /// dry run; don't build anything\n     pub dry_run: bool,\n-    pub color: Color,\n+    #[arg(global(true), long, value_name = \"N\")]\n+    /// stage to build (indicates compiler to use/test, e.g., stage 0 uses the\n+    /// bootstrap compiler, stage 1 the stage 0 rustc artifacts, etc.)\n+    pub stage: Option<u32>,\n \n+    #[arg(global(true), long, value_name = \"N\")]\n+    /// stage(s) to keep without recompiling\n+    /// (pass multiple times to keep e.g., both stages 0 and 1)\n+    pub keep_stage: Vec<u32>,\n+    #[arg(global(true), long, value_name = \"N\")]\n+    /// stage(s) of the standard library to keep without recompiling\n+    /// (pass multiple times to keep e.g., both stages 0 and 1)\n+    pub keep_stage_std: Vec<u32>,\n+    #[arg(global(true), long, value_hint = clap::ValueHint::DirPath, value_name = \"DIR\")]\n+    /// path to the root of the rust checkout\n+    pub src: Option<PathBuf>,\n+\n+    #[arg(\n+        global(true),\n+        short,\n+        long,\n+        default_value_t = std::thread::available_parallelism().map_or(1, std::num::NonZeroUsize::get),\n+        value_name = \"JOBS\"\n+    )]\n+    /// number of jobs to run in parallel\n+    pub jobs: usize,\n     // This overrides the deny-warnings configuration option,\n     // which passes -Dwarnings to the compiler invocations.\n-    //\n-    // true => deny, false => warn\n-    pub deny_warnings: Option<bool>,\n+    #[arg(global(true), long)]\n+    #[clap(value_enum, default_value_t=Warnings::Default, value_name = \"deny|warn\")]\n+    /// if value is deny, will deny warnings\n+    /// if value is warn, will emit warnings\n+    /// otherwise, use the default configured behaviour\n+    pub warnings: Warnings,\n+\n+    #[arg(global(true), long, value_name = \"FORMAT\")]\n+    /// rustc error format\n+    pub error_format: Option<String>,\n+    #[arg(global(true), long)]\n+    /// use message-format=json\n+    pub json_output: bool,\n \n-    pub rust_profile_use: Option<String>,\n-    pub rust_profile_generate: Option<String>,\n+    #[arg(global(true), long, value_name = \"STYLE\")]\n+    #[clap(value_enum, default_value_t = Color::Auto)]\n+    /// whether to use color in cargo and rustc output\n+    pub color: Color,\n \n+    /// whether rebuilding llvm should be skipped, overriding `skip-rebuld` in config.toml\n+    #[arg(global(true), long, value_name = \"VALUE\")]\n+    pub llvm_skip_rebuild: Option<bool>,\n+    /// generate PGO profile with rustc build\n+    #[arg(global(true), long, value_name = \"PROFILE\")]\n+    pub rust_profile_generate: Option<String>,\n+    /// use PGO profile for rustc build\n+    #[arg(global(true), long, value_name = \"PROFILE\")]\n+    pub rust_profile_use: Option<String>,\n+    /// use PGO profile for LLVM build\n+    #[arg(global(true), long, value_name = \"PROFILE\")]\n     pub llvm_profile_use: Option<String>,\n     // LLVM doesn't support a custom location for generating profile\n     // information.\n     //\n     // llvm_out/build/profiles/ is the location this writes to.\n+    /// generate PGO profile with llvm built for rustc\n+    #[arg(global(true), long)]\n     pub llvm_profile_generate: bool,\n+    /// generate BOLT profile for LLVM build\n+    #[arg(global(true), long)]\n     pub llvm_bolt_profile_generate: bool,\n+    /// use BOLT profile for LLVM build\n+    #[arg(global(true), long, value_name = \"PROFILE\")]\n     pub llvm_bolt_profile_use: Option<String>,\n+    #[arg(global(true))]\n+    /// paths for the subcommand\n+    pub paths: Vec<PathBuf>,\n+    /// arguments passed to subcommands\n+    #[arg(global(true), last(true), value_name = \"ARGS\")]\n+    pub free_args: Vec<String>,\n+}\n+\n+impl Flags {\n+    pub fn parse(args: &[String]) -> Self {\n+        let first = String::from(\"x.py\");\n+        let it = std::iter::once(&first).chain(args.iter());\n+        // We need to check for `<cmd> -h -v`, in which case we list the paths\n+        #[derive(Parser)]\n+        #[clap(disable_help_flag(true))]\n+        struct HelpVerboseOnly {\n+            #[arg(short, long)]\n+            help: bool,\n+            #[arg(global(true), short, long, action = clap::ArgAction::Count)]\n+            pub verbose: u8,\n+            #[arg(value_enum)]\n+            cmd: Kind,\n+        }\n+        if let Ok(HelpVerboseOnly { help: true, verbose: 1.., cmd: subcommand }) =\n+            HelpVerboseOnly::try_parse_from(it.clone())\n+        {\n+            println!(\"note: updating submodules before printing available paths\");\n+            let config = Config::parse(&[String::from(\"build\")]);\n+            let build = Build::new(config);\n+            let paths = Builder::get_help(&build, subcommand);\n+            if let Some(s) = paths {\n+                println!(\"{}\", s);\n+            } else {\n+                panic!(\"No paths available for subcommand `{}`\", subcommand.as_str());\n+            }\n+            crate::detail_exit(0);\n+        }\n \n-    /// Arguments appearing after `--` to be forwarded to tools,\n-    /// e.g. `--fix-broken` or test arguments.\n-    pub free_args: Option<Vec<String>>,\n+        Flags::parse_from(it)\n+    }\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, Default, clap::Subcommand)]\n pub enum Subcommand {\n-    Build {\n-        paths: Vec<PathBuf>,\n-    },\n+    #[clap(aliases = [\"b\"], long_about = \"\\n\n+    Arguments:\n+        This subcommand accepts a number of paths to directories to the crates\n+        and/or artifacts to compile. For example, for a quick build of a usable\n+        compiler:\n+            ./x.py build --stage 1 library/std\n+        This will build a compiler and standard library from the local source code.\n+        Once this is done, build/$ARCH/stage1 contains a usable compiler.\n+        If no arguments are passed then the default artifacts for that stage are\n+        compiled. For example:\n+            ./x.py build --stage 0\n+            ./x.py build \")]\n+    /// Compile either the compiler or libraries\n+    #[default]\n+    Build,\n+    #[clap(aliases = [\"c\"], long_about = \"\\n\n+    Arguments:\n+        This subcommand accepts a number of paths to directories to the crates\n+        and/or artifacts to compile. For example:\n+            ./x.py check library/std\n+        If no arguments are passed then many artifacts are checked.\")]\n+    /// Compile either the compiler or libraries, using cargo check\n     Check {\n-        paths: Vec<PathBuf>,\n+        #[arg(long)]\n+        /// Check all targets\n+        all_targets: bool,\n     },\n+    /// Run Clippy (uses rustup/cargo-installed clippy binary)\n+    #[clap(long_about = \"\\n\n+    Arguments:\n+        This subcommand accepts a number of paths to directories to the crates\n+        and/or artifacts to run clippy against. For example:\n+            ./x.py clippy library/core\n+            ./x.py clippy library/core library/proc_macro\")]\n     Clippy {\n+        #[arg(long)]\n         fix: bool,\n-        paths: Vec<PathBuf>,\n-        clippy_lint_allow: Vec<String>,\n-        clippy_lint_deny: Vec<String>,\n-        clippy_lint_warn: Vec<String>,\n-        clippy_lint_forbid: Vec<String>,\n-    },\n-    Fix {\n-        paths: Vec<PathBuf>,\n+        /// clippy lints to allow\n+        #[arg(global(true), short = 'A', action = clap::ArgAction::Append, value_name = \"LINT\")]\n+        allow: Vec<String>,\n+        /// clippy lints to deny\n+        #[arg(global(true), short = 'D', action = clap::ArgAction::Append, value_name = \"LINT\")]\n+        deny: Vec<String>,\n+        /// clippy lints to warn on\n+        #[arg(global(true), short = 'W', action = clap::ArgAction::Append, value_name = \"LINT\")]\n+        warn: Vec<String>,\n+        /// clippy lints to forbid\n+        #[arg(global(true), short = 'F', action = clap::ArgAction::Append, value_name = \"LINT\")]\n+        forbid: Vec<String>,\n     },\n+    /// Run cargo fix\n+    #[clap(long_about = \"\\n\n+    Arguments:\n+        This subcommand accepts a number of paths to directories to the crates\n+        and/or artifacts to run `cargo fix` against. For example:\n+            ./x.py fix library/core\n+            ./x.py fix library/core library/proc_macro\")]\n+    Fix,\n+    #[clap(\n+        name = \"fmt\",\n+        long_about = \"\\n\n+    Arguments:\n+        This subcommand optionally accepts a `--check` flag which succeeds if formatting is correct and\n+        fails if it is not. For example:\n+            ./x.py fmt\n+            ./x.py fmt --check\"\n+    )]\n+    /// Run rustfmt\n     Format {\n-        paths: Vec<PathBuf>,\n+        /// check formatting instead of applying\n+        #[arg(long)]\n         check: bool,\n     },\n+    #[clap(aliases = [\"d\"], long_about = \"\\n\n+    Arguments:\n+        This subcommand accepts a number of paths to directories of documentation\n+        to build. For example:\n+            ./x.py doc src/doc/book\n+            ./x.py doc src/doc/nomicon\n+            ./x.py doc src/doc/book library/std\n+            ./x.py doc library/std --json\n+            ./x.py doc library/std --open\n+        If no arguments are passed then everything is documented:\n+            ./x.py doc\n+            ./x.py doc --stage 1\")]\n+    /// Build documentation\n     Doc {\n-        paths: Vec<PathBuf>,\n+        #[arg(long)]\n+        /// open the docs in a browser\n         open: bool,\n+        #[arg(long)]\n+        /// render the documentation in JSON format in addition to the usual HTML format\n         json: bool,\n     },\n+    #[clap(aliases = [\"t\"], long_about = \"\\n\n+    Arguments:\n+        This subcommand accepts a number of paths to test directories that\n+        should be compiled and run. For example:\n+            ./x.py test tests/ui\n+            ./x.py test library/std --test-args hash_map\n+            ./x.py test library/std --stage 0 --no-doc\n+            ./x.py test tests/ui --bless\n+            ./x.py test tests/ui --compare-mode chalk\n+        Note that `test tests/* --stage N` does NOT depend on `build compiler/rustc --stage N`;\n+        just like `build library/std --stage N` it tests the compiler produced by the previous\n+        stage.\n+        Execute tool tests with a tool name argument:\n+            ./x.py test tidy\n+        If no arguments are passed then the complete artifacts for that stage are\n+        compiled and tested.\n+            ./x.py test\n+            ./x.py test --stage 1\")]\n+    /// Build and run some test suites\n     Test {\n-        paths: Vec<PathBuf>,\n-        /// Whether to automatically update stderr/stdout files\n+        #[arg(long)]\n+        /// run all tests regardless of failure\n+        no_fail_fast: bool,\n+        #[arg(long, value_name = \"SUBSTRING\")]\n+        /// skips tests matching SUBSTRING, if supported by test tool. May be passed multiple times\n+        skip: Vec<String>,\n+        #[arg(long, value_name = \"ARGS\", allow_hyphen_values(true))]\n+        /// extra arguments to be passed for the test tool being used\n+        /// (e.g. libtest, compiletest or rustdoc)\n+        test_args: Vec<String>,\n+        /// extra options to pass the compiler when running tests\n+        #[arg(long, value_name = \"ARGS\", allow_hyphen_values(true))]\n+        rustc_args: Vec<String>,\n+        #[arg(long)]\n+        /// do not run doc tests\n+        no_doc: bool,\n+        #[arg(long)]\n+        /// only run doc tests\n+        doc: bool,\n+        #[arg(long)]\n+        /// whether to automatically update stderr/stdout files\n         bless: bool,\n+        #[arg(long)]\n+        /// rerun tests even if the inputs are unchanged\n         force_rerun: bool,\n+        #[arg(long)]\n+        /// only run tests that result has been changed\n+        only_modified: bool,\n+        #[arg(long, value_name = \"COMPARE MODE\")]\n+        /// mode describing what file the actual ui output will be compared to\n         compare_mode: Option<String>,\n+        #[arg(long, value_name = \"check | build | run\")]\n+        /// force {check,build,run}-pass tests to this mode.\n         pass: Option<String>,\n+        #[arg(long, value_name = \"auto | always | never\")]\n+        /// whether to execute run-* tests\n         run: Option<String>,\n-        test_args: Vec<String>,\n-        rustc_args: Vec<String>,\n-        fail_fast: bool,\n-        doc_tests: DocTests,\n+        #[arg(long)]\n+        /// enable this to generate a Rustfix coverage file, which is saved in\n+        /// `/<build_base>/rustfix_missing_coverage.txt`\n         rustfix_coverage: bool,\n-        only_modified: bool,\n     },\n+    /// Build and run some benchmarks\n     Bench {\n-        paths: Vec<PathBuf>,\n+        #[arg(long, allow_hyphen_values(true))]\n         test_args: Vec<String>,\n     },\n+    /// Clean out build directories\n     Clean {\n-        paths: Vec<PathBuf>,\n+        #[arg(long)]\n         all: bool,\n     },\n-    Dist {\n-        paths: Vec<PathBuf>,\n-    },\n-    Install {\n-        paths: Vec<PathBuf>,\n-    },\n+    /// Duild distribution artifacts\n+    Dist,\n+    /// Install distribution artifacts\n+    Install,\n+    #[clap(aliases = [\"r\"], long_about = \"\\n\n+    Arguments:\n+        This subcommand accepts a number of paths to tools to build and run. For\n+        example:\n+            ./x.py run src/tools/expand-yaml-anchors\n+        At least a tool needs to be called.\")]\n+    /// Run tools contained in this repository\n     Run {\n-        paths: Vec<PathBuf>,\n+        /// arguments for the tool\n+        #[arg(long, allow_hyphen_values(true))]\n         args: Vec<String>,\n     },\n-    Setup {\n-        profile: Option<PathBuf>,\n-    },\n-    Suggest {\n-        run: bool,\n-    },\n-}\n-\n-impl Default for Subcommand {\n-    fn default() -> Subcommand {\n-        Subcommand::Build { paths: vec![PathBuf::from(\"nowhere\")] }\n-    }\n-}\n-\n-impl Flags {\n-    pub fn parse(args: &[String]) -> Flags {\n-        let (args, free_args) = if let Some(pos) = args.iter().position(|s| s == \"--\") {\n-            let (args, free) = args.split_at(pos);\n-            (args, Some(free[1..].to_vec()))\n-        } else {\n-            (args, None)\n-        };\n-        let mut subcommand_help = String::from(\n-            \"\\\n-Usage: x.py <subcommand> [options] [<paths>...]\n-\n-Subcommands:\n-    build, b    Compile either the compiler or libraries\n-    check, c    Compile either the compiler or libraries, using cargo check\n-    clippy      Run clippy (uses rustup/cargo-installed clippy binary)\n-    fix         Run cargo fix\n-    fmt         Run rustfmt\n-    test, t     Build and run some test suites\n-    bench       Build and run some benchmarks\n-    doc, d      Build documentation\n-    clean       Clean out build directories\n-    dist        Build distribution artifacts\n-    install     Install distribution artifacts\n-    run, r      Run tools contained in this repository\n-    setup       Create a config.toml (making it easier to use `x.py` itself)\n-    suggest     Suggest a subset of tests to run, based on modified files\n-\n-To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n-        );\n-\n-        let mut opts = Options::new();\n-        // Options common to all subcommands\n-        opts.optflagmulti(\"v\", \"verbose\", \"use verbose output (-vv for very verbose)\");\n-        opts.optflag(\"i\", \"incremental\", \"use incremental compilation\");\n-        opts.optopt(\"\", \"config\", \"TOML configuration file for build\", \"FILE\");\n-        opts.optopt(\n-            \"\",\n-            \"build-dir\",\n-            \"Build directory, overrides `build.build-dir` in `config.toml`\",\n-            \"DIR\",\n-        );\n-        opts.optopt(\"\", \"build\", \"build target of the stage0 compiler\", \"BUILD\");\n-        opts.optmulti(\"\", \"host\", \"host targets to build\", \"HOST\");\n-        opts.optmulti(\"\", \"target\", \"target targets to build\", \"TARGET\");\n-        opts.optmulti(\"\", \"exclude\", \"build paths to exclude\", \"PATH\");\n-        opts.optflag(\n-            \"\",\n-            \"include-default-paths\",\n-            \"include default paths in addition to the provided ones\",\n-        );\n-        opts.optopt(\"\", \"on-fail\", \"command to run on failure\", \"CMD\");\n-        opts.optflag(\"\", \"dry-run\", \"dry run; don't build anything\");\n-        opts.optopt(\n-            \"\",\n-            \"stage\",\n-            \"stage to build (indicates compiler to use/test, e.g., stage 0 uses the \\\n-             bootstrap compiler, stage 1 the stage 0 rustc artifacts, etc.)\",\n-            \"N\",\n-        );\n-        opts.optmulti(\n-            \"\",\n-            \"keep-stage\",\n-            \"stage(s) to keep without recompiling \\\n-            (pass multiple times to keep e.g., both stages 0 and 1)\",\n-            \"N\",\n-        );\n-        opts.optmulti(\n-            \"\",\n-            \"keep-stage-std\",\n-            \"stage(s) of the standard library to keep without recompiling \\\n-            (pass multiple times to keep e.g., both stages 0 and 1)\",\n-            \"N\",\n-        );\n-        opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n-        let j_msg = format!(\n-            \"number of jobs to run in parallel; \\\n-             defaults to {} (this host's logical CPU count)\",\n-            std::thread::available_parallelism().map_or(1, std::num::NonZeroUsize::get)\n-        );\n-        opts.optopt(\"j\", \"jobs\", &j_msg, \"JOBS\");\n-        opts.optflag(\"h\", \"help\", \"print this help message\");\n-        opts.optopt(\n-            \"\",\n-            \"warnings\",\n-            \"if value is deny, will deny warnings, otherwise use default\",\n-            \"VALUE\",\n-        );\n-        opts.optopt(\"\", \"error-format\", \"rustc error format\", \"FORMAT\");\n-        opts.optflag(\"\", \"json-output\", \"use message-format=json\");\n-        opts.optopt(\"\", \"color\", \"whether to use color in cargo and rustc output\", \"STYLE\");\n-        opts.optopt(\n-            \"\",\n-            \"rust-profile-generate\",\n-            \"generate PGO profile with rustc build\",\n-            \"PROFILE\",\n-        );\n-        opts.optopt(\"\", \"rust-profile-use\", \"use PGO profile for rustc build\", \"PROFILE\");\n-        opts.optflag(\"\", \"llvm-profile-generate\", \"generate PGO profile with llvm built for rustc\");\n-        opts.optopt(\"\", \"llvm-profile-use\", \"use PGO profile for llvm build\", \"PROFILE\");\n-        opts.optmulti(\"A\", \"\", \"allow certain clippy lints\", \"OPT\");\n-        opts.optmulti(\"D\", \"\", \"deny certain clippy lints\", \"OPT\");\n-        opts.optmulti(\"W\", \"\", \"warn about certain clippy lints\", \"OPT\");\n-        opts.optmulti(\"F\", \"\", \"forbid certain clippy lints\", \"OPT\");\n-        opts.optflag(\"\", \"llvm-bolt-profile-generate\", \"generate BOLT profile for LLVM build\");\n-        opts.optopt(\"\", \"llvm-bolt-profile-use\", \"use BOLT profile for LLVM build\", \"PROFILE\");\n-\n-        // We can't use getopt to parse the options until we have completed specifying which\n-        // options are valid, but under the current implementation, some options are conditional on\n-        // the subcommand. Therefore we must manually identify the subcommand first, so that we can\n-        // complete the definition of the options.  Then we can use the getopt::Matches object from\n-        // there on out.\n-        let subcommand = match args.iter().find_map(|s| Kind::parse(&s)) {\n-            Some(s) => s,\n-            None => {\n-                // No or an invalid subcommand -- show the general usage and subcommand help\n-                // An exit code will be 0 when no subcommand is given, and 1 in case of an invalid\n-                // subcommand.\n-                println!(\"{}\\n\", subcommand_help);\n-                let exit_code = if args.is_empty() { 0 } else { 1 };\n-                crate::detail_exit(exit_code);\n-            }\n-        };\n-\n-        // Some subcommands get extra options\n-        match subcommand {\n-            Kind::Test => {\n-                opts.optflag(\"\", \"no-fail-fast\", \"Run all tests regardless of failure\");\n-                opts.optmulti(\"\", \"skip\", \"skips tests matching SUBSTRING, if supported by test tool. May be passed multiple times\", \"SUBSTRING\");\n-                opts.optmulti(\n-                    \"\",\n-                    \"test-args\",\n-                    \"extra arguments to be passed for the test tool being used \\\n-                        (e.g. libtest, compiletest or rustdoc)\",\n-                    \"ARGS\",\n-                );\n-                opts.optmulti(\n-                    \"\",\n-                    \"rustc-args\",\n-                    \"extra options to pass the compiler when running tests\",\n-                    \"ARGS\",\n-                );\n-                opts.optflag(\"\", \"no-doc\", \"do not run doc tests\");\n-                opts.optflag(\"\", \"doc\", \"only run doc tests\");\n-                opts.optflag(\"\", \"bless\", \"update all stderr/stdout files of failing ui tests\");\n-                opts.optflag(\"\", \"force-rerun\", \"rerun tests even if the inputs are unchanged\");\n-                opts.optflag(\"\", \"only-modified\", \"only run tests that result has been changed\");\n-                opts.optopt(\n-                    \"\",\n-                    \"compare-mode\",\n-                    \"mode describing what file the actual ui output will be compared to\",\n-                    \"COMPARE MODE\",\n-                );\n-                opts.optopt(\n-                    \"\",\n-                    \"pass\",\n-                    \"force {check,build,run}-pass tests to this mode.\",\n-                    \"check | build | run\",\n-                );\n-                opts.optopt(\"\", \"run\", \"whether to execute run-* tests\", \"auto | always | never\");\n-                opts.optflag(\n-                    \"\",\n-                    \"rustfix-coverage\",\n-                    \"enable this to generate a Rustfix coverage file, which is saved in \\\n-                        `/<build_base>/rustfix_missing_coverage.txt`\",\n-                );\n-            }\n-            Kind::Check => {\n-                opts.optflag(\"\", \"all-targets\", \"Check all targets\");\n-            }\n-            Kind::Bench => {\n-                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n-            }\n-            Kind::Clippy => {\n-                opts.optflag(\"\", \"fix\", \"automatically apply lint suggestions\");\n-            }\n-            Kind::Doc => {\n-                opts.optflag(\"\", \"open\", \"open the docs in a browser\");\n-                opts.optflag(\n-                    \"\",\n-                    \"json\",\n-                    \"render the documentation in JSON format in addition to the usual HTML format\",\n-                );\n-            }\n-            Kind::Clean => {\n-                opts.optflag(\"\", \"all\", \"clean all build artifacts\");\n-            }\n-            Kind::Format => {\n-                opts.optflag(\"\", \"check\", \"check formatting instead of applying.\");\n-            }\n-            Kind::Run => {\n-                opts.optmulti(\"\", \"args\", \"arguments for the tool\", \"ARGS\");\n-            }\n-            Kind::Suggest => {\n-                opts.optflag(\"\", \"run\", \"run suggested tests\");\n-            }\n-            _ => {}\n-        };\n-\n-        // fn usage()\n-        let usage = |exit_code: i32, opts: &Options, verbose: bool, subcommand_help: &str| -> ! {\n-            println!(\"{}\", opts.usage(subcommand_help));\n-            if verbose {\n-                // We have an unfortunate situation here: some Steps use `builder.in_tree_crates` to determine their paths.\n-                // To determine those crates, we need to run `cargo metadata`, which means we need all submodules to be checked out.\n-                // That takes a while to run, so only do it when paths were explicitly requested, not on all CLI errors.\n-                // `Build::new` won't load submodules for the `setup` command.\n-                let cmd = if verbose {\n-                    println!(\"note: updating submodules before printing available paths\");\n-                    \"build\"\n-                } else {\n-                    \"setup\"\n-                };\n-                let config = Config::parse(&[cmd.to_string()]);\n-                let build = Build::new(config);\n-                let paths = Builder::get_help(&build, subcommand);\n-\n-                if let Some(s) = paths {\n-                    println!(\"{}\", s);\n-                } else {\n-                    panic!(\"No paths available for subcommand `{}`\", subcommand.as_str());\n-                }\n-            } else {\n-                println!(\n-                    \"Run `./x.py {} -h -v` to see a list of available paths.\",\n-                    subcommand.as_str()\n-                );\n-            }\n-            crate::detail_exit(exit_code);\n-        };\n-\n-        // Done specifying what options are possible, so do the getopts parsing\n-        let matches = opts.parse(args).unwrap_or_else(|e| {\n-            // Invalid argument/option format\n-            println!(\"\\n{}\\n\", e);\n-            usage(1, &opts, false, &subcommand_help);\n-        });\n-\n-        // Extra sanity check to make sure we didn't hit this crazy corner case:\n-        //\n-        //     ./x.py --frobulate clean build\n-        //            ^-- option  ^     ^- actual subcommand\n-        //                        \\_ arg to option could be mistaken as subcommand\n-        let mut pass_sanity_check = true;\n-        match matches.free.get(0).and_then(|s| Kind::parse(&s)) {\n-            Some(check_subcommand) => {\n-                if check_subcommand != subcommand {\n-                    pass_sanity_check = false;\n-                }\n-            }\n-            None => {\n-                pass_sanity_check = false;\n-            }\n-        }\n-        if !pass_sanity_check {\n-            eprintln!(\"{}\\n\", subcommand_help);\n-            eprintln!(\n-                \"Sorry, I couldn't figure out which subcommand you were trying to specify.\\n\\\n-                 You may need to move some options to after the subcommand.\\n\"\n-            );\n-            crate::detail_exit(1);\n-        }\n-        // Extra help text for some commands\n-        match subcommand {\n-            Kind::Build => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand accepts a number of paths to directories to the crates\n-    and/or artifacts to compile. For example, for a quick build of a usable\n-    compiler:\n-\n-        ./x.py build --stage 1 library/std\n-\n-    This will build a compiler and standard library from the local source code.\n-    Once this is done, build/$ARCH/stage1 contains a usable compiler.\n-\n-    If no arguments are passed then the default artifacts for that stage are\n-    compiled. For example:\n-\n-        ./x.py build --stage 0\n-        ./x.py build \",\n-                );\n-            }\n-            Kind::Check => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand accepts a number of paths to directories to the crates\n-    and/or artifacts to compile. For example:\n-\n-        ./x.py check library/std\n-\n-    If no arguments are passed then many artifacts are checked.\",\n-                );\n-            }\n-            Kind::Clippy => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand accepts a number of paths to directories to the crates\n-    and/or artifacts to run clippy against. For example:\n-\n-        ./x.py clippy library/core\n-        ./x.py clippy library/core library/proc_macro\",\n-                );\n-            }\n-            Kind::Fix => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand accepts a number of paths to directories to the crates\n-    and/or artifacts to run `cargo fix` against. For example:\n-\n-        ./x.py fix library/core\n-        ./x.py fix library/core library/proc_macro\",\n-                );\n-            }\n-            Kind::Format => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand optionally accepts a `--check` flag which succeeds if formatting is correct and\n-    fails if it is not. For example:\n-\n-        ./x.py fmt\n-        ./x.py fmt --check\",\n-                );\n-            }\n-            Kind::Test => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand accepts a number of paths to test directories that\n-    should be compiled and run. For example:\n-\n-        ./x.py test tests/ui\n-        ./x.py test library/std --test-args hash_map\n-        ./x.py test library/std --stage 0 --no-doc\n-        ./x.py test tests/ui --bless\n-        ./x.py test tests/ui --compare-mode chalk\n-\n-    Note that `test tests/* --stage N` does NOT depend on `build compiler/rustc --stage N`;\n-    just like `build library/std --stage N` it tests the compiler produced by the previous\n-    stage.\n-\n-    Execute tool tests with a tool name argument:\n-\n-        ./x.py test tidy\n-\n-    If no arguments are passed then the complete artifacts for that stage are\n-    compiled and tested.\n-\n-        ./x.py test\n-        ./x.py test --stage 1\",\n-                );\n-            }\n-            Kind::Doc => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand accepts a number of paths to directories of documentation\n-    to build. For example:\n-\n-        ./x.py doc src/doc/book\n-        ./x.py doc src/doc/nomicon\n-        ./x.py doc src/doc/book library/std\n-        ./x.py doc library/std --json\n-        ./x.py doc library/std --open\n-\n-    If no arguments are passed then everything is documented:\n-\n-        ./x.py doc\n-        ./x.py doc --stage 1\",\n-                );\n-            }\n-            Kind::Run => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand accepts a number of paths to tools to build and run. For\n-    example:\n-\n-        ./x.py run src/tools/expand-yaml-anchors\n-\n-    At least a tool needs to be called.\",\n-                );\n-            }\n-            Kind::Setup => {\n-                subcommand_help.push_str(&format!(\n-                    \"\\n\n+    /// Set up the environment for development\n+    #[clap(long_about = format!(\n+        \"\\n\n x.py setup creates a `config.toml` which changes the defaults for x.py itself,\n-as well as setting up a git pre-push hook, VS code config and toolchain link.\n-\n+as well as setting up a git pre-push hook, VS Code config and toolchain link.\n Arguments:\n     This subcommand accepts a 'profile' to use for builds. For example:\n-\n         ./x.py setup library\n-\n     The profile is optional and you will be prompted interactively if it is not given.\n     The following profiles are available:\n-\n {}\n-\n-    To only set up the git hook, VS code or toolchain link, you may use\n+    To only set up the git hook, VS Code config or toolchain link, you may use\n         ./x.py setup hook\n         ./x.py setup vscode\n-        ./x.py setup link\n-\",\n-                    Profile::all_for_help(\"        \").trim_end()\n-                ));\n-            }\n-            Kind::Bench | Kind::Clean | Kind::Dist | Kind::Install | Kind::Suggest => {}\n-        };\n-        // Get any optional paths which occur after the subcommand\n-        let mut paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n-\n-        let verbose = matches.opt_present(\"verbose\");\n-\n-        // User passed in -h/--help?\n-        if matches.opt_present(\"help\") {\n-            usage(0, &opts, verbose, &subcommand_help);\n-        }\n-\n-        let cmd = match subcommand {\n-            Kind::Build => Subcommand::Build { paths },\n-            Kind::Check => {\n-                if matches.opt_present(\"all-targets\") {\n-                    println!(\n-                        \"Warning: --all-targets is now on by default and does not need to be passed explicitly.\"\n-                    );\n-                }\n-                Subcommand::Check { paths }\n-            }\n-            Kind::Clippy => Subcommand::Clippy {\n-                paths,\n-                fix: matches.opt_present(\"fix\"),\n-                clippy_lint_allow: matches.opt_strs(\"A\"),\n-                clippy_lint_warn: matches.opt_strs(\"W\"),\n-                clippy_lint_deny: matches.opt_strs(\"D\"),\n-                clippy_lint_forbid: matches.opt_strs(\"F\"),\n-            },\n-            Kind::Fix => Subcommand::Fix { paths },\n-            Kind::Test => Subcommand::Test {\n-                paths,\n-                bless: matches.opt_present(\"bless\"),\n-                force_rerun: matches.opt_present(\"force-rerun\"),\n-                compare_mode: matches.opt_str(\"compare-mode\"),\n-                pass: matches.opt_str(\"pass\"),\n-                run: matches.opt_str(\"run\"),\n-                test_args: matches.opt_strs(\"test-args\"),\n-                rustc_args: matches.opt_strs(\"rustc-args\"),\n-                fail_fast: !matches.opt_present(\"no-fail-fast\"),\n-                rustfix_coverage: matches.opt_present(\"rustfix-coverage\"),\n-                only_modified: matches.opt_present(\"only-modified\"),\n-                doc_tests: if matches.opt_present(\"doc\") {\n-                    DocTests::Only\n-                } else if matches.opt_present(\"no-doc\") {\n-                    DocTests::No\n-                } else {\n-                    DocTests::Yes\n-                },\n-            },\n-            Kind::Bench => Subcommand::Bench { paths, test_args: matches.opt_strs(\"test-args\") },\n-            Kind::Doc => Subcommand::Doc {\n-                paths,\n-                open: matches.opt_present(\"open\"),\n-                json: matches.opt_present(\"json\"),\n-            },\n-            Kind::Clean => Subcommand::Clean { all: matches.opt_present(\"all\"), paths },\n-            Kind::Format => Subcommand::Format { check: matches.opt_present(\"check\"), paths },\n-            Kind::Dist => Subcommand::Dist { paths },\n-            Kind::Install => Subcommand::Install { paths },\n-            Kind::Suggest => Subcommand::Suggest { run: matches.opt_present(\"run\") },\n-            Kind::Run => {\n-                if paths.is_empty() {\n-                    println!(\"\\nrun requires at least a path!\\n\");\n-                    usage(1, &opts, verbose, &subcommand_help);\n-                }\n-                Subcommand::Run { paths, args: matches.opt_strs(\"args\") }\n-            }\n-            Kind::Setup => {\n-                let profile = if paths.len() > 1 {\n-                    eprintln!(\"\\nerror: At most one option can be passed to setup\\n\");\n-                    usage(1, &opts, verbose, &subcommand_help)\n-                } else if let Some(path) = paths.pop() {\n-                    let profile_string = t!(path.into_os_string().into_string().map_err(\n-                        |path| format!(\"{} is not a valid UTF8 string\", path.to_string_lossy())\n-                    ));\n-\n-                    let profile = profile_string.parse().unwrap_or_else(|err| {\n-                        eprintln!(\"error: {}\", err);\n-                        eprintln!(\"help: the available profiles are:\");\n-                        eprint!(\"{}\", Profile::all_for_help(\"- \"));\n-                        crate::detail_exit(1);\n-                    });\n-                    Some(profile)\n-                } else {\n-                    None\n-                };\n-                Subcommand::Setup { profile }\n-            }\n-        };\n-\n-        Flags {\n-            verbose: matches.opt_count(\"verbose\"),\n-            stage: matches.opt_str(\"stage\").map(|j| j.parse().expect(\"`stage` should be a number\")),\n-            dry_run: matches.opt_present(\"dry-run\"),\n-            on_fail: matches.opt_str(\"on-fail\"),\n-            rustc_error_format: matches.opt_str(\"error-format\"),\n-            json_output: matches.opt_present(\"json-output\"),\n-            keep_stage: matches\n-                .opt_strs(\"keep-stage\")\n-                .into_iter()\n-                .map(|j| j.parse().expect(\"`keep-stage` should be a number\"))\n-                .collect(),\n-            keep_stage_std: matches\n-                .opt_strs(\"keep-stage-std\")\n-                .into_iter()\n-                .map(|j| j.parse().expect(\"`keep-stage-std` should be a number\"))\n-                .collect(),\n-            host: if matches.opt_present(\"host\") {\n-                Some(\n-                    split(&matches.opt_strs(\"host\"))\n-                        .into_iter()\n-                        .map(|x| TargetSelection::from_user(&x))\n-                        .collect::<Vec<_>>(),\n-                )\n-            } else {\n-                None\n-            },\n-            target: if matches.opt_present(\"target\") {\n-                Some(\n-                    split(&matches.opt_strs(\"target\"))\n-                        .into_iter()\n-                        .map(|x| TargetSelection::from_user(&x))\n-                        .collect::<Vec<_>>(),\n-                )\n-            } else {\n-                None\n-            },\n-            config: matches.opt_str(\"config\").map(PathBuf::from),\n-            build_dir: matches.opt_str(\"build-dir\").map(PathBuf::from),\n-            jobs: matches.opt_str(\"jobs\").map(|j| j.parse().expect(\"`jobs` should be a number\")),\n-            cmd,\n-            incremental: matches.opt_present(\"incremental\"),\n-            exclude: split(&matches.opt_strs(\"exclude\"))\n-                .into_iter()\n-                .map(|p| p.into())\n-                .collect::<Vec<_>>(),\n-            include_default_paths: matches.opt_present(\"include-default-paths\"),\n-            deny_warnings: parse_deny_warnings(&matches),\n-            color: matches\n-                .opt_get_default(\"color\", Color::Auto)\n-                .expect(\"`color` should be `always`, `never`, or `auto`\"),\n-            rust_profile_use: matches.opt_str(\"rust-profile-use\"),\n-            rust_profile_generate: matches.opt_str(\"rust-profile-generate\"),\n-            llvm_profile_use: matches.opt_str(\"llvm-profile-use\"),\n-            llvm_profile_generate: matches.opt_present(\"llvm-profile-generate\"),\n-            llvm_bolt_profile_generate: matches.opt_present(\"llvm-bolt-profile-generate\"),\n-            llvm_bolt_profile_use: matches.opt_str(\"llvm-bolt-profile-use\"),\n-            free_args,\n-        }\n-    }\n+        ./x.py setup link\", Profile::all_for_help(\"        \").trim_end()))]\n+    Setup {\n+        /// Either the profile for `config.toml` or another setup action.\n+        /// May be omitted to set up interactively\n+        #[arg(value_name = \"<PROFILE>|hook|vscode|link\")]\n+        profile: Option<PathBuf>,\n+    },\n+    /// Suggest a subset of tests to run, based on modified files\n+    #[clap(long_about = \"\\n\")]\n+    Suggest {\n+        /// run suggested tests\n+        #[arg(long)]\n+        run: bool,\n+    },\n }\n \n impl Subcommand {\n@@ -756,14 +441,22 @@ impl Subcommand {\n \n     pub fn fail_fast(&self) -> bool {\n         match *self {\n-            Subcommand::Test { fail_fast, .. } => fail_fast,\n+            Subcommand::Test { no_fail_fast, .. } => !no_fail_fast,\n             _ => false,\n         }\n     }\n \n     pub fn doc_tests(&self) -> DocTests {\n         match *self {\n-            Subcommand::Test { doc_tests, .. } => doc_tests,\n+            Subcommand::Test { doc, no_doc, .. } => {\n+                if doc {\n+                    DocTests::Only\n+                } else if no_doc {\n+                    DocTests::No\n+                } else {\n+                    DocTests::Yes\n+                }\n+            }\n             _ => DocTests::Yes,\n         }\n     }\n@@ -831,19 +524,3 @@ impl Subcommand {\n         }\n     }\n }\n-\n-fn split(s: &[String]) -> Vec<String> {\n-    s.iter().flat_map(|s| s.split(',')).filter(|s| !s.is_empty()).map(|s| s.to_string()).collect()\n-}\n-\n-fn parse_deny_warnings(matches: &getopts::Matches) -> Option<bool> {\n-    match matches.opt_str(\"warnings\").as_deref() {\n-        Some(\"deny\") => Some(true),\n-        Some(\"warn\") => Some(false),\n-        Some(value) => {\n-            eprintln!(r#\"invalid value for --warnings: {:?}, expected \"warn\" or \"deny\"\"#, value,);\n-            crate::detail_exit(1);\n-        }\n-        None => None,\n-    }\n-}"}, {"sha": "994336977dc6a89f408916e4840eb5cb275455a1", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -660,8 +660,8 @@ impl Build {\n \n         // hardcoded subcommands\n         match &self.config.cmd {\n-            Subcommand::Format { check, paths } => {\n-                return format::format(&builder::Builder::new(&self), *check, &paths);\n+            Subcommand::Format { check } => {\n+                return format::format(&builder::Builder::new(&self), *check, &self.config.paths);\n             }\n             Subcommand::Suggest { run } => {\n                 return suggest::suggest(&builder::Builder::new(&self), *run);"}, {"sha": "854b7f5bd3afa4d3061dd14f70e06a49be1876d9", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1545,7 +1545,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n \n         // Get paths from cmd args\n         let paths = match &builder.config.cmd {\n-            Subcommand::Test { ref paths, .. } => &paths[..],\n+            Subcommand::Test { .. } => &builder.config.paths[..],\n             _ => &[],\n         };\n "}, {"sha": "3ac5343aa575dabb04798c111eff89676dbc56c7", "filename": "src/ci/docker/host-x86_64/dist-arm-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-arm-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-arm-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-arm-linux%2FDockerfile?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -8,7 +8,6 @@ RUN sh /scripts/crosstool-ng.sh\n \n WORKDIR /build\n \n-COPY scripts/musl-patch-configure.diff /build/\n COPY scripts/musl-toolchain.sh /build/\n # We need to mitigate rust-lang/rust#34978 when compiling musl itself as well\n RUN CFLAGS=\"-Wa,--compress-debug-sections=none -Wl,--compress-debug-sections=none\" \\"}, {"sha": "6f04dcad9a54fe44cb307e55e312aad5cb4a7123", "filename": "src/ci/docker/host-x86_64/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-musl%2FDockerfile?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -25,7 +25,6 @@ WORKDIR /build/\n COPY scripts/cmake.sh /scripts/\n RUN /scripts/cmake.sh\n \n-COPY scripts/musl-patch-configure.diff /build/\n COPY scripts/musl-toolchain.sh /build/\n # We need to mitigate rust-lang/rust#34978 when compiling musl itself as well\n RUN CFLAGS=\"-Wa,-mrelax-relocations=no -Wa,--compress-debug-sections=none -Wl,--compress-debug-sections=none\" \\"}, {"sha": "1dc7b7987243887529959bb90f94a64a4918df85", "filename": "src/ci/docker/host-x86_64/test-various/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -33,7 +33,6 @@ RUN curl -sL --output ovmf-ia32.deb http://mirrors.kernel.org/ubuntu/pool/univer\n RUN dpkg -i ovmf-ia32.deb && rm ovmf-ia32.deb\n \n WORKDIR /build/\n-COPY scripts/musl-patch-configure.diff /build/\n COPY scripts/musl-toolchain.sh /build/\n RUN bash musl-toolchain.sh x86_64 && rm -rf build\n WORKDIR /"}, {"sha": "8bea8cd4c878c17fb8afb66e9e131b570df3b629", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -169,6 +169,7 @@ if [ \"$SCCACHE_BUCKET\" != \"\" ]; then\n     args=\"$args --env SCCACHE_REGION\"\n     args=\"$args --env AWS_ACCESS_KEY_ID\"\n     args=\"$args --env AWS_SECRET_ACCESS_KEY\"\n+    args=\"$args --env AWS_REGION\"\n else\n     mkdir -p $HOME/.cache/sccache\n     args=\"$args --env SCCACHE_DIR=/sccache --volume $HOME/.cache/sccache:/sccache\""}, {"sha": "bc1b30e2d31ae204857f1202b9dc17efe14042a8", "filename": "src/ci/docker/scripts/musl-toolchain.sh", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -4,7 +4,7 @@\n #\n # Versions of the toolchain components are configurable in `musl-cross-make/Makefile` and\n # musl unlike GLIBC is forward compatible so upgrading it shouldn't break old distributions.\n-# Right now we have: Binutils 2.31.1, GCC 9.2.0, musl 1.1.24.\n+# Right now we have: Binutils 2.31.1, GCC 9.2.0, musl 1.2.3.\n \n # ignore-tidy-linelength\n \n@@ -32,6 +32,7 @@ TARGET=$ARCH-linux-musl\n \n # Don't depend on the mirrors of sabotage linux that musl-cross-make uses.\n LINUX_HEADERS_SITE=https://ci-mirrors.rust-lang.org/rustc/sabotage-linux-tarballs\n+LINUX_VER=headers-4.19.88\n \n OUTPUT=/usr/local\n shift\n@@ -44,18 +45,11 @@ export CFLAGS=\"-fPIC -g1 $CFLAGS\"\n \n git clone https://github.com/richfelker/musl-cross-make # -b v0.9.9\n cd musl-cross-make\n-# A few commits ahead of v0.9.9 to include the cowpatch fix:\n-git checkout a54eb56f33f255dfca60be045f12a5cfaf5a72a9\n+# A version that includes support for building musl 1.2.3\n+git checkout fe915821b652a7fa37b34a596f47d8e20bc72338\n \n-# Fix the cfi detection script in musl's configure so cfi is generated\n-# when debug info is asked for. This patch is derived from\n-# https://git.musl-libc.org/cgit/musl/commit/?id=c4d4028dde90562f631edf559fbc42d8ec1b29de.\n-# When we upgrade to a version that includes this commit, we can remove the patch.\n-mkdir patches/musl-1.1.24\n-cp ../musl-patch-configure.diff patches/musl-1.1.24/0001-fix-cfi-detection.diff\n-\n-hide_output make -j$(nproc) TARGET=$TARGET MUSL_VER=1.1.24 LINUX_HEADERS_SITE=$LINUX_HEADERS_SITE\n-hide_output make install TARGET=$TARGET MUSL_VER=1.1.24 LINUX_HEADERS_SITE=$LINUX_HEADERS_SITE OUTPUT=$OUTPUT\n+hide_output make -j$(nproc) TARGET=$TARGET MUSL_VER=1.2.3 LINUX_HEADERS_SITE=$LINUX_HEADERS_SITE LINUX_VER=$LINUX_VER\n+hide_output make install TARGET=$TARGET MUSL_VER=1.2.3 LINUX_HEADERS_SITE=$LINUX_HEADERS_SITE LINUX_VER=$LINUX_VER OUTPUT=$OUTPUT\n \n cd -\n "}, {"sha": "ece8e6c15c0cbd3260168a228b4c376883e0bd26", "filename": "src/ci/docker/scripts/musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -25,7 +25,7 @@ shift\n # Apparently applying `-fPIC` everywhere allows them to link successfully.\n export CFLAGS=\"-fPIC $CFLAGS\"\n \n-MUSL=musl-1.1.24\n+MUSL=musl-1.2.3\n \n # may have been downloaded in a previous run\n if [ ! -d $MUSL ]; then"}, {"sha": "f81e740936ba59b174f9c02ae1d16dc4969787e3", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -53,6 +53,7 @@ x--expand-yaml-anchors--remove:\n     # (caches, artifacts...).\n     CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZI5DHEBFL\n     ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZN24CBO55\n+    AWS_REGION: us-west-1\n     CACHE_DOMAIN: ci-caches.rust-lang.org\n \n   - &dummy-variables\n@@ -68,6 +69,7 @@ x--expand-yaml-anchors--remove:\n     # (caches, artifacts...).\n     CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n     ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+    AWS_REGION: us-west-1\n     CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n \n   - &base-job\n@@ -158,10 +160,6 @@ x--expand-yaml-anchors--remove:\n         run: src/ci/scripts/dump-environment.sh\n         <<: *step\n \n-      - name: install awscli\n-        run: src/ci/scripts/install-awscli.sh\n-        <<: *step\n-\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n         <<: *step\n@@ -300,25 +298,21 @@ jobs:\n     env:\n       <<: [*shared-ci-variables, *public-variables]\n     if: github.event_name == 'pull_request'\n-    continue-on-error: ${{ matrix.tidy }}\n+    continue-on-error: ${{ matrix.name == 'mingw-check-tidy' }}\n     strategy:\n       matrix:\n         include:\n           - name: mingw-check\n             <<: *job-linux-16c\n-            tidy: false\n \n           - name: mingw-check-tidy\n             <<: *job-linux-16c\n-            tidy: true\n \n           - name: x86_64-gnu-llvm-14\n             <<: *job-linux-16c\n-            tidy: false\n \n           - name: x86_64-gnu-tools\n             <<: *job-linux-16c\n-            tidy: false\n \n   auto:\n     permissions:"}, {"sha": "aa62407eaea7df5f0ad3dd051d51f721c41a10fd", "filename": "src/ci/scripts/install-awscli.sh", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Fci%2Fscripts%2Finstall-awscli.sh", "raw_url": "https://github.com/rust-lang/rust/raw/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Fci%2Fscripts%2Finstall-awscli.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-awscli.sh?ref=dd9df18792cd13b25a54406ef60e3b32ac358272", "patch": "@@ -1,38 +0,0 @@\n-#!/bin/bash\n-# This script downloads and installs awscli from the packages mirrored in our\n-# own S3 bucket. This follows the recommendations at:\n-#\n-#    https://packaging.python.org/guides/index-mirrors-and-caches/#caching-with-pip\n-#\n-# To create a new mirrored copy you can run the command:\n-#\n-#    pip wheel awscli\n-#\n-# Before compressing please make sure all the wheels end with `-none-any.whl`.\n-# If that's not the case you'll need to remove the non-cross-platform ones and\n-# replace them with the .tar.gz downloaded from https://pypi.org.\n-\n-set -euo pipefail\n-IFS=$'\\n\\t'\n-\n-source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n-\n-MIRROR=\"${MIRRORS_BASE}/2023-04-28-awscli.tar\"\n-DEPS_DIR=\"/tmp/awscli-deps\"\n-\n-pip=\"pip\"\n-pipflags=\"\"\n-if isLinux; then\n-    pip=\"pip3\"\n-    pipflags=\"--user\"\n-\n-    sudo apt-get install -y python3-setuptools python3-wheel\n-    ciCommandAddPath \"${HOME}/.local/bin\"\n-elif isMacOS; then\n-    pip=\"pip3\"\n-fi\n-\n-mkdir -p \"${DEPS_DIR}\"\n-curl \"${MIRROR}\" | tar xf - -C \"${DEPS_DIR}\"\n-\"${pip}\" install ${pipflags} --no-index \"--find-links=${DEPS_DIR}\" awscli\n-rm -rf \"${DEPS_DIR}\""}, {"sha": "1041d5026690f97c60d61437fd5d00441e2b5f7f", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -90,6 +90,14 @@ It takes one of the following values:\n For example, for gcc flavor linkers, this issues the `-nodefaultlibs` flag to\n the linker.\n \n+## dlltool\n+\n+On `windows-gnu` targets, this flag controls which dlltool `rustc` invokes to\n+generate import libraries when using the [`raw-dylib` link kind](../../reference/items/external-blocks.md#the-link-attribute).\n+It takes a path to [the dlltool executable](https://sourceware.org/binutils/docs/binutils/dlltool.html).\n+If this flag is not specified, a dlltool executable will be inferred based on\n+the host environment and target.\n+\n ## embed-bitcode\n \n This flag controls whether or not the compiler embeds LLVM bitcode into object\n@@ -574,7 +582,8 @@ change in the future.\n This instructs `rustc` to generate code specifically for a particular processor.\n \n You can run `rustc --print target-cpus` to see the valid options to pass\n-here. Each target has a default base CPU. Special values include:\n+and the default target CPU for the current buid target.\n+Each target has a default base CPU. Special values include:\n \n * `native` can be passed to use the processor of the host machine.\n * `generic` refers to an LLVM target with minimal features but modern tuning."}, {"sha": "087b37dd8def51410317a489486047000acb3000", "filename": "src/doc/unstable-book/src/compiler-flags/extern-options.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fextern-options.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fextern-options.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fextern-options.md?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -4,6 +4,7 @@\n * Tracking issue for `noprelude`: [#98398](https://github.com/rust-lang/rust/issues/98398)\n * Tracking issue for `priv`: [#98399](https://github.com/rust-lang/rust/issues/98399)\n * Tracking issue for `nounused`: [#98400](https://github.com/rust-lang/rust/issues/98400)\n+* Tracking issue for `force`: [#111302](https://github.com/rust-lang/rust/issues/111302)\n \n The behavior of the `--extern` flag can be modified with `noprelude`, `priv` or `nounused` options.\n \n@@ -25,3 +26,4 @@ To use multiple options, separate them with a comma:\n   This is used by the [build-std project](https://github.com/rust-lang/wg-cargo-std-aware/) to simulate compatibility with sysroot-only crates.\n * `priv`: Mark the crate as a private dependency for the [`exported_private_dependencies`](../../rustc/lints/listing/warn-by-default.html#exported-private-dependencies) lint.\n * `nounused`: Suppress [`unused-crate-dependencies`](../../rustc/lints/listing/allowed-by-default.html#unused-crate-dependencies) warnings for the crate.\n+* `force`: Resolve the crate as if it is used, even if it is not used. This can be used to satisfy compilation session requirements like the presence of an allocator or panic handler."}, {"sha": "532cb9eea1107ad56faaca76eec2daeadcf7b41e", "filename": "src/doc/unstable-book/src/language-features/asm-experimental-arch.md", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -18,6 +18,7 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n - MSP430\n - M68k\n - LoongArch\n+- s390x\n \n ## Register classes\n \n@@ -48,6 +49,8 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | M68k         | `reg_addr`     | `a[0-3]`                           | `a`                  |\n | LoongArch    | `reg`          | `$r1`, `$r[4-20]`, `$r[23,30]`     | `r`                  |\n | LoongArch    | `freg`         | `$f[0-31]`                         | `f`                  |\n+| s390x        | `reg`          | `r[0-10]`, `r[12-14]`              | `r`                  |\n+| s390x        | `freg`         | `f[0-15]`                          | `f`                  |\n \n > **Notes**:\n > - NVPTX doesn't have a fixed register set, so named registers are not supported.\n@@ -81,6 +84,8 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | M68k         | `reg_data`                      | None           | `i8`, `i16`, `i32`                      |\n | LoongArch64  | `reg`                           | None           | `i8`, `i16`, `i32`, `i64`, `f32`, `f64` |\n | LoongArch64  | `freg`                          | None           | `f32`, `f64`                            |\n+| s390x        | `reg`                           | None           | `i8`, `i16`, `i32`, `i64`               |\n+| s390x        | `freg`                          | None           | `f32`, `f64`                            |\n \n ## Register aliases\n \n@@ -115,8 +120,8 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n \n | Architecture | Unsupported register                    | Reason                                                                                                                                                                              |\n | ------------ | --------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n-| All          | `sp`                                    | The stack pointer must be restored to its original value at the end of an asm code block.                                                                                           |\n-| All          | `fr` (Hexagon), `$fp` (MIPS), `Y` (AVR), `r4` (MSP430), `a6` (M68k), `$fp` (LoongArch) | The frame pointer cannot be used as an input or output.                                                                                                                             |\n+| All          | `sp`, `r15` (s390x)                     | The stack pointer must be restored to its original value at the end of an asm code block.                                                                                           |\n+| All          | `fr` (Hexagon), `$fp` (MIPS), `Y` (AVR), `r4` (MSP430), `a6` (M68k), `$fp` (LoongArch), `r11` (s390x) | The frame pointer cannot be used as an input or output.                                                                                                                             |\n | All          | `r19` (Hexagon)                         | This is used internally by LLVM as a \"base pointer\" for functions with complex stack frames.                                                                                        |\n | MIPS         | `$0` or `$zero`                         | This is a constant zero register which can't be modified.                                                                                                                           |\n | MIPS         | `$1` or `$at`                           | Reserved for assembler.                                                                                                                                                             |\n@@ -147,6 +152,8 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | PowerPC      | `freg`         | None     | `0`            | None          |\n | LoongArch    | `reg`          | None     | `$r2`          | None          |\n | LoongArch    | `freg`         | None     | `$f0`          | None          |\n+| s390x        | `reg`          | None     | `%r0`          | None          |\n+| s390x        | `freg`         | None     | `%f0`          | None          |\n \n # Flags covered by `preserves_flags`\n \n@@ -157,3 +164,5 @@ These flags registers must be restored upon exiting the asm block if the `preser\n   - The status register `r2`.\n - M68k\n   - The condition code register `ccr`.\n+- s390x\n+  - The condition code register `cc`."}, {"sha": "5fd208ae7571c979d61c7b3342d13bff6da7c832", "filename": "src/doc/unstable-book/src/language-features/raw-dylib.md", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fraw-dylib.md", "raw_url": "https://github.com/rust-lang/rust/raw/dd9df18792cd13b25a54406ef60e3b32ac358272/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fraw-dylib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fraw-dylib.md?ref=dd9df18792cd13b25a54406ef60e3b32ac358272", "patch": "@@ -1,34 +0,0 @@\n-# `raw_dylib`\n-\n-The tracking issue for this feature is: [#58713]\n-\n-[#58713]: https://github.com/rust-lang/rust/issues/58713\n-\n-------------------------\n-\n-The `raw_dylib` feature allows you to link against the implementations of functions in an `extern`\n-block without, on Windows, linking against an import library.\n-\n-```rust,ignore (partial-example)\n-#![feature(raw_dylib)]\n-\n-#[link(name=\"library\", kind=\"raw-dylib\")]\n-extern {\n-    fn extern_function(x: i32);\n-}\n-\n-fn main() {\n-    unsafe {\n-        extern_function(14);\n-    }\n-}\n-```\n-\n-## Limitations\n-\n-This feature is unstable for the `x86` architecture, and stable for all other architectures.\n-\n-This feature is only supported on Windows.\n-\n-On the `x86` architecture, this feature supports only the `cdecl`, `stdcall`, `system`, `fastcall`, and\n-`vectorcall` calling conventions."}, {"sha": "c94968b4817cbea0ecc52d857efb7fc4e567a77d", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -811,7 +811,9 @@ impl<'src> Classifier<'src> {\n                 | LiteralKind::Str { .. }\n                 | LiteralKind::ByteStr { .. }\n                 | LiteralKind::RawStr { .. }\n-                | LiteralKind::RawByteStr { .. } => Class::String,\n+                | LiteralKind::RawByteStr { .. }\n+                | LiteralKind::CStr { .. }\n+                | LiteralKind::RawCStr { .. } => Class::String,\n                 // Number literals.\n                 LiteralKind::Float { .. } | LiteralKind::Int { .. } => Class::Number,\n             },"}, {"sha": "a3be6dd52690963377ca1a2abea92e9760b296fa", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -391,12 +391,14 @@ fn get_index_type_id(clean_type: &clean::Type) -> Option<RenderTypeId> {\n         clean::BorrowedRef { ref type_, .. } | clean::RawPointer(_, ref type_) => {\n             get_index_type_id(type_)\n         }\n+        // The type parameters are converted to generics in `add_generics_and_bounds_as_types`\n+        clean::Slice(_) => Some(RenderTypeId::Primitive(clean::PrimitiveType::Slice)),\n+        clean::Array(_, _) => Some(RenderTypeId::Primitive(clean::PrimitiveType::Array)),\n+        // Not supported yet\n         clean::BareFunction(_)\n         | clean::Generic(_)\n         | clean::ImplTrait(_)\n         | clean::Tuple(_)\n-        | clean::Slice(_)\n-        | clean::Array(_, _)\n         | clean::QPath { .. }\n         | clean::Infer => None,\n     }\n@@ -563,6 +565,30 @@ fn add_generics_and_bounds_as_types<'tcx, 'a>(\n             }\n         }\n         insert_ty(res, arg.clone(), ty_generics);\n+    } else if let Type::Slice(ref ty) = *arg {\n+        let mut ty_generics = Vec::new();\n+        add_generics_and_bounds_as_types(\n+            self_,\n+            generics,\n+            &ty,\n+            tcx,\n+            recurse + 1,\n+            &mut ty_generics,\n+            cache,\n+        );\n+        insert_ty(res, arg.clone(), ty_generics);\n+    } else if let Type::Array(ref ty, _) = *arg {\n+        let mut ty_generics = Vec::new();\n+        add_generics_and_bounds_as_types(\n+            self_,\n+            generics,\n+            &ty,\n+            tcx,\n+            recurse + 1,\n+            &mut ty_generics,\n+            cache,\n+        );\n+        insert_ty(res, arg.clone(), ty_generics);\n     } else {\n         // This is not a type parameter. So for example if we have `T, U: Option<T>`, and we're\n         // looking at `Option`, we enter this \"else\" condition, otherwise if it's `T`, we don't."}, {"sha": "b6eb450d62be5d19a8c207332176fce7e984a380", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -156,23 +156,31 @@ pub fn main() {\n         }\n     }\n \n-    rustc_driver::install_ice_hook();\n+    rustc_driver::install_ice_hook(\n+        \"https://github.com/rust-lang/rust/issues/new\\\n+    ?labels=C-bug%2C+I-ICE%2C+T-rustdoc&template=ice.md\",\n+        |_| (),\n+    );\n \n-    // When using CI artifacts (with `download_stage1 = true`), tracing is unconditionally built\n+    // When using CI artifacts with `download-rustc`, tracing is unconditionally built\n     // with `--features=static_max_level_info`, which disables almost all rustdoc logging. To avoid\n     // this, compile our own version of `tracing` that logs all levels.\n     // NOTE: this compiles both versions of tracing unconditionally, because\n     // - The compile time hit is not that bad, especially compared to rustdoc's incremental times, and\n-    // - Otherwise, there's no warning that logging is being ignored when `download_stage1 = true`.\n-    // NOTE: The reason this doesn't show double logging when `download_stage1 = false` and\n+    // - Otherwise, there's no warning that logging is being ignored when `download-rustc` is enabled\n+    // NOTE: The reason this doesn't show double logging when `download-rustc = false` and\n     // `debug_logging = true` is because all rustc logging goes to its version of tracing (the one\n     // in the sysroot), and all of rustdoc's logging goes to its version (the one in Cargo.toml).\n     init_logging();\n     rustc_driver::init_env_logger(\"RUSTDOC_LOG\");\n \n     let exit_code = rustc_driver::catch_with_exit_code(|| match get_args() {\n         Some(args) => main_args(&args),\n-        _ => Err(ErrorGuaranteed::unchecked_claim_error_was_emitted()),\n+        _ =>\n+        {\n+            #[allow(deprecated)]\n+            Err(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n+        }\n     });\n     process::exit(exit_code);\n }\n@@ -725,6 +733,7 @@ fn main_args(at_args: &[String]) -> MainResult {\n             return if code == 0 {\n                 Ok(())\n             } else {\n+                #[allow(deprecated)]\n                 Err(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n             };\n         }"}, {"sha": "569b648b5831ae8a515e90c80843a5287c3304ef", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1 +1 @@\n-Subproject commit ac84010322a31f4a581dafe26258aa4ac8dea9cd\n+Subproject commit 569b648b5831ae8a515e90c80843a5287c3304ef"}, {"sha": "0bc2f49f5e9b551edb1640ffbcc86a9f1de3483e", "filename": "src/tools/clippy/.github/workflows/remark.yml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fremark.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fremark.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fremark.yml?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -36,6 +36,12 @@ jobs:\n     - name: Check *.md files\n       run: git ls-files -z '*.md' | xargs -0 -n 1 -I {} ./node_modules/.bin/remark {} -u lint -f > /dev/null\n \n+    - name: Linkcheck book\n+      run: |\n+        rustup toolchain install nightly --component rust-docs\n+        curl https://raw.githubusercontent.com/rust-lang/rust/master/src/tools/linkchecker/linkcheck.sh -o linkcheck.sh\n+        sh linkcheck.sh clippy --path ./book\n+        \n     - name: Build mdbook\n       run: mdbook build book\n "}, {"sha": "ebf5b58a586992f4852d51892bb4c9cdb104f163", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -44,7 +44,7 @@ Current stable, released 2023-04-20\n \n ### Enhancements\n \n-* [`arithmetic_side_effects`]: No longer lints, if safe constant values are used.\n+* [`arithmetic_side_effects`]: No longer lints if safe constant values are used.\n   [#10310](https://github.com/rust-lang/rust-clippy/pull/10310)\n * [`needless_lifetimes`]: Now works in local macros\n   [#10257](https://github.com/rust-lang/rust-clippy/pull/10257)\n@@ -60,39 +60,39 @@ Current stable, released 2023-04-20\n \n ### False Positive Fixes\n \n-* [`explicit_auto_deref`]: Now considers projections, when determining if auto deref is applicable\n+* [`explicit_auto_deref`]: Now considers projections when determining if auto deref is applicable\n   [#10386](https://github.com/rust-lang/rust-clippy/pull/10386)\n-* [`manual_let_else`]: Now considers side effects of branches, before linting \n+* [`manual_let_else`]: Now considers side effects of branches before linting\n   [#10336](https://github.com/rust-lang/rust-clippy/pull/10336)\n * [`uninlined_format_args`]: No longer lints for arguments with generic parameters\n   [#10343](https://github.com/rust-lang/rust-clippy/pull/10343)\n-* [`needless_lifetimes`]: No longer lints signatures in macros, if the lifetime is a metavariable\n+* [`needless_lifetimes`]: No longer lints signatures in macros if the lifetime is a metavariable\n   [#10380](https://github.com/rust-lang/rust-clippy/pull/10380)\n-* [`len_without_is_empty`]: No longer lints, if `len` as a non-default signature\n+* [`len_without_is_empty`]: No longer lints if `len` as a non-default signature\n   [#10255](https://github.com/rust-lang/rust-clippy/pull/10255)\n-* [`unusual_byte_groupings`]: Relaxed the required restrictions for specific sizes, to reduce false\n+* [`unusual_byte_groupings`]: Relaxed the required restrictions for specific sizes to reduce false\n   positives\n   [#10353](https://github.com/rust-lang/rust-clippy/pull/10353)\n * [`manual_let_else`]: No longer lints `if-else` blocks if they can divergent\n   [#10332](https://github.com/rust-lang/rust-clippy/pull/10332)\n * [`expect_used`], [`unwrap_used`], [`dbg_macro`], [`print_stdout`], [`print_stderr`]: No longer lint\n-  in test functions, if `allow-expect-in-tests` is set\n+  in test functions if `allow-expect-in-tests` is set\n   [#10391](https://github.com/rust-lang/rust-clippy/pull/10391)\n * [`unnecessary_safety_comment`]: No longer lints code inside macros\n   [#10106](https://github.com/rust-lang/rust-clippy/pull/10106)\n-* [`never_loop`]: No longer lints, for statements following break statements for outer blocks.\n+* [`never_loop`]: No longer lints statements following break statements for outer blocks.\n   [#10311](https://github.com/rust-lang/rust-clippy/pull/10311)\n \n ### Suggestion Fixes/Improvements\n \n-* [`box_default`]: The suggestion now includes the type for trait objects, when needed\n+* [`box_default`]: The suggestion now includes the type for trait objects when needed\n   [#10382](https://github.com/rust-lang/rust-clippy/pull/10382)\n * [`cast_possible_truncation`]: Now suggests using `try_from` or allowing the lint\n   [#10038](https://github.com/rust-lang/rust-clippy/pull/10038)\n * [`invalid_regex`]: Regex errors for non-literals or regular strings containing escape sequences will\n   now show the complete error\n   [#10231](https://github.com/rust-lang/rust-clippy/pull/10231)\n-* [`transmutes_expressible_as_ptr_casts`]: The suggestion now works, if the base type is borrowed\n+* [`transmutes_expressible_as_ptr_casts`]: The suggestion now works if the base type is borrowed\n   [#10193](https://github.com/rust-lang/rust-clippy/pull/10193)\n * [`needless_return`]: Now removes all semicolons on the same line\n   [#10187](https://github.com/rust-lang/rust-clippy/pull/10187)\n@@ -113,7 +113,7 @@ Current stable, released 2023-04-20\n \n ### ICE Fixes\n \n-* [`needless_pass_by_value`]: Fixed an ICE, caused by how late bounds were handled\n+* [`needless_pass_by_value`]: Fixed an ICE caused by how late bounds were handled\n   [#10328](https://github.com/rust-lang/rust-clippy/pull/10328)\n * [`needless_borrow`]: No longer panics on ambiguous projections\n   [#10403](https://github.com/rust-lang/rust-clippy/pull/10403)\n@@ -4582,6 +4582,7 @@ Released 2018-09-13\n [`debug_assert_with_mut_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#debug_assert_with_mut_call\n [`decimal_literal_representation`]: https://rust-lang.github.io/rust-clippy/master/index.html#decimal_literal_representation\n [`declare_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#declare_interior_mutable_const\n+[`default_constructed_unit_structs`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_constructed_unit_structs\n [`default_instead_of_iter_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_instead_of_iter_empty\n [`default_numeric_fallback`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_numeric_fallback\n [`default_trait_access`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_trait_access\n@@ -4797,6 +4798,7 @@ Released 2018-09-13\n [`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n [`manual_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_unwrap_or\n+[`manual_while_let_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_while_let_some\n [`many_single_char_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#many_single_char_names\n [`map_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_clone\n [`map_collect_result_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_collect_result_unit\n@@ -4864,6 +4866,7 @@ Released 2018-09-13\n [`needless_arbitrary_self_type`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_arbitrary_self_type\n [`needless_bitwise_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_bitwise_bool\n [`needless_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_bool\n+[`needless_bool_assign`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_bool_assign\n [`needless_borrow`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrow\n [`needless_borrowed_reference`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrowed_reference\n [`needless_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_collect"}, {"sha": "3c72bb62ed19e75625b871ac88893d66024835a4", "filename": "src/tools/clippy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCargo.toml?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.1.70\"\n+version = \"0.1.71\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\""}, {"sha": "6745e15c0065703166bfff84b42492bfc3f2d694", "filename": "src/tools/clippy/README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FREADME.md?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -91,7 +91,8 @@ cargo clippy\n \n #### Automatically applying Clippy suggestions\n \n-Clippy can automatically apply some lint suggestions, just like the compiler.\n+Clippy can automatically apply some lint suggestions, just like the compiler. Note that `--fix` implies\n+`--all-targets`, so it can fix as much code as it can.\n \n ```terminal\n cargo clippy --fix"}, {"sha": "621fc20972ea11b46ffad9ba8378cd24e023acbe", "filename": "src/tools/clippy/book/src/development/lint_passes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Fdevelopment%2Flint_passes.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Fdevelopment%2Flint_passes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Fdevelopment%2Flint_passes.md?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -50,7 +50,7 @@ questions already, but the parser is okay with it. This is what we\n mean when we say `EarlyLintPass` deals with only syntax on the AST level.\n \n Alternatively, think of the `foo_functions` lint we mentioned in\n-define new lints chapter.\n+define new lints <!-- FIXME: add link --> chapter.\n \n We want the `foo_functions` lint to detect functions with `foo` as their name.\n Writing a lint that only checks for the name of a function means that we only"}, {"sha": "285488cec55c2db4f5a47b0a2218a4b2059d9532", "filename": "src/tools/clippy/book/src/development/proposals/syntax-tree-patterns.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Fdevelopment%2Fproposals%2Fsyntax-tree-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Fdevelopment%2Fproposals%2Fsyntax-tree-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Fdevelopment%2Fproposals%2Fsyntax-tree-patterns.md?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -139,7 +139,7 @@ whether the pattern matched.\n \n ## Pattern syntax\n \n-The following examples demonstate the pattern syntax:\n+The following examples demonstrate the pattern syntax:\n \n \n #### Any (`_`)"}, {"sha": "5646c9b15208f268219e05063a480a3f33be368c", "filename": "src/tools/clippy/book/src/lint_configuration.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Flint_configuration.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Flint_configuration.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Flint_configuration.md?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -13,6 +13,8 @@ Please use that command to update the file and do not edit it by hand.\n | [msrv](#msrv) | `None` |\n | [cognitive-complexity-threshold](#cognitive-complexity-threshold) | `25` |\n | [disallowed-names](#disallowed-names) | `[\"foo\", \"baz\", \"quux\"]` |\n+| [semicolon-inside-block-ignore-singleline](#semicolon-inside-block-ignore-singleline) | `false` |\n+| [semicolon-outside-block-ignore-multiline](#semicolon-outside-block-ignore-multiline) | `false` |\n | [doc-valid-idents](#doc-valid-idents) | `[\"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"DirectX\", \"ECMAScript\", \"GPLv2\", \"GPLv3\", \"GitHub\", \"GitLab\", \"IPv4\", \"IPv6\", \"ClojureScript\", \"CoffeeScript\", \"JavaScript\", \"PureScript\", \"TypeScript\", \"NaN\", \"NaNs\", \"OAuth\", \"GraphQL\", \"OCaml\", \"OpenGL\", \"OpenMP\", \"OpenSSH\", \"OpenSSL\", \"OpenStreetMap\", \"OpenDNS\", \"WebGL\", \"TensorFlow\", \"TrueType\", \"iOS\", \"macOS\", \"FreeBSD\", \"TeX\", \"LaTeX\", \"BibTeX\", \"BibLaTeX\", \"MinGW\", \"CamelCase\"]` |\n | [too-many-arguments-threshold](#too-many-arguments-threshold) | `7` |\n | [type-complexity-threshold](#type-complexity-threshold) | `250` |\n@@ -203,6 +205,22 @@ default configuration of Clippy. By default, any configuration will replace the\n * [disallowed_names](https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_names)\n \n \n+### semicolon-inside-block-ignore-singleline\n+Whether to lint only if it's multiline.\n+\n+**Default Value:** `false` (`bool`)\n+\n+* [semicolon_inside_block](https://rust-lang.github.io/rust-clippy/master/index.html#semicolon_inside_block)\n+\n+\n+### semicolon-outside-block-ignore-multiline\n+Whether to lint only if it's singleline.\n+\n+**Default Value:** `false` (`bool`)\n+\n+* [semicolon_outside_block](https://rust-lang.github.io/rust-clippy/master/index.html#semicolon_outside_block)\n+\n+\n ### doc-valid-idents\n The list of words this lint should not consider as identifiers needing ticks. The value\n `\"..\"` can be used as part of the list to indicate, that the configured values should be appended to the"}, {"sha": "36448e4cccfa4650730adbc83136f0a9e1e7c9b4", "filename": "src/tools/clippy/book/src/usage.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Fusage.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Fusage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Fusage.md?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -111,7 +111,8 @@ fn main() {\n \n ### Automatically applying Clippy suggestions\n \n-Clippy can automatically apply some lint suggestions, just like the compiler.\n+Clippy can automatically apply some lint suggestions, just like the compiler. Note that `--fix` implies\n+`--all-targets`, so it can fix as much code as it can.\n \n ```terminal\n cargo clippy --fix"}, {"sha": "a0d57f5ab483fc37737f0127ebde954e47f2f5d8", "filename": "src/tools/clippy/clippy_dev/src/dogfood.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fdogfood.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,4 +1,4 @@\n-use crate::clippy_project_root;\n+use crate::{clippy_project_root, exit_if_err};\n use std::process::Command;\n \n /// # Panics\n@@ -10,7 +10,7 @@ pub fn dogfood(fix: bool, allow_dirty: bool, allow_staged: bool) {\n     cmd.current_dir(clippy_project_root())\n         .args([\"test\", \"--test\", \"dogfood\"])\n         .args([\"--features\", \"internal\"])\n-        .args([\"--\", \"dogfood_clippy\"]);\n+        .args([\"--\", \"dogfood_clippy\", \"--nocapture\"]);\n \n     let mut dogfood_args = Vec::new();\n     if fix {\n@@ -27,7 +27,5 @@ pub fn dogfood(fix: bool, allow_dirty: bool, allow_staged: bool) {\n \n     cmd.env(\"__CLIPPY_DOGFOOD_ARGS\", dogfood_args.join(\" \"));\n \n-    let output = cmd.output().expect(\"failed to run command\");\n-\n-    println!(\"{}\", String::from_utf8_lossy(&output.stdout));\n+    exit_if_err(cmd.status());\n }"}, {"sha": "56a269288c0536f030ca7f6fd99c386db4a9bcd4", "filename": "src/tools/clippy/clippy_dev/src/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -10,7 +10,9 @@\n extern crate rustc_driver;\n extern crate rustc_lexer;\n \n+use std::io;\n use std::path::PathBuf;\n+use std::process::{self, ExitStatus};\n \n pub mod bless;\n pub mod dogfood;\n@@ -58,3 +60,14 @@ pub fn clippy_project_root() -> PathBuf {\n     }\n     panic!(\"error: Can't determine root of project. Please run inside a Clippy working dir.\");\n }\n+\n+pub fn exit_if_err(status: io::Result<ExitStatus>) {\n+    match status.expect(\"failed to run command\").code() {\n+        Some(0) => {},\n+        Some(n) => process::exit(n),\n+        None => {\n+            eprintln!(\"Killed by signal\");\n+            process::exit(1);\n+        },\n+    }\n+}"}, {"sha": "a19be1bca6c3d8bf996ae6576b3f29e1a4ac57f9", "filename": "src/tools/clippy/clippy_dev/src/lint.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flint.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,17 +1,6 @@\n-use crate::cargo_clippy_path;\n-use std::process::{self, Command, ExitStatus};\n-use std::{fs, io};\n-\n-fn exit_if_err(status: io::Result<ExitStatus>) {\n-    match status.expect(\"failed to run command\").code() {\n-        Some(0) => {},\n-        Some(n) => process::exit(n),\n-        None => {\n-            eprintln!(\"Killed by signal\");\n-            process::exit(1);\n-        },\n-    }\n-}\n+use crate::{cargo_clippy_path, exit_if_err};\n+use std::fs;\n+use std::process::{self, Command};\n \n pub fn run<'a>(path: &str, args: impl Iterator<Item = &'a String>) {\n     let is_file = match fs::metadata(path) {"}, {"sha": "7213c9dfede993bae6ee40b48ce845a0db3bb708", "filename": "src/tools/clippy/clippy_dev/src/update_lints.rs", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -36,60 +36,6 @@ pub enum UpdateMode {\n pub fn update(update_mode: UpdateMode) {\n     let (lints, deprecated_lints, renamed_lints) = gather_all();\n     generate_lint_files(update_mode, &lints, &deprecated_lints, &renamed_lints);\n-    remove_old_files(update_mode);\n-}\n-\n-/// Remove files no longer needed after <https://github.com/rust-lang/rust-clippy/pull/9541>\n-/// that may be reintroduced unintentionally\n-///\n-/// FIXME: This is a temporary measure that should be removed when there are no more PRs that\n-/// include the stray files\n-fn remove_old_files(update_mode: UpdateMode) {\n-    let mut failed = false;\n-    let mut remove_file = |path: &Path| match update_mode {\n-        UpdateMode::Check => {\n-            if path.exists() {\n-                failed = true;\n-                println!(\"unexpected file: {}\", path.display());\n-            }\n-        },\n-        UpdateMode::Change => {\n-            if fs::remove_file(path).is_ok() {\n-                println!(\"removed file: {}\", path.display());\n-            }\n-        },\n-    };\n-\n-    let files = [\n-        \"clippy_lints/src/lib.register_all.rs\",\n-        \"clippy_lints/src/lib.register_cargo.rs\",\n-        \"clippy_lints/src/lib.register_complexity.rs\",\n-        \"clippy_lints/src/lib.register_correctness.rs\",\n-        \"clippy_lints/src/lib.register_internal.rs\",\n-        \"clippy_lints/src/lib.register_lints.rs\",\n-        \"clippy_lints/src/lib.register_nursery.rs\",\n-        \"clippy_lints/src/lib.register_pedantic.rs\",\n-        \"clippy_lints/src/lib.register_perf.rs\",\n-        \"clippy_lints/src/lib.register_restriction.rs\",\n-        \"clippy_lints/src/lib.register_style.rs\",\n-        \"clippy_lints/src/lib.register_suspicious.rs\",\n-        \"src/docs.rs\",\n-    ];\n-\n-    for file in files {\n-        remove_file(Path::new(file));\n-    }\n-\n-    if let Ok(docs_dir) = fs::read_dir(\"src/docs\") {\n-        for doc_file in docs_dir {\n-            let path = doc_file.unwrap().path();\n-            remove_file(&path);\n-        }\n-    }\n-\n-    if failed {\n-        exit_with_failure();\n-    }\n }\n \n fn generate_lint_files("}, {"sha": "37e1e6a742f60eae6395d6155e1c31274c08a3f6", "filename": "src/tools/clippy/clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_lints\"\n-version = \"0.1.70\"\n+version = \"0.1.71\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\""}, {"sha": "add73d0aeeed38053b76275b1226e1b6791235e2", "filename": "src/tools/clippy/clippy_lints/src/allow_attributes.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fallow_attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fallow_attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fallow_attributes.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -2,7 +2,8 @@ use ast::AttrStyle;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use rustc_ast as ast;\n use rustc_errors::Applicability;\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -51,6 +52,7 @@ impl LateLintPass<'_> for AllowAttribute {\n     // Separate each crate's features.\n     fn check_attribute(&mut self, cx: &LateContext<'_>, attr: &ast::Attribute) {\n         if_chain! {\n+            if !in_external_macro(cx.sess(), attr.span);\n             if cx.tcx.features().lint_reasons;\n             if let AttrStyle::Outer = attr.style;\n             if let Some(ident) = attr.ident();"}, {"sha": "cfeb75eed3bb99c08abef65c8e7e9f2f6faea4d3", "filename": "src/tools/clippy/clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -638,7 +638,7 @@ declare_clippy_lint! {\n     #[clippy::version = \"1.66.0\"]\n     pub AS_PTR_CAST_MUT,\n     nursery,\n-    \"casting the result of the `&self`-taking `as_ptr` to a mutabe pointer\"\n+    \"casting the result of the `&self`-taking `as_ptr` to a mutable pointer\"\n }\n \n declare_clippy_lint! {"}, {"sha": "804ae841100a5088459a088b97a9aed0d19cc13a", "filename": "src/tools/clippy/clippy_lints/src/casts/unnecessary_cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -141,9 +141,9 @@ fn lint_unnecessary_cast(\n \n fn get_numeric_literal<'e>(expr: &'e Expr<'e>) -> Option<&'e Lit> {\n     match expr.kind {\n-        ExprKind::Lit(ref lit) => Some(lit),\n+        ExprKind::Lit(lit) => Some(lit),\n         ExprKind::Unary(UnOp::Neg, e) => {\n-            if let ExprKind::Lit(ref lit) = e.kind {\n+            if let ExprKind::Lit(lit) = e.kind {\n                 Some(lit)\n             } else {\n                 None"}, {"sha": "1c321f46e2da4fcd8d77bd82f9020b9f17538a14", "filename": "src/tools/clippy/clippy_lints/src/copies.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -591,7 +591,7 @@ fn lint_same_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>], ignored_ty_ids: &De\n         conds,\n         |e| hash_expr(cx, e),\n         |lhs, rhs| {\n-            // Ignore eq_expr side effects iff one of the expressin kind is a method call\n+            // Ignore eq_expr side effects iff one of the expression kind is a method call\n             // and the caller is not a mutable, including inner mutable type.\n             if let ExprKind::MethodCall(_, caller, _, _) = lhs.kind {\n                 if method_caller_is_mutable(cx, caller, ignored_ty_ids) {"}, {"sha": "79d0f6f3607932225a93a5ca8d7e8fd745b47727", "filename": "src/tools/clippy/clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -105,6 +105,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::dbg_macro::DBG_MACRO_INFO,\n     crate::default::DEFAULT_TRAIT_ACCESS_INFO,\n     crate::default::FIELD_REASSIGN_WITH_DEFAULT_INFO,\n+    crate::default_constructed_unit_structs::DEFAULT_CONSTRUCTED_UNIT_STRUCTS_INFO,\n     crate::default_instead_of_iter_empty::DEFAULT_INSTEAD_OF_ITER_EMPTY_INFO,\n     crate::default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK_INFO,\n     crate::default_union_representation::DEFAULT_UNION_REPRESENTATION_INFO,\n@@ -249,6 +250,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::loops::MANUAL_FIND_INFO,\n     crate::loops::MANUAL_FLATTEN_INFO,\n     crate::loops::MANUAL_MEMCPY_INFO,\n+    crate::loops::MANUAL_WHILE_LET_SOME_INFO,\n     crate::loops::MISSING_SPIN_LOOP_INFO,\n     crate::loops::MUT_RANGE_BOUND_INFO,\n     crate::loops::NEEDLESS_RANGE_LOOP_INFO,\n@@ -445,6 +447,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE_INFO,\n     crate::needless_bool::BOOL_COMPARISON_INFO,\n     crate::needless_bool::NEEDLESS_BOOL_INFO,\n+    crate::needless_bool::NEEDLESS_BOOL_ASSIGN_INFO,\n     crate::needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE_INFO,\n     crate::needless_continue::NEEDLESS_CONTINUE_INFO,\n     crate::needless_for_each::NEEDLESS_FOR_EACH_INFO,"}, {"sha": "e529d81a7e9f38717e225d547b0b556d30c83667", "filename": "src/tools/clippy/clippy_lints/src/default_constructed_unit_structs.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_constructed_unit_structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_constructed_unit_structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_constructed_unit_structs.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,72 @@\n+use clippy_utils::{diagnostics::span_lint_and_sugg, is_from_proc_macro, match_def_path, paths};\n+use hir::{def::Res, ExprKind};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Check for construction on unit struct using `default`.\n+    ///\n+    /// ### Why is this bad?\n+    /// This adds code complexity and an unnecessary function call.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::marker::PhantomData;\n+    /// #[derive(Default)]\n+    /// struct S<T> {\n+    ///     _marker: PhantomData<T>\n+    /// }\n+    ///\n+    /// let _: S<i32> = S {\n+    ///     _marker: PhantomData::default()\n+    /// };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::marker::PhantomData;\n+    /// struct S<T> {\n+    ///     _marker: PhantomData<T>\n+    /// }\n+    ///\n+    /// let _: S<i32> = S {\n+    ///     _marker: PhantomData\n+    /// };\n+    /// ```\n+    #[clippy::version = \"1.71.0\"]\n+    pub DEFAULT_CONSTRUCTED_UNIT_STRUCTS,\n+    complexity,\n+    \"unit structs can be contructed without calling `default`\"\n+}\n+declare_lint_pass!(DefaultConstructedUnitStructs => [DEFAULT_CONSTRUCTED_UNIT_STRUCTS]);\n+\n+impl LateLintPass<'_> for DefaultConstructedUnitStructs {\n+    fn check_expr<'tcx>(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n+        if_chain!(\n+            // make sure we have a call to `Default::default`\n+            if let hir::ExprKind::Call(fn_expr, &[]) = expr.kind;\n+            if let ExprKind::Path(ref qpath@ hir::QPath::TypeRelative(_,_)) = fn_expr.kind;\n+            if let Res::Def(_, def_id) = cx.qpath_res(qpath, fn_expr.hir_id);\n+            if match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n+            // make sure we have a struct with no fields (unit struct)\n+            if let ty::Adt(def, ..) = cx.typeck_results().expr_ty(expr).kind();\n+            if def.is_struct();\n+            if let var @ ty::VariantDef { ctor: Some((hir::def::CtorKind::Const, _)), .. } = def.non_enum_variant();\n+            if !var.is_field_list_non_exhaustive() && !is_from_proc_macro(cx, expr);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    DEFAULT_CONSTRUCTED_UNIT_STRUCTS,\n+                    expr.span.with_lo(qpath.qself_span().hi()),\n+                    \"use of `default` to create a unit struct\",\n+                    \"remove this call to `default`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                )\n+            }\n+        );\n+    }\n+}"}, {"sha": "a51a8ee09f6e562f4ec255fab0bc877f610bb9bf", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -92,10 +92,8 @@ impl<'tcx> LateLintPass<'tcx> for BoxedLocal {\n                     if trait_item.id.owner_id.def_id == fn_def_id {\n                         // be sure we have `self` parameter in this function\n                         if trait_item.kind == (AssocItemKind::Fn { has_self: true }) {\n-                            trait_self_ty = Some(\n-                                TraitRef::identity(cx.tcx, trait_item.id.owner_id.to_def_id())\n-                                    .self_ty(),\n-                            );\n+                            trait_self_ty =\n+                                Some(TraitRef::identity(cx.tcx, trait_item.id.owner_id.to_def_id()).self_ty());\n                         }\n                     }\n                 }"}, {"sha": "93bf50fd5e79547469894c380a4e619531934aee", "filename": "src/tools/clippy/clippy_lints/src/float_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -66,7 +66,7 @@ impl<'tcx> LateLintPass<'tcx> for FloatLiteral {\n         let ty = cx.typeck_results().expr_ty(expr);\n         if_chain! {\n             if let ty::Float(fty) = *ty.kind();\n-            if let hir::ExprKind::Lit(ref lit) = expr.kind;\n+            if let hir::ExprKind::Lit(lit) = expr.kind;\n             if let LitKind::Float(sym, lit_float_ty) = lit.node;\n             then {\n                 let sym_str = sym.as_str();"}, {"sha": "a1a2c398a8a0262eecb1f114d019bf0ae760b96c", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -2,9 +2,10 @@ use clippy_utils::consts::{\n     constant, constant_simple, Constant,\n     Constant::{Int, F32, F64},\n };\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher;\n-use clippy_utils::{eq_expr_value, get_parent_expr, in_constant, numeric_literal, peel_blocks, sugg};\n+use clippy_utils::{\n+    diagnostics::span_lint_and_sugg, eq_expr_value, get_parent_expr, higher, in_constant, is_no_std_crate,\n+    numeric_literal, peel_blocks, sugg,\n+};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, UnOp};\n@@ -677,7 +678,7 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             {\n                 let mut proposal = format!(\"{}.to_degrees()\", Sugg::hir(cx, mul_lhs, \"..\").maybe_par());\n                 if_chain! {\n-                    if let ExprKind::Lit(ref literal) = mul_lhs.kind;\n+                    if let ExprKind::Lit(literal) = mul_lhs.kind;\n                     if let ast::LitKind::Float(ref value, float_type) = literal.node;\n                     if float_type == ast::LitFloatType::Unsuffixed;\n                     then {\n@@ -703,7 +704,7 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             {\n                 let mut proposal = format!(\"{}.to_radians()\", Sugg::hir(cx, mul_lhs, \"..\").maybe_par());\n                 if_chain! {\n-                    if let ExprKind::Lit(ref literal) = mul_lhs.kind;\n+                    if let ExprKind::Lit(literal) = mul_lhs.kind;\n                     if let ast::LitKind::Float(ref value, float_type) = literal.node;\n                     if float_type == ast::LitFloatType::Unsuffixed;\n                     then {\n@@ -730,15 +731,15 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        // All of these operations are currently not const.\n+        // All of these operations are currently not const and are in std.\n         if in_constant(cx, expr.hir_id) {\n             return;\n         }\n \n         if let ExprKind::MethodCall(path, receiver, args, _) = &expr.kind {\n             let recv_ty = cx.typeck_results().expr_ty(receiver);\n \n-            if recv_ty.is_floating_point() {\n+            if recv_ty.is_floating_point() && !is_no_std_crate(cx) {\n                 match path.ident.name.as_str() {\n                     \"ln\" => check_ln1p(cx, expr, receiver),\n                     \"log\" => check_log_base(cx, expr, receiver, args),\n@@ -749,10 +750,12 @@ impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n                 }\n             }\n         } else {\n-            check_expm1(cx, expr);\n-            check_mul_add(cx, expr);\n-            check_custom_abs(cx, expr);\n-            check_log_division(cx, expr);\n+            if !is_no_std_crate(cx) {\n+                check_expm1(cx, expr);\n+                check_mul_add(cx, expr);\n+                check_custom_abs(cx, expr);\n+                check_log_division(cx, expr);\n+            }\n             check_radians(cx, expr);\n         }\n     }"}, {"sha": "10ce2a0f0c7ecd3ed24ed5b9b6749186b33726ec", "filename": "src/tools/clippy/clippy_lints/src/from_over_into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -94,7 +94,7 @@ impl<'tcx> LateLintPass<'tcx> for FromOverInto {\n                         );\n                     }\n \n-                    let message = format!(\"replace the `Into` implentation with `From<{}>`\", middle_trait_ref.self_ty());\n+                    let message = format!(\"replace the `Into` implementation with `From<{}>`\", middle_trait_ref.self_ty());\n                     if let Some(suggestions) = convert_to_from(cx, into_trait_seg, target_ty, self_ty, impl_item_ref) {\n                         diag.multipart_suggestion(message, suggestions, Applicability::MachineApplicable);\n                     } else {"}, {"sha": "b244b91331436429a365c474653a303a37cd2454", "filename": "src/tools/clippy/clippy_lints/src/functions/misnamed_getters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmisnamed_getters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmisnamed_getters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmisnamed_getters.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -40,7 +40,7 @@ pub fn check_fn(cx: &LateContext<'_>, kind: FnKind<'_>, decl: &FnDecl<'_>, body:\n     };\n \n     // Body must be &(mut) <self_data>.name\n-    // self_data is not neccessarilly self, to also lint sub-getters, etc\u2026\n+    // self_data is not necessarily self, to also lint sub-getters, etc\u2026\n \n     let block_expr = if_chain! {\n         if let ExprKind::Block(block,_) = body.value.kind;"}, {"sha": "ee10334c67f139ddfb2053f689531e5f2da6acd2", "filename": "src/tools/clippy/clippy_lints/src/functions/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -252,6 +252,11 @@ declare_clippy_lint! {\n     /// A `Result` is at least as large as the `Err`-variant. While we\n     /// expect that variant to be seldomly used, the compiler needs to reserve\n     /// and move that much memory every single time.\n+    /// Furthermore, errors are often simply passed up the call-stack, making\n+    /// use of the `?`-operator and its type-conversion mechanics. If the\n+    /// `Err`-variant further up the call-stack stores the `Err`-variant in\n+    /// question (as library code often does), it itself needs to be at least\n+    /// as large, propagating the problem.\n     ///\n     /// ### Known problems\n     /// The size determined by Clippy is platform-dependent.\n@@ -330,7 +335,7 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Lints when `impl Trait` is being used in a function's paremeters.\n+    /// Lints when `impl Trait` is being used in a function's parameters.\n     /// ### Why is this bad?\n     /// Turbofish syntax (`::<>`) cannot be used when `impl Trait` is being used, making `impl Trait` less powerful. Readability may also be a factor.\n     ///"}, {"sha": "012aa5a1d1daf862b281d86d1c8f581ec0d52422", "filename": "src/tools/clippy/clippy_lints/src/implicit_saturating_add.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_add.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -60,7 +60,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingAdd {\n             if expr1.span.ctxt() == ctxt;\n             if clippy_utils::SpanlessEq::new(cx).eq_expr(l, target);\n             if BinOpKind::Add == op1.node;\n-            if let ExprKind::Lit(ref lit) = value.kind;\n+            if let ExprKind::Lit(lit) = value.kind;\n             if let LitKind::Int(1, LitIntType::Unsuffixed) = lit.node;\n             if block.expr.is_none();\n             then {"}, {"sha": "1e99b6faa6ca5025fde771cf9342d68b05dafe13", "filename": "src/tools/clippy/clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -87,7 +87,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                 // Get the variable name\n                 let var_name = ares_path.segments[0].ident.name.as_str();\n                 match cond_num_val.kind {\n-                    ExprKind::Lit(ref cond_lit) => {\n+                    ExprKind::Lit(cond_lit) => {\n                         // Check if the constant is zero\n                         if let LitKind::Int(0, _) = cond_lit.node {\n                             if cx.typeck_results().expr_ty(cond_left).is_signed() {"}, {"sha": "924a361c0f6a8801bad390ef18906ca6482e582b", "filename": "src/tools/clippy/clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -170,7 +170,7 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n                         return;\n                     }\n                     // Index is a constant uint.\n-                    if let Some(..) = constant(cx, cx.typeck_results(), index) {\n+                    if constant(cx, cx.typeck_results(), index).is_some() {\n                         // Let rustc's `const_err` lint handle constant `usize` indexing on arrays.\n                         return;\n                     }"}, {"sha": "b992d689aa979107b37dfdd4c8a1b276c31f40ca", "filename": "src/tools/clippy/clippy_lints/src/items_after_test_module.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_test_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_test_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_test_module.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -64,20 +64,21 @@ impl LateLintPass<'_> for ItemsAfterTestModule {\n                 span_lint_and_help(cx, ITEMS_AFTER_TEST_MODULE, test_mod_span.unwrap().with_hi(item.span.hi()), \"items were found after the testing module\", None, \"move the items to before the testing module was defined\");\n             }};\n \n-            if matches!(item.kind, ItemKind::Mod(_)) {\n-                for attr in cx.tcx.get_attrs(item.owner_id.to_def_id(), sym::cfg) {\n-                    if_chain! {\n-                        if attr.has_name(sym::cfg);\n+            if let ItemKind::Mod(module) = item.kind && item.span.hi() == module.spans.inner_span.hi() {\n+\t\t\t// Check that it works the same way, the only I way I've found for #10713\n+\t\t\t\tfor attr in cx.tcx.get_attrs(item.owner_id.to_def_id(), sym::cfg) {\n+\t\t\t\t\tif_chain! {\n+\t\t\t\t\t\tif attr.has_name(sym::cfg);\n                         if let Some(mitems) = attr.meta_item_list();\n                         if let [mitem] = &*mitems;\n                         if mitem.has_name(sym::test);\n                         then {\n-                            was_test_mod_visited = true;\n+\t\t\t\t\t\t\twas_test_mod_visited = true;\n                             test_mod_span = Some(item.span);\n                         }\n                     }\n                 }\n-            }\n+\t\t\t}\n         }\n     }\n }"}, {"sha": "0ca31033b169b712d2ba524813f50196fc021210", "filename": "src/tools/clippy/clippy_lints/src/large_futures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_futures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_futures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_futures.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -11,7 +11,7 @@ declare_clippy_lint! {\n     /// It checks for the size of a `Future` created by `async fn` or `async {}`.\n     ///\n     /// ### Why is this bad?\n-    /// Due to the current [unideal implemention](https://github.com/rust-lang/rust/issues/69826) of `Generator`,\n+    /// Due to the current [unideal implementation](https://github.com/rust-lang/rust/issues/69826) of `Generator`,\n     /// large size of a `Future` may cause stack overflows.\n     ///\n     /// ### Example"}, {"sha": "17bd89efaee03e2b58d0e0c3063ed2974ea1177f", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -532,7 +532,7 @@ fn check_empty_expr(cx: &LateContext<'_>, span: Span, lit1: &Expr<'_>, lit2: &Ex\n }\n \n fn is_empty_string(expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Lit(ref lit) = expr.kind {\n+    if let ExprKind::Lit(lit) = expr.kind {\n         if let LitKind::Str(lit, _) = lit.node {\n             let lit = lit.as_str();\n             return lit.is_empty();"}, {"sha": "16772a9d5987b619321f2f13f351308b8dd633a8", "filename": "src/tools/clippy/clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -6,6 +6,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{BytePos, Span};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -205,8 +206,13 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                     LET_UNDERSCORE_UNTYPED,\n                     local.span,\n                     \"non-binding `let` without a type annotation\",\n-                    None,\n-                    \"consider adding a type annotation or removing the `let` keyword\",\n+                    Some(\n+\t\t\t\t\t\tSpan::new(local.pat.span.hi(),\n+\t\t\t\t\t\tlocal.pat.span.hi() + BytePos(1),\n+\t\t\t\t\t\tlocal.pat.span.ctxt(),\n+\t\t\t\t\t\tlocal.pat.span.parent()\n+\t\t\t\t\t)),\n+                    \"consider adding a type annotation\",\n                 );\n             }\n         }"}, {"sha": "3517842a01e7bb8104038977bb288ab8f0ceeb36", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -94,6 +94,7 @@ mod crate_in_macro_def;\n mod create_dir;\n mod dbg_macro;\n mod default;\n+mod default_constructed_unit_structs;\n mod default_instead_of_iter_empty;\n mod default_numeric_fallback;\n mod default_union_representation;\n@@ -933,7 +934,14 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(from_raw_with_void_ptr::FromRawWithVoidPtr));\n     store.register_late_pass(|_| Box::new(suspicious_xor_used_as_pow::ConfusingXorAndPow));\n     store.register_late_pass(move |_| Box::new(manual_is_ascii_check::ManualIsAsciiCheck::new(msrv())));\n-    store.register_late_pass(|_| Box::new(semicolon_block::SemicolonBlock));\n+    let semicolon_inside_block_ignore_singleline = conf.semicolon_inside_block_ignore_singleline;\n+    let semicolon_outside_block_ignore_multiline = conf.semicolon_outside_block_ignore_multiline;\n+    store.register_late_pass(move |_| {\n+        Box::new(semicolon_block::SemicolonBlock::new(\n+            semicolon_inside_block_ignore_singleline,\n+            semicolon_outside_block_ignore_multiline,\n+        ))\n+    });\n     store.register_late_pass(|_| Box::new(fn_null_check::FnNullCheck));\n     store.register_late_pass(|_| Box::new(permissions_set_readonly_false::PermissionsSetReadonlyFalse));\n     store.register_late_pass(|_| Box::new(size_of_ref::SizeOfRef));\n@@ -963,6 +971,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(manual_slice_size_calculation::ManualSliceSizeCalculation));\n     store.register_early_pass(|| Box::new(suspicious_doc_comments::SuspiciousDocComments));\n     store.register_late_pass(|_| Box::new(items_after_test_module::ItemsAfterTestModule));\n+    store.register_late_pass(|_| Box::new(default_constructed_unit_structs::DefaultConstructedUnitStructs));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "d4c3f76b864172d7eb54e5640e3ab5d365d84afe", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -15,7 +15,7 @@ use rustc_span::symbol::sym;\n use std::fmt::Display;\n use std::iter::Iterator;\n \n-/// Checks for for loops that sequentially copy items from one slice-like\n+/// Checks for `for` loops that sequentially copy items from one slice-like\n /// object to another.\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,"}, {"sha": "cb9c84be4c7a695fbd481f088cc218b4db4dece0", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_while_let_some.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_while_let_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_while_let_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_while_let_some.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,110 @@\n+use clippy_utils::{\n+    diagnostics::{multispan_sugg_with_applicability, span_lint_and_then},\n+    match_def_path, paths,\n+    source::snippet,\n+    SpanlessEq,\n+};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, Pat, Stmt, StmtKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_span::Span;\n+use std::borrow::Cow;\n+\n+use super::MANUAL_WHILE_LET_SOME;\n+\n+/// The kind of statement that the `pop()` call appeared in.\n+///\n+/// Depending on whether the value was assigned to a variable or not changes what pattern\n+/// we use for the suggestion.\n+#[derive(Copy, Clone)]\n+enum PopStmt<'hir> {\n+    /// `x.pop().unwrap()` was and assigned to a variable.\n+    /// The pattern of this local variable will be used and the local statement\n+    /// is deleted in the suggestion.\n+    Local(&'hir Pat<'hir>),\n+    /// `x.pop().unwrap()` appeared in an arbitrary expression and was not assigned to a variable.\n+    /// The suggestion will use some placeholder identifier and the `x.pop().unwrap()` expression\n+    /// is replaced with that identifier.\n+    Anonymous,\n+}\n+\n+fn report_lint(cx: &LateContext<'_>, pop_span: Span, pop_stmt_kind: PopStmt<'_>, loop_span: Span, receiver_span: Span) {\n+    span_lint_and_then(\n+        cx,\n+        MANUAL_WHILE_LET_SOME,\n+        pop_span,\n+        \"you seem to be trying to pop elements from a `Vec` in a loop\",\n+        |diag| {\n+            let (pat, pop_replacement) = match pop_stmt_kind {\n+                PopStmt::Local(pat) => (snippet(cx, pat.span, \"..\"), String::new()),\n+                PopStmt::Anonymous => (Cow::Borrowed(\"element\"), \"element\".into()),\n+            };\n+\n+            let loop_replacement = format!(\"while let Some({}) = {}.pop()\", pat, snippet(cx, receiver_span, \"..\"));\n+            multispan_sugg_with_applicability(\n+                diag,\n+                \"consider using a `while..let` loop\",\n+                Applicability::MachineApplicable,\n+                [(loop_span, loop_replacement), (pop_span, pop_replacement)],\n+            );\n+        },\n+    );\n+}\n+\n+fn match_method_call(cx: &LateContext<'_>, expr: &Expr<'_>, method: &[&str]) -> bool {\n+    if let ExprKind::MethodCall(..) = expr.kind\n+        && let Some(id) = cx.typeck_results().type_dependent_def_id(expr.hir_id)\n+    {\n+        match_def_path(cx, id, method)\n+    } else {\n+        false\n+    }\n+}\n+\n+fn is_vec_pop_unwrap(cx: &LateContext<'_>, expr: &Expr<'_>, is_empty_recv: &Expr<'_>) -> bool {\n+    if (match_method_call(cx, expr, &paths::OPTION_UNWRAP) || match_method_call(cx, expr, &paths::OPTION_EXPECT))\n+        && let ExprKind::MethodCall(_, unwrap_recv, ..) = expr.kind\n+        && match_method_call(cx, unwrap_recv, &paths::VEC_POP)\n+        && let ExprKind::MethodCall(_, pop_recv, ..) = unwrap_recv.kind\n+    {\n+        // make sure they're the same `Vec`\n+        SpanlessEq::new(cx).eq_expr(pop_recv, is_empty_recv)\n+    } else {\n+        false\n+    }\n+}\n+\n+fn check_local(cx: &LateContext<'_>, stmt: &Stmt<'_>, is_empty_recv: &Expr<'_>, loop_span: Span) {\n+    if let StmtKind::Local(local) = stmt.kind\n+        && let Some(init) = local.init\n+        && is_vec_pop_unwrap(cx, init, is_empty_recv)\n+    {\n+        report_lint(cx, stmt.span, PopStmt::Local(local.pat), loop_span, is_empty_recv.span);\n+    }\n+}\n+\n+fn check_call_arguments(cx: &LateContext<'_>, stmt: &Stmt<'_>, is_empty_recv: &Expr<'_>, loop_span: Span) {\n+    if let StmtKind::Semi(expr) | StmtKind::Expr(expr) = stmt.kind {\n+        if let ExprKind::MethodCall(.., args, _) | ExprKind::Call(_, args) = expr.kind {\n+            let offending_arg = args\n+                .iter()\n+                .find_map(|arg| is_vec_pop_unwrap(cx, arg, is_empty_recv).then_some(arg.span));\n+\n+            if let Some(offending_arg) = offending_arg {\n+                report_lint(cx, offending_arg, PopStmt::Anonymous, loop_span, is_empty_recv.span);\n+            }\n+        }\n+    }\n+}\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, full_cond: &'tcx Expr<'_>, body: &'tcx Expr<'_>, loop_span: Span) {\n+    if let ExprKind::Unary(UnOp::Not, cond) = full_cond.kind\n+        && let ExprKind::MethodCall(_, is_empty_recv, _, _) = cond.kind\n+        && match_method_call(cx, cond, &paths::VEC_IS_EMPTY)\n+        && let ExprKind::Block(body, _) = body.kind\n+        && let Some(stmt) = body.stmts.first()\n+    {\n+        check_local(cx, stmt, is_empty_recv, loop_span);\n+        check_call_arguments(cx, stmt, is_empty_recv, loop_span);\n+    }\n+}"}, {"sha": "f83ad388a742fc4d5916f4bc216de4d4b6c1f724", "filename": "src/tools/clippy/clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -7,6 +7,7 @@ mod iter_next_loop;\n mod manual_find;\n mod manual_flatten;\n mod manual_memcpy;\n+mod manual_while_let_some;\n mod missing_spin_loop;\n mod mut_range_bound;\n mod needless_range_loop;\n@@ -575,6 +576,36 @@ declare_clippy_lint! {\n     \"manual implementation of `Iterator::find`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Looks for loops that check for emptiness of a `Vec` in the condition and pop an element\n+    /// in the body as a separate operation.\n+    ///\n+    /// ### Why is this bad?\n+    /// Such loops can be written in a more idiomatic way by using a while-let loop and directly\n+    /// pattern matching on the return value of `Vec::pop()`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut numbers = vec![1, 2, 3, 4, 5];\n+    /// while !numbers.is_empty() {\n+    ///     let number = numbers.pop().unwrap();\n+    ///     // use `number`\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut numbers = vec![1, 2, 3, 4, 5];\n+    /// while let Some(number) = numbers.pop() {\n+    ///     // use `number`\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.70.0\"]\n+    pub MANUAL_WHILE_LET_SOME,\n+    style,\n+    \"checking for emptiness of a `Vec` in the loop condition and popping an element in the body\"\n+}\n+\n declare_lint_pass!(Loops => [\n     MANUAL_MEMCPY,\n     MANUAL_FLATTEN,\n@@ -594,6 +625,7 @@ declare_lint_pass!(Loops => [\n     SINGLE_ELEMENT_LOOP,\n     MISSING_SPIN_LOOP,\n     MANUAL_FIND,\n+    MANUAL_WHILE_LET_SOME\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Loops {\n@@ -640,9 +672,10 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n \n         while_let_on_iterator::check(cx, expr);\n \n-        if let Some(higher::While { condition, body }) = higher::While::hir(expr) {\n+        if let Some(higher::While { condition, body, span }) = higher::While::hir(expr) {\n             while_immutable_condition::check(cx, condition, body);\n             missing_spin_loop::check(cx, condition, body);\n+            manual_while_let_some::check(cx, condition, body, span);\n         }\n     }\n }"}, {"sha": "cb446567506af142031b0085a7ad7e7281818903", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -208,7 +208,7 @@ fn is_end_eq_array_len<'tcx>(\n     indexed_ty: Ty<'tcx>,\n ) -> bool {\n     if_chain! {\n-        if let ExprKind::Lit(ref lit) = end.kind;\n+        if let ExprKind::Lit(lit) = end.kind;\n         if let ast::LitKind::Int(end_int, _) = lit.node;\n         if let ty::Array(_, arr_len_const) = indexed_ty.kind();\n         if let Some(arr_len) = arr_len_const.try_eval_target_usize(cx.tcx, cx.param_env);"}, {"sha": "45ea5aab4c2a26c7369e40ec290ec79b6e852c5f", "filename": "src/tools/clippy/clippy_lints/src/manual_assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_assert.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualAssert {\n             };\n             let cond_sugg = sugg::Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability).maybe_par();\n             let sugg = format!(\"assert!({not}{cond_sugg}, {format_args_snip});\");\n-            // we show to the user the suggestion without the comments, but when applicating the fix, include the comments in the block\n+            // we show to the user the suggestion without the comments, but when applying the fix, include the comments in the block\n             span_lint_and_then(\n                 cx,\n                 MANUAL_ASSERT,"}, {"sha": "1247370b74a2f42b6d2f8e52531be0c2661190e8", "filename": "src/tools/clippy/clippy_lints/src/manual_let_else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_let_else.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -101,7 +101,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualLetElse {\n                 if source != MatchSource::Normal {\n                     return;\n                 }\n-                // Any other number than two arms doesn't (neccessarily)\n+                // Any other number than two arms doesn't (necessarily)\n                 // have a trivial mapping to let else.\n                 if arms.len() != 2 {\n                     return;"}, {"sha": "5259066eb713cc7b7350fef0cd0755c5750e6d8f", "filename": "src/tools/clippy/clippy_lints/src/manual_retain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_retain.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -46,7 +46,7 @@ declare_clippy_lint! {\n     #[clippy::version = \"1.64.0\"]\n     pub MANUAL_RETAIN,\n     perf,\n-    \"`retain()` is simpler and the same functionalitys\"\n+    \"`retain()` is simpler and the same functionalities\"\n }\n \n pub struct ManualRetain {"}, {"sha": "69105ff0d5c7acaa31c85c0461aae50c3491831e", "filename": "src/tools/clippy/clippy_lints/src/matches/match_bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -22,7 +22,7 @@ pub(crate) fn check(cx: &LateContext<'_>, scrutinee: &Expr<'_>, arms: &[Arm<'_>]\n                 if arms.len() == 2 {\n                     // no guards\n                     let exprs = if let PatKind::Lit(arm_bool) = arms[0].pat.kind {\n-                        if let ExprKind::Lit(ref lit) = arm_bool.kind {\n+                        if let ExprKind::Lit(lit) = arm_bool.kind {\n                             match lit.node {\n                                 LitKind::Bool(true) => Some((arms[0].body, arms[1].body)),\n                                 LitKind::Bool(false) => Some((arms[1].body, arms[0].body)),"}, {"sha": "a48f4c77f857fb5cd8119d9c5aea9d1958eca4e5", "filename": "src/tools/clippy/clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -284,6 +284,7 @@ impl<'a> NormalizedPat<'a> {\n                     LitKind::Str(sym, _) => Self::LitStr(sym),\n                     LitKind::ByteStr(ref bytes, _) => Self::LitBytes(bytes),\n                     LitKind::Byte(val) => Self::LitInt(val.into()),\n+                    LitKind::CStr(ref bytes, _) => Self::LitBytes(bytes),\n                     LitKind::Char(val) => Self::LitInt(val.into()),\n                     LitKind::Int(val, _) => Self::LitInt(val),\n                     LitKind::Bool(val) => Self::LitBool(val),"}, {"sha": "af121f317cd187d966d2973da91284ba23d425bb", "filename": "src/tools/clippy/clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -63,8 +63,11 @@ fn find_sugg_for_if_let<'tcx>(\n     // Determine which function should be used, and the type contained by the corresponding\n     // variant.\n     let (good_method, inner_ty) = match check_pat.kind {\n-        PatKind::TupleStruct(ref qpath, [sub_pat], _) => {\n-            if let PatKind::Wild = sub_pat.kind {\n+        PatKind::TupleStruct(ref qpath, args, rest) => {\n+            let is_wildcard = matches!(args.first().map(|p| &p.kind), Some(PatKind::Wild));\n+            let is_rest = matches!((args, rest.as_opt_usize()), ([], Some(_)));\n+\n+            if is_wildcard || is_rest {\n                 let res = cx.typeck_results().qpath_res(qpath, check_pat.hir_id);\n                 let Some(id) = res.opt_def_id().map(|ctor_id| cx.tcx.parent(ctor_id)) else { return };\n                 let lang_items = cx.tcx.lang_items();\n@@ -334,7 +337,7 @@ fn find_good_method_for_match<'a>(\n     };\n \n     match body_node_pair {\n-        (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n+        (ExprKind::Lit(lit_left), ExprKind::Lit(lit_right)) => match (&lit_left.node, &lit_right.node) {\n             (LitKind::Bool(true), LitKind::Bool(false)) => Some(should_be_left),\n             (LitKind::Bool(false), LitKind::Bool(true)) => Some(should_be_right),\n             _ => None,"}, {"sha": "8984b2cf8fd5005450c4e5b75d81bd57fa9e2f1a", "filename": "src/tools/clippy/clippy_lints/src/methods/chars_cmp_with_unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -18,7 +18,7 @@ pub(super) fn check(\n ) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprKind::Lit(ref lit) = info.other.kind;\n+        if let hir::ExprKind::Lit(lit) = info.other.kind;\n         if let ast::LitKind::Char(c) = lit.node;\n         then {\n             let mut applicability = Applicability::MachineApplicable;"}, {"sha": "e2029da8081f4b1a3798a82cea748934a71174d7", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_next_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -30,7 +30,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, cal\n             if let hir::ExprKind::Index(caller_var, index_expr) = &caller_expr.kind;\n             if let Some(higher::Range { start: Some(start_expr), end: None, limits: ast::RangeLimits::HalfOpen })\n                 = higher::Range::hir(index_expr);\n-            if let hir::ExprKind::Lit(ref start_lit) = &start_expr.kind;\n+            if let hir::ExprKind::Lit(start_lit) = &start_expr.kind;\n             if let ast::LitKind::Int(start_idx, _) = start_lit.node;\n             then {\n                 let mut applicability = Applicability::MachineApplicable;"}, {"sha": "bd625a6914c3ca54a3f22bbaf05ffef298e90823", "filename": "src/tools/clippy/clippy_lints/src/methods/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -42,11 +42,11 @@ fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec\n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n         if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && !arguments.is_empty() {\n             let argument_option = match arguments[0].kind {\n-                ExprKind::Lit(ref span) => {\n+                ExprKind::Lit(span) => {\n                     if let Spanned {\n                         node: LitKind::Bool(lit),\n                         ..\n-                    } = *span\n+                    } = span\n                     {\n                         if *lit { Argument::True } else { Argument::False }\n                     } else {"}, {"sha": "0284d9dea3032438730d3b88fc6f66c45b392642", "filename": "src/tools/clippy/clippy_lints/src/methods/path_buf_push_overwrite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fpath_buf_push_overwrite.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -15,7 +15,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arg: &'t\n         if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n         if is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id).subst_identity(), sym::PathBuf);\n-        if let ExprKind::Lit(ref lit) = arg.kind;\n+        if let ExprKind::Lit(lit) = arg.kind;\n         if let LitKind::Str(ref path_lit, _) = lit.node;\n         if let pushed_path = Path::new(path_lit.as_str());\n         if let Some(pushed_path_lit) = pushed_path.to_str();"}, {"sha": "c028e954381dde85e8a4b147630d309e4c9e7de1", "filename": "src/tools/clippy/clippy_lints/src/methods/seek_from_current.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fseek_from_current.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fseek_from_current.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fseek_from_current.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -38,7 +38,7 @@ fn arg_is_seek_from_current<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>)\n         match_def_path(cx, def_id, &paths::STD_IO_SEEK_FROM_CURRENT) {\n         // check if argument of `SeekFrom::Current` is `0`\n         if args.len() == 1 &&\n-            let ExprKind::Lit(ref lit) = args[0].kind &&\n+            let ExprKind::Lit(lit) = args[0].kind &&\n             let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node {\n             return true\n         }"}, {"sha": "787e9e0ebd245647f51bd856d7b6b2e8338ddb7b", "filename": "src/tools/clippy/clippy_lints/src/methods/seek_to_start_instead_of_rewind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fseek_to_start_instead_of_rewind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fseek_to_start_instead_of_rewind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fseek_to_start_instead_of_rewind.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -30,7 +30,7 @@ pub(super) fn check<'tcx>(\n         let Some(def_id) = cx.qpath_res(path, func.hir_id).opt_def_id() &&\n         match_def_path(cx, def_id, &paths::STD_IO_SEEKFROM_START) &&\n         args1.len() == 1 &&\n-        let ExprKind::Lit(ref lit) = args1[0].kind &&\n+        let ExprKind::Lit(lit) = args1[0].kind &&\n         let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node\n     {\n         let method_call_span = expr.span.with_lo(name_span.lo());"}, {"sha": "5a3d12fd790ea4f2063dfaf8bc5bcbf5377c4d24", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -78,7 +78,7 @@ pub(super) fn check(\n     }\n \n     // Check if the first argument to .fold is a suitable literal\n-    if let hir::ExprKind::Lit(ref lit) = init.kind {\n+    if let hir::ExprKind::Lit(lit) = init.kind {\n         match lit.node {\n             ast::LitKind::Bool(false) => check_fold_with_op(cx, expr, acc, fold_span, hir::BinOpKind::Or, \"any\", true),\n             ast::LitKind::Bool(true) => check_fold_with_op(cx, expr, acc, fold_span, hir::BinOpKind::And, \"all\", true),"}, {"sha": "1adecd2caacad7f117ed66241b1ee6f784ff6581", "filename": "src/tools/clippy/clippy_lints/src/missing_trait_methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_trait_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_trait_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_trait_methods.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -12,7 +12,7 @@ declare_clippy_lint! {\n     /// Checks if a provided method is used implicitly by a trait\n     /// implementation. A usage example would be a wrapper where every method\n     /// should perform some operation before delegating to the inner type's\n-    /// implemenation.\n+    /// implementation.\n     ///\n     /// This lint should typically be enabled on a specific trait `impl` item\n     /// rather than globally."}, {"sha": "71281a0b40b0acb04f0eb2bffc63855b073cb7c9", "filename": "src/tools/clippy/clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -3,10 +3,12 @@\n //! This lint is **warn** by default\n \n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n-use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{get_parent_node, is_else_clause, is_expn_of, peel_blocks, peel_blocks_with_stmt};\n+use clippy_utils::{\n+    get_parent_node, is_else_clause, is_expn_of, peel_blocks, peel_blocks_with_stmt, span_extract_comment,\n+};\n+use clippy_utils::{higher, SpanlessEq};\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, Node, UnOp};\n@@ -77,7 +79,39 @@ declare_clippy_lint! {\n     \"comparing a variable to a boolean, e.g., `if x == true` or `if x != true`\"\n }\n \n-declare_lint_pass!(NeedlessBool => [NEEDLESS_BOOL]);\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for expressions of the form `if c { x = true } else { x = false }`\n+    /// (or vice versa) and suggest assigning the variable directly from the\n+    /// condition.\n+    ///\n+    /// ### Why is this bad?\n+    /// Redundant code.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// # fn must_keep(x: i32, y: i32) -> bool { x == y }\n+    /// # let x = 32; let y = 10;\n+    /// # let mut skip: bool;\n+    /// if must_keep(x, y) {\n+    ///     skip = false;\n+    /// } else {\n+    ///     skip = true;\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// # fn must_keep(x: i32, y: i32) -> bool { x == y }\n+    /// # let x = 32; let y = 10;\n+    /// # let mut skip: bool;\n+    /// skip = !must_keep(x, y);\n+    /// ```\n+    #[clippy::version = \"1.69.0\"]\n+    pub NEEDLESS_BOOL_ASSIGN,\n+    complexity,\n+    \"setting the same boolean variable in both branches of an if-statement\"\n+}\n+declare_lint_pass!(NeedlessBool => [NEEDLESS_BOOL, NEEDLESS_BOOL_ASSIGN]);\n \n fn condition_needs_parentheses(e: &Expr<'_>) -> bool {\n     let mut inner = e;\n@@ -173,6 +207,29 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                     _ => (),\n                 }\n             }\n+            if let Some((lhs_a, a)) = fetch_assign(then) &&\n+                let Some((lhs_b, b)) = fetch_assign(r#else) &&\n+                SpanlessEq::new(cx).eq_expr(lhs_a, lhs_b) &&\n+                span_extract_comment(cx.tcx.sess.source_map(), e.span).is_empty()\n+            {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let cond = Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability);\n+                let lhs = snippet_with_applicability(cx, lhs_a.span, \"..\", &mut applicability);\n+                let sugg = if a == b {\n+                    format!(\"{cond}; {lhs} = {a:?};\")\n+                } else {\n+                    format!(\"{lhs} = {};\", if a { cond } else { !cond })\n+                };\n+                span_lint_and_sugg(\n+                    cx,\n+                    NEEDLESS_BOOL_ASSIGN,\n+                    e.span,\n+                    \"this if-then-else expression assigns a bool literal\",\n+                    \"you can reduce it to\",\n+                    sugg,\n+                    applicability\n+                );\n+            }\n         }\n     }\n }\n@@ -369,10 +426,18 @@ fn fetch_bool_block(expr: &Expr<'_>) -> Option<Expression> {\n }\n \n fn fetch_bool_expr(expr: &Expr<'_>) -> Option<bool> {\n-    if let ExprKind::Lit(ref lit_ptr) = peel_blocks(expr).kind {\n+    if let ExprKind::Lit(lit_ptr) = peel_blocks(expr).kind {\n         if let LitKind::Bool(value) = lit_ptr.node {\n             return Some(value);\n         }\n     }\n     None\n }\n+\n+fn fetch_assign<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<(&'tcx Expr<'tcx>, bool)> {\n+    if let ExprKind::Assign(lhs, rhs, _) = peel_blocks_with_stmt(expr).kind {\n+        fetch_bool_expr(rhs).map(|b| (lhs, b))\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "da1b9d99931a5dc65e615e671f04bc05017d5ea9", "filename": "src/tools/clippy/clippy_lints/src/needless_parens_on_range_literals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_parens_on_range_literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_parens_on_range_literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_parens_on_range_literals.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -49,14 +49,14 @@ fn snippet_enclosed_in_parenthesis(snippet: &str) -> bool {\n \n fn check_for_parens(cx: &LateContext<'_>, e: &Expr<'_>, is_start: bool) {\n     if is_start &&\n-    let ExprKind::Lit(ref literal) = e.kind &&\n+    let ExprKind::Lit(literal) = e.kind &&\n     let ast::LitKind::Float(_sym, ast::LitFloatType::Unsuffixed) = literal.node\n     {\n         // don't check floating point literals on the start expression of a range\n         return;\n     }\n     if_chain! {\n-        if let ExprKind::Lit(ref literal) = e.kind;\n+        if let ExprKind::Lit(literal) = e.kind;\n         // the indicator that parenthesis surround the literal is that the span of the expression and the literal differ\n         if (literal.span.data().hi - literal.span.data().lo) != (e.span.data().hi - e.span.data().lo);\n         // inspect the source code of the expression for parenthesis"}, {"sha": "db0e22842d14ade5e5f151ac0fc2ffaa9cb00d80", "filename": "src/tools/clippy/clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for NegMultiply {\n \n fn check_mul(cx: &LateContext<'_>, span: Span, lit: &Expr<'_>, exp: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::Lit(ref l) = lit.kind;\n+        if let ExprKind::Lit(l) = lit.kind;\n         if consts::lit_to_mir_constant(&l.node, cx.typeck_results().expr_ty_opt(lit)) == Constant::Int(1);\n         if cx.typeck_results().expr_ty(exp).is_integral();\n "}, {"sha": "f72595987ee2fe1bbec99dc095f71ae8f498411e", "filename": "src/tools/clippy/clippy_lints/src/operators/arithmetic_side_effects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -110,7 +110,7 @@ impl ArithmeticSideEffects {\n     /// like `i32::MAX` or constant references like `N` from `const N: i32 = 1;`,\n     fn literal_integer(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<u128> {\n         let actual = peel_hir_expr_unary(expr).0;\n-        if let hir::ExprKind::Lit(ref lit) = actual.kind && let ast::LitKind::Int(n, _) = lit.node {\n+        if let hir::ExprKind::Lit(lit) = actual.kind && let ast::LitKind::Int(n, _) = lit.node {\n             return Some(n)\n         }\n         if let Some((Constant::Int(n), _)) = constant(cx, cx.typeck_results(), expr) {"}, {"sha": "b8b32df6cc64b624472fb4f7de88cfad701645ee", "filename": "src/tools/clippy/clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -180,7 +180,7 @@ fn check_regex<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n         .allow_invalid_utf8(!utf8)\n         .build();\n \n-    if let ExprKind::Lit(ref lit) = expr.kind {\n+    if let ExprKind::Lit(lit) = expr.kind {\n         if let LitKind::Str(ref r, style) = lit.node {\n             let r = r.as_str();\n             let offset = if let StrStyle::Raw(n) = style { 2 + n } else { 1 };"}, {"sha": "419d7991f0ec0bfb1edbf45d36c1d728d0bbb905", "filename": "src/tools/clippy/clippy_lints/src/semicolon_block.rs", "status": "modified", "additions": 82, "deletions": 43, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsemicolon_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsemicolon_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsemicolon_block.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::{multispan_sugg_with_applicability, span_lint_and\n use rustc_errors::Applicability;\n use rustc_hir::{Block, Expr, ExprKind, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n \n declare_clippy_lint! {\n@@ -64,7 +64,78 @@ declare_clippy_lint! {\n     restriction,\n     \"add a semicolon outside the block\"\n }\n-declare_lint_pass!(SemicolonBlock => [SEMICOLON_INSIDE_BLOCK, SEMICOLON_OUTSIDE_BLOCK]);\n+impl_lint_pass!(SemicolonBlock => [SEMICOLON_INSIDE_BLOCK, SEMICOLON_OUTSIDE_BLOCK]);\n+\n+#[derive(Copy, Clone)]\n+pub struct SemicolonBlock {\n+    semicolon_inside_block_ignore_singleline: bool,\n+    semicolon_outside_block_ignore_multiline: bool,\n+}\n+\n+impl SemicolonBlock {\n+    pub fn new(semicolon_inside_block_ignore_singleline: bool, semicolon_outside_block_ignore_multiline: bool) -> Self {\n+        Self {\n+            semicolon_inside_block_ignore_singleline,\n+            semicolon_outside_block_ignore_multiline,\n+        }\n+    }\n+\n+    fn semicolon_inside_block(self, cx: &LateContext<'_>, block: &Block<'_>, tail: &Expr<'_>, semi_span: Span) {\n+        let insert_span = tail.span.source_callsite().shrink_to_hi();\n+        let remove_span = semi_span.with_lo(block.span.hi());\n+\n+        if self.semicolon_inside_block_ignore_singleline && get_line(cx, remove_span) == get_line(cx, insert_span) {\n+            return;\n+        }\n+\n+        span_lint_and_then(\n+            cx,\n+            SEMICOLON_INSIDE_BLOCK,\n+            semi_span,\n+            \"consider moving the `;` inside the block for consistent formatting\",\n+            |diag| {\n+                multispan_sugg_with_applicability(\n+                    diag,\n+                    \"put the `;` here\",\n+                    Applicability::MachineApplicable,\n+                    [(remove_span, String::new()), (insert_span, \";\".to_owned())],\n+                );\n+            },\n+        );\n+    }\n+\n+    fn semicolon_outside_block(\n+        self,\n+        cx: &LateContext<'_>,\n+        block: &Block<'_>,\n+        tail_stmt_expr: &Expr<'_>,\n+        semi_span: Span,\n+    ) {\n+        let insert_span = block.span.with_lo(block.span.hi());\n+        // account for macro calls\n+        let semi_span = cx.sess().source_map().stmt_span(semi_span, block.span);\n+        let remove_span = semi_span.with_lo(tail_stmt_expr.span.source_callsite().hi());\n+\n+        if self.semicolon_outside_block_ignore_multiline && get_line(cx, remove_span) != get_line(cx, insert_span) {\n+            return;\n+        }\n+\n+        span_lint_and_then(\n+            cx,\n+            SEMICOLON_OUTSIDE_BLOCK,\n+            block.span,\n+            \"consider moving the `;` outside the block for consistent formatting\",\n+            |diag| {\n+                multispan_sugg_with_applicability(\n+                    diag,\n+                    \"put the `;` here\",\n+                    Applicability::MachineApplicable,\n+                    [(remove_span, String::new()), (insert_span, \";\".to_owned())],\n+                );\n+            },\n+        );\n+    }\n+}\n \n impl LateLintPass<'_> for SemicolonBlock {\n     fn check_stmt(&mut self, cx: &LateContext<'_>, stmt: &Stmt<'_>) {\n@@ -83,55 +154,23 @@ impl LateLintPass<'_> for SemicolonBlock {\n                     span,\n                     ..\n                 } = stmt else { return };\n-                semicolon_outside_block(cx, block, expr, span);\n+                self.semicolon_outside_block(cx, block, expr, span);\n             },\n             StmtKind::Semi(Expr {\n                 kind: ExprKind::Block(block @ Block { expr: Some(tail), .. }, _),\n                 ..\n-            }) if !block.span.from_expansion() => semicolon_inside_block(cx, block, tail, stmt.span),\n+            }) if !block.span.from_expansion() => {\n+                self.semicolon_inside_block(cx, block, tail, stmt.span);\n+            },\n             _ => (),\n         }\n     }\n }\n \n-fn semicolon_inside_block(cx: &LateContext<'_>, block: &Block<'_>, tail: &Expr<'_>, semi_span: Span) {\n-    let insert_span = tail.span.source_callsite().shrink_to_hi();\n-    let remove_span = semi_span.with_lo(block.span.hi());\n-\n-    span_lint_and_then(\n-        cx,\n-        SEMICOLON_INSIDE_BLOCK,\n-        semi_span,\n-        \"consider moving the `;` inside the block for consistent formatting\",\n-        |diag| {\n-            multispan_sugg_with_applicability(\n-                diag,\n-                \"put the `;` here\",\n-                Applicability::MachineApplicable,\n-                [(remove_span, String::new()), (insert_span, \";\".to_owned())],\n-            );\n-        },\n-    );\n-}\n-\n-fn semicolon_outside_block(cx: &LateContext<'_>, block: &Block<'_>, tail_stmt_expr: &Expr<'_>, semi_span: Span) {\n-    let insert_span = block.span.with_lo(block.span.hi());\n-    // account for macro calls\n-    let semi_span = cx.sess().source_map().stmt_span(semi_span, block.span);\n-    let remove_span = semi_span.with_lo(tail_stmt_expr.span.source_callsite().hi());\n+fn get_line(cx: &LateContext<'_>, span: Span) -> Option<usize> {\n+    if let Ok(line) = cx.sess().source_map().lookup_line(span.lo()) {\n+        return Some(line.line);\n+    }\n \n-    span_lint_and_then(\n-        cx,\n-        SEMICOLON_OUTSIDE_BLOCK,\n-        block.span,\n-        \"consider moving the `;` outside the block for consistent formatting\",\n-        |diag| {\n-            multispan_sugg_with_applicability(\n-                diag,\n-                \"put the `;` here\",\n-                Applicability::MachineApplicable,\n-                [(remove_span, String::new()), (insert_span, \";\".to_owned())],\n-            );\n-        },\n-    );\n+    None\n }"}, {"sha": "993f9373d85d351ff8f2e4931c764fcc2554d4eb", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -108,7 +108,7 @@ impl<'tcx> LateLintPass<'tcx> for Shadow {\n     fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n         let PatKind::Binding(_, id, ident, _) = pat.kind else { return };\n \n-        if pat.span.desugaring_kind().is_some() {\n+        if pat.span.desugaring_kind().is_some() || pat.span.from_expansion() {\n             return;\n         }\n "}, {"sha": "858135c8d4647091f1810d7668adcbeec1c0fa27", "filename": "src/tools/clippy/clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -74,7 +74,7 @@ enum InitializationType<'tcx> {\n \n impl<'tcx> LateLintPass<'tcx> for SlowVectorInit {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        // Matches initialization on reassignements. For example: `vec = Vec::with_capacity(100)`\n+        // Matches initialization on reassignments. For example: `vec = Vec::with_capacity(100)`\n         if_chain! {\n             if let ExprKind::Assign(left, right, _) = expr.kind;\n "}, {"sha": "5b588e914fdf887b1d50b15bee5e0887e8794312", "filename": "src/tools/clippy/clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -292,6 +292,7 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n         }\n \n         if_chain! {\n+            if !in_external_macro(cx.sess(), e.span);\n             if let ExprKind::MethodCall(path, receiver, ..) = &e.kind;\n             if path.ident.name == sym!(as_bytes);\n             if let ExprKind::Lit(lit) = &receiver.kind;"}, {"sha": "2f2e84fa35a12ce8f7dad577678e6bfdd504fefe", "filename": "src/tools/clippy/clippy_lints/src/strlen_on_c_strings.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_context;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use clippy_utils::visitors::is_expr_unsafe;\n use clippy_utils::{get_parent_node, match_libc_symbol};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, BlockCheckMode, Expr, ExprKind, Node, UnsafeSource};\n+use rustc_hir::{Block, BlockCheckMode, Expr, ExprKind, LangItem, Node, UnsafeSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::sym;\n@@ -67,7 +67,7 @@ impl<'tcx> LateLintPass<'tcx> for StrlenOnCStrings {\n                 let val_name = snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0;\n                 let method_name = if is_type_diagnostic_item(cx, ty, sym::cstring_type) {\n                     \"as_bytes\"\n-                } else if is_type_diagnostic_item(cx, ty, sym::CStr) {\n+                } else if is_type_lang_item(cx, ty, LangItem::CStr) {\n                     \"to_bytes\"\n                 } else {\n                     return;"}, {"sha": "bb9da3a2047086b46b24c0f55b145431c351381a", "filename": "src/tools/clippy/clippy_lints/src/trailing_empty_array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -60,7 +60,7 @@ fn is_struct_with_trailing_zero_sized_array(cx: &LateContext<'_>, item: &Item<'_\n         if let Some(last_field) = data.fields().last();\n         if let rustc_hir::TyKind::Array(_, rustc_hir::ArrayLen::Body(length)) = last_field.ty.kind;\n \n-        // Then check if that that array zero-sized\n+        // Then check if that array is zero-sized\n         let length = Const::from_anon_const(cx.tcx, length.def_id);\n         let length = length.try_eval_target_usize(cx.tcx, cx.param_env);\n         if let Some(length) = length;"}, {"sha": "3c873a5901d42fed4b5c207b93a6593872be1491", "filename": "src/tools/clippy/clippy_lints/src/types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -90,8 +90,8 @@ declare_clippy_lint! {\n     ///\n     /// ### Why is this bad?\n     /// `Option<_>` represents an optional value. `Option<Option<_>>`\n-    /// represents an optional optional value which is logically the same thing as an optional\n-    /// value but has an unneeded extra level of wrapping.\n+    /// represents an optional value which itself wraps an optional. This is logically the\n+    /// same thing as an optional value but has an unneeded extra level of wrapping.\n     ///\n     /// If you have a case where `Some(Some(_))`, `Some(None)` and `None` are distinct cases,\n     /// consider a custom `enum` instead, with clear names for each case."}, {"sha": "e275bfd37b003d3fdb6fe43bf0b2e946e327463f", "filename": "src/tools/clippy/clippy_lints/src/unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funicode.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -76,7 +76,7 @@ declare_lint_pass!(Unicode => [INVISIBLE_CHARACTERS, NON_ASCII_LITERAL, UNICODE_\n \n impl LateLintPass<'_> for Unicode {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'_ Expr<'_>) {\n-        if let ExprKind::Lit(ref lit) = expr.kind {\n+        if let ExprKind::Lit(lit) = expr.kind {\n             if let LitKind::Str(_, _) | LitKind::Char(_) = lit.node {\n                 check_str(cx, lit.span, expr.hir_id);\n             }"}, {"sha": "e7449639f3af307f88145854ec77a00b50744a4b", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_box_returns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_box_returns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_box_returns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_box_returns.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -109,7 +109,7 @@ impl LateLintPass<'_> for UnnecessaryBoxReturns {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, item: &rustc_hir::ImplItem<'_>) {\n         // Ignore implementations of traits, because the lint should be on the\n-        // trait, not on the implmentation of it.\n+        // trait, not on the implementation of it.\n         let Node::Item(parent) = cx.tcx.hir().get_parent(item.hir_id()) else { return };\n         let ItemKind::Impl(parent) = parent.kind else { return };\n         if parent.of_trait.is_some() {"}, {"sha": "935ea90d2452ad4142f04926508984414d46bb90", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -304,6 +304,11 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 kind!(\"ByteStr(ref {vec})\");\n                 chain!(self, \"let [{:?}] = **{vec}\", vec.value);\n             },\n+            LitKind::CStr(ref vec, _) => {\n+                bind!(self, vec);\n+                kind!(\"CStr(ref {vec})\");\n+                chain!(self, \"let [{:?}] = **{vec}\", vec.value);\n+            }\n             LitKind::Str(s, _) => {\n                 bind!(self, s);\n                 kind!(\"Str({s}, _)\");\n@@ -333,7 +338,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n \n     #[allow(clippy::too_many_lines)]\n     fn expr(&self, expr: &Binding<&hir::Expr<'_>>) {\n-        if let Some(higher::While { condition, body }) = higher::While::hir(expr.value) {\n+        if let Some(higher::While { condition, body, .. }) = higher::While::hir(expr.value) {\n             bind!(self, condition, body);\n             chain!(\n                 self,\n@@ -561,7 +566,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n             ExprKind::OffsetOf(container, ref fields) => {\n                 bind!(self, container, fields);\n                 kind!(\"OffsetOf({container}, {fields})\");\n-            }\n+            },\n             ExprKind::Struct(qpath, fields, base) => {\n                 bind!(self, qpath, fields);\n                 opt_bind!(self, base);"}, {"sha": "5f05d971fce23a5485c674b0de458d7b45594df8", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -277,6 +277,14 @@ define_Conf! {\n     /// `\"..\"` can be used as part of the list to indicate, that the configured values should be appended to the\n     /// default configuration of Clippy. By default, any configuration will replace the default value.\n     (disallowed_names: Vec<String> = super::DEFAULT_DISALLOWED_NAMES.iter().map(ToString::to_string).collect()),\n+    /// Lint: SEMICOLON_INSIDE_BLOCK.\n+    ///\n+    /// Whether to lint only if it's multiline.\n+    (semicolon_inside_block_ignore_singleline: bool = false),\n+    /// Lint: SEMICOLON_OUTSIDE_BLOCK.\n+    ///\n+    /// Whether to lint only if it's singleline.\n+    (semicolon_outside_block_ignore_multiline: bool = false),\n     /// Lint: DOC_MARKDOWN.\n     ///\n     /// The list of words this lint should not consider as identifiers needing ticks. The value"}, {"sha": "66a5079fa85ef2bda7d11d0ebf42b7128176d5de", "filename": "src/tools/clippy/clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_utils\"\n-version = \"0.1.70\"\n+version = \"0.1.71\"\n edition = \"2021\"\n publish = false\n "}, {"sha": "9edaae853734ce842c596b4c0175b5e763e6c72c", "filename": "src/tools/clippy/clippy_utils/src/check_proc_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fcheck_proc_macro.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -117,7 +117,7 @@ fn expr_search_pat(tcx: TyCtxt<'_>, e: &Expr<'_>) -> (Pat, Pat) {\n         ExprKind::Unary(UnOp::Deref, e) => (Pat::Str(\"*\"), expr_search_pat(tcx, e).1),\n         ExprKind::Unary(UnOp::Not, e) => (Pat::Str(\"!\"), expr_search_pat(tcx, e).1),\n         ExprKind::Unary(UnOp::Neg, e) => (Pat::Str(\"-\"), expr_search_pat(tcx, e).1),\n-        ExprKind::Lit(ref lit) => lit_search_pat(&lit.node),\n+        ExprKind::Lit(lit) => lit_search_pat(&lit.node),\n         ExprKind::Array(_) | ExprKind::Repeat(..) => (Pat::Str(\"[\"), Pat::Str(\"]\")),\n         ExprKind::Call(e, []) | ExprKind::MethodCall(_, e, [], _) => (expr_search_pat(tcx, e).0, Pat::Str(\"(\")),\n         ExprKind::Call(first, [.., last])"}, {"sha": "8075881e3bb9d5e31ddb8ad0233c9ca7316cf639", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -211,6 +211,7 @@ pub fn lit_to_mir_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n         LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n         LitKind::Byte(b) => Constant::Int(u128::from(b)),\n         LitKind::ByteStr(ref s, _) => Constant::Binary(Lrc::clone(s)),\n+        LitKind::CStr(ref s, _) => Constant::Binary(Lrc::clone(s)),\n         LitKind::Char(c) => Constant::Char(c),\n         LitKind::Int(n, _) => Constant::Int(n),\n         LitKind::Float(ref is, LitFloatType::Suffixed(fty)) => match fty {\n@@ -324,7 +325,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n         match e.kind {\n             ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.typeck_results.expr_ty(e)),\n             ExprKind::Block(block, _) => self.block(block),\n-            ExprKind::Lit(ref lit) => {\n+            ExprKind::Lit(lit) => {\n                 if is_direct_expn_of(e.span, \"cfg\").is_some() {\n                     None\n                 } else {"}, {"sha": "a61e4c380886d3401267bfbc7bf94479a00c5a0c", "filename": "src/tools/clippy/clippy_utils/src/higher.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -311,6 +311,8 @@ pub struct While<'hir> {\n     pub condition: &'hir Expr<'hir>,\n     /// `while` loop body\n     pub body: &'hir Expr<'hir>,\n+    /// Span of the loop header\n+    pub span: Span,\n }\n \n impl<'hir> While<'hir> {\n@@ -336,10 +338,10 @@ impl<'hir> While<'hir> {\n             },\n             _,\n             LoopSource::While,\n-            _,\n+            span,\n         ) = expr.kind\n         {\n-            return Some(Self { condition, body });\n+            return Some(Self { condition, body, span });\n         }\n         None\n     }"}, {"sha": "9b7408d51339290585d6bee88d53657601c0c16d", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -301,7 +301,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n             (&ExprKind::Unary(l_op, le), &ExprKind::Unary(r_op, re)) => l_op == r_op && self.eq_expr(le, re),\n             (&ExprKind::Array(l), &ExprKind::Array(r)) => self.eq_exprs(l, r),\n             (&ExprKind::DropTemps(le), &ExprKind::DropTemps(re)) => self.eq_expr(le, re),\n-            (&ExprKind::OffsetOf(l_container, ref l_fields), &ExprKind::OffsetOf(r_container, ref r_fields)) => {\n+            (&ExprKind::OffsetOf(l_container, l_fields), &ExprKind::OffsetOf(r_container, r_fields)) => {\n                 self.eq_ty(l_container, r_container) && over(l_fields, r_fields, |l, r| l.name == r.name)\n             },\n             _ => false,\n@@ -718,7 +718,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 self.hash_pat(pat);\n             },\n             ExprKind::Err(_) => {},\n-            ExprKind::Lit(ref l) => {\n+            ExprKind::Lit(l) => {\n                 l.node.hash(&mut self.s);\n             },\n             ExprKind::Loop(b, ref i, ..) => {"}, {"sha": "964104fc31d0e207bb01b49d1173f119a3636af9", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 14, "deletions": 37, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -86,10 +86,10 @@ use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n-    self as hir, def, Arm, ArrayLen, BindingAnnotation, Block, BlockCheckMode, Body, Closure, Constness, Destination,\n-    Expr, ExprKind, FnDecl, HirId, Impl, ImplItem, ImplItemKind, ImplItemRef, IsAsync, Item, ItemKind, LangItem, Local,\n+    self as hir, def, Arm, ArrayLen, BindingAnnotation, Block, BlockCheckMode, Body, Closure, Destination, Expr,\n+    ExprKind, FnDecl, HirId, Impl, ImplItem, ImplItemKind, ImplItemRef, IsAsync, Item, ItemKind, LangItem, Local,\n     MatchSource, Mutability, Node, OwnerId, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind,\n-    TraitItem, TraitItemKind, TraitItemRef, TraitRef, TyKind, UnOp,\n+    TraitItem, TraitItemRef, TraitRef, TyKind, UnOp,\n };\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n@@ -197,31 +197,7 @@ pub fn find_binding_init<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<\n /// }\n /// ```\n pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n-    let parent_id = cx.tcx.hir().get_parent_item(id).def_id;\n-    match cx.tcx.hir().get_by_def_id(parent_id) {\n-        Node::Item(&Item {\n-            kind: ItemKind::Const(..) | ItemKind::Static(..) | ItemKind::Enum(..),\n-            ..\n-        })\n-        | Node::TraitItem(&TraitItem {\n-            kind: TraitItemKind::Const(..),\n-            ..\n-        })\n-        | Node::ImplItem(&ImplItem {\n-            kind: ImplItemKind::Const(..),\n-            ..\n-        })\n-        | Node::AnonConst(_) => true,\n-        Node::Item(&Item {\n-            kind: ItemKind::Fn(ref sig, ..),\n-            ..\n-        })\n-        | Node::ImplItem(&ImplItem {\n-            kind: ImplItemKind::Fn(ref sig, _),\n-            ..\n-        }) => sig.header.constness == Constness::Const,\n-        _ => false,\n-    }\n+    cx.tcx.hir().is_inside_const_context(id)\n }\n \n /// Checks if a `Res` refers to a constructor of a `LangItem`\n@@ -846,7 +822,7 @@ pub fn is_default_equivalent(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n         },\n         ExprKind::Tup(items) | ExprKind::Array(items) => items.iter().all(|x| is_default_equivalent(cx, x)),\n         ExprKind::Repeat(x, ArrayLen::Body(len)) => if_chain! {\n-            if let ExprKind::Lit(ref const_lit) = cx.tcx.hir().body(len.body).value.kind;\n+            if let ExprKind::Lit(const_lit) = cx.tcx.hir().body(len.body).value.kind;\n             if let LitKind::Int(v, _) = const_lit.node;\n             if v <= 32 && is_default_equivalent(cx, x);\n             then {\n@@ -875,7 +851,7 @@ fn is_default_equivalent_from(cx: &LateContext<'_>, from_func: &Expr<'_>, arg: &\n             }) => return sym.is_empty() && is_path_lang_item(cx, ty, LangItem::String),\n             ExprKind::Array([]) => return is_path_diagnostic_item(cx, ty, sym::Vec),\n             ExprKind::Repeat(_, ArrayLen::Body(len)) => {\n-                if let ExprKind::Lit(ref const_lit) = cx.tcx.hir().body(len.body).value.kind &&\n+                if let ExprKind::Lit(const_lit) = cx.tcx.hir().body(len.body).value.kind &&\n                     let LitKind::Int(v, _) = const_lit.node\n                 {\n                         return v == 0 && is_path_diagnostic_item(cx, ty, sym::Vec);\n@@ -1569,7 +1545,7 @@ pub fn is_integer_const(cx: &LateContext<'_>, e: &Expr<'_>, value: u128) -> bool\n /// Checks whether the given expression is a constant literal of the given value.\n pub fn is_integer_literal(expr: &Expr<'_>, value: u128) -> bool {\n     // FIXME: use constant folding\n-    if let ExprKind::Lit(ref spanned) = expr.kind {\n+    if let ExprKind::Lit(spanned) = expr.kind {\n         if let LitKind::Int(v, _) = spanned.node {\n             return v == value;\n         }\n@@ -2165,10 +2141,7 @@ pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n         .predicates\n         .iter()\n         .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n-    traits::impossible_predicates(\n-        cx.tcx,\n-        traits::elaborate(cx.tcx, predicates).collect::<Vec<_>>(),\n-    )\n+    traits::impossible_predicates(cx.tcx, traits::elaborate(cx.tcx, predicates).collect::<Vec<_>>())\n }\n \n /// Returns the `DefId` of the callee if the given expression is a function or method call.\n@@ -2233,8 +2206,12 @@ pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<S\n     None\n }\n \n-/// returns list of all pairs (a, b) from `exprs` such that `eq(a, b)`\n-/// `hash` must be comformed with `eq`\n+/// Returns list of all pairs `(a, b)` where `eq(a, b) == true`\n+/// and `a` is before `b` in `exprs` for all `a` and `b` in\n+/// `exprs`\n+///\n+/// Given functions `eq` and `hash` such that `eq(a, b) == true`\n+/// implies `hash(a) == hash(b)`\n pub fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Vec<(&T, &T)>\n where\n     Hash: Fn(&T) -> u64,"}, {"sha": "e4a4936ff42fce98f57374a6588e2c309bdabcba", "filename": "src/tools/clippy/clippy_utils/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -362,7 +362,7 @@ thread_local! {\n     /// able to access the many features of a [`LateContext`].\n     ///\n     /// A thread local is used because [`FormatArgs`] is `!Send` and `!Sync`, we are making an\n-    /// assumption that the early pass the populates the map and the later late passes will all be\n+    /// assumption that the early pass that populates the map and the later late passes will all be\n     /// running on the same thread.\n     static AST_FORMAT_ARGS: RefCell<FxHashMap<Span, FormatArgs>> = {\n         static CALLED: AtomicBool = AtomicBool::new(false);"}, {"sha": "0f0792fdaa963f366061124a3bf309bee63892ec", "filename": "src/tools/clippy/clippy_utils/src/paths.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -159,3 +159,7 @@ pub const WEAK_RC: [&str; 3] = [\"alloc\", \"rc\", \"Weak\"];\n pub const PTR_NON_NULL: [&str; 4] = [\"core\", \"ptr\", \"non_null\", \"NonNull\"];\n pub const INSTANT_NOW: [&str; 4] = [\"std\", \"time\", \"Instant\", \"now\"];\n pub const INSTANT: [&str; 3] = [\"std\", \"time\", \"Instant\"];\n+pub const VEC_IS_EMPTY: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"is_empty\"];\n+pub const VEC_POP: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"pop\"];\n+pub const OPTION_UNWRAP: [&str; 4] = [\"core\", \"option\", \"Option\", \"unwrap\"];\n+pub const OPTION_EXPECT: [&str; 4] = [\"core\", \"option\", \"Option\", \"expect\"];"}, {"sha": "c0d2c835d63d48d85f21f6eb583cb0b99df92a02", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -194,7 +194,9 @@ fn check_rvalue<'tcx>(\n                 ))\n             }\n         },\n-        Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf | NullOp::OffsetOf(_), _) | Rvalue::ShallowInitBox(_, _) => Ok(()),\n+        Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf | NullOp::OffsetOf(_), _) | Rvalue::ShallowInitBox(_, _) => {\n+            Ok(())\n+        },\n         Rvalue::UnaryOp(_, operand) => {\n             let ty = operand.ty(body, tcx);\n             if ty.is_integral() || ty.is_bool() {"}, {"sha": "14f7f03016fbe5605110f03918bccade6b086b06", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -162,7 +162,7 @@ impl<'a> Sugg<'a> {\n                 get_snippet(lhs.span),\n                 get_snippet(rhs.span),\n             ),\n-            hir::ExprKind::Cast(lhs, ty) => Sugg::BinOp(AssocOp::As, get_snippet(lhs.span), get_snippet(ty.span)),\n+            hir::ExprKind::Cast(lhs, ty) |\n             //FIXME(chenyukang), remove this after type ascription is removed from AST\n             hir::ExprKind::Type(lhs, ty) => Sugg::BinOp(AssocOp::As, get_snippet(lhs.span), get_snippet(ty.span)),\n         }\n@@ -254,11 +254,7 @@ impl<'a> Sugg<'a> {\n                 snippet_with_context(cx, lhs.span, ctxt, default, app).0,\n                 snippet_with_context(cx, rhs.span, ctxt, default, app).0,\n             ),\n-            ast::ExprKind::Cast(ref lhs, ref ty) => Sugg::BinOp(\n-                AssocOp::As,\n-                snippet_with_context(cx, lhs.span, ctxt, default, app).0,\n-                snippet_with_context(cx, ty.span, ctxt, default, app).0,\n-            ),\n+            ast::ExprKind::Cast(ref lhs, ref ty) |\n             //FIXME(chenyukang), remove this after type ascription is removed from AST\n             ast::ExprKind::Type(ref lhs, ref ty) => Sugg::BinOp(\n                 AssocOp::As,\n@@ -603,8 +599,8 @@ enum Associativity {\n #[must_use]\n fn associativity(op: AssocOp) -> Associativity {\n     use rustc_ast::util::parser::AssocOp::{\n-        Add, As, Assign, AssignOp, BitAnd, BitOr, BitXor, Divide, DotDot, DotDotEq, Equal, Greater,\n-        GreaterEqual, LAnd, LOr, Less, LessEqual, Modulus, Multiply, NotEqual, ShiftLeft, ShiftRight, Subtract,\n+        Add, As, Assign, AssignOp, BitAnd, BitOr, BitXor, Divide, DotDot, DotDotEq, Equal, Greater, GreaterEqual, LAnd,\n+        LOr, Less, LessEqual, Modulus, Multiply, NotEqual, ShiftLeft, ShiftRight, Subtract,\n     };\n \n     match op {"}, {"sha": "7b4ed77e8edb9eac7570078f927f40c03f48f105", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -93,7 +93,7 @@ pub fn contains_ty_adt_constructor_opaque<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'\n                     for (predicate, _span) in cx.tcx.explicit_item_bounds(def_id).subst_identity_iter_copied() {\n                         match predicate.kind().skip_binder() {\n                             // For `impl Trait<U>`, it will register a predicate of `T: Trait<U>`, so we go through\n-                            // and check substituions to find `U`.\n+                            // and check substitutions to find `U`.\n                             ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) => {\n                                 if trait_predicate\n                                     .trait_ref\n@@ -837,7 +837,7 @@ pub fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     if let ty::Adt(adt, _) = ty.kind()\n         && let &[krate, .., name] = &*cx.get_def_path(adt.did())\n         && let sym::libc | sym::core | sym::std = krate\n-        && name.as_str() == \"c_void\"\n+        && name == rustc_span::sym::c_void\n     {\n         true\n     } else {\n@@ -1101,7 +1101,7 @@ pub fn make_projection<'tcx>(\n ///\n /// This function is for associated types which are \"known\" to be valid with the given\n /// substitutions, and as such, will only return `None` when debug assertions are disabled in order\n-/// to prevent ICE's. With debug assertions enabled this will check that that type normalization\n+/// to prevent ICE's. With debug assertions enabled this will check that type normalization\n /// succeeds as well as everything checked by `make_projection`.\n pub fn make_normalized_projection<'tcx>(\n     tcx: TyCtxt<'tcx>,"}, {"sha": "139102798c42a398fcf338fc2784bbcb20a0c492", "filename": "src/tools/clippy/declare_clippy_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fdeclare_clippy_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fdeclare_clippy_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdeclare_clippy_lint%2FCargo.toml?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"declare_clippy_lint\"\n-version = \"0.1.70\"\n+version = \"0.1.71\"\n edition = \"2021\"\n publish = false\n "}, {"sha": "37cc045380949e0b3a140a0a03a07aa1de39aa66", "filename": "src/tools/clippy/lintcheck/README.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Flintcheck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Flintcheck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Flintcheck%2FREADME.md?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -79,9 +79,11 @@ is explicitly specified in the options.\n \n ### Fix mode\n You can run `cargo lintcheck --fix` which will run Clippy with `--fix` and\n-print a warning if Clippy's suggestions fail to apply (if the resulting code does not build).  \n+print a warning if Clippy's suggestions fail to apply (if the resulting code does not build). \n This lets us spot bad suggestions or false positives automatically in some cases.  \n \n+> Note: Fix mode implies `--all-targets`, so it can fix as much code as it can.\n+\n Please note that the target dir should be cleaned afterwards since clippy will modify\n the downloaded sources which can lead to unexpected results when running lintcheck again afterwards.\n "}, {"sha": "03d1877d6c64497aeaac07ce29ba8fe1d31f779f", "filename": "src/tools/clippy/lintcheck/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Flintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Flintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Flintcheck%2Fsrc%2Fmain.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -421,7 +421,7 @@ impl Crate {\n             {\n                 let subcrate = &stderr[63..];\n                 println!(\n-                    \"ERROR: failed to apply some suggetion to {} / to (sub)crate {subcrate}\",\n+                    \"ERROR: failed to apply some suggestion to {} / to (sub)crate {subcrate}\",\n                     self.name\n                 );\n             }"}, {"sha": "60b8a5ac0719353b14a0aef3e019b2b40ccdac9f", "filename": "src/tools/clippy/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frust-toolchain?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2023-04-06\"\n+channel = \"nightly-2023-05-05\"\n components = [\"cargo\", \"llvm-tools\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "59bf447a7cd0758c9961b1cc826b4d4498dc487b", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 9, "deletions": 61, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -11,7 +11,6 @@\n // FIXME: switch to something more ergonomic here, once available.\n // (Currently there is no way to opt into sysroot crates without `extern crate`.)\n extern crate rustc_driver;\n-extern crate rustc_errors;\n extern crate rustc_interface;\n extern crate rustc_session;\n extern crate rustc_span;\n@@ -20,13 +19,10 @@ use rustc_interface::interface;\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::Symbol;\n \n-use std::borrow::Cow;\n use std::env;\n use std::ops::Deref;\n-use std::panic;\n use std::path::Path;\n use std::process::exit;\n-use std::sync::LazyLock;\n \n /// If a command-line option matches `find_arg`, then apply the predicate `pred` on its value. If\n /// true, then return it. The parameter is assumed to be either `--arg=value` or `--arg value`.\n@@ -198,66 +194,18 @@ You can use tool lints to allow or deny lints from your code, eg.:\n \n const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust-clippy/issues/new\";\n \n-type PanicCallback = dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static;\n-static ICE_HOOK: LazyLock<Box<PanicCallback>> = LazyLock::new(|| {\n-    let hook = panic::take_hook();\n-    panic::set_hook(Box::new(|info| report_clippy_ice(info, BUG_REPORT_URL)));\n-    hook\n-});\n-\n-fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n-    // Invoke our ICE handler, which prints the actual panic message and optionally a backtrace\n-    (*ICE_HOOK)(info);\n-\n-    // Separate the output with an empty line\n-    eprintln!();\n-\n-    let fallback_bundle = rustc_errors::fallback_fluent_bundle(rustc_driver::DEFAULT_LOCALE_RESOURCES.to_vec(), false);\n-    let emitter = Box::new(rustc_errors::emitter::EmitterWriter::stderr(\n-        rustc_errors::ColorConfig::Auto,\n-        None,\n-        None,\n-        fallback_bundle,\n-        false,\n-        false,\n-        None,\n-        false,\n-        false,\n-        rustc_errors::TerminalUrl::No,\n-    ));\n-    let handler = rustc_errors::Handler::with_emitter(true, None, emitter);\n-\n-    // a .span_bug or .bug call has already printed what\n-    // it wants to print.\n-    if !info.payload().is::<rustc_errors::ExplicitBug>() {\n-        let mut d = rustc_errors::Diagnostic::new(rustc_errors::Level::Bug, \"unexpected panic\");\n-        handler.emit_diagnostic(&mut d);\n-    }\n-\n-    let version_info = rustc_tools_util::get_version_info!();\n-\n-    let xs: Vec<Cow<'static, str>> = vec![\n-        \"the compiler unexpectedly panicked. this is a bug.\".into(),\n-        format!(\"we would appreciate a bug report: {bug_report_url}\").into(),\n-        format!(\"Clippy version: {version_info}\").into(),\n-    ];\n-\n-    for note in &xs {\n-        handler.note_without_error(note.as_ref());\n-    }\n-\n-    // If backtraces are enabled, also print the query stack\n-    let backtrace = env::var_os(\"RUST_BACKTRACE\").map_or(false, |x| &x != \"0\");\n-\n-    let num_frames = if backtrace { None } else { Some(2) };\n-\n-    interface::try_print_query_stack(&handler, num_frames);\n-}\n-\n #[allow(clippy::too_many_lines)]\n pub fn main() {\n     rustc_driver::init_rustc_env_logger();\n-    LazyLock::force(&ICE_HOOK);\n+\n+    rustc_driver::install_ice_hook(BUG_REPORT_URL, |handler| {\n+        // FIXME: this macro calls unwrap internally but is called in a panicking context!  It's not\n+        // as simple as moving the call from the hook to main, because `install_ice_hook` doesn't\n+        // accept a generic closure.\n+        let version_info = rustc_tools_util::get_version_info!();\n+        handler.note_without_error(format!(\"Clippy version: {version_info}\"));\n+    });\n+\n     exit(rustc_driver::catch_with_exit_code(move || {\n         let mut orig_args: Vec<String> = env::args().collect();\n         let has_sysroot_arg = arg_value(&orig_args, \"--sysroot\", |_| true).is_some();"}, {"sha": "188ff87abfc53e4cde41c1fa2919d6e7de015e66", "filename": "src/tools/clippy/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fmain.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -13,7 +13,7 @@ Usage:\n \n Common options:\n     --no-deps                Run Clippy only on the given crate, without linting the dependencies\n-    --fix                    Automatically apply lint suggestions. This flag implies `--no-deps`\n+    --fix                    Automatically apply lint suggestions. This flag implies `--no-deps` and `--all-targets`\n     -h, --help               Print this message\n     -V, --version            Print version info and exit\n     --explain LINT           Print the documentation for a given lint"}, {"sha": "afde31face11349b87f43582d30d42cbd9e4181a", "filename": "src/tools/clippy/tests/dogfood.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -39,7 +39,7 @@ fn dogfood_clippy() {\n     assert!(\n         failed_packages.is_empty(),\n         \"Dogfood failed for packages `{}`\",\n-        failed_packages.iter().format(\", \"),\n+        failed_packages.iter().join(\", \"),\n     );\n }\n "}, {"sha": "fc8038a090715590aa2e1d032077e4fb40cc215f", "filename": "src/tools/clippy/tests/ui-toml/semicolon_block/both.fixed", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fboth.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fboth.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fboth.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,86 @@\n+//@run-rustfix\n+#![allow(\n+    unused,\n+    clippy::unused_unit,\n+    clippy::unnecessary_operation,\n+    clippy::no_effect,\n+    clippy::single_element_loop\n+)]\n+#![warn(clippy::semicolon_inside_block)]\n+#![warn(clippy::semicolon_outside_block)]\n+\n+macro_rules! m {\n+    (()) => {\n+        ()\n+    };\n+    (0) => {{\n+        0\n+    };};\n+    (1) => {{\n+        1;\n+    }};\n+    (2) => {{\n+        2;\n+    }};\n+}\n+\n+fn unit_fn_block() {\n+    ()\n+}\n+\n+#[rustfmt::skip]\n+fn main() {\n+    { unit_fn_block() }\n+    unsafe { unit_fn_block() }\n+\n+    {\n+        unit_fn_block()\n+    }\n+\n+    { unit_fn_block() };\n+    unsafe { unit_fn_block() };\n+\n+    { unit_fn_block() };\n+    unsafe { unit_fn_block() };\n+\n+    { unit_fn_block(); };\n+    unsafe { unit_fn_block(); };\n+\n+    {\n+        unit_fn_block();\n+        unit_fn_block();\n+    }\n+    {\n+        unit_fn_block();\n+        unit_fn_block();\n+    }\n+    {\n+        unit_fn_block();\n+        unit_fn_block();\n+    };\n+\n+    { m!(()) };\n+    { m!(()) };\n+    { m!(()); };\n+    m!(0);\n+    m!(1);\n+    m!(2);\n+\n+    for _ in [()] {\n+        unit_fn_block();\n+    }\n+    for _ in [()] {\n+        unit_fn_block()\n+    }\n+\n+    let _d = || {\n+        unit_fn_block();\n+    };\n+    let _d = || {\n+        unit_fn_block()\n+    };\n+\n+    { unit_fn_block(); };\n+\n+    unit_fn_block()\n+}"}, {"sha": "52ce1f0387ee1d5ad4e3b1291bac422de1990909", "filename": "src/tools/clippy/tests/ui-toml/semicolon_block/both.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fboth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fboth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fboth.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,86 @@\n+//@run-rustfix\n+#![allow(\n+    unused,\n+    clippy::unused_unit,\n+    clippy::unnecessary_operation,\n+    clippy::no_effect,\n+    clippy::single_element_loop\n+)]\n+#![warn(clippy::semicolon_inside_block)]\n+#![warn(clippy::semicolon_outside_block)]\n+\n+macro_rules! m {\n+    (()) => {\n+        ()\n+    };\n+    (0) => {{\n+        0\n+    };};\n+    (1) => {{\n+        1;\n+    }};\n+    (2) => {{\n+        2;\n+    }};\n+}\n+\n+fn unit_fn_block() {\n+    ()\n+}\n+\n+#[rustfmt::skip]\n+fn main() {\n+    { unit_fn_block() }\n+    unsafe { unit_fn_block() }\n+\n+    {\n+        unit_fn_block()\n+    }\n+\n+    { unit_fn_block() };\n+    unsafe { unit_fn_block() };\n+\n+    { unit_fn_block(); }\n+    unsafe { unit_fn_block(); }\n+\n+    { unit_fn_block(); };\n+    unsafe { unit_fn_block(); };\n+\n+    {\n+        unit_fn_block();\n+        unit_fn_block()\n+    };\n+    {\n+        unit_fn_block();\n+        unit_fn_block();\n+    }\n+    {\n+        unit_fn_block();\n+        unit_fn_block();\n+    };\n+\n+    { m!(()) };\n+    { m!(()); }\n+    { m!(()); };\n+    m!(0);\n+    m!(1);\n+    m!(2);\n+\n+    for _ in [()] {\n+        unit_fn_block();\n+    }\n+    for _ in [()] {\n+        unit_fn_block()\n+    }\n+\n+    let _d = || {\n+        unit_fn_block();\n+    };\n+    let _d = || {\n+        unit_fn_block()\n+    };\n+\n+    { unit_fn_block(); };\n+\n+    unit_fn_block()\n+}"}, {"sha": "2f58842eab01b1933d10f8a0530058c4e3bfba56", "filename": "src/tools/clippy/tests/ui-toml/semicolon_block/both.stderr", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fboth.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fboth.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fboth.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,55 @@\n+error: consider moving the `;` outside the block for consistent formatting\n+  --> $DIR/both.rs:43:5\n+   |\n+LL |     { unit_fn_block(); }\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::semicolon-outside-block` implied by `-D warnings`\n+help: put the `;` here\n+   |\n+LL -     { unit_fn_block(); }\n+LL +     { unit_fn_block() };\n+   |\n+\n+error: consider moving the `;` outside the block for consistent formatting\n+  --> $DIR/both.rs:44:5\n+   |\n+LL |     unsafe { unit_fn_block(); }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: put the `;` here\n+   |\n+LL -     unsafe { unit_fn_block(); }\n+LL +     unsafe { unit_fn_block() };\n+   |\n+\n+error: consider moving the `;` inside the block for consistent formatting\n+  --> $DIR/both.rs:49:5\n+   |\n+LL | /     {\n+LL | |         unit_fn_block();\n+LL | |         unit_fn_block()\n+LL | |     };\n+   | |______^\n+   |\n+   = note: `-D clippy::semicolon-inside-block` implied by `-D warnings`\n+help: put the `;` here\n+   |\n+LL ~         unit_fn_block();\n+LL ~     }\n+   |\n+\n+error: consider moving the `;` outside the block for consistent formatting\n+  --> $DIR/both.rs:63:5\n+   |\n+LL |     { m!(()); }\n+   |     ^^^^^^^^^^^\n+   |\n+help: put the `;` here\n+   |\n+LL -     { m!(()); }\n+LL +     { m!(()) };\n+   |\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "4d03e88deba8a95f19109e8bdce65096a35fed74", "filename": "src/tools/clippy/tests/ui-toml/semicolon_block/clippy.toml", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fclippy.toml?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,2 @@\n+semicolon-inside-block-ignore-singleline = true\n+semicolon-outside-block-ignore-multiline = true"}, {"sha": "23df9830177359ebdb797d0c0e5110b6ea6b11b6", "filename": "src/tools/clippy/tests/ui-toml/semicolon_block/semicolon_inside_block.fixed", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_inside_block.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_inside_block.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_inside_block.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,85 @@\n+//@run-rustfix\n+#![allow(\n+    unused,\n+    clippy::unused_unit,\n+    clippy::unnecessary_operation,\n+    clippy::no_effect,\n+    clippy::single_element_loop\n+)]\n+#![warn(clippy::semicolon_inside_block)]\n+\n+macro_rules! m {\n+    (()) => {\n+        ()\n+    };\n+    (0) => {{\n+        0\n+    };};\n+    (1) => {{\n+        1;\n+    }};\n+    (2) => {{\n+        2;\n+    }};\n+}\n+\n+fn unit_fn_block() {\n+    ()\n+}\n+\n+#[rustfmt::skip]\n+fn main() {\n+    { unit_fn_block() }\n+    unsafe { unit_fn_block() }\n+\n+    {\n+        unit_fn_block()\n+    }\n+\n+    { unit_fn_block() };\n+    unsafe { unit_fn_block() };\n+\n+    { unit_fn_block(); }\n+    unsafe { unit_fn_block(); }\n+\n+    { unit_fn_block(); };\n+    unsafe { unit_fn_block(); };\n+\n+    {\n+        unit_fn_block();\n+        unit_fn_block();\n+    }\n+    {\n+        unit_fn_block();\n+        unit_fn_block();\n+    }\n+    {\n+        unit_fn_block();\n+        unit_fn_block();\n+    };\n+\n+    { m!(()) };\n+    { m!(()); }\n+    { m!(()); };\n+    m!(0);\n+    m!(1);\n+    m!(2);\n+\n+    for _ in [()] {\n+        unit_fn_block();\n+    }\n+    for _ in [()] {\n+        unit_fn_block()\n+    }\n+\n+    let _d = || {\n+        unit_fn_block();\n+    };\n+    let _d = || {\n+        unit_fn_block()\n+    };\n+\n+    { unit_fn_block(); };\n+\n+    unit_fn_block()\n+}"}, {"sha": "e8516f79b20cde60d35cc611f152a4817430b2eb", "filename": "src/tools/clippy/tests/ui-toml/semicolon_block/semicolon_inside_block.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_inside_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_inside_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_inside_block.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,85 @@\n+//@run-rustfix\n+#![allow(\n+    unused,\n+    clippy::unused_unit,\n+    clippy::unnecessary_operation,\n+    clippy::no_effect,\n+    clippy::single_element_loop\n+)]\n+#![warn(clippy::semicolon_inside_block)]\n+\n+macro_rules! m {\n+    (()) => {\n+        ()\n+    };\n+    (0) => {{\n+        0\n+    };};\n+    (1) => {{\n+        1;\n+    }};\n+    (2) => {{\n+        2;\n+    }};\n+}\n+\n+fn unit_fn_block() {\n+    ()\n+}\n+\n+#[rustfmt::skip]\n+fn main() {\n+    { unit_fn_block() }\n+    unsafe { unit_fn_block() }\n+\n+    {\n+        unit_fn_block()\n+    }\n+\n+    { unit_fn_block() };\n+    unsafe { unit_fn_block() };\n+\n+    { unit_fn_block(); }\n+    unsafe { unit_fn_block(); }\n+\n+    { unit_fn_block(); };\n+    unsafe { unit_fn_block(); };\n+\n+    {\n+        unit_fn_block();\n+        unit_fn_block()\n+    };\n+    {\n+        unit_fn_block();\n+        unit_fn_block();\n+    }\n+    {\n+        unit_fn_block();\n+        unit_fn_block();\n+    };\n+\n+    { m!(()) };\n+    { m!(()); }\n+    { m!(()); };\n+    m!(0);\n+    m!(1);\n+    m!(2);\n+\n+    for _ in [()] {\n+        unit_fn_block();\n+    }\n+    for _ in [()] {\n+        unit_fn_block()\n+    }\n+\n+    let _d = || {\n+        unit_fn_block();\n+    };\n+    let _d = || {\n+        unit_fn_block()\n+    };\n+\n+    { unit_fn_block(); };\n+\n+    unit_fn_block()\n+}"}, {"sha": "2569dc4b4e4530f1ab37a7fc21284d761f6c1b7d", "filename": "src/tools/clippy/tests/ui-toml/semicolon_block/semicolon_inside_block.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_inside_block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_inside_block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_inside_block.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,18 @@\n+error: consider moving the `;` inside the block for consistent formatting\n+  --> $DIR/semicolon_inside_block.rs:48:5\n+   |\n+LL | /     {\n+LL | |         unit_fn_block();\n+LL | |         unit_fn_block()\n+LL | |     };\n+   | |______^\n+   |\n+   = note: `-D clippy::semicolon-inside-block` implied by `-D warnings`\n+help: put the `;` here\n+   |\n+LL ~         unit_fn_block();\n+LL ~     }\n+   |\n+\n+error: aborting due to previous error\n+"}, {"sha": "7e9055e71106aff3f8be5036359aea19210135cc", "filename": "src/tools/clippy/tests/ui-toml/semicolon_block/semicolon_outside_block.fixed", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_outside_block.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_outside_block.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_outside_block.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,85 @@\n+//@run-rustfix\n+#![allow(\n+    unused,\n+    clippy::unused_unit,\n+    clippy::unnecessary_operation,\n+    clippy::no_effect,\n+    clippy::single_element_loop\n+)]\n+#![warn(clippy::semicolon_outside_block)]\n+\n+macro_rules! m {\n+    (()) => {\n+        ()\n+    };\n+    (0) => {{\n+        0\n+    };};\n+    (1) => {{\n+        1;\n+    }};\n+    (2) => {{\n+        2;\n+    }};\n+}\n+\n+fn unit_fn_block() {\n+    ()\n+}\n+\n+#[rustfmt::skip]\n+fn main() {\n+    { unit_fn_block() }\n+    unsafe { unit_fn_block() }\n+\n+    {\n+        unit_fn_block()\n+    }\n+\n+    { unit_fn_block() };\n+    unsafe { unit_fn_block() };\n+\n+    { unit_fn_block() };\n+    unsafe { unit_fn_block() };\n+\n+    { unit_fn_block(); };\n+    unsafe { unit_fn_block(); };\n+\n+    {\n+        unit_fn_block();\n+        unit_fn_block()\n+    };\n+    {\n+        unit_fn_block();\n+        unit_fn_block();\n+    }\n+    {\n+        unit_fn_block();\n+        unit_fn_block();\n+    };\n+\n+    { m!(()) };\n+    { m!(()) };\n+    { m!(()); };\n+    m!(0);\n+    m!(1);\n+    m!(2);\n+\n+    for _ in [()] {\n+        unit_fn_block();\n+    }\n+    for _ in [()] {\n+        unit_fn_block()\n+    }\n+\n+    let _d = || {\n+        unit_fn_block();\n+    };\n+    let _d = || {\n+        unit_fn_block()\n+    };\n+\n+    { unit_fn_block(); };\n+\n+    unit_fn_block()\n+}"}, {"sha": "4dc956d8a4b51773bad95b87afa1774ce1b2229c", "filename": "src/tools/clippy/tests/ui-toml/semicolon_block/semicolon_outside_block.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_outside_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_outside_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_outside_block.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,85 @@\n+//@run-rustfix\n+#![allow(\n+    unused,\n+    clippy::unused_unit,\n+    clippy::unnecessary_operation,\n+    clippy::no_effect,\n+    clippy::single_element_loop\n+)]\n+#![warn(clippy::semicolon_outside_block)]\n+\n+macro_rules! m {\n+    (()) => {\n+        ()\n+    };\n+    (0) => {{\n+        0\n+    };};\n+    (1) => {{\n+        1;\n+    }};\n+    (2) => {{\n+        2;\n+    }};\n+}\n+\n+fn unit_fn_block() {\n+    ()\n+}\n+\n+#[rustfmt::skip]\n+fn main() {\n+    { unit_fn_block() }\n+    unsafe { unit_fn_block() }\n+\n+    {\n+        unit_fn_block()\n+    }\n+\n+    { unit_fn_block() };\n+    unsafe { unit_fn_block() };\n+\n+    { unit_fn_block(); }\n+    unsafe { unit_fn_block(); }\n+\n+    { unit_fn_block(); };\n+    unsafe { unit_fn_block(); };\n+\n+    {\n+        unit_fn_block();\n+        unit_fn_block()\n+    };\n+    {\n+        unit_fn_block();\n+        unit_fn_block();\n+    }\n+    {\n+        unit_fn_block();\n+        unit_fn_block();\n+    };\n+\n+    { m!(()) };\n+    { m!(()); }\n+    { m!(()); };\n+    m!(0);\n+    m!(1);\n+    m!(2);\n+\n+    for _ in [()] {\n+        unit_fn_block();\n+    }\n+    for _ in [()] {\n+        unit_fn_block()\n+    }\n+\n+    let _d = || {\n+        unit_fn_block();\n+    };\n+    let _d = || {\n+        unit_fn_block()\n+    };\n+\n+    { unit_fn_block(); };\n+\n+    unit_fn_block()\n+}"}, {"sha": "6dd3577dd09f06812829e50f1a07cba32b4a356a", "filename": "src/tools/clippy/tests/ui-toml/semicolon_block/semicolon_outside_block.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_outside_block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_outside_block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fsemicolon_block%2Fsemicolon_outside_block.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,39 @@\n+error: consider moving the `;` outside the block for consistent formatting\n+  --> $DIR/semicolon_outside_block.rs:42:5\n+   |\n+LL |     { unit_fn_block(); }\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::semicolon-outside-block` implied by `-D warnings`\n+help: put the `;` here\n+   |\n+LL -     { unit_fn_block(); }\n+LL +     { unit_fn_block() };\n+   |\n+\n+error: consider moving the `;` outside the block for consistent formatting\n+  --> $DIR/semicolon_outside_block.rs:43:5\n+   |\n+LL |     unsafe { unit_fn_block(); }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: put the `;` here\n+   |\n+LL -     unsafe { unit_fn_block(); }\n+LL +     unsafe { unit_fn_block() };\n+   |\n+\n+error: consider moving the `;` outside the block for consistent formatting\n+  --> $DIR/semicolon_outside_block.rs:62:5\n+   |\n+LL |     { m!(()); }\n+   |     ^^^^^^^^^^^\n+   |\n+help: put the `;` here\n+   |\n+LL -     { m!(()); }\n+LL +     { m!(()) };\n+   |\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "44710b09648eeb91accaa2d4761fc4be1410e08b", "filename": "src/tools/clippy/tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -37,6 +37,8 @@ error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown fie\n            missing-docs-in-crate-items\n            msrv\n            pass-by-value-size-limit\n+           semicolon-inside-block-ignore-singleline\n+           semicolon-outside-block-ignore-multiline\n            single-char-binding-names-threshold\n            standard-macro-braces\n            suppress-restriction-lint-in-const"}, {"sha": "5c3407628be27408ec55fcd717667c2b3d91ceae", "filename": "src/tools/clippy/tests/ui/allow_attributes_false_positive.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fallow_attributes_false_positive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fallow_attributes_false_positive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fallow_attributes_false_positive.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,5 @@\n+#![warn(clippy::allow_attributes)]\n+#![feature(lint_reasons)]\n+#![crate_type = \"proc-macro\"]\n+\n+fn main() {}"}, {"sha": "e5bb906663c564d65674e91fa6239dc49adb2da5", "filename": "src/tools/clippy/tests/ui/auxiliary/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fmacro_rules.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -21,6 +21,13 @@ macro_rules! string_add {\n     };\n }\n \n+#[macro_export]\n+macro_rules! string_lit_as_bytes {\n+    ($s:literal) => {\n+        const C: &[u8] = $s.as_bytes();\n+    };\n+}\n+\n #[macro_export]\n macro_rules! mut_mut {\n     () => {"}, {"sha": "d164dd0e54505d556dd48c32d280e94178cb735e", "filename": "src/tools/clippy/tests/ui/auxiliary/proc_macro_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fproc_macro_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fproc_macro_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fproc_macro_attr.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -82,7 +82,7 @@ pub fn rename_my_lifetimes(_args: TokenStream, input: TokenStream) -> TokenStrea\n                     elided += 1;\n \n                     // HACK: Syn uses `Span` from the proc_macro2 crate, and does not seem to reexport it.\n-                    // In order to avoid adding the dependency, get a default span from a non-existent token.\n+                    // In order to avoid adding the dependency, get a default span from a nonexistent token.\n                     // A default span is needed to mark the code as coming from expansion.\n                     let span = Star::default().span();\n "}, {"sha": "fbb10a133e2b0a5a83a81fccf0ad618e969cb555", "filename": "src/tools/clippy/tests/ui/bool_to_int_with_if.fixed", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_to_int_with_if.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_to_int_with_if.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_to_int_with_if.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,6 +1,6 @@\n //@run-rustfix\n \n-#![feature(let_chains)]\n+#![feature(let_chains, inline_const)]\n #![warn(clippy::bool_to_int_with_if)]\n #![allow(unused, dead_code, clippy::unnecessary_operation, clippy::no_effect)]\n \n@@ -79,6 +79,13 @@ fn main() {\n \n     pub const SHOULD_NOT_LINT: usize = if true { 1 } else { 0 };\n \n+    // https://github.com/rust-lang/rust-clippy/issues/10452\n+    let should_not_lint = [(); if true { 1 } else { 0 }];\n+\n+    let should_not_lint = const {\n+        if true { 1 } else { 0 }\n+    };\n+\n     some_fn(a);\n }\n "}, {"sha": "709a18d63e401c00f5f7a2d974dfaef8fd3d80cf", "filename": "src/tools/clippy/tests/ui/bool_to_int_with_if.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_to_int_with_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_to_int_with_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_to_int_with_if.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,6 +1,6 @@\n //@run-rustfix\n \n-#![feature(let_chains)]\n+#![feature(let_chains, inline_const)]\n #![warn(clippy::bool_to_int_with_if)]\n #![allow(unused, dead_code, clippy::unnecessary_operation, clippy::no_effect)]\n \n@@ -111,6 +111,13 @@ fn main() {\n \n     pub const SHOULD_NOT_LINT: usize = if true { 1 } else { 0 };\n \n+    // https://github.com/rust-lang/rust-clippy/issues/10452\n+    let should_not_lint = [(); if true { 1 } else { 0 }];\n+\n+    let should_not_lint = const {\n+        if true { 1 } else { 0 }\n+    };\n+\n     some_fn(a);\n }\n "}, {"sha": "3bdae75cad22b037d7d03c1325a3663ea0a0e2a6", "filename": "src/tools/clippy/tests/ui/bool_to_int_with_if.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_to_int_with_if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_to_int_with_if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_to_int_with_if.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -98,7 +98,7 @@ LL | |     };\n    = note: `!b as i32` or `(!b).into()` can also be valid options\n \n error: boolean to int conversion using if\n-  --> $DIR/bool_to_int_with_if.rs:119:5\n+  --> $DIR/bool_to_int_with_if.rs:126:5\n    |\n LL |     if a { 1 } else { 0 }\n    |     ^^^^^^^^^^^^^^^^^^^^^ help: replace with from: `u8::from(a)`"}, {"sha": "e6331290420b47bb5604792fc516a6e755c7112f", "filename": "src/tools/clippy/tests/ui/box_default.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,5 +1,6 @@\n //@run-rustfix\n #![warn(clippy::box_default)]\n+#![allow(clippy::default_constructed_unit_structs)]\n \n #[derive(Default)]\n struct ImplementsDefault;"}, {"sha": "34a05a29c5aa343ff21993aaf256833c2639ef4c", "filename": "src/tools/clippy/tests/ui/box_default.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,5 +1,6 @@\n //@run-rustfix\n #![warn(clippy::box_default)]\n+#![allow(clippy::default_constructed_unit_structs)]\n \n #[derive(Default)]\n struct ImplementsDefault;"}, {"sha": "c9834863601446b21d7325d316111a70ad10e79e", "filename": "src/tools/clippy/tests/ui/box_default.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_default.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,97 +1,97 @@\n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:22:32\n+  --> $DIR/box_default.rs:23:32\n    |\n LL |     let _string: Box<String> = Box::new(Default::default());\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::default()`\n    |\n    = note: `-D clippy::box-default` implied by `-D warnings`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:23:17\n+  --> $DIR/box_default.rs:24:17\n    |\n LL |     let _byte = Box::new(u8::default());\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<u8>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:24:16\n+  --> $DIR/box_default.rs:25:16\n    |\n LL |     let _vec = Box::new(Vec::<u8>::new());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<Vec<u8>>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:25:17\n+  --> $DIR/box_default.rs:26:17\n    |\n LL |     let _impl = Box::new(ImplementsDefault::default());\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<ImplementsDefault>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:26:18\n+  --> $DIR/box_default.rs:27:18\n    |\n LL |     let _impl2 = Box::new(<ImplementsDefault as Default>::default());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<ImplementsDefault>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:27:42\n+  --> $DIR/box_default.rs:28:42\n    |\n LL |     let _impl3: Box<ImplementsDefault> = Box::new(Default::default());\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:29:28\n+  --> $DIR/box_default.rs:30:28\n    |\n LL |     let _in_macro = outer!(Box::new(String::new()));\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<String>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:30:34\n+  --> $DIR/box_default.rs:31:34\n    |\n LL |     let _string_default = outer!(Box::new(String::from(\"\")));\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<String>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:31:46\n+  --> $DIR/box_default.rs:32:46\n    |\n LL |     let _vec2: Box<Vec<ImplementsDefault>> = Box::new(vec![]);\n    |                                              ^^^^^^^^^^^^^^^^ help: try: `Box::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:32:33\n+  --> $DIR/box_default.rs:33:33\n    |\n LL |     let _vec3: Box<Vec<bool>> = Box::new(Vec::from([]));\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:33:25\n+  --> $DIR/box_default.rs:34:25\n    |\n LL |     let _vec4: Box<_> = Box::new(Vec::from([false; 0]));\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<Vec<bool>>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:35:16\n+  --> $DIR/box_default.rs:36:16\n    |\n LL |     call_ty_fn(Box::new(u8::default()));\n    |                ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:40:5\n+  --> $DIR/box_default.rs:41:5\n    |\n LL |     Box::new(bool::default())\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<bool>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:57:28\n+  --> $DIR/box_default.rs:58:28\n    |\n LL |     let _: Box<dyn Read> = Box::new(ImplementsDefault::default());\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<ImplementsDefault>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:66:17\n+  --> $DIR/box_default.rs:67:17\n    |\n LL |         let _ = Box::new(WeirdPathed::default());\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<WeirdPathed>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:78:18\n+  --> $DIR/box_default.rs:79:18\n    |\n LL |             Some(Box::new(Foo::default()))\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<Foo>::default()`"}, {"sha": "b77f01883bf38f9ab16da9a63a5e760930b3a172", "filename": "src/tools/clippy/tests/ui/cast_slice_different_sizes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_slice_different_sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_slice_different_sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_slice_different_sizes.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -23,7 +23,7 @@ fn main() {\n         r_x as *const [i32]\n     } as *const [u8];\n \n-    // Check that resores of the same size are detected through blocks\n+    // Check that resources of the same size are detected through blocks\n     let restore_block_1 = { r_x as *const [i32] } as *const [u8] as *const [u32];\n     let restore_block_2 = { ({ r_x as *const [i32] }) as *const [u8] } as *const [u32];\n     let restore_block_3 = {"}, {"sha": "4d8698d383ba51ec8ac67712109b87292daac0e4", "filename": "src/tools/clippy/tests/ui/crashes/ice-10645.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-10645.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-10645.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-10645.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,7 @@\n+// compile-flags: --cap-lints=warn\n+// https://github.com/rust-lang/rust-clippy/issues/10645\n+\n+#![warn(clippy::future_not_send)]\n+pub async fn bar<'a, T: 'a>(_: T) {}\n+\n+fn main() {}"}, {"sha": "fc084e30d7fe8aff89f6f9c48f45ca86189b58f5", "filename": "src/tools/clippy/tests/ui/crashes/ice-10645.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-10645.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-10645.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-10645.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,11 +1,11 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/ice-5207.rs:6:35\n+  --> $DIR/ice-10645.rs:5:35\n    |\n LL | pub async fn bar<'a, T: 'a>(_: T) {}\n    |                                   ^ future returned by `bar` is not `Send`\n    |\n note: captured value is not `Send`\n-  --> $DIR/ice-5207.rs:6:29\n+  --> $DIR/ice-10645.rs:5:29\n    |\n LL | pub async fn bar<'a, T: 'a>(_: T) {}\n    |                             ^ has type `T` which is not `Send`", "previous_filename": "src/tools/clippy/tests/ui/crashes/ice-5207.stderr"}, {"sha": "0df8b88fea2f9a7dce7510de77a31736a4cd1651", "filename": "src/tools/clippy/tests/ui/crashes/ice-5207.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-5207.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-5207.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-5207.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,8 +1,4 @@\n-// compile-flags: --cap-lints=warn\n-// ^ for https://github.com/rust-lang/rust-clippy/issues/10645\n-\n // Regression test for https://github.com/rust-lang/rust-clippy/issues/5207\n-#![warn(clippy::future_not_send)]\n pub async fn bar<'a, T: 'a>(_: T) {}\n \n fn main() {}"}, {"sha": "30e4b11ec0bd450bcebc7c57465649e037f45e21", "filename": "src/tools/clippy/tests/ui/crashes/ice_exact_size.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice_exact_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice_exact_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice_exact_size.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "previous_filename": "src/tools/clippy/tests/ui/crashes/ice_exacte_size.rs"}, {"sha": "4c2d1ea48e1192284417b679e145ab4c3ba71423", "filename": "src/tools/clippy/tests/ui/default_constructed_unit_structs.fixed", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,119 @@\n+//@run-rustfix\n+\n+#![allow(unused)]\n+#![warn(clippy::default_constructed_unit_structs)]\n+use std::marker::PhantomData;\n+\n+#[derive(Default)]\n+struct UnitStruct;\n+\n+impl UnitStruct {\n+    fn new() -> Self {\n+        //should lint\n+        Self\n+    }\n+}\n+\n+#[derive(Default)]\n+struct TupleStruct(usize);\n+\n+impl TupleStruct {\n+    fn new() -> Self {\n+        // should not lint\n+        Self(Default::default())\n+    }\n+}\n+\n+// no lint for derived impl\n+#[derive(Default)]\n+struct NormalStruct {\n+    inner: PhantomData<usize>,\n+}\n+\n+struct NonDefaultStruct;\n+\n+impl NonDefaultStruct {\n+    fn default() -> Self {\n+        Self\n+    }\n+}\n+\n+#[derive(Default)]\n+enum SomeEnum {\n+    #[default]\n+    Unit,\n+    Tuple(UnitStruct),\n+    Struct {\n+        inner: usize,\n+    },\n+}\n+\n+impl NormalStruct {\n+    fn new() -> Self {\n+        // should lint\n+        Self {\n+            inner: PhantomData,\n+        }\n+    }\n+\n+    fn new2() -> Self {\n+        // should not lint\n+        Self {\n+            inner: Default::default(),\n+        }\n+    }\n+}\n+\n+#[derive(Default)]\n+struct GenericStruct<T> {\n+    t: T,\n+}\n+\n+impl<T: Default> GenericStruct<T> {\n+    fn new() -> Self {\n+        // should not lint\n+        Self { t: T::default() }\n+    }\n+\n+    fn new2() -> Self {\n+        // should not lint\n+        Self { t: Default::default() }\n+    }\n+}\n+\n+struct FakeDefault;\n+impl FakeDefault {\n+    fn default() -> Self {\n+        Self\n+    }\n+}\n+\n+impl Default for FakeDefault {\n+    fn default() -> Self {\n+        Self\n+    }\n+}\n+\n+#[derive(Default)]\n+struct EmptyStruct {}\n+\n+#[derive(Default)]\n+#[non_exhaustive]\n+struct NonExhaustiveStruct;\n+\n+fn main() {\n+    // should lint\n+    let _ = PhantomData::<usize>;\n+    let _: PhantomData<i32> = PhantomData;\n+    let _ = UnitStruct;\n+\n+    // should not lint\n+    let _ = TupleStruct::default();\n+    let _ = NormalStruct::default();\n+    let _ = NonExhaustiveStruct::default();\n+    let _ = SomeEnum::default();\n+    let _ = NonDefaultStruct::default();\n+    let _ = EmptyStruct::default();\n+    let _ = FakeDefault::default();\n+    let _ = <FakeDefault as Default>::default();\n+}"}, {"sha": "850793dd5de81a32e4494474240adfc02d90ac05", "filename": "src/tools/clippy/tests/ui/default_constructed_unit_structs.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,119 @@\n+//@run-rustfix\n+\n+#![allow(unused)]\n+#![warn(clippy::default_constructed_unit_structs)]\n+use std::marker::PhantomData;\n+\n+#[derive(Default)]\n+struct UnitStruct;\n+\n+impl UnitStruct {\n+    fn new() -> Self {\n+        //should lint\n+        Self::default()\n+    }\n+}\n+\n+#[derive(Default)]\n+struct TupleStruct(usize);\n+\n+impl TupleStruct {\n+    fn new() -> Self {\n+        // should not lint\n+        Self(Default::default())\n+    }\n+}\n+\n+// no lint for derived impl\n+#[derive(Default)]\n+struct NormalStruct {\n+    inner: PhantomData<usize>,\n+}\n+\n+struct NonDefaultStruct;\n+\n+impl NonDefaultStruct {\n+    fn default() -> Self {\n+        Self\n+    }\n+}\n+\n+#[derive(Default)]\n+enum SomeEnum {\n+    #[default]\n+    Unit,\n+    Tuple(UnitStruct),\n+    Struct {\n+        inner: usize,\n+    },\n+}\n+\n+impl NormalStruct {\n+    fn new() -> Self {\n+        // should lint\n+        Self {\n+            inner: PhantomData::default(),\n+        }\n+    }\n+\n+    fn new2() -> Self {\n+        // should not lint\n+        Self {\n+            inner: Default::default(),\n+        }\n+    }\n+}\n+\n+#[derive(Default)]\n+struct GenericStruct<T> {\n+    t: T,\n+}\n+\n+impl<T: Default> GenericStruct<T> {\n+    fn new() -> Self {\n+        // should not lint\n+        Self { t: T::default() }\n+    }\n+\n+    fn new2() -> Self {\n+        // should not lint\n+        Self { t: Default::default() }\n+    }\n+}\n+\n+struct FakeDefault;\n+impl FakeDefault {\n+    fn default() -> Self {\n+        Self\n+    }\n+}\n+\n+impl Default for FakeDefault {\n+    fn default() -> Self {\n+        Self\n+    }\n+}\n+\n+#[derive(Default)]\n+struct EmptyStruct {}\n+\n+#[derive(Default)]\n+#[non_exhaustive]\n+struct NonExhaustiveStruct;\n+\n+fn main() {\n+    // should lint\n+    let _ = PhantomData::<usize>::default();\n+    let _: PhantomData<i32> = PhantomData::default();\n+    let _ = UnitStruct::default();\n+\n+    // should not lint\n+    let _ = TupleStruct::default();\n+    let _ = NormalStruct::default();\n+    let _ = NonExhaustiveStruct::default();\n+    let _ = SomeEnum::default();\n+    let _ = NonDefaultStruct::default();\n+    let _ = EmptyStruct::default();\n+    let _ = FakeDefault::default();\n+    let _ = <FakeDefault as Default>::default();\n+}"}, {"sha": "4058943d08727eae7a8aa072c234b39396e1c49a", "filename": "src/tools/clippy/tests/ui/default_constructed_unit_structs.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_constructed_unit_structs.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,34 @@\n+error: use of `default` to create a unit struct\n+  --> $DIR/default_constructed_unit_structs.rs:13:13\n+   |\n+LL |         Self::default()\n+   |             ^^^^^^^^^^^ help: remove this call to `default`\n+   |\n+   = note: `-D clippy::default-constructed-unit-structs` implied by `-D warnings`\n+\n+error: use of `default` to create a unit struct\n+  --> $DIR/default_constructed_unit_structs.rs:55:31\n+   |\n+LL |             inner: PhantomData::default(),\n+   |                               ^^^^^^^^^^^ help: remove this call to `default`\n+\n+error: use of `default` to create a unit struct\n+  --> $DIR/default_constructed_unit_structs.rs:106:33\n+   |\n+LL |     let _ = PhantomData::<usize>::default();\n+   |                                 ^^^^^^^^^^^ help: remove this call to `default`\n+\n+error: use of `default` to create a unit struct\n+  --> $DIR/default_constructed_unit_structs.rs:107:42\n+   |\n+LL |     let _: PhantomData<i32> = PhantomData::default();\n+   |                                          ^^^^^^^^^^^ help: remove this call to `default`\n+\n+error: use of `default` to create a unit struct\n+  --> $DIR/default_constructed_unit_structs.rs:108:23\n+   |\n+LL |     let _ = UnitStruct::default();\n+   |                       ^^^^^^^^^^^ help: remove this call to `default`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "a42c6383ccea2091126a93dfc2cfef371b534640", "filename": "src/tools/clippy/tests/ui/floating_point_arithmetic_nostd.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_arithmetic_nostd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_arithmetic_nostd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_arithmetic_nostd.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,31 @@\n+#![feature(lang_items, start)]\n+#![warn(clippy::imprecise_flops)]\n+#![warn(clippy::suboptimal_flops)]\n+#![no_std]\n+\n+// The following should not lint, as the suggested methods {f32,f64}.mul_add()\n+// and {f32,f64}::abs() are not available in no_std\n+\n+pub fn mul_add() {\n+    let a: f64 = 1234.567;\n+    let b: f64 = 45.67834;\n+    let c: f64 = 0.0004;\n+    let _ = a * b + c;\n+}\n+\n+fn fake_abs1(num: f64) -> f64 {\n+    if num >= 0.0 { num } else { -num }\n+}\n+\n+#[start]\n+fn main(_argc: isize, _argv: *const *const u8) -> isize {\n+    0\n+}\n+\n+#[panic_handler]\n+fn panic(_info: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}\n+\n+#[lang = \"eh_personality\"]\n+extern \"C\" fn eh_personality() {}"}, {"sha": "d18f93875658c90105d6cc7572c7facfdf915a46", "filename": "src/tools/clippy/tests/ui/from_over_into.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_over_into.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_over_into.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_over_into.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -32,7 +32,7 @@ struct SelfKeywords;\n \n impl From<X> for SelfKeywords {\n     fn from(val: X) -> Self {\n-        let _ = X::default();\n+        let _ = X;\n         let _ = X::FOO;\n         let _: X = val;\n "}, {"sha": "de8ff0b06bdca3a744dc467aeaeda58f969673ce", "filename": "src/tools/clippy/tests/ui/from_over_into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_over_into.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -32,7 +32,7 @@ struct SelfKeywords;\n \n impl Into<SelfKeywords> for X {\n     fn into(self) -> SelfKeywords {\n-        let _ = Self::default();\n+        let _ = Self;\n         let _ = Self::FOO;\n         let _: Self = self;\n "}, {"sha": "6039f86fe6703d05d7f58b3f1d44be113287efec", "filename": "src/tools/clippy/tests/ui/from_over_into.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_over_into.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_over_into.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_over_into.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -5,7 +5,7 @@ LL | impl Into<StringWrapper> for String {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::from-over-into` implied by `-D warnings`\n-help: replace the `Into` implentation with `From<std::string::String>`\n+help: replace the `Into` implementation with `From<std::string::String>`\n    |\n LL ~ impl From<String> for StringWrapper {\n LL ~     fn from(val: String) -> Self {\n@@ -18,7 +18,7 @@ error: an implementation of `From` is preferred since it gives you `Into<_>` for\n LL | impl Into<SelfType> for String {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace the `Into` implentation with `From<std::string::String>`\n+help: replace the `Into` implementation with `From<std::string::String>`\n    |\n LL ~ impl From<String> for SelfType {\n LL ~     fn from(val: String) -> Self {\n@@ -31,11 +31,11 @@ error: an implementation of `From` is preferred since it gives you `Into<_>` for\n LL | impl Into<SelfKeywords> for X {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace the `Into` implentation with `From<X>`\n+help: replace the `Into` implementation with `From<X>`\n    |\n LL ~ impl From<X> for SelfKeywords {\n LL ~     fn from(val: X) -> Self {\n-LL ~         let _ = X::default();\n+LL ~         let _ = X;\n LL ~         let _ = X::FOO;\n LL ~         let _: X = val;\n    |\n@@ -48,7 +48,7 @@ LL | impl core::convert::Into<bool> for crate::ExplicitPaths {\n    |\n    = help: `impl From<Local> for Foreign` is allowed by the orphan rules, for more information see\n            https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence\n-help: replace the `Into` implentation with `From<ExplicitPaths>`\n+help: replace the `Into` implementation with `From<ExplicitPaths>`\n    |\n LL ~ impl core::convert::From<crate::ExplicitPaths> for bool {\n LL ~     fn from(mut val: crate::ExplicitPaths) -> Self {\n@@ -64,7 +64,7 @@ error: an implementation of `From` is preferred since it gives you `Into<_>` for\n LL |     impl<T> Into<FromOverInto<T>> for Vec<T> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace the `Into` implentation with `From<std::vec::Vec<T>>`\n+help: replace the `Into` implementation with `From<std::vec::Vec<T>>`\n    |\n LL ~     impl<T> From<Vec<T>> for FromOverInto<T> {\n LL ~         fn from(val: Vec<T>) -> Self {"}, {"sha": "251f1d84e74e367bb4ba268bda75a176d26af35a", "filename": "src/tools/clippy/tests/ui/from_over_into_unfixable.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_over_into_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_over_into_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_over_into_unfixable.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -4,7 +4,7 @@ error: an implementation of `From` is preferred since it gives you `Into<_>` for\n LL | impl Into<InMacro> for String {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: replace the `Into` implentation with `From<std::string::String>`\n+   = help: replace the `Into` implementation with `From<std::string::String>`\n    = note: `-D clippy::from-over-into` implied by `-D warnings`\n \n error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n@@ -13,7 +13,7 @@ error: an implementation of `From` is preferred since it gives you `Into<_>` for\n LL | impl Into<WeirdUpperSelf> for &'static [u8] {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: replace the `Into` implentation with `From<&'static [u8]>`\n+   = help: replace the `Into` implementation with `From<&'static [u8]>`\n \n error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n   --> $DIR/from_over_into_unfixable.rs:28:1\n@@ -23,7 +23,7 @@ LL | impl Into<u8> for ContainsVal {\n    |\n    = help: `impl From<Local> for Foreign` is allowed by the orphan rules, for more information see\n            https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence\n-   = help: replace the `Into` implentation with `From<ContainsVal>`\n+   = help: replace the `Into` implementation with `From<ContainsVal>`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "f328e4d9d04c31d0d70d16d21a07d1613be9d577", "filename": "src/tools/clippy/tests/ui/items_after_test_module/auxiliary/tests.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitems_after_test_module%2Fauxiliary%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitems_after_test_module%2Fauxiliary%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitems_after_test_module%2Fauxiliary%2Ftests.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1 @@\n+fn main() {}"}, {"sha": "5136b2557ec1a6d695b66a4b67181d7ea71f29c6", "filename": "src/tools/clippy/tests/ui/items_after_test_module/block_module.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitems_after_test_module%2Fblock_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitems_after_test_module%2Fblock_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitems_after_test_module%2Fblock_module.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "previous_filename": "src/tools/clippy/tests/ui/items_after_test_module.rs"}, {"sha": "597f1b9510c5649d464d9335dcd4e9cbf3500971", "filename": "src/tools/clippy/tests/ui/items_after_test_module/block_module.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitems_after_test_module%2Fblock_module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitems_after_test_module%2Fblock_module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitems_after_test_module%2Fblock_module.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,5 +1,5 @@\n error: items were found after the testing module\n-  --> $DIR/items_after_test_module.rs:13:1\n+  --> $DIR/block_module.rs:13:1\n    |\n LL | / mod tests {\n LL | |     #[test]", "previous_filename": "src/tools/clippy/tests/ui/items_after_test_module.stderr"}, {"sha": "6a757aef48e79cdcfbcf451bfe34fb96eda0c9bd", "filename": "src/tools/clippy/tests/ui/items_after_test_module/imported_module.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitems_after_test_module%2Fimported_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitems_after_test_module%2Fimported_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fitems_after_test_module%2Fimported_module.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,20 @@\n+//@compile-flags: --test\n+#![allow(unused)]\n+#![warn(clippy::items_after_test_module)]\n+\n+// Nothing here should lint, as `tests` is an imported module (that has no body).\n+\n+fn main() {}\n+\n+fn should_not_lint() {}\n+\n+#[path = \"auxiliary/tests.rs\"]\n+#[cfg(test)]\n+mod tests; // Should not lint\n+\n+fn should_not_lint2() {}\n+\n+const SHOULD_ALSO_NOT_LINT: usize = 1;\n+macro_rules! should_not_lint {\n+    () => {};\n+}"}, {"sha": "6844cb998f72a2a73896749c4b434c334f8eb454", "filename": "src/tools/clippy/tests/ui/let_underscore_untyped.stderr", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_underscore_untyped.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_underscore_untyped.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_underscore_untyped.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -4,7 +4,11 @@ error: non-binding `let` without a type annotation\n LL |     let _ = a();\n    |     ^^^^^^^^^^^^\n    |\n-   = help: consider adding a type annotation or removing the `let` keyword\n+help: consider adding a type annotation\n+  --> $DIR/let_underscore_untyped.rs:36:10\n+   |\n+LL |     let _ = a();\n+   |          ^\n    = note: `-D clippy::let-underscore-untyped` implied by `-D warnings`\n \n error: non-binding `let` without a type annotation\n@@ -13,31 +17,47 @@ error: non-binding `let` without a type annotation\n LL |     let _ = b(1);\n    |     ^^^^^^^^^^^^^\n    |\n-   = help: consider adding a type annotation or removing the `let` keyword\n+help: consider adding a type annotation\n+  --> $DIR/let_underscore_untyped.rs:37:10\n+   |\n+LL |     let _ = b(1);\n+   |          ^\n \n error: non-binding `let` without a type annotation\n   --> $DIR/let_underscore_untyped.rs:39:5\n    |\n LL |     let _ = d(&1);\n    |     ^^^^^^^^^^^^^^\n    |\n-   = help: consider adding a type annotation or removing the `let` keyword\n+help: consider adding a type annotation\n+  --> $DIR/let_underscore_untyped.rs:39:10\n+   |\n+LL |     let _ = d(&1);\n+   |          ^\n \n error: non-binding `let` without a type annotation\n   --> $DIR/let_underscore_untyped.rs:40:5\n    |\n LL |     let _ = e();\n    |     ^^^^^^^^^^^^\n    |\n-   = help: consider adding a type annotation or removing the `let` keyword\n+help: consider adding a type annotation\n+  --> $DIR/let_underscore_untyped.rs:40:10\n+   |\n+LL |     let _ = e();\n+   |          ^\n \n error: non-binding `let` without a type annotation\n   --> $DIR/let_underscore_untyped.rs:41:5\n    |\n LL |     let _ = f();\n    |     ^^^^^^^^^^^^\n    |\n-   = help: consider adding a type annotation or removing the `let` keyword\n+help: consider adding a type annotation\n+  --> $DIR/let_underscore_untyped.rs:41:10\n+   |\n+LL |     let _ = f();\n+   |          ^\n \n error: aborting due to 5 previous errors\n "}, {"sha": "7c1835e8cd18f994ca672d613b05bf30d9f31297", "filename": "src/tools/clippy/tests/ui/let_with_type_underscore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_with_type_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_with_type_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_with_type_underscore.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     let _: _ = 2;\n     let x: _ = func();\n \n-    let x = 1; // Will not lint, Rust inferres this to an integer before Clippy\n+    let x = 1; // Will not lint, Rust infers this to an integer before Clippy\n     let x = func();\n     let x: Vec<_> = Vec::<u32>::new();\n     let x: [_; 1] = [1];"}, {"sha": "09fb0d758524e7ffdcfcd5942528a230b1105f28", "filename": "src/tools/clippy/tests/ui/manual_retain.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_retain.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_retain.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_retain.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -23,8 +23,8 @@ fn main() {\n }\n \n fn binary_heap_retain() {\n-    // NOTE: Do not lint now, because binary_heap_retain is nighyly API.\n-    // And we need to add a test case for msrv if we update this implmention.\n+    // NOTE: Do not lint now, because binary_heap_retain is nightly API.\n+    // And we need to add a test case for msrv if we update this implementation.\n     // https://github.com/rust-lang/rust/issues/71503\n     let mut heap = BinaryHeap::from([1, 2, 3]);\n     heap = heap.into_iter().filter(|x| x % 2 == 0).collect();"}, {"sha": "7fee4c95cea5a2fe87bca841bbc98aff702381bb", "filename": "src/tools/clippy/tests/ui/manual_retain.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_retain.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -23,8 +23,8 @@ fn main() {\n }\n \n fn binary_heap_retain() {\n-    // NOTE: Do not lint now, because binary_heap_retain is nighyly API.\n-    // And we need to add a test case for msrv if we update this implmention.\n+    // NOTE: Do not lint now, because binary_heap_retain is nightly API.\n+    // And we need to add a test case for msrv if we update this implementation.\n     // https://github.com/rust-lang/rust/issues/71503\n     let mut heap = BinaryHeap::from([1, 2, 3]);\n     heap = heap.into_iter().filter(|x| x % 2 == 0).collect();"}, {"sha": "8b610919536c0fc26a827b8c722d71bb078de434", "filename": "src/tools/clippy/tests/ui/manual_while_let_some.fixed", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_while_let_some.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_while_let_some.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_while_let_some.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,93 @@\n+//@run-rustfix\n+\n+#![allow(unused)]\n+#![warn(clippy::manual_while_let_some)]\n+\n+struct VecInStruct {\n+    numbers: Vec<i32>,\n+    unrelated: String,\n+}\n+\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn accept_i32(_: i32) {}\n+fn accept_optional_i32(_: Option<i32>) {}\n+fn accept_i32_tuple(_: (i32, i32)) {}\n+\n+fn main() {\n+    let mut numbers = vec![1, 2, 3, 4, 5];\n+    while let Some(number) = numbers.pop() {\n+        \n+    }\n+\n+    let mut val = VecInStruct {\n+        numbers: vec![1, 2, 3, 4, 5],\n+        unrelated: String::new(),\n+    };\n+    while let Some(number) = val.numbers.pop() {\n+        \n+    }\n+\n+    while let Some(element) = numbers.pop() {\n+        accept_i32(element);\n+    }\n+\n+    while let Some(element) = numbers.pop() {\n+        accept_i32(element);\n+    }\n+\n+    // This should not warn. It \"conditionally\" pops elements.\n+    while !numbers.is_empty() {\n+        if true {\n+            accept_i32(numbers.pop().unwrap());\n+        }\n+    }\n+\n+    // This should also not warn. It conditionally pops elements.\n+    while !numbers.is_empty() {\n+        if false {\n+            continue;\n+        }\n+        accept_i32(numbers.pop().unwrap());\n+    }\n+\n+    // This should not warn. It pops elements, but does not unwrap it.\n+    // Might handle the Option in some other arbitrary way.\n+    while !numbers.is_empty() {\n+        accept_optional_i32(numbers.pop());\n+    }\n+\n+    let unrelated_vec: Vec<String> = Vec::new();\n+    // This should not warn. It pops elements from a different vector.\n+    while !unrelated_vec.is_empty() {\n+        accept_i32(numbers.pop().unwrap());\n+    }\n+\n+    macro_rules! generate_loop {\n+        () => {\n+            while !numbers.is_empty() {\n+                accept_i32(numbers.pop().unwrap());\n+            }\n+        };\n+    }\n+    // Do not warn if the loop comes from a macro.\n+    generate_loop!();\n+\n+    // Try other kinds of patterns\n+    let mut numbers = vec![(0, 0), (1, 1), (2, 2)];\n+    while let Some((a, b)) = numbers.pop() {\n+        \n+    }\n+\n+    while let Some(element) = numbers.pop() {\n+        accept_i32_tuple(element);\n+    }\n+\n+    let mut results = vec![Foo { a: 1, b: 2 }, Foo { a: 3, b: 4 }];\n+    while let Some(Foo { a, b }) = results.pop() {\n+        \n+    }\n+}"}, {"sha": "85a0a084a424ff8d7624b712dc2c049c70142111", "filename": "src/tools/clippy/tests/ui/manual_while_let_some.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_while_let_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_while_let_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_while_let_some.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,93 @@\n+//@run-rustfix\n+\n+#![allow(unused)]\n+#![warn(clippy::manual_while_let_some)]\n+\n+struct VecInStruct {\n+    numbers: Vec<i32>,\n+    unrelated: String,\n+}\n+\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn accept_i32(_: i32) {}\n+fn accept_optional_i32(_: Option<i32>) {}\n+fn accept_i32_tuple(_: (i32, i32)) {}\n+\n+fn main() {\n+    let mut numbers = vec![1, 2, 3, 4, 5];\n+    while !numbers.is_empty() {\n+        let number = numbers.pop().unwrap();\n+    }\n+\n+    let mut val = VecInStruct {\n+        numbers: vec![1, 2, 3, 4, 5],\n+        unrelated: String::new(),\n+    };\n+    while !val.numbers.is_empty() {\n+        let number = val.numbers.pop().unwrap();\n+    }\n+\n+    while !numbers.is_empty() {\n+        accept_i32(numbers.pop().unwrap());\n+    }\n+\n+    while !numbers.is_empty() {\n+        accept_i32(numbers.pop().expect(\"\"));\n+    }\n+\n+    // This should not warn. It \"conditionally\" pops elements.\n+    while !numbers.is_empty() {\n+        if true {\n+            accept_i32(numbers.pop().unwrap());\n+        }\n+    }\n+\n+    // This should also not warn. It conditionally pops elements.\n+    while !numbers.is_empty() {\n+        if false {\n+            continue;\n+        }\n+        accept_i32(numbers.pop().unwrap());\n+    }\n+\n+    // This should not warn. It pops elements, but does not unwrap it.\n+    // Might handle the Option in some other arbitrary way.\n+    while !numbers.is_empty() {\n+        accept_optional_i32(numbers.pop());\n+    }\n+\n+    let unrelated_vec: Vec<String> = Vec::new();\n+    // This should not warn. It pops elements from a different vector.\n+    while !unrelated_vec.is_empty() {\n+        accept_i32(numbers.pop().unwrap());\n+    }\n+\n+    macro_rules! generate_loop {\n+        () => {\n+            while !numbers.is_empty() {\n+                accept_i32(numbers.pop().unwrap());\n+            }\n+        };\n+    }\n+    // Do not warn if the loop comes from a macro.\n+    generate_loop!();\n+\n+    // Try other kinds of patterns\n+    let mut numbers = vec![(0, 0), (1, 1), (2, 2)];\n+    while !numbers.is_empty() {\n+        let (a, b) = numbers.pop().unwrap();\n+    }\n+\n+    while !numbers.is_empty() {\n+        accept_i32_tuple(numbers.pop().unwrap());\n+    }\n+\n+    let mut results = vec![Foo { a: 1, b: 2 }, Foo { a: 3, b: 4 }];\n+    while !results.is_empty() {\n+        let Foo { a, b } = results.pop().unwrap();\n+    }\n+}"}, {"sha": "633fe05c49b840c62c03045c1003822edcd020fb", "filename": "src/tools/clippy/tests/ui/manual_while_let_some.stderr", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_while_let_some.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_while_let_some.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_while_let_some.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,87 @@\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/manual_while_let_some.rs:23:9\n+   |\n+LL |         let number = numbers.pop().unwrap();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::manual-while-let-some` implied by `-D warnings`\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(number) = numbers.pop() {\n+LL ~         \n+   |\n+\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/manual_while_let_some.rs:31:9\n+   |\n+LL |         let number = val.numbers.pop().unwrap();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(number) = val.numbers.pop() {\n+LL ~         \n+   |\n+\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/manual_while_let_some.rs:35:20\n+   |\n+LL |         accept_i32(numbers.pop().unwrap());\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(element) = numbers.pop() {\n+LL ~         accept_i32(element);\n+   |\n+\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/manual_while_let_some.rs:39:20\n+   |\n+LL |         accept_i32(numbers.pop().expect(\"\"));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(element) = numbers.pop() {\n+LL ~         accept_i32(element);\n+   |\n+\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/manual_while_let_some.rs:82:9\n+   |\n+LL |         let (a, b) = numbers.pop().unwrap();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some((a, b)) = numbers.pop() {\n+LL ~         \n+   |\n+\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/manual_while_let_some.rs:86:26\n+   |\n+LL |         accept_i32_tuple(numbers.pop().unwrap());\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(element) = numbers.pop() {\n+LL ~         accept_i32_tuple(element);\n+   |\n+\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/manual_while_let_some.rs:91:9\n+   |\n+LL |         let Foo { a, b } = results.pop().unwrap();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(Foo { a, b }) = results.pop() {\n+LL ~         \n+   |\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "3ed31d4d711fac4b0ce60d5e583cb3fa7b2553d3", "filename": "src/tools/clippy/tests/ui/needless_bool_assign.fixed", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool_assign.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool_assign.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool_assign.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,33 @@\n+//@run-rustfix\n+\n+#![allow(unused)]\n+#![warn(clippy::needless_bool_assign)]\n+\n+fn random() -> bool {\n+    true\n+}\n+\n+fn main() {\n+    struct Data {\n+        field: bool,\n+    };\n+    let mut a = Data { field: false };\n+    a.field = random() && random();\n+    a.field = !(random() && random());\n+    // Do not lint\u2026\n+    if random() {\n+        a.field = false;\n+    } else {\n+        // \u2026to avoid losing this comment\n+        a.field = true\n+    }\n+    // This one also triggers lint `clippy::if_same_then_else`\n+    // which does not suggest a rewrite.\n+    random(); a.field = true;\n+    let mut b = false;\n+    if random() {\n+        a.field = false;\n+    } else {\n+        b = true;\n+    }\n+}"}, {"sha": "efaeb67fa45de3ec84ce22d9292f95f565618a25", "filename": "src/tools/clippy/tests/ui/needless_bool_assign.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool_assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool_assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool_assign.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,45 @@\n+//@run-rustfix\n+\n+#![allow(unused)]\n+#![warn(clippy::needless_bool_assign)]\n+\n+fn random() -> bool {\n+    true\n+}\n+\n+fn main() {\n+    struct Data {\n+        field: bool,\n+    };\n+    let mut a = Data { field: false };\n+    if random() && random() {\n+        a.field = true;\n+    } else {\n+        a.field = false\n+    }\n+    if random() && random() {\n+        a.field = false;\n+    } else {\n+        a.field = true\n+    }\n+    // Do not lint\u2026\n+    if random() {\n+        a.field = false;\n+    } else {\n+        // \u2026to avoid losing this comment\n+        a.field = true\n+    }\n+    // This one also triggers lint `clippy::if_same_then_else`\n+    // which does not suggest a rewrite.\n+    if random() {\n+        a.field = true;\n+    } else {\n+        a.field = true;\n+    }\n+    let mut b = false;\n+    if random() {\n+        a.field = false;\n+    } else {\n+        b = true;\n+    }\n+}"}, {"sha": "601bbed5493b9d64746df4c47fa9e16417607723", "filename": "src/tools/clippy/tests/ui/needless_bool_assign.stderr", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool_assign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool_assign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_bool_assign.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,53 @@\n+error: this if-then-else expression assigns a bool literal\n+  --> $DIR/needless_bool_assign.rs:15:5\n+   |\n+LL | /     if random() && random() {\n+LL | |         a.field = true;\n+LL | |     } else {\n+LL | |         a.field = false\n+LL | |     }\n+   | |_____^ help: you can reduce it to: `a.field = random() && random();`\n+   |\n+   = note: `-D clippy::needless-bool-assign` implied by `-D warnings`\n+\n+error: this if-then-else expression assigns a bool literal\n+  --> $DIR/needless_bool_assign.rs:20:5\n+   |\n+LL | /     if random() && random() {\n+LL | |         a.field = false;\n+LL | |     } else {\n+LL | |         a.field = true\n+LL | |     }\n+   | |_____^ help: you can reduce it to: `a.field = !(random() && random());`\n+\n+error: this if-then-else expression assigns a bool literal\n+  --> $DIR/needless_bool_assign.rs:34:5\n+   |\n+LL | /     if random() {\n+LL | |         a.field = true;\n+LL | |     } else {\n+LL | |         a.field = true;\n+LL | |     }\n+   | |_____^ help: you can reduce it to: `random(); a.field = true;`\n+\n+error: this `if` has identical blocks\n+  --> $DIR/needless_bool_assign.rs:34:17\n+   |\n+LL |       if random() {\n+   |  _________________^\n+LL | |         a.field = true;\n+LL | |     } else {\n+   | |_____^\n+   |\n+note: same as this\n+  --> $DIR/needless_bool_assign.rs:36:12\n+   |\n+LL |       } else {\n+   |  ____________^\n+LL | |         a.field = true;\n+LL | |     }\n+   | |_____^\n+   = note: `#[deny(clippy::if_same_then_else)]` on by default\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "92572942bc0d456fef2f1676b3c244addd08d0cd", "filename": "src/tools/clippy/tests/ui/needless_for_each_fixable.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_for_each_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_for_each_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_for_each_fixable.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -110,7 +110,7 @@ fn should_not_lint() {\n         }),\n     }\n \n-    // `for_each` is in a let bingind.\n+    // `for_each` is in a let binding.\n     let _ = v.iter().for_each(|elem| {\n         acc += elem;\n     });"}, {"sha": "95acbdff8cc2342135cd831dcd17dc83149b52af", "filename": "src/tools/clippy/tests/ui/needless_for_each_fixable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_for_each_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_for_each_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_for_each_fixable.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -110,7 +110,7 @@ fn should_not_lint() {\n         }),\n     }\n \n-    // `for_each` is in a let bingind.\n+    // `for_each` is in a let binding.\n     let _ = v.iter().for_each(|elem| {\n         acc += elem;\n     });"}, {"sha": "818119f7be579bfff0eb229b20db143d33cda04b", "filename": "src/tools/clippy/tests/ui/no_mangle_with_rust_abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fno_mangle_with_rust_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fno_mangle_with_rust_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fno_mangle_with_rust_abi.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -25,7 +25,7 @@ fn rust_abi_multiline_function_really_long_name_to_overflow_args_to_multiple_lin\n     0\n }\n \n-// Must not run on functions that explicitly opt in to Rust ABI with `extern \"Rust\"`\n+// Must not run on functions that explicitly opt in to using the Rust ABI with `extern \"Rust\"`\n #[no_mangle]\n #[rustfmt::skip]\n extern \"Rust\" fn rust_abi_fn_explicit_opt_in(arg_one: u32, arg_two: usize) {}"}, {"sha": "57f341e0276c5e03082815422ba91cffbfe8f8eb", "filename": "src/tools/clippy/tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -97,7 +97,7 @@ enum DummyEnum {\n     Two,\n }\n \n-// should not warn since there is a compled complex subpat\n+// should not warn since there is a complex subpat\n // see #7991\n fn complex_subpat() -> DummyEnum {\n     let x = Some(DummyEnum::One(1));"}, {"sha": "19f9f70451796914a3eccc967b4beba39c4fde17", "filename": "src/tools/clippy/tests/ui/option_if_let_else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -120,7 +120,7 @@ enum DummyEnum {\n     Two,\n }\n \n-// should not warn since there is a compled complex subpat\n+// should not warn since there is a complex subpat\n // see #7991\n fn complex_subpat() -> DummyEnum {\n     let x = Some(DummyEnum::One(1));"}, {"sha": "d62f7d26a35ccfeee7e723bf545ed68e2ef604e1", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching_option.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_option.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -54,6 +54,8 @@ fn main() {\n     } else {\n         3\n     };\n+\n+    if gen_opt().is_some() {}\n }\n \n fn gen_opt() -> Option<()> {"}, {"sha": "d64294265731bbc225fac437313bdd30160b5ad4", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching_option.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_option.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -63,6 +63,8 @@ fn main() {\n     } else {\n         3\n     };\n+\n+    if let Some(..) = gen_opt() {}\n }\n \n fn gen_opt() -> Option<()> {"}, {"sha": "7c5a047e455cf4f7a919bb9b6285d3fdac96e7f6", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching_option.stderr", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_option.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -89,31 +89,37 @@ LL |     } else if let None = gen_opt() {\n    |            -------^^^^------------ help: try this: `if gen_opt().is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:80:12\n+  --> $DIR/redundant_pattern_matching_option.rs:67:12\n+   |\n+LL |     if let Some(..) = gen_opt() {}\n+   |     -------^^^^^^^^------------ help: try this: `if gen_opt().is_some()`\n+\n+error: redundant pattern matching, consider using `is_some()`\n+  --> $DIR/redundant_pattern_matching_option.rs:82:12\n    |\n LL |     if let Some(_) = Some(42) {}\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:82:12\n+  --> $DIR/redundant_pattern_matching_option.rs:84:12\n    |\n LL |     if let None = None::<()> {}\n    |     -------^^^^------------- help: try this: `if None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:84:15\n+  --> $DIR/redundant_pattern_matching_option.rs:86:15\n    |\n LL |     while let Some(_) = Some(42) {}\n    |     ----------^^^^^^^----------- help: try this: `while Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:86:15\n+  --> $DIR/redundant_pattern_matching_option.rs:88:15\n    |\n LL |     while let None = None::<()> {}\n    |     ----------^^^^------------- help: try this: `while None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:88:5\n+  --> $DIR/redundant_pattern_matching_option.rs:90:5\n    |\n LL | /     match Some(42) {\n LL | |         Some(_) => true,\n@@ -122,7 +128,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:93:5\n+  --> $DIR/redundant_pattern_matching_option.rs:95:5\n    |\n LL | /     match None::<()> {\n LL | |         Some(_) => false,\n@@ -131,16 +137,16 @@ LL | |     };\n    | |_____^ help: try this: `None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:101:12\n+  --> $DIR/redundant_pattern_matching_option.rs:103:12\n    |\n LL |     if let None = *(&None::<()>) {}\n    |     -------^^^^----------------- help: try this: `if (&None::<()>).is_none()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:102:12\n+  --> $DIR/redundant_pattern_matching_option.rs:104:12\n    |\n LL |     if let None = *&None::<()> {}\n    |     -------^^^^--------------- help: try this: `if (&None::<()>).is_none()`\n \n-error: aborting due to 21 previous errors\n+error: aborting due to 22 previous errors\n "}, {"sha": "42a59f6d43dfa483cfde7198fcb37390ea594496", "filename": "src/tools/clippy/tests/ui/rename.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -27,6 +27,7 @@\n #![allow(clippy::module_name_repetitions)]\n #![allow(clippy::recursive_format_impl)]\n #![allow(clippy::invisible_characters)]\n+#![allow(suspicious_double_ref_op)]\n #![allow(drop_bounds)]\n #![allow(for_loops_over_fallibles)]\n #![allow(array_into_iter)]"}, {"sha": "4d173e8cbbfa71f90b7a8f7281db3113e137689c", "filename": "src/tools/clippy/tests/ui/rename.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -27,6 +27,7 @@\n #![allow(clippy::module_name_repetitions)]\n #![allow(clippy::recursive_format_impl)]\n #![allow(clippy::invisible_characters)]\n+#![allow(suspicious_double_ref_op)]\n #![allow(drop_bounds)]\n #![allow(for_loops_over_fallibles)]\n #![allow(array_into_iter)]"}, {"sha": "0da4ed7520c86f5b2ea553a9152905226c674499", "filename": "src/tools/clippy/tests/ui/rename.stderr", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,259 +1,259 @@\n error: lint `clippy::almost_complete_letter_range` has been renamed to `clippy::almost_complete_range`\n-  --> $DIR/rename.rs:43:9\n+  --> $DIR/rename.rs:44:9\n    |\n LL | #![warn(clippy::almost_complete_letter_range)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::almost_complete_range`\n    |\n    = note: `-D renamed-and-removed-lints` implied by `-D warnings`\n \n error: lint `clippy::blacklisted_name` has been renamed to `clippy::disallowed_names`\n-  --> $DIR/rename.rs:44:9\n+  --> $DIR/rename.rs:45:9\n    |\n LL | #![warn(clippy::blacklisted_name)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_names`\n \n error: lint `clippy::block_in_if_condition_expr` has been renamed to `clippy::blocks_in_if_conditions`\n-  --> $DIR/rename.rs:45:9\n+  --> $DIR/rename.rs:46:9\n    |\n LL | #![warn(clippy::block_in_if_condition_expr)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n \n error: lint `clippy::block_in_if_condition_stmt` has been renamed to `clippy::blocks_in_if_conditions`\n-  --> $DIR/rename.rs:46:9\n+  --> $DIR/rename.rs:47:9\n    |\n LL | #![warn(clippy::block_in_if_condition_stmt)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n \n error: lint `clippy::box_vec` has been renamed to `clippy::box_collection`\n-  --> $DIR/rename.rs:47:9\n+  --> $DIR/rename.rs:48:9\n    |\n LL | #![warn(clippy::box_vec)]\n    |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::box_collection`\n \n error: lint `clippy::const_static_lifetime` has been renamed to `clippy::redundant_static_lifetimes`\n-  --> $DIR/rename.rs:48:9\n+  --> $DIR/rename.rs:49:9\n    |\n LL | #![warn(clippy::const_static_lifetime)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::redundant_static_lifetimes`\n \n error: lint `clippy::cyclomatic_complexity` has been renamed to `clippy::cognitive_complexity`\n-  --> $DIR/rename.rs:49:9\n+  --> $DIR/rename.rs:50:9\n    |\n LL | #![warn(clippy::cyclomatic_complexity)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::cognitive_complexity`\n \n error: lint `clippy::derive_hash_xor_eq` has been renamed to `clippy::derived_hash_with_manual_eq`\n-  --> $DIR/rename.rs:50:9\n+  --> $DIR/rename.rs:51:9\n    |\n LL | #![warn(clippy::derive_hash_xor_eq)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::derived_hash_with_manual_eq`\n \n error: lint `clippy::disallowed_method` has been renamed to `clippy::disallowed_methods`\n-  --> $DIR/rename.rs:51:9\n+  --> $DIR/rename.rs:52:9\n    |\n LL | #![warn(clippy::disallowed_method)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_methods`\n \n error: lint `clippy::disallowed_type` has been renamed to `clippy::disallowed_types`\n-  --> $DIR/rename.rs:52:9\n+  --> $DIR/rename.rs:53:9\n    |\n LL | #![warn(clippy::disallowed_type)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_types`\n \n error: lint `clippy::eval_order_dependence` has been renamed to `clippy::mixed_read_write_in_expression`\n-  --> $DIR/rename.rs:53:9\n+  --> $DIR/rename.rs:54:9\n    |\n LL | #![warn(clippy::eval_order_dependence)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::mixed_read_write_in_expression`\n \n error: lint `clippy::identity_conversion` has been renamed to `clippy::useless_conversion`\n-  --> $DIR/rename.rs:54:9\n+  --> $DIR/rename.rs:55:9\n    |\n LL | #![warn(clippy::identity_conversion)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::useless_conversion`\n \n error: lint `clippy::if_let_some_result` has been renamed to `clippy::match_result_ok`\n-  --> $DIR/rename.rs:55:9\n+  --> $DIR/rename.rs:56:9\n    |\n LL | #![warn(clippy::if_let_some_result)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::match_result_ok`\n \n error: lint `clippy::logic_bug` has been renamed to `clippy::overly_complex_bool_expr`\n-  --> $DIR/rename.rs:56:9\n+  --> $DIR/rename.rs:57:9\n    |\n LL | #![warn(clippy::logic_bug)]\n    |         ^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::overly_complex_bool_expr`\n \n error: lint `clippy::new_without_default_derive` has been renamed to `clippy::new_without_default`\n-  --> $DIR/rename.rs:57:9\n+  --> $DIR/rename.rs:58:9\n    |\n LL | #![warn(clippy::new_without_default_derive)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::new_without_default`\n \n error: lint `clippy::option_and_then_some` has been renamed to `clippy::bind_instead_of_map`\n-  --> $DIR/rename.rs:58:9\n+  --> $DIR/rename.rs:59:9\n    |\n LL | #![warn(clippy::option_and_then_some)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::bind_instead_of_map`\n \n error: lint `clippy::option_expect_used` has been renamed to `clippy::expect_used`\n-  --> $DIR/rename.rs:59:9\n+  --> $DIR/rename.rs:60:9\n    |\n LL | #![warn(clippy::option_expect_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::expect_used`\n \n error: lint `clippy::option_map_unwrap_or` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:60:9\n+  --> $DIR/rename.rs:61:9\n    |\n LL | #![warn(clippy::option_map_unwrap_or)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::option_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:61:9\n+  --> $DIR/rename.rs:62:9\n    |\n LL | #![warn(clippy::option_map_unwrap_or_else)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::option_unwrap_used` has been renamed to `clippy::unwrap_used`\n-  --> $DIR/rename.rs:62:9\n+  --> $DIR/rename.rs:63:9\n    |\n LL | #![warn(clippy::option_unwrap_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n \n error: lint `clippy::ref_in_deref` has been renamed to `clippy::needless_borrow`\n-  --> $DIR/rename.rs:63:9\n+  --> $DIR/rename.rs:64:9\n    |\n LL | #![warn(clippy::ref_in_deref)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::needless_borrow`\n \n error: lint `clippy::result_expect_used` has been renamed to `clippy::expect_used`\n-  --> $DIR/rename.rs:64:9\n+  --> $DIR/rename.rs:65:9\n    |\n LL | #![warn(clippy::result_expect_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::expect_used`\n \n error: lint `clippy::result_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:65:9\n+  --> $DIR/rename.rs:66:9\n    |\n LL | #![warn(clippy::result_map_unwrap_or_else)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::result_unwrap_used` has been renamed to `clippy::unwrap_used`\n-  --> $DIR/rename.rs:66:9\n+  --> $DIR/rename.rs:67:9\n    |\n LL | #![warn(clippy::result_unwrap_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n \n error: lint `clippy::single_char_push_str` has been renamed to `clippy::single_char_add_str`\n-  --> $DIR/rename.rs:67:9\n+  --> $DIR/rename.rs:68:9\n    |\n LL | #![warn(clippy::single_char_push_str)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::single_char_add_str`\n \n error: lint `clippy::stutter` has been renamed to `clippy::module_name_repetitions`\n-  --> $DIR/rename.rs:68:9\n+  --> $DIR/rename.rs:69:9\n    |\n LL | #![warn(clippy::stutter)]\n    |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::module_name_repetitions`\n \n error: lint `clippy::to_string_in_display` has been renamed to `clippy::recursive_format_impl`\n-  --> $DIR/rename.rs:69:9\n+  --> $DIR/rename.rs:70:9\n    |\n LL | #![warn(clippy::to_string_in_display)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::recursive_format_impl`\n \n error: lint `clippy::zero_width_space` has been renamed to `clippy::invisible_characters`\n-  --> $DIR/rename.rs:70:9\n+  --> $DIR/rename.rs:71:9\n    |\n LL | #![warn(clippy::zero_width_space)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::invisible_characters`\n \n error: lint `clippy::clone_double_ref` has been renamed to `suspicious_double_ref_op`\n-  --> $DIR/rename.rs:71:9\n+  --> $DIR/rename.rs:72:9\n    |\n LL | #![warn(clippy::clone_double_ref)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `suspicious_double_ref_op`\n \n error: lint `clippy::drop_bounds` has been renamed to `drop_bounds`\n-  --> $DIR/rename.rs:72:9\n+  --> $DIR/rename.rs:73:9\n    |\n LL | #![warn(clippy::drop_bounds)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `drop_bounds`\n \n error: lint `clippy::for_loop_over_option` has been renamed to `for_loops_over_fallibles`\n-  --> $DIR/rename.rs:73:9\n+  --> $DIR/rename.rs:74:9\n    |\n LL | #![warn(clippy::for_loop_over_option)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `for_loops_over_fallibles`\n \n error: lint `clippy::for_loop_over_result` has been renamed to `for_loops_over_fallibles`\n-  --> $DIR/rename.rs:74:9\n+  --> $DIR/rename.rs:75:9\n    |\n LL | #![warn(clippy::for_loop_over_result)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `for_loops_over_fallibles`\n \n error: lint `clippy::for_loops_over_fallibles` has been renamed to `for_loops_over_fallibles`\n-  --> $DIR/rename.rs:75:9\n+  --> $DIR/rename.rs:76:9\n    |\n LL | #![warn(clippy::for_loops_over_fallibles)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `for_loops_over_fallibles`\n \n error: lint `clippy::into_iter_on_array` has been renamed to `array_into_iter`\n-  --> $DIR/rename.rs:76:9\n+  --> $DIR/rename.rs:77:9\n    |\n LL | #![warn(clippy::into_iter_on_array)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `array_into_iter`\n \n error: lint `clippy::invalid_atomic_ordering` has been renamed to `invalid_atomic_ordering`\n-  --> $DIR/rename.rs:77:9\n+  --> $DIR/rename.rs:78:9\n    |\n LL | #![warn(clippy::invalid_atomic_ordering)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_atomic_ordering`\n \n error: lint `clippy::invalid_ref` has been renamed to `invalid_value`\n-  --> $DIR/rename.rs:78:9\n+  --> $DIR/rename.rs:79:9\n    |\n LL | #![warn(clippy::invalid_ref)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_value`\n \n error: lint `clippy::let_underscore_drop` has been renamed to `let_underscore_drop`\n-  --> $DIR/rename.rs:79:9\n+  --> $DIR/rename.rs:80:9\n    |\n LL | #![warn(clippy::let_underscore_drop)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `let_underscore_drop`\n \n error: lint `clippy::mem_discriminant_non_enum` has been renamed to `enum_intrinsics_non_enums`\n-  --> $DIR/rename.rs:80:9\n+  --> $DIR/rename.rs:81:9\n    |\n LL | #![warn(clippy::mem_discriminant_non_enum)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `enum_intrinsics_non_enums`\n \n error: lint `clippy::panic_params` has been renamed to `non_fmt_panics`\n-  --> $DIR/rename.rs:81:9\n+  --> $DIR/rename.rs:82:9\n    |\n LL | #![warn(clippy::panic_params)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `non_fmt_panics`\n \n error: lint `clippy::positional_named_format_parameters` has been renamed to `named_arguments_used_positionally`\n-  --> $DIR/rename.rs:82:9\n+  --> $DIR/rename.rs:83:9\n    |\n LL | #![warn(clippy::positional_named_format_parameters)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `named_arguments_used_positionally`\n \n error: lint `clippy::temporary_cstring_as_ptr` has been renamed to `temporary_cstring_as_ptr`\n-  --> $DIR/rename.rs:83:9\n+  --> $DIR/rename.rs:84:9\n    |\n LL | #![warn(clippy::temporary_cstring_as_ptr)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `temporary_cstring_as_ptr`\n \n error: lint `clippy::unknown_clippy_lints` has been renamed to `unknown_lints`\n-  --> $DIR/rename.rs:84:9\n+  --> $DIR/rename.rs:85:9\n    |\n LL | #![warn(clippy::unknown_clippy_lints)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unknown_lints`\n \n error: lint `clippy::unused_label` has been renamed to `unused_labels`\n-  --> $DIR/rename.rs:85:9\n+  --> $DIR/rename.rs:86:9\n    |\n LL | #![warn(clippy::unused_label)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unused_labels`"}, {"sha": "f31a7e33c4b9ecdf54e6a629fffe56a92c80c20f", "filename": "src/tools/clippy/tests/ui/same_name_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsame_name_method.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -62,7 +62,7 @@ mod should_lint {\n         impl T1 for S {}\n     }\n \n-    mod multiply_conflicit_trait {\n+    mod multiple_conflicting_traits {\n         use crate::{T1, T2};\n \n         struct S;"}, {"sha": "2c0fc3e3fd83ffb8bdd090599162478abb36c01f", "filename": "src/tools/clippy/tests/ui/shadow.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshadow.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -8,6 +8,12 @@ extern crate proc_macro_derive;\n #[derive(proc_macro_derive::ShadowDerive)]\n pub struct Nothing;\n \n+macro_rules! reuse {\n+    ($v:ident) => {\n+        let $v = $v + 1;\n+    };\n+}\n+\n fn shadow_same() {\n     let x = 1;\n     let x = x;\n@@ -33,6 +39,12 @@ fn shadow_reuse() -> Option<()> {\n     None\n }\n \n+fn shadow_reuse_macro() {\n+    let x = 1;\n+    // this should not warn\n+    reuse!(x);\n+}\n+\n fn shadow_unrelated() {\n     let x = 1;\n     let x = 2;"}, {"sha": "8321f6df224cf8444d39605c81ee3b8b122225a1", "filename": "src/tools/clippy/tests/ui/shadow.stderr", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshadow.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,278 +1,278 @@\n error: `x` is shadowed by itself in `x`\n-  --> $DIR/shadow.rs:13:9\n+  --> $DIR/shadow.rs:19:9\n    |\n LL |     let x = x;\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:12:9\n+  --> $DIR/shadow.rs:18:9\n    |\n LL |     let x = 1;\n    |         ^\n    = note: `-D clippy::shadow-same` implied by `-D warnings`\n \n error: `mut x` is shadowed by itself in `&x`\n-  --> $DIR/shadow.rs:14:13\n+  --> $DIR/shadow.rs:20:13\n    |\n LL |     let mut x = &x;\n    |             ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:13:9\n+  --> $DIR/shadow.rs:19:9\n    |\n LL |     let x = x;\n    |         ^\n \n error: `x` is shadowed by itself in `&mut x`\n-  --> $DIR/shadow.rs:15:9\n+  --> $DIR/shadow.rs:21:9\n    |\n LL |     let x = &mut x;\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:14:9\n+  --> $DIR/shadow.rs:20:9\n    |\n LL |     let mut x = &x;\n    |         ^^^^^\n \n error: `x` is shadowed by itself in `*x`\n-  --> $DIR/shadow.rs:16:9\n+  --> $DIR/shadow.rs:22:9\n    |\n LL |     let x = *x;\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:15:9\n+  --> $DIR/shadow.rs:21:9\n    |\n LL |     let x = &mut x;\n    |         ^\n \n error: `x` is shadowed\n-  --> $DIR/shadow.rs:21:9\n+  --> $DIR/shadow.rs:27:9\n    |\n LL |     let x = x.0;\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:20:9\n+  --> $DIR/shadow.rs:26:9\n    |\n LL |     let x = ([[0]], ());\n    |         ^\n    = note: `-D clippy::shadow-reuse` implied by `-D warnings`\n \n error: `x` is shadowed\n-  --> $DIR/shadow.rs:22:9\n+  --> $DIR/shadow.rs:28:9\n    |\n LL |     let x = x[0];\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:21:9\n+  --> $DIR/shadow.rs:27:9\n    |\n LL |     let x = x.0;\n    |         ^\n \n error: `x` is shadowed\n-  --> $DIR/shadow.rs:23:10\n+  --> $DIR/shadow.rs:29:10\n    |\n LL |     let [x] = x;\n    |          ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:22:9\n+  --> $DIR/shadow.rs:28:9\n    |\n LL |     let x = x[0];\n    |         ^\n \n error: `x` is shadowed\n-  --> $DIR/shadow.rs:24:9\n+  --> $DIR/shadow.rs:30:9\n    |\n LL |     let x = Some(x);\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:23:10\n+  --> $DIR/shadow.rs:29:10\n    |\n LL |     let [x] = x;\n    |          ^\n \n error: `x` is shadowed\n-  --> $DIR/shadow.rs:25:9\n+  --> $DIR/shadow.rs:31:9\n    |\n LL |     let x = foo(x);\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:24:9\n+  --> $DIR/shadow.rs:30:9\n    |\n LL |     let x = Some(x);\n    |         ^\n \n error: `x` is shadowed\n-  --> $DIR/shadow.rs:26:9\n+  --> $DIR/shadow.rs:32:9\n    |\n LL |     let x = || x;\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:25:9\n+  --> $DIR/shadow.rs:31:9\n    |\n LL |     let x = foo(x);\n    |         ^\n \n error: `x` is shadowed\n-  --> $DIR/shadow.rs:27:9\n+  --> $DIR/shadow.rs:33:9\n    |\n LL |     let x = Some(1).map(|_| x)?;\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:26:9\n+  --> $DIR/shadow.rs:32:9\n    |\n LL |     let x = || x;\n    |         ^\n \n error: `y` is shadowed\n-  --> $DIR/shadow.rs:29:9\n+  --> $DIR/shadow.rs:35:9\n    |\n LL |     let y = match y {\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:28:9\n+  --> $DIR/shadow.rs:34:9\n    |\n LL |     let y = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:38:9\n+  --> $DIR/shadow.rs:50:9\n    |\n LL |     let x = 2;\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:37:9\n+  --> $DIR/shadow.rs:49:9\n    |\n LL |     let x = 1;\n    |         ^\n    = note: `-D clippy::shadow-unrelated` implied by `-D warnings`\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:43:13\n+  --> $DIR/shadow.rs:55:13\n    |\n LL |         let x = 1;\n    |             ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:42:10\n+  --> $DIR/shadow.rs:54:10\n    |\n LL |     fn f(x: u32) {\n    |          ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:48:14\n+  --> $DIR/shadow.rs:60:14\n    |\n LL |         Some(x) => {\n    |              ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:45:9\n+  --> $DIR/shadow.rs:57:9\n    |\n LL |     let x = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:49:17\n+  --> $DIR/shadow.rs:61:17\n    |\n LL |             let x = 1;\n    |                 ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:48:14\n+  --> $DIR/shadow.rs:60:14\n    |\n LL |         Some(x) => {\n    |              ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:53:17\n+  --> $DIR/shadow.rs:65:17\n    |\n LL |     if let Some(x) = Some(1) {}\n    |                 ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:45:9\n+  --> $DIR/shadow.rs:57:9\n    |\n LL |     let x = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:54:20\n+  --> $DIR/shadow.rs:66:20\n    |\n LL |     while let Some(x) = Some(1) {}\n    |                    ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:45:9\n+  --> $DIR/shadow.rs:57:9\n    |\n LL |     let x = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:55:15\n+  --> $DIR/shadow.rs:67:15\n    |\n LL |     let _ = |[x]: [u32; 1]| {\n    |               ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:45:9\n+  --> $DIR/shadow.rs:57:9\n    |\n LL |     let x = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:56:13\n+  --> $DIR/shadow.rs:68:13\n    |\n LL |         let x = 1;\n    |             ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:55:15\n+  --> $DIR/shadow.rs:67:15\n    |\n LL |     let _ = |[x]: [u32; 1]| {\n    |               ^\n \n error: `y` is shadowed\n-  --> $DIR/shadow.rs:59:17\n+  --> $DIR/shadow.rs:71:17\n    |\n LL |     if let Some(y) = y {}\n    |                 ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:58:9\n+  --> $DIR/shadow.rs:70:9\n    |\n LL |     let y = Some(1);\n    |         ^\n \n error: `_b` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:95:9\n+  --> $DIR/shadow.rs:107:9\n    |\n LL |     let _b = _a;\n    |         ^^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:94:28\n+  --> $DIR/shadow.rs:106:28\n    |\n LL | pub async fn foo2(_a: i32, _b: i64) {\n    |                            ^^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:101:21\n+  --> $DIR/shadow.rs:113:21\n    |\n LL |         if let Some(x) = Some(1) { x } else { 1 }\n    |                     ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:100:13\n+  --> $DIR/shadow.rs:112:13\n    |\n LL |         let x = 1;\n    |             ^"}, {"sha": "3fc11b8b0885e9070944e97d74cc9fa6ddb6a42e", "filename": "src/tools/clippy/tests/ui/string_lit_as_bytes.fixed", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,8 +1,18 @@\n //@run-rustfix\n+//@aux-build:macro_rules.rs\n \n #![allow(dead_code, unused_variables)]\n #![warn(clippy::string_lit_as_bytes)]\n \n+#[macro_use]\n+extern crate macro_rules;\n+\n+macro_rules! b {\n+    ($b:literal) => {\n+        const B: &[u8] = b\"warning\";\n+    };\n+}\n+\n fn str_lit_as_bytes() {\n     let bs = b\"hello there\";\n \n@@ -11,6 +21,10 @@ fn str_lit_as_bytes() {\n     let bs = b\"lit to string\".to_vec();\n     let bs = b\"lit to owned\".to_vec();\n \n+    b!(\"warning\");\n+\n+    string_lit_as_bytes!(\"no warning\");\n+\n     // no warning, because these cannot be written as byte string literals:\n     let ubs = \"\u2603\".as_bytes();\n     let ubs = \"hello there! this is a very long string\".as_bytes();"}, {"sha": "7d54acf630e6cf06d0ffad3298b2809245407e6e", "filename": "src/tools/clippy/tests/ui/string_lit_as_bytes.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,8 +1,18 @@\n //@run-rustfix\n+//@aux-build:macro_rules.rs\n \n #![allow(dead_code, unused_variables)]\n #![warn(clippy::string_lit_as_bytes)]\n \n+#[macro_use]\n+extern crate macro_rules;\n+\n+macro_rules! b {\n+    ($b:literal) => {\n+        const B: &[u8] = $b.as_bytes();\n+    };\n+}\n+\n fn str_lit_as_bytes() {\n     let bs = \"hello there\".as_bytes();\n \n@@ -11,6 +21,10 @@ fn str_lit_as_bytes() {\n     let bs = \"lit to string\".to_string().into_bytes();\n     let bs = \"lit to owned\".to_owned().into_bytes();\n \n+    b!(\"warning\");\n+\n+    string_lit_as_bytes!(\"no warning\");\n+\n     // no warning, because these cannot be written as byte string literals:\n     let ubs = \"\u2603\".as_bytes();\n     let ubs = \"hello there! this is a very long string\".as_bytes();"}, {"sha": "61b4e210e0fb94d6c0173faf863016639a8b0733", "filename": "src/tools/clippy/tests/ui/string_lit_as_bytes.stderr", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,40 +1,51 @@\n error: calling `as_bytes()` on a string literal\n-  --> $DIR/string_lit_as_bytes.rs:7:14\n+  --> $DIR/string_lit_as_bytes.rs:17:14\n    |\n LL |     let bs = \"hello there\".as_bytes();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using a byte string literal instead: `b\"hello there\"`\n    |\n    = note: `-D clippy::string-lit-as-bytes` implied by `-D warnings`\n \n error: calling `as_bytes()` on a string literal\n-  --> $DIR/string_lit_as_bytes.rs:9:14\n+  --> $DIR/string_lit_as_bytes.rs:19:14\n    |\n LL |     let bs = r###\"raw string with 3# plus \" \"\"###.as_bytes();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using a byte string literal instead: `br###\"raw string with 3# plus \" \"\"###`\n \n error: calling `into_bytes()` on a string literal\n-  --> $DIR/string_lit_as_bytes.rs:11:14\n+  --> $DIR/string_lit_as_bytes.rs:21:14\n    |\n LL |     let bs = \"lit to string\".to_string().into_bytes();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using a byte string literal instead: `b\"lit to string\".to_vec()`\n \n error: calling `into_bytes()` on a string literal\n-  --> $DIR/string_lit_as_bytes.rs:12:14\n+  --> $DIR/string_lit_as_bytes.rs:22:14\n    |\n LL |     let bs = \"lit to owned\".to_owned().into_bytes();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using a byte string literal instead: `b\"lit to owned\".to_vec()`\n \n+error: calling `as_bytes()` on a string literal\n+  --> $DIR/string_lit_as_bytes.rs:12:26\n+   |\n+LL |         const B: &[u8] = $b.as_bytes();\n+   |                          ^^^^^^^^^^^^^ help: consider using a byte string literal instead: `b\"warning\"`\n+...\n+LL |     b!(\"warning\");\n+   |     ------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `b` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error: calling `as_bytes()` on `include_str!(..)`\n-  --> $DIR/string_lit_as_bytes.rs:25:22\n+  --> $DIR/string_lit_as_bytes.rs:39:22\n    |\n LL |     let includestr = include_str!(\"string_lit_as_bytes.rs\").as_bytes();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `include_bytes!(..)` instead: `include_bytes!(\"string_lit_as_bytes.rs\")`\n \n error: calling `as_bytes()` on a string literal\n-  --> $DIR/string_lit_as_bytes.rs:27:13\n+  --> $DIR/string_lit_as_bytes.rs:41:13\n    |\n LL |     let _ = \"string with newline/t/n\".as_bytes();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using a byte string literal instead: `b\"string with newline/t/n\"`\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 7 previous errors\n "}, {"sha": "928475b5f35ea584f5c280a94ce685ccefa2f4fc", "filename": "src/tools/clippy/tests/ui/trailing_empty_array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrailing_empty_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrailing_empty_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrailing_empty_array.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -144,7 +144,7 @@ struct ReprCAlign {\n \n // NOTE: because of https://doc.rust-lang.org/stable/reference/type-layout.html#primitive-representation-of-enums-with-fields and I'm not sure when in the compilation pipeline that would happen\n #[repr(C)]\n-enum DontLintAnonymousStructsFromDesuraging {\n+enum DontLintAnonymousStructsFromDesugaring {\n     A(u32),\n     B(f32, [u64; 0]),\n     C { x: u32, y: [u64; 0] },"}, {"sha": "2d567630e15debe7845b45e3e17c8964768e4467", "filename": "src/tools/clippy/tests/ui/uninit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funinit.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -17,10 +17,10 @@ fn main() {\n     // This is OK, because `MaybeUninit` allows uninitialized data.\n     let _: MaybeUninit<usize> = unsafe { MaybeUninit::uninit().assume_init() };\n \n-    // This is OK, because all constitutent types are uninit-compatible.\n+    // This is OK, because all constituent types are uninit-compatible.\n     let _: (MaybeUninit<usize>, MaybeUninit<bool>) = unsafe { MaybeUninit::uninit().assume_init() };\n \n-    // This is OK, because all constitutent types are uninit-compatible.\n+    // This is OK, because all constituent types are uninit-compatible.\n     let _: (MaybeUninit<usize>, [MaybeUninit<bool>; 2]) = unsafe { MaybeUninit::uninit().assume_init() };\n \n     // This is OK, because our own MaybeUninit is just as fine as the one from core."}, {"sha": "20138a29fd1f148072adf6b51445be76e35079b2", "filename": "src/tools/clippy/tests/ui/use_self_trait.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.fixed?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -33,7 +33,7 @@ impl SelfTrait for Bad {\n     fn nested(_p1: Box<Self>, _p2: (&u8, &Self)) {}\n \n     fn vals(_: Self) -> Self {\n-        Self::default()\n+        Self\n     }\n }\n \n@@ -70,7 +70,7 @@ impl SelfTrait for Good {\n     fn nested(_p1: Box<Self>, _p2: (&u8, &Self)) {}\n \n     fn vals(_: Self) -> Self {\n-        Self::default()\n+        Self\n     }\n }\n "}, {"sha": "bf697b01a42f7b6731f68641c756179ed8f29462", "filename": "src/tools/clippy/tests/ui/use_self_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -33,7 +33,7 @@ impl SelfTrait for Bad {\n     fn nested(_p1: Box<Bad>, _p2: (&u8, &Bad)) {}\n \n     fn vals(_: Bad) -> Bad {\n-        Bad::default()\n+        Bad\n     }\n }\n \n@@ -70,7 +70,7 @@ impl SelfTrait for Good {\n     fn nested(_p1: Box<Self>, _p2: (&u8, &Self)) {}\n \n     fn vals(_: Self) -> Self {\n-        Self::default()\n+        Self\n     }\n }\n "}, {"sha": "6257f802dd80a0c4eefb06f3ae4f00bd643dfd2a", "filename": "src/tools/clippy/tests/ui/use_self_trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.stderr?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -63,7 +63,7 @@ LL |     fn vals(_: Bad) -> Bad {\n error: unnecessary structure name repetition\n   --> $DIR/use_self_trait.rs:36:9\n    |\n-LL |         Bad::default()\n+LL |         Bad\n    |         ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition"}, {"sha": "8791debad7231c7d9702a690f0e92a36097b9ec5", "filename": "src/tools/clippy/util/gh-pages/index.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Futil%2Fgh-pages%2Findex.html", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fclippy%2Futil%2Fgh-pages%2Findex.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Futil%2Fgh-pages%2Findex.html?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -564,7 +564,7 @@ <h2 class=\"panel-title\">\n     </div>\n \n     <a href=\"https://github.com/rust-lang/rust-clippy\">\n-        <img style=\"position: absolute; top: 0; right: 0; border: 0; clip-path: polygon(0% 0%, 100% 0%, 100% 100%);\" src=\"https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png\" alt=\"Fork me on Github\"/>\n+        <img style=\"position: absolute; top: 0; right: 0; border: 0; clip-path: polygon(0% 0%, 100% 0%, 100% 100%);\" src=\"https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png\" alt=\"Fork me on GitHub\"/>\n     </a>\n \n     <script src=\"https://cdnjs.cloudflare.com/ajax/libs/markdown-it/12.3.2/markdown-it.min.js\"></script>"}, {"sha": "4a57c61406ce42032bccc5039c16822795a2ec15", "filename": "src/tools/compiletest/src/header/needs.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fneeds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fneeds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fneeds.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -115,6 +115,11 @@ pub(super) fn handle_needs(\n             condition: cache.x86_64_dlltool,\n             ignore_reason: \"ignored when dlltool for x86_64 is not present\",\n         },\n+        Need {\n+            name: \"needs-dlltool\",\n+            condition: cache.dlltool,\n+            ignore_reason: \"ignored when dlltool for the current architecture is not present\",\n+        },\n         Need {\n             name: \"needs-git-hash\",\n             condition: config.git_hash,\n@@ -183,13 +188,25 @@ pub(super) struct CachedNeedsConditions {\n     rust_lld: bool,\n     i686_dlltool: bool,\n     x86_64_dlltool: bool,\n+    dlltool: bool,\n }\n \n impl CachedNeedsConditions {\n     pub(super) fn load(config: &Config) -> Self {\n         let path = std::env::var_os(\"PATH\").expect(\"missing PATH environment variable\");\n         let path = std::env::split_paths(&path).collect::<Vec<_>>();\n \n+        // On Windows, dlltool.exe is used for all architectures.\n+        #[cfg(windows)]\n+        let dlltool = path.iter().any(|dir| dir.join(\"dlltool.exe\").is_file());\n+\n+        // For non-Windows, there are architecture specific dlltool binaries.\n+        #[cfg(not(windows))]\n+        let i686_dlltool = path.iter().any(|dir| dir.join(\"i686-w64-mingw32-dlltool\").is_file());\n+        #[cfg(not(windows))]\n+        let x86_64_dlltool =\n+            path.iter().any(|dir| dir.join(\"x86_64-w64-mingw32-dlltool\").is_file());\n+\n         let target = &&*config.target;\n         Self {\n             sanitizer_support: std::env::var_os(\"RUSTC_SANITIZER_SUPPORT\").is_some(),\n@@ -225,17 +242,26 @@ impl CachedNeedsConditions {\n                 .join(if config.host.contains(\"windows\") { \"rust-lld.exe\" } else { \"rust-lld\" })\n                 .exists(),\n \n-            // On Windows, dlltool.exe is used for all architectures.\n             #[cfg(windows)]\n-            i686_dlltool: path.iter().any(|dir| dir.join(\"dlltool.exe\").is_file()),\n+            i686_dlltool: dlltool,\n             #[cfg(windows)]\n-            x86_64_dlltool: path.iter().any(|dir| dir.join(\"dlltool.exe\").is_file()),\n+            x86_64_dlltool: dlltool,\n+            #[cfg(windows)]\n+            dlltool,\n \n             // For non-Windows, there are architecture specific dlltool binaries.\n             #[cfg(not(windows))]\n-            i686_dlltool: path.iter().any(|dir| dir.join(\"i686-w64-mingw32-dlltool\").is_file()),\n+            i686_dlltool,\n+            #[cfg(not(windows))]\n+            x86_64_dlltool,\n             #[cfg(not(windows))]\n-            x86_64_dlltool: path.iter().any(|dir| dir.join(\"x86_64-w64-mingw32-dlltool\").is_file()),\n+            dlltool: if config.matches_arch(\"x86\") {\n+                i686_dlltool\n+            } else if config.matches_arch(\"x86_64\") {\n+                x86_64_dlltool\n+            } else {\n+                false\n+            },\n         }\n     }\n }"}, {"sha": "4ede46037894b1e20a0f7bffdb637e912abe44b4", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 63, "deletions": 10, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1483,14 +1483,24 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn compile_test(&self, will_execute: WillExecute, emit: Emit) -> ProcRes {\n-        self.compile_test_general(will_execute, emit, self.props.local_pass_mode())\n+        self.compile_test_general(will_execute, emit, self.props.local_pass_mode(), Vec::new())\n+    }\n+\n+    fn compile_test_with_passes(\n+        &self,\n+        will_execute: WillExecute,\n+        emit: Emit,\n+        passes: Vec<String>,\n+    ) -> ProcRes {\n+        self.compile_test_general(will_execute, emit, self.props.local_pass_mode(), passes)\n     }\n \n     fn compile_test_general(\n         &self,\n         will_execute: WillExecute,\n         emit: Emit,\n         local_pm: Option<PassMode>,\n+        passes: Vec<String>,\n     ) -> ProcRes {\n         // Only use `make_exe_name` when the test ends up being executed.\n         let output_file = match will_execute {\n@@ -1527,6 +1537,7 @@ impl<'test> TestCx<'test> {\n             emit,\n             allow_unused,\n             LinkToAux::Yes,\n+            passes,\n         );\n \n         self.compose_and_run_compiler(rustc, None)\n@@ -1777,6 +1788,7 @@ impl<'test> TestCx<'test> {\n             Emit::None,\n             AllowUnused::No,\n             LinkToAux::No,\n+            Vec::new(),\n         );\n \n         for key in &aux_props.unset_rustc_env {\n@@ -1908,6 +1920,7 @@ impl<'test> TestCx<'test> {\n         emit: Emit,\n         allow_unused: AllowUnused,\n         link_to_aux: LinkToAux,\n+        passes: Vec<String>, // Vec of passes under mir-opt test to be dumped\n     ) -> Command {\n         let is_aux = input_file.components().map(|c| c.as_os_str()).any(|c| c == \"auxiliary\");\n         let is_rustdoc = self.is_rustdoc() && !is_aux;\n@@ -2008,9 +2021,18 @@ impl<'test> TestCx<'test> {\n                 rustc.arg(\"-Cstrip=debuginfo\");\n             }\n             MirOpt => {\n+                // We check passes under test to minimize the mir-opt test dump\n+                // if files_for_miropt_test parses the passes, we dump only those passes\n+                // otherwise we conservatively pass -Zdump-mir=all\n+                let zdump_arg = if !passes.is_empty() {\n+                    format!(\"-Zdump-mir={}\", passes.join(\" | \"))\n+                } else {\n+                    \"-Zdump-mir=all\".to_string()\n+                };\n+\n                 rustc.args(&[\n                     \"-Copt-level=1\",\n-                    \"-Zdump-mir=all\",\n+                    &zdump_arg,\n                     \"-Zvalidate-mir\",\n                     \"-Zdump-mir-exclude-pass-number\",\n                     \"-Zmir-pretty-relative-line-numbers=yes\",\n@@ -2333,6 +2355,7 @@ impl<'test> TestCx<'test> {\n             Emit::LlvmIr,\n             AllowUnused::No,\n             LinkToAux::Yes,\n+            Vec::new(),\n         );\n \n         self.compose_and_run_compiler(rustc, None)\n@@ -2364,8 +2387,14 @@ impl<'test> TestCx<'test> {\n             None => self.fatal(\"missing 'assembly-output' header\"),\n         }\n \n-        let rustc =\n-            self.make_compile_args(input_file, output_file, emit, AllowUnused::No, LinkToAux::Yes);\n+        let rustc = self.make_compile_args(\n+            input_file,\n+            output_file,\n+            emit,\n+            AllowUnused::No,\n+            LinkToAux::Yes,\n+            Vec::new(),\n+        );\n \n         (self.compose_and_run_compiler(rustc, None), output_path)\n     }\n@@ -2496,6 +2525,7 @@ impl<'test> TestCx<'test> {\n             Emit::None,\n             AllowUnused::Yes,\n             LinkToAux::Yes,\n+            Vec::new(),\n         );\n         new_rustdoc.build_all_auxiliary(&mut rustc);\n \n@@ -3310,7 +3340,8 @@ impl<'test> TestCx<'test> {\n         if let Some(FailMode::Build) = self.props.fail_mode {\n             // Make sure a build-fail test cannot fail due to failing analysis (e.g. typeck).\n             let pm = Some(PassMode::Check);\n-            let proc_res = self.compile_test_general(WillExecute::No, Emit::Metadata, pm);\n+            let proc_res =\n+                self.compile_test_general(WillExecute::No, Emit::Metadata, pm, Vec::new());\n             self.check_if_test_should_compile(&proc_res, pm);\n         }\n \n@@ -3479,6 +3510,7 @@ impl<'test> TestCx<'test> {\n                 emit_metadata,\n                 AllowUnused::No,\n                 LinkToAux::Yes,\n+                Vec::new(),\n             );\n             let res = self.compose_and_run_compiler(rustc, None);\n             if !res.status.success() {\n@@ -3497,14 +3529,14 @@ impl<'test> TestCx<'test> {\n         let pm = self.pass_mode();\n         let should_run = self.should_run(pm);\n         let emit_metadata = self.should_emit_metadata(pm);\n-        let proc_res = self.compile_test(should_run, emit_metadata);\n+        let passes = self.get_passes();\n \n+        let proc_res = self.compile_test_with_passes(should_run, emit_metadata, passes);\n+        self.check_mir_dump();\n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n         }\n \n-        self.check_mir_dump();\n-\n         if let WillExecute::Yes = should_run {\n             let proc_res = self.exec_compiled_test();\n \n@@ -3514,6 +3546,26 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n+    fn get_passes(&self) -> Vec<String> {\n+        let files = miropt_test_tools::files_for_miropt_test(\n+            &self.testpaths.file,\n+            self.config.get_pointer_width(),\n+        );\n+\n+        let mut out = Vec::new();\n+\n+        for miropt_test_tools::MiroptTestFiles {\n+            from_file: _,\n+            to_file: _,\n+            expected_file: _,\n+            passes,\n+        } in files\n+        {\n+            out.extend(passes);\n+        }\n+        out\n+    }\n+\n     fn check_mir_dump(&self) {\n         let test_file_contents = fs::read_to_string(&self.testpaths.file).unwrap();\n \n@@ -3543,8 +3595,9 @@ impl<'test> TestCx<'test> {\n             &self.testpaths.file,\n             self.config.get_pointer_width(),\n         );\n-\n-        for miropt_test_tools::MiroptTestFiles { from_file, to_file, expected_file } in files {\n+        for miropt_test_tools::MiroptTestFiles { from_file, to_file, expected_file, passes: _ } in\n+            files\n+        {\n             let dumped_string = if let Some(after) = to_file {\n                 self.diff_mir_files(from_file.into(), after.into())\n             } else {"}, {"sha": "e95c955a9a1fbe78b93617f8b1ba927bdaf1d721", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1 +1 @@\n-74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d\n+c4190f2d3a46a59f435f7b42f58bc22b2f4d6917"}, {"sha": "28f9912e2838db36638b7ba8001d95c98fb72c87", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -288,11 +288,10 @@ fn main() {\n     // (`install_ice_hook` might change `RUST_BACKTRACE`.)\n     let env_snapshot = env::vars_os().collect::<Vec<_>>();\n \n-    // Earliest rustc setup.\n-    rustc_driver::install_ice_hook();\n-\n     // If the environment asks us to actually be rustc, then do that.\n     if let Some(crate_kind) = env::var_os(\"MIRI_BE_RUSTC\") {\n+        // Earliest rustc setup.\n+        rustc_driver::install_ice_hook(rustc_driver::DEFAULT_BUG_REPORT_URL, |_| ());\n         rustc_driver::init_rustc_env_logger();\n \n         let target_crate = if crate_kind == \"target\" {\n@@ -311,6 +310,9 @@ fn main() {\n         )\n     }\n \n+    // Add an ICE bug report hook.\n+    rustc_driver::install_ice_hook(\"https://github.com/rust-lang/miri/issues/new\", |_| ());\n+\n     // Init loggers the Miri way.\n     init_early_loggers();\n "}, {"sha": "f86c3ce0afeaae7868c0942398494ce070a6549f", "filename": "src/tools/miropt-test-tools/src/lib.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fmiropt-test-tools%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fmiropt-test-tools%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiropt-test-tools%2Fsrc%2Flib.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -4,6 +4,8 @@ pub struct MiroptTestFiles {\n     pub expected_file: std::path::PathBuf,\n     pub from_file: String,\n     pub to_file: Option<String>,\n+    /// Vec of passes under test to be dumped\n+    pub passes: Vec<String>,\n }\n \n pub fn files_for_miropt_test(testfile: &std::path::Path, bit_width: u32) -> Vec<MiroptTestFiles> {\n@@ -28,17 +30,26 @@ pub fn files_for_miropt_test(testfile: &std::path::Path, bit_width: u32) -> Vec<\n             let mut expected_file;\n             let from_file;\n             let to_file;\n+            let mut passes = Vec::new();\n \n             if test_name.ends_with(\".diff\") {\n                 let trimmed = test_name.trim_end_matches(\".diff\");\n+                passes.push(trimmed.split('.').last().unwrap().to_owned());\n                 let test_against = format!(\"{}.after.mir\", trimmed);\n                 from_file = format!(\"{}.before.mir\", trimmed);\n                 expected_file = format!(\"{}{}.diff\", trimmed, bit_width);\n                 assert!(test_names.next().is_none(), \"two mir pass names specified for MIR diff\");\n                 to_file = Some(test_against);\n             } else if let Some(first_pass) = test_names.next() {\n                 let second_pass = test_names.next().unwrap();\n+                if let Some((first_pass_name, _)) = first_pass.split_once('.') {\n+                    passes.push(first_pass_name.to_owned());\n+                }\n+                if let Some((second_pass_name, _)) = second_pass.split_once('.') {\n+                    passes.push(second_pass_name.to_owned());\n+                }\n                 assert!(test_names.next().is_none(), \"three mir pass names specified for MIR diff\");\n+\n                 expected_file =\n                     format!(\"{}{}.{}-{}.diff\", test_name, bit_width, first_pass, second_pass);\n                 let second_file = format!(\"{}.{}.mir\", test_name, second_pass);\n@@ -51,18 +62,24 @@ pub fn files_for_miropt_test(testfile: &std::path::Path, bit_width: u32) -> Vec<\n                     .next()\n                     .expect(\"test_name has an invalid extension\");\n                 let extension = cap.get(1).unwrap().as_str();\n+\n                 expected_file =\n                     format!(\"{}{}{}\", test_name.trim_end_matches(extension), bit_width, extension,);\n                 from_file = test_name.to_string();\n                 assert!(test_names.next().is_none(), \"two mir pass names specified for MIR dump\");\n                 to_file = None;\n+                // the pass name is the third to last string in the test name\n+                // this gets pushed into passes\n+                passes.push(\n+                    test_name.split('.').rev().nth(2).expect(\"invalid test format\").to_string(),\n+                );\n             };\n             if !expected_file.starts_with(&test_crate) {\n                 expected_file = format!(\"{}.{}\", test_crate, expected_file);\n             }\n             let expected_file = test_dir.join(expected_file);\n \n-            out.push(MiroptTestFiles { expected_file, from_file, to_file });\n+            out.push(MiroptTestFiles { expected_file, from_file, to_file, passes });\n         }\n     }\n "}, {"sha": "47846424b06e4a139c015c25e898e76685b15e7f", "filename": "src/tools/rustfmt/src/bin/main.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Frustfmt%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Frustfmt%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fbin%2Fmain.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,3 +1,5 @@\n+#![feature(rustc_private)]\n+\n use anyhow::{format_err, Result};\n \n use io::Error as IoError;\n@@ -19,7 +21,14 @@ use crate::rustfmt::{\n     FormatReportFormatterBuilder, Input, Session, Verbosity,\n };\n \n+const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rustfmt/issues/new?labels=bug\";\n+\n+// N.B. these crates are loaded from the sysroot, so they need extern crate.\n+extern crate rustc_driver;\n+\n fn main() {\n+    rustc_driver::install_ice_hook(BUG_REPORT_URL, |_| ());\n+\n     env_logger::Builder::from_env(\"RUSTFMT_LOG\").init();\n     let opts = make_opts();\n "}, {"sha": "a84e78254f26982da7289ebf0f8af7fcead245db", "filename": "src/tools/suggest-tests/src/static_suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fsuggest-tests%2Fsrc%2Fstatic_suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fsuggest-tests%2Fsrc%2Fstatic_suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fsuggest-tests%2Fsrc%2Fstatic_suggestions.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -15,7 +15,7 @@ static_suggestions! {\n \n     \"compiler/*\" => [\n         sug!(\"check\"),\n-        sug!(\"test\", 1, [\"src/test/ui\", \"src/test/run-make\"])\n+        sug!(\"test\", 1, [\"tests/ui\", \"tests/run-make\"])\n     ],\n \n     \"src/librustdoc/*\" => ["}, {"sha": "b4149136fa309a9f3de4bd7deb944ada56061017", "filename": "src/tools/suggest-tests/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fsuggest-tests%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/src%2Ftools%2Fsuggest-tests%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fsuggest-tests%2Fsrc%2Ftests.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -12,7 +12,7 @@ macro_rules! sugg_test {\n \n sugg_test! {\n     test_error_code_docs: [\"compiler/rustc_error_codes/src/error_codes/E0000.md\"] =>\n-        [\"check N/A\", \"test compiler/rustc_error_codes N/A\", \"test linkchecker 0\", \"test src/test/ui src/test/run-make 1\"],\n+        [\"check N/A\", \"test compiler/rustc_error_codes N/A\", \"test linkchecker 0\", \"test tests/ui tests/run-make 1\"],\n \n     test_rustdoc: [\"src/librustdoc/src/lib.rs\"] => [\"test rustdoc 1\"],\n "}, {"sha": "b3e1fee15a715cad555cd7eb3ffc1fb6f3a18e80", "filename": "tests/assembly/slice-is_ascii.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fassembly%2Fslice-is_ascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fassembly%2Fslice-is_ascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fassembly%2Fslice-is_ascii.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -0,0 +1,35 @@\n+// revisions: WIN LIN\n+// [WIN] only-windows\n+// [LIN] only-linux\n+// assembly-output: emit-asm\n+// compile-flags: --crate-type=lib -O -C llvm-args=-x86-asm-syntax=intel\n+// min-llvm-version: 14\n+// only-x86_64\n+// ignore-sgx\n+// ignore-debug\n+\n+#![feature(str_internals)]\n+\n+// CHECK-LABEL: is_ascii_simple_demo:\n+#[no_mangle]\n+pub fn is_ascii_simple_demo(bytes: &[u8]) -> bool {\n+    // Linux (System V): pointer is rdi; length is rsi\n+    // Windows: pointer is rcx; length is rdx.\n+\n+    // CHECK-NOT: mov\n+    // CHECK-NOT: test\n+    // CHECK-NOT: cmp\n+\n+    // CHECK: .[[LOOPHEAD:.+]]:\n+    // CHECK-NEXT: mov [[TEMP:.+]], [[LEN:rsi|rdx]]\n+    // CHECK-NEXT: sub [[LEN]], 1\n+    // CHECK-NEXT: jb .[[LOOPEXIT:.+]]\n+    // CHECK-NEXT: cmp byte ptr [{{rdi|rcx}} + [[TEMP]] - 1], 0\n+    // CHECK-NEXT: jns .[[LOOPHEAD]]\n+\n+    // CHECK-NEXT: .[[LOOPEXIT]]:\n+    // CHECK-NEXT: test [[TEMP]], [[TEMP]]\n+    // CHECK-NEXT: sete al\n+    // CHECK-NEXT: ret\n+    core::slice::is_ascii_simple(bytes)\n+}"}, {"sha": "169e99deee755235eb4d7604d40c432cf866220f", "filename": "tests/mir-opt/const_allocation.main.ConstProp.after.32bit.mir", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.32bit.mir?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -21,42 +21,42 @@ fn main() -> () {\n }\n \n alloc1 (static: FOO, size: 8, align: 4) {\n-    \u257e\u2500alloc18\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+    \u257e\u2500alloc19\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc18 (size: 48, align: 4) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc5\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc8\u2500\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc13\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+alloc19 (size: 48, align: 4) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc6\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc9\u2500\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc14\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n }\n \n-alloc5 (size: 0, align: 4) {}\n+alloc6 (size: 0, align: 4) {}\n \n-alloc8 (size: 16, align: 4) {\n-    \u257e\u2500alloc9\u2500\u2500\u257c 03 00 00 00 \u257e\u2500alloc10\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n+alloc9 (size: 16, align: 4) {\n+    \u257e\u2500alloc10\u2500\u257c 03 00 00 00 \u257e\u2500alloc11\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n }\n \n-alloc9 (size: 3, align: 1) {\n+alloc10 (size: 3, align: 1) {\n     66 6f 6f                                        \u2502 foo\n }\n \n-alloc10 (size: 3, align: 1) {\n+alloc11 (size: 3, align: 1) {\n     62 61 72                                        \u2502 bar\n }\n \n-alloc13 (size: 24, align: 4) {\n-    0x00 \u2502 \u257e\u2500alloc14\u2500\u257c 03 00 00 00 \u257e\u2500alloc15\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 \u257e\u2500alloc16\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+alloc14 (size: 24, align: 4) {\n+    0x00 \u2502 \u257e\u2500alloc15\u2500\u257c 03 00 00 00 \u257e\u2500alloc16\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 \u257e\u2500alloc17\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc14 (size: 3, align: 1) {\n+alloc15 (size: 3, align: 1) {\n     6d 65 68                                        \u2502 meh\n }\n \n-alloc15 (size: 3, align: 1) {\n+alloc16 (size: 3, align: 1) {\n     6d 6f 70                                        \u2502 mop\n }\n \n-alloc16 (size: 4, align: 1) {\n+alloc17 (size: 4, align: 1) {\n     6d c3 b6 70                                     \u2502 m..p\n }"}, {"sha": "db1f9648843ea2f749e39f3e6a7ba252f51ddd8c", "filename": "tests/mir-opt/const_allocation.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.64bit.mir?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -21,46 +21,46 @@ fn main() -> () {\n }\n \n alloc1 (static: FOO, size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc18\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc19\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc18 (size: 72, align: 8) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc5\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc19 (size: 72, align: 8) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc6\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n-alloc5 (size: 0, align: 8) {}\n+alloc6 (size: 0, align: 8) {}\n \n-alloc8 (size: 32, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc10\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+alloc9 (size: 32, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc10\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc11\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc9 (size: 3, align: 1) {\n+alloc10 (size: 3, align: 1) {\n     66 6f 6f                                        \u2502 foo\n }\n \n-alloc10 (size: 3, align: 1) {\n+alloc11 (size: 3, align: 1) {\n     62 61 72                                        \u2502 bar\n }\n \n-alloc13 (size: 48, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc15\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc16\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+alloc14 (size: 48, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc15\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc16\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc17\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc14 (size: 3, align: 1) {\n+alloc15 (size: 3, align: 1) {\n     6d 65 68                                        \u2502 meh\n }\n \n-alloc15 (size: 3, align: 1) {\n+alloc16 (size: 3, align: 1) {\n     6d 6f 70                                        \u2502 mop\n }\n \n-alloc16 (size: 4, align: 1) {\n+alloc17 (size: 4, align: 1) {\n     6d c3 b6 70                                     \u2502 m..p\n }"}, {"sha": "999acb48afec33b64561796ac885fa642ac5e425", "filename": "tests/mir-opt/const_allocation2.main.ConstProp.after.32bit.mir", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.32bit.mir?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -21,41 +21,41 @@ fn main() -> () {\n }\n \n alloc1 (static: FOO, size: 8, align: 4) {\n-    \u257e\u2500alloc22\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+    \u257e\u2500alloc23\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc22 (size: 48, align: 4) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc9\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc14\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc20\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+alloc23 (size: 48, align: 4) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc10\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc15\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc21\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n }\n \n-alloc9 (size: 0, align: 4) {}\n+alloc10 (size: 0, align: 4) {}\n \n-alloc14 (size: 8, align: 4) {\n-    \u257e\u2500alloc12\u2500\u257c \u257e\u2500alloc13\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+alloc15 (size: 8, align: 4) {\n+    \u257e\u2500alloc13\u2500\u257c \u257e\u2500alloc14\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n-alloc12 (size: 1, align: 1) {\n+alloc13 (size: 1, align: 1) {\n     05                                              \u2502 .\n }\n \n-alloc13 (size: 1, align: 1) {\n+alloc14 (size: 1, align: 1) {\n     06                                              \u2502 .\n }\n \n-alloc20 (size: 12, align: 4) {\n-    \u257e\u2500a17+0x3\u2500\u257c \u257e\u2500alloc18\u2500\u257c \u257e\u2500a19+0x2\u2500\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+alloc21 (size: 12, align: 4) {\n+    \u257e\u2500a18+0x3\u2500\u257c \u257e\u2500alloc19\u2500\u257c \u257e\u2500a20+0x2\u2500\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n-alloc17 (size: 4, align: 1) {\n+alloc18 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }\n \n-alloc18 (size: 1, align: 1) {\n+alloc19 (size: 1, align: 1) {\n     2a                                              \u2502 *\n }\n \n-alloc19 (size: 4, align: 1) {\n+alloc20 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }"}, {"sha": "30311890eeef9293fc644712bc89491e29bd70c1", "filename": "tests/mir-opt/const_allocation2.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -21,44 +21,44 @@ fn main() -> () {\n }\n \n alloc1 (static: FOO, size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc22\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc23\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc22 (size: 72, align: 8) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc23 (size: 72, align: 8) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc10\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc20\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc15\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc21\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n-alloc9 (size: 0, align: 8) {}\n+alloc10 (size: 0, align: 8) {}\n \n-alloc14 (size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc12\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc15 (size: 16, align: 8) {\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc12 (size: 1, align: 1) {\n+alloc13 (size: 1, align: 1) {\n     05                                              \u2502 .\n }\n \n-alloc13 (size: 1, align: 1) {\n+alloc14 (size: 1, align: 1) {\n     06                                              \u2502 .\n }\n \n-alloc20 (size: 24, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc17+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc18\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc19+0x2\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc21 (size: 24, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc18+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc19\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc20+0x2\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc17 (size: 4, align: 1) {\n+alloc18 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }\n \n-alloc18 (size: 1, align: 1) {\n+alloc19 (size: 1, align: 1) {\n     2a                                              \u2502 *\n }\n \n-alloc19 (size: 4, align: 1) {\n+alloc20 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }"}, {"sha": "d592e59fafd795757aceecf691197b4df24c1cf2", "filename": "tests/mir-opt/const_allocation3.main.ConstProp.after.32bit.mir", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.32bit.mir?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -21,30 +21,30 @@ fn main() -> () {\n }\n \n alloc1 (static: FOO, size: 4, align: 4) {\n-    \u257e\u2500alloc11\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+    \u257e\u2500alloc12\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n }\n \n-alloc11 (size: 168, align: 1) {\n+alloc12 (size: 168, align: 1) {\n     0x00 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab \u2502 ................\n-    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500alloc6\u2500\u2500\u257c \u2502 ............\u257e\u2500\u2500\u257c\n+    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500alloc7\u2500\u2500\u257c \u2502 ............\u257e\u2500\u2500\u257c\n     0x20 \u2502 01 ef cd ab 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x30 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x40 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x50 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x60 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x70 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n-    0x80 \u2502 00 00 00 00 00 00 00 00 00 00 \u257e\u2500alloc8\u2500\u2500\u257c 00 00 \u2502 ..........\u257e\u2500\u2500\u257c..\n-    0x90 \u2502 \u257e\u2500a9+0x63\u2500\u257c 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u257c............\n+    0x80 \u2502 00 00 00 00 00 00 00 00 00 00 \u257e\u2500alloc9\u2500\u2500\u257c 00 00 \u2502 ..........\u257e\u2500\u2500\u257c..\n+    0x90 \u2502 \u257ea10+0x63\u2500\u257c 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u257c............\n     0xa0 \u2502 00 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n-alloc6 (size: 4, align: 4) {\n+alloc7 (size: 4, align: 4) {\n     2a 00 00 00                                     \u2502 *...\n }\n \n-alloc8 (fn: main)\n+alloc9 (fn: main)\n \n-alloc9 (size: 100, align: 1) {\n+alloc10 (size: 100, align: 1) {\n     0x00 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x20 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................"}, {"sha": "ca53b28be7cbf4fa2c46c6fa1f23dc7b8b8494b5", "filename": "tests/mir-opt/const_allocation3.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.64bit.mir?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -21,31 +21,31 @@ fn main() -> () {\n }\n \n alloc1 (static: FOO, size: 8, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc11\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc12\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc11 (size: 180, align: 1) {\n+alloc12 (size: 180, align: 1) {\n     0x00 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab \u2502 ................\n-    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500\u2500alloc6\u2500\u2500 \u2502 ............\u257e\u2500\u2500\u2500\n+    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500\u2500alloc7\u2500\u2500 \u2502 ............\u257e\u2500\u2500\u2500\n     0x20 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 ef cd ab 00 00 00 00 00 00 00 00 \u2502 \u2500\u2500\u2500\u257c............\n     0x30 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x40 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x50 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x60 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x70 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x80 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u257e\u2500\u2500\u2500\u2500 \u2502 ..............\u257e\u2500\n-    0x90 \u2502 \u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u257c 00 00 \u257e\u2500\u2500\u2500\u2500\u2500alloc9+0x63\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u2500\u2500\u2500\u2500\u2500\u257c..\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x90 \u2502 \u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u257c 00 00 \u257e\u2500\u2500\u2500\u2500alloc10+0x63\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u2500\u2500\u2500\u2500\u2500\u257c..\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0xa0 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0xb0 \u2502 00 00 00 00                                     \u2502 ....\n }\n \n-alloc6 (size: 4, align: 4) {\n+alloc7 (size: 4, align: 4) {\n     2a 00 00 00                                     \u2502 *...\n }\n \n-alloc8 (fn: main)\n+alloc9 (fn: main)\n \n-alloc9 (size: 100, align: 1) {\n+alloc10 (size: 100, align: 1) {\n     0x00 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x20 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................"}, {"sha": "85d6b5e3d003e76a558443037e77b7506435cf94", "filename": "tests/mir-opt/const_prop/bad_op_mod_by_zero.main.ConstProp.diff", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero.main.ConstProp.diff?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -18,29 +18,35 @@\n       }\n   \n       bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/bad_op_mod_by_zero.rs:+1:9: +1:10\n           _1 = const 0_i32;                // scope 0 at $DIR/bad_op_mod_by_zero.rs:+1:13: +1:14\n           StorageLive(_2);                 // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:9: +2:11\n--         _4 = Eq(_1, const 0_i32);        // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n+          StorageLive(_3);                 // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:18: +2:19\n+-         _3 = _1;                         // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:18: +2:19\n+-         _4 = Eq(_3, const 0_i32);        // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n -         assert(!move _4, \"attempt to calculate the remainder of `{}` with a divisor of zero\", const 1_i32) -> bb1; // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n++         _3 = const 0_i32;                // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:18: +2:19\n +         _4 = const true;                 // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n +         assert(!const true, \"attempt to calculate the remainder of `{}` with a divisor of zero\", const 1_i32) -> bb1; // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n       }\n   \n       bb1: {\n--         _5 = Eq(_1, const -1_i32);       // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n+-         _5 = Eq(_3, const -1_i32);       // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n -         _6 = Eq(const 1_i32, const i32::MIN); // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n -         _7 = BitAnd(move _5, move _6);   // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n--         assert(!move _7, \"attempt to compute the remainder of `{} % {}`, which would overflow\", const 1_i32, _1) -> bb2; // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n+-         assert(!move _7, \"attempt to compute the remainder of `{} % {}`, which would overflow\", const 1_i32, _3) -> bb2; // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n +         _5 = const false;                // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n +         _6 = const false;                // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n +         _7 = const false;                // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n-+         assert(!const false, \"attempt to compute the remainder of `{} % {}`, which would overflow\", const 1_i32, const 0_i32) -> bb2; // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n++         assert(!const false, \"attempt to compute the remainder of `{} % {}`, which would overflow\", const 1_i32, _3) -> bb2; // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n       }\n   \n       bb2: {\n--         _2 = Rem(const 1_i32, _1);       // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n-+         _2 = Rem(const 1_i32, const 0_i32); // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n+          _2 = Rem(const 1_i32, move _3);  // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n+          StorageDead(_3);                 // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:18: +2:19\n+          _0 = const ();                   // scope 0 at $DIR/bad_op_mod_by_zero.rs:+0:11: +3:2\n           StorageDead(_2);                 // scope 1 at $DIR/bad_op_mod_by_zero.rs:+3:1: +3:2\n+          StorageDead(_1);                 // scope 0 at $DIR/bad_op_mod_by_zero.rs:+3:1: +3:2\n           return;                          // scope 0 at $DIR/bad_op_mod_by_zero.rs:+3:2: +3:2\n       }\n   }"}, {"sha": "93d558250eaf172e390d1c0f8d0d3d1e8af272ad", "filename": "tests/mir-opt/const_prop/bad_op_mod_by_zero.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero.rs?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -1,3 +1,4 @@\n+// unit-test: ConstProp\n // ignore-wasm32 compiled with panic=abort by default\n // EMIT_MIR bad_op_mod_by_zero.main.ConstProp.diff\n #[allow(unconditional_panic)]"}, {"sha": "f63ee705d92a6daa6f0b1c79fecb69415ea0236a", "filename": "tests/mir-opt/const_prop/bad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a5167101f0f828a2c7a084a3a7631ad1a44ed/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff?ref=3d5a5167101f0f828a2c7a084a3a7631ad1a44ed", "patch": "@@ -6,44 +6,49 @@\n       let _1: *const [i32];                // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:9: +1:10\n       let mut _2: *const [i32; 3];         // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:25: +1:35\n       let _3: &[i32; 3];                   // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:25: +1:35\n-      let _5: usize;                       // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:23: +3:24\n-      let mut _6: usize;                   // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n-      let mut _7: bool;                    // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n-      let mut _8: &[i32; 3];               // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:25: +1:35\n+      let _4: [i32; 3];                    // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:26: +1:35\n+      let _6: usize;                       // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:23: +3:24\n+      let mut _7: usize;                   // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n+      let mut _8: bool;                    // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n+      let mut _9: &[i32; 3];               // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:25: +1:35\n       scope 1 {\n           debug a => _1;                   // in scope 1 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:9: +1:10\n           scope 2 {\n-              let _4: i32;                 // in scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:13: +3:15\n+              let _5: i32;                 // in scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:13: +3:15\n               scope 3 {\n-                  debug _b => _4;          // in scope 3 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:13: +3:15\n+                  debug _b => _5;          // in scope 3 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:13: +3:15\n               }\n           }\n       }\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:9: +1:10\n           StorageLive(_2);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:25: +1:35\n-          _8 = const _;                    // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:25: +1:35\n+          StorageLive(_3);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:25: +1:35\n+          _9 = const _;                    // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:25: +1:35\n                                            // mir::Constant\n-                                           // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:6:25: 6:35\n+                                           // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:9:25: 9:35\n                                            // + literal: Const { ty: &[i32; 3], val: Unevaluated(main, [], Some(promoted[0])) }\n-          _2 = &raw const (*_8);           // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:25: +1:35\n+          _3 = &(*_9);                     // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:25: +1:35\n+          _2 = &raw const (*_3);           // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:25: +1:35\n           _1 = move _2 as *const [i32] (Pointer(Unsize)); // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:25: +1:35\n           StorageDead(_2);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:34: +1:35\n-          StorageLive(_4);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:13: +3:15\n-          StorageLive(_5);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:23: +3:24\n-          _5 = const 3_usize;              // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:23: +3:24\n-          _6 = const 3_usize;              // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n--         _7 = Lt(_5, _6);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n--         assert(move _7, \"index out of bounds: the length is {} but the index is {}\", move _6, _5) -> bb1; // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n-+         _7 = const false;                // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n-+         assert(const false, \"index out of bounds: the length is {} but the index is {}\", const 3_usize, const 3_usize) -> bb1; // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n+          StorageDead(_3);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+1:35: +1:36\n+          StorageLive(_5);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:13: +3:15\n+          StorageLive(_6);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:23: +3:24\n+          _6 = const 3_usize;              // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:23: +3:24\n+          _7 = const 3_usize;              // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n+-         _8 = Lt(_6, _7);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n+-         assert(move _8, \"index out of bounds: the length is {} but the index is {}\", move _7, _6) -> bb1; // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n++         _8 = const false;                // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n++         assert(const false, \"index out of bounds: the length is {} but the index is {}\", move _7, _6) -> bb1; // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n       }\n   \n       bb1: {\n-          _4 = (*_1)[_5];                  // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n-          StorageDead(_5);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:25: +3:26\n-          StorageDead(_4);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+4:5: +4:6\n+          _5 = (*_1)[_6];                  // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n+          StorageDead(_6);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:25: +3:26\n+          _0 = const ();                   // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+2:5: +4:6\n+          StorageDead(_5);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+4:5: +4:6\n           StorageDead(_1);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+5:1: +5:2\n           return;                          // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:+5:2: +5:2\n       }"}]}