{"sha": "2ed25f069768c046464e68fd382c867ddb04a1e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlZDI1ZjA2OTc2OGMwNDY0NjRlNjhmZDM4MmM4NjdkZGIwNGExZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-12T13:16:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-12T13:16:58Z"}, "message": "Auto merge of #68241 - ecstatic-morse:unified-dataflow-impls, r=pnkfelix\n\nMigrate borrowck dataflow impls to new framework\n\nThis uses #65672 to implement the dataflow analyses needed by borrowck. These include all the `InitializedPlaces` analyses as well as `Borrows`. Additionally, this PR contains several independent changes around the dataflow API which improve performance and make it more ergonomic.\n\n* An optimization that inhibits the caching of block transfer functions for acyclic MIR (~0.3% I-CNT savings).\n* A `ResultsVisitor` for dataflow results that is more efficient than `ResultsCursor` when we have to visit every statement unconditionally (~0.3% I-CNT savings).\n* An `into_engine` method on `Analysis` that selects the appropriate `Engine` constructor.\n* A `contains` method for `ResultsCursor` as a shorthand for `.get().contains()`.\n* A `find_descendants` helper on `MovePath` that replaces `has_any_child_of` on the old `FlowsAtLocation`\n\nThese changes made porting the dataflow analyses much easier. Finally, this PR removes some now-unused code in `dataflow/at_location.rs` and elsewhere.\n\nYou can view the perf results for the final version of this PR [here](https://perf.rust-lang.org/compare.html?start=29b854fb741809c29764e33fc17c32ba9c6523ba&end=6e516c1410c18cfe4eb6d030a39fdb73c8d8a4fe). Here's an example of the graphviz diagrams that are generated for the `MaybeInitializedPlaces` analysis.\n\n![image](https://user-images.githubusercontent.com/29463364/72846117-c3e97d80-3c54-11ea-8171-3d48981c9ddd.png)", "tree": {"sha": "32fa45c28a2290ece5bedf78aabbc67df0877030", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32fa45c28a2290ece5bedf78aabbc67df0877030"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ed25f069768c046464e68fd382c867ddb04a1e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ed25f069768c046464e68fd382c867ddb04a1e3", "html_url": "https://github.com/rust-lang/rust/commit/2ed25f069768c046464e68fd382c867ddb04a1e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ed25f069768c046464e68fd382c867ddb04a1e3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "html_url": "https://github.com/rust-lang/rust/commit/cd5441faf4e56d136d7c05d5eb55b4a41396edaf"}, {"sha": "5f40fe96a42d3590b804264c029fb02d0a4b065c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f40fe96a42d3590b804264c029fb02d0a4b065c", "html_url": "https://github.com/rust-lang/rust/commit/5f40fe96a42d3590b804264c029fb02d0a4b065c"}], "stats": {"total": 1304, "additions": 788, "deletions": 516}, "files": [{"sha": "57c544fda0c5467f30099bf523dc75e76aebcdac", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -1,142 +0,0 @@\n-//! Manages the dataflow bits required for borrowck.\n-//!\n-//! FIXME: this might be better as a \"generic\" fixed-point combinator,\n-//! but is not as ugly as it is right now.\n-\n-use rustc::mir::{BasicBlock, Location};\n-use rustc_index::bit_set::BitIter;\n-\n-use crate::borrow_check::location::LocationIndex;\n-\n-use crate::borrow_check::nll::PoloniusOutput;\n-\n-use crate::dataflow::indexes::BorrowIndex;\n-use crate::dataflow::move_paths::HasMoveData;\n-use crate::dataflow::Borrows;\n-use crate::dataflow::EverInitializedPlaces;\n-use crate::dataflow::MaybeUninitializedPlaces;\n-use crate::dataflow::{FlowAtLocation, FlowsAtLocation};\n-use either::Either;\n-use std::fmt;\n-use std::rc::Rc;\n-\n-crate struct Flows<'b, 'tcx> {\n-    borrows: FlowAtLocation<'tcx, Borrows<'b, 'tcx>>,\n-    pub uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'tcx>>,\n-    pub ever_inits: FlowAtLocation<'tcx, EverInitializedPlaces<'b, 'tcx>>,\n-\n-    /// Polonius Output\n-    pub polonius_output: Option<Rc<PoloniusOutput>>,\n-}\n-\n-impl<'b, 'tcx> Flows<'b, 'tcx> {\n-    crate fn new(\n-        borrows: FlowAtLocation<'tcx, Borrows<'b, 'tcx>>,\n-        uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'tcx>>,\n-        ever_inits: FlowAtLocation<'tcx, EverInitializedPlaces<'b, 'tcx>>,\n-        polonius_output: Option<Rc<PoloniusOutput>>,\n-    ) -> Self {\n-        Flows { borrows, uninits, ever_inits, polonius_output }\n-    }\n-\n-    crate fn borrows_in_scope(\n-        &self,\n-        location: LocationIndex,\n-    ) -> impl Iterator<Item = BorrowIndex> + '_ {\n-        if let Some(ref polonius) = self.polonius_output {\n-            Either::Left(polonius.errors_at(location).iter().cloned())\n-        } else {\n-            Either::Right(self.borrows.iter_incoming())\n-        }\n-    }\n-\n-    crate fn with_outgoing_borrows(&self, op: impl FnOnce(BitIter<'_, BorrowIndex>)) {\n-        self.borrows.with_iter_outgoing(op)\n-    }\n-}\n-\n-macro_rules! each_flow {\n-    ($this:ident, $meth:ident($arg:ident)) => {\n-        FlowAtLocation::$meth(&mut $this.borrows, $arg);\n-        FlowAtLocation::$meth(&mut $this.uninits, $arg);\n-        FlowAtLocation::$meth(&mut $this.ever_inits, $arg);\n-    };\n-}\n-\n-impl<'b, 'tcx> FlowsAtLocation for Flows<'b, 'tcx> {\n-    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n-        each_flow!(self, reset_to_entry_of(bb));\n-    }\n-\n-    fn reset_to_exit_of(&mut self, bb: BasicBlock) {\n-        each_flow!(self, reset_to_exit_of(bb));\n-    }\n-\n-    fn reconstruct_statement_effect(&mut self, location: Location) {\n-        each_flow!(self, reconstruct_statement_effect(location));\n-    }\n-\n-    fn reconstruct_terminator_effect(&mut self, location: Location) {\n-        each_flow!(self, reconstruct_terminator_effect(location));\n-    }\n-\n-    fn apply_local_effect(&mut self, location: Location) {\n-        each_flow!(self, apply_local_effect(location));\n-    }\n-}\n-\n-impl<'b, 'tcx> fmt::Display for Flows<'b, 'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut s = String::new();\n-\n-        s.push_str(\"borrows in effect: [\");\n-        let mut saw_one = false;\n-        self.borrows.each_state_bit(|borrow| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let borrow_data = &self.borrows.operator().borrows()[borrow];\n-            s.push_str(&borrow_data.to_string());\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"borrows generated: [\");\n-        let mut saw_one = false;\n-        self.borrows.each_gen_bit(|borrow| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let borrow_data = &self.borrows.operator().borrows()[borrow];\n-            s.push_str(&borrow_data.to_string());\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"uninits: [\");\n-        let mut saw_one = false;\n-        self.uninits.each_state_bit(|mpi_uninit| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let move_path = &self.uninits.operator().move_data().move_paths[mpi_uninit];\n-            s.push_str(&move_path.to_string());\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"ever_init: [\");\n-        let mut saw_one = false;\n-        self.ever_inits.each_state_bit(|mpi_ever_init| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let ever_init = &self.ever_inits.operator().move_data().inits[mpi_ever_init];\n-            s.push_str(&format!(\"{:?}\", ever_init));\n-        });\n-        s.push_str(\"]\");\n-\n-        fmt::Display::fmt(&s, fmt)\n-    }\n-}"}, {"sha": "88173137bd2e4637c57104c1c65234f8243ab91d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 122, "deletions": 101, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -4,8 +4,8 @@ use rustc::infer::InferCtxt;\n use rustc::lint::builtin::MUTABLE_BORROW_RESERVATION_CONFLICT;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::mir::{\n-    read_only, Body, BodyAndCache, ClearCrossCrate, Local, Location, Mutability, Operand, Place,\n-    PlaceElem, PlaceRef, ReadOnlyBodyAndCache,\n+    read_only, traversal, Body, BodyAndCache, ClearCrossCrate, Local, Location, Mutability,\n+    Operand, Place, PlaceElem, PlaceRef, ReadOnlyBodyAndCache,\n };\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n@@ -21,6 +21,7 @@ use rustc_hir::{def_id::DefId, HirId, Node};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n \n+use either::Either;\n use smallvec::SmallVec;\n use std::cell::RefCell;\n use std::collections::BTreeMap;\n@@ -30,19 +31,17 @@ use std::rc::Rc;\n use rustc_span::{Span, DUMMY_SP};\n use syntax::ast::Name;\n \n+use crate::dataflow;\n+use crate::dataflow::generic::{Analysis, BorrowckFlowState as Flows, BorrowckResults};\n use crate::dataflow::indexes::{BorrowIndex, InitIndex, MoveOutIndex, MovePathIndex};\n-use crate::dataflow::move_paths::{HasMoveData, InitLocation, LookupResult, MoveData, MoveError};\n+use crate::dataflow::move_paths::{InitLocation, LookupResult, MoveData, MoveError};\n use crate::dataflow::Borrows;\n-use crate::dataflow::DataflowResultsConsumer;\n use crate::dataflow::EverInitializedPlaces;\n-use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MoveDataParamEnv;\n-use crate::dataflow::{do_dataflow, DebugFormatted};\n use crate::dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use crate::transform::MirSource;\n \n use self::diagnostics::{AccessKind, RegionName};\n-use self::flows::Flows;\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n use self::MutateMode::{JustWrite, WriteAndRead};\n@@ -54,7 +53,6 @@ mod constraint_generation;\n mod constraints;\n mod diagnostics;\n mod facts;\n-mod flows;\n mod invalidation;\n mod location;\n mod member_constraints;\n@@ -70,7 +68,7 @@ mod universal_regions;\n mod used_muts;\n \n crate use borrow_set::{BorrowData, BorrowSet};\n-crate use nll::ToRegionVid;\n+crate use nll::{PoloniusOutput, ToRegionVid};\n crate use place_ext::PlaceExt;\n crate use places_conflict::{places_conflict, PlaceConflictBias};\n crate use region_infer::RegionInferenceContext;\n@@ -115,7 +113,6 @@ fn do_mir_borrowck<'a, 'tcx>(\n     debug!(\"do_mir_borrowck(def_id = {:?})\", def_id);\n \n     let tcx = infcx.tcx;\n-    let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);\n     let id = tcx.hir().as_local_hir_id(def_id).expect(\"do_mir_borrowck: non-local DefId\");\n \n@@ -188,16 +185,10 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let mdpe = MoveDataParamEnv { move_data, param_env };\n \n-    let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n-    let mut flow_inits = FlowAtLocation::new(do_dataflow(\n-        tcx,\n-        &body,\n-        def_id,\n-        &attributes,\n-        &dead_unwinds,\n-        MaybeInitializedPlaces::new(tcx, &body, &mdpe),\n-        |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n-    ));\n+    let mut flow_inits = MaybeInitializedPlaces::new(tcx, &body, &mdpe)\n+        .into_engine(tcx, &body, def_id)\n+        .iterate_to_fixpoint()\n+        .into_results_cursor(&body);\n \n     let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind(id).is_fn_or_closure();\n     let borrow_set =\n@@ -233,33 +224,15 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let regioncx = Rc::new(regioncx);\n \n-    let flow_borrows = FlowAtLocation::new(do_dataflow(\n-        tcx,\n-        &body,\n-        def_id,\n-        &attributes,\n-        &dead_unwinds,\n-        Borrows::new(tcx, &body, regioncx.clone(), &borrow_set),\n-        |rs, i| DebugFormatted::new(&rs.location(i)),\n-    ));\n-    let flow_uninits = FlowAtLocation::new(do_dataflow(\n-        tcx,\n-        &body,\n-        def_id,\n-        &attributes,\n-        &dead_unwinds,\n-        MaybeUninitializedPlaces::new(tcx, &body, &mdpe),\n-        |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n-    ));\n-    let flow_ever_inits = FlowAtLocation::new(do_dataflow(\n-        tcx,\n-        &body,\n-        def_id,\n-        &attributes,\n-        &dead_unwinds,\n-        EverInitializedPlaces::new(tcx, &body, &mdpe),\n-        |bd, i| DebugFormatted::new(&bd.move_data().inits[i]),\n-    ));\n+    let flow_borrows = Borrows::new(tcx, &body, regioncx.clone(), &borrow_set)\n+        .into_engine(tcx, &body, def_id)\n+        .iterate_to_fixpoint();\n+    let flow_uninits = MaybeUninitializedPlaces::new(tcx, &body, &mdpe)\n+        .into_engine(tcx, &body, def_id)\n+        .iterate_to_fixpoint();\n+    let flow_ever_inits = EverInitializedPlaces::new(tcx, &body, &mdpe)\n+        .into_engine(tcx, &body, def_id)\n+        .iterate_to_fixpoint();\n \n     let movable_generator = match tcx.hir().get(id) {\n         Node::Expr(&hir::Expr {\n@@ -294,17 +267,28 @@ fn do_mir_borrowck<'a, 'tcx>(\n         local_names,\n         region_names: RefCell::default(),\n         next_region_name: RefCell::new(1),\n+        polonius_output,\n     };\n \n     // Compute and report region errors, if any.\n     mbcx.report_region_errors(nll_errors);\n \n-    let mut state = Flows::new(flow_borrows, flow_uninits, flow_ever_inits, polonius_output);\n+    let results = BorrowckResults {\n+        ever_inits: flow_ever_inits,\n+        uninits: flow_uninits,\n+        borrows: flow_borrows,\n+    };\n \n     if let Some(errors) = move_errors {\n         mbcx.report_move_errors(errors);\n     }\n-    mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n+\n+    dataflow::generic::visit_results(\n+        &*body,\n+        traversal::reverse_postorder(&*body).map(|(bb, _)| bb),\n+        &results,\n+        &mut mbcx,\n+    );\n \n     // Convert any reservation warnings into lints.\n     let reservation_warnings = mem::take(&mut mbcx.reservation_warnings);\n@@ -499,31 +483,26 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// The counter for generating new region names.\n     next_region_name: RefCell<usize>,\n+\n+    /// Results of Polonius analysis.\n+    polonius_output: Option<Rc<PoloniusOutput>>,\n }\n \n // Check that:\n // 1. assignments are always made to mutable locations (FIXME: does that still really go here?)\n // 2. loans made in overlapping scopes do not conflict\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves do not affect things loaned out in any way\n-impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx> {\n+impl<'cx, 'tcx> dataflow::generic::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx> {\n     type FlowState = Flows<'cx, 'tcx>;\n \n-    fn body(&self) -> &'cx Body<'tcx> {\n-        *self.body\n-    }\n-\n-    fn visit_block_entry(&mut self, bb: BasicBlock, flow_state: &Self::FlowState) {\n-        debug!(\"MirBorrowckCtxt::process_block({:?}): {}\", bb, flow_state);\n-    }\n-\n-    fn visit_statement_entry(\n+    fn visit_statement(\n         &mut self,\n-        location: Location,\n+        flow_state: &Flows<'cx, 'tcx>,\n         stmt: &'cx Statement<'tcx>,\n-        flow_state: &Self::FlowState,\n+        location: Location,\n     ) {\n-        debug!(\"MirBorrowckCtxt::process_statement({:?}, {:?}): {}\", location, stmt, flow_state);\n+        debug!(\"MirBorrowckCtxt::process_statement({:?}, {:?}): {:?}\", location, stmt, flow_state);\n         let span = stmt.source_info.span;\n \n         self.check_activations(location, span, flow_state);\n@@ -606,17 +585,16 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n         }\n     }\n \n-    fn visit_terminator_entry(\n+    fn visit_terminator(\n         &mut self,\n-        location: Location,\n+        flow_state: &Flows<'cx, 'tcx>,\n         term: &'cx Terminator<'tcx>,\n-        flow_state: &Self::FlowState,\n+        loc: Location,\n     ) {\n-        let loc = location;\n-        debug!(\"MirBorrowckCtxt::process_terminator({:?}, {:?}): {}\", location, term, flow_state);\n+        debug!(\"MirBorrowckCtxt::process_terminator({:?}, {:?}): {:?}\", loc, term, flow_state);\n         let span = term.source_info.span;\n \n-        self.check_activations(location, span, flow_state);\n+        self.check_activations(loc, span, flow_state);\n \n         match term.kind {\n             TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n@@ -685,19 +663,40 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n \n             TerminatorKind::Yield { ref value, resume: _, ref resume_arg, drop: _ } => {\n                 self.consume_operand(loc, (value, span), flow_state);\n+                self.mutate_place(loc, (resume_arg, span), Deep, JustWrite, flow_state);\n+            }\n \n+            TerminatorKind::Goto { target: _ }\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Return\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::FalseEdges { real_target: _, imaginary_target: _ }\n+            | TerminatorKind::FalseUnwind { real_target: _, unwind: _ } => {\n+                // no data used, thus irrelevant to borrowck\n+            }\n+        }\n+    }\n+\n+    fn visit_terminator_exit(\n+        &mut self,\n+        flow_state: &Flows<'cx, 'tcx>,\n+        term: &'cx Terminator<'tcx>,\n+        loc: Location,\n+    ) {\n+        let span = term.source_info.span;\n+\n+        match term.kind {\n+            TerminatorKind::Yield { value: _, resume: _, resume_arg: _, drop: _ } => {\n                 if self.movable_generator {\n                     // Look for any active borrows to locals\n                     let borrow_set = self.borrow_set.clone();\n-                    flow_state.with_outgoing_borrows(|borrows| {\n-                        for i in borrows {\n-                            let borrow = &borrow_set[i];\n-                            self.check_for_local_borrow(borrow, span);\n-                        }\n-                    });\n+                    for i in flow_state.borrows.iter() {\n+                        let borrow = &borrow_set[i];\n+                        self.check_for_local_borrow(borrow, span);\n+                    }\n                 }\n-\n-                self.mutate_place(loc, (resume_arg, span), Deep, JustWrite, flow_state);\n             }\n \n             TerminatorKind::Resume | TerminatorKind::Return | TerminatorKind::GeneratorDrop => {\n@@ -706,20 +705,22 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 // StorageDead, but we don't always emit those (notably on unwind paths),\n                 // so this \"extra check\" serves as a kind of backup.\n                 let borrow_set = self.borrow_set.clone();\n-                flow_state.with_outgoing_borrows(|borrows| {\n-                    for i in borrows {\n-                        let borrow = &borrow_set[i];\n-                        self.check_for_invalidation_at_exit(loc, borrow, span);\n-                    }\n-                });\n+                for i in flow_state.borrows.iter() {\n+                    let borrow = &borrow_set[i];\n+                    self.check_for_invalidation_at_exit(loc, borrow, span);\n+                }\n             }\n-            TerminatorKind::Goto { target: _ }\n-            | TerminatorKind::Abort\n-            | TerminatorKind::Unreachable\n+\n+            TerminatorKind::Abort\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::Call { .. }\n+            | TerminatorKind::Drop { .. }\n+            | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::FalseEdges { real_target: _, imaginary_target: _ }\n-            | TerminatorKind::FalseUnwind { real_target: _, unwind: _ } => {\n-                // no data used, thus irrelevant to borrowck\n-            }\n+            | TerminatorKind::FalseUnwind { real_target: _, unwind: _ }\n+            | TerminatorKind::Goto { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Unreachable => {}\n         }\n     }\n }\n@@ -854,6 +855,10 @@ impl InitializationRequiringAction {\n }\n \n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n+    fn body(&self) -> &'cx Body<'tcx> {\n+        *self.body\n+    }\n+\n     /// Checks an access to the given place to see if it is allowed. Examines the set of borrows\n     /// that are in scope, as well as which paths have been initialized, to ensure that (a) the\n     /// place is initialized and (b) it is not borrowed in some way that would prevent this\n@@ -933,16 +938,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         let body = self.body;\n         let body: &Body<'_> = &body;\n-        let location_table = self.location_table.start_index(location);\n         let borrow_set = self.borrow_set.clone();\n+\n+        // Use polonius output if it has been enabled.\n+        let polonius_output = self.polonius_output.clone();\n+        let borrows_in_scope = if let Some(polonius) = &polonius_output {\n+            let location = self.location_table.start_index(location);\n+            Either::Left(polonius.errors_at(location).iter().copied())\n+        } else {\n+            Either::Right(flow_state.borrows.iter())\n+        };\n+\n         each_borrow_involving_path(\n             self,\n             tcx,\n             body,\n             location,\n             (sd, place_span.0),\n             &borrow_set,\n-            flow_state.borrows_in_scope(location_table),\n+            borrows_in_scope,\n             |this, borrow_index, borrow| match (rw, borrow.kind) {\n                 // Obviously an activation is compatible with its own\n                 // reservation (or even prior activating uses of same\n@@ -1472,9 +1486,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // initial reservation.\n         }\n     }\n-}\n \n-impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn check_if_reassignment_to_immutable_state(\n         &mut self,\n         location: Location,\n@@ -1564,21 +1576,26 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         location: Location,\n         desired_action: InitializationRequiringAction,\n         place_span: (PlaceRef<'cx, 'tcx>, Span),\n-        maybe_uninits: &FlowAtLocation<'tcx, MaybeUninitializedPlaces<'cx, 'tcx>>,\n+        maybe_uninits: &BitSet<MovePathIndex>,\n         from: u32,\n         to: u32,\n     ) {\n         if let Some(mpi) = self.move_path_for_place(place_span.0) {\n-            let mut child = self.move_data.move_paths[mpi].first_child;\n+            let move_paths = &self.move_data.move_paths;\n+            let mut child = move_paths[mpi].first_child;\n             while let Some(child_mpi) = child {\n-                let child_move_place = &self.move_data.move_paths[child_mpi];\n-                let child_place = &child_move_place.place;\n-                let last_proj = child_place.projection.last().unwrap();\n+                let child_move_path = &move_paths[child_mpi];\n+                let last_proj = child_move_path.place.projection.last().unwrap();\n                 if let ProjectionElem::ConstantIndex { offset, from_end, .. } = last_proj {\n                     debug_assert!(!from_end, \"Array constant indexing shouldn't be `from_end`.\");\n \n                     if (from..to).contains(offset) {\n-                        if let Some(uninit_child) = maybe_uninits.has_any_child_of(child_mpi) {\n+                        let uninit_child =\n+                            self.move_data.find_in_move_path_or_its_descendants(child_mpi, |mpi| {\n+                                maybe_uninits.contains(mpi)\n+                            });\n+\n+                        if let Some(uninit_child) = uninit_child {\n                             self.report_use_of_moved_or_uninitialized(\n                                 location,\n                                 desired_action,\n@@ -1589,7 +1606,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         }\n                     }\n                 }\n-                child = child_move_place.next_sibling;\n+                child = child_move_path.next_sibling;\n             }\n         }\n     }\n@@ -1650,12 +1667,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         debug!(\"check_if_path_or_subpath_is_moved place: {:?}\", place_span.0);\n         if let Some(mpi) = self.move_path_for_place(place_span.0) {\n-            if let Some(child_mpi) = maybe_uninits.has_any_child_of(mpi) {\n+            let uninit_mpi = self\n+                .move_data\n+                .find_in_move_path_or_its_descendants(mpi, |mpi| maybe_uninits.contains(mpi));\n+\n+            if let Some(uninit_mpi) = uninit_mpi {\n                 self.report_use_of_moved_or_uninitialized(\n                     location,\n                     desired_action,\n                     (place_span.0, place_span.0, place_span.1),\n-                    child_mpi,\n+                    uninit_mpi,\n                 );\n                 return; // don't bother finding other problems.\n             }"}, {"sha": "a71dfc9a7780fe754f3d7d94e3233bac2da01e5b", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -20,8 +20,8 @@ use std::str::FromStr;\n use self::mir_util::PassWhere;\n use polonius_engine::{Algorithm, Output};\n \n+use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::move_paths::{InitKind, InitLocation, MoveData};\n-use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n use crate::transform::MirSource;\n use crate::util as mir_util;\n@@ -149,7 +149,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     promoted: &IndexVec<Promoted, ReadOnlyBodyAndCache<'_, 'tcx>>,\n     location_table: &LocationTable,\n     param_env: ty::ParamEnv<'tcx>,\n-    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'cx, 'tcx>>,\n+    flow_inits: &mut ResultsCursor<'cx, 'tcx, MaybeInitializedPlaces<'cx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n ) -> NllOutput<'tcx> {"}, {"sha": "cdf962ee31a6ee66bad985e34eb47bb913b539ab", "filename": "src/librustc_mir/borrow_check/type_check/liveness/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -3,8 +3,8 @@ use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use std::rc::Rc;\n \n+use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::move_paths::MoveData;\n-use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n \n use crate::borrow_check::{\n@@ -30,11 +30,11 @@ mod trace;\n ///\n /// N.B., this computation requires normalization; therefore, it must be\n /// performed before\n-pub(super) fn generate<'tcx>(\n+pub(super) fn generate<'mir, 'tcx>(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n     body: ReadOnlyBodyAndCache<'_, 'tcx>,\n     elements: &Rc<RegionValueElements>,\n-    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n+    flow_inits: &mut ResultsCursor<'mir, 'tcx, MaybeInitializedPlaces<'mir, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     location_table: &LocationTable,\n ) {"}, {"sha": "198f4b4b42e052d048c155a56a08a7914266eeee", "filename": "src/librustc_mir/borrow_check/type_check/liveness/trace.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -8,9 +8,10 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::bit_set::HybridBitSet;\n use std::rc::Rc;\n \n+use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::indexes::MovePathIndex;\n-use crate::dataflow::move_paths::MoveData;\n-use crate::dataflow::{FlowAtLocation, FlowsAtLocation, MaybeInitializedPlaces};\n+use crate::dataflow::move_paths::{HasMoveData, MoveData};\n+use crate::dataflow::MaybeInitializedPlaces;\n \n use crate::borrow_check::{\n     region_infer::values::{self, PointIndex, RegionValueElements},\n@@ -38,7 +39,7 @@ pub(super) fn trace(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n     body: ReadOnlyBodyAndCache<'_, 'tcx>,\n     elements: &Rc<RegionValueElements>,\n-    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n+    flow_inits: &mut ResultsCursor<'mir, 'tcx, MaybeInitializedPlaces<'mir, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     live_locals: Vec<Local>,\n     polonius_drop_used: Option<Vec<(Local, Location)>>,\n@@ -85,7 +86,7 @@ struct LivenessContext<'me, 'typeck, 'flow, 'tcx> {\n \n     /// Results of dataflow tracking which variables (and paths) have been\n     /// initialized.\n-    flow_inits: &'me mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'flow, 'tcx>>,\n+    flow_inits: &'me mut ResultsCursor<'flow, 'tcx, MaybeInitializedPlaces<'flow, 'tcx>>,\n \n     /// Index indicating where each variable is assigned, used, or\n     /// dropped.\n@@ -389,23 +390,26 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n }\n \n impl LivenessContext<'_, '_, '_, 'tcx> {\n+    /// Returns `true` if the local variable (or some part of it) is initialized at the current\n+    /// cursor position. Callers should call one of the `seek` methods immediately before to point\n+    /// the cursor to the desired location.\n+    fn initialized_at_curr_loc(&self, mpi: MovePathIndex) -> bool {\n+        let state = self.flow_inits.get();\n+        if state.contains(mpi) {\n+            return true;\n+        }\n+\n+        let move_paths = &self.flow_inits.analysis().move_data().move_paths;\n+        move_paths[mpi].find_descendant(&move_paths, |mpi| state.contains(mpi)).is_some()\n+    }\n+\n     /// Returns `true` if the local variable (or some part of it) is initialized in\n     /// the terminator of `block`. We need to check this to determine if a\n     /// DROP of some local variable will have an effect -- note that\n     /// drops, as they may unwind, are always terminators.\n     fn initialized_at_terminator(&mut self, block: BasicBlock, mpi: MovePathIndex) -> bool {\n-        // Compute the set of initialized paths at terminator of block\n-        // by resetting to the start of the block and then applying\n-        // the effects of all statements. This is the only way to get\n-        // \"just ahead\" of a terminator.\n-        self.flow_inits.reset_to_entry_of(block);\n-        for statement_index in 0..self.body[block].statements.len() {\n-            let location = Location { block, statement_index };\n-            self.flow_inits.reconstruct_statement_effect(location);\n-            self.flow_inits.apply_local_effect(location);\n-        }\n-\n-        self.flow_inits.has_any_child_of(mpi).is_some()\n+        self.flow_inits.seek_before(self.body.terminator_loc(block));\n+        self.initialized_at_curr_loc(mpi)\n     }\n \n     /// Returns `true` if the path `mpi` (or some part of it) is initialized at\n@@ -414,8 +418,8 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n     /// **Warning:** Does not account for the result of `Call`\n     /// instructions.\n     fn initialized_at_exit(&mut self, block: BasicBlock, mpi: MovePathIndex) -> bool {\n-        self.flow_inits.reset_to_exit_of(block);\n-        self.flow_inits.has_any_child_of(mpi).is_some()\n+        self.flow_inits.seek_after(self.body.terminator_loc(block));\n+        self.initialized_at_curr_loc(mpi)\n     }\n \n     /// Stores the result that all regions in `value` are live for the"}, {"sha": "100fd7dc48d0e7b7db0d05997378e32f8f6eaab8", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -34,8 +34,8 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_span::{Span, DUMMY_SP};\n use syntax::ast;\n \n+use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::move_paths::MoveData;\n-use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n use crate::transform::promote_consts::should_suggest_const_in_array_repeat_expressions_attribute;\n \n@@ -114,7 +114,7 @@ mod relate_tys;\n ///   constraints for the regions in the types of variables\n /// - `flow_inits` -- results of a maybe-init dataflow analysis\n /// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysis\n-pub(crate) fn type_check<'tcx>(\n+pub(crate) fn type_check<'mir, 'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: ReadOnlyBodyAndCache<'_, 'tcx>,\n@@ -124,7 +124,7 @@ pub(crate) fn type_check<'tcx>(\n     location_table: &LocationTable,\n     borrow_set: &BorrowSet<'tcx>,\n     all_facts: &mut Option<AllFacts>,\n-    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n+    flow_inits: &mut ResultsCursor<'mir, 'tcx, MaybeInitializedPlaces<'mir, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     elements: &Rc<RegionValueElements>,\n ) -> MirTypeckResults<'tcx> {"}, {"sha": "e4eb8506846c0b60b571ef0fc9603e780f2a2277", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -4,7 +4,6 @@\n use rustc::mir::{BasicBlock, Location};\n use rustc_index::bit_set::{BitIter, BitSet, HybridBitSet};\n \n-use crate::dataflow::move_paths::{HasMoveData, MovePathIndex};\n use crate::dataflow::{BitDenotation, DataflowResults, GenKillSet};\n \n use std::borrow::Borrow;\n@@ -168,43 +167,3 @@ where\n         self.stmt_trans.apply(&mut self.curr_state)\n     }\n }\n-\n-impl<'tcx, T, DR> FlowAtLocation<'tcx, T, DR>\n-where\n-    T: HasMoveData<'tcx> + BitDenotation<'tcx, Idx = MovePathIndex>,\n-    DR: Borrow<DataflowResults<'tcx, T>>,\n-{\n-    pub fn has_any_child_of(&self, mpi: T::Idx) -> Option<T::Idx> {\n-        // We process `mpi` before the loop below, for two reasons:\n-        // - it's a little different from the loop case (we don't traverse its\n-        //   siblings);\n-        // - ~99% of the time the loop isn't reached, and this code is hot, so\n-        //   we don't want to allocate `todo` unnecessarily.\n-        if self.contains(mpi) {\n-            return Some(mpi);\n-        }\n-        let move_data = self.operator().move_data();\n-        let move_path = &move_data.move_paths[mpi];\n-        let mut todo = if let Some(child) = move_path.first_child {\n-            vec![child]\n-        } else {\n-            return None;\n-        };\n-\n-        while let Some(mpi) = todo.pop() {\n-            if self.contains(mpi) {\n-                return Some(mpi);\n-            }\n-            let move_path = &move_data.move_paths[mpi];\n-            if let Some(child) = move_path.first_child {\n-                todo.push(child);\n-            }\n-            // After we've processed the original `mpi`, we should always\n-            // traverse the siblings of any of its children.\n-            if let Some(sibling) = move_path.next_sibling {\n-                todo.push(sibling);\n-            }\n-        }\n-        return None;\n-    }\n-}"}, {"sha": "8c0ab1505284a0d5014e98ad7674bc1bfd10a1b1", "filename": "src/librustc_mir/dataflow/generic/cursor.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fcursor.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -65,6 +65,13 @@ where\n         &self.state\n     }\n \n+    /// Returns `true` if the dataflow state at the current location contains the given element.\n+    ///\n+    /// Shorthand for `self.get().contains(elem)`\n+    pub fn contains(&self, elem: A::Idx) -> bool {\n+        self.state.contains(elem)\n+    }\n+\n     /// Resets the cursor to the start of the given basic block.\n     pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n         self.state.overwrite(&self.results.borrow().entry_sets[block]);"}, {"sha": "b81f0adc2015b972812dc0b860b65f10a0bc62c6", "filename": "src/librustc_mir/dataflow/generic/engine.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -44,15 +44,20 @@ where\n         def_id: DefId,\n         analysis: A,\n     ) -> Self {\n+        // If there are no back-edges in the control-flow graph, we only ever need to apply the\n+        // transfer function for each block exactly once (assuming that we process blocks in RPO).\n+        //\n+        // In this case, there's no need to compute the block transfer functions ahead of time.\n+        if !body.is_cfg_cyclic() {\n+            return Self::new(tcx, body, def_id, analysis, None);\n+        }\n+\n+        // Otherwise, compute and store the cumulative transfer function for each block.\n+\n         let bits_per_block = analysis.bits_per_block(body);\n         let mut trans_for_block =\n             IndexVec::from_elem(GenKillSet::identity(bits_per_block), body.basic_blocks());\n \n-        // Compute cumulative block transfer functions.\n-        //\n-        // FIXME: we may want to skip this if the MIR is acyclic, since we will never access a\n-        // block transfer function more than once.\n-\n         for (block, block_data) in body.basic_blocks().iter_enumerated() {\n             let trans = &mut trans_for_block[block];\n \n@@ -62,11 +67,10 @@ where\n                 analysis.statement_effect(trans, statement, loc);\n             }\n \n-            if let Some(terminator) = &block_data.terminator {\n-                let loc = Location { block, statement_index: block_data.statements.len() };\n-                analysis.before_terminator_effect(trans, terminator, loc);\n-                analysis.terminator_effect(trans, terminator, loc);\n-            }\n+            let terminator = block_data.terminator();\n+            let loc = Location { block, statement_index: block_data.statements.len() };\n+            analysis.before_terminator_effect(trans, terminator, loc);\n+            analysis.terminator_effect(trans, terminator, loc);\n         }\n \n         Self::new(tcx, body, def_id, analysis, Some(trans_for_block))"}, {"sha": "ea643042c5f8628fb064e08712324f1d76d149e9", "filename": "src/librustc_mir/dataflow/generic/mod.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -35,6 +35,8 @@\n use std::io;\n \n use rustc::mir::{self, BasicBlock, Location};\n+use rustc::ty::TyCtxt;\n+use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n use rustc_index::vec::{Idx, IndexVec};\n \n@@ -43,9 +45,12 @@ use crate::dataflow::BottomValue;\n mod cursor;\n mod engine;\n mod graphviz;\n+mod visitor;\n \n pub use self::cursor::{ResultsCursor, ResultsRefCursor};\n pub use self::engine::Engine;\n+pub use self::visitor::{visit_results, ResultsVisitor};\n+pub use self::visitor::{BorrowckFlowState, BorrowckResults};\n \n /// A dataflow analysis that has converged to fixpoint.\n pub struct Results<'tcx, A>\n@@ -166,6 +171,30 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n         args: &[mir::Operand<'tcx>],\n         return_place: &mir::Place<'tcx>,\n     );\n+\n+    /// Calls the appropriate `Engine` constructor to find the fixpoint for this dataflow problem.\n+    ///\n+    /// You shouldn't need to override this outside this module, since the combination of the\n+    /// default impl and the one for all `A: GenKillAnalysis` will do the right thing.\n+    /// Its purpose is to enable method chaining like so:\n+    ///\n+    /// ```ignore(cross-crate-imports)\n+    /// let results = MyAnalysis::new(tcx, body)\n+    ///     .into_engine(tcx, body, def_id)\n+    ///     .iterate_to_fixpoint()\n+    ///     .into_results_cursor(body);\n+    /// ```\n+    fn into_engine(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        body: &'mir mir::Body<'tcx>,\n+        def_id: DefId,\n+    ) -> Engine<'mir, 'tcx, Self>\n+    where\n+        Self: Sized,\n+    {\n+        Engine::new_generic(tcx, body, def_id, self)\n+    }\n }\n \n /// A gen/kill dataflow problem.\n@@ -272,6 +301,18 @@ where\n     ) {\n         self.call_return_effect(state, block, func, args, return_place);\n     }\n+\n+    fn into_engine(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        body: &'mir mir::Body<'tcx>,\n+        def_id: DefId,\n+    ) -> Engine<'mir, 'tcx, Self>\n+    where\n+        Self: Sized,\n+    {\n+        Engine::new_gen_kill(tcx, body, def_id, self)\n+    }\n }\n \n /// The legal operations for a transfer function in a gen/kill problem."}, {"sha": "5bad8c61a0cd7068d8e8b3f016cf50ece8318d0f", "filename": "src/librustc_mir/dataflow/generic/visitor.rs", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fvisitor.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -0,0 +1,272 @@\n+use rustc::mir::{self, BasicBlock, Location};\n+use rustc_index::bit_set::BitSet;\n+\n+use super::{Analysis, Results};\n+use crate::dataflow::impls::{borrows::Borrows, EverInitializedPlaces, MaybeUninitializedPlaces};\n+\n+/// Calls the corresponding method in `ResultsVisitor` for every location in a `mir::Body` with the\n+/// dataflow state at that location.\n+pub fn visit_results<F>(\n+    body: &'mir mir::Body<'tcx>,\n+    blocks: impl IntoIterator<Item = BasicBlock>,\n+    results: &impl ResultsVisitable<'tcx, FlowState = F>,\n+    vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = F>,\n+) {\n+    let mut state = results.new_flow_state(body);\n+\n+    for block in blocks {\n+        let block_data = &body[block];\n+        results.reset_to_block_start(&mut state, block);\n+\n+        for (statement_index, stmt) in block_data.statements.iter().enumerate() {\n+            let loc = Location { block, statement_index };\n+\n+            results.reconstruct_before_statement_effect(&mut state, stmt, loc);\n+            vis.visit_statement(&mut state, stmt, loc);\n+\n+            results.reconstruct_statement_effect(&mut state, stmt, loc);\n+            vis.visit_statement_exit(&mut state, stmt, loc);\n+        }\n+\n+        let loc = body.terminator_loc(block);\n+        let term = block_data.terminator();\n+\n+        results.reconstruct_before_terminator_effect(&mut state, term, loc);\n+        vis.visit_terminator(&mut state, term, loc);\n+\n+        results.reconstruct_terminator_effect(&mut state, term, loc);\n+        vis.visit_terminator_exit(&mut state, term, loc);\n+    }\n+}\n+\n+pub trait ResultsVisitor<'mir, 'tcx> {\n+    type FlowState;\n+\n+    /// Called with the `before_statement_effect` of the given statement applied to `state` but not\n+    /// its `statement_effect`.\n+    fn visit_statement(\n+        &mut self,\n+        _state: &Self::FlowState,\n+        _statement: &'mir mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+\n+    /// Called with both the `before_statement_effect` and the `statement_effect` of the given\n+    /// statement applied to `state`.\n+    fn visit_statement_exit(\n+        &mut self,\n+        _state: &Self::FlowState,\n+        _statement: &'mir mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+\n+    /// Called with the `before_terminator_effect` of the given terminator applied to `state` but not\n+    /// its `terminator_effect`.\n+    fn visit_terminator(\n+        &mut self,\n+        _state: &Self::FlowState,\n+        _terminator: &'mir mir::Terminator<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+\n+    /// Called with both the `before_terminator_effect` and the `terminator_effect` of the given\n+    /// terminator applied to `state`.\n+    ///\n+    /// The `call_return_effect` (if one exists) will *not* be applied to `state`.\n+    fn visit_terminator_exit(\n+        &mut self,\n+        _state: &Self::FlowState,\n+        _terminator: &'mir mir::Terminator<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+}\n+\n+/// Things that can be visited by a `ResultsVisitor`.\n+///\n+/// This trait exists so that we can visit the results of multiple dataflow analyses simultaneously.\n+/// DO NOT IMPLEMENT MANUALLY. Instead, use the `impl_visitable` macro below.\n+pub trait ResultsVisitable<'tcx> {\n+    type FlowState;\n+\n+    /// Creates an empty `FlowState` to hold the transient state for these dataflow results.\n+    ///\n+    /// The value of the newly created `FlowState` will be overwritten by `reset_to_block_start`\n+    /// before it can be observed by a `ResultsVisitor`.\n+    fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState;\n+\n+    fn reset_to_block_start(&self, state: &mut Self::FlowState, block: BasicBlock);\n+\n+    fn reconstruct_before_statement_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    );\n+\n+    fn reconstruct_statement_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    );\n+\n+    fn reconstruct_before_terminator_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    );\n+\n+    fn reconstruct_terminator_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    );\n+}\n+\n+impl<'tcx, A> ResultsVisitable<'tcx> for Results<'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    type FlowState = BitSet<A::Idx>;\n+\n+    fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState {\n+        BitSet::new_empty(self.analysis.bits_per_block(body))\n+    }\n+\n+    fn reset_to_block_start(&self, state: &mut Self::FlowState, block: BasicBlock) {\n+        state.overwrite(&self.entry_set_for_block(block));\n+    }\n+\n+    fn reconstruct_before_statement_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        stmt: &mir::Statement<'tcx>,\n+        loc: Location,\n+    ) {\n+        self.analysis.apply_before_statement_effect(state, stmt, loc);\n+    }\n+\n+    fn reconstruct_statement_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        stmt: &mir::Statement<'tcx>,\n+        loc: Location,\n+    ) {\n+        self.analysis.apply_statement_effect(state, stmt, loc);\n+    }\n+\n+    fn reconstruct_before_terminator_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        term: &mir::Terminator<'tcx>,\n+        loc: Location,\n+    ) {\n+        self.analysis.apply_before_terminator_effect(state, term, loc);\n+    }\n+\n+    fn reconstruct_terminator_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        term: &mir::Terminator<'tcx>,\n+        loc: Location,\n+    ) {\n+        self.analysis.apply_terminator_effect(state, term, loc);\n+    }\n+}\n+\n+/// A tuple with named fields that can hold either the results or the transient state of the\n+/// dataflow analyses used by the borrow checker.\n+#[derive(Debug)]\n+pub struct BorrowckAnalyses<B, U, E> {\n+    pub borrows: B,\n+    pub uninits: U,\n+    pub ever_inits: E,\n+}\n+\n+/// The results of the dataflow analyses used by the borrow checker.\n+pub type BorrowckResults<'mir, 'tcx> = BorrowckAnalyses<\n+    Results<'tcx, Borrows<'mir, 'tcx>>,\n+    Results<'tcx, MaybeUninitializedPlaces<'mir, 'tcx>>,\n+    Results<'tcx, EverInitializedPlaces<'mir, 'tcx>>,\n+>;\n+\n+/// The transient state of the dataflow analyses used by the borrow checker.\n+pub type BorrowckFlowState<'mir, 'tcx> =\n+    <BorrowckResults<'mir, 'tcx> as ResultsVisitable<'tcx>>::FlowState;\n+\n+macro_rules! impl_visitable {\n+    ( $(\n+        $T:ident { $( $field:ident : $A:ident ),* $(,)? }\n+    )* ) => { $(\n+        impl<'tcx, $($A),*> ResultsVisitable<'tcx> for $T<$( Results<'tcx, $A> ),*>\n+        where\n+            $( $A: Analysis<'tcx>, )*\n+        {\n+            type FlowState = $T<$( BitSet<$A::Idx> ),*>;\n+\n+            fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState {\n+                $T {\n+                    $( $field: BitSet::new_empty(self.$field.analysis.bits_per_block(body)) ),*\n+                }\n+            }\n+\n+            fn reset_to_block_start(\n+                &self,\n+                state: &mut Self::FlowState,\n+                block: BasicBlock,\n+            ) {\n+                $( state.$field.overwrite(&self.$field.entry_sets[block]); )*\n+            }\n+\n+            fn reconstruct_before_statement_effect(\n+                &self,\n+                state: &mut Self::FlowState,\n+                stmt: &mir::Statement<'tcx>,\n+                loc: Location,\n+            ) {\n+                $( self.$field.analysis\n+                    .apply_before_statement_effect(&mut state.$field, stmt, loc); )*\n+            }\n+\n+            fn reconstruct_statement_effect(\n+                &self,\n+                state: &mut Self::FlowState,\n+                stmt: &mir::Statement<'tcx>,\n+                loc: Location,\n+            ) {\n+                $( self.$field.analysis\n+                    .apply_statement_effect(&mut state.$field, stmt, loc); )*\n+            }\n+\n+            fn reconstruct_before_terminator_effect(\n+                &self,\n+                state: &mut Self::FlowState,\n+                term: &mir::Terminator<'tcx>,\n+                loc: Location,\n+            ) {\n+                $( self.$field.analysis\n+                    .apply_before_terminator_effect(&mut state.$field, term, loc); )*\n+            }\n+\n+            fn reconstruct_terminator_effect(\n+                &self,\n+                state: &mut Self::FlowState,\n+                term: &mir::Terminator<'tcx>,\n+                loc: Location,\n+            ) {\n+                $( self.$field.analysis\n+                    .apply_terminator_effect(&mut state.$field, term, loc); )*\n+            }\n+        }\n+    )* }\n+}\n+\n+impl_visitable! {\n+    BorrowckAnalyses { borrows: B, uninits: U, ever_inits: E }\n+}"}, {"sha": "74d1094f9645e2d9348af309b93b314ba34e9803", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 56, "deletions": 40, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -4,13 +4,12 @@ use rustc::ty::TyCtxt;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n \n use crate::borrow_check::{\n-    places_conflict, BorrowData, BorrowSet, PlaceConflictBias, PlaceExt, RegionInferenceContext,\n-    ToRegionVid,\n+    places_conflict, BorrowSet, PlaceConflictBias, PlaceExt, RegionInferenceContext, ToRegionVid,\n };\n-use crate::dataflow::{BitDenotation, BottomValue, GenKillSet};\n+use crate::dataflow::generic::{self, GenKill};\n+use crate::dataflow::BottomValue;\n \n use std::rc::Rc;\n \n@@ -160,10 +159,6 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         }\n     }\n \n-    crate fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> {\n-        &self.borrow_set.borrows\n-    }\n-\n     pub fn location(&self, idx: BorrowIndex) -> &Location {\n         &self.borrow_set.borrows[idx].reserve_location\n     }\n@@ -172,7 +167,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     /// That means they went out of a nonlexical scope\n     fn kill_loans_out_of_scope_at_location(\n         &self,\n-        trans: &mut GenKillSet<BorrowIndex>,\n+        trans: &mut impl GenKill<BorrowIndex>,\n         location: Location,\n     ) {\n         // NOTE: The state associated with a given `location`\n@@ -187,16 +182,21 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         // region, then setting that gen-bit will override any\n         // potential kill introduced here.\n         if let Some(indices) = self.borrows_out_of_scope_at_location.get(&location) {\n-            trans.kill_all(indices);\n+            trans.kill_all(indices.iter().copied());\n         }\n     }\n \n     /// Kill any borrows that conflict with `place`.\n-    fn kill_borrows_on_place(&self, trans: &mut GenKillSet<BorrowIndex>, place: &Place<'tcx>) {\n+    fn kill_borrows_on_place(&self, trans: &mut impl GenKill<BorrowIndex>, place: &Place<'tcx>) {\n         debug!(\"kill_borrows_on_place: place={:?}\", place);\n \n-        let other_borrows_of_local =\n-            self.borrow_set.local_map.get(&place.local).into_iter().flat_map(|bs| bs.into_iter());\n+        let other_borrows_of_local = self\n+            .borrow_set\n+            .local_map\n+            .get(&place.local)\n+            .into_iter()\n+            .flat_map(|bs| bs.into_iter())\n+            .copied();\n \n         // If the borrowed place is a local with no projections, all other borrows of this\n         // local must conflict. This is purely an optimization so we don't have to call\n@@ -212,7 +212,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         // pair of array indices are unequal, so that when `places_conflict` returns true, we\n         // will be assured that two places being compared definitely denotes the same sets of\n         // locations.\n-        let definitely_conflicting_borrows = other_borrows_of_local.filter(|&&i| {\n+        let definitely_conflicting_borrows = other_borrows_of_local.filter(|&i| {\n             places_conflict(\n                 self.tcx,\n                 self.body,\n@@ -226,36 +226,41 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'tcx> {\n+impl<'tcx> generic::AnalysisDomain<'tcx> for Borrows<'_, 'tcx> {\n     type Idx = BorrowIndex;\n-    fn name() -> &'static str {\n-        \"borrows\"\n-    }\n-    fn bits_per_block(&self) -> usize {\n+\n+    const NAME: &'static str = \"borrows\";\n+\n+    fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n         self.borrow_set.borrows.len() * 2\n     }\n \n-    fn start_block_effect(&self, _entry_set: &mut BitSet<Self::Idx>) {\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut BitSet<Self::Idx>) {\n         // no borrows of code region_scopes have been taken prior to\n         // function execution, so this method has no effect.\n     }\n \n-    fn before_statement_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n-        debug!(\"Borrows::before_statement_effect trans: {:?} location: {:?}\", trans, location);\n-        self.kill_loans_out_of_scope_at_location(trans, location);\n+    fn pretty_print_idx(&self, w: &mut impl std::io::Write, idx: Self::Idx) -> std::io::Result<()> {\n+        write!(w, \"{:?}\", self.location(idx))\n     }\n+}\n \n-    fn statement_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n-        debug!(\"Borrows::statement_effect: trans={:?} location={:?}\", trans, location);\n-\n-        let block = &self.body.basic_blocks().get(location.block).unwrap_or_else(|| {\n-            panic!(\"could not find block at location {:?}\", location);\n-        });\n-        let stmt = block.statements.get(location.statement_index).unwrap_or_else(|| {\n-            panic!(\"could not find statement at location {:?}\");\n-        });\n+impl<'tcx> generic::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n+    fn before_statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        self.kill_loans_out_of_scope_at_location(trans, location);\n+    }\n \n-        debug!(\"Borrows::statement_effect: stmt={:?}\", stmt);\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        stmt: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n         match stmt.kind {\n             mir::StatementKind::Assign(box (ref lhs, ref rhs)) => {\n                 if let mir::Rvalue::Ref(_, _, ref place) = *rhs {\n@@ -301,18 +306,29 @@ impl<'a, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'tcx> {\n         }\n     }\n \n-    fn before_terminator_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n-        debug!(\"Borrows::before_terminator_effect: trans={:?} location={:?}\", trans, location);\n+    fn before_terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n         self.kill_loans_out_of_scope_at_location(trans, location);\n     }\n \n-    fn terminator_effect(&self, _: &mut GenKillSet<Self::Idx>, _: Location) {}\n+    fn terminator_effect(\n+        &self,\n+        _: &mut impl GenKill<Self::Idx>,\n+        _: &mir::Terminator<'tcx>,\n+        _: Location,\n+    ) {\n+    }\n \n-    fn propagate_call_return(\n+    fn call_return_effect(\n         &self,\n-        _in_out: &mut BitSet<BorrowIndex>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _block: mir::BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n         _dest_place: &mir::Place<'tcx>,\n     ) {\n     }"}, {"sha": "5b2264c2a65266b6a85c6537b48117b1b16858a8", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 140, "deletions": 75, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -11,8 +11,9 @@ use super::MoveDataParamEnv;\n \n use crate::util::elaborate_drops::DropFlagState;\n \n+use super::generic::{AnalysisDomain, GenKill, GenKillAnalysis};\n use super::move_paths::{HasMoveData, InitIndex, InitKind, MoveData, MovePathIndex};\n-use super::{BitDenotation, BottomValue, GenKillSet};\n+use super::{BottomValue, GenKillSet};\n \n use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;\n@@ -216,6 +217,7 @@ impl<'a, 'tcx> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n /// }\n /// ```\n pub struct EverInitializedPlaces<'a, 'tcx> {\n+    #[allow(dead_code)]\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'tcx>,\n@@ -235,7 +237,7 @@ impl<'a, 'tcx> HasMoveData<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n \n impl<'a, 'tcx> MaybeInitializedPlaces<'a, 'tcx> {\n     fn update_bits(\n-        trans: &mut GenKillSet<MovePathIndex>,\n+        trans: &mut impl GenKill<MovePathIndex>,\n         path: MovePathIndex,\n         state: DropFlagState,\n     ) {\n@@ -248,7 +250,7 @@ impl<'a, 'tcx> MaybeInitializedPlaces<'a, 'tcx> {\n \n impl<'a, 'tcx> MaybeUninitializedPlaces<'a, 'tcx> {\n     fn update_bits(\n-        trans: &mut GenKillSet<MovePathIndex>,\n+        trans: &mut impl GenKill<MovePathIndex>,\n         path: MovePathIndex,\n         state: DropFlagState,\n     ) {\n@@ -261,7 +263,7 @@ impl<'a, 'tcx> MaybeUninitializedPlaces<'a, 'tcx> {\n \n impl<'a, 'tcx> DefinitelyInitializedPlaces<'a, 'tcx> {\n     fn update_bits(\n-        trans: &mut GenKillSet<MovePathIndex>,\n+        trans: &mut impl GenKill<MovePathIndex>,\n         path: MovePathIndex,\n         state: DropFlagState,\n     ) {\n@@ -272,39 +274,56 @@ impl<'a, 'tcx> DefinitelyInitializedPlaces<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation<'tcx> for MaybeInitializedPlaces<'a, 'tcx> {\n+impl<'tcx> AnalysisDomain<'tcx> for MaybeInitializedPlaces<'_, 'tcx> {\n     type Idx = MovePathIndex;\n-    fn name() -> &'static str {\n-        \"maybe_init\"\n-    }\n-    fn bits_per_block(&self) -> usize {\n+\n+    const NAME: &'static str = \"maybe_init\";\n+\n+    fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n         self.move_data().move_paths.len()\n     }\n \n-    fn start_block_effect(&self, entry_set: &mut BitSet<MovePathIndex>) {\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n         drop_flag_effects_for_function_entry(self.tcx, self.body, self.mdpe, |path, s| {\n             assert!(s == DropFlagState::Present);\n-            entry_set.insert(path);\n+            state.insert(path);\n         });\n     }\n \n-    fn statement_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n+    fn pretty_print_idx(&self, w: &mut impl std::io::Write, mpi: Self::Idx) -> std::io::Result<()> {\n+        write!(w, \"{}\", self.move_data().move_paths[mpi])\n+    }\n+}\n+\n+impl<'tcx> GenKillAnalysis<'tcx> for MaybeInitializedPlaces<'_, 'tcx> {\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n         })\n     }\n \n-    fn terminator_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n         })\n     }\n \n-    fn propagate_call_return(\n+    fn call_return_effect(\n         &self,\n-        in_out: &mut BitSet<MovePathIndex>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _block: mir::BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n         dest_place: &mir::Place<'tcx>,\n     ) {\n         // when a call returns successfully, that means we need to set\n@@ -315,50 +334,67 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeInitializedPlaces<'a, 'tcx> {\n             self.move_data(),\n             self.move_data().rev_lookup.find(dest_place.as_ref()),\n             |mpi| {\n-                in_out.insert(mpi);\n+                trans.gen(mpi);\n             },\n         );\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation<'tcx> for MaybeUninitializedPlaces<'a, 'tcx> {\n+impl<'tcx> AnalysisDomain<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n     type Idx = MovePathIndex;\n-    fn name() -> &'static str {\n-        \"maybe_uninit\"\n-    }\n-    fn bits_per_block(&self) -> usize {\n+\n+    const NAME: &'static str = \"maybe_uninit\";\n+\n+    fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n         self.move_data().move_paths.len()\n     }\n \n     // sets on_entry bits for Arg places\n-    fn start_block_effect(&self, entry_set: &mut BitSet<MovePathIndex>) {\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n         // set all bits to 1 (uninit) before gathering counterevidence\n-        assert!(self.bits_per_block() == entry_set.domain_size());\n-        entry_set.insert_all();\n+        assert!(self.bits_per_block(body) == state.domain_size());\n+        state.insert_all();\n \n         drop_flag_effects_for_function_entry(self.tcx, self.body, self.mdpe, |path, s| {\n             assert!(s == DropFlagState::Present);\n-            entry_set.remove(path);\n+            state.remove(path);\n         });\n     }\n \n-    fn statement_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n+    fn pretty_print_idx(&self, w: &mut impl std::io::Write, mpi: Self::Idx) -> std::io::Result<()> {\n+        write!(w, \"{}\", self.move_data().move_paths[mpi])\n+    }\n+}\n+\n+impl<'tcx> GenKillAnalysis<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n         })\n     }\n \n-    fn terminator_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n         })\n     }\n \n-    fn propagate_call_return(\n+    fn call_return_effect(\n         &self,\n-        in_out: &mut BitSet<MovePathIndex>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _block: mir::BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n         dest_place: &mir::Place<'tcx>,\n     ) {\n         // when a call returns successfully, that means we need to set\n@@ -369,48 +405,65 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeUninitializedPlaces<'a, 'tcx> {\n             self.move_data(),\n             self.move_data().rev_lookup.find(dest_place.as_ref()),\n             |mpi| {\n-                in_out.remove(mpi);\n+                trans.kill(mpi);\n             },\n         );\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n+impl<'a, 'tcx> AnalysisDomain<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n     type Idx = MovePathIndex;\n-    fn name() -> &'static str {\n-        \"definite_init\"\n-    }\n-    fn bits_per_block(&self) -> usize {\n+\n+    const NAME: &'static str = \"definite_init\";\n+\n+    fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n         self.move_data().move_paths.len()\n     }\n \n     // sets on_entry bits for Arg places\n-    fn start_block_effect(&self, entry_set: &mut BitSet<MovePathIndex>) {\n-        entry_set.clear();\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n+        state.clear();\n \n         drop_flag_effects_for_function_entry(self.tcx, self.body, self.mdpe, |path, s| {\n             assert!(s == DropFlagState::Present);\n-            entry_set.insert(path);\n+            state.insert(path);\n         });\n     }\n \n-    fn statement_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n+    fn pretty_print_idx(&self, w: &mut impl std::io::Write, mpi: Self::Idx) -> std::io::Result<()> {\n+        write!(w, \"{}\", self.move_data().move_paths[mpi])\n+    }\n+}\n+\n+impl<'tcx> GenKillAnalysis<'tcx> for DefinitelyInitializedPlaces<'_, 'tcx> {\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n         })\n     }\n \n-    fn terminator_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n         })\n     }\n \n-    fn propagate_call_return(\n+    fn call_return_effect(\n         &self,\n-        in_out: &mut BitSet<MovePathIndex>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _block: mir::BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n         dest_place: &mir::Place<'tcx>,\n     ) {\n         // when a call returns successfully, that means we need to set\n@@ -421,30 +474,36 @@ impl<'a, 'tcx> BitDenotation<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n             self.move_data(),\n             self.move_data().rev_lookup.find(dest_place.as_ref()),\n             |mpi| {\n-                in_out.insert(mpi);\n+                trans.gen(mpi);\n             },\n         );\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n+impl<'tcx> AnalysisDomain<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n     type Idx = InitIndex;\n-    fn name() -> &'static str {\n-        \"ever_init\"\n-    }\n-    fn bits_per_block(&self) -> usize {\n+\n+    const NAME: &'static str = \"ever_init\";\n+\n+    fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n         self.move_data().inits.len()\n     }\n \n-    fn start_block_effect(&self, entry_set: &mut BitSet<InitIndex>) {\n-        for arg_init in 0..self.body.arg_count {\n-            entry_set.insert(InitIndex::new(arg_init));\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n+        for arg_init in 0..body.arg_count {\n+            state.insert(InitIndex::new(arg_init));\n         }\n     }\n+}\n \n-    fn statement_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n-        let (_, body, move_data) = (self.tcx, self.body, self.move_data());\n-        let stmt = &body[location.block].statements[location.statement_index];\n+impl<'tcx> GenKillAnalysis<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        stmt: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        let move_data = self.move_data();\n         let init_path_map = &move_data.init_path_map;\n         let init_loc_map = &move_data.init_loc_map;\n         let rev_lookup = &move_data.rev_lookup;\n@@ -453,7 +512,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n             \"statement {:?} at loc {:?} initializes move_indexes {:?}\",\n             stmt, location, &init_loc_map[location]\n         );\n-        trans.gen_all(&init_loc_map[location]);\n+        trans.gen_all(init_loc_map[location].iter().copied());\n \n         match stmt.kind {\n             mir::StatementKind::StorageDead(local) => {\n@@ -464,13 +523,18 @@ impl<'a, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n                     \"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n                     stmt, location, &init_path_map[move_path_index]\n                 );\n-                trans.kill_all(&init_path_map[move_path_index]);\n+                trans.kill_all(init_path_map[move_path_index].iter().copied());\n             }\n             _ => {}\n         }\n     }\n \n-    fn terminator_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n         let (body, move_data) = (self.body, self.move_data());\n         let term = body[location.block].terminator();\n         let init_loc_map = &move_data.init_loc_map;\n@@ -479,28 +543,29 @@ impl<'a, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n             term, location, &init_loc_map[location]\n         );\n         trans.gen_all(\n-            init_loc_map[location].iter().filter(|init_index| {\n-                move_data.inits[**init_index].kind != InitKind::NonPanicPathOnly\n-            }),\n+            init_loc_map[location]\n+                .iter()\n+                .filter(|init_index| {\n+                    move_data.inits[**init_index].kind != InitKind::NonPanicPathOnly\n+                })\n+                .copied(),\n         );\n     }\n \n-    fn propagate_call_return(\n+    fn call_return_effect(\n         &self,\n-        in_out: &mut BitSet<InitIndex>,\n-        call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        block: mir::BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n         _dest_place: &mir::Place<'tcx>,\n     ) {\n         let move_data = self.move_data();\n-        let bits_per_block = self.bits_per_block();\n         let init_loc_map = &move_data.init_loc_map;\n \n-        let call_loc =\n-            Location { block: call_bb, statement_index: self.body[call_bb].statements.len() };\n+        let call_loc = self.body.terminator_loc(block);\n         for init_index in &init_loc_map[call_loc] {\n-            assert!(init_index.index() < bits_per_block);\n-            in_out.insert(*init_index);\n+            trans.gen(*init_index);\n         }\n     }\n }"}, {"sha": "614a276164334203584bb1a64edf8aa3547f2f3c", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -72,6 +72,41 @@ impl<'tcx> MovePath<'tcx> {\n \n         parents\n     }\n+\n+    /// Finds the closest descendant of `self` for which `f` returns `true` using a breadth-first\n+    /// search.\n+    ///\n+    /// `f` will **not** be called on `self`.\n+    pub fn find_descendant(\n+        &self,\n+        move_paths: &IndexVec<MovePathIndex, MovePath<'_>>,\n+        f: impl Fn(MovePathIndex) -> bool,\n+    ) -> Option<MovePathIndex> {\n+        let mut todo = if let Some(child) = self.first_child {\n+            vec![child]\n+        } else {\n+            return None;\n+        };\n+\n+        while let Some(mpi) = todo.pop() {\n+            if f(mpi) {\n+                return Some(mpi);\n+            }\n+\n+            let move_path = &move_paths[mpi];\n+            if let Some(child) = move_path.first_child {\n+                todo.push(child);\n+            }\n+\n+            // After we've processed the original `mpi`, we should always\n+            // traverse the siblings of any of its children.\n+            if let Some(sibling) = move_path.next_sibling {\n+                todo.push(sibling);\n+            }\n+        }\n+\n+        None\n+    }\n }\n \n impl<'tcx> fmt::Debug for MovePath<'tcx> {\n@@ -333,4 +368,16 @@ impl<'tcx> MoveData<'tcx> {\n             }\n         }\n     }\n+\n+    pub fn find_in_move_path_or_its_descendants(\n+        &self,\n+        root: MovePathIndex,\n+        pred: impl Fn(MovePathIndex) -> bool,\n+    ) -> Option<MovePathIndex> {\n+        if pred(root) {\n+            return Some(root);\n+        }\n+\n+        self.move_paths[root].find_descendant(&self.move_paths, pred)\n+    }\n }"}, {"sha": "e9715f682b04a84a500ff7158f516aff2637a348", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -22,6 +22,7 @@ use super::resolver::FlowSensitiveAnalysis;\n use super::{is_lang_panic_fn, ConstKind, Item, Qualif};\n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n use crate::dataflow::{self as old_dataflow, generic as dataflow};\n+use dataflow::Analysis;\n \n pub type IndirectlyMutableResults<'mir, 'tcx> =\n     old_dataflow::DataflowResultsCursor<'mir, 'tcx, IndirectlyMutableLocals<'mir, 'tcx>>;\n@@ -33,10 +34,10 @@ struct QualifCursor<'a, 'mir, 'tcx, Q: Qualif> {\n \n impl<Q: Qualif> QualifCursor<'a, 'mir, 'tcx, Q> {\n     pub fn new(q: Q, item: &'a Item<'mir, 'tcx>) -> Self {\n-        let analysis = FlowSensitiveAnalysis::new(q, item);\n-        let results = dataflow::Engine::new_generic(item.tcx, &item.body, item.def_id, analysis)\n-            .iterate_to_fixpoint();\n-        let cursor = dataflow::ResultsCursor::new(*item.body, results);\n+        let cursor = FlowSensitiveAnalysis::new(q, item)\n+            .into_engine(item.tcx, &item.body, item.def_id)\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(*item.body);\n \n         let mut in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n         for (local, decl) in item.body.local_decls.iter_enumerated() {"}, {"sha": "99f13f68cbc794e4a12af894954da8547bd9572e", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 24, "deletions": 35, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -1,7 +1,7 @@\n-use crate::dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n-use crate::dataflow::DataflowResults;\n+use crate::dataflow;\n+use crate::dataflow::generic::{Analysis, Results};\n+use crate::dataflow::move_paths::{LookupResult, MoveData, MovePathIndex};\n use crate::dataflow::MoveDataParamEnv;\n-use crate::dataflow::{self, do_dataflow, DebugFormatted};\n use crate::dataflow::{drop_flag_effects_for_location, on_lookup_result_bits};\n use crate::dataflow::{on_all_children_bits, on_all_drop_children_bits};\n use crate::dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n@@ -40,24 +40,16 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n             let body = &*body;\n             let env = MoveDataParamEnv { move_data, param_env };\n             let dead_unwinds = find_dead_unwinds(tcx, body, def_id, &env);\n-            let flow_inits = do_dataflow(\n-                tcx,\n-                body,\n-                def_id,\n-                &[],\n-                &dead_unwinds,\n-                MaybeInitializedPlaces::new(tcx, body, &env),\n-                |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]),\n-            );\n-            let flow_uninits = do_dataflow(\n-                tcx,\n-                body,\n-                def_id,\n-                &[],\n-                &dead_unwinds,\n-                MaybeUninitializedPlaces::new(tcx, body, &env),\n-                |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]),\n-            );\n+\n+            let flow_inits = MaybeInitializedPlaces::new(tcx, body, &env)\n+                .into_engine(tcx, body, def_id)\n+                .dead_unwinds(&dead_unwinds)\n+                .iterate_to_fixpoint();\n+\n+            let flow_uninits = MaybeUninitializedPlaces::new(tcx, body, &env)\n+                .into_engine(tcx, body, def_id)\n+                .dead_unwinds(&dead_unwinds)\n+                .iterate_to_fixpoint();\n \n             ElaborateDropsCtxt {\n                 tcx,\n@@ -87,15 +79,9 @@ fn find_dead_unwinds<'tcx>(\n     // We only need to do this pass once, because unwind edges can only\n     // reach cleanup blocks, which can't have unwind edges themselves.\n     let mut dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n-    let flow_inits = do_dataflow(\n-        tcx,\n-        body,\n-        def_id,\n-        &[],\n-        &dead_unwinds,\n-        MaybeInitializedPlaces::new(tcx, body, &env),\n-        |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]),\n-    );\n+    let flow_inits = MaybeInitializedPlaces::new(tcx, body, &env)\n+        .into_engine(tcx, body, def_id)\n+        .iterate_to_fixpoint();\n     for (bb, bb_data) in body.basic_blocks().iter_enumerated() {\n         let location = match bb_data.terminator().kind {\n             TerminatorKind::Drop { ref location, unwind: Some(_), .. }\n@@ -104,7 +90,7 @@ fn find_dead_unwinds<'tcx>(\n         };\n \n         let mut init_data = InitializationData {\n-            live: flow_inits.sets().entry_set_for(bb.index()).to_owned(),\n+            live: flow_inits.entry_set_for_block(bb).clone(),\n             dead: BitSet::new_empty(env.move_data.move_paths.len()),\n         };\n         debug!(\"find_dead_unwinds @ {:?}: {:?}; init_data={:?}\", bb, bb_data, init_data.live);\n@@ -283,8 +269,8 @@ struct ElaborateDropsCtxt<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     env: &'a MoveDataParamEnv<'tcx>,\n-    flow_inits: DataflowResults<'tcx, MaybeInitializedPlaces<'a, 'tcx>>,\n-    flow_uninits: DataflowResults<'tcx, MaybeUninitializedPlaces<'a, 'tcx>>,\n+    flow_inits: Results<'tcx, MaybeInitializedPlaces<'a, 'tcx>>,\n+    flow_uninits: Results<'tcx, MaybeUninitializedPlaces<'a, 'tcx>>,\n     drop_flags: FxHashMap<MovePathIndex, Local>,\n     patch: MirPatch<'tcx>,\n }\n@@ -298,10 +284,13 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         self.env.param_env\n     }\n \n+    // FIXME(ecstaticmorse): This duplicates `dataflow::ResultsCursor` but hardcodes the transfer\n+    // function for `Maybe{Un,}InitializedPlaces` directly. It should be replaced by a a pair of\n+    // `ResultsCursor`s.\n     fn initialization_data_at(&self, loc: Location) -> InitializationData {\n         let mut data = InitializationData {\n-            live: self.flow_inits.sets().entry_set_for(loc.block.index()).to_owned(),\n-            dead: self.flow_uninits.sets().entry_set_for(loc.block.index()).to_owned(),\n+            live: self.flow_inits.entry_set_for_block(loc.block).to_owned(),\n+            dead: self.flow_uninits.entry_set_for_block(loc.block).to_owned(),\n         };\n         for stmt in 0..loc.statement_index {\n             data.apply_location("}, {"sha": "7d8506eb281054ec2cdd88b76cac51e87f8091b2", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 28, "deletions": 42, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -9,24 +9,22 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n \n+use crate::dataflow::generic::{Analysis, Results, ResultsCursor};\n use crate::dataflow::move_paths::{HasMoveData, MoveData};\n use crate::dataflow::move_paths::{LookupResult, MovePathIndex};\n-use crate::dataflow::BitDenotation;\n-use crate::dataflow::DataflowResults;\n-use crate::dataflow::DataflowResultsCursor;\n use crate::dataflow::IndirectlyMutableLocals;\n use crate::dataflow::MoveDataParamEnv;\n use crate::dataflow::{do_dataflow, DebugFormatted};\n use crate::dataflow::{\n     DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeUninitializedPlaces,\n };\n \n-use crate::dataflow::has_rustc_mir_with;\n-\n pub struct SanityCheck;\n \n impl<'tcx> MirPass<'tcx> for SanityCheck {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+        use crate::dataflow::has_rustc_mir_with;\n+\n         let def_id = src.def_id();\n         if !tcx.has_attr(def_id, sym::rustc_mir) {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n@@ -40,34 +38,17 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n         let move_data = MoveData::gather_moves(body, tcx, param_env).unwrap();\n         let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n         let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n-        let flow_inits = do_dataflow(\n-            tcx,\n-            body,\n-            def_id,\n-            &attributes,\n-            &dead_unwinds,\n-            MaybeInitializedPlaces::new(tcx, body, &mdpe),\n-            |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n-        );\n-        let flow_uninits = do_dataflow(\n-            tcx,\n-            body,\n-            def_id,\n-            &attributes,\n-            &dead_unwinds,\n-            MaybeUninitializedPlaces::new(tcx, body, &mdpe),\n-            |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n-        );\n-        let flow_def_inits = do_dataflow(\n-            tcx,\n-            body,\n-            def_id,\n-            &attributes,\n-            &dead_unwinds,\n-            DefinitelyInitializedPlaces::new(tcx, body, &mdpe),\n-            |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n-        );\n-        let flow_indirectly_mut = do_dataflow(\n+\n+        let flow_inits = MaybeInitializedPlaces::new(tcx, body, &mdpe)\n+            .into_engine(tcx, body, def_id)\n+            .iterate_to_fixpoint();\n+        let flow_uninits = MaybeUninitializedPlaces::new(tcx, body, &mdpe)\n+            .into_engine(tcx, body, def_id)\n+            .iterate_to_fixpoint();\n+        let flow_def_inits = DefinitelyInitializedPlaces::new(tcx, body, &mdpe)\n+            .into_engine(tcx, body, def_id)\n+            .iterate_to_fixpoint();\n+        let _flow_indirectly_mut = do_dataflow(\n             tcx,\n             body,\n             def_id,\n@@ -86,9 +67,12 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_definite_init).is_some() {\n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_def_inits);\n         }\n+        // FIXME: Uncomment these as analyses are migrated to the new framework\n+        /*\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_indirectly_mutable).is_some() {\n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_indirectly_mut);\n         }\n+        */\n         if has_rustc_mir_with(&attributes, sym::stop_after_dataflow).is_some() {\n             tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n         }\n@@ -111,18 +95,18 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n /// (If there are any calls to `rustc_peek` that do not match the\n /// expression form above, then that emits an error as well, but those\n /// errors are not intended to be used for unit tests.)\n-pub fn sanity_check_via_rustc_peek<'tcx, O>(\n+pub fn sanity_check_via_rustc_peek<'tcx, A>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     def_id: DefId,\n     _attributes: &[ast::Attribute],\n-    results: &DataflowResults<'tcx, O>,\n+    results: &Results<'tcx, A>,\n ) where\n-    O: RustcPeekAt<'tcx>,\n+    A: RustcPeekAt<'tcx>,\n {\n     debug!(\"sanity_check_via_rustc_peek def_id: {:?}\", def_id);\n \n-    let mut cursor = DataflowResultsCursor::new(results, body);\n+    let mut cursor = ResultsCursor::new(body, results);\n \n     let peek_calls = body.basic_blocks().iter_enumerated().filter_map(|(bb, block_data)| {\n         PeekCall::from_terminator(tcx, block_data.terminator()).map(|call| (bb, block_data, call))\n@@ -153,9 +137,9 @@ pub fn sanity_check_via_rustc_peek<'tcx, O>(\n             | (PeekCallKind::ByVal, mir::Rvalue::Use(mir::Operand::Move(place)))\n             | (PeekCallKind::ByVal, mir::Rvalue::Use(mir::Operand::Copy(place))) => {\n                 let loc = Location { block: bb, statement_index };\n-                cursor.seek(loc);\n+                cursor.seek_before(loc);\n                 let state = cursor.get();\n-                results.operator().peek_at(tcx, place, state, call);\n+                results.analysis.peek_at(tcx, place, state, call);\n             }\n \n             _ => {\n@@ -255,7 +239,7 @@ impl PeekCall {\n     }\n }\n \n-pub trait RustcPeekAt<'tcx>: BitDenotation<'tcx> {\n+pub trait RustcPeekAt<'tcx>: Analysis<'tcx> {\n     fn peek_at(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -265,9 +249,9 @@ pub trait RustcPeekAt<'tcx>: BitDenotation<'tcx> {\n     );\n }\n \n-impl<'tcx, O> RustcPeekAt<'tcx> for O\n+impl<'tcx, A> RustcPeekAt<'tcx> for A\n where\n-    O: BitDenotation<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n+    A: Analysis<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n {\n     fn peek_at(\n         &self,\n@@ -292,6 +276,7 @@ where\n     }\n }\n \n+/* FIXME: Add this back once `IndirectlyMutableLocals` uses the new dataflow framework.\n impl<'tcx> RustcPeekAt<'tcx> for IndirectlyMutableLocals<'_, 'tcx> {\n     fn peek_at(\n         &self,\n@@ -313,3 +298,4 @@ impl<'tcx> RustcPeekAt<'tcx> for IndirectlyMutableLocals<'_, 'tcx> {\n         }\n     }\n }\n+*/"}, {"sha": "884c83b66163c225248fd4b130b8b576bb781dd2", "filename": "src/test/ui/mir-dataflow/indirect-mutation-offset.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed25f069768c046464e68fd382c867ddb04a1e3/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs?ref=2ed25f069768c046464e68fd382c867ddb04a1e3", "patch": "@@ -1,5 +1,7 @@\n // compile-flags: -Zunleash-the-miri-inside-of-you\n \n+// ignore-test Temporarily ignored while this analysis is migrated to the new framework.\n+\n #![feature(core_intrinsics, rustc_attrs, const_raw_ptr_deref)]\n \n use std::cell::UnsafeCell;"}]}