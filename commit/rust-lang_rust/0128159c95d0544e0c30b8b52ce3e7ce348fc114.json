{"sha": "0128159c95d0544e0c30b8b52ce3e7ce348fc114", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMjgxNTljOTVkMDU0NGUwYzMwYjhiNTJjZTNlN2NlMzQ4ZmMxMTQ=", "commit": {"author": {"name": "Johannes Hoff", "email": "johshoff@gmail.com", "date": "2014-12-24T12:22:11Z"}, "committer": {"name": "Johannes Hoff", "email": "johshoff@gmail.com", "date": "2014-12-24T12:22:11Z"}, "message": "Merge branch 'master' into cfg_tmp_dir\n\nConflicts:\n\tsrc/etc/rustup.sh", "tree": {"sha": "8af4db0f2758f86434b895169122a9962fb79b21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8af4db0f2758f86434b895169122a9962fb79b21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0128159c95d0544e0c30b8b52ce3e7ce348fc114", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0128159c95d0544e0c30b8b52ce3e7ce348fc114", "html_url": "https://github.com/rust-lang/rust/commit/0128159c95d0544e0c30b8b52ce3e7ce348fc114", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0128159c95d0544e0c30b8b52ce3e7ce348fc114/comments", "author": {"login": "johshoff", "id": 353935, "node_id": "MDQ6VXNlcjM1MzkzNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/353935?v=4", "gravatar_id": "", "url": "https://api.github.com/users/johshoff", "html_url": "https://github.com/johshoff", "followers_url": "https://api.github.com/users/johshoff/followers", "following_url": "https://api.github.com/users/johshoff/following{/other_user}", "gists_url": "https://api.github.com/users/johshoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/johshoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/johshoff/subscriptions", "organizations_url": "https://api.github.com/users/johshoff/orgs", "repos_url": "https://api.github.com/users/johshoff/repos", "events_url": "https://api.github.com/users/johshoff/events{/privacy}", "received_events_url": "https://api.github.com/users/johshoff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "johshoff", "id": 353935, "node_id": "MDQ6VXNlcjM1MzkzNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/353935?v=4", "gravatar_id": "", "url": "https://api.github.com/users/johshoff", "html_url": "https://github.com/johshoff", "followers_url": "https://api.github.com/users/johshoff/followers", "following_url": "https://api.github.com/users/johshoff/following{/other_user}", "gists_url": "https://api.github.com/users/johshoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/johshoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/johshoff/subscriptions", "organizations_url": "https://api.github.com/users/johshoff/orgs", "repos_url": "https://api.github.com/users/johshoff/repos", "events_url": "https://api.github.com/users/johshoff/events{/privacy}", "received_events_url": "https://api.github.com/users/johshoff/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f827d33cab1be648120fc8ac34651d9cc079b5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f827d33cab1be648120fc8ac34651d9cc079b5e", "html_url": "https://github.com/rust-lang/rust/commit/8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "e64a8193b02ce72ef183274994a25eae281cb89c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e64a8193b02ce72ef183274994a25eae281cb89c", "html_url": "https://github.com/rust-lang/rust/commit/e64a8193b02ce72ef183274994a25eae281cb89c"}], "stats": {"total": 132271, "additions": 70927, "deletions": 61344}, "files": [{"sha": "6cd704b3703760d0ab5599e5098dd3a02e8fbce8", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -11,3 +11,6 @@\n [submodule \"src/jemalloc\"]\n \tpath = src/jemalloc\n \turl = https://github.com/rust-lang/jemalloc.git\n+[submodule \"src/rust-installer\"]\n+\tpath = src/rust-installer\n+\turl = https://github.com/rust-lang/rust-installer"}, {"sha": "9aa09ac1763561e527850a0781c2bb4852fb6b06", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -498,6 +498,7 @@ Robert Irelan <rirelan@gmail.com>\n Robert Knight <robertknight@gmail.com>\n Robert Millar <robert.millar@cantab.net>\n Roland Tanglao <roland@rolandtanglao.com>\n+Rolf Timmermans <r.w.timmermans@gmail.com>\n Ron Dahlgren <ronald.dahlgren@gmail.com>\n Roy Frostig <rfrostig@mozilla.com>\n Russell <rpjohnst@gmail.com>"}, {"sha": "17ae845bf0773da92ce98f685375a92e3e709b2f", "filename": "Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -198,6 +198,8 @@ include $(CFG_SRC_DIR)mk/rustllvm.mk\n include $(CFG_SRC_DIR)mk/docs.mk\n # LLVM\n include $(CFG_SRC_DIR)mk/llvm.mk\n+# Rules for installing debugger scripts\n+include $(CFG_SRC_DIR)mk/debuggers.mk\n \n ######################################################################\n # Secondary makefiles, conditionalized for speed"}, {"sha": "f14009b46543326624895afea3172efa739be666", "filename": "configure", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/configure", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -546,22 +546,26 @@ CFG_TARGET=$(to_llvm_triple $CFG_TARGET)\n # there's no rpath. This is where the build system itself puts libraries;\n # --libdir is used to configure the installation directory.\n # FIXME: This needs to parameterized over target triples. Do it in platform.mk\n-CFG_LIBDIR_RELATIVE=lib\n if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ]\n then\n     CFG_LIBDIR_RELATIVE=bin\n-    CFG_LIBDIR=\"${CFG_PREFIX}/${CFG_LIBDIR_RELATIVE}\"\n else\n-    valopt libdir \"${CFG_PREFIX}/${CFG_LIBDIR_RELATIVE}\" \"install libraries (ignored on windows platform)\"\n+    CFG_LIBDIR_RELATIVE=lib\n+fi\n \n-    case \"$CFG_LIBDIR\" in\n-\t\"$CFG_PREFIX\"/*) CAT_INC=2;;\n-\t\"$CFG_PREFIX\"*)  CAT_INC=1;;\n-\t*)\n-            err \"libdir must begin with the prefix. Use --prefix to set it accordingly.\";;\n-    esac\n+valopt libdir \"${CFG_PREFIX}/${CFG_LIBDIR_RELATIVE}\" \"install libraries (do not set it on windows platform)\"\n+\n+case \"$CFG_LIBDIR\" in\n+    \"$CFG_PREFIX\"/*) CAT_INC=2;;\n+    \"$CFG_PREFIX\"*)  CAT_INC=1;;\n+    *)\n+        err \"libdir must begin with the prefix. Use --prefix to set it accordingly.\";;\n+esac\n \n-    CFG_LIBDIR_RELATIVE=`echo ${CFG_LIBDIR} | cut -c$((${#CFG_PREFIX}+${CAT_INC}))-`\n+CFG_LIBDIR_RELATIVE=`echo ${CFG_LIBDIR} | cut -c$((${#CFG_PREFIX}+${CAT_INC}))-`\n+\n+if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ] && [ \"$CFG_LIBDIR_RELATIVE\" != \"bin\" ]; then\n+    err \"libdir on windows should be set to 'bin'\"\n fi\n \n if [ $HELP -eq 1 ]\n@@ -620,7 +624,6 @@ probe CFG_LD               ld\n probe CFG_VALGRIND         valgrind\n probe CFG_PERF             perf\n probe CFG_ISCC             iscc\n-probe CFG_LLNEXTGEN        LLnextgen\n probe CFG_JAVAC            javac\n probe CFG_ANTLR4           antlr4\n probe CFG_GRUN             grun\n@@ -711,11 +714,6 @@ then\n     fi\n     step_msg \"using rustc at: ${CFG_LOCAL_RUST_ROOT} with version: $LRV\"\n     putvar CFG_LOCAL_RUST_ROOT\n-else\n-    if [ ! -z \"$CFG_LOCAL_RUST_ROOT\" ]\n-    then\n-       warn \"Use of --local-rust-root without --enable-local-rust\"\n-    fi\n fi\n \n # Force freebsd to build with clang; gcc doesn't like us there\n@@ -990,8 +988,7 @@ do\n     make_dir $t/rt/jemalloc\n     for i in                                          \\\n       isaac sync test \\\n-      arch/i386 arch/x86_64 arch/arm arch/mips  \\\n-      sundown/src sundown/html\n+      arch/i386 arch/x86_64 arch/arm arch/mips\n     do\n       make_dir $t/rt/stage$s/$i\n     done\n@@ -1042,19 +1039,18 @@ do\n     make_dir $h/test/debuginfo-gdb\n     make_dir $h/test/debuginfo-lldb\n     make_dir $h/test/codegen\n-    make_dir $h/test/doc-tutorial\n     make_dir $h/test/doc-guide\n     make_dir $h/test/doc-guide-ffi\n     make_dir $h/test/doc-guide-runtime\n     make_dir $h/test/doc-guide-macros\n-    make_dir $h/test/doc-guide-lifetimes\n+    make_dir $h/test/doc-guide-ownership\n     make_dir $h/test/doc-guide-pointers\n     make_dir $h/test/doc-guide-container\n     make_dir $h/test/doc-guide-tasks\n     make_dir $h/test/doc-guide-plugin\n     make_dir $h/test/doc-guide-crates\n     make_dir $h/test/doc-guide-error-handling\n-    make_dir $h/test/doc-rust\n+    make_dir $h/test/doc-reference\n done\n \n # Configure submodules"}, {"sha": "4457ac8cce7e31fe39686105b38d1cdb72af7fab", "filename": "man/rustc.1", "status": "modified", "additions": 79, "deletions": 52, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -12,75 +12,54 @@ This program is a compiler for the Rust language, available at\n .SH OPTIONS\n \n .TP\n-\\fB\\-\\-crate-name NAME\\fR\n-Specify the name of the crate being built\n-.TP\n-\\fB\\-\\-crate-type=[bin|lib|dylib|rlib|staticlib]\\fR\n-Configure the flavor of rust crate that is generated (default `bin`)\n+\\fB\\-h\\fR, \\fB\\-\\-help\\fR\n+Display the help message\n .TP\n \\fB\\-\\-cfg\\fR SPEC\n Configure the compilation environment\n .TP\n-\\fB\\-\\-emit=[asm,ir,bc,obj,link]\\fR\n-Configure the output that rustc will produce\n-.TP\n-\\fB\\-h\\fR, \\fB\\-\\-help\\fR\n-Display this message\n-.TP\n \\fB\\-L\\fR PATH\n Add a directory to the library search path\n .TP\n-\\fB\\-\\-no\\-trans\\fR\n-Run all passes except translation; no output\n+\\fB\\-l\\fR NAME[:KIND]\n+Link the generated crate(s) to the specified native library NAME. The optional\n+KIND can be one of, static, dylib, or framework. If omitted, dylib is assumed.\n .TP\n-\\fB\\-\\-no\\-analysis\\fR\n-Parse and expand the source, but run no analysis and produce no output\n+\\fB\\-\\-crate-type\\fR [bin|lib|rlib|dylib|staticlib]\n+Comma separated list of types of crates for the compiler to emit\n .TP\n-\\fB\\-g\\fR\n-Emit DWARF debug information into object files generated.\n+\\fB\\-\\-crate-name NAME\\fR\n+Specify the name of the crate being built\n .TP\n-\\fB\\-\\-debuginfo\\fR LEVEL\n-Emit DWARF debug info to the objects created: 0 = no debug info, 1 =\n-line-tables only (for stacktraces and breakpoints), 2 = full debug\n-info with variable and type information (same as -g).\n+\\fB\\-\\-emit\\fR [asm|llvm-bc|llvm-ir|obj|link|dep-info]\n+Configure the output that rustc will produce\n+.TP\n+\\fB\\-\\-print\\fR [crate-name|output-file-names|sysroot]\n+Comma separated list of compiler information to print on stdout\n+.TP\n+\\fB\\-g\\fR\n+Equivalent to \\fI\\-C\\fR debuginfo=2\n .TP\n \\fB\\-O\\fR\n-Equivalent to \\fI\\-\\-opt\\-level=2\\fR\n+Equivalent to \\fI\\-C\\fR opt-level=2\n .TP\n \\fB\\-o\\fR FILENAME\n-Write output to <filename>. Ignored if more than one --emit is specified.\n-.TP\n-\\fB\\-\\-opt\\-level\\fR LEVEL\n-Optimize with possible levels 0-3\n+Write output to <filename>. Ignored if multiple \\fI\\-\\-emit\\fR outputs are\n+specified.\n .TP\n \\fB\\-\\-out\\-dir\\fR DIR\n-Write output to compiler-chosen filename in <dir>. Ignored if -o is specified.\n-(default the current directory)\n-.TP\n-\\fB\\-\\-parse\\-only\\fR\n-Parse only; do not compile, assemble, or link\n+Write output to compiler-chosen filename in <dir>. Ignored if \\fI\\-o\\fR is\n+specified. Defaults to the current directory.\n .TP\n-\\fB\\-\\-pretty\\fR [TYPE]\n-Pretty-print the input instead of compiling; valid types are: normal\n-(un-annotated source), expanded (crates expanded), typed (crates\n-expanded, with type annotations), identified (fully parenthesized,\n-AST nodes and blocks with IDs), or flowgraph=<nodeid> (graphviz\n-formatted flowgraph for node)\n-.TP\n-\\fB\\-\\-dep-info\\fR [FILENAME]\n-Output dependency info to <filename> after compiling, in a format suitable\n-for use by Makefiles.\n-.TP\n-\\fB\\-\\-sysroot\\fR PATH\n-Override the system root\n+\\fB\\-\\-explain\\fR OPT\n+Provide a detailed explanation of an error message\n .TP\n \\fB\\-\\-test\\fR\n Build a test harness\n .TP\n \\fB\\-\\-target\\fR TRIPLE\n-Target triple cpu-manufacturer-kernel[-os] to compile for (see\n-http://sources.redhat.com/autobook/autobook/autobook_17.html\n-for details)\n+Target triple cpu-manufacturer-kernel[-os] to compile for (see chapter 3.4 of\n+http://www.sourceware.org/autobook/ for details)\n .TP\n \\fB\\-W\\fR help\n Print 'lint' options and default settings\n@@ -97,15 +76,30 @@ Set lint denied\n \\fB\\-F\\fR OPT, \\fB\\-\\-forbid\\fR OPT\n Set lint forbidden\n .TP\n-\\fB\\-Z\\fR FLAG\n-Set internal debugging options. Use \"-Z help\" to print available options.\n-.TP\n \\fB\\-C\\fR FLAG[=VAL], \\fB\\-\\-codegen\\fR FLAG[=VAL]\n Set a codegen-related flag to the value specified. Use \"-C help\" to print\n available flags. See CODEGEN OPTIONS below\n .TP\n-\\fB\\-v\\fR, \\fB\\-\\-version\\fR\n+\\fB\\-V\\fR, \\fB\\-\\-version\\fR\n Print version info and exit\n+.TP\n+\\fB\\-v\\fR, \\fB\\-\\-verbose\\fR\n+Use verbose output\n+.TP\n+\\fB\\-\\-extern\\fR NAME=PATH\n+Specify where an external rust library is located\n+.TP\n+\\fB\\-\\-sysroot\\fR PATH\n+Override the system root\n+.TP\n+\\fB\\-Z\\fR FLAG\n+Set internal debugging options. Use \"-Z help\" to print available options.\n+.TP\n+\\fB\\-\\-color\\fR auto|always|never\n+Configure coloring of output:\n+    auto = colorize, if output goes to a tty (default);\n+    always = always colorize output;\n+    never = never colorize output\n \n .SH CODEGEN OPTIONS\n \n@@ -121,6 +115,9 @@ objects.\n A space-separated list of extra arguments to pass to the linker when the linker\n is invoked.\n .TP\n+\\fBlto\\fR\n+Perform LLVM link-time optimizations.\n+.TP\n \\fBtarget-cpu\\fR=help\n Selects a target processor. If the value is 'help', then a list of available\n CPUs is printed.\n@@ -167,8 +164,38 @@ Prefers dynamic linking to static linking.\n \\fBno-integrated-as\\fR\n Force usage of an external assembler rather than LLVM's integrated one.\n .TP\n+\\fBno-redzone\\fR\n+Disable the use of the redzone.\n+.TP\n \\fBrelocation-model\\fR=[pic,static,dynamic-no-pic]\n-The relocation model to use. (default: pic)\n+The relocation model to use. (Default: pic)\n+.TP\n+\\fBcode-model\\fR=[small,kernel,medium,large]\n+Choose the code model to use.\n+.TP\n+\\fBmetadata\\fR=val\n+Metadata to mangle symbol names with.\n+.TP\n+\\fBextra-filename\\fR=val\n+Extra data to put in each output filename.\n+.TP\n+\\fBcodegen-units\\fR=val\n+Divide crate into N units to optimize in parallel.\n+.TP\n+\\fBremark\\fR=val\n+Print remarks for these optimization passes (space separated, or \"all\").\n+.TP\n+\\fBno-stack-check\\fR\n+Disable checks for stack exhaustion (a memory-safety hazard!).\n+.TP\n+\\fBdebuginfo\\fR=val\n+Debug info emission level:\n+    0 = no debug info;\n+    1 = line-tables only (for stacktraces and breakpoints);\n+    2 = full debug info with variable and type information.\n+.TP\n+\\fBopt-level\\fR=val\n+Optimize with possible levels 0-3\n \n .SH \"EXAMPLES\"\n To build an executable from a source file with a main function:"}, {"sha": "aadc55ba6c4977dda86d5e5567c1ea6a8681b108", "filename": "mk/clean.mk", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -63,6 +63,7 @@ clean-generic-$(2)-$(1):\n          -name '*.lib' -o \\\n          -name '*.dll' -o \\\n          -name '*.def' -o \\\n+         -name '*.py' -o \\\n          -name '*.bc' \\\n          \\) \\\n          | xargs rm -f\n@@ -78,7 +79,7 @@ define CLEAN_HOST_STAGE_N\n \n clean$(1)_H_$(2): \\\n \t    $$(foreach crate,$$(CRATES),clean$(1)_H_$(2)-lib-$$(crate)) \\\n-\t    $$(foreach tool,$$(TOOLS),clean$(1)_H_$(2)-tool-$$(tool))\n+\t    $$(foreach tool,$$(TOOLS) $$(DEBUGGER_BIN_SCRIPTS),clean$(1)_H_$(2)-tool-$$(tool))\n \t$$(Q)rm -fr $(2)/rt/libbacktrace\n \n clean$(1)_H_$(2)-tool-%:\n@@ -98,7 +99,7 @@ define CLEAN_TARGET_STAGE_N\n \n clean$(1)_T_$(2)_H_$(3): \\\n \t    $$(foreach crate,$$(CRATES),clean$(1)_T_$(2)_H_$(3)-lib-$$(crate)) \\\n-\t    $$(foreach tool,$$(TOOLS),clean$(1)_T_$(2)_H_$(3)-tool-$$(tool))\n+\t    $$(foreach tool,$$(TOOLS) $$(DEBUGGER_BIN_SCRIPTS),clean$(1)_T_$(2)_H_$(3)-tool-$$(tool))\n \t$$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a\n \t$$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/libcompiler-rt.a\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/librun_pass_stage* # For unix"}, {"sha": "e20cb06e3a8ca43a21aadb134bbfa52e6c2648a8", "filename": "mk/crates.mk", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -50,29 +50,35 @@\n ################################################################################\n \n TARGET_CRATES := libc std flate arena term \\\n-                 serialize sync getopts collections test time rand \\\n-                 log regex graphviz core rbml alloc rustrt \\\n+                 serialize getopts collections test time rand \\\n+                 log regex graphviz core rbml alloc \\\n                  unicode\n-HOST_CRATES := syntax rustc rustc_trans rustdoc regex_macros fmt_macros \\\n-\t       rustc_llvm rustc_back\n+RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_resolve rustc_driver \\\n+                rustc_trans rustc_back rustc_llvm\n+HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc regex_macros fmt_macros\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n \n DEPS_core :=\n DEPS_libc := core\n DEPS_unicode := core\n DEPS_alloc := core libc native:jemalloc\n-DEPS_rustrt := alloc core libc collections native:rustrt_native\n-DEPS_std := core libc rand alloc collections rustrt sync unicode \\\n-\tnative:rust_builtin native:backtrace\n+DEPS_std := core libc rand alloc collections unicode \\\n+\tnative:rust_builtin native:backtrace native:rustrt_native\n DEPS_graphviz := std\n DEPS_syntax := std term serialize log fmt_macros arena libc\n-DEPS_rustc_trans := rustc rustc_back rustc_llvm libc\n+DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n+                     rustc_typeck rustc_resolve log syntax serialize rustc_llvm rustc_trans\n+DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n+\t                log syntax serialize rustc_llvm\n+DEPS_rustc_typeck := rustc syntax\n+DEPS_rustc_borrowck := rustc log graphviz syntax\n+DEPS_rustc_resolve := rustc log syntax\n DEPS_rustc := syntax flate arena serialize getopts rbml \\\n               time log graphviz rustc_llvm rustc_back\n DEPS_rustc_llvm := native:rustllvm libc std\n DEPS_rustc_back := std syntax rustc_llvm flate log libc\n-DEPS_rustdoc := rustc rustc_trans native:hoedown serialize getopts \\\n+DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\\n                 test time\n DEPS_flate := std native:miniz\n DEPS_arena := std\n@@ -81,7 +87,6 @@ DEPS_glob := std\n DEPS_serialize := std log\n DEPS_rbml := std log serialize\n DEPS_term := std log\n-DEPS_sync := core alloc rustrt collections\n DEPS_getopts := std\n DEPS_collections := core alloc unicode\n DEPS_num := std\n@@ -95,7 +100,7 @@ DEPS_fmt_macros = std\n \n TOOL_DEPS_compiletest := test getopts\n TOOL_DEPS_rustdoc := rustdoc\n-TOOL_DEPS_rustc := rustc_trans\n+TOOL_DEPS_rustc := rustc_driver\n TOOL_SOURCE_compiletest := $(S)src/compiletest/compiletest.rs\n TOOL_SOURCE_rustdoc := $(S)src/driver/driver.rs\n TOOL_SOURCE_rustc := $(S)src/driver/driver.rs\n@@ -111,8 +116,15 @@ ONLY_RLIB_unicode := 1\n # You should not need to edit below this line\n ################################################################################\n \n-DOC_CRATES := $(filter-out rustc, $(filter-out rustc_trans, $(filter-out syntax, $(CRATES))))\n-COMPILER_DOC_CRATES := rustc rustc_trans syntax\n+DOC_CRATES := $(filter-out rustc, \\\n+              $(filter-out rustc_trans, \\\n+              $(filter-out rustc_typeck, \\\n+              $(filter-out rustc_borrowck, \\\n+              $(filter-out rustc_resolve, \\\n+              $(filter-out rustc_driver, \\\n+              $(filter-out syntax, $(CRATES))))))))\n+COMPILER_DOC_CRATES := rustc rustc_trans rustc_borrowck rustc_resolve \\\n+                       rustc_typeck rustc_driver syntax\n \n # This macro creates some simple definitions for each crate being built, just\n # some munging of all of the parameters above."}, {"sha": "c7a3406a9e746e2f9329c479f4fed02904b95980", "filename": "mk/ctags.mk", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fctags.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fctags.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fctags.mk?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -16,7 +16,7 @@\n .PHONY: TAGS.emacs TAGS.vi\n \n # This is using a blacklist approach, probably more durable than a whitelist.\n-# We exclude: external dependencies (llvm, rt/{msvc,sundown,vg}),\n+# We exclude: external dependencies (llvm, rt/{msvc,vg}),\n # tests (compiletest, test) and a couple of other things (rt/arch, etc)\n CTAGS_LOCATIONS=$(patsubst ${CFG_SRC_DIR}src/llvm,, \\\n \t\t\t\t$(patsubst ${CFG_SRC_DIR}src/compiletest,, \\\n@@ -25,10 +25,9 @@ CTAGS_LOCATIONS=$(patsubst ${CFG_SRC_DIR}src/llvm,, \\\n \t\t\t\t$(patsubst ${CFG_SRC_DIR}src/rt,, \\\n \t\t\t\t$(patsubst ${CFG_SRC_DIR}src/rt/arch,, \\\n \t\t\t\t$(patsubst ${CFG_SRC_DIR}src/rt/msvc,, \\\n-\t\t\t\t$(patsubst ${CFG_SRC_DIR}src/rt/sundown,, \\\n \t\t\t\t$(patsubst ${CFG_SRC_DIR}src/rt/vg,, \\\n \t\t\t\t$(wildcard ${CFG_SRC_DIR}src/*) $(wildcard ${CFG_SRC_DIR}src/rt/*) \\\n-\t\t\t\t)))))))))\n+\t\t\t\t))))))))\n CTAGS_OPTS=--options=\"${CFG_SRC_DIR}src/etc/ctags.rust\" --languages=-javascript --recurse ${CTAGS_LOCATIONS}\n # We could use `--languages=Rust`, but there is value in producing tags for the\n # C++ parts of the code base too (at the time of writing, those are .h and .cpp"}, {"sha": "54955f06295fc168eb069bb170601d02ed96a54b", "filename": "mk/debuggers.mk", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fdebuggers.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fdebuggers.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdebuggers.mk?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -0,0 +1,59 @@\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+######################################################################\n+# Copy debugger related scripts\n+######################################################################\n+\n+DEBUGGER_RUSTLIB_ETC_SCRIPTS=lldb_rust_formatters.py\n+DEBUGGER_BIN_SCRIPTS=rust-lldb\n+\n+DEBUGGER_RUSTLIB_ETC_SCRIPTS_ABS=$(foreach script,$(DEBUGGER_RUSTLIB_ETC_SCRIPTS), \\\n+                                     $(CFG_SRC_DIR)src/etc/$(script))\n+DEBUGGER_BIN_SCRIPTS_ABS=$(foreach script,$(DEBUGGER_BIN_SCRIPTS), \\\n+                             $(CFG_SRC_DIR)src/etc/$(script))\n+\n+DEBUGGER_SCRIPTS_ALL=$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_ABS) $(DEBUGGER_BIN_SCRIPTS_ABS)\n+\n+# $(1) - the stage to copy to\n+# $(2) - the host triple\n+define DEF_INSTALL_DEBUGGER_SCRIPTS_HOST\n+\n+tmp/install-debugger-scripts$(1)_H_$(2).done: $$(DEBUGGER_SCRIPTS_ALL)\n+\t$(Q)mkdir -p $$(HBIN$(1)_H_$(2))\n+\t$(Q)mkdir -p $$(HLIB$(1)_H_$(2))/rustlib/etc\n+\t$(Q)install $(DEBUGGER_BIN_SCRIPTS_ABS) $$(HBIN$(1)_H_$(2))\n+\t$(Q)install $(DEBUGGER_RUSTLIB_ETC_SCRIPTS_ABS) $$(HLIB$(1)_H_$(2))/rustlib/etc\n+\t$(Q)touch $$@\n+endef\n+\n+# Expand host make-targets for all stages\n+$(foreach stage,$(STAGES), \\\n+  $(foreach host,$(CFG_HOST), \\\n+    $(eval $(call DEF_INSTALL_DEBUGGER_SCRIPTS_HOST,$(stage),$(host)))))\n+\n+# $(1) is the stage number\n+# $(2) is the target triple\n+# $(3) is the host triple\n+define DEF_INSTALL_DEBUGGER_SCRIPTS_TARGET\n+\n+tmp/install-debugger-scripts$(1)_T_$(2)_H_$(3).done: $$(DEBUGGER_SCRIPTS_ALL)\n+\t$(Q)mkdir -p $$(TBIN$(1)_T_$(2)_H_$(3))\n+\t$(Q)mkdir -p $$(TLIB$(1)_T_$(2)_H_$(3))/rustlib/etc\n+\t$(Q)install $(DEBUGGER_BIN_SCRIPTS_ABS) $$(TBIN$(1)_T_$(2)_H_$(3))\n+\t$(Q)install $(DEBUGGER_RUSTLIB_ETC_SCRIPTS_ABS) $$(TLIB$(1)_T_$(2)_H_$(3))/rustlib/etc\n+\t$(Q)touch $$@\n+endef\n+\n+# Expand target make-targets for all stages\n+$(foreach stage,$(STAGES), \\\n+  $(foreach target,$(CFG_TARGET), \\\n+    $(foreach host,$(CFG_HOST), \\\n+      $(eval $(call DEF_INSTALL_DEBUGGER_SCRIPTS_TARGET,$(stage),$(target),$(host))))))"}, {"sha": "bdda15dcc1835a9d63e40766707ef9c52da85c94", "filename": "mk/dist.mk", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -48,7 +48,6 @@ PKG_FILES := \\\n     $(S)configure $(S)Makefile.in              \\\n     $(S)man                                    \\\n     $(addprefix $(S)src/,                      \\\n-      README.md                                \\\n       compiletest                              \\\n       doc                                      \\\n       driver                                   \\\n@@ -59,6 +58,7 @@ PKG_FILES := \\\n       rt                                       \\\n       rustllvm                                 \\\n       snapshots.txt                            \\\n+      rust-installer                           \\\n       test)                                    \\\n     $(PKG_GITMODULES)                          \\\n     $(filter-out config.stamp, \\\n@@ -123,15 +123,16 @@ PKG_EXE = dist/$(PKG_NAME)-$(CFG_BUILD).exe\n $(PKG_EXE): rust.iss modpath.iss upgrade.iss LICENSE.txt rust-logo.ico \\\n             $(CSREQ3_T_$(CFG_BUILD)_H_$(CFG_BUILD)) \\\n             dist-prepare-win\n-\t$(CFG_PYTHON) $(S)src/etc/make-win-dist.py tmp/dist/win $(CFG_BUILD)\n+\t$(Q)rm -rf tmp/dist/win/gcc\n+\t$(CFG_PYTHON) $(S)src/etc/make-win-dist.py tmp/dist/win/rust tmp/dist/win/gcc $(CFG_BUILD)\n \t@$(call E, ISCC: $@)\n \t$(Q)$(CFG_ISCC) $<\n \n $(eval $(call DEF_PREPARE,win))\n \n dist-prepare-win: PREPARE_HOST=$(CFG_BUILD)\n dist-prepare-win: PREPARE_TARGETS=$(CFG_BUILD)\n-dist-prepare-win: PREPARE_DEST_DIR=tmp/dist/win\n+dist-prepare-win: PREPARE_DEST_DIR=tmp/dist/win/rust\n dist-prepare-win: PREPARE_DIR_CMD=$(DEFAULT_PREPARE_DIR_CMD)\n dist-prepare-win: PREPARE_BIN_CMD=$(DEFAULT_PREPARE_BIN_CMD)\n dist-prepare-win: PREPARE_LIB_CMD=$(DEFAULT_PREPARE_LIB_CMD)\n@@ -209,33 +210,40 @@ distcheck-osx: dist-osx\n # Unix binary installer tarballs\n ######################################################################\n \n+NON_INSTALLED_PREFIXES=COPYRIGHT,LICENSE-APACHE,LICENSE-MIT,README.md,doc\n+\n define DEF_INSTALLER\n \n $$(eval $$(call DEF_PREPARE,dir-$(1)))\n \n dist-install-dir-$(1): PREPARE_HOST=$(1)\n dist-install-dir-$(1): PREPARE_TARGETS=$(2)\n-dist-install-dir-$(1): PREPARE_DEST_DIR=tmp/dist/$$(PKG_NAME)-$(1)\n+dist-install-dir-$(1): PREPARE_DEST_DIR=tmp/dist/$$(PKG_NAME)-$(1)-image\n dist-install-dir-$(1): PREPARE_DIR_CMD=$(DEFAULT_PREPARE_DIR_CMD)\n dist-install-dir-$(1): PREPARE_BIN_CMD=$(DEFAULT_PREPARE_BIN_CMD)\n dist-install-dir-$(1): PREPARE_LIB_CMD=$(DEFAULT_PREPARE_LIB_CMD)\n dist-install-dir-$(1): PREPARE_MAN_CMD=$(DEFAULT_PREPARE_MAN_CMD)\n dist-install-dir-$(1): PREPARE_CLEAN=true\n dist-install-dir-$(1): prepare-base-dir-$(1) docs compiler-docs\n-\t$$(Q)(cd $$(PREPARE_DEST_DIR)/ && find . -type f | sed 's/^\\.\\///') \\\n-      > tmp/dist/manifest-$(1).in\n-\t$$(Q)mv tmp/dist/manifest-$(1).in $$(PREPARE_DEST_DIR)/$$(CFG_LIBDIR_RELATIVE)/rustlib/manifest.in\n-# Add remaining non-installed files\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)COPYRIGHT $$(PREPARE_DEST_DIR)\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)LICENSE-APACHE $$(PREPARE_DEST_DIR)\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)LICENSE-MIT $$(PREPARE_DEST_DIR)\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)README.md $$(PREPARE_DEST_DIR)\n-\t$$(Q)cp -r doc $$(PREPARE_DEST_DIR)\n-\t$$(Q)$$(PREPARE_BIN_CMD) $$(S)src/etc/install.sh $$(PREPARE_DEST_DIR)\n+\t$$(Q)[ ! -d doc ] || cp -r doc $$(PREPARE_DEST_DIR)\n \n dist/$$(PKG_NAME)-$(1).tar.gz: dist-install-dir-$(1)\n \t@$(call E, build: $$@)\n-\t$$(Q)tar -czf dist/$$(PKG_NAME)-$(1).tar.gz -C tmp/dist $$(PKG_NAME)-$(1)\n+\t$$(Q)$$(S)src/rust-installer/gen-installer.sh \\\n+\t\t--product-name=Rust \\\n+\t\t--verify-bin=rustc \\\n+\t\t--rel-manifest-dir=rustlib \\\n+\t\t--success-message=Rust-is-ready-to-roll. \\\n+\t\t--image-dir=tmp/dist/$$(PKG_NAME)-$(1)-image \\\n+\t\t--work-dir=tmp/dist \\\n+\t\t--output-dir=dist \\\n+\t\t--non-installed-prefixes=$$(NON_INSTALLED_PREFIXES) \\\n+\t\t--package-name=$$(PKG_NAME)-$(1)\n+\t$$(Q)rm -R tmp/dist/$$(PKG_NAME)-$(1)-image\n \n endef\n \n@@ -304,9 +312,17 @@ MAYBE_DIST_TAR_SRC=dist-tar-src\n MAYBE_DISTCHECK_TAR_SRC=distcheck-tar-src\n endif\n \n-dist: $(MAYBE_DIST_TAR_SRC) dist-osx dist-tar-bins dist-docs\n+ifneq ($(CFG_DISABLE_DOCS),)\n+MAYBE_DIST_DOCS=\n+MAYBE_DISTCHECK_DOCS=\n+else\n+MAYBE_DIST_DOCS=dist-docs\n+MAYBE_DISTCHECK_DOCS=distcheck-docs\n+endif\n+\n+dist: $(MAYBE_DIST_TAR_SRC) dist-osx dist-tar-bins $(MAYBE_DIST_DOCS)\n \n-distcheck: $(MAYBE_DISTCHECK_TAR_SRC) distcheck-osx distcheck-tar-bins distcheck-docs\n+distcheck: $(MAYBE_DISTCHECK_TAR_SRC) distcheck-osx distcheck-tar-bins $(MAYBE_DISTCHECK_DOCS)\n \t$(Q)rm -Rf tmp/distcheck\n \t@echo\n \t@echo -----------------------------------------------"}, {"sha": "9a924916ec8615a3b1ee285468b50ff822ba9547", "filename": "mk/docs.mk", "status": "modified", "additions": 3, "deletions": 56, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -25,7 +25,7 @@\n # L10N_LANGS are the languages for which the docs have been\n # translated.\n ######################################################################\n-DOCS := index intro tutorial guide guide-ffi guide-macros guide-lifetimes \\\n+DOCS := index intro tutorial guide guide-ffi guide-macros guide-ownership \\\n \tguide-tasks guide-container guide-pointers guide-testing \\\n \tguide-plugin guide-crates complement-bugreport guide-error-handling \\\n \tcomplement-lang-faq complement-design-faq complement-project-faq \\\n@@ -216,56 +216,6 @@ endef\n $(foreach docname,$(DOCS),$(eval $(call DEF_DOC,$(docname))))\n \n \n-# Localized documentation\n-\n-# FIXME: I (huonw) haven't actually been able to test properly, since\n-# e.g. (by default) I'm doing an out-of-tree build (#12763), but even\n-# adjusting for that, the files are too old(?) and are rejected by\n-# po4a.\n-#\n-# As such, I've attempted to get it working as much as possible (and\n-# switching from pandoc to rustdoc), but preserving the old behaviour\n-# (e.g. only running on the guide)\n-.PHONY: l10n-mds\n-l10n-mds: $(D)/po4a.conf \\\n-\t\t$(foreach lang,$(L10N_LANG),$(D)/po/$(lang)/*.md.po)\n-\t$(warning WARNING: localized documentation is experimental)\n-\tpo4a --copyright-holder=\"The Rust Project Developers\" \\\n-\t\t--package-name=\"Rust\" \\\n-\t\t--package-version=\"$(CFG_RELEASE)\" \\\n-\t\t-M UTF-8 -L UTF-8 \\\n-\t\t$(D)/po4a.conf\n-\n-define DEF_L10N_DOC\n-DOC_L10N_TARGETS += doc/l10n/$(1)/$(2).html\n-doc/l10n/$(1)/$(2).html: l10n-mds $$(HTML_DEPS) $$(RUSTDOC_DEPS_$(2))\n-\t@$$(call E, rustdoc: $$@)\n-\t$$(RUSTDOC) $$(RUSTDOC_HTML_OPTS) $$(RUSTDOC_FLAGS_$(1)) doc/l10n/$(1)/$(2).md\n-endef\n-\n-$(foreach lang,$(L10N_LANGS),$(eval $(call DEF_L10N_DOC,$(lang),guide)))\n-\n-\n-######################################################################\n-# LLnextgen (grammar analysis from refman)\n-######################################################################\n-\n-ifeq ($(CFG_LLNEXTGEN),)\n-  $(info cfg: no llnextgen found, omitting grammar-verification)\n-else\n-.PHONY: verify-grammar\n-\n-doc/rust.g: $(D)/rust.md $(S)src/etc/extract_grammar.py\n-\t@$(call E, extract_grammar: $@)\n-\t$(Q)$(CFG_PYTHON) $(S)src/etc/extract_grammar.py $< >$@\n-\n-verify-grammar: doc/rust.g\n-\t@$(call E, LLnextgen: $<)\n-\t$(Q)$(CFG_LLNEXTGEN) --generate-lexer-wrapper=no $< >$@\n-\t$(Q)rm -f doc/rust.c doc/rust.h\n-endif\n-\n-\n ######################################################################\n # Rustdoc (libstd/extra)\n ######################################################################\n@@ -299,7 +249,8 @@ $(2) += doc/$(1)/index.html\n doc/$(1)/index.html: CFG_COMPILER_HOST_TRIPLE = $(CFG_TARGET)\n doc/$(1)/index.html: $$(LIB_DOC_DEP_$(1)) doc/$(1)/\n \t@$$(call E, rustdoc: $$@)\n-\t$$(Q)$$(RUSTDOC) --cfg dox --cfg stage2 $$<\n+\t$$(Q)CFG_LLVM_LINKAGE_FILE=$$(LLVM_LINKAGE_PATH_$(CFG_BUILD)) \\\n+\t\t$$(RUSTDOC) --cfg dox --cfg stage2 $$<\n endef\n \n $(foreach crate,$(DOC_CRATES),$(eval $(call DEF_LIB_DOC,$(crate),DOC_TARGETS)))\n@@ -313,7 +264,3 @@ endif\n \n docs: $(DOC_TARGETS)\n compiler-docs: $(COMPILER_DOC_TARGETS)\n-\n-docs-l10n: $(DOC_L10N_TARGETS)\n-\n-.PHONY: docs-l10n"}, {"sha": "632df3c754b8d153efdf193e1365f7a5bfa73366", "filename": "mk/install.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -25,7 +25,7 @@ endif\n # Remove tmp files because it's a decent amount of disk space\n \t$(Q)rm -R tmp/dist\n \n-prepare_install: dist-install-dir-$(CFG_BUILD) | tmp/empty_dir\n+prepare_install: dist/$(PKG_NAME)-$(CFG_BUILD).tar.gz | tmp/empty_dir\n \n uninstall:\n ifeq (root user, $(USER) $(patsubst %,user,$(SUDO_USER)))\n@@ -38,7 +38,7 @@ endif\n # Remove tmp files because it's a decent amount of disk space\n \t$(Q)rm -R tmp/dist\n \n-prepare_uninstall: dist-install-dir-$(CFG_BUILD) | tmp/empty_dir\n+prepare_uninstall: dist/$(PKG_NAME)-$(CFG_BUILD).tar.gz | tmp/empty_dir\n \n .PHONY: install prepare_install uninstall prepare_uninstall\n "}, {"sha": "ba2e073803935b89632a9e476a40a4293fd45cfb", "filename": "mk/llvm.mk", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fllvm.mk?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -49,6 +49,12 @@ else\n LLVM_STDCPP_LOCATION_$(1) =\n endif\n \n+\n+# LLVM linkage:\n+LLVM_LINKAGE_PATH_$(1):=$$(abspath $$(RT_OUTPUT_DIR_$(1))/llvmdeps.rs)\n+$$(LLVM_LINKAGE_PATH_$(1)): $(S)src/etc/mklldeps.py $$(LLVM_CONFIG_$(1))\n+\t$(Q)$(CFG_PYTHON) \"$$<\" \"$$@\" \"$$(LLVM_COMPONENTS)\" \"$$(CFG_ENABLE_LLVM_STATIC_STDCPP)\" \\\n+\t\t$$(LLVM_CONFIG_$(1))\n endef\n \n $(foreach host,$(CFG_HOST), \\\n@@ -57,10 +63,14 @@ $(foreach host,$(CFG_HOST), \\\n $(foreach host,$(CFG_HOST), \\\n  $(eval LLVM_CONFIGS := $(LLVM_CONFIGS) $(LLVM_CONFIG_$(host))))\n \n-$(S)src/librustc_llvm/llvmdeps.rs: \\\n-\t\t    $(LLVM_CONFIGS) \\\n-\t\t    $(S)src/etc/mklldeps.py \\\n-\t\t    $(MKFILE_DEPS)\n-\t$(Q)$(CFG_PYTHON) $(S)src/etc/mklldeps.py \\\n-\t\t\"$@\" \"$(LLVM_COMPONENTS)\" \"$(CFG_ENABLE_LLVM_STATIC_STDCPP)\" \\\n-\t\t$(LLVM_CONFIGS)\n+# This can't be done in target.mk because it's included before this file.\n+define LLVM_LINKAGE_DEPS\n+$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.rustc_llvm: $$(LLVM_LINKAGE_PATH_$(3))\n+endef\n+\n+$(foreach source,$(CFG_HOST), \\\n+ $(foreach target,$(CFG_TARGET), \\\n+  $(eval $(call LLVM_LINKAGE_DEPS,0,$(target),$(source))) \\\n+  $(eval $(call LLVM_LINKAGE_DEPS,1,$(target),$(source))) \\\n+  $(eval $(call LLVM_LINKAGE_DEPS,2,$(target),$(source))) \\\n+  $(eval $(call LLVM_LINKAGE_DEPS,3,$(target),$(source)))))"}, {"sha": "4aed1cea9ca0987dd637ffbdd1a5fdac70e2307c", "filename": "mk/main.mk", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -190,11 +190,14 @@ endif\n # Target-and-rule \"utility variables\"\n ######################################################################\n \n-define DEF_X\n+define DEF_FOR_TARGET\n X_$(1) := $(CFG_EXE_SUFFIX_$(1))\n+ifndef CFG_LLVM_TARGET_$(1)\n+CFG_LLVM_TARGET_$(1) := $(1)\n+endif\n endef\n $(foreach target,$(CFG_TARGET), \\\n-  $(eval $(call DEF_X,$(target))))\n+  $(eval $(call DEF_FOR_TARGET,$(target))))\n \n # \"Source\" files we generate in builddir along the way.\n GENERATED :=\n@@ -353,7 +356,8 @@ HSREQ$(1)_H_$(3) = $$(HBIN$(1)_H_$(3))/rustc$$(X_$(3))\n else\n HSREQ$(1)_H_$(3) = \\\n \t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3)) \\\n-\t$$(MKFILE_DEPS)\n+\t$$(MKFILE_DEPS) \\\n+\ttmp/install-debugger-scripts$(1)_H_$(3).done\n endif\n \n # Prerequisites for using the stageN compiler to build target artifacts\n@@ -367,7 +371,8 @@ TSREQ$(1)_T_$(2)_H_$(3) = \\\n SREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n \t$$(foreach dep,$$(TARGET_CRATES), \\\n-\t    $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(dep))\n+\t    $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(dep)) \\\n+\ttmp/install-debugger-scripts$(1)_T_$(2)_H_$(3).done\n \n # Prerequisites for a working stageN compiler and complete set of target\n # libraries"}, {"sha": "d404d3d2950e04a931740f3e926975ad4f97efd2", "filename": "mk/prepare.mk", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fprepare.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fprepare.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fprepare.mk?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -155,7 +155,7 @@ prepare-base-$(1): PREPARE_DEST_LIB_DIR=$$(PREPARE_DEST_DIR)/$$(CFG_LIBDIR_RELAT\n prepare-base-$(1): PREPARE_DEST_MAN_DIR=$$(PREPARE_DEST_DIR)/share/man/man1\n prepare-base-$(1): prepare-everything-$(1)\n \n-prepare-everything-$(1): prepare-host-$(1) prepare-targets-$(1)\n+prepare-everything-$(1): prepare-host-$(1) prepare-targets-$(1) prepare-debugger-scripts-$(1)\n \n prepare-host-$(1): prepare-host-tools-$(1)\n \n@@ -167,8 +167,13 @@ prepare-host-tools-$(1): \\\n prepare-host-dirs-$(1): prepare-maybe-clean-$(1)\n \t$$(call PREPARE_DIR,$$(PREPARE_DEST_BIN_DIR))\n \t$$(call PREPARE_DIR,$$(PREPARE_DEST_LIB_DIR))\n+\t$$(call PREPARE_DIR,$$(PREPARE_DEST_LIB_DIR)/rustlib/etc)\n \t$$(call PREPARE_DIR,$$(PREPARE_DEST_MAN_DIR))\n \n+prepare-debugger-scripts-$(1): prepare-host-dirs-$(1) $(DEBUGGER_SCRIPTS_ALL)\n+\t$$(Q)$$(PREPARE_BIN_CMD) $(DEBUGGER_BIN_SCRIPTS_ABS) $$(PREPARE_DEST_BIN_DIR)\n+\t$$(Q)$$(PREPARE_LIB_CMD) $(DEBUGGER_RUSTLIB_ETC_SCRIPTS_ABS) $$(PREPARE_DEST_LIB_DIR)/rustlib/etc\n+\n $$(foreach tool,$$(PREPARE_TOOLS), \\\n   $$(foreach host,$$(CFG_HOST), \\\n       $$(eval $$(call DEF_PREPARE_HOST_TOOL,$$(tool),$$(PREPARE_STAGE),$$(host),$(1)))))"}, {"sha": "a1d18aae1b45948fbdcbdad8a9fd9f58f1a4fd04", "filename": "mk/rt.mk", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -35,7 +35,7 @@\n # that's per-target so you're allowed to conditionally add files based on the\n # target.\n ################################################################################\n-NATIVE_LIBS := rust_builtin hoedown morestack miniz context_switch \\\n+NATIVE_LIBS := rust_builtin hoedown morestack miniz \\\n \t\trustrt_native rust_test_helpers\n \n # $(1) is the target triple\n@@ -58,8 +58,7 @@ NATIVE_DEPS_rustrt_native_$(1) := \\\n \t\t\tarch/$$(HOST_$(1))/record_sp.S\n NATIVE_DEPS_rust_test_helpers_$(1) := rust_test_helpers.c\n NATIVE_DEPS_morestack_$(1) := arch/$$(HOST_$(1))/morestack.S\n-NATIVE_DEPS_context_switch_$(1) := \\\n-\t\t\tarch/$$(HOST_$(1))/_context.S\n+\n \n ################################################################################\n # You shouldn't find it that necessary to edit anything below this line.\n@@ -75,7 +74,7 @@ $$(RT_OUTPUT_DIR_$(1))/%.o: $(S)src/rt/%.ll $$(MKFILE_DEPS) \\\n \t@mkdir -p $$(@D)\n \t@$$(call E, compile: $$@)\n \t$$(Q)$$(LLC_$$(CFG_BUILD)) $$(CFG_LLC_FLAGS_$(1)) \\\n-\t    -filetype=obj -mtriple=$(1) -relocation-model=pic -o $$@ $$<\n+\t    -filetype=obj -mtriple=$$(CFG_LLVM_TARGET_$(1)) -relocation-model=pic -o $$@ $$<\n \n $$(RT_OUTPUT_DIR_$(1))/%.o: $(S)src/rt/%.c $$(MKFILE_DEPS)\n \t@mkdir -p $$(@D)"}, {"sha": "44225020811c0470848bb5130b4f022e970b6142", "filename": "mk/rustllvm.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Frustllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Frustllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frustllvm.mk?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -22,7 +22,8 @@ LLVM_EXTRA_INCDIRS_$(1)= -iquote $(S)src/llvm/include \\\n                          -iquote $$(CFG_LLVM_BUILD_DIR_$(1))/include\n endif\n \n-RUSTLLVM_OBJS_CS_$(1) := $$(addprefix rustllvm/, RustWrapper.cpp PassWrapper.cpp)\n+RUSTLLVM_OBJS_CS_$(1) := $$(addprefix rustllvm/, \\\n+\tExecutionEngineWrapper.cpp RustWrapper.cpp PassWrapper.cpp)\n \n RUSTLLVM_DEF_$(1) := $(1)/rustllvm/rustllvm$(CFG_DEF_SUFFIX_$(1))\n "}, {"sha": "460a4a7f445e36419bed34826710950850e9a0a1", "filename": "mk/stage0.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fstage0.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Fstage0.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage0.mk?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -22,7 +22,7 @@ ifdef CFG_ENABLE_LOCAL_RUST\n else\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/get-snapshot.py $(CFG_BUILD) $(SNAPSHOT_FILE)\n endif\n-\t$(Q)touch $@\n+\t$(Q)if [ -e \"$@\" ]; then touch \"$@\"; else echo \"ERROR: snapshot $@ not found\"; exit 1; fi\n \n # For other targets, let the host build the target:\n "}, {"sha": "1f67d9ed8da2934a6f3c68cdf2fc6e3823d255b7", "filename": "mk/target.mk", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -79,7 +79,8 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4): \\\n \t    $$(dir $$@)$$(call CFG_LIB_GLOB_$(2),$(4)))\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES, \\\n \t    $$(dir $$@)$$(call CFG_RLIB_GLOB,$(4)))\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) \\\n+\t$(Q)CFG_LLVM_LINKAGE_FILE=$$(LLVM_LINKAGE_PATH_$(3)) \\\n+\t    $$(subst @,,$$(STAGE$(1)_T_$(2)_H_$(3))) \\\n \t\t$$(RUST_LIB_FLAGS_ST$(1)) \\\n \t\t-L \"$$(RT_OUTPUT_DIR_$(2))\" \\\n \t\t-L \"$$(LLVM_LIBDIR_$(2))\" \\\n@@ -116,7 +117,7 @@ $$(TBIN$(1)_T_$(2)_H_$(3))/$(4)$$(X_$(2)): \\\n \t\t$$(foreach dep,$$(TOOL_DEPS_$(4)), \\\n \t\t    $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(dep)) \\\n \t\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n-\t\t| $$(TBIN$(1)_T_$(4)_H_$(3))/\n+\t\t| $$(TBIN$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, rustc: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --cfg $(4)\n \n@@ -134,8 +135,6 @@ SNAPSHOT_RUSTC_POST_CLEANUP=$(HBIN0_H_$(CFG_BUILD))/rustc$(X_$(CFG_BUILD))\n \n define TARGET_HOST_RULES\n \n-$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.rustc_llvm: $(S)src/librustc_llvm/llvmdeps.rs\n-\n $$(TBIN$(1)_T_$(2)_H_$(3))/:\n \tmkdir -p $$@\n "}, {"sha": "1a122572e434c4c7a05f3c906209735fcbdab964", "filename": "mk/tests.mk", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -21,7 +21,8 @@ $(eval $(call RUST_CRATE,coretest))\n \n TEST_TARGET_CRATES = $(filter-out core unicode,$(TARGET_CRATES)) coretest\n TEST_DOC_CRATES = $(DOC_CRATES)\n-TEST_HOST_CRATES = $(HOST_CRATES)\n+TEST_HOST_CRATES = $(filter-out rustc_typeck rustc_borrowck rustc_resolve rustc_trans,\\\n+                     $(HOST_CRATES))\n TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n \n ######################################################################\n@@ -73,21 +74,6 @@ endif\n TEST_LOG_FILE=tmp/check-stage$(1)-T-$(2)-H-$(3)-$(4).log\n TEST_OK_FILE=tmp/check-stage$(1)-T-$(2)-H-$(3)-$(4).ok\n \n-TEST_RATCHET_FILE=tmp/check-stage$(1)-T-$(2)-H-$(3)-$(4)-metrics.json\n-TEST_RATCHET_NOISE_PERCENT=10.0\n-\n-# Whether to ratchet or merely save benchmarks\n-ifdef CFG_RATCHET_BENCH\n-CRATE_TEST_EXTRA_ARGS= \\\n-  --test $(TEST_BENCH) \\\n-  --ratchet-metrics $(call TEST_RATCHET_FILE,$(1),$(2),$(3),$(4)) \\\n-  --ratchet-noise-percent $(TEST_RATCHET_NOISE_PERCENT)\n-else\n-CRATE_TEST_EXTRA_ARGS= \\\n-  --test $(TEST_BENCH) \\\n-  --save-metrics $(call TEST_RATCHET_FILE,$(1),$(2),$(3),$(4))\n-endif\n-\n # If we're sharding the testsuite between parallel testers,\n # pass this argument along to the compiletest and crate test\n # invocations.\n@@ -412,7 +398,8 @@ $(3)/stage$(1)/test/$(4)test-$(2)$$(X_$(2)): \\\n \t\t$$(CRATEFILE_$(4)) \\\n \t\t$$(TESTDEP_$(1)_$(2)_$(3)_$(4))\n \t@$$(call E, rustc: $$@)\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test \\\n+\t$(Q)CFG_LLVM_LINKAGE_FILE=$$(LLVM_LINKAGE_PATH_$(3)) \\\n+\t    $$(subst @,,$$(STAGE$(1)_T_$(2)_H_$(3))) -o $$@ $$< --test \\\n \t\t-L \"$$(RT_OUTPUT_DIR_$(2))\" \\\n \t\t-L \"$$(LLVM_LIBDIR_$(2))\" \\\n \t\t$$(RUSTFLAGS_$(4))\n@@ -453,7 +440,6 @@ $$(call TEST_OK_FILE,$(1),$(2),$(3),$(4)): \\\n \t$$(Q)touch tmp/check-stage$(1)-T-$(2)-H-$(3)-$(4).log\n \t$$(Q)$(CFG_ADB) pull $(CFG_ADB_TEST_DIR)/check-stage$(1)-T-$(2)-H-$(3)-$(4).log tmp/\n \t$$(Q)$(CFG_ADB) shell rm $(CFG_ADB_TEST_DIR)/check-stage$(1)-T-$(2)-H-$(3)-$(4).log\n-\t$$(Q)$(CFG_ADB) pull $(CFG_ADB_TEST_DIR)/$$(call TEST_RATCHET_FILE,$(1),$(2),$(3),$(4)) tmp/\n \t@if grep -q \"result: ok\" tmp/check-stage$(1)-T-$(2)-H-$(3)-$(4).tmp; \\\n \tthen \\\n \t\trm tmp/check-stage$(1)-T-$(2)-H-$(3)-$(4).tmp; \\\n@@ -597,7 +583,7 @@ CTEST_DISABLE_debuginfo-lldb = \"lldb tests are only run on darwin\"\n endif\n \n ifeq ($(CFG_OSTYPE),apple-darwin)\n-CTEST_DISABLE_debuginfo-gdb = \"gdb on darwing needs root\"\n+CTEST_DISABLE_debuginfo-gdb = \"gdb on darwin needs root\"\n endif\n \n # CTEST_DISABLE_NONSELFHOST_$(TEST_GROUP), if set, will cause that\n@@ -695,7 +681,6 @@ CTEST_ARGS$(1)-T-$(2)-H-$(3)-$(4) := \\\n         $$(CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3)) \\\n         --src-base $$(S)src/test/$$(CTEST_SRC_BASE_$(4))/ \\\n         --build-base $(3)/test/$$(CTEST_BUILD_BASE_$(4))/ \\\n-        --ratchet-metrics $(call TEST_RATCHET_FILE,$(1),$(2),$(3),$(4)) \\\n         --mode $$(CTEST_MODE_$(4)) \\\n \t$$(CTEST_RUNTOOL_$(4))\n \n@@ -890,7 +875,8 @@ endif\n ifeq ($(2),$$(CFG_BUILD))\n $$(call TEST_OK_FILE,$(1),$(2),$(3),doc-crate-$(4)): $$(CRATEDOCTESTDEP_$(1)_$(2)_$(3)_$(4))\n \t@$$(call E, run doc-crate-$(4) [$(2)])\n-\t$$(Q)$$(RUSTDOC_$(1)_T_$(2)_H_$(3)) --test --cfg dox \\\n+\t$$(Q)CFG_LLVM_LINKAGE_FILE=$$(LLVM_LINKAGE_PATH_$(3)) \\\n+\t    $$(RUSTDOC_$(1)_T_$(2)_H_$(3)) --test --cfg dox \\\n \t    \t$$(CRATEFILE_$(4)) --test-args \"$$(TESTARGS)\" && touch $$@\n else\n $$(call TEST_OK_FILE,$(1),$(2),$(3),doc-crate-$(4)):"}, {"sha": "c72fd14ec5b6d09487e80d1f6c0938942a906bfa", "filename": "src/README.md", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e", "patch": "@@ -1,66 +0,0 @@\n-This is a preliminary version of the Rust compiler, libraries and tools.\n-\n-Source layout:\n-\n-| Path                | Description                                               |\n-| ------------------- | --------------------------------------------------------- |\n-| `librustc/`         | The self-hosted compiler                                  |\n-| `liballoc/`         | Rust's core allocation library                            |\n-| `libcore/`          | The Rust core library                                     |\n-| `libdebug/`         | Debugging utilities                                       |\n-| `libstd/`           | The standard library (imported and linked by default)     |\n-| `libsyntax/`        | The Rust parser and pretty-printer                        |\n-| `libtest/`          | Rust's test-runner code                                   |\n-| ------------------- | --------------------------------------------------------- |\n-| `libarena/`         | The arena (a fast but limited) memory allocator           |\n-| `libbacktrace/`     | The libbacktrace library                                  |\n-| `libcollections/`   | A collection of useful data structures and containers     |\n-| `libflate/`         | Simple compression library                                |\n-| `libfmt_macros/`    | Macro support for format strings                          |\n-| `libfourcc/`        | Data format identifier library                            |\n-| `libgetopts/`       | Get command-line-options library                          |\n-| `libglob/`          | Unix glob patterns library                                |\n-| `libgraphviz/`      | Generating files for Graphviz                             |\n-| `libhexfloat/`      | Hexadecimal floating-point literals                       |\n-| `liblibc/`          | Bindings for the C standard library                       |\n-| `liblog/`           | Utilities for program-wide and customizable logging       |\n-| `libnum/`           | Extended number support library (complex, rational, etc)  |\n-| `librand/`          | Random numbers and distributions                          |\n-| `libregex/`         | Regular expressions                                       |\n-| `libregex_macros/`  | The regex! syntax extension                               |\n-| `libsemver/`        | Rust's semantic versioning library                        |\n-| `libserialize/`     | Encode-Decode types library                               |\n-| `libsync/`          | Concurrency mechanisms and primitives                     |\n-| `libterm/`          | ANSI color library for terminals                          |\n-| `libtime/`          | Time operations library                                   |\n-| `liburl/`           | URL handling lirary                                       |\n-| `libuuid/`          | UUID's handling code                                      |\n-| ------------------- | --------------------------------------------------------- |\n-| `rt/`               | The runtime system                                        |\n-| `rt/rust_*.c`       | - Some of the runtime services                            |\n-| `rt/vg`             | - Valgrind headers                                        |\n-| `rt/msvc`           | - MSVC support                                            |\n-| `rt/sundown`        | - The Markdown library used by rustdoc                    |\n-| ------------------- | --------------------------------------------------------- |\n-| `compiletest/`      | The test runner                                           |\n-| `test/`             | Testsuite                                                 |\n-| `test/codegen`      | - Tests for the LLVM IR infrastructure                    |\n-| `test/compile-fail` | - Tests that should fail to compile                       |\n-| `test/debug-info`   | - Tests for the `debuginfo` tool                          |\n-| `test/run-fail`     | - Tests that should compile, run and fail                 |\n-| `test/run-make`     | - Tests that depend on a Makefile infrastructure          |\n-| `test/run-pass`     | - Tests that should compile, run and succeed              |\n-| `test/bench`        | - Benchmarks and miscellaneous                            |\n-| `test/pretty`       | - Pretty-printer tests                                    |\n-| `test/auxiliary`    | - Dependencies of tests                                   |\n-| ------------------- | --------------------------------------------------------- |\n-| `librustdoc/`       | The Rust API documentation tool                           |\n-| ------------------- | --------------------------------------------------------- |\n-| `llvm/`             | The LLVM submodule                                        |\n-| `rustllvm/`         | LLVM support code                                         |\n-| ------------------- | --------------------------------------------------------- |\n-| `etc/`              | Scripts, editors support, misc                            |\n-\n-\n-NOTE: This list (especially the second part of the table which contains modules and libraries)\n-is highly volatile and subject to change."}, {"sha": "62b757529dc9f46c6781f14fedae18ec45f636e7", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -25,6 +25,8 @@ pub enum Mode {\n     Codegen\n }\n \n+impl Copy for Mode {}\n+\n impl FromStr for Mode {\n     fn from_str(s: &str) -> Option<Mode> {\n         match s {"}, {"sha": "bdbfbfd7c89d60a9e1933b94c312ebc362ede8d2", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_type = \"bin\"]\n-#![feature(phase, slicing_syntax, globs)]\n+#![feature(phase, slicing_syntax, globs, unboxed_closures)]\n \n #![deny(warnings)]\n \n@@ -23,6 +23,7 @@ use std::os;\n use std::io;\n use std::io::fs;\n use std::str::FromStr;\n+use std::thunk::{Thunk};\n use getopts::{optopt, optflag, reqopt};\n use common::Config;\n use common::{Pretty, DebugInfoGdb, DebugInfoLldb, Codegen};\n@@ -151,7 +152,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n             matches.opt_str(\"ratchet-metrics\").map(|s| Path::new(s)),\n         ratchet_noise_percent:\n             matches.opt_str(\"ratchet-noise-percent\")\n-                   .and_then(|s| from_str::<f64>(s.as_slice())),\n+                   .and_then(|s| s.as_slice().parse::<f64>()),\n         runtool: matches.opt_str(\"runtool\"),\n         host_rustcflags: matches.opt_str(\"host-rustcflags\"),\n         target_rustcflags: matches.opt_str(\"target-rustcflags\"),\n@@ -189,9 +190,7 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"filter: {}\",\n                     opt_str(&config.filter\n                                    .as_ref()\n-                                   .map(|re| {\n-                                       re.to_string().into_string()\n-                                   }))));\n+                                   .map(|re| re.to_string()))));\n     logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n     logv(c, format!(\"host-rustcflags: {}\",\n                     opt_str(&config.host_rustcflags)));\n@@ -286,6 +285,9 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         test_shard: config.test_shard.clone(),\n         nocapture: false,\n         color: test::AutoColor,\n+        show_boxplot: false,\n+        boxplot_width: 50,\n+        show_all_stats: false,\n     }\n }\n \n@@ -343,7 +345,7 @@ pub fn make_test(config: &Config, testfile: &Path, f: || -> test::TestFn)\n         desc: test::TestDesc {\n             name: make_test_name(config, testfile),\n             ignore: header::is_test_ignored(config, testfile),\n-            should_fail: false\n+            should_fail: test::ShouldFail::No,\n         },\n         testfn: f(),\n     }\n@@ -366,16 +368,16 @@ pub fn make_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n     let config = (*config).clone();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let testfile = testfile.as_str().unwrap().to_string();\n-    test::DynTestFn(proc() {\n+    test::DynTestFn(Thunk::new(move || {\n         runtest::run(config, testfile)\n-    })\n+    }))\n }\n \n pub fn make_metrics_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n     let config = (*config).clone();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let testfile = testfile.as_str().unwrap().to_string();\n-    test::DynMetricFn(proc(mm) {\n+    test::DynMetricFn(box move |: mm: &mut test::MetricMap| {\n         runtest::run_metrics(config, testfile, mm)\n     })\n }\n@@ -390,7 +392,7 @@ fn extract_gdb_version(full_version_line: Option<String>) -> Option<String> {\n \n             match re.captures(full_version_line) {\n                 Some(captures) => {\n-                    Some(captures.at(2).to_string())\n+                    Some(captures.at(2).unwrap_or(\"\").to_string())\n                 }\n                 None => {\n                     println!(\"Could not extract GDB version from line '{}'\",\n@@ -424,7 +426,7 @@ fn extract_lldb_version(full_version_line: Option<String>) -> Option<String> {\n \n             match re.captures(full_version_line) {\n                 Some(captures) => {\n-                    Some(captures.at(1).to_string())\n+                    Some(captures.at(1).unwrap_or(\"\").to_string())\n                 }\n                 None => {\n                     println!(\"Could not extract LLDB version from line '{}'\","}, {"sha": "b7df43aabdd2093b9b6462970cdb30bff074bdf6", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 61, "deletions": 13, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -7,7 +7,9 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+use self::WhichLine::*;\n \n+use std::ascii::AsciiExt;\n use std::io::{BufferedReader, File};\n use regex::Regex;\n \n@@ -17,28 +19,74 @@ pub struct ExpectedError {\n     pub msg: String,\n }\n \n-pub static EXPECTED_PATTERN : &'static str = r\"//~(?P<adjusts>\\^*)\\s*(?P<kind>\\S*)\\s*(?P<msg>.*)\";\n+/// Looks for either \"//~| KIND MESSAGE\" or \"//~^^... KIND MESSAGE\"\n+/// The former is a \"follow\" that inherits its target from the preceding line;\n+/// the latter is an \"adjusts\" that goes that many lines up.\n+///\n+/// Goal is to enable tests both like: //~^^^ ERROR go up three\n+/// and also //~^ ERROR message one for the preceding line, and\n+///          //~| ERROR message two for that same line.\n+\n+pub static EXPECTED_PATTERN : &'static str =\n+    r\"//~(?P<follow>\\|)?(?P<adjusts>\\^*)\\s*(?P<kind>\\S*)\\s*(?P<msg>.*)\";\n+\n+#[deriving(PartialEq, Show)]\n+enum WhichLine { ThisLine, FollowPrevious(uint), AdjustBackward(uint) }\n \n // Load any test directives embedded in the file\n pub fn load_errors(re: &Regex, testfile: &Path) -> Vec<ExpectedError> {\n     let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n \n+    // `last_nonfollow_error` tracks the most recently seen\n+    // line with an error template that did not use the\n+    // follow-syntax, \"//~| ...\".\n+    //\n+    // (pnkfelix could not find an easy way to compose Iterator::scan\n+    // and Iterator::filter_map to pass along this information into\n+    // `parse_expected`. So instead I am storing that state here and\n+    // updating it in the map callback below.)\n+    let mut last_nonfollow_error = None;\n+\n     rdr.lines().enumerate().filter_map(|(line_no, ln)| {\n-        parse_expected(line_no + 1, ln.unwrap().as_slice(), re)\n+        parse_expected(last_nonfollow_error,\n+                       line_no + 1,\n+                       ln.unwrap().as_slice(), re)\n+            .map(|(which, error)| {\n+                match which {\n+                    FollowPrevious(_) => {}\n+                    _ => last_nonfollow_error = Some(error.line),\n+                }\n+                error\n+            })\n     }).collect()\n }\n \n-fn parse_expected(line_num: uint, line: &str, re: &Regex) -> Option<ExpectedError> {\n+fn parse_expected(last_nonfollow_error: Option<uint>,\n+                  line_num: uint,\n+                  line: &str,\n+                  re: &Regex) -> Option<(WhichLine, ExpectedError)> {\n     re.captures(line).and_then(|caps| {\n-        let adjusts = caps.name(\"adjusts\").len();\n-        let kind = caps.name(\"kind\").to_ascii().to_lowercase().into_string();\n-        let msg = caps.name(\"msg\").trim().to_string();\n-\n-        debug!(\"line={} kind={} msg={}\", line_num, kind, msg);\n-        Some(ExpectedError {\n-            line: line_num - adjusts,\n-            kind: kind,\n-            msg: msg,\n-        })\n+        let adjusts = caps.name(\"adjusts\").unwrap_or(\"\").len();\n+        let kind = caps.name(\"kind\").unwrap_or(\"\").to_ascii_lower();\n+        let msg = caps.name(\"msg\").unwrap_or(\"\").trim().to_string();\n+        let follow = caps.name(\"follow\").unwrap_or(\"\").len() > 0;\n+\n+        let (which, line) = if follow {\n+            assert!(adjusts == 0, \"use either //~| or //~^, not both.\");\n+            let line = last_nonfollow_error.unwrap_or_else(|| {\n+                panic!(\"encountered //~| without preceding //~^ line.\")\n+            });\n+            (FollowPrevious(line), line)\n+        } else {\n+            let which =\n+                if adjusts > 0 { AdjustBackward(adjusts) } else { ThisLine };\n+            let line = line_num - adjusts;\n+            (which, line)\n+        };\n+\n+        debug!(\"line={} which={} kind={} msg={}\", line_num, which, kind, msg);\n+        Some((which, ExpectedError { line: line,\n+                                     kind: kind,\n+                                     msg: msg, }))\n     })\n }"}, {"sha": "27be6c6d8356889e700203280c56e285e476364f", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -351,8 +351,8 @@ pub fn gdb_version_to_int(version_string: &str) -> int {\n         panic!(\"{}\", error_string);\n     }\n \n-    let major: int = from_str(components[0]).expect(error_string);\n-    let minor: int = from_str(components[1]).expect(error_string);\n+    let major: int = components[0].parse().expect(error_string);\n+    let minor: int = components[1].parse().expect(error_string);\n \n     return major * 1000 + minor;\n }\n@@ -362,6 +362,6 @@ pub fn lldb_version_to_int(version_string: &str) -> int {\n         \"Encountered LLDB version string with unexpected format: {}\",\n         version_string);\n     let error_string = error_string.as_slice();\n-    let major: int = from_str(version_string).expect(error_string);\n+    let major: int = version_string.parse().expect(error_string);\n     return major;\n }"}, {"sha": "bf72250c4705af70e5e43d64cf8eafb9f4e8e917", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#[cfg(not(stage0))]\n+\n use self::TargetLocation::*;\n \n use common::Config;\n@@ -32,7 +32,7 @@ use std::io;\n use std::os;\n use std::str;\n use std::string::String;\n-use std::task;\n+use std::thread::Thread;\n use std::time::Duration;\n use test::MetricMap;\n \n@@ -445,9 +445,9 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             loop {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(Duration::milliseconds(1000));\n-                let result = task::try(proc() {\n+                let result = Thread::spawn(move || {\n                     tcp::TcpStream::connect(\"127.0.0.1:5039\").unwrap();\n-                });\n+                }).join();\n                 if result.is_err() {\n                     continue;\n                 }\n@@ -990,7 +990,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n         let i = s.chars();\n         let c : Vec<char> = i.map( |c| {\n             if c.is_ascii() {\n-                c.to_ascii().to_lowercase().to_char()\n+                c.to_ascii().to_lowercase().as_char()\n             } else {\n                 c\n             }\n@@ -1161,7 +1161,7 @@ fn compile_test_(config: &Config, props: &TestProps,\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args,\n-                                 |a, b| ThisFile(make_exe_name(a, b)), testfile);\n+                                 |a, b| TargetLocation::ThisFile(make_exe_name(a, b)), testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)\n }\n \n@@ -1219,7 +1219,7 @@ fn compose_and_run_compiler(\n                               crate_type,\n                               |a,b| {\n                                   let f = make_lib_name(a, b, testfile);\n-                                  ThisDirectory(f.dir_path())\n+                                  TargetLocation::ThisDirectory(f.dir_path())\n                               },\n                               &abs_ab);\n         let auxres = compose_and_run(config,\n@@ -1296,11 +1296,11 @@ fn make_compile_args(config: &Config,\n         args.push(\"prefer-dynamic\".to_string());\n     }\n     let path = match xform_file {\n-        ThisFile(path) => {\n+        TargetLocation::ThisFile(path) => {\n             args.push(\"-o\".to_string());\n             path\n         }\n-        ThisDirectory(path) => {\n+        TargetLocation::ThisDirectory(path) => {\n             args.push(\"--out-dir\".to_string());\n             path\n         }\n@@ -1361,7 +1361,7 @@ fn split_maybe_args(argstr: &Option<String>) -> Vec<String> {\n             s.as_slice()\n              .split(' ')\n              .filter_map(|s| {\n-                 if s.is_whitespace() {\n+                 if s.chars().all(|c| c.is_whitespace()) {\n                      None\n                  } else {\n                      Some(s.to_string())\n@@ -1609,7 +1609,7 @@ fn _arm_exec_compiled_test(config: &Config,\n                 stderr_out.as_slice());\n \n     ProcRes {\n-        status: process::ExitStatus(exitcode),\n+        status: process::ProcessExit::ExitStatus(exitcode),\n         stdout: stdout_out,\n         stderr: stderr_out,\n         cmdline: cmdline\n@@ -1666,13 +1666,14 @@ fn compile_test_and_save_bitcode(config: &Config, props: &TestProps,\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let mut link_args = vec!(\"-L\".to_string(),\n                              aux_dir.as_str().unwrap().to_string());\n-    let llvm_args = vec!(\"--emit=bc,obj\".to_string(),\n+    let llvm_args = vec!(\"--emit=llvm-bc,obj\".to_string(),\n                          \"--crate-type=lib\".to_string());\n     link_args.extend(llvm_args.into_iter());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args,\n-                                 |a, b| ThisDirectory(output_base_name(a, b).dir_path()),\n+                                 |a, b| TargetLocation::ThisDirectory(\n+                                     output_base_name(a, b).dir_path()),\n                                  testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)\n }"}, {"sha": "3b12ffe8f11e1bf25151fe09760763ef079960ad", "filename": "src/doc/README.md", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2FREADME.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -6,12 +6,6 @@\n document converter, is required to generate docs as HTML from Rust's\n source code.\n \n-[po4a](http://po4a.alioth.debian.org/) is required for generating translated\n-docs from the master (English) docs.\n-\n-[GNU gettext](http://www.gnu.org/software/gettext/) is required for managing\n-the translation data.\n-\n ## Building\n \n To generate all the docs, just run `make docs` from the root of the repository.\n@@ -44,43 +38,3 @@ The syntax for pandoc flavored markdown can be found at:\n A nice quick reference (for non-pandoc markdown) is at:\n \n - http://kramdown.gettalong.org/quickref.html\n-\n-## Notes for translators\n-\n-Notice: The procedure described below is a work in progress. We are working on\n-translation system but the procedure contains some manual operations for now.\n-\n-To start the translation for a new language, see `po4a.conf` at first.\n-\n-To generate `.pot` and `.po` files, do something like:\n-\n-~~~~\n-po4a --copyright-holder=\"The Rust Project Developers\" \\\n-    --package-name=\"Rust\" \\\n-    --package-version=\"0.13.0\" \\\n-    -M UTF-8 -L UTF-8 \\\n-    src/doc/po4a.conf\n-~~~~\n-\n-(the version number must be changed if it is not `0.13.0` now.)\n-\n-Now you can translate documents with `.po` files, commonly used with gettext. If\n-you are not familiar with gettext-based translation, please read the online\n-manual linked from http://www.gnu.org/software/gettext/ . We use UTF-8 as the\n-file encoding of `.po` files.\n-\n-When you want to make a commit, do the command below before staging your\n-change:\n-\n-~~~~\n-for f in src/doc/po/**/*.po; do\n-    msgattrib --translated $f -o $f.strip\n-    if [ -e $f.strip ]; then\n-       mv $f.strip $f\n-    else\n-       rm $f\n-    fi\n-done\n-~~~~\n-\n-This removes untranslated entries from `.po` files to save disk space."}, {"sha": "848c56ee543dd24bd773677aab39594baecc3817", "filename": "src/doc/complement-bugreport.md", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fcomplement-bugreport.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fcomplement-bugreport.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-bugreport.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -2,7 +2,7 @@\n \n # I think I found a bug in the compiler!\n \n-If you see this message: `error: internal compiler error: unexpected failure`,\n+If you see this message: `error: internal compiler error: unexpected panic`,\n then you have definitely found a bug in the compiler. It's also possible that\n your code is not well-typed, but if you saw this message, it's still a bug in\n error reporting.\n@@ -34,10 +34,10 @@ miss out on valid bug reports.\n It generally helps our diagnosis to include your specific OS (for example: Mac OS X 10.8.3,\n Windows 7, Ubuntu 12.04) and your hardware architecture (for example: i686, x86_64).\n It's also helpful to provide the exact version and host by copying the output of\n-re-running the erroneous rustc command with the `--version=verbose` flag, which will\n+re-running the erroneous rustc command with the `--version --verbose` flags, which will\n produce something like this:\n \n-```{ignore}\n+```text\n rustc 0.12.0 (ba4081a5a 2014-10-07 13:44:41 -0700)\n binary: rustc\n commit-hash: ba4081a5a8573875fed17545846f6f6902c8ba8d\n@@ -46,8 +46,13 @@ host: i686-apple-darwin\n release: 0.12.0\n ```\n \n-Finally, if you can run the offending command under gdb, pasting a stack trace can be\n-useful; to do so, you will need to set a breakpoint on `rust_panic`.\n+Finally, if you can also provide a backtrace, that'd be great. You can get a\n+backtrace by setting the `RUST_BACKTRACE` environment variable to `1`, like\n+this: \n+\n+```bash\n+$ RUST_BACKTRACE=1 rustc ...\n+```\n \n # I submitted a bug, but nobody has commented on it!\n "}, {"sha": "9e73863239fbc06b05e807f243b7bb65d99d7cf5", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -24,7 +24,7 @@ Some examples that demonstrate different aspects of the language:\n [HashMap]: https://github.com/rust-lang/rust/blob/master/src/libcollections/hashmap.rs\n [json]: https://github.com/rust-lang/rust/blob/master/src/libserialize/json.rs\n \n-You may also be interested in browsing [GitHub's Rust][github-rust] page.\n+You may also be interested in browsing [trending Rust repositories][github-rust] on GitHub.\n \n [github-rust]: https://github.com/trending?l=rust\n \n@@ -42,7 +42,7 @@ Let the fact that this is an easily countable number be a warning.\n \n ## Does it run on Windows?\n \n-Yes. All development happens in lock-step on all 3 target platforms. Using MinGW, not Cygwin. Note that the windows implementation currently has some limitations: in particular 64-bit build is [not fully supported yet][win64], and all executables created by rustc [depend on libgcc DLL at runtime][libgcc].\n+Yes. All development happens in lockstep on all 3 target platforms (using MinGW, not Cygwin). Note that the Windows implementation currently has some limitations; in particular, the 64-bit build is [not fully supported yet][win64], and all executables created by rustc [depend on libgcc DLL at runtime][libgcc].\n \n [win64]: https://github.com/rust-lang/rust/issues/1237\n [libgcc]: https://github.com/rust-lang/rust/issues/11782\n@@ -104,11 +104,11 @@ Similar to the reasoning about default-sync: it wires fewer assumptions into the\n \n ## Why are strings UTF-8 by default? Why not UCS2 or UCS4?\n \n-The `str` type is UTF-8 because we observe more text in the wild in this encoding -- particularly in network transmissions, which are endian-agnostic -- and we think it's best that the default treatment of I/O not involve having to recode codepoints in each direction.\n+The `str` type is UTF-8 because we observe more text in the wild in this encoding \u2013 particularly in network transmissions, which are endian-agnostic \u2013 and we think it's best that the default treatment of I/O not involve having to recode codepoints in each direction.\n \n This does mean that indexed access to a Unicode codepoint inside a `str` value is an O(n) operation. On the one hand, this is clearly undesirable; on the other hand, this problem is full of trade-offs and we'd like to point a few important qualifications:\n \n-* Scanning a `str` for ASCII-range codepoints can still be done safely octet-at-a-time, with each indexing operation pulling out a `u8` costing only O(1) and producing a value that can be cast and compared to an ASCII-range `char`. So if you're (say) line-breaking on `'\\n'`, octet-based treatment still works. UTF8 was well-designed this way.\n+* Scanning a `str` for ASCII-range codepoints can still be done safely octet-at-a-time. If you use `.as_bytes()`, pulling out a `u8` costs only O(1) and produces a value that can be cast and compared to an ASCII-range `char`. So if you're (say) line-breaking on `'\\n'`, octet-based treatment still works. UTF8 was well-designed this way.\n * Most \"character oriented\" operations on text only work under very restricted language assumptions sets such as \"ASCII-range codepoints only\". Outside ASCII-range, you tend to have to use a complex (non-constant-time) algorithm for determining linguistic-unit (glyph, word, paragraph) boundaries anyways. We recommend using an \"honest\" linguistically-aware, Unicode-approved algorithm.\n * The `char` type is UCS4. If you honestly need to do a codepoint-at-a-time algorithm, it's trivial to write a `type wstr = [char]`, and unpack a `str` into it in a single pass, then work with the `wstr`. In other words: the fact that the language is not \"decoding to UCS4 by default\" shouldn't stop you from decoding (or re-encoding any other way) if you need to work with that encoding.\n \n@@ -145,23 +145,27 @@ For simplicity, we do not plan to do so. Implementing automatic semicolon insert\n \n ## How do I get my program to display the output of logging macros?\n \n-**Short answer** set the RUST_LOG environment variable to the name of your source file, sans extension.\n+**Short Answer**: Set the `RUST_LOG` environment variable to the name of your source file, sans extension.\n \n ```sh\n rustc hello.rs\n export RUST_LOG=hello\n ./hello\n ```\n \n-**Long answer** RUST_LOG takes a 'logging spec' that consists of a\n+**Long Answer**: `RUST_LOG` takes a 'logging spec' that consists of a\n comma-separated list of paths, where a path consists of the crate name and\n-sequence of module names, each separated by double-colons. For standalone .rs\n-files the crate is implicitly named after the source file, so in the above\n-example we were setting RUST_LOG to the name of the hello crate. Multiple paths\n+sequence of module names, each separated by double-colons. For standalone `.rs`\n+files, the crate is implicitly named after the source file, so in the above\n+example we were setting `RUST_LOG` to the name of the hello crate. Multiple paths\n can be combined to control the exact logging you want to see. For example, when\n-debugging linking in the compiler you might set\n-`RUST_LOG=rustc::metadata::creader,rustc::util::filesearch,rustc::back::rpath`\n-For a full description see [the logging crate][1].\n+debugging linking in the compiler, you might set the following:\n+\n+```sh\n+RUST_LOG=rustc::metadata::creader,rustc::util::filesearch,rustc::back::rpath\n+```\n+\n+For a full description, see [the logging crate][1].\n \n ## How fast is Rust?\n \n@@ -172,6 +176,6 @@ performance.\n That said, it is an explicit goal of Rust to be as fast as C++ for most things.\n Language decisions are made with performance in mind, and we want Rust to be as\n fast as possible. Given that Rust is built on top of LLVM, any performance\n-improvements in it also help us be faster.\n+improvements in it also help Rust become faster.\n \n [1]:log/index.html"}, {"sha": "ba825c2c9a8008e6ea22cda292cd213269ca0d0f", "filename": "src/doc/guide-crates.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-crates.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-crates.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-crates.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -32,7 +32,7 @@ two languages for those phrases to be in. We'll use this module layout:\n               +---------+   |   +-----------+\n               |             +---| farewells |\n +---------+   |                 +-----------+\n-| phrases |---+ \n+| phrases |---+\n +---------+   |                  +-----------+\n               |              +---| greetings |\n               +----------+   |   +-----------+\n@@ -219,7 +219,7 @@ Put this in `src/english/greetings.rs`:\n \n fn hello() -> String {\n     \"Hello!\".to_string()\n-}  \n+}\n ```\n \n Put this in `src/english/farewells.rs`:\n@@ -229,7 +229,7 @@ Put this in `src/english/farewells.rs`:\n \n fn goodbye() -> String {\n     \"Goodbye.\".to_string()\n-} \n+}\n ```\n \n Put this in `src/japanese/greetings.rs`:\n@@ -239,7 +239,7 @@ Put this in `src/japanese/greetings.rs`:\n \n fn hello() -> String {\n     \"\u3053\u3093\u306b\u3061\u306f\".to_string()\n-}  \n+}\n ```\n \n Of course, you can copy and paste this from this web page, or just type\n@@ -253,7 +253,7 @@ Put this in `src/japanese/farewells.rs`:\n \n fn goodbye() -> String {\n     \"\u3055\u3088\u3046\u306a\u3089\".to_string()\n-} \n+}\n ```\n \n (This is \"Sayoonara\", if you're curious.)\n@@ -381,11 +381,11 @@ $ cargo run\n /home/you/projects/phrases/src/japanese/greetings.rs:1:1: 3:2 warning: code is never used: `hello`, #[warn(dead_code)] on by default\n /home/you/projects/phrases/src/japanese/greetings.rs:1 fn hello() -> String {\n /home/you/projects/phrases/src/japanese/greetings.rs:2     \"\u3053\u3093\u306b\u3061\u306f\".to_string()\n-/home/you/projects/phrases/src/japanese/greetings.rs:3 } \n+/home/you/projects/phrases/src/japanese/greetings.rs:3 }\n /home/you/projects/phrases/src/japanese/farewells.rs:1:1: 3:2 warning: code is never used: `goodbye`, #[warn(dead_code)] on by default\n /home/you/projects/phrases/src/japanese/farewells.rs:1 fn goodbye() -> String {\n /home/you/projects/phrases/src/japanese/farewells.rs:2     \"\u3055\u3088\u3046\u306a\u3089\".to_string()\n-/home/you/projects/phrases/src/japanese/farewells.rs:3 } \n+/home/you/projects/phrases/src/japanese/farewells.rs:3 }\n      Running `target/phrases`\n Hello in English: Hello!\n Goodbye in English: Goodbye.\n@@ -452,7 +452,7 @@ fn main() {\n \n Rust will give us a compile-time error:\n \n-```{notrust,ignore}\n+```text\n    Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n /home/you/projects/phrases/src/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this module\n /home/you/projects/phrases/src/main.rs:4 use phrases::japanese::greetings::hello;"}, {"sha": "d833827981e277ffd2f1205bbf01b7230ebc6cfb", "filename": "src/doc/guide-error-handling.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-error-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-error-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-error-handling.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -2,7 +2,7 @@\n \n > The best-laid plans of mice and men\n > Often go awry\n-> \n+>\n > \"Tae a Moose\", Robert Burns\n \n Sometimes, things just go wrong. It's important to have a plan for when the\n@@ -76,7 +76,7 @@ fn main() {\n \n This will give us an error:\n \n-```{notrust,ignore}\n+```text\n error: non-exhaustive patterns: `_` not covered [E0004]\n ```\n \n@@ -189,7 +189,7 @@ panic!(\"boom\");\n \n gives\n \n-```{notrust,ignore}\n+```text\n task '<main>' panicked at 'boom', hello.rs:2\n ```\n "}, {"sha": "7a5c535827c251f35f58f50ee146d6b6d2075046", "filename": "src/doc/guide-lifetimes.md", "status": "removed", "additions": 0, "deletions": 565, "changes": 565, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Fdoc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Fdoc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-lifetimes.md?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e", "patch": "@@ -1,565 +0,0 @@\n-% The Rust References and Lifetimes Guide\n-\n-# Introduction\n-\n-References are one of the more flexible and powerful tools available in\n-Rust. They can point anywhere: into the heap, stack, and even into the\n-interior of another data structure. A reference is as flexible as a C pointer\n-or C++ reference.\n-\n-Unlike C and C++ compilers, the Rust compiler includes special static\n-checks that ensure that programs use references safely.\n-\n-Despite their complete safety, a reference's representation at runtime\n-is the same as that of an ordinary pointer in a C program. They introduce zero\n-overhead. The compiler does all safety checks at compile time.\n-\n-Although references have rather elaborate theoretical underpinnings\n-(e.g. region pointers), the core concepts will be familiar to anyone\n-who has worked with C or C++. The best way to explain how they are\n-used\u2014and their limitations\u2014is probably just to work through several examples.\n-\n-# By example\n-\n-References, sometimes known as *borrowed pointers*, are only valid for\n-a limited duration. References never claim any kind of ownership\n-over the data that they point to. Instead, they are used for cases\n-where you would like to use data for a short time.\n-\n-Consider a simple struct type `Point`:\n-\n-~~~\n-struct Point {x: f64, y: f64}\n-~~~\n-\n-We can use this simple definition to allocate points in many different ways. For\n-example, in this code, each of these local variables contains a point,\n-but allocated in a different place:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-let on_the_stack : Point      =     Point {x: 3.0, y: 4.0};\n-let on_the_heap  : Box<Point> = box Point {x: 7.0, y: 9.0};\n-~~~\n-\n-Suppose we wanted to write a procedure that computed the distance between any\n-two points, no matter where they were stored. One option is to define a function\n-that takes two arguments of type `Point`\u2014that is, it takes the points by value.\n-But if we define it this way, calling the function will cause the points to be\n-copied. For points, this is probably not so bad, but often copies are\n-expensive. So we'd like to define a function that takes the points just as\n-a reference.\n-\n-~~~\n-# use std::num::Float;\n-# struct Point {x: f64, y: f64}\n-# fn sqrt(f: f64) -> f64 { 0.0 }\n-fn compute_distance(p1: &Point, p2: &Point) -> f64 {\n-    let x_d = p1.x - p2.x;\n-    let y_d = p1.y - p2.y;\n-    (x_d * x_d + y_d * y_d).sqrt()\n-}\n-~~~\n-\n-Now we can call `compute_distance()`:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-# let on_the_stack :     Point  =     Point{x: 3.0, y: 4.0};\n-# let on_the_heap  : Box<Point> = box Point{x: 7.0, y: 9.0};\n-# fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n-compute_distance(&on_the_stack, &*on_the_heap);\n-~~~\n-\n-Here, the `&` operator takes the address of the variable\n-`on_the_stack`; this is because `on_the_stack` has the type `Point`\n-(that is, a struct value) and we have to take its address to get a\n-value. We also call this _borrowing_ the local variable\n-`on_the_stack`, because we have created an alias: that is, another\n-name for the same data.\n-\n-Likewise, in the case of `on_the_heap`,\n-the `&` operator is used in conjunction with the `*` operator\n-to take a reference to the contents of the box.\n-\n-Whenever a caller lends data to a callee, there are some limitations on what\n-the caller can do with the original. For example, if the contents of a\n-variable have been lent out, you cannot send that variable to another task. In\n-addition, the compiler will reject any code that might cause the borrowed\n-value to be freed or overwrite its component fields with values of different\n-types (I'll get into what kinds of actions those are shortly). This rule\n-should make intuitive sense: you must wait for a borrower to return the value\n-that you lent it (that is, wait for the reference to go out of scope)\n-before you can make full use of it again.\n-\n-# Other uses for the & operator\n-\n-In the previous example, the value `on_the_stack` was defined like so:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-let on_the_stack: Point = Point {x: 3.0, y: 4.0};\n-~~~\n-\n-This declaration means that code can only pass `Point` by value to other\n-functions. As a consequence, we had to explicitly take the address of\n-`on_the_stack` to get a reference. Sometimes however it is more\n-convenient to move the & operator into the definition of `on_the_stack`:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-let on_the_stack2: &Point = &Point {x: 3.0, y: 4.0};\n-~~~\n-\n-Applying `&` to an rvalue (non-assignable location) is just a convenient\n-shorthand for creating a temporary and taking its address. A more verbose\n-way to write the same code is:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-let tmp = Point {x: 3.0, y: 4.0};\n-let on_the_stack2 : &Point = &tmp;\n-~~~\n-\n-# Taking the address of fields\n-\n-The `&` operator is not limited to taking the address of\n-local variables. It can also take the address of fields or\n-individual array elements. For example, consider this type definition\n-for `Rectangle`:\n-\n-~~~\n-struct Point {x: f64, y: f64} // as before\n-struct Size {w: f64, h: f64} // as before\n-struct Rectangle {origin: Point, size: Size}\n-~~~\n-\n-Now, as before, we can define rectangles in a few different ways:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-# struct Size {w: f64, h: f64} // as before\n-# struct Rectangle {origin: Point, size: Size}\n-let rect_stack   =    &Rectangle {origin: Point {x: 1.0, y: 2.0},\n-                                  size: Size {w: 3.0, h: 4.0}};\n-let rect_heap    = box Rectangle {origin: Point {x: 5.0, y: 6.0},\n-                                  size: Size {w: 3.0, h: 4.0}};\n-~~~\n-\n-In each case, we can extract out individual subcomponents with the `&`\n-operator. For example, I could write:\n-\n-~~~\n-# struct Point {x: f64, y: f64} // as before\n-# struct Size {w: f64, h: f64} // as before\n-# struct Rectangle {origin: Point, size: Size}\n-# let rect_stack  = &Rectangle {origin: Point {x: 1.0, y: 2.0}, size: Size {w: 3.0, h: 4.0}};\n-# let rect_heap   = box Rectangle {origin: Point {x: 5.0, y: 6.0}, size: Size {w: 3.0, h: 4.0}};\n-# fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n-compute_distance(&rect_stack.origin, &rect_heap.origin);\n-~~~\n-\n-which would borrow the field `origin` from the rectangle on the stack\n-as well as from the owned box, and then compute the distance between them.\n-\n-# Lifetimes\n-\n-We\u2019ve seen a few examples of borrowing data. To this point, we\u2019ve glossed\n-over issues of safety. As stated in the introduction, at runtime a reference\n-is simply a pointer, nothing more. Therefore, avoiding C's problems with\n-dangling pointers requires a compile-time safety check.\n-\n-The basis for the check is the notion of _lifetimes_. A lifetime is a\n-static approximation of the span of execution during which the pointer\n-is valid: it always corresponds to some expression or block within the\n-program.\n-\n-The compiler will only allow a borrow *if it can guarantee that the data will\n-not be reassigned or moved for the lifetime of the pointer*. This does not\n-necessarily mean that the data is stored in immutable memory. For example,\n-the following function is legal:\n-\n-~~~\n-# fn some_condition() -> bool { true }\n-# struct Foo { f: int }\n-fn example3() -> int {\n-    let mut x = box Foo {f: 3};\n-    if some_condition() {\n-        let y = &x.f;      // -+ L\n-        return *y;         //  |\n-    }                      // -+\n-    x = box Foo {f: 4};\n-    // ...\n-# return 0;\n-}\n-~~~\n-\n-Here, the interior of the variable `x` is being borrowed\n-and `x` is declared as mutable. However, the compiler can prove that\n-`x` is not assigned anywhere in the lifetime L of the variable\n-`y`. Therefore, it accepts the function, even though `x` is mutable\n-and in fact is mutated later in the function.\n-\n-It may not be clear why we are so concerned about mutating a borrowed\n-variable. The reason is that the runtime system frees any box\n-_as soon as its owning reference changes or goes out of\n-scope_. Therefore, a program like this is illegal (and would be\n-rejected by the compiler):\n-\n-~~~ {.ignore}\n-fn example3() -> int {\n-    let mut x = box X {f: 3};\n-    let y = &x.f;\n-    x = box X {f: 4};  // Error reported here.\n-    *y\n-}\n-~~~\n-\n-To make this clearer, consider this diagram showing the state of\n-memory immediately before the re-assignment of `x`:\n-\n-~~~ {.text}\n-    Stack               Exchange Heap\n-\n-  x +-------------+\n-    | box {f:int} | ----+\n-  y +-------------+     |\n-    | &int        | ----+\n-    +-------------+     |    +---------+\n-                        +--> |  f: 3   |\n-                             +---------+\n-~~~\n-\n-Once the reassignment occurs, the memory will look like this:\n-\n-~~~ {.text}\n-    Stack               Exchange Heap\n-\n-  x +-------------+          +---------+\n-    | box {f:int} | -------> |  f: 4   |\n-  y +-------------+          +---------+\n-    | &int        | ----+\n-    +-------------+     |    +---------+\n-                        +--> | (freed) |\n-                             +---------+\n-~~~\n-\n-Here you can see that the variable `y` still points at the old `f`\n-property of Foo, which has been freed.\n-\n-In fact, the compiler can apply the same kind of reasoning to any\n-memory that is (uniquely) owned by the stack frame. So we could\n-modify the previous example to introduce additional owned pointers\n-and structs, and the compiler will still be able to detect possible\n-mutations. This time, we'll use an analogy to illustrate the concept.\n-\n-~~~ {.ignore}\n-fn example3() -> int {\n-    struct House { owner: Box<Person> }\n-    struct Person { age: int }\n-\n-    let mut house = box House {\n-        owner: box Person {age: 30}\n-    };\n-\n-    let owner_age = &house.owner.age;\n-    house = box House {owner: box Person {age: 40}};  // Error reported here.\n-    house.owner = box Person {age: 50};               // Error reported here.\n-    *owner_age\n-}\n-~~~\n-\n-In this case, two errors are reported, one when the variable `house` is\n-modified and another when `house.owner` is modified. Either modification would\n-invalidate the pointer `owner_age`.\n-\n-# Borrowing and enums\n-\n-The previous example showed that the type system forbids any mutations\n-of owned boxed values while they are being borrowed. In general, the type\n-system also forbids borrowing a value as mutable if it is already being\n-borrowed - either as a mutable reference or an immutable one. This restriction\n-prevents pointers from pointing into freed memory. There is one other\n-case where the compiler must be very careful to ensure that pointers\n-remain valid: pointers into the interior of an `enum`.\n-\n-Let\u2019s look at the following `shape` type that can represent both rectangles\n-and circles:\n-\n-~~~\n-struct Point {x: f64, y: f64}; // as before\n-struct Size {w: f64, h: f64}; // as before\n-enum Shape {\n-    Circle(Point, f64),   // origin, radius\n-    Rectangle(Point, Size)  // upper-left, dimensions\n-}\n-~~~\n-\n-Now we might write a function to compute the area of a shape. This\n-function takes a reference to a shape, to avoid the need for\n-copying.\n-\n-~~~\n-# struct Point {x: f64, y: f64}; // as before\n-# struct Size {w: f64, h: f64}; // as before\n-# enum Shape {\n-#     Circle(Point, f64),   // origin, radius\n-#     Rectangle(Point, Size)  // upper-left, dimensions\n-# }\n-fn compute_area(shape: &Shape) -> f64 {\n-    match *shape {\n-        Shape::Circle(_, radius) => std::f64::consts::PI * radius * radius,\n-        Shape::Rectangle(_, ref size) => size.w * size.h\n-    }\n-}\n-~~~\n-\n-The first case matches against circles. Here, the pattern extracts the\n-radius from the shape variant and the action uses it to compute the\n-area of the circle.\n-\n-The second match is more interesting. Here we match against a\n-rectangle and extract its size: but rather than copy the `size`\n-struct, we use a by-reference binding to create a pointer to it. In\n-other words, a pattern binding like `ref size` binds the name `size`\n-to a pointer of type `&size` into the _interior of the enum_.\n-\n-To make this more clear, let's look at a diagram of memory layout in\n-the case where `shape` points at a rectangle:\n-\n-~~~ {.text}\n-Stack             Memory\n-\n-+-------+         +---------------+\n-| shape | ------> | rectangle(    |\n-+-------+         |   {x: f64,    |\n-| size  | -+      |    y: f64},   |\n-+-------+  +----> |   {w: f64,    |\n-                  |    h: f64})   |\n-                  +---------------+\n-~~~\n-\n-Here you can see that rectangular shapes are composed of five words of\n-memory. The first is a tag indicating which variant this enum is\n-(`rectangle`, in this case). The next two words are the `x` and `y`\n-fields for the point and the remaining two are the `w` and `h` fields\n-for the size. The binding `size` is then a pointer into the inside of\n-the shape.\n-\n-Perhaps you can see where the danger lies: if the shape were somehow\n-to be reassigned, perhaps to a circle, then although the memory used\n-to store that shape value would still be valid, _it would have a\n-different type_! The following diagram shows what memory would look\n-like if code overwrote `shape` with a circle:\n-\n-~~~ {.text}\n-Stack             Memory\n-\n-+-------+         +---------------+\n-| shape | ------> | circle(       |\n-+-------+         |   {x: f64,    |\n-| size  | -+      |    y: f64},   |\n-+-------+  +----> |   f64)        |\n-                  |               |\n-                  +---------------+\n-~~~\n-\n-As you can see, the `size` pointer would be pointing at a `f64`\n-instead of a struct. This is not good: dereferencing the second field\n-of a `f64` as if it were a struct with two fields would be a memory\n-safety violation.\n-\n-So, in fact, for every `ref` binding, the compiler will impose the\n-same rules as the ones we saw for borrowing the interior of an owned\n-box: it must be able to guarantee that the `enum` will not be\n-overwritten for the duration of the borrow.  In fact, the compiler\n-would accept the example we gave earlier. The example is safe because\n-the shape pointer has type `&Shape`, which means \"reference to\n-immutable memory containing a `shape`\". If, however, the type of that\n-pointer were `&mut Shape`, then the ref binding would be ill-typed.\n-Just as with owned boxes, the compiler will permit `ref` bindings\n-into data owned by the stack frame even if the data are mutable,\n-but otherwise it requires that the data reside in immutable memory.\n-\n-# Returning references\n-\n-So far, all of the examples we have looked at, use references in a\n-\u201cdownward\u201d direction. That is, a method or code block creates a\n-reference, then uses it within the same scope. It is also\n-possible to return references as the result of a function, but\n-as we'll see, doing so requires some explicit annotation.\n-\n-We could write a subroutine like this:\n-\n-~~~\n-struct Point {x: f64, y: f64}\n-fn get_x<'r>(p: &'r Point) -> &'r f64 { &p.x }\n-~~~\n-\n-Here, the function `get_x()` returns a pointer into the structure it\n-was given. The type of the parameter (`&'r Point`) and return type\n-(`&'r f64`) both use a new syntactic form that we have not seen so\n-far.  Here the identifier `r` names the lifetime of the pointer\n-explicitly. So in effect, this function declares that it takes a\n-pointer with lifetime `r` and returns a pointer with that same\n-lifetime.\n-\n-In general, it is only possible to return references if they\n-are derived from a parameter to the procedure. In that case, the\n-pointer result will always have the same lifetime as one of the\n-parameters; named lifetimes indicate which parameter that\n-is.\n-\n-In the previous code samples, function parameter types did not include a\n-lifetime name. The compiler simply creates a fresh name for the lifetime\n-automatically: that is, the lifetime name is guaranteed to refer to a distinct\n-lifetime from the lifetimes of all other parameters.\n-\n-Named lifetimes that appear in function signatures are conceptually\n-the same as the other lifetimes we have seen before, but they are a bit\n-abstract: they don\u2019t refer to a specific expression within `get_x()`,\n-but rather to some expression within the *caller of `get_x()`*.  The\n-lifetime `r` is actually a kind of *lifetime parameter*: it is defined\n-by the caller to `get_x()`, just as the value for the parameter `p` is\n-defined by that caller.\n-\n-In any case, whatever the lifetime of `r` is, the pointer produced by\n-`&p.x` always has the same lifetime as `p` itself: a pointer to a\n-field of a struct is valid as long as the struct is valid. Therefore,\n-the compiler accepts the function `get_x()`.\n-\n-In general, if you borrow a struct or box to create a\n-reference, it will only be valid within the function\n-and cannot be returned. This is why the typical way to return references\n-is to take references as input (the only other case in\n-which it can be legal to return a reference is if it\n-points at a static constant).\n-\n-# Named lifetimes\n-\n-Lifetimes can be named and referenced. For example, the special lifetime\n-`'static`, which does not go out of scope, can be used to create global\n-variables and communicate between tasks (see the manual for use cases).\n-\n-## Parameter Lifetimes\n-\n-Named lifetimes allow for grouping of parameters by lifetime.\n-For example, consider this function:\n-\n-~~~\n-# struct Point {x: f64, y: f64}; // as before\n-# struct Size {w: f64, h: f64}; // as before\n-# enum Shape {\n-#     Circle(Point, f64),   // origin, radius\n-#     Rectangle(Point, Size)  // upper-left, dimensions\n-# }\n-# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n-fn select<'r, T>(shape: &'r Shape, threshold: f64,\n-                 a: &'r T, b: &'r T) -> &'r T {\n-    if compute_area(shape) > threshold {a} else {b}\n-}\n-~~~\n-\n-This function takes three references and assigns each the same\n-lifetime `r`.  In practice, this means that, in the caller, the\n-lifetime `r` will be the *intersection of the lifetime of the three\n-region parameters*. This may be overly conservative, as in this\n-example:\n-\n-~~~\n-# struct Point {x: f64, y: f64}; // as before\n-# struct Size {w: f64, h: f64}; // as before\n-# enum Shape {\n-#     Circle(Point, f64),   // origin, radius\n-#     Rectangle(Point, Size)  // upper-left, dimensions\n-# }\n-# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n-# fn select<'r, T>(shape: &Shape, threshold: f64,\n-#                  a: &'r T, b: &'r T) -> &'r T {\n-#     if compute_area(shape) > threshold {a} else {b}\n-# }\n-                                                            // -+ r\n-fn select_based_on_unit_circle<'r, T>(                      //  |-+ B\n-    threshold: f64, a: &'r T, b: &'r T) -> &'r T {          //  | |\n-                                                            //  | |\n-    let shape = Shape::Circle(Point {x: 0., y: 0.}, 1.);    //  | |\n-    select(&shape, threshold, a, b)                         //  | |\n-}                                                           //  |-+\n-                                                            // -+\n-~~~\n-\n-In this call to `select()`, the lifetime of the first parameter shape\n-is B, the function body. Both of the second two parameters `a` and `b`\n-share the same lifetime, `r`, which is a lifetime parameter of\n-`select_based_on_unit_circle()`. The caller will infer the\n-intersection of these two lifetimes as the lifetime of the returned\n-value, and hence the return value of `select()` will be assigned a\n-lifetime of B. This will in turn lead to a compilation error, because\n-`select_based_on_unit_circle()` is supposed to return a value with the\n-lifetime `r`.\n-\n-To address this, we can modify the definition of `select()` to\n-distinguish the lifetime of the first parameter from the lifetime of\n-the latter two. After all, the first parameter is not being\n-returned. Here is how the new `select()` might look:\n-\n-~~~\n-# struct Point {x: f64, y: f64}; // as before\n-# struct Size {w: f64, h: f64}; // as before\n-# enum Shape {\n-#     Circle(Point, f64),   // origin, radius\n-#     Rectangle(Point, Size)  // upper-left, dimensions\n-# }\n-# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n-fn select<'r, 'tmp, T>(shape: &'tmp Shape, threshold: f64,\n-                       a: &'r T, b: &'r T) -> &'r T {\n-    if compute_area(shape) > threshold {a} else {b}\n-}\n-~~~\n-\n-Here you can see that `shape`'s lifetime is now named `tmp`. The\n-parameters `a`, `b`, and the return value all have the lifetime `r`.\n-However, since the lifetime `tmp` is not returned, it would be more\n-concise to just omit the named lifetime for `shape` altogether:\n-\n-~~~\n-# struct Point {x: f64, y: f64}; // as before\n-# struct Size {w: f64, h: f64}; // as before\n-# enum Shape {\n-#     Circle(Point, f64),   // origin, radius\n-#     Rectangle(Point, Size)  // upper-left, dimensions\n-# }\n-# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n-fn select<'r, T>(shape: &Shape, threshold: f64,\n-                 a: &'r T, b: &'r T) -> &'r T {\n-    if compute_area(shape) > threshold {a} else {b}\n-}\n-~~~\n-\n-This is equivalent to the previous definition.\n-\n-## Labeled Control Structures\n-\n-Named lifetime notation can also be used to control the flow of execution:\n-\n-~~~\n-'h: for i in range(0u, 10) {\n-    'g: loop {\n-        if i % 2 == 0 { continue 'h; }\n-        if i == 9 { break 'h; }\n-        break 'g;\n-    }\n-}\n-~~~\n-\n-> *Note:* Labelled breaks are not currently supported within `while` loops.\n-\n-Named labels are hygienic and can be used safely within macros.\n-See the macros guide section on hygiene for more details.\n-\n-# Conclusion\n-\n-So there you have it: a (relatively) brief tour of the lifetime\n-system. For more details, we refer to the (yet to be written) reference\n-document on references, which will explain the full notation\n-and give more examples."}, {"sha": "58af591740709de8d5174a4ad8e55e2f234d2fea", "filename": "src/doc/guide-macros.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-macros.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -58,7 +58,7 @@ macro_rules! early_return(\n             _ => {}\n         }\n     );\n-)\n+);\n // ...\n early_return!(input_1 T::SpecialA);\n // ...\n@@ -179,8 +179,8 @@ macro_rules! early_return(\n             )+\n             _ => {}\n         }\n-    );\n-)\n+    )\n+);\n // ...\n early_return!(input_1, [T::SpecialA|T::SpecialC|T::SpecialD]);\n // ...\n@@ -195,7 +195,7 @@ early_return!(input_2, [T::SpecialB]);\n As the above example demonstrates, `$(...)*` is also valid on the right-hand\n side of a macro definition. The behavior of `*` in transcription,\n especially in cases where multiple `*`s are nested, and multiple different\n-names are involved, can seem somewhat magical and intuitive at first. The\n+names are involved, can seem somewhat magical and unintuitive at first. The\n system that interprets them is called \"Macro By Example\". The two rules to\n keep in mind are (1) the behavior of `$(...)*` is to walk through one \"layer\"\n of repetitions for all of the `$name`s it contains in lockstep, and (2) each\n@@ -275,17 +275,17 @@ macro_rules! biased_match (\n             _ => { $err }\n         };\n     )\n-)\n+);\n \n # enum T1 { Good1(T2, uint), Bad1}\n # struct T2 { body: T3 }\n # enum T3 { Good2(uint), Bad2}\n # fn f(x: T1) -> uint {\n biased_match!((x)       ~ (T1::Good1(g1, val)) else { return 0 };\n-              binds g1, val )\n+              binds g1, val );\n biased_match!((g1.body) ~ (T3::Good2(result) )\n                   else { panic!(\"Didn't get good_2\") };\n-              binds result )\n+              binds result );\n // complicated stuff goes here\n return result + val;\n # }\n@@ -303,7 +303,7 @@ pattern we want is clear:\n     ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n       binds $( $bind_res:ident ),*\n     )\n-# => (0))\n+# => (0));\n ~~~~\n \n However, it's not possible to directly expand to nested match statements. But\n@@ -323,7 +323,7 @@ input patterns:\n # #![feature(macro_rules)]\n # macro_rules! b(\n     ( binds $( $bind_res:ident ),* )\n-# => (0))\n+# => (0));\n # fn main() {}\n ~~~~\n \n@@ -337,7 +337,7 @@ input patterns:\n       $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n       binds  $( $bind_res:ident ),*\n     )\n-# => (0))\n+# => (0));\n ~~~~\n \n The resulting macro looks like this. Note that the separation into\n@@ -366,7 +366,7 @@ macro_rules! biased_match_rec (\n     );\n     // Produce the requested values\n     ( binds $( $bind_res:ident ),* ) => ( ($( $bind_res ),*) )\n-)\n+);\n \n // Wrap the whole thing in a `let`.\n macro_rules! biased_match (\n@@ -388,7 +388,7 @@ macro_rules! biased_match (\n             binds $( $bind_res ),*\n         );\n     )\n-)\n+);\n \n \n # enum T1 { Good1(T2, uint), Bad1}\n@@ -398,7 +398,7 @@ macro_rules! biased_match (\n biased_match!(\n     (x)       ~ (T1::Good1(g1, val)) else { return 0 };\n     (g1.body) ~ (T3::Good2(result) ) else { panic!(\"Didn't get Good2\") };\n-    binds val, result )\n+    binds val, result );\n // complicated stuff goes here\n return result + val;\n # }\n@@ -444,7 +444,7 @@ macro_rules! loop_x (\n             $e\n         }\n     );\n-)\n+);\n \n fn main() {\n     'x: loop {\n@@ -482,30 +482,30 @@ An example:\n \n ```rust\n # #![feature(macro_rules)]\n-macro_rules! m1 (() => (()))\n+macro_rules! m1 (() => (()));\n \n // visible here: m1\n \n mod foo {\n     // visible here: m1\n \n     #[macro_export]\n-    macro_rules! m2 (() => (()))\n+    macro_rules! m2 (() => (()));\n \n     // visible here: m1, m2\n }\n \n // visible here: m1\n \n-macro_rules! m3 (() => (()))\n+macro_rules! m3 (() => (()));\n \n // visible here: m1, m3\n \n #[macro_escape]\n mod bar {\n     // visible here: m1, m3\n \n-    macro_rules! m4 (() => (()))\n+    macro_rules! m4 (() => (()));\n \n     // visible here: m1, m3, m4\n }"}, {"sha": "bf750ecaa8f673acd63f36e7822feb6c0c33465f", "filename": "src/doc/guide-ownership.md", "status": "added", "additions": 454, "deletions": 0, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-ownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-ownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ownership.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -0,0 +1,454 @@\n+% The Rust Ownership Guide\n+\n+This guide presents Rust's ownership system. This is one of Rust's most unique\n+and compelling features, with which Rust developers should become quite\n+acquainted. Ownership is how Rust achieves its largest goal, memory safety.\n+The ownership system has a few distinct concepts: **ownership**, **borrowing**,\n+and **lifetimes**. We'll talk about each one in turn.\n+\n+# Meta\n+\n+Before we get to the details, two important notes about the ownership system.\n+\n+Rust has a focus on safety and speed. It accomplishes these goals through many\n+\"zero cost abstractions,\" which means that in Rust, abstractions cost as little\n+as possible in order to make them work. The ownership system is a prime example\n+of a zero cost abstraction. All of the analysis we'll talk about in this guide\n+is _done at compile time_. You do not pay any run-time cost for any of these\n+features.\n+\n+However, this system does have a certain cost: learning curve. Many new users\n+to Rust experience something we like to call \"fighting with the borrow\n+checker,\" where the Rust compiler refuses to compile a program that the author\n+thinks is valid. This often happens because the programmer's mental model of\n+how ownership should work doesn't match the actual rules that Rust implements.\n+You probably will experience similar things at first. There is good news,\n+however: more experienced Rust developers report that once they work with the\n+rules of the ownership system for a period of time, they fight the borrow\n+checker less and less.\n+\n+With that in mind, let's learn about ownership.\n+\n+# Ownership\n+\n+At its core, ownership is about 'resources.' For the purposes of the vast\n+majority of this guide, we will talk about a specific resource: memory. The\n+concept generalizes to any kind of resource, like a file handle, but to make it\n+more concrete, we'll focus on memory.\n+\n+When your program allocates some memory, it needs some way to deallocate that\n+memory. Imagine a function `foo` that allocates four bytes of memory, and then\n+never deallocates that memory. We call this problem 'leaking' memory, because\n+each time we call `foo`, we're allocating another four bytes. Eventually, with\n+enough calls to `foo`, we will run our system out of memory. That's no good. So\n+we need some way for `foo` to deallocate those four bytes. It's also important\n+that we don't deallocate too many times, either. Without getting into the\n+details, attempting to deallocate memory multiple times can lead to problems.\n+In other words, any time some memory is allocated, we need to make sure that we\n+deallocate that memory once and only once. Too many times is bad, not enough\n+times is bad. The counts must match.\n+\n+There's one other important detail with regards to allocating memory. Whenever\n+we request some amount of memory, what we are given is a handle to that memory.\n+This handle (often called a 'pointer', when we're referring to memory) is how\n+we interact with the allocated memory. As long as we have that handle, we can\n+do something with the memory. Once we're done with the handle, we're also done\n+with the memory, as we can't do anything useful without a handle to it.\n+\n+Historically, systems programming languages require you to track these\n+allocations, deallocations, and handles yourself. For example, if we want some\n+memory from the heap in a language like C, we do this:\n+\n+```c\n+{\n+    int *x = malloc(sizeof(int));\n+\n+    // we can now do stuff with our handle x\n+    *x = 5;\n+\n+    free(x);\n+}\n+```\n+\n+The call to `malloc` allocates some memory. The call to `free` deallocates the\n+memory. There's also bookkeeping about allocating the correct amount of memory.\n+\n+Rust combines these two aspects of allocating memory (and other resources) into\n+a concept called 'ownership.' Whenever we request some memory, that handle we\n+receive is called the 'owning handle.' Whenever that handle goes out of scope,\n+Rust knows that you cannot do anything with the memory anymore, and so\n+therefore deallocates the memory for you. Here's the equivalent example in\n+Rust:\n+\n+```rust\n+{\n+    let x = box 5i;\n+}\n+```\n+\n+The `box` keyword creates a `Box<T>` (specifically `Box<int>` in this case) by\n+allocating a small segment of memory on the heap with enough space to fit an\n+`int`. But where in the code is the box deallocated? We said before that we\n+must have a deallocation for each allocation. Rust handles this for you. It\n+knows that our handle, `x`, is the owning reference to our box. Rust knows that\n+`x` will go out of scope at the end of the block, and so it inserts a call to\n+deallocate the memory at the end of the scope. Because the compiler does this\n+for us, it's impossible to forget. We always have exactly one deallocation paired\n+with each of our allocations.\n+\n+This is pretty straightforward, but what happens when we want to pass our box\n+to a function? Let's look at some code:\n+\n+```rust\n+fn main() {\n+    let x = box 5i;\n+\n+    add_one(x);\n+}\n+\n+fn add_one(mut num: Box<int>) {\n+    *num += 1;\n+}\n+```\n+\n+This code works, but it's not ideal. For example, let's add one more line of\n+code, where we print out the value of `x`:\n+\n+```{rust,ignore}\n+fn main() {\n+    let x = box 5i;\n+\n+    add_one(x);\n+\n+    println!(\"{}\", x);\n+}\n+\n+fn add_one(mut num: Box<int>) {\n+    *num += 1;\n+}\n+```\n+\n+This does not compile, and gives us an error:\n+\n+```text\n+error: use of moved value: `x`\n+   println!(\"{}\", x);\n+                  ^\n+```\n+\n+Remember, we need one deallocation for every allocation. When we try to pass\n+our box to `add_one`, we would have two handles to the memory: `x` in `main`,\n+and `num` in `add_one`. If we deallocated the memory when each handle went out\n+of scope, we would have two deallocations and one allocation, and that's wrong.\n+So when we call `add_one`, Rust defines `num` as the owner of the handle. And\n+so, now that we've given ownership to `num`, `x` is invalid. `x`'s value has\n+\"moved\" from `x` to `num`. Hence the error: use of moved value `x`.\n+\n+To fix this, we can have `add_one` give ownership back when it's done with the\n+box:\n+\n+```rust\n+fn main() {\n+    let x = box 5i;\n+\n+    let y = add_one(x);\n+\n+    println!(\"{}\", y);\n+}\n+\n+fn add_one(mut num: Box<int>) -> Box<int> {\n+    *num += 1;\n+\n+    num\n+}\n+```\n+\n+This code will compile and run just fine. Now, we return a `box`, and so the\n+ownership is transferred back to `y` in `main`. We only have ownership for the\n+duration of our function before giving it back. This pattern is very common,\n+and so Rust introduces a concept to describe a handle which temporarily refers\n+to something another handle owns. It's called \"borrowing,\" and it's done with\n+\"references\", designated by the `&` symbol.\n+\n+# Borrowing\n+\n+Here's the current state of our `add_one` function:\n+\n+```rust\n+fn add_one(mut num: Box<int>) -> Box<int> {\n+    *num += 1;\n+\n+    num\n+}\n+```\n+\n+This function takes ownership, because it takes a `Box`, which owns its\n+contents. But then we give ownership right back.\n+\n+In the physical world, you can give one of your possessions to someone for a\n+short period of time. You still own your possession, you're just letting someone\n+else use it for a while. We call that 'lending' something to someone, and that\n+person is said to be 'borrowing' that something from you.\n+\n+Rust's ownership system also allows an owner to lend out a handle for a limited\n+period. This is also called 'borrowing.' Here's a version of `add_one` which\n+borrows its argument rather than taking ownership:\n+\n+```rust\n+fn add_one(num: &mut int) {\n+    *num += 1;\n+}\n+```\n+\n+This function borrows an `int` from its caller, and then increments it. When\n+the function is over, and `num` goes out of scope, the borrow is over.\n+\n+# Lifetimes\n+\n+Lending out a reference to a resource that someone else owns can be\n+complicated, however. For example, imagine this set of operations:\n+\n+1. I acquire a handle to some kind of resource.\n+2. I lend you a reference to the resource.\n+3. I decide I'm done with the resource, and deallocate it, while you still have\n+   your reference.\n+4. You decide to use the resource.\n+\n+Uh oh! Your reference is pointing to an invalid resource. This is called a\n+\"dangling pointer\" or \"use after free,\" when the resource is memory.\n+\n+To fix this, we have to make sure that step four never happens after step\n+three. The ownership system in Rust does this through a concept called\n+\"lifetimes,\" which describe the scope that a reference is valid for.\n+\n+Let's look at that function which borrows an `int` again:\n+\n+```rust\n+fn add_one(num: &int) -> int {\n+    *num + 1\n+}\n+```\n+\n+Rust has a feature called 'lifetime elision,' which allows you to not write\n+lifetime annotations in certain circumstances. This is one of them. Without\n+eliding the lifetimes, `add_one` looks like this:\n+\n+```rust\n+fn add_one<'a>(num: &'a int) -> int {\n+    *num + 1\n+}\n+```\n+\n+The `'a` is called a **lifetime**. Most lifetimes are used in places where\n+short names like `'a`, `'b` and `'c` are clearest, but it's often useful to\n+have more descriptive names. Let's dig into the syntax in a bit more detail:\n+\n+```{rust,ignore}\n+fn add_one<'a>(...)\n+```\n+\n+This part _declares_ our lifetimes. This says that `add_one` has one lifetime,\n+`'a`. If we had two, it would look like this:\n+\n+```{rust,ignore}\n+fn add_two<'a, 'b>(...)\n+```\n+\n+Then in our parameter list, we use the lifetimes we've named:\n+\n+```{rust,ignore}\n+...(num: &'a int) -> ...\n+```\n+\n+If you compare `&int` to `&'a int`, they're the same, it's just that the\n+lifetime `'a` has snuck in between the `&` and the `int`. We read `&int` as \"a\n+reference to an int\" and `&'a int` as \"a reference to an int with the lifetime 'a.'\"\n+\n+Why do lifetimes matter? Well, for example, here's some code:\n+\n+```rust\n+struct Foo<'a> {\n+    x: &'a int,\n+}\n+\n+fn main() {\n+    let y = &5i; // this is the same as `let _y = 5; let y = &_y;\n+    let f = Foo { x: y };\n+\n+    println!(\"{}\", f.x);\n+}\n+```\n+\n+As you can see, `struct`s can also have lifetimes. In a similar way to functions,\n+\n+```{rust}\n+struct Foo<'a> {\n+# x: &'a int,\n+# }\n+```\n+\n+declares a lifetime, and\n+\n+```rust\n+# struct Foo<'a> {\n+x: &'a int,\n+# }\n+```\n+\n+uses it. So why do we need a lifetime here? We need to ensure that any reference\n+to a `Foo` cannot outlive the reference to an `int` it contains.\n+\n+## Thinking in scopes\n+\n+A way to think about lifetimes is to visualize the scope that a reference is\n+valid for. For example:\n+\n+```rust\n+fn main() {\n+    let y = &5i;    // -+ y goes into scope\n+                    //  |\n+    // stuff        //  |\n+                    //  |\n+}                   // -+ y goes out of scope\n+```\n+\n+Adding in our `Foo`:\n+\n+```rust\n+struct Foo<'a> {\n+    x: &'a int,\n+}\n+\n+fn main() {\n+    let y = &5i;          // -+ y goes into scope\n+    let f = Foo { x: y }; // -+ f goes into scope\n+    // stuff              //  |\n+                          //  |\n+}                         // -+ f and y go out of scope\n+```\n+\n+Our `f` lives within the scope of `y`, so everything works. What if it didn't?\n+This code won't work:\n+\n+```{rust,ignore}\n+struct Foo<'a> {\n+    x: &'a int,\n+}\n+\n+fn main() {\n+    let x;                    // -+ x goes into scope\n+                              //  |\n+    {                         //  |\n+        let y = &5i;          // ---+ y goes into scope\n+        let f = Foo { x: y }; // ---+ f goes into scope\n+        x = &f.x;             //  | | error here\n+    }                         // ---+ f and y go out of scope\n+                              //  |\n+    println!(\"{}\", x);        //  |\n+}                             // -+ x goes out of scope\n+```\n+\n+Whew! As you can see here, the scopes of `f` and `y` are smaller than the scope\n+of `x`. But when we do `x = &f.x`, we make `x` a reference to something that's\n+about to go out of scope.\n+\n+Named lifetimes are a way of giving these scopes a name. Giving something a\n+name is the first step towards being able to talk about it.\n+\n+## 'static\n+\n+The lifetime named 'static' is a special lifetime. It signals that something\n+has the lifetime of the entire program. Most Rust programmers first come across\n+`'static` when dealing with strings:\n+\n+```rust\n+let x: &'static str = \"Hello, world.\";\n+```\n+\n+String literals have the type `&'static str` because the reference is always\n+alive: they are baked into the data segment of the final binary. Another\n+example are globals:\n+\n+```rust\n+static FOO: int = 5i;\n+let x: &'static int = &FOO;\n+```\n+\n+This adds an `int` to the data segment of the binary, and FOO is a reference to\n+it.\n+\n+# Shared Ownership\n+\n+In all the examples we've considered so far, we've assumed that each handle has\n+a singular owner. But sometimes, this doesn't work. Consider a car. Cars have\n+four wheels. We would want a wheel to know which car it was attached to. But\n+this won't work:\n+\n+```{rust,ignore}\n+struct Car {\n+    name: String,\n+}\n+\n+struct Wheel {\n+    size: int,\n+    owner: Car,\n+}\n+\n+fn main() {\n+    let car = Car { name: \"DeLorean\".to_string() };\n+\n+    for _ in range(0u, 4) {\n+        Wheel { size: 360, owner: car };\n+    }\n+}\n+```\n+\n+We try to make four `Wheel`s, each with a `Car` that it's attached to. But the\n+compiler knows that on the second iteration of the loop, there's a problem:\n+\n+```text\n+error: use of moved value: `car`\n+    Wheel { size: 360, owner: car };\n+                              ^~~\n+note: `car` moved here because it has type `Car`, which is non-copyable\n+    Wheel { size: 360, owner: car };\n+                              ^~~\n+```\n+\n+We need our `Car` to be pointed to by multiple `Wheel`s. We can't do that with\n+`Box<T>`, because it has a single owner. We can do it with `Rc<T>` instead:\n+\n+```rust\n+use std::rc::Rc;\n+\n+struct Car {\n+    name: String,\n+}\n+\n+struct Wheel {\n+    size: int,\n+    owner: Rc<Car>,\n+}\n+\n+fn main() {\n+    let car = Car { name: \"DeLorean\".to_string() };\n+\n+    let car_owner = Rc::new(car);\n+\n+    for _ in range(0u, 4) {\n+        Wheel { size: 360, owner: car_owner.clone() };\n+    }\n+}\n+```\n+\n+We wrap our `Car` in an `Rc<T>`, getting an `Rc<Car>`, and then use the\n+`clone()` method to make new references. We've also changed our `Wheel` to have\n+an `Rc<Car>` rather than just a `Car`.\n+\n+This is the simplest kind of multiple ownership possible. For example, there's\n+also `Arc<T>`, which uses more expensive atomic instructions to be the\n+thread-safe counterpart of `Rc<T>`.\n+\n+# Related Resources\n+\n+Coming Soon."}, {"sha": "678e817e2ebbe06b751610278775c2b2aeae0d1b", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -84,7 +84,7 @@ println!(\"{}\", x + z);\n \n This gives us an error:\n \n-```{notrust,ignore}\n+```text\n hello.rs:6:24: 6:25 error: mismatched types: expected `int` but found `&int` (expected int but found &-ptr)\n hello.rs:6     println!(\"{}\", x + z);\n                                   ^\n@@ -132,7 +132,7 @@ Pointers are useful in languages that are pass-by-value, rather than\n pass-by-reference. Basically, languages can make two choices (this is made\n up syntax, it's not Rust):\n \n-```{notrust,ignore}\n+```text\n func foo(x) {\n     x = 5\n }\n@@ -152,7 +152,7 @@ and therefore, can change its value. At the comment, `i` will be `5`.\n So what do pointers have to do with this? Well, since pointers point to a\n location in memory...\n \n-```{notrust,ignore}\n+```text\n func foo(&int x) {\n     *x = 5\n }\n@@ -179,7 +179,7 @@ but here are problems with pointers in other languages:\n Uninitialized pointers can cause a problem. For example, what does this program\n do?\n \n-```{notrust,ignore}\n+```{ignore}\n &int x;\n *x = 5; // whoops!\n ```\n@@ -191,7 +191,7 @@ knows. This might be harmless, and it might be catastrophic.\n When you combine pointers and functions, it's easy to accidentally invalidate\n the memory the pointer is pointing to. For example:\n \n-```{notrust,ignore}\n+```text\n func make_pointer(): &int {\n     x = 5;\n \n@@ -213,7 +213,7 @@ As one last example of a big problem with pointers, **aliasing** can be an\n issue. Two pointers are said to alias when they point at the same location\n in memory. Like this:\n \n-```{notrust,ignore}\n+```text\n func mutate(&int i, int j) {\n     *i = j;\n }\n@@ -398,7 +398,7 @@ fn main() {\n \n It gives this error:\n \n-```{notrust,ignore}\n+```text\n test.rs:5:8: 5:10 error: cannot assign to `*x` because it is borrowed\n test.rs:5         *x -= 1;\n                   ^~\n@@ -408,8 +408,8 @@ test.rs:4         let y = &x;\n ```\n \n As you might guess, this kind of analysis is complex for a human, and therefore\n-hard for a computer, too! There is an entire [guide devoted to references\n-and lifetimes](guide-lifetimes.html) that goes into lifetimes in\n+hard for a computer, too! There is an entire [guide devoted to references, ownership,\n+and lifetimes](guide-ownership.html) that goes into this topic in\n great detail, so if you want the full details, check that out.\n \n ## Best practices\n@@ -445,11 +445,32 @@ fn succ(x: &int) -> int { *x + 1 }\n to\n \n ```{rust}\n+use std::rc::Rc;\n+\n fn box_succ(x: Box<int>) -> int { *x + 1 }\n \n-fn rc_succ(x: std::rc::Rc<int>) -> int { *x + 1 }\n+fn rc_succ(x: Rc<int>) -> int { *x + 1 }\n+```\n+\n+Note that the caller of your function will have to modify their calls slightly:\n+\n+```{rust}\n+use std::rc::Rc;\n+\n+fn succ(x: &int) -> int { *x + 1 }\n+\n+let ref_x = &5i;\n+let box_x = box 5i;\n+let rc_x  = Rc::new(5i);\n+\n+succ(ref_x);\n+succ(&*box_x);\n+succ(&*rc_x);\n ```\n \n+The initial `*` dereferences the pointer, and then `&` takes a reference to\n+those contents.\n+\n # Boxes\n \n `Box<T>` is Rust's 'boxed pointer' type. Boxes provide the simplest form of\n@@ -501,7 +522,7 @@ boxes, though. As a rough approximation, you can treat this Rust code:\n \n As being similar to this C code:\n \n-```{notrust,ignore}\n+```c\n {\n     int *x;\n     x = (int *)malloc(sizeof(int));\n@@ -526,7 +547,7 @@ with some improvements:\n 4. Rust enforces that no other writeable pointers alias to this heap memory,\n    which means writing to an invalid pointer is not possible.\n \n-See the section on references or the [lifetimes guide](guide-lifetimes.html)\n+See the section on references or the [ownership guide](guide-ownership.html)\n for more detail on how lifetimes work.\n \n Using boxes and references together is very common. For example:\n@@ -572,7 +593,7 @@ fn add_one(x: &mut int) -> int {\n fn main() {\n     let x = box 5i;\n \n-    println!(\"{}\", add_one(&*x)); // error: cannot borrow immutable dereference \n+    println!(\"{}\", add_one(&*x)); // error: cannot borrow immutable dereference\n                                   // of `&`-pointer as mutable\n }\n ```\n@@ -605,7 +626,7 @@ fn main() {\n \n This prints:\n \n-```{notrust,ignore}\n+```text\n Cons(1, box Cons(2, box Cons(3, box Nil)))\n ```\n \n@@ -700,9 +721,9 @@ This gives you flexibility without sacrificing performance.\n \n You may think that this gives us terrible performance: return a value and then\n immediately box it up ?! Isn't that the worst of both worlds? Rust is smarter\n-than that. There is no copy in this code. main allocates enough room for the\n-`box , passes a pointer to that memory into foo as x, and then foo writes the\n-value straight into that pointer. This writes the return value directly into\n+than that. There is no copy in this code. `main` allocates enough room for the\n+`box`, passes a pointer to that memory into `foo` as `x`, and then `foo` writes\n+the value straight into that pointer. This writes the return value directly into\n the allocated box.\n \n This is important enough that it bears repeating: pointers are not for\n@@ -759,5 +780,5 @@ Here's a quick rundown of Rust's pointer types:\n # Related resources\n \n * [API documentation for Box](std/boxed/index.html)\n-* [Lifetimes guide](guide-lifetimes.html)\n+* [Ownership guide](guide-ownership.html)\n * [Cyclone paper on regions](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf), which inspired Rust's lifetime system"}, {"sha": "43cc8483bcec54a6784ed71a6c0209b36711f29a", "filename": "src/doc/guide-strings.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-strings.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -181,7 +181,7 @@ for l in s.graphemes(true) {\n \n This prints:\n \n-```{notrust,ignore}\n+```{text}\n u\u0354\n n\u030e\u0348\u0330\n i\u0319\u032e\u035a\u0326\n@@ -207,7 +207,7 @@ for l in s.chars() {\n \n This prints:\n \n-```{notrust,ignore}\n+```{text}\n u\n \u0354\n n\n@@ -252,7 +252,7 @@ for l in s.bytes() {\n \n This will print:\n \n-```{notrust,ignore}\n+```{text}\n 117\n 205\n 148"}, {"sha": "87a3abd8f226bef6f68d36f86301db06037b2898", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -1,5 +1,7 @@\n % The Rust Tasks and Communication Guide\n \n+**NOTE** This guide is badly out of date an needs to be rewritten.\n+\n # Introduction\n \n Rust provides safe concurrent abstractions through a number of core library\n@@ -22,38 +24,44 @@ from shared mutable state.\n At its simplest, creating a task is a matter of calling the `spawn` function\n with a closure argument. `spawn` executes the closure in the new task.\n \n-```{rust}\n+```{rust,ignore}\n # use std::task::spawn;\n \n // Print something profound in a different task using a named function\n fn print_message() { println!(\"I am running in a different task!\"); }\n spawn(print_message);\n \n-// Alternatively, use a `proc` expression instead of a named function.\n-// The `proc` expression evaluates to an (unnamed) proc.\n-// That proc will call `println!(...)` when the spawned task runs.\n-spawn(proc() println!(\"I am also running in a different task!\") );\n+// Alternatively, use a `move ||` expression instead of a named function.\n+// `||` expressions evaluate to an unnamed closure. The `move` keyword\n+// indicates that the closure should take ownership of any variables it\n+// touches.\n+spawn(move || println!(\"I am also running in a different task!\"));\n ```\n \n In Rust, a task is not a concept that appears in the language semantics.\n Instead, Rust's type system provides all the tools necessary to implement safe\n concurrency: particularly, ownership. The language leaves the implementation\n details to the standard library.\n \n-The `spawn` function has a very simple type signature: `fn spawn(f: proc():\n-Send)`. Because it accepts only procs, and procs contain only owned data,\n-`spawn` can safely move the entire proc and all its associated state into an\n-entirely different task for execution. Like any closure, the function passed to\n-`spawn` may capture an environment that it carries across tasks.\n+The `spawn` function has the type signature: `fn\n+spawn<F:FnOnce()+Send>(f: F)`.  This indicates that it takes as\n+argument a closure (of type `F`) that it will run exactly once. This\n+closure is limited to capturing `Send`-able data from its environment\n+(that is, data which is deeply owned). Limiting the closure to `Send`\n+ensures that `spawn` can safely move the entire closure and all its\n+associated state into an entirely different task for execution.\n \n-```{rust}\n+```{rust,ignore}\n # use std::task::spawn;\n # fn generate_task_number() -> int { 0 }\n // Generate some state locally\n let child_task_number = generate_task_number();\n \n-spawn(proc() {\n-    // Capture it in the remote task\n+spawn(move || {\n+    // Capture it in the remote task. The `move` keyword indicates\n+    // that this closure should move `child_task_number` into its\n+    // environment, rather than capturing a reference into the\n+    // enclosing stack frame.\n     println!(\"I am child number {}\", child_task_number);\n });\n ```\n@@ -69,12 +77,12 @@ The simplest way to create a channel is to use the `channel` function to create\n of a channel, and a **receiver** is the receiving endpoint. Consider the following\n example of calculating two results concurrently:\n \n-```{rust}\n+```{rust,ignore}\n # use std::task::spawn;\n \n let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n \n-spawn(proc() {\n+spawn(move || {\n     let result = some_expensive_computation();\n     tx.send(result);\n });\n@@ -90,19 +98,19 @@ stream for sending and receiving integers (the left-hand side of the `let`,\n `(tx, rx)`, is an example of a destructuring let: the pattern separates a tuple\n into its component parts).\n \n-```{rust}\n+```{rust,ignore}\n let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n ```\n \n The child task will use the sender to send data to the parent task, which will\n wait to receive the data on the receiver. The next statement spawns the child\n task.\n \n-```{rust}\n+```{rust,ignore}\n # use std::task::spawn;\n # fn some_expensive_computation() -> int { 42 }\n # let (tx, rx) = channel();\n-spawn(proc() {\n+spawn(move || {\n     let result = some_expensive_computation();\n     tx.send(result);\n });\n@@ -117,7 +125,7 @@ computation, then sends the result over the captured channel.\n Finally, the parent continues with some other expensive computation, then waits\n for the child's result to arrive on the receiver:\n \n-```{rust}\n+```{rust,ignore}\n # fn some_other_expensive_computation() {}\n # let (tx, rx) = channel::<int>();\n # tx.send(0);\n@@ -135,26 +143,26 @@ results across a number of tasks? The following program is ill-typed:\n # fn some_expensive_computation() -> int { 42 }\n let (tx, rx) = channel();\n \n-spawn(proc() {\n+spawn(move || {\n     tx.send(some_expensive_computation());\n });\n \n // ERROR! The previous spawn statement already owns the sender,\n // so the compiler will not allow it to be captured again\n-spawn(proc() {\n+spawn(move || {\n     tx.send(some_expensive_computation());\n });\n ```\n \n Instead we can clone the `tx`, which allows for multiple senders.\n \n-```{rust}\n+```{rust,ignore}\n let (tx, rx) = channel();\n \n for init_val in range(0u, 3) {\n     // Create a new channel handle to distribute to the child task\n     let child_tx = tx.clone();\n-    spawn(proc() {\n+    spawn(move || {\n         child_tx.send(some_expensive_computation(init_val));\n     });\n }\n@@ -173,13 +181,13 @@ Note that the above cloning example is somewhat contrived since you could also\n simply use three `Sender` pairs, but it serves to illustrate the point. For\n reference, written with multiple streams, it might look like the example below.\n \n-```{rust}\n+```{rust,ignore}\n # use std::task::spawn;\n \n // Create a vector of ports, one for each child task\n let rxs = Vec::from_fn(3, |init_val| {\n     let (tx, rx) = channel();\n-    spawn(proc() {\n+    spawn(move || {\n         tx.send(some_expensive_computation(init_val));\n     });\n     rx\n@@ -197,7 +205,7 @@ getting the result later.\n \n The basic example below illustrates this.\n \n-```{rust}\n+```{rust,ignore}\n use std::sync::Future;\n \n # fn main() {\n@@ -207,7 +215,7 @@ fn fib(n: u64) -> u64 {\n     12586269025\n }\n \n-let mut delayed_fib = Future::spawn(proc() fib(50));\n+let mut delayed_fib = Future::spawn(move || fib(50));\n make_a_sandwich();\n println!(\"fib(50) = {}\", delayed_fib.get())\n # }\n@@ -224,7 +232,7 @@ called.\n Here is another example showing how futures allow you to background\n computations. The workload will be distributed on the available cores.\n \n-```{rust}\n+```{rust,ignore}\n # use std::num::Float;\n # use std::sync::Future;\n fn partial_sum(start: uint) -> f64 {\n@@ -236,7 +244,7 @@ fn partial_sum(start: uint) -> f64 {\n }\n \n fn main() {\n-    let mut futures = Vec::from_fn(200, |ind| Future::spawn( proc() { partial_sum(ind) }));\n+    let mut futures = Vec::from_fn(200, |ind| Future::spawn(move || partial_sum(ind)));\n \n     let mut final_res = 0f64;\n     for ft in futures.iter_mut()  {\n@@ -262,7 +270,7 @@ Here is a small example showing how to use Arcs. We wish to run concurrently\n several computations on a single large vector of floats. Each task needs the\n full vector to perform its duty.\n \n-```{rust}\n+```{rust,ignore}\n use std::num::Float;\n use std::rand;\n use std::sync::Arc;\n@@ -278,7 +286,7 @@ fn main() {\n     for num in range(1u, 10) {\n         let task_numbers = numbers_arc.clone();\n \n-        spawn(proc() {\n+        spawn(move || {\n             println!(\"{}-norm = {}\", num, pnorm(task_numbers.as_slice(), num));\n         });\n     }\n@@ -289,7 +297,7 @@ The function `pnorm` performs a simple computation on the vector (it computes\n the sum of its items at the power given as argument and takes the inverse power\n of this value). The Arc on the vector is created by the line:\n \n-```{rust}\n+```{rust,ignore}\n # use std::rand;\n # use std::sync::Arc;\n # fn main() {\n@@ -303,7 +311,7 @@ the wrapper and not its contents. Within the task's procedure, the captured\n Arc reference can be used as a shared reference to the underlying vector as\n if it were local.\n \n-```{rust}\n+```{rust,ignore}\n # use std::rand;\n # use std::sync::Arc;\n # fn pnorm(nums: &[f64], p: uint) -> f64 { 4.0 }\n@@ -312,7 +320,7 @@ if it were local.\n # let numbers_arc = Arc::new(numbers);\n # let num = 4;\n let task_numbers = numbers_arc.clone();\n-spawn(proc() {\n+spawn(move || {\n     // Capture task_numbers and use it as if it was the underlying vector\n     println!(\"{}-norm = {}\", num, pnorm(task_numbers.as_slice(), num));\n });\n@@ -340,17 +348,17 @@ and `()`, callers can pattern-match on a result to check whether it's an `Ok`\n result with an `int` field (representing a successful result) or an `Err` result\n (representing termination with an error).\n \n-```{rust}\n-# use std::task;\n+```{rust,ignore}\n+# use std::thread::Thread;\n # fn some_condition() -> bool { false }\n # fn calculate_result() -> int { 0 }\n-let result: Result<int, Box<std::any::Any + Send>> = task::try(proc() {\n+let result: Result<int, Box<std::any::Any + Send>> = Thread::spawn(move || {\n     if some_condition() {\n         calculate_result()\n     } else {\n         panic!(\"oops!\");\n     }\n-});\n+}).join();\n assert!(result.is_err());\n ```\n "}, {"sha": "682c89fcc53fcc73bd3646247c970a8f41d2c0eb", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 455, "deletions": 245, "changes": 700, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -1,268 +1,515 @@\n % The Rust Testing Guide\n \n-# Quick start\n+> Program testing can be a very effective way to show the presence of bugs, but\n+> it is hopelessly inadequate for showing their absence. \n+>\n+> Edsger W. Dijkstra, \"The Humble Programmer\" (1972)\n \n-To create test functions, add a `#[test]` attribute like this:\n+Let's talk about how to test Rust code. What we will not be talking about is\n+the right way to test Rust code. There are many schools of thought regarding\n+the right and wrong way to write tests. All of these approaches use the same\n+basic tools, and so we'll show you the syntax for using them.\n \n-~~~test_harness\n-fn return_two() -> int {\n-    2\n+# The `test` attribute\n+\n+At its simplest, a test in Rust is a function that's annotated with the `test`\n+attribute. Let's make a new project with Cargo called `adder`:\n+\n+```bash\n+$ cargo new adder\n+$ cd adder\n+```\n+\n+Cargo will automatically generate a simple test when you make a new project.\n+Here's the contents of `src/lib.rs`:\n+\n+```rust\n+#[test]\n+fn it_works() {\n }\n+```\n+\n+Note the `#[test]`. This attribute indicates that this is a test function. It\n+currently has no body. That's good enough to pass! We can run the tests with\n+`cargo test`:\n+\n+```bash\n+$ cargo test\n+   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n+     Running target/adder-91b3e234d4ed382a\n+\n+running 1 test\n+test it_works ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+\n+   Doc-tests adder\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n+```\n+\n+Cargo compiled and ran our tests. There are two sets of output here: one\n+for the test we wrote, and another for documentation tests. We'll talk about\n+those later. For now, see this line:\n+\n+```text\n+test it_works ... ok\n+```\n+\n+Note the `it_works`. This comes from the name of our function:\n \n+```rust\n+fn it_works() {\n+# }\n+```\n+\n+We also get a summary line:\n+\n+```text\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+```\n+\n+So why does our do-nothing test pass? Any test which doesn't `panic!` passes,\n+and any test that does `panic!` fails. Let's make our test fail:\n+\n+```rust\n #[test]\n-fn return_two_test() {\n-    let x = return_two();\n-    assert!(x == 2);\n+fn it_works() {\n+    assert!(false);\n }\n-~~~\n+```\n+\n+`assert!` is a macro provided by Rust which takes one argument: if the argument\n+is `true`, nothing happens. If the argument is false, it `panic!`s. Let's run\n+our tests again:\n \n-To run these tests, compile with `rustc --test` and run the resulting\n-binary:\n+```bash\n+$ cargo test\n+   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n+     Running target/adder-91b3e234d4ed382a\n \n-~~~console\n-$ rustc --test foo.rs\n-$ ./foo\n running 1 test\n-test return_two_test ... ok\n+test it_works ... FAILED\n+\n+failures:\n+\n+---- it_works stdout ----\n+        task 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3\n+\n+\n+\n+failures:\n+    it_works\n+\n+test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n+\n+task '<main>' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247\n+```\n+\n+Rust indicates that our test failed:\n+\n+```text\n+test it_works ... FAILED\n+```\n+\n+And that's reflected in the summary line:\n+\n+```text\n+test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n+```\n+\n+We also get a non-zero status code:\n+\n+```bash\n+$ echo $?\n+101\n+```\n+\n+This is useful if you want to integrate `cargo test` into other tooling.\n+\n+We can invert our test's failure with another attribute: `should_fail`:\n+\n+```rust\n+#[test]\n+#[should_fail]\n+fn it_works() {\n+    assert!(false);\n+}\n+```\n+\n+This test will now succeed if we `panic!` and fail if we complete. Let's try it:\n+\n+```bash\n+$ cargo test\n+   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n+     Running target/adder-91b3e234d4ed382a\n+\n+running 1 test\n+test it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n-~~~\n \n-`rustc foo.rs` will *not* compile the tests, since `#[test]` implies\n-`#[cfg(test)]`. The `--test` flag to `rustc` implies `--cfg test`.\n+   Doc-tests adder\n \n+running 0 tests\n \n-# Unit testing in Rust\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n+```\n \n-Rust has built in support for simple unit testing. Functions can be\n-marked as unit tests using the `test` attribute.\n+Rust provides another macro, `assert_eq!`, that compares two arguments for\n+equality:\n+\n+```rust\n+#[test]\n+#[should_fail]\n+fn it_works() {\n+    assert_eq!(\"Hello\", \"world\");\n+}\n+```\n+\n+Does this test pass or fail? Because of the `should_fail` attribute, it\n+passes:\n+\n+```bash\n+$ cargo test\n+   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n+     Running target/adder-91b3e234d4ed382a\n+\n+running 1 test\n+test it_works ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+\n+   Doc-tests adder\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n+```\n+\n+`should_fail` tests can be fragile, as it's hard to guarantee that the test\n+didn't fail for an unexpected reason. To help with this, an optional `expected`\n+parameter can be added to the `should_fail` attribute. The test harness will\n+make sure that the failure message contains the provided text. A safer version\n+of the example above would be:\n+\n+```\n+#[test]\n+#[should_fail(expected = \"assertion failed\")]\n+fn it_works() {\n+    assert_eq!(\"Hello\", \"world\");\n+}\n+```\n+\n+That's all there is to the basics! Let's write one 'real' test:\n+\n+```{rust,ignore}\n+pub fn add_two(a: i32) -> i32 {\n+    a + 2\n+}\n \n-~~~test_harness\n #[test]\n-fn return_none_if_empty() {\n-    // ... test code ...\n+fn it_works() {\n+    assert_eq!(4, add_two(2));\n }\n-~~~\n+```\n \n-A test function's signature must have no arguments and no return\n-value. To run the tests in a crate, it must be compiled with the\n-`--test` flag: `rustc myprogram.rs --test -o myprogram-tests`. Running\n-the resulting executable will run all the tests in the crate. A test\n-is considered successful if its function returns; if the task running\n-the test fails, through a call to `panic!`, a failed `assert`, or some\n-other (`assert_eq`, ...) means, then the test fails.\n+This is a very common use of `assert_eq!`: call some function with\n+some known arguments and compare it to the expected output.\n \n-When compiling a crate with the `--test` flag `--cfg test` is also\n-implied, so that tests can be conditionally compiled.\n+# The `test` module\n+\n+There is one way in which our existing example is not idiomatic: it's\n+missing the test module. The idiomatic way of writing our example\n+looks like this:\n+\n+```{rust,ignore}\n+pub fn add_two(a: i32) -> i32 {\n+    a + 2\n+}\n \n-~~~test_harness\n #[cfg(test)]\n mod tests {\n+    use super::add_two;\n+\n     #[test]\n-    fn return_none_if_empty() {\n-      // ... test code ...\n+    fn it_works() {\n+        assert_eq!(4, add_two(2));\n     }\n }\n-~~~\n+```\n \n-Additionally `#[test]` items behave as if they also have the\n-`#[cfg(test)]` attribute, and will not be compiled when the `--test` flag\n-is not used.\n+There's a few changes here. The first is the introduction of a `mod tests` with\n+a `cfg` attribute. The module allows us to group all of our tests together, and\n+to also define helper functions if needed, that don't become a part of the rest\n+of our crate. The `cfg` attribute only compiles our test code if we're\n+currently trying to run the tests. This can save compile time, and also ensures\n+that our tests are entirely left out of a normal build.\n \n-Tests that should not be run can be annotated with the `ignore`\n-attribute. The existence of these tests will be noted in the test\n-runner output, but the test will not be run. Tests can also be ignored\n-by configuration using the `cfg_attr` attribute so, for example, to ignore a\n-test on windows you can write `#[cfg_attr(windows, ignore)]`.\n+The second change is the `use` declaration. Because we're in an inner module,\n+we need to bring our test function into scope. This can be annoying if you have\n+a large module, and so this is a common use of the `glob` feature. Let's change\n+our `src/lib.rs` to make use of it:\n \n-Tests that are intended to fail can be annotated with the\n-`should_fail` attribute. The test will be run, and if it causes its\n-task to panic then the test will be counted as successful; otherwise it\n-will be counted as a failure. For example:\n+```{rust,ignore}\n+#![feature(globs)]\n \n-~~~test_harness\n-#[test]\n-#[should_fail]\n-fn test_out_of_bounds_failure() {\n-    let v: &[int] = &[];\n-    v[0];\n+pub fn add_two(a: i32) -> i32 {\n+    a + 2\n }\n-~~~\n \n-A test runner built with the `--test` flag supports a limited set of\n-arguments to control which tests are run:\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n \n-- the first free argument passed to a test runner is interpreted as a\n-  regular expression\n-  ([syntax reference](regex/index.html#syntax))\n-  and is used to narrow down the set of tests being run. Note: a plain\n-  string is a valid regular expression that matches itself.\n-- the `--ignored` flag tells the test runner to run only tests with the\n-  `ignore` attribute.\n+    #[test]\n+    fn it_works() {\n+        assert_eq!(4, add_two(2));\n+    }\n+}\n+```\n \n-## Parallelism\n+Note the `feature` attribute, as well as the different `use` line. Now we run\n+our tests:\n \n-By default, tests are run in parallel, which can make interpreting\n-failure output difficult. In these cases you can set the\n-`RUST_TEST_TASKS` environment variable to 1 to make the tests run\n-sequentially.\n+```bash\n+$ cargo test\n+    Updating registry `https://github.com/rust-lang/crates.io-index`\n+   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n+     Running target/adder-91b3e234d4ed382a\n \n-## Examples\n+running 1 test\n+test test::it_works ... ok\n \n-### Typical test run\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n-~~~console\n-$ mytests\n+   Doc-tests adder\n \n-running 30 tests\n-running driver::tests::mytest1 ... ok\n-running driver::tests::mytest2 ... ignored\n-... snip ...\n-running driver::tests::mytest30 ... ok\n+running 0 tests\n \n-result: ok. 28 passed; 0 failed; 2 ignored\n-~~~\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n+```\n \n-### Test run with failures\n+It works!\n \n-~~~console\n-$ mytests\n+The current convention is to use the `test` module to hold your \"unit\"-style\n+tests. Anything that just tests one small bit of functionality makes sense to\n+go here. But what about \"integration\"-style tests instead? For that, we have\n+the `tests` directory\n \n-running 30 tests\n-running driver::tests::mytest1 ... ok\n-running driver::tests::mytest2 ... ignored\n-... snip ...\n-running driver::tests::mytest30 ... FAILED\n+# The `tests` directory\n \n-result: FAILED. 27 passed; 1 failed; 2 ignored\n-~~~\n+To write an integration test, let's make a `tests` directory, and\n+put a `tests/lib.rs` file inside, with this as its contents:\n \n-### Running ignored tests\n+```{rust,ignore}\n+extern crate adder;\n \n-~~~console\n-$ mytests --ignored\n+#[test]\n+fn it_works() {\n+    assert_eq(4, adder::add_two(2));\n+}   \n+```\n \n-running 2 tests\n-running driver::tests::mytest2 ... failed\n-running driver::tests::mytest10 ... ok\n+This looks similar to our previous tests, but slightly different. We now have\n+an `extern crate adder` at the top. This is because the tests in the `tests`\n+directory are an entirely separate crate, and so we need to import our library.\n+This is also why `tests` is a suitable place to write integration-style tests:\n+they use the library like any other consumer of it would.\n \n-result: FAILED. 1 passed; 1 failed; 0 ignored\n-~~~\n+Let's run them:\n \n-### Running a subset of tests\n+```bash\n+$ cargo test\n+   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n+     Running target/adder-91b3e234d4ed382a\n \n-Using a plain string:\n+running 1 test\n+test test::it_works ... ok\n \n-~~~console\n-$ mytests mytest23\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n-running 1 tests\n-running driver::tests::mytest23 ... ok\n+     Running target/lib-c18e7d3494509e74\n \n-result: ok. 1 passed; 0 failed; 0 ignored\n-~~~\n+running 1 test\n+test it_works ... ok\n \n-Using some regular expression features:\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n-~~~console\n-$ mytests 'mytest[145]'\n+   Doc-tests adder\n \n-running 13 tests\n-running driver::tests::mytest1 ... ok\n-running driver::tests::mytest4 ... ok\n-running driver::tests::mytest5 ... ok\n-running driver::tests::mytest10 ... ignored\n-... snip ...\n-running driver::tests::mytest19 ... ok\n+running 0 tests\n \n-result: ok. 13 passed; 0 failed; 1 ignored\n-~~~\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n+```\n \n-# Microbenchmarking\n+Now we have three sections: our previous test is also run, as well as our new\n+one.\n \n-The test runner also understands a simple form of benchmark execution.\n-Benchmark functions are marked with the `#[bench]` attribute, rather\n-than `#[test]`, and have a different form and meaning. They are\n-compiled along with `#[test]` functions when a crate is compiled with\n-`--test`, but they are not run by default. To run the benchmark\n-component of your testsuite, pass `--bench` to the compiled test\n-runner.\n+That's all there is to the `tests` directory. The `test` module isn't needed\n+here, since the whole thing is focused on tests.\n \n-The type signature of a benchmark function differs from a unit test:\n-it takes a mutable reference to type\n-`test::Bencher`. Inside the benchmark function, any\n-time-variable or \"setup\" code should execute first, followed by a call\n-to `iter` on the benchmark harness, passing a closure that contains\n-the portion of the benchmark you wish to actually measure the\n-per-iteration speed of.\n+Let's finally check out that third section: documentation tests.\n \n-For benchmarks relating to processing/generating data, one can set the\n-`bytes` field to the number of bytes consumed/produced in each\n-iteration; this will be used to show the throughput of the benchmark.\n-This must be the amount used in each iteration, *not* the total\n-amount.\n+# Documentation tests\n \n-For example:\n+Nothing is better than documentation with examples. Nothing is worse than\n+examples that don't actually work, because the code has changed since the\n+documentation has been written. To this end, Rust supports automatically\n+running examples in your documentation. Here's a fleshed-out `src/lib.rs`\n+with examples:\n \n-~~~test_harness\n-extern crate test;\n+```{rust,ignore}\n+//! The `adder` crate provides functions that add numbers to other numbers.\n+//!\n+//! # Examples\n+//!\n+//! ```\n+//! assert_eq!(4, adder::add_two(2));\n+//! ```\n \n-use test::Bencher;\n+#![feature(globs)]\n \n-#[bench]\n-fn bench_sum_1024_ints(b: &mut Bencher) {\n-    let v = Vec::from_fn(1024, |n| n);\n-    b.iter(|| v.iter().fold(0, |old, new| old + *new));\n+/// This function adds two to its argument.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use adder::add_two;\n+///\n+/// assert_eq!(4, add_two(2));\n+/// ```\n+pub fn add_two(a: i32) -> i32 {\n+    a + 2\n }\n \n-#[bench]\n-fn initialise_a_vector(b: &mut Bencher) {\n-    b.iter(|| Vec::from_elem(1024, 0u64));\n-    b.bytes = 1024 * 8;\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn it_works() {\n+        assert_eq!(4, add_two(2));\n+    }\n }\n-~~~\n+```\n \n-The benchmark runner will calibrate measurement of the benchmark\n-function to run the `iter` block \"enough\" times to get a reliable\n-measure of the per-iteration speed.\n+Note the module-level documentation with `//!` and the function-level\n+documentation with `///`. Rust's documentation supports Markdown in comments,\n+and so triple graves mark code blocks. It is conventional to include the\n+`# Examples` section, exactly like that, with examples following.\n \n-Advice on writing benchmarks:\n+Let's run the tests again:\n+\n+```bash\n+$ cargo test\n+   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)\n+     Running target/adder-91b3e234d4ed382a\n+\n+running 1 test\n+test test::it_works ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+\n+     Running target/lib-c18e7d3494509e74\n \n-  - Move setup code outside the `iter` loop; only put the part you\n-    want to measure inside\n-  - Make the code do \"the same thing\" on each iteration; do not\n-    accumulate or change state\n-  - Make the outer function idempotent too; the benchmark runner is\n-    likely to run it many times\n-  - Make the inner `iter` loop short and fast so benchmark runs are\n-    fast and the calibrator can adjust the run-length at fine\n-    resolution\n-  - Make the code in the `iter` loop do something simple, to assist in\n-    pinpointing performance improvements (or regressions)\n-\n-To run benchmarks, pass the `--bench` flag to the compiled\n-test-runner. Benchmarks are compiled-in but not executed by default.\n-\n-~~~console\n-$ rustc mytests.rs -O --test\n-$ mytests --bench\n+running 1 test\n+test it_works ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+\n+   Doc-tests adder\n \n running 2 tests\n-test bench_sum_1024_ints ... bench: 709 ns/iter (+/- 82)\n-test initialise_a_vector ... bench: 424 ns/iter (+/- 99) = 19320 MB/s\n+test add_two_0 ... ok\n+test _0 ... ok\n+\n+test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured\n+```\n+\n+Now we have all three kinds of tests running! Note the names of the\n+documentation tests: the `_0` is generated for the module test, and `add_two_0`\n+for the function test. These will auto increment with names like `add_two_1` as\n+you add more examples.\n+\n+# Benchmark tests\n+\n+Rust also supports benchmark tests, which can test the performance of your\n+code. Let's make our `src/lib.rs` look like this (comments elided):\n+\n+```{rust,ignore}\n+#![feature(globs)]\n+\n+extern crate test;\n+\n+pub fn add_two(a: i32) -> i32 {\n+    a + 2\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use test::Bencher;\n+\n+    #[test]\n+    fn it_works() {\n+        assert_eq!(4, add_two(2));\n+    }\n+\n+    #[bench]\n+    fn bench_add_two(b: &mut Bencher) {\n+        b.iter(|| add_two(2));\n+    }\n+}\n+```\n+\n+We've imported the `test` crate, which contains our benchmarking support.\n+We have a new function as well, with the `bench` attribute. Unlike regular\n+tests, which take no arguments, benchmark tests take a `&mut Bencher`. This\n+`Bencher` provides an `iter` method, which takes a closure. This closure\n+contains the code we'd like to benchmark.\n+\n+We can run benchmark tests with `cargo bench`:\n+\n+```bash\n+$ cargo bench\n+   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)\n+     Running target/release/adder-91b3e234d4ed382a\n+\n+running 2 tests\n+test tests::it_works ... ignored\n+test tests::bench_add_two ... bench:         1 ns/iter (+/- 0)\n+\n+test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured\n+```\n+\n+Our non-benchmark test was ignored. You may have noticed that `cargo bench`\n+takes a bit longer than `cargo test`. This is because Rust runs our benchmark\n+a number of times, and then takes the average. Because we're doing so little\n+work in this example, we have a `1 ns/iter (+/- 0)`, but this would show\n+the variance if there was one.\n+\n+Advice on writing benchmarks:\n \n-test result: ok. 0 passed; 0 failed; 0 ignored; 2 measured\n-~~~\n \n-## Benchmarks and the optimizer\n+* Move setup code outside the `iter` loop; only put the part you want to measure inside\n+* Make the code do \"the same thing\" on each iteration; do not accumulate or change state\n+* Make the outer function idempotent too; the benchmark runner is likely to run\n+  it many times\n+*  Make the inner `iter` loop short and fast so benchmark runs are fast and the\n+   calibrator can adjust the run-length at fine resolution\n+* Make the code in the `iter` loop do something simple, to assist in pinpointing\n+  performance improvements (or regressions)\n \n-Benchmarks compiled with optimizations activated can be dramatically\n-changed by the optimizer so that the benchmark is no longer\n-benchmarking what one expects. For example, the compiler might\n-recognize that some calculation has no external effects and remove\n-it entirely.\n+There's another tricky part to writing benchmarks: benchmarks compiled with\n+optimizations activated can be dramatically changed by the optimizer so that\n+the benchmark is no longer benchmarking what one expects. For example, the\n+compiler might recognize that some calculation has no external effects and\n+remove it entirely.\n \n-~~~test_harness\n+```{rust,ignore}\n extern crate test;\n use test::Bencher;\n \n@@ -272,36 +519,36 @@ fn bench_xor_1000_ints(b: &mut Bencher) {\n         range(0u, 1000).fold(0, |old, new| old ^ new);\n     });\n }\n-~~~\n+```\n \n gives the following results\n \n-~~~console\n+```text\n running 1 test\n test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)\n \n test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\n-~~~\n+```\n \n-The benchmarking runner offers two ways to avoid this. Either, the\n-closure that the `iter` method receives can return an arbitrary value\n-which forces the optimizer to consider the result used and ensures it\n-cannot remove the computation entirely. This could be done for the\n-example above by adjusting the `b.iter` call to\n+The benchmarking runner offers two ways to avoid this. Either, the closure that\n+the `iter` method receives can return an arbitrary value which forces the\n+optimizer to consider the result used and ensures it cannot remove the\n+computation entirely. This could be done for the example above by adjusting the\n+`b.iter` call to\n \n-~~~\n+```rust\n # struct X; impl X { fn iter<T>(&self, _: || -> T) {} } let b = X;\n b.iter(|| {\n     // note lack of `;` (could also use an explicit `return`).\n     range(0u, 1000).fold(0, |old, new| old ^ new)\n });\n-~~~\n+```\n \n-Or, the other option is to call the generic `test::black_box`\n-function, which is an opaque \"black box\" to the optimizer and so\n-forces it to consider any argument as used.\n+Or, the other option is to call the generic `test::black_box` function, which\n+is an opaque \"black box\" to the optimizer and so forces it to consider any\n+argument as used.\n \n-~~~\n+```rust\n extern crate test;\n \n # fn main() {\n@@ -310,54 +557,17 @@ b.iter(|| {\n     test::black_box(range(0u, 1000).fold(0, |old, new| old ^ new));\n });\n # }\n-~~~\n+```\n \n-Neither of these read or modify the value, and are very cheap for\n-small values. Larger values can be passed indirectly to reduce\n-overhead (e.g. `black_box(&huge_struct)`).\n+Neither of these read or modify the value, and are very cheap for small values.\n+Larger values can be passed indirectly to reduce overhead (e.g.\n+`black_box(&huge_struct)`).\n \n-Performing either of the above changes gives the following\n-benchmarking results\n+Performing either of the above changes gives the following benchmarking results\n \n-~~~console\n+```text\n running 1 test\n-test bench_xor_1000_ints ... bench:       375 ns/iter (+/- 148)\n+test bench_xor_1000_ints ... bench:       1 ns/iter (+/- 0)\n \n test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\n-~~~\n-\n-However, the optimizer can still modify a testcase in an undesirable\n-manner even when using either of the above. Benchmarks can be checked\n-by hand by looking at the output of the compiler using the `--emit=ir`\n-(for LLVM IR), `--emit=asm` (for assembly) or compiling normally and\n-using any method for examining object code.\n-\n-## Saving and ratcheting metrics\n-\n-When running benchmarks or other tests, the test runner can record\n-per-test \"metrics\". Each metric is a scalar `f64` value, plus a noise\n-value which represents uncertainty in the measurement. By default, all\n-`#[bench]` benchmarks are recorded as metrics, which can be saved as\n-JSON in an external file for further reporting.\n-\n-In addition, the test runner supports _ratcheting_ against a metrics\n-file. Ratcheting is like saving metrics, except that after each run,\n-if the output file already exists the results of the current run are\n-compared against the contents of the existing file, and any regression\n-_causes the testsuite to fail_. If the comparison passes -- if all\n-metrics stayed the same (within noise) or improved -- then the metrics\n-file is overwritten with the new values. In this way, a metrics file\n-in your workspace can be used to ensure your work does not regress\n-performance.\n-\n-Test runners take 3 options that are relevant to metrics:\n-\n-  - `--save-metrics=<file.json>` will save the metrics from a test run\n-    to `file.json`\n-  - `--ratchet-metrics=<file.json>` will ratchet the metrics against\n-    the `file.json`\n-  - `--ratchet-noise-percent=N` will override the noise measurements\n-    in `file.json`, and consider a metric change less than `N%` to be\n-    noise. This can be helpful if you are testing in a noisy\n-    environment where the benchmark calibration loop cannot acquire a\n-    clear enough signal.\n+```"}, {"sha": "bda1b34563208e0317b958b1b1f9e029b7b1d902", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -37,7 +37,7 @@ build safe interfaces.\n ## References\n \n One of Rust's biggest features is memory safety.  This is achieved in\n-part via [the lifetime system](guide-lifetimes.html), which is how the\n+part via [the ownership system](guide-ownership.html), which is how the\n compiler can guarantee that every `&` reference is always valid, and,\n for example, never pointing to freed memory.\n \n@@ -661,6 +661,9 @@ extern {\n     fn abort() -> !;\n }\n \n+#[lang = \"owned_box\"]\n+pub struct Box<T>(*mut T);\n+\n #[lang=\"exchange_malloc\"]\n unsafe fn allocate(size: uint, _align: uint) -> *mut u8 {\n     let p = libc::malloc(size as libc::size_t) as *mut u8;"}, {"sha": "22cbd18a86520a46f8b9c2998ae28fc8b53f32c9", "filename": "src/doc/guide.md", "status": "modified", "additions": 349, "deletions": 262, "changes": 611, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -22,24 +22,24 @@ install Rust, but the easiest is to use the `rustup` script. If you're on\n Linux or a Mac, all you need to do is this (note that you don't need to type\n in the `$`s, they just indicate the start of each command):\n \n-```{ignore}\n+```bash\n $ curl -s https://static.rust-lang.org/rustup.sh | sudo sh\n ```\n \n (If you're concerned about `curl | sudo sh`, please keep reading. Disclaimer\n below.)\n \n If you're on Windows, please download either the [32-bit\n-installer](https://static.rust-lang.org/dist/rust-nightly-i686-w64-mingw32.exe)\n+installer](https://static.rust-lang.org/dist/rust-nightly-i686-pc-windows-gnu.exe)\n or the [64-bit\n-installer](https://static.rust-lang.org/dist/rust-nightly-x86_64-w64-mingw32.exe)\n+installer](https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.exe)\n and run it.\n \n If you decide you don't want Rust anymore, we'll be a bit sad, but that's okay.\n Not every programming language is great for everyone. Just pass an argument to\n the script:\n \n-```{ignore}\n+```bash\n $ curl -s https://static.rust-lang.org/rustup.sh | sudo sh -s -- --uninstall\n ```\n \n@@ -62,7 +62,7 @@ the easiest way to keep people updated while Rust is in its alpha state.\n \n Oh, we should also mention the officially supported platforms:\n \n-* Windows (7, 8, Server 2008 R2), x86 only\n+* Windows (7, 8, Server 2008 R2)\n * Linux (2.6.18 or later, various distributions), x86 and x86-64\n * OSX 10.7 (Lion) or greater, x86 and x86-64\n \n@@ -78,13 +78,13 @@ commit is tested against Windows just like any other platform.\n \n If you've got Rust installed, you can open up a shell, and type this:\n \n-```{ignore}\n+```bash\n $ rustc --version\n ```\n \n You should see some output that looks something like this:\n \n-```{ignore}\n+```bash\n rustc 0.12.0-nightly (b7aa03a3c 2014-09-28 11:38:01 +0000)\n ```\n \n@@ -140,7 +140,7 @@ $ editor main.rs\n ```\n \n Rust files always end in a `.rs` extension. If you're using more than one word\n-in your file name, use an underscore. `hello_world.rs` rather than\n+in your filename, use an underscore. `hello_world.rs` rather than\n `helloworld.rs`.\n \n Now that you've got your file open, type this in:\n@@ -200,7 +200,7 @@ about this difference. Just know that sometimes, you'll see a `!`, and that\n means that you're calling a macro instead of a normal function. Rust implements\n `println!` as a macro rather than a function for good reasons, but that's a\n very advanced topic. You'll learn more when we talk about macros later. One\n-last thing to mention: Rust's macros are significantly different than C macros,\n+last thing to mention: Rust's macros are significantly different from C macros,\n if you've used those. Don't be scared of using macros. We'll get to the details\n eventually, you'll just have to trust us for now.\n \n@@ -310,7 +310,7 @@ Make sure to get this name right: you need the capital `C`!\n \n Put this inside:\n \n-```{ignore}\n+```toml\n [package]\n \n name = \"hello_world\"\n@@ -355,7 +355,7 @@ just `cargo build` and it'll work the right way.\n \n You'll also notice that Cargo has created a new file: `Cargo.lock`.\n \n-```{ignore,notrust}\n+```toml\n [root]\n name = \"hello_world\"\n version = \"0.0.1\"\n@@ -378,9 +378,15 @@ of your time with Rust.\n The first thing we'll learn about are 'variable bindings.' They look like this:\n \n ```{rust}\n-let x = 5i;\n+fn main() {\n+    let x = 5i;\n+}\n ```\n \n+Putting `fn main() {` in each example is a bit tedious, so we'll leave that out\n+in the future. If you're following along, make sure to edit your `main()`\n+function, rather than leaving it off. Otherwise, you'll get an error.\n+\n In many languages, this is called a 'variable.' But Rust's variable bindings\n have a few tricks up their sleeves. Rust has a very powerful feature called\n 'pattern matching' that we'll get into detail with later, but the left\n@@ -411,6 +417,19 @@ let x: int = 5;\n If I asked you to read this out loud to the rest of the class, you'd say \"`x`\n is a binding with the type `int` and the value `five`.\"\n \n+In future examples, we may annotate the type in a comment. The examples will\n+look like this:\n+\n+```{rust}\n+fn main() {\n+    let x = 5i; // x: int\n+}\n+```\n+\n+Note the similarities between this annotation and the syntax you use with `let`.\n+Including these kinds of comments is not idiomatic Rust, but we'll occasionally\n+include them to help you understand what the types that Rust infers are.\n+\n By default, bindings are **immutable**. This code will not compile:\n \n ```{ignore}\n@@ -420,7 +439,7 @@ x = 10i;\n \n It will give you this error:\n \n-```{ignore,notrust}\n+```text\n error: re-assignment of immutable variable `x`\n      x = 10i;\n      ^~~~~~~\n@@ -429,7 +448,7 @@ error: re-assignment of immutable variable `x`\n If you want a binding to be mutable, you can use `mut`:\n \n ```{rust}\n-let mut x = 5i;\n+let mut x = 5i; // mut x: int\n x = 10i;\n ```\n \n@@ -455,7 +474,7 @@ let x;\n \n ...we'll get an error:\n \n-```{ignore}\n+```text\n src/main.rs:2:9: 2:10 error: cannot determine a type for this local variable: unconstrained type\n src/main.rs:2     let x;\n                       ^\n@@ -480,7 +499,7 @@ fn main() {\n You can use `cargo build` on the command line to build it. You'll get a warning,\n but it will still print \"Hello, world!\":\n \n-```{ignore,notrust}\n+```text\n    Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\n src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)] on by default\n src/main.rs:2     let x: int;\n@@ -531,7 +550,7 @@ format in a more detailed manner, there are a [wide number of options\n available](std/fmt/index.html). For now, we'll just stick to the default:\n integers aren't very complicated to print.\n \n-# If\n+# `if`\n \n Rust's take on `if` is not particularly complex, but it's much more like the\n `if` you'll find in a dynamically typed language than in a more traditional\n@@ -577,20 +596,20 @@ let y = if x == 5i {\n     10i\n } else {\n     15i\n-};\n+}; // y: int\n ```\n \n Which we can (and probably should) write like this:\n \n ```{rust}\n let x = 5i;\n \n-let y = if x == 5i { 10i } else { 15i };\n+let y = if x == 5i { 10i } else { 15i }; // y: int\n ```\n \n This reveals two interesting things about Rust: it is an expression-based\n-language, and semicolons are different than in other 'curly brace and\n-semicolon'-based languages. These two things are related.\n+language, and semicolons are different from semicolons in other 'curly brace\n+and semicolon'-based languages. These two things are related.\n \n ## Expressions vs. Statements\n \n@@ -658,7 +677,7 @@ let y: int = if x == 5i { 10i; } else { 15i; };\n \n Note the semicolons after the 10 and 15. Rust will give us the following error:\n \n-```{ignore,notrust}\n+```text\n error: mismatched types: expected `int` but found `()` (expected int but found ())\n ```\n \n@@ -683,7 +702,7 @@ fn main() {\n ```\n \n This is the simplest possible function declaration. As we mentioned before,\n-`fn` says 'this is a function,' followed by the name, some parenthesis because\n+`fn` says 'this is a function,' followed by the name, some parentheses because\n this function takes no arguments, and then some curly braces to indicate the\n body. Here's a function named `foo`:\n \n@@ -741,7 +760,7 @@ fn print_number(x, y) {\n \n You get this error:\n \n-```{ignore,notrust}\n+```text\n hello.rs:5:18: 5:19 error: expected `:` but found `,`\n hello.rs:5 fn print_number(x, y) {\n ```\n@@ -773,7 +792,7 @@ fn add_one(x: int) -> int {\n \n We would get an error:\n \n-```{ignore,notrust}\n+```text\n error: not all control paths return a value\n fn add_one(x: int) -> int {\n      x + 1;\n@@ -884,7 +903,7 @@ Tuples are an ordered list of a fixed size. Like this:\n let x = (1i, \"hello\");\n ```\n \n-The parenthesis and commas form this two-length tuple. Here's the same code, but\n+The parentheses and commas form this two-length tuple. Here's the same code, but\n with the type annotated:\n \n ```rust\n@@ -908,21 +927,21 @@ let (x, y, z) = (1i, 2i, 3i);\n println!(\"x is {}\", x);\n ```\n \n-Remember before when I said the left hand side of a `let` statement was more\n+Remember before when I said the left-hand side of a `let` statement was more\n powerful than just assigning a binding? Here we are. We can put a pattern on\n-the left hand side of the `let`, and if it matches up to the right hand side,\n+the left-hand side of the `let`, and if it matches up to the right-hand side,\n we can assign multiple bindings at once. In this case, `let` 'destructures,'\n or 'breaks up,' the tuple, and assigns the bits to three bindings.\n \n This pattern is very powerful, and we'll see it repeated more later.\n \n-There also a few things you can do with a tuple as a whole, without\n+There are also a few things you can do with a tuple as a whole, without\n destructuring. You can assign one tuple into another, if they have the same\n arity and contained types.\n \n ```rust\n-let mut x = (1i, 2i);\n-let y = (2i, 3i);\n+let mut x = (1i, 2i); // x: (int, int)\n+let y = (2i, 3i);     // y: (int, int)\n \n x = y;\n ```\n@@ -974,7 +993,7 @@ struct Point {\n }\n \n fn main() {\n-    let origin = Point { x: 0i, y: 0i };\n+    let origin = Point { x: 0i, y: 0i }; // origin: Point\n \n     println!(\"The origin is at ({}, {})\", origin.x, origin.y);\n }\n@@ -991,8 +1010,8 @@ in the original declaration.\n Finally, because fields have names, we can access the field through dot\n notation: `origin.x`.\n \n-The values in structs are immutable, like other bindings in Rust. However, you\n-can use `mut` to make them mutable:\n+The values in structs are immutable by default, like other bindings in Rust.\n+Use `mut` to make them mutable:\n \n ```{rust}\n struct Point {\n@@ -1094,7 +1113,7 @@ fn main() {\n     let x = 5i;\n     let y = 10i;\n \n-    let ordering = cmp(x, y);\n+    let ordering = cmp(x, y); // ordering: Ordering\n \n     if ordering == Less {\n         println!(\"less\");\n@@ -1150,20 +1169,69 @@ enum StringResult {\n     ErrorReason(String),\n }\n ```\n-Where a `StringResult` is either an `StringOK`, with the result of a computation, or an\n+Where a `StringResult` is either a `StringOK`, with the result of a computation, or an\n `ErrorReason` with a `String` explaining what caused the computation to fail. These kinds of\n `enum`s are actually very useful and are even part of the standard library.\n \n-As you can see `enum`s with values are quite a powerful tool for data representation,\n-and can be even more useful when they're generic across types. But before we get to\n-generics, let's talk about how to use them with pattern matching, a tool that will\n+Enum variants are namespaced under the enum names. For example, here is an example of using\n+our `StringResult`:\n+\n+```rust\n+# enum StringResult {\n+#     StringOK(String),\n+#     ErrorReason(String),\n+# }\n+fn respond(greeting: &str) -> StringResult {\n+    if greeting == \"Hello\" {\n+        StringResult::StringOK(\"Good morning!\".to_string())\n+    } else {\n+        StringResult::ErrorReason(\"I didn't understand you!\".to_string())\n+    }\n+}\n+```\n+\n+Notice that we need both the enum name and the variant name: `StringResult::StringOK`, but\n+we didn't need to with `Ordering` \u2013 we just said `Greater` rather than `Ordering::Greater`.\n+There's a reason: the Rust prelude imports the variants of `Ordering` as well as the enum\n+itself. We can use the `use` keyword to do something similar with `StringResult`:\n+\n+```rust\n+use StringResult::StringOK;\n+use StringResult::ErrorReason;\n+\n+enum StringResult {\n+    StringOK(String),\n+    ErrorReason(String),\n+}\n+\n+# fn main() {}\n+\n+fn respond(greeting: &str) -> StringResult {\n+    if greeting == \"Hello\" {\n+        StringOK(\"Good morning!\".to_string())\n+    } else {\n+        ErrorReason(\"I didn't understand you!\".to_string())\n+    }\n+}\n+```\n+\n+We'll learn more about `use` later, but it's used to bring names into scope. `use` declarations\n+must come before anything else, which looks a little strange in this example, since we `use`\n+the variants before we define them. Anyway, in the body of `respond`, we can just say `StringOK`\n+now, rather than the full `StringResult::StringOK`. Importing variants can be convenient, but can\n+also cause name conflicts, so do this with caution. It's considered good style to rarely import\n+variants for this reason.\n+\n+As you can see, `enum`s with values are quite a powerful tool for data representation,\n+and can be even more useful when they're generic across types. Before we get to generics,\n+though, let's talk about how to use them with pattern matching, a tool that will\n let us deconstruct this sum type (the type theory term for enums) in a very elegant\n way and avoid all these messy `if`/`else`s.\n \n # Match\n \n Often, a simple `if`/`else` isn't enough, because you have more than two\n-possible options. And `else` conditions can get incredibly complicated. So\n+possible options. Also, `else` conditions can get incredibly complicated, so\n what's the solution?\n \n Rust has a keyword, `match`, that allows you to replace complicated `if`/`else`\n@@ -1182,25 +1250,25 @@ match x {\n }\n ```\n \n-`match` takes an expression, and then branches based on its value. Each 'arm' of\n+`match` takes an expression and then branches based on its value. Each 'arm' of\n the branch is of the form `val => expression`. When the value matches, that arm's\n expression will be evaluated. It's called `match` because of the term 'pattern\n-matching,' which `match` is an implementation of.\n+matching', which `match` is an implementation of.\n \n So what's the big advantage here? Well, there are a few. First of all, `match`\n-enforces 'exhaustiveness checking.' Do you see that last arm, the one with the\n+enforces 'exhaustiveness checking'. Do you see that last arm, the one with the\n underscore (`_`)? If we remove that arm, Rust will give us an error:\n \n-```{ignore,notrust}\n+```text\n error: non-exhaustive patterns: `_` not covered\n ```\n \n In other words, Rust is trying to tell us we forgot a value. Because `x` is an\n-integer, Rust knows that it can have a number of different values. For example,\n-`6i`. But without the `_`, there is no arm that could match, and so Rust refuses\n-to compile. `_` is sort of like a catch-all arm. If none of the other arms match,\n-the arm with `_` will. And since we have this catch-all arm, we now have an arm\n-for every possible value of `x`, and so our program will now compile.\n+integer, Rust knows that it can have a number of different values \u2013 for example,\n+`6i`. Without the `_`, however, there is no arm that could match, and so Rust refuses\n+to compile. `_` acts like a 'catch-all arm'. If none of the other arms match,\n+the arm with `_` will, and since we have this catch-all arm, we now have an arm\n+for every possible value of `x`, and so our program will compile successfully.\n \n `match` statements also destructure enums, as well. Remember this code from the\n section on enums?\n@@ -1281,14 +1349,14 @@ fn main() {\n ```\n \n That is how you can get and use the values contained in `enum`s.\n-It can also allow us to treat errors or unexpected computations, for example, a\n-function that is not guaranteed to be able to compute a result (an `int` here),\n+It can also allow us to handle errors or unexpected computations; for example, a\n+function that is not guaranteed to be able to compute a result (an `int` here)\n could return an `OptionalInt`, and we would handle that value with a `match`.\n As you can see, `enum` and `match` used together are quite useful!\n \n-`match` is also an expression, which means we can use it on the right\n-hand side of a `let` binding or directly where an expression is\n-used. We could also implement the previous line like this:\n+`match` is also an expression, which means we can use it on the right-hand\n+side of a `let` binding or directly where an expression is used. We could\n+also implement the previous line like this:\n \n ```{rust}\n fn cmp(a: int, b: int) -> Ordering {\n@@ -1320,7 +1388,7 @@ two main looping constructs: `for` and `while`.\n \n The `for` loop is used to loop a particular number of times. Rust's `for` loops\n work a bit differently than in other systems languages, however. Rust's `for`\n-loop doesn't look like this \"C style\" `for` loop:\n+loop doesn't look like this \"C-style\" `for` loop:\n \n ```{c}\n for (x = 0; x < 10; x++) {\n@@ -1332,13 +1400,13 @@ Instead, it looks like this:\n \n ```{rust}\n for x in range(0i, 10i) {\n-    println!(\"{}\", x);\n+    println!(\"{}\", x); // x: int\n }\n ```\n \n In slightly more abstract terms,\n \n-```{ignore,notrust}\n+```{ignore}\n for var in expression {\n     code\n }\n@@ -1355,7 +1423,7 @@ In our example, `range` is a function that takes a start and an end position,\n and gives an iterator over those values. The upper bound is exclusive, though,\n so our loop will print `0` through `9`, not `10`.\n \n-Rust does not have the \"C style\" `for` loop on purpose. Manually controlling\n+Rust does not have the \"C-style\" `for` loop on purpose. Manually controlling\n each element of the loop is complicated and error prone, even for experienced C\n developers.\n \n@@ -1367,8 +1435,8 @@ The other kind of looping construct in Rust is the `while` loop. It looks like\n this:\n \n ```{rust}\n-let mut x = 5u;\n-let mut done = false;\n+let mut x = 5u;       // mut x: uint\n+let mut done = false; // mut done: bool\n \n while !done {\n     x += x - 3;\n@@ -1386,7 +1454,7 @@ If you need an infinite loop, you may be tempted to write this:\n while true {\n ```\n \n-Rust has a dedicated keyword, `loop`, to handle this case:\n+However, Rust has a dedicated keyword, `loop`, to handle this case:\n \n ```{rust,ignore}\n loop {\n@@ -1396,7 +1464,7 @@ Rust's control-flow analysis treats this construct differently than a\n `while true`, since we know that it will always loop. The details of what\n that _means_ aren't super important to understand at this stage, but in\n general, the more information we can give to the compiler, the better it\n-can do with safety and code generation. So you should always prefer\n+can do with safety and code generation, so you should always prefer\n `loop` when you plan to loop infinitely.\n \n ## Ending iteration early\n@@ -1415,7 +1483,7 @@ while !done {\n ```\n \n We had to keep a dedicated `mut` boolean variable binding, `done`, to know\n-when we should skip out of the loop. Rust has two keywords to help us with\n+when we should exit out of the loop. Rust has two keywords to help us with\n modifying iteration: `break` and `continue`.\n \n In this case, we can write the loop in a better way with `break`:\n@@ -1430,10 +1498,10 @@ loop {\n }\n ```\n \n-We now loop forever with `loop`, and use `break` to break out early.\n+We now loop forever with `loop` and use `break` to break out early.\n \n `continue` is similar, but instead of ending the loop, goes to the next\n-iteration: This will only print the odd numbers:\n+iteration. This will only print the odd numbers:\n \n ```{rust}\n for x in range(0i, 10i) {\n@@ -1448,14 +1516,14 @@ Both `continue` and `break` are valid in both kinds of loops.\n # Strings\n \n Strings are an important concept for any programmer to master. Rust's string\n-handling system is a bit different than in other languages, due to its systems\n+handling system is a bit different from other languages, due to its systems\n focus. Any time you have a data structure of variable size, things can get\n-tricky, and strings are a re-sizable data structure. That said, Rust's strings\n-also work differently than in some other systems languages, such as C.\n+tricky, and strings are a re-sizable data structure. That being said, Rust's\n+strings also work differently than in some other systems languages, such as C.\n \n-Let's dig into the details. A **string** is a sequence of unicode scalar values\n+Let's dig into the details. A **string** is a sequence of Unicode scalar values\n encoded as a stream of UTF-8 bytes. All strings are guaranteed to be\n-validly-encoded UTF-8 sequences. Additionally, strings are not null-terminated\n+validly encoded UTF-8 sequences. Additionally, strings are not null-terminated\n and can contain null bytes.\n \n Rust has two main types of strings: `&str` and `String`.\n@@ -1464,7 +1532,7 @@ The first kind is a `&str`. This is pronounced a 'string slice.' String literals\n are of the type `&str`:\n \n ```{rust}\n-let string = \"Hello there.\";\n+let string = \"Hello there.\"; // string: &str\n ```\n \n This string is statically allocated, meaning that it's saved inside our\n@@ -1476,7 +1544,7 @@ A `String`, on the other hand, is an in-memory string.  This string is\n growable, and is also guaranteed to be UTF-8.\n \n ```{rust}\n-let mut s = \"Hello\".to_string();\n+let mut s = \"Hello\".to_string(); // mut s: String\n println!(\"{}\", s);\n \n s.push_str(\", world.\");\n@@ -1532,16 +1600,19 @@ things. The most basic is the **array**, a fixed-size list of elements of the\n same type. By default, arrays are immutable.\n \n ```{rust}\n-let a = [1i, 2i, 3i];\n-let mut m = [1i, 2i, 3i];\n+let a = [1i, 2i, 3i];     // a: [int, ..3]\n+let mut m = [1i, 2i, 3i]; // mut m: [int, ..3]\n ```\n \n You can create an array with a given number of elements, all initialized to the\n same value, with `[val, ..N]` syntax. The compiler ensures that arrays are\n always initialized.\n \n+There's a shorthand for initializing each element of an array to the same\n+value. In this example, each element of `a` will be initialized to `0i`:\n+\n ```{rust}\n-let a = [0i, ..20];  // Shorthand for array of 20 elements all initialized to 0\n+let a = [0i, ..20]; // a: [int, ..20]\n ```\n \n Arrays have type `[T,..N]`. We'll talk about this `T` notation later, when we\n@@ -1552,7 +1623,7 @@ You can get the number of elements in an array `a` with `a.len()`, and use\n number in order:\n \n ```{rust}\n-let a = [1i, 2, 3];     // Only the first item needs a type suffix\n+let a = [1i, 2, 3]; // Only the first item needs a type suffix\n \n println!(\"a has {} elements\", a.len());\n for e in a.iter() {\n@@ -1563,7 +1634,7 @@ for e in a.iter() {\n You can access a particular element of an array with **subscript notation**:\n \n ```{rust}\n-let names = [\"Graydon\", \"Brian\", \"Niko\"];\n+let names = [\"Graydon\", \"Brian\", \"Niko\"]; // names: [&str, 3]\n \n println!(\"The second name is: {}\", names[1]);\n ```\n@@ -1581,7 +1652,7 @@ later). Vectors are to arrays what `String` is to `&str`. You can create them\n with the `vec!` macro:\n \n ```{rust}\n-let v = vec![1i, 2, 3];\n+let v = vec![1i, 2, 3]; // v: Vec<int>\n ```\n \n (Notice that unlike the `println!` macro we've used in the past, we use square\n@@ -1592,8 +1663,10 @@ You can get the length of, iterate over, and subscript vectors just like\n arrays. In addition, (mutable) vectors can grow automatically:\n \n ```{rust}\n-let mut nums = vec![1i, 2, 3];\n+let mut nums = vec![1i, 2, 3]; // mut nums: Vec<int>\n+\n nums.push(4);\n+\n println!(\"The length of nums is now {}\", nums.len());   // Prints 4\n ```\n \n@@ -1719,22 +1792,22 @@ fn main() {\n }\n ```\n \n-We had to match each time, to see if we had a value or not. In this case,\n-though, we _know_ that `x` has a `Value`. But `match` forces us to handle\n+We had to match each time to see if we had a value or not. In this case,\n+though, we _know_ that `x` has a `Value`, but `match` forces us to handle\n the `missing` case. This is what we want 99% of the time, but sometimes, we\n know better than the compiler.\n \n Likewise, `read_line()` does not return a line of input. It _might_ return a\n-line of input. It might also fail to do so. This could happen if our program\n+line of input, though it might also fail to do so. This could happen if our program\n isn't running in a terminal, but as part of a cron job, or some other context\n where there's no standard input. Because of this, `read_line` returns a type\n very similar to our `OptionalInt`: an `IoResult<T>`. We haven't talked about\n `IoResult<T>` yet because it is the **generic** form of our `OptionalInt`.\n-Until then, you can think of it as being the same thing, just for any type, not\n-just `int`s.\n+Until then, you can think of it as being the same thing, just for any type \u2013\n+not just `int`s.\n \n Rust provides a method on these `IoResult<T>`s called `ok()`, which does the\n-same thing as our `match` statement, but assuming that we have a valid value.\n+same thing as our `match` statement but assumes that we have a valid value.\n We then call `expect()` on the result, which will terminate our program if we\n don't have a valid value. In this case, if we can't get input, our program\n doesn't work, so we're okay with that. In most cases, we would want to handle\n@@ -1767,16 +1840,18 @@ use std::io;\n fn main() {\n     println!(\"Type something!\");\n \n-    let input = io::stdin()\n-                  .read_line()\n-                  .ok()\n-                  .expect(\"Failed to read line\");\n+                                                  // here, we'll show the types at each step\n+\n+    let input = io::stdin()                       // std::io::stdio::StdinReader\n+                  .read_line()                    // IoResult<String>\n+                  .ok()                           // Option<String>\n+                  .expect(\"Failed to read line\"); // String\n \n     println!(\"{}\", input);\n }\n ```\n \n-Sometimes, this makes things more readable. Sometimes, less. Use your judgment\n+Sometimes, this makes things more readable \u2013 sometimes, less. Use your judgement\n here.\n \n That's all you need to get basic input from the standard input! It's not too\n@@ -1809,7 +1884,7 @@ since we're making a binary, rather than a library.\n \n Check out the generated `Cargo.toml`:\n \n-```{ignore}\n+```toml\n [package]\n \n name = \"guessing_game\"\n@@ -1843,7 +1918,7 @@ Before we move on, let me show you one more Cargo command: `run`. `cargo run`\n is kind of like `cargo build`, but it also then runs the produced executable.\n Try it out:\n \n-```{notrust,ignore}\n+```bash\n $ cargo run\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n@@ -1896,10 +1971,8 @@ You can find that page [here](std/index.html). There's a lot of information on\n that page, but the best part is the search bar. Right up at the top, there's\n a box that you can enter in a search term. The search is pretty primitive\n right now, but is getting better all the time. If you type 'random' in that\n-box, the page will update to [this\n-one](std/index.html?search=random). The very first\n-result is a link to\n-[std::rand::random](std/rand/fn.random.html). If we\n+box, the page will update to [this one](std/index.html?search=random). The very\n+first result is a link to [`std::rand::random`](std/rand/fn.random.html). If we\n click on that result, we'll be taken to its documentation page.\n \n This page shows us a few things: the type signature of the function, some\n@@ -1913,7 +1986,7 @@ use std::rand;\n fn main() {\n     println!(\"Guess the number!\");\n \n-    let secret_number = (rand::random() % 100i) + 1i;\n+    let secret_number = (rand::random() % 100i) + 1i; // secret_number: int\n \n     println!(\"The secret number is: {}\", secret_number);\n \n@@ -1941,7 +2014,7 @@ for this example, it is not important.\n \n Let's try to compile this using `cargo build`:\n \n-```{notrust,no_run}\n+```bash\n $ cargo build\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n src/main.rs:7:26: 7:34 error: the type of this value must be known in this context\n@@ -1963,7 +2036,7 @@ rand::random::<int>();\n ```\n \n This says \"please give me a random `int` value.\" We can change our code to use\n-this hint...\n+this hint:\n \n ```{rust,no_run}\n use std::io;\n@@ -1989,7 +2062,7 @@ fn main() {\n \n Try running our new program a few times:\n \n-```{notrust,ignore}\n+```bash\n $ cargo run\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n@@ -2042,7 +2115,7 @@ fn main() {\n \n And trying it out:\n \n-```{notrust,ignore}\n+```bash\n $ cargo run\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n@@ -2058,8 +2131,8 @@ Great! Next up: let's compare our guess to the secret guess.\n ## Comparing guesses\n \n If you remember, earlier in the guide, we made a `cmp` function that compared\n-two numbers. Let's add that in, along with a `match` statement to compare the\n-guess to the secret guess:\n+two numbers. Let's add that in, along with a `match` statement to compare our\n+guess to the secret number:\n \n ```{rust,ignore}\n use std::io;\n@@ -2097,7 +2170,7 @@ fn cmp(a: int, b: int) -> Ordering {\n \n If we try to compile, we'll get some errors:\n \n-```{notrust,ignore}\n+```bash\n $ cargo build\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n src/main.rs:20:15: 20:20 error: mismatched types: expected `int` but found `collections::string::String` (expected int but found struct collections::string::String)\n@@ -2151,7 +2224,7 @@ fn cmp(a: uint, b: uint) -> Ordering {\n \n And try compiling again:\n \n-```{notrust,ignore}\n+```bash\n $ cargo build\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n src/main.rs:20:15: 20:20 error: mismatched types: expected `uint` but found `collections::string::String` (expected uint but found struct collections::string::String)\n@@ -2164,7 +2237,7 @@ This error is similar to the last one: we expected to get a `uint`, but we got\n a `String` instead! That's because our `input` variable is coming from the\n standard input, and you can guess anything. Try it:\n \n-```{notrust,ignore}\n+```bash\n $ ./target/guessing_game\n Guess the number!\n The secret number is: 73\n@@ -2184,10 +2257,10 @@ a function for that:\n let input = io::stdin().read_line()\n                        .ok()\n                        .expect(\"Failed to read line\");\n-let input_num: Option<uint> = from_str(input.as_slice());\n+let input_num: Option<uint> = input.parse();\n ```\n \n-The `from_str` function takes in a `&str` value and converts it into something.\n+The `parse` function takes in a `&str` value and converts it into something.\n We tell it what kind of something with a type hint. Remember our type hint with\n `random()`? It looked like this:\n \n@@ -2206,8 +2279,8 @@ In this case, we say `x` is a `uint` explicitly, so Rust is able to properly\n tell `random()` what to generate. In a similar fashion, both of these work:\n \n ```{rust,ignore}\n-let input_num = from_str::<uint>(\"5\");\n-let input_num: Option<uint> = from_str(\"5\");\n+let input_num = \"5\".parse::<uint>();         // input_num: Option<uint>\n+let input_num: Option<uint> = \"5\".parse();   // input_num: Option<uint>\n ```\n \n Anyway, with us now converting our input to a number, our code looks like this:\n@@ -2228,7 +2301,7 @@ fn main() {\n     let input = io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<uint> = from_str(input.as_slice());\n+    let input_num: Option<uint> = input.parse();\n \n     println!(\"You guessed: {}\", input_num);\n \n@@ -2248,7 +2321,7 @@ fn cmp(a: uint, b: uint) -> Ordering {\n \n Let's try it out!\n \n-```{notrust,ignore}\n+```bash\n $ cargo build\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n src/main.rs:22:15: 22:24 error: mismatched types: expected `uint` but found `core::option::Option<uint>` (expected uint but found enum core::option::Option)\n@@ -2277,7 +2350,7 @@ fn main() {\n     let input = io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<uint> = from_str(input.as_slice());\n+    let input_num: Option<uint> = input.parse();\n \n     let num = match input_num {\n         Some(num) => num,\n@@ -2304,10 +2377,10 @@ fn cmp(a: uint, b: uint) -> Ordering {\n }\n ```\n \n-We use a `match` to either give us the `uint` inside of the `Option`, or we\n+We use a `match` to either give us the `uint` inside of the `Option`, or else\n print an error message and return. Let's give this a shot:\n \n-```{notrust,ignore}\n+```bash\n $ cargo run\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n@@ -2322,8 +2395,8 @@ Uh, what? But we did!\n \n ... actually, we didn't. See, when you get a line of input from `stdin()`,\n you get all the input. Including the `\\n` character from you pressing Enter.\n-So, `from_str()` sees the string `\"5\\n\"` and says \"nope, that's not a number,\n-there's non-number stuff in there!\" Luckily for us, `&str`s have an easy\n+Therefore, `parse()` sees the string `\"5\\n\"` and says \"nope, that's not a\n+number; there's non-number stuff in there!\" Luckily for us, `&str`s have an easy\n method we can use defined on them: `trim()`. One small modification, and our\n code looks like this:\n \n@@ -2343,7 +2416,7 @@ fn main() {\n     let input = io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<uint> = from_str(input.as_slice().trim());\n+    let input_num: Option<uint> = input.trim().parse();\n \n     let num = match input_num {\n         Some(num) => num,\n@@ -2372,7 +2445,7 @@ fn cmp(a: uint, b: uint) -> Ordering {\n \n Let's try it!\n \n-```{notrust,ignore}\n+```bash\n $ cargo run\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n@@ -2389,16 +2462,16 @@ out that I guessed 76. Run the program a few times, and verify that guessing\n the number works, as well as guessing a number too small.\n \n The Rust compiler helped us out quite a bit there! This technique is called\n-\"lean on the compiler,\" and it's often useful when working on some code. Let\n+\"lean on the compiler\", and it's often useful when working on some code. Let\n the error messages help guide you towards the correct types.\n \n Now we've got most of the game working, but we can only make one guess. Let's\n change that by adding loops!\n \n ## Looping\n \n-As we already discussed, the `loop` keyword gives us an infinite loop. So\n-let's add that in:\n+As we already discussed, the `loop` keyword gives us an infinite loop.\n+Let's add that in:\n \n ```{rust,no_run}\n use std::io;\n@@ -2418,7 +2491,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+        let input_num: Option<uint> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -2449,7 +2522,7 @@ fn cmp(a: uint, b: uint) -> Ordering {\n And try it out. But wait, didn't we just add an infinite loop? Yup. Remember\n that `return`? If we give a non-number answer, we'll `return` and quit. Observe:\n \n-```{notrust,ignore}\n+```bash\n $ cargo run\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n@@ -2493,7 +2566,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+        let input_num: Option<uint> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -2548,7 +2621,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+        let input_num: Option<uint> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -2581,7 +2654,7 @@ fn cmp(a: uint, b: uint) -> Ordering {\n \n Now we should be good! Let's try:\n \n-```{notrust,ignore}\n+```bash\n $ cargo run\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n@@ -2624,7 +2697,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+        let input_num: Option<uint> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -2697,19 +2770,18 @@ $ cd modules\n \n Let's double check our work by compiling:\n \n-```{bash,notrust}\n+```{bash}\n $ cargo run\n    Compiling modules v0.0.1 (file:///home/you/projects/modules)\n      Running `target/modules`\n Hello, world!\n ```\n \n-Excellent! So, we already have a single crate here: our `src/main.rs` is a crate.\n+Excellent! We already have a single crate here: our `src/main.rs` is a crate.\n Everything in that file is in the crate root. A crate that generates an executable\n defines a `main` function inside its root, as we've done here.\n \n-Let's define a new module inside our crate. Edit `src/main.rs` to look\n-like this:\n+Let's define a new module inside our crate. Edit `src/main.rs` to look like this:\n \n ```\n fn main() {\n@@ -2727,7 +2799,7 @@ We now have a module named `hello` inside of our crate root. Modules use\n `snake_case` naming, like functions and variable bindings.\n \n Inside the `hello` module, we've defined a `print_hello` function. This will\n-also print out our hello world message. Modules allow you to split up your\n+also print out our \"hello world\" message. Modules allow you to split up your\n program into nice neat boxes of functionality, grouping common things together,\n and keeping different things apart. It's kinda like having a set of shelves:\n a place for everything and everything in its place.\n@@ -2759,7 +2831,7 @@ mod hello {\n \n It gives an error:\n \n-```{notrust,ignore}\n+```bash\n    Compiling modules v0.0.1 (file:///home/you/projects/modules)\n src/main.rs:2:5: 2:23 error: function `print_hello` is private\n src/main.rs:2     hello::print_hello();\n@@ -2783,7 +2855,7 @@ mod hello {\n Usage of the `pub` keyword is sometimes called 'exporting', because\n we're making the function available for other modules. This will work:\n \n-```{notrust,ignore}\n+```bash\n $ cargo run\n    Compiling modules v0.0.1 (file:///home/you/projects/modules)\n      Running `target/modules`\n@@ -2855,7 +2927,7 @@ parts of your library. The six levels are:\n * experimental: This item was only recently introduced or is otherwise in a\n   state of flux. It may change significantly, or even be removed. No guarantee\n   of backwards-compatibility.\n-* unstable: This item is still under development, but requires more testing to\n+* unstable: This item is still under development and requires more testing to\n   be considered stable. No guarantee of backwards-compatibility.\n * stable: This item is considered stable, and will not change significantly.\n   Guarantee of backwards-compatibility.\n@@ -2887,7 +2959,7 @@ You'll get a warning if you use something marked unstable.\n \n You may have noticed an exclamation point in the `warn` attribute declaration.\n The `!` in this attribute means that this attribute applies to the enclosing\n-item, rather than to the item that follows the attribute. So this `warn`\n+item, rather than to the item that follows the attribute. This `warn`\n attribute declaration applies to the enclosing crate itself, rather than\n to whatever item statement follows it:\n \n@@ -2917,7 +2989,7 @@ $ cd testing\n \n And try it out:\n \n-```{notrust,ignore}\n+```bash\n $ cargo run\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n      Running `target/testing`\n@@ -2927,9 +2999,9 @@ Hello, world!\n Great. Rust's infrastructure supports tests in two sorts of places, and they're\n for two kinds of tests: you include **unit test**s inside of the crate itself,\n and you place **integration test**s inside a `tests` directory. \"Unit tests\"\n-are small tests that test one focused unit, \"integration tests\" tests multiple\n-units in integration. That said, this is a social convention, they're no different\n-in syntax. Let's make a `tests` directory:\n+are small tests that test one focused unit; \"integration tests\" test multiple\n+units in integration. That being said, this is a social convention \u2013 they're no\n+different in syntax. Let's make a `tests` directory:\n \n ```{bash,ignore}\n $ mkdir tests\n@@ -2949,7 +3021,7 @@ you give them descriptive names. You'll see why in a moment. We then use a\n macro, `assert!`, to assert that something is true. In this case, we're giving\n it `false`, so this test should fail. Let's try it!\n \n-```{notrust,ignore}\n+```bash\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n /home/you/projects/testing/src/main.rs:1:1: 3:2 warning: function is never used: `main`, #[warn(dead_code)] on by default\n@@ -2978,15 +3050,15 @@ task '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.\n \n Lots of output! Let's break this down:\n \n-```{notrust,ignore}\n+```bash\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n ```\n \n You can run all of your tests with `cargo test`. This runs both your tests in\n `tests`, as well as the tests you put inside of your crate.\n \n-```{notrust,ignore}\n+```text\n /home/you/projects/testing/src/main.rs:1:1: 3:2 warning: function is never used: `main`, #[warn(dead_code)] on by default\n /home/you/projects/testing/src/main.rs:1 fn main() {\n /home/you/projects/testing/src/main.rs:2     println!(\"Hello, world!\")\n@@ -3000,7 +3072,7 @@ case, Rust is warning us that we've written some code that's never used: our\n We'll turn this lint off for just this function soon. For now, just ignore this\n output.\n \n-```{notrust,ignore}\n+```text\n      Running target/lib-654ce120f310a3a5\n \n running 1 test\n@@ -3009,10 +3081,10 @@ test foo ... FAILED\n \n Now we're getting somewhere. Remember when we talked about naming our tests\n with good names? This is why. Here, it says 'test foo' because we called our\n-test 'foo.' If we had given it a good name, it'd be more clear which test\n+test 'foo'. If we had given it a good name, it'd be more clear which test\n failed, especially as we accumulate more tests.\n \n-```{notrust,ignore}\n+```text\n failures:\n \n ---- foo stdout ----\n@@ -3043,7 +3115,7 @@ fn foo() {\n \n And then try to run our tests again:\n \n-```{notrust,ignore}\n+```bash\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n      Running target/lib-654ce120f310a3a5\n@@ -3080,10 +3152,10 @@ our tests, it sets things up so that `cfg(test)` is true. But we want to only\n include `main` when it's _not_ true. So we use `not` to negate things:\n `cfg(not(test))` will only compile our code when the `cfg(test)` is false.\n \n-With this attribute we won't get the warning (even\n+With this attribute, we won't get the warning (even\n though `src/main.rs` gets recompiled this time):\n \n-```{notrust,ignore}\n+```bash\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n      Running target/lib-654ce120f310a3a5\n@@ -3114,7 +3186,7 @@ fn math_checks_out() {\n \n And try to run the test:\n \n-```{notrust,ignore}\n+```bash\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n /home/you/projects/testing/tests/lib.rs:3:18: 3:38 error: unresolved name `add_three_times_four`.\n@@ -3124,15 +3196,15 @@ error: aborting due to previous error\n Build failed, waiting for other jobs to finish...\n Could not compile `testing`.\n \n-To learn more, run the command again with --verbose.\n+To learn more, run the command again with `--verbose`.\n ```\n \n Rust can't find this function. That makes sense, as we didn't write it yet!\n \n In order to share this code with our tests, we'll need to make a library crate.\n This is also just good software design: as we mentioned before, it's a good idea\n to put most of your functionality into a library crate, and have your executable\n-crate use that library. This allows for code re-use.\n+crate use that library. This allows for code reuse.\n \n To do that, we'll need to make a new module. Make a new file, `src/lib.rs`,\n and put this in it:\n@@ -3144,8 +3216,8 @@ pub fn add_three_times_four(x: int) -> int {\n }\n ```\n \n-We're calling this file `lib.rs` because it has the same name as our project,\n-and so it's named this, by convention.\n+We're calling this file `lib.rs`, because Cargo uses that filename as the crate\n+root by convention.\n \n We'll then need to use this crate in our `src/main.rs`:\n \n@@ -3174,7 +3246,7 @@ fn math_checks_out() {\n \n Let's give it a run:\n \n-```{ignore,notrust}\n+```bash\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n      Running target/lib-654ce120f310a3a5\n@@ -3206,8 +3278,8 @@ test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n Great! One test passed. We've got an integration test showing that our public\n method works, but maybe we want to test some of the internal logic as well.\n While this function is simple, if it were more complicated, you can imagine\n-we'd need more tests. So let's break it up into two helper functions, and\n-write some unit tests to test those.\n+we'd need more tests. Let's break it up into two helper functions and write\n+some unit tests to test those.\n \n Change your `src/lib.rs` to look like this:\n \n@@ -3223,7 +3295,7 @@ fn times_four(x: int) -> int { x * 4 }\n \n If you run `cargo test`, you should get the same output:\n \n-```{ignore,notrust}\n+```bash\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n      Running target/lib-654ce120f310a3a5\n@@ -3277,7 +3349,7 @@ fn test_add_three() {\n \n We'd get this error:\n \n-```{notrust,ignore}\n+```text\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n /home/you/projects/testing/tests/lib.rs:3:5: 3:24 error: function `add_three` is private\n /home/you/projects/testing/tests/lib.rs:3 use testing::add_three;\n@@ -3319,7 +3391,7 @@ mod test {\n \n Let's give it a shot:\n \n-```{ignore,notrust}\n+```bash\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n      Running target/lib-654ce120f310a3a5\n@@ -3449,14 +3521,14 @@ let y = &mut x;\n \n Rust will complain:\n \n-```{ignore,notrust}\n+```text\n error: cannot borrow immutable local variable `x` as mutable\n  let y = &mut x;\n               ^\n ```\n \n We don't want a mutable reference to immutable data! This error message uses a\n-term we haven't talked about yet, 'borrow.' We'll get to that in just a moment.\n+term we haven't talked about yet, 'borrow'. We'll get to that in just a moment.\n \n This simple example actually illustrates a lot of Rust's power: Rust has\n prevented us, at compile time, from breaking our own rules. Because Rust's\n@@ -3476,7 +3548,7 @@ let z = &mut x;\n \n It gives us this error:\n \n-```{notrust,ignore}\n+```text\n error: cannot borrow `x` as mutable more than once at a time\n      let z = &mut x;\n                   ^\n@@ -3577,9 +3649,10 @@ all of Rust. Let's see this syntax in action:\n fn foo(x: &int) -> &int { x }\n \n {\n-    let x = 5i; // x is the owner of this integer, which is memory on the stack.\n+    // x is the owner of the integer, which is memory on the stack.\n+    let x = 5i;\n \n-    // privilege 2: you may lend that resource, to as many borrowers as you'd like\n+    // privilege 2: you may lend that resource to as many borrowers as you like\n     let y = &x;\n     let z = &x;\n \n@@ -3589,10 +3662,11 @@ fn foo(x: &int) -> &int { x }\n }\n \n {\n-    let mut x = 5i; // x is the owner of this integer, which is memory on the stack.\n+    // x is the owner of this integer, which is memory on the stack.\n+    let mut x = 5i;\n \n-    let y = &mut x; // privilege 3: you may lend that resource to a single borrower,\n-                    // mutably\n+    // privilege 3: you may lend that resource to a single borrower, mutably\n+    let y = &mut x;\n }\n ```\n \n@@ -3608,7 +3682,7 @@ This last requirement can seem odd, but it also makes sense. If you have to\n return something, and you've lent it to someone, they need to give it back to\n you for you to give it back! If we didn't, then the owner could deallocate\n the memory, and the person we've loaned it out to would have a pointer to\n-invalid memory. This is called a 'dangling pointer.'\n+invalid memory. This is called a 'dangling pointer'.\n \n Let's re-examine the error that led us to talk about all of this, which was a\n violation of the restrictions placed on owners who lend something out mutably.\n@@ -3622,7 +3696,7 @@ let z = &mut x;\n \n The error:\n \n-```{notrust,ignore}\n+```text\n error: cannot borrow `x` as mutable more than once at a time\n      let z = &mut x;\n                   ^\n@@ -3640,7 +3714,7 @@ note: previous borrow ends here\n \n This error comes in three parts. Let's go over each in turn.\n \n-```{notrust,ignore}\n+```text\n error: cannot borrow `x` as mutable more than once at a time\n      let z = &mut x;\n                   ^\n@@ -3649,7 +3723,7 @@ error: cannot borrow `x` as mutable more than once at a time\n This error states the restriction: you cannot lend out something mutable more\n than once at the same time. The borrow checker knows the rules!\n \n-```{notrust,ignore}\n+```text\n note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends\n      let y = &mut x;\n                   ^\n@@ -3661,7 +3735,7 @@ the first mutable borrow occurred. The error showed us the second. So now we\n see both parts of the problem. It also alludes to rule #3, by reminding us that\n we can't change `x` until the borrow is over.\n \n-```{notrust,ignore}\n+```text\n note: previous borrow ends here\n  fn main() {\n      let mut x = 5i;\n@@ -3675,8 +3749,8 @@ Here's the second note, which lets us know where the first borrow would be over.\n This is useful, because if we wait to try to borrow `x` after this borrow is\n over, then everything will work.\n \n-For more advanced patterns, please consult the [Lifetime\n-Guide](guide-lifetimes.html).  You'll also learn what this type signature with\n+For more advanced patterns, please consult the [Ownership\n+Guide](guide-ownership.html).  You'll also learn what this type signature with\n the `'a` syntax is:\n \n ```{rust,ignore}\n@@ -3731,8 +3805,8 @@ an integer `5` and makes `x` a pointer to it:\n ```\n \n The great thing about boxes is that we don't have to manually free this\n-allocation! Instead, when `x` reaches the end of its lifetime -- in this case,\n-when it goes out of scope at the end of the block -- Rust `free`s `x`. This\n+allocation! Instead, when `x` reaches the end of its lifetime \u2013 in this case,\n+when it goes out of scope at the end of the block \u2013 Rust `free`s `x`. This\n isn't because Rust has a garbage collector (it doesn't). Instead, by tracking\n the ownership and lifetime of a variable (with a little help from you, the\n programmer), the compiler knows precisely when it is no longer used.\n@@ -3764,7 +3838,7 @@ let y = &mut x;\n \n This gives us this error:\n \n-```{notrust,ignore}\n+```text\n error: cannot use `*x` because it was mutably borrowed\n  *x;\n  ^~\n@@ -3797,12 +3871,12 @@ Sometimes you need a variable that is referenced from multiple places\n (immutably!), lasting as long as any of those places, and disappearing when it\n is no longer referenced. For instance, in a graph-like data structure, a node\n might be referenced from all of its neighbors. In this case, it is not possible\n-for the compiler to determine ahead of time when the value can be freed -- it\n+for the compiler to determine ahead of time when the value can be freed \u2013 it\n needs a little run-time support.\n \n Rust's **Rc** type provides shared ownership of a dynamically allocated value\n that is automatically freed at the end of its last owner's lifetime. (`Rc`\n-stands for 'reference counted,' referring to the way these library types are\n+stands for 'reference counted', referring to the way these library types are\n implemented.) This provides more flexibility than single-owner boxes, but has\n some runtime overhead.\n \n@@ -3933,7 +4007,7 @@ match x {\n }\n ```\n \n-Here, the `val` inside the `match` has type `int`. In other words, the left hand\n+Here, the `val` inside the `match` has type `int`. In other words, the left-hand\n side of the pattern destructures the value. If we have `&5i`, then in `&val`, `val`\n would be `5i`.\n \n@@ -3991,6 +4065,35 @@ match origin {\n }\n ```\n \n+You can do this kind of match on any member, not just the first:\n+\n+```{rust}\n+# #![allow(non_shorthand_field_patterns)]\n+struct Point {\n+    x: int,\n+    y: int,\n+}\n+\n+let origin = Point { x: 0i, y: 0i };\n+\n+match origin {\n+    Point { y: y, .. } => println!(\"y is {}\", y),\n+}\n+```\n+\n+If you want to match against a slice or array, you can use `[]`:\n+\n+```{rust}\n+fn main() {\n+    let v = vec![\"match_this\", \"1\"];\n+\n+    match v.as_slice() {\n+        [\"match_this\", second] => println!(\"The second element is {}\", second),\n+        _ => {},\n+    }\n+}\n+```\n+\n Whew! That's a lot of different ways to match things, and they can all be\n mixed and matched, depending on what you're doing:\n \n@@ -4151,36 +4254,16 @@ fn main() {\n }\n ```\n \n-## Procs\n-\n-Rust has a second type of closure, called a **proc**. Procs are created\n-with the `proc` keyword:\n-\n-```{rust}\n-let x = 5i;\n-\n-let p = proc() { x * x };\n-println!(\"{}\", p()); // prints 25\n-```\n-\n-There is a big difference between procs and closures: procs may only be called once. This\n-will error when we try to compile:\n-\n-```{rust,ignore}\n-let x = 5i;\n-\n-let p = proc() { x * x };\n-println!(\"{}\", p());\n-println!(\"{}\", p()); // error: use of moved value `p`\n-```\n-\n-This restriction is important. Procs are allowed to consume values that they\n-capture, and thus have to be restricted to being called once for soundness\n-reasons: any value consumed would be invalid on a second call.\n+## Moving closures\n \n-Procs are most useful with Rust's concurrency features, and so we'll just leave\n-it at this for now. We'll talk about them more in the \"Tasks\" section of the\n-guide.\n+Rust has a second type of closure, called a **moving closure**. Moving\n+closures are indicated using the `move` keyword (e.g., `move || x *\n+x`). The difference between a moving closure and an ordinary closure\n+is that a moving closure always takes ownership of all variables that\n+it uses. Ordinary closures, in contrast, just create a reference into\n+the enclosing stack frame. Moving closures are most useful with Rust's\n+concurrency features, and so we'll just leave it at this for\n+now. We'll talk about them more in the \"Tasks\" section of the guide.\n \n ## Accepting closures as arguments\n \n@@ -4215,7 +4298,7 @@ This line is more interesting. Here, we call our function, `twice`, and we pass\n it two arguments: an integer, `5`, and our closure, `square`. This is just like\n passing any other two variable bindings to a function, but if you've never\n worked with closures before, it can seem a little complex. Just think: \"I'm\n-passing two variables, one is an int, and one is a function.\"\n+passing two variables: one is an int, and one is a function.\"\n \n Next, let's look at how `twice` is defined:\n \n@@ -4251,7 +4334,7 @@ fn twice(x: int, f: |int| -> int) -> int {\n ```\n \n Since our closure is named `f`, we can call it just like we called our closures\n-before. And we pass in our `x` argument to each one. Hence 'twice.'\n+before, and we pass in our `x` argument to each one, hence the name `twice`.\n \n If you do the math, `(5 * 5) + (5 * 5) == 50`, so that's the output we get.\n \n@@ -4354,7 +4437,7 @@ for i in range(0u, nums.len()) {\n ```\n \n This is strictly worse than using an actual iterator. The `.iter()` method on\n-vectors returns an iterator which iterates through a reference to each element\n+vectors returns an iterator that iterates through a reference to each element\n of the vector in turn. So write this:\n \n ```{rust}\n@@ -4560,7 +4643,7 @@ element reference has the closure it's been given as an argument called on it.\n So this would give us the numbers from `2-100`. Well, almost! If you\n compile the example, you'll get a warning:\n \n-```{notrust,ignore}\n+```text\n warning: unused result which must be used: iterator adaptors are lazy and\n          do nothing unless consumed, #[warn(unused_must_use)] on by default\n  range(1i, 100i).map(|x| x + 1i);\n@@ -4590,7 +4673,7 @@ for i in std::iter::count(1i, 5i).take(5) {\n \n This will print\n \n-```{notrust,ignore}\n+```text\n 1\n 6\n 11\n@@ -4681,7 +4764,7 @@ let x: Option<int> = Some(5i);\n \n In the type declaration, we say `Option<int>`. Note how similar this looks to\n `Option<T>`. So, in this particular `Option`, `T` has the value of `int`. On\n-the right hand side of the binding, we do make a `Some(T)`, where `T` is `5i`.\n+the right-hand side of the binding, we do make a `Some(T)`, where `T` is `5i`.\n Since that's an `int`, the two sides match, and Rust is happy. If they didn't\n match, we'd get an error:\n \n@@ -4722,7 +4805,7 @@ enum Result<H, N> {\n ```\n \n if we wanted to. Convention says that the first generic parameter should be\n-`T`, for 'type,' and that we use `E` for 'error.' Rust doesn't care, however.\n+`T`, for 'type,' and that we use `E` for 'error'. Rust doesn't care, however.\n \n The `Result<T, E>` type is intended to\n be used to return the result of a computation, and to have the ability to\n@@ -4803,7 +4886,7 @@ We can then use `T` inside the rest of the signature: `x` has type `T`, and half\n of the `Result` has type `T`. However, if we try to compile that example, we'll get\n an error:\n \n-```{notrust,ignore}\n+```text\n error: binary operation `==` cannot be applied to type `T`\n ```\n \n@@ -4859,7 +4942,7 @@ we use `impl Trait for Item`, rather than just `impl Item`.\n So what's the big deal? Remember the error we were getting with our generic\n `inverse` function?\n \n-```{notrust,ignore}\n+```text\n error: binary operation `==` cannot be applied to type `T`\n ```\n \n@@ -4874,7 +4957,7 @@ fn print_area<T>(shape: T) {\n \n Rust complains:\n \n-```{notrust,ignore}\n+```text\n error: type `T` does not implement any method in scope named `area`\n ```\n \n@@ -4950,7 +5033,7 @@ fn main() {\n \n This program outputs:\n \n-```{notrust,ignore}\n+```text\n This shape has an area of 3.141593\n This shape has an area of 1\n ```\n@@ -4964,7 +5047,7 @@ print_area(5i);\n \n We get a compile-time error:\n \n-```{notrust,ignore}\n+```text\n error: failed to find an implementation of trait main::HasArea for int\n ```\n \n@@ -5031,7 +5114,7 @@ fn main() {\n Now that we've moved the structs and traits into their own module, we get an\n error:\n \n-```{notrust,ignore}\n+```text\n error: type `shapes::Circle` does not implement any method in scope named `area`\n ```\n \n@@ -5127,57 +5210,61 @@ fn main() {\n \n The names don't actually change to this, it's just for illustration. But\n as you can see, there's no overhead of deciding which version to call here,\n-hence 'statically dispatched.' The downside is that we have two copies of\n+hence 'statically dispatched'. The downside is that we have two copies of\n the same function, so our binary is a little bit larger.\n \n # Tasks\n \n+**NOTE**: this section is currently out of date and will be rewritten soon.\n+\n Concurrency and parallelism are topics that are of increasing interest to a\n broad subsection of software developers. Modern computers are often multi-core,\n to the point that even embedded devices like cell phones have more than one\n processor. Rust's semantics lend themselves very nicely to solving a number of\n issues that programmers have with concurrency. Many concurrency errors that are\n runtime errors in other languages are compile-time errors in Rust.\n \n-Rust's concurrency primitive is called a **task**. Tasks are lightweight, and\n-do not share memory in an unsafe manner, preferring message passing to\n-communicate.  It's worth noting that tasks are implemented as a library, and\n-not part of the language.  This means that in the future, other concurrency\n-libraries can be written for Rust to help in specific scenarios.  Here's an\n-example of creating a task:\n+Rust's concurrency primitive is called a **task**. Tasks are similar to\n+threads, and do not share memory in an unsafe manner, preferring message\n+passing to communicate. It's worth noting that tasks are implemented as a\n+library, and not part of the language. This means that in the future, other\n+concurrency libraries can be written for Rust to help in specific scenarios.\n+Here's an example of creating a task:\n \n-```{rust}\n-spawn(proc() {\n+```{rust,ignore}\n+spawn(move || {\n     println!(\"Hello from a task!\");\n });\n ```\n \n-The `spawn` function takes a proc as an argument, and runs that proc in a new\n-task. A proc takes ownership of its entire environment, and so any variables\n-that you use inside the proc will not be usable afterward:\n+The `spawn` function takes a closure as an argument, and runs that\n+closure in a new task. Typically, you will want to use a moving\n+closure, so that the closure takes ownership of any variables that it\n+touches.  This implies that those variables are not usable from the\n+parent task after the child task is spawned:\n \n ```{rust,ignore}\n let mut x = vec![1i, 2i, 3i];\n \n-spawn(proc() {\n+spawn(move || {\n     println!(\"The value of x[0] is: {}\", x[0]);\n });\n \n println!(\"The value of x[0] is: {}\", x[0]); // error: use of moved value: `x`\n ```\n \n-`x` is now owned by the proc, and so we can't use it anymore. Many other\n-languages would let us do this, but it's not safe to do so. Rust's borrow\n-checker catches the error.\n+`x` is now owned by the closure, and so we can't use it anymore. Many\n+other languages would let us do this, but it's not safe to do\n+so. Rust's borrow checker catches the error.\n \n If tasks were only able to capture these values, they wouldn't be very useful.\n Luckily, tasks can communicate with each other through **channel**s. Channels\n work like this:\n \n-```{rust}\n+```{rust,ignore}\n let (tx, rx) = channel();\n \n-spawn(proc() {\n+spawn(move || {\n     tx.send(\"Hello from a task!\".to_string());\n });\n \n@@ -5193,11 +5280,11 @@ which returns an `Result<T, TryRecvError>` and does not block.\n \n If you want to send messages to the task as well, create two channels!\n \n-```{rust}\n+```{rust,ignore}\n let (tx1, rx1) = channel();\n let (tx2, rx2) = channel();\n \n-spawn(proc() {\n+spawn(move || {\n     tx1.send(\"Hello from a task!\".to_string());\n     let message = rx2.recv();\n     println!(\"{}\", message);\n@@ -5209,8 +5296,9 @@ println!(\"{}\", message);\n tx2.send(\"Goodbye from main!\".to_string());\n ```\n \n-The proc has one sending end and one receiving end, and the main task has one\n-of each as well. Now they can talk back and forth in whatever way they wish.\n+The closure has one sending end and one receiving end, and the main\n+task has one of each as well. Now they can talk back and forth in\n+whatever way they wish.\n \n Notice as well that because `Sender` and `Receiver` are generic, while you can\n pass any kind of information through the channel, the ends are strongly typed.\n@@ -5226,46 +5314,46 @@ a useful thing to use:\n ```{rust}\n use std::sync::Future;\n \n-let mut delayed_value = Future::spawn(proc() {\n+let mut delayed_value = Future::spawn(move || {\n     // just return anything for examples' sake\n \n     12345i\n });\n println!(\"value = {}\", delayed_value.get());\n ```\n \n-Calling `Future::spawn` works just like `spawn()`: it takes a proc. In this\n-case, though, you don't need to mess with the channel: just have the proc\n-return the value.\n+Calling `Future::spawn` works just like `spawn()`: it takes a\n+closure. In this case, though, you don't need to mess with the\n+channel: just have the closure return the value.\n \n `Future::spawn` will return a value which we can bind with `let`. It needs\n to be mutable, because once the value is computed, it saves a copy of the\n value, and if it were immutable, it couldn't update itself.\n \n-The proc will go on processing in the background, and when we need the final\n-value, we can call `get()` on it. This will block until the result is done,\n-but if it's finished computing in the background, we'll just get the value\n-immediately.\n+The future will go on processing in the background, and when we need\n+the final value, we can call `get()` on it. This will block until the\n+result is done, but if it's finished computing in the background,\n+we'll just get the value immediately.\n \n ## Success and failure\n \n-Tasks don't always succeed, they can also panic. A task that wishes to panic \n+Tasks don't always succeed, they can also panic. A task that wishes to panic\n can call the `panic!` macro, passing a message:\n \n-```{rust}\n-spawn(proc() {\n+```{rust,ignore}\n+spawn(move || {\n     panic!(\"Nope.\");\n });\n ```\n \n If a task panics, it is not possible for it to recover. However, it can\n notify other tasks that it has panicked. We can do this with `task::try`:\n \n-```{rust}\n+```{rust,ignore}\n use std::task;\n use std::rand;\n \n-let result = task::try(proc() {\n+let result = task::try(move || {\n     if rand::random() {\n         println!(\"OK\");\n     } else {\n@@ -5322,7 +5410,7 @@ fn main() {\n }\n ```\n \n-You can have the macros expanded like this: `rustc print.rs --pretty=expanded` \u2013 which will\n+You can have the macros expanded like this: `rustc print.rs --pretty=expanded`, which will\n give us this huge result:\n \n ```{rust,ignore}\n@@ -5408,7 +5496,6 @@ We covered a lot of ground here. When you've mastered everything in this Guide,\n you will have a firm grasp of basic Rust development. There's a whole lot more\n out there, we've just covered the surface. There's tons of topics that you can\n dig deeper into, and we've built specialized guides for many of them. To learn\n-more, dig into the [full documentation\n-index](index.html).\n+more, dig into the [full documentation index](index.html).\n \n Happy hacking!"}, {"sha": "779099558220a9e96cfc7b1a4d02707e4cdf6a49", "filename": "src/doc/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -54,9 +54,9 @@ Rust Guides are in-depth looks at a particular topic that's relevant to Rust\n development. If you're trying to figure out how to do something, there may be\n a guide that can help you out:\n \n+* [Ownership](guide-ownership.html)\n * [Strings](guide-strings.html)\n * [Pointers](guide-pointers.html)\n-* [References and Lifetimes](guide-lifetimes.html)\n * [Crates and modules](guide-crates.html)\n * [Tasks and Communication](guide-tasks.html)\n * [Error Handling](guide-error-handling.html)"}, {"sha": "5be97034357eb11dde654053571898fa2cc9a924", "filename": "src/doc/intro.md", "status": "modified", "additions": 53, "deletions": 37, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -58,13 +58,13 @@ authors = [\"Your Name <you@example.com>\"]\n ```\n \n This is called a **manifest**, and it contains all of the metadata that Cargo\n-needs to compile your project. \n+needs to compile your project.\n \n Here's what's in `src/main.rs`:\n \n ```{rust}\n fn main() {\n-    println!(\"Hello, world!\")\n+    println!(\"Hello, world!\");\n }\n ```\n \n@@ -155,13 +155,13 @@ when you have unrestricted access to memory. As an example, here's some Ruby\n code:\n \n ```{ruby}\n-v = [];\n+v = []\n \n-v.push(\"Hello\");\n+v.push(\"Hello\")\n \n-x = v[0];\n+x = v[0]\n \n-v.push(\"world\");\n+v.push(\"world\")\n \n puts x\n ```\n@@ -207,7 +207,7 @@ and two...\n \n ```{bash}\n $ g++ hello.cpp -Wall -Werror\n-$ ./a.out \n+$ ./a.out\n Segmentation fault (core dumped)\n ```\n \n@@ -313,7 +313,7 @@ print `\"Hello\"`, or does Rust crash?\n \n Neither. It refuses to compile:\n \n-```{notrust,ignore}\n+```bash\n $ cargo run\n    Compiling hello_world v0.0.1 (file:///Users/you/src/hello_world)\n main.rs:8:5: 8:6 error: cannot borrow `v` as mutable because it is also borrowed as immutable\n@@ -389,63 +389,76 @@ safe concurrent programs.\n Here's an example of a concurrent Rust program:\n \n ```{rust}\n+use std::thread::Thread;\n+\n fn main() {\n     for _ in range(0u, 10u) {\n-        spawn(proc() {\n+        Thread::spawn(move || {\n             println!(\"Hello, world!\");\n-        });\n+        }).detach();\n     }\n }\n ```\n \n-This program creates ten threads, who all print `Hello, world!`. The `spawn`\n-function takes one argument, a `proc`. 'proc' is short for 'procedure,' and is\n-a form of closure. This closure is executed in a new thread, created by `spawn`\n-itself.\n-\n-One common form of problem in concurrent programs is a 'data race.' This occurs\n-when two different threads attempt to access the same location in memory in a\n-non-synchronized way, where at least one of them is a write. If one thread is\n-attempting to read, and one thread is attempting to write, you cannot be sure\n-that your data will not be corrupted. Note the first half of that requirement:\n-two threads that attempt to access the same location in memory. Rust's\n-ownership model can track which pointers own which memory locations, which\n-solves this problem.\n+This program creates ten threads, who all print `Hello, world!`. The\n+`spawn` function takes one argument, a closure, indicated by the\n+double bars `||`. (The `move` keyword indicates that the closure takes\n+ownership of any data it uses; we'll have more on the significance of\n+this shortly.) This closure is executed in a new thread created by\n+`spawn`. The `detach` method means that the child thread is allowed to\n+outlive its parent.\n+\n+One common form of problem in concurrent programs is a 'data race.'\n+This occurs when two different threads attempt to access the same\n+location in memory in a non-synchronized way, where at least one of\n+them is a write. If one thread is attempting to read, and one thread\n+is attempting to write, you cannot be sure that your data will not be\n+corrupted. Note the first half of that requirement: two threads that\n+attempt to access the same location in memory. Rust's ownership model\n+can track which pointers own which memory locations, which solves this\n+problem.\n \n Let's see an example. This Rust code will not compile:\n \n ```{rust,ignore}\n+use std::thread::Thread;\n+\n fn main() {\n     let mut numbers = vec![1i, 2i, 3i];\n \n     for i in range(0u, 3u) {\n-        spawn(proc() {\n+        Thread::spawn(move || {\n             for j in range(0, 3) { numbers[j] += 1 }\n-        });\n+        }).detach();\n     }\n }\n ```\n \n It gives us this error:\n \n-```{notrust,ignore}\n+```text\n 6:71 error: capture of moved value: `numbers`\n     for j in range(0, 3) { numbers[j] += 1 }\n                ^~~~~~~\n-7:50 note: `numbers` moved into closure environment here because it has type `proc():Send`, which is non-copyable (perhaps you meant to use clone()?)\n-    spawn(proc() {\n+7:50 note: `numbers` moved into closure environment here\n+    spawn(move || {\n         for j in range(0, 3) { numbers[j] += 1 }\n     });\n 6:79 error: cannot assign to immutable dereference (dereference is implicit, due to indexing)\n         for j in range(0, 3) { numbers[j] += 1 }\n                            ^~~~~~~~~~~~~~~\n ```\n \n-It mentions that \"numbers moved into closure environment\". Because we referred\n-to `numbers` inside of our `proc`, and we create three `proc`s, we would have\n-three references. Rust detects this and gives us the error: we claim that\n-`numbers` has ownership, but our code tries to make three owners. This may\n-cause a safety problem, so Rust disallows it.\n+It mentions that \"numbers moved into closure environment\". Because we\n+declared the closure as a moving closure, and it referred to\n+`numbers`, the closure will try to take ownership of the vector. But\n+the closure itself is created in a loop, and hence we will actually\n+create three closures, one for every iteration of the loop. This means\n+that all three of those closures would try to own `numbers`, which is\n+impossible -- `numbers` must have just one owner. Rust detects this\n+and gives us the error: we claim that `numbers` has ownership, but our\n+code tries to make three owners. This may cause a safety problem, so\n+Rust disallows it.\n \n What to do here? Rust has two types that helps us: `Arc<T>` and `Mutex<T>`.\n \"Arc\" stands for \"atomically reference counted.\" In other words, an Arc will\n@@ -461,20 +474,21 @@ mutation doesn't cause a data race.\n Here's what using an Arc with a Mutex looks like:\n \n ```{rust}\n+use std::thread::Thread;\n use std::sync::{Arc,Mutex};\n \n fn main() {\n     let numbers = Arc::new(Mutex::new(vec![1i, 2i, 3i]));\n \n     for i in range(0u, 3u) {\n         let number = numbers.clone();\n-        spawn(proc() {\n+        Thread::spawn(move || {\n             let mut array = number.lock();\n \n             (*array)[i] += 1;\n \n             println!(\"numbers[{}] is {}\", i, (*array)[i]);\n-        });\n+        }).detach();\n     }\n }\n ```\n@@ -524,13 +538,15 @@ As an example, Rust's ownership system is _entirely_ at compile time. The\n safety check that makes this an error about moved values:\n \n ```{rust,ignore}\n+use std::thread::Thread;\n+\n fn main() {\n     let vec = vec![1i, 2, 3];\n \n     for i in range(1u, 3) {\n-        spawn(proc() {\n+        Thread::spawn(move || {\n             println!(\"{}\", vec[i]);\n-        });\n+        }).detach();\n     }\n }\n ```"}, {"sha": "4fbb3c210165ad830847722243e52264f7b57f18", "filename": "src/doc/po4a.conf", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Fdoc%2Fpo4a.conf", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Fdoc%2Fpo4a.conf", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo4a.conf?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e", "patch": "@@ -1,29 +0,0 @@\n-# Add here a list of target languages; po4a will automatically\n-# generates .po for them and build .md when translated, eg:\n-# [po4a_langs] es fr it pt_BR\n-[po4a_langs] ja\n-[po4a_paths] doc/po/$master.pot $lang:src/doc/po/$lang/$master.po\n-\n-# Add here below all source documents to be translated\n-[type: text] src/doc/complement-bugreport.md $lang:doc/l10n/$lang/complement-bugreport.md\n-[type: text] src/doc/complement-design-faq.md $lang:doc/l10n/$lang/complement-design-faq.md\n-[type: text] src/doc/complement-lang-faq.md $lang:doc/l10n/$lang/complement-lang-faq.md\n-[type: text] src/doc/complement-project-faq.md $lang:doc/l10n/$lang/complement-project-faq.md\n-[type: text] src/doc/guide-container.md $lang:doc/l10n/$lang/guide-container.md\n-[type: text] src/doc/guide-ffi.md $lang:doc/l10n/$lang/guide-ffi.md\n-[type: text] src/doc/guide-lifetimes.md $lang:doc/l10n/$lang/guide-lifetimes.md\n-[type: text] src/doc/guide-macros.md $lang:doc/l10n/$lang/guide-macros.md\n-[type: text] src/doc/guide-plugin.md $lang:doc/l10n/$lang/guide-plugin.md\n-[type: text] src/doc/guide-pointers.md $lang:doc/l10n/$lang/guide-pointers.md\n-[type: text] src/doc/guide-strings.md $lang:doc/l10n/$lang/guide-strings.md\n-[type: text] src/doc/guide-tasks.md $lang:doc/l10n/$lang/guide-tasks.md\n-[type: text] src/doc/guide-testing.md $lang:doc/l10n/$lang/guide-testing.md\n-[type: text] src/doc/guide-unsafe.md $lang:doc/l10n/$lang/guide-unsafe.md\n-[type: text] src/doc/guide-crates.md $lang:doc/l10n/$lang/guide-crates.md\n-[type: text] src/doc/guide-error-handling.md $lang:doc/l10n/$lang/guide-error-handling.md\n-[type: text] src/doc/guide.md $lang:doc/l10n/$lang/guide.md\n-[type: text] src/doc/index.md $lang:doc/l10n/$lang/index.md\n-[type: text] src/doc/intro.md $lang:doc/l10n/$lang/intro.md\n-[type: text] src/doc/rust.md $lang:doc/l10n/$lang/rust.md\n-[type: text] src/doc/rustdoc.md $lang:doc/l10n/$lang/rustdoc.md\n-[type: text] src/doc/guide.md $lang:doc/l10n/$lang/guide.md"}, {"sha": "97184d534983c48fc16ffc7489448da7d221447a", "filename": "src/doc/reference.md", "status": "modified", "additions": 62, "deletions": 76, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -187,19 +187,18 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n \n <p id=\"keyword-table-marker\"></p>\n \n-|          |          |          |          |        |\n-|----------|----------|----------|----------|--------|\n-| abstract | alignof  | as       | be       | box    |\n-| break    | const    | continue | crate    | do     |\n-| else     | enum     | extern   | false    | final  |\n-| fn       | for      | if       | impl     | in     |\n-| let      | loop     | match    | mod      | move   |\n-| mut      | offsetof | once     | override | priv   |\n-| proc     | pub      | pure     | ref      | return |\n-| sizeof   | static   | self     | struct   | super  |\n-| true     | trait    | type     | typeof   | unsafe |\n-| unsized  | use      | virtual  | where    | while  |\n-| yield    |          |          |          |        |\n+|          |          |          |          |         |\n+|----------|----------|----------|----------|---------|\n+| abstract | alignof  | as       | be       | box     |\n+| break    | const    | continue | crate    | do      |\n+| else     | enum     | extern   | false    | final   |\n+| fn       | for      | if       | impl     | in      |\n+| let      | loop     | match    | mod      | move    |\n+| mut      | offsetof | once     | override | priv    |\n+| pub      | pure     | ref      | return   | sizeof  |\n+| static   | self     | struct   | super    | true    |\n+| trait    | type     | typeof   | unsafe   | unsized |\n+| use      | virtual  | where    | while    | yield   |\n \n \n Each of these keywords has special meaning in its grammar, and all of them are\n@@ -496,9 +495,8 @@ Examples of integer literals of various forms:\n \n A _floating-point literal_ has one of two forms:\n \n-* Two _decimal literals_ separated by a period\n-  character `U+002E` (`.`), with an optional _exponent_ trailing after the\n-  second decimal literal.\n+* A _decimal literal_ followed by a period character `U+002E` (`.`). This is\n+  optionally followed by another decimal literal, with an optional _exponent_.\n * A single _decimal literal_ followed by an _exponent_.\n \n By default, a floating-point literal has a generic type, and, like integer\n@@ -509,20 +507,25 @@ types), which explicitly determine the type of the literal.\n Examples of floating-point literals of various forms:\n \n ```\n-123.0f64;                          // type f64\n-0.1f64;                            // type f64\n-0.1f32;                            // type f32\n-12E+99_f64;                        // type f64\n+123.0f64;        // type f64\n+0.1f64;          // type f64\n+0.1f32;          // type f32\n+12E+99_f64;      // type f64\n+let x: f64 = 2.; // type f64\n ```\n \n-##### Boolean literals\n+This last example is different because it is not possible to use the suffix\n+syntax with a floating point literal ending in a period. `2.f64` would attempt\n+to call a method named `f64` on `2`.\n+\n+#### Boolean literals\n \n The two values of the boolean type are written `true` and `false`.\n \n ### Symbols\n \n ```{.ebnf .gram}\n-symbol : \"::\" \"->\"\n+symbol : \"::\" | \"->\"\n        | '#' | '[' | ']' | '(' | ')' | '{' | '}'\n        | ',' | ';' ;\n ```\n@@ -777,13 +780,8 @@ metadata that influences the behavior of the compiler.\n \n ```{.rust}\n # #![allow(unused_attribute)]\n-// Crate ID\n-#![crate_id = \"projx#2.5\"]\n-\n-// Additional metadata attributes\n-#![desc = \"Project X\"]\n-#![license = \"BSD\"]\n-#![comment = \"This is a comment on Project X.\"]\n+// Crate name\n+#![crate_name = \"projx\"]\n \n // Specify the output type\n #![crate_type = \"lib\"]\n@@ -936,7 +934,7 @@ kinds of view items:\n \n ```{.ebnf .gram}\n extern_crate_decl : \"extern\" \"crate\" crate_name\n-crate_name: ident | ( string_lit as ident )\n+crate_name: ident | ( string_lit \"as\" ident )\n ```\n \n An _`extern crate` declaration_ specifies a dependency on an external crate.\n@@ -999,7 +997,7 @@ An example of `use` declarations:\n \n ```\n use std::iter::range_step;\n-use std::option::{Some, None};\n+use std::option::Option::{Some, None};\n use std::collections::hash_map::{mod, HashMap};\n \n fn foo<T>(_: T){}\n@@ -1009,8 +1007,8 @@ fn main() {\n     // Equivalent to 'std::iter::range_step(0u, 10u, 2u);'\n     range_step(0u, 10u, 2u);\n \n-    // Equivalent to 'foo(vec![std::option::Some(1.0f64),\n-    // std::option::None]);'\n+    // Equivalent to 'foo(vec![std::option::Option::Some(1.0f64),\n+    // std::option::Option::None]);'\n     foo(vec![Some(1.0f64), None]);\n \n     // Both `hash_map` and `HashMap` are in scope.\n@@ -1319,10 +1317,10 @@ let fptr: extern \"C\" fn() -> int = new_int;\n Extern functions may be called directly from Rust code as Rust uses large,\n contiguous stack segments like C.\n \n-### Type definitions\n+### Type aliases\n \n-A _type definition_ defines a new name for an existing [type](#types). Type\n-definitions are declared with the keyword `type`. Every value has a single,\n+A _type alias_ defines a new name for an existing [type](#types). Type\n+aliases are declared with the keyword `type`. Every value has a single,\n specific type; the type-specified aspects of a value include:\n \n * Whether the value is composed of sub-values or is indivisible.\n@@ -1334,7 +1332,12 @@ specific type; the type-specified aspects of a value include:\n For example, the type `(u8, u8)` defines the set of immutable values that are\n composite pairs, each containing two unsigned 8-bit integers accessed by\n pattern-matching and laid out in memory with the `x` component preceding the\n-`y` component.\n+`y` component:\n+\n+```\n+type Point = (u8, u8);\n+let p: Point = (41, 68);\n+```\n \n ### Structures\n \n@@ -1660,6 +1663,7 @@ Implementations are defined with the keyword `impl`.\n \n ```\n # struct Point {x: f64, y: f64};\n+# impl Copy for Point {}\n # type Surface = int;\n # struct BoundingBox {x: f64, y: f64, width: f64, height: f64};\n # trait Shape { fn draw(&self, Surface); fn bounding_box(&self) -> BoundingBox; }\n@@ -1669,6 +1673,8 @@ struct Circle {\n     center: Point,\n }\n \n+impl Copy for Circle {}\n+\n impl Shape for Circle {\n     fn draw(&self, s: Surface) { do_draw_circle(s, *self); }\n     fn bounding_box(&self) -> BoundingBox {\n@@ -1684,7 +1690,20 @@ methods in such an implementation can only be used as direct calls on the\n values of the type that the implementation targets. In such an implementation,\n the trait type and `for` after `impl` are omitted. Such implementations are\n limited to nominal types (enums, structs), and the implementation must appear\n-in the same module or a sub-module as the `self` type.\n+in the same module or a sub-module as the `self` type:\n+\n+```\n+struct Point {x: int, y: int}\n+\n+impl Point {\n+    fn log(&self) {\n+        println!(\"Point is at ({}, {})\", self.x, self.y);\n+    }\n+}\n+\n+let my_point = Point {x: 10, y:11};\n+my_point.log();\n+```\n \n When a trait _is_ specified in an `impl`, all methods declared as part of the\n trait must be implemented, with matching types and type parameter counts.\n@@ -1778,6 +1797,7 @@ default visibility with the `priv` keyword. When an item is declared as `pub`,\n it can be thought of as being accessible to the outside world. For example:\n \n ```\n+# #![allow(missing_copy_implementations)]\n # fn main() {}\n // Declare a private struct\n struct Foo;\n@@ -1943,7 +1963,7 @@ An example of attributes:\n \n ```{.rust}\n // General metadata applied to the enclosing module or crate.\n-#![license = \"BSD\"]\n+#![crate_type = \"lib\"]\n \n // A function marked as a unit test\n #[test]\n@@ -2528,10 +2548,6 @@ The currently implemented features of the reference compiler are:\n * `default_type_params` - Allows use of default type parameters. The future of\n                           this feature is uncertain.\n \n-* `if_let` - Allows use of the `if let` syntax.\n-\n-* `while_let` - Allows use of the `while let` syntax.\n-\n * `intrinsics` - Allows use of the \"rust-intrinsics\" ABI. Compiler intrinsics\n                  are inherently unstable and no promise about them is made.\n \n@@ -2618,8 +2634,6 @@ The currently implemented features of the reference compiler are:\n                         which is considered wildly unsafe and will be\n                         obsoleted by language improvements.\n \n-* `tuple_indexing` - Allows use of tuple indexing (expressions like `expr.0`)\n-\n * `associated_types` - Allows type aliases in traits. Experimental.\n \n If a feature is promoted to a language feature, then all existing programs will\n@@ -3124,8 +3138,8 @@ as\n ```\n \n Operators at the same precedence level are evaluated left-to-right. [Unary\n-operators](#unary-operator-expressions) have the same precedence level and it\n-is stronger than any of the binary operators'.\n+operators](#unary-operator-expressions) have the same precedence level and are\n+stronger than any of the binary operators.\n \n ### Grouped expressions\n \n@@ -3163,7 +3177,7 @@ Some examples of call expressions:\n # fn add(x: int, y: int) -> int { 0 }\n \n let x: int = add(1, 2);\n-let pi: Option<f32> = from_str(\"3.14\");\n+let pi: Option<f32> = \"3.14\".parse();\n ```\n \n ### Lambda expressions\n@@ -3821,8 +3835,6 @@ x = bo(5,7);\n ```{.ebnf .notation}\n closure_type := [ 'unsafe' ] [ '<' lifetime-list '>' ] '|' arg-list '|'\n                 [ ':' bound-list ] [ '->' type ]\n-procedure_type := 'proc' [ '<' lifetime-list '>' ] '(' arg-list ')'\n-                  [ ':' bound-list ] [ '->' type ]\n lifetime-list := lifetime | lifetime ',' lifetime-list\n arg-list := ident ':' type | ident ':' type ',' arg-list\n bound-list := bound | bound '+' bound-list\n@@ -3831,8 +3843,6 @@ bound := path | lifetime\n \n The type of a closure mapping an input of type `A` to an output of type `B` is\n `|A| -> B`. A closure with no arguments or return values has type `||`.\n-Similarly, a procedure mapping `A` to `B` is `proc(A) -> B` and a no-argument\n-and no-return value closure has type `proc()`.\n \n An example of creating and calling a closure:\n \n@@ -3855,30 +3865,6 @@ call_closure(closure_no_args, closure_args);\n \n ```\n \n-Unlike closures, procedures may only be invoked once, but own their\n-environment, and are allowed to move out of their environment. Procedures are\n-allocated on the heap (unlike closures). An example of creating and calling a\n-procedure:\n-\n-```rust\n-let string = \"Hello\".to_string();\n-\n-// Creates a new procedure, passing it to the `spawn` function.\n-spawn(proc() {\n-  println!(\"{} world!\", string);\n-});\n-\n-// the variable `string` has been moved into the previous procedure, so it is\n-// no longer usable.\n-\n-\n-// Create an invoke a procedure. Note that the procedure is *moved* when\n-// invoked, so it cannot be invoked again.\n-let f = proc(n: int) { n + 22 };\n-println!(\"answer: {}\", f(20));\n-\n-```\n-\n ### Object types\n \n Every trait item (see [traits](#traits)) defines a type with the same name as"}, {"sha": "128d75468e6f4239274d463943b91f784b7ca863", "filename": "src/doc/rust.css", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -1,5 +1,5 @@\n /**\n- * Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+ * Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n  * file at the top-level directory of this distribution and at\n  * http://rust-lang.org/COPYRIGHT.\n  * With elements taken from Bootstrap v3.0.2 (MIT licensed).\n@@ -209,7 +209,6 @@ pre {\n code {\n     padding: 0 2px;\n     color: #8D1A38;\n-    white-space: pre-wrap;\n }\n pre code {\n     padding: 0;"}, {"sha": "054552559dbec077fb5a1fd4533b3f0d40b83efb", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -210,11 +210,11 @@ that one can still write things like `#[deriving(Eq)]`).\n #\u00a0// what's actually being documented.\n #\u00a0fn fib(n: int) { n + 2 }\n \n-spawn(proc() { fib(200); })\n+spawn(move || { fib(200); })\n ```\n ~~~\n \n-The documentation online would look like `spawn(proc() { fib(200); })`, but when\n+The documentation online would look like `spawn(move || { fib(200); })`, but when\n testing this code, the `fib` function will be included (so it can compile).\n \n ## Running tests (advanced)"}, {"sha": "5c29cb4ec72760f3813ff1270b1c8b93d8005a58", "filename": "src/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![no_start]\n-\n #[cfg(rustdoc)]\n extern crate \"rustdoc\" as this;\n \n #[cfg(rustc)]\n-extern crate \"rustc_trans\" as this;\n+extern crate \"rustc_driver\" as this;\n \n fn main() { this::main() }"}, {"sha": "6917e9ee354eef895cb04b503371258f8b7daf2d", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -31,9 +31,6 @@\n     (modify-syntax-entry ?\\\" \"\\\"\" table)\n     (modify-syntax-entry ?\\\\ \"\\\\\" table)\n \n-    ;; _ is a word-char\n-    (modify-syntax-entry ?_ \"w\" table)\n-\n     ;; Comments\n     (modify-syntax-entry ?/  \". 124b\" table)\n     (modify-syntax-entry ?*  \". 23\"   table)\n@@ -177,7 +174,7 @@\n     \"if\" \"impl\" \"in\"\n     \"let\" \"loop\"\n     \"match\" \"mod\" \"move\" \"mut\"\n-    \"priv\" \"proc\" \"pub\"\n+    \"priv\" \"pub\"\n     \"ref\" \"return\"\n     \"self\" \"static\" \"struct\" \"super\"\n     \"true\" \"trait\" \"type\"\n@@ -397,7 +394,7 @@ This is written mainly to be used as `beginning-of-defun-function' for Rust.\n Don't move to the beginning of the line. `beginning-of-defun',\n which calls this, does that afterwards.\"\n   (interactive \"p\")\n-  (re-search-backward (concat \"^\\\\(\" rust-top-item-beg-re \"\\\\)\\\\b\")\n+  (re-search-backward (concat \"^\\\\(\" rust-top-item-beg-re \"\\\\)\\\\_>\")\n                       nil 'move (or arg 1)))\n \n (defun rust-end-of-defun ()"}, {"sha": "7e5918ea39e1edf6173bb397859f20727e69de57", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -54,21 +54,27 @@ def rust_pretty_printer_lookup_function(val):\n       return RustStructPrinter(val, false)\n \n     if enum_member_count == 1:\n-      if enum_members[0].name == None:\n+      first_variant_name = enum_members[0].name\n+      if first_variant_name == None:\n         # This is a singleton enum\n         return rust_pretty_printer_lookup_function(val[enum_members[0]])\n       else:\n-        assert enum_members[0].name.startswith(\"RUST$ENCODED$ENUM$\")\n+        assert first_variant_name.startswith(\"RUST$ENCODED$ENUM$\")\n         # This is a space-optimized enum\n-        last_separator_index = enum_members[0].name.rfind(\"$\")\n+        last_separator_index = first_variant_name.rfind(\"$\")\n         second_last_separator_index = first_variant_name.rfind(\"$\", 0, last_separator_index)\n         disr_field_index = first_variant_name[second_last_separator_index + 1 :\n                                               last_separator_index]\n         disr_field_index = int(disr_field_index)\n \n         sole_variant_val = val[enum_members[0]]\n         disr_field = get_field_at_index(sole_variant_val, disr_field_index)\n-        discriminant = int(sole_variant_val[disr_field])\n+        discriminant = sole_variant_val[disr_field]\n+\n+        # If the discriminant field is a fat pointer we have to consider the\n+        # first word as the true discriminant\n+        if discriminant.type.code == gdb.TYPE_CODE_STRUCT:\n+            discriminant = discriminant[get_field_at_index(discriminant, 0)]\n \n         if discriminant == 0:\n           null_variant_name = first_variant_name[last_separator_index + 1:]\n@@ -173,7 +179,7 @@ def to_string(self):\n \n class IdentityPrinter:\n   def __init__(self, string):\n-    self.string\n+    self.string = string\n \n   def to_string(self):\n     return self.string"}, {"sha": "373e9f78cc2952c7ecff4fd86496942061f9e06c", "filename": "src/etc/gedit/share/gtksourceview-3.0/language-specs/rust.lang", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -270,6 +270,7 @@\n       '|\"|\n       \\\\|n|r|t|0|\n       x\\%{hex_digit}{2}|\n+      u{\\%{hex_digit}{1,6}}|\n       u\\%{hex_digit}{4}|\n       U\\%{hex_digit}{8}\n     </define-regex>"}, {"sha": "8bc48fc7934e22e9079c42197fc588be9c0c377c", "filename": "src/etc/install.sh", "status": "removed", "additions": 0, "deletions": 519, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Fetc%2Finstall.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Fetc%2Finstall.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstall.sh?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e", "patch": "@@ -1,519 +0,0 @@\n-#!/bin/sh\n-# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-msg() {\n-    echo \"install: $1\"\n-}\n-\n-step_msg() {\n-    msg\n-    msg \"$1\"\n-    msg\n-}\n-\n-warn() {\n-    echo \"install: WARNING: $1\"\n-}\n-\n-err() {\n-    echo \"install: error: $1\"\n-    exit 1\n-}\n-\n-need_ok() {\n-    if [ $? -ne 0 ]\n-    then\n-        err \"$1\"\n-    fi\n-}\n-\n-need_cmd() {\n-    if command -v $1 >/dev/null 2>&1\n-    then msg \"found $1\"\n-    else err \"need $1\"\n-    fi\n-}\n-\n-putvar() {\n-    local T\n-    eval T=\\$$1\n-    eval TLEN=\\${#$1}\n-    if [ $TLEN -gt 35 ]\n-    then\n-        printf \"install: %-20s := %.35s ...\\n\" $1 \"$T\"\n-    else\n-        printf \"install: %-20s := %s %s\\n\" $1 \"$T\" \"$2\"\n-    fi\n-}\n-\n-valopt() {\n-    VAL_OPTIONS=\"$VAL_OPTIONS $1\"\n-\n-    local OP=$1\n-    local DEFAULT=$2\n-    shift\n-    shift\n-    local DOC=\"$*\"\n-    if [ $HELP -eq 0 ]\n-    then\n-        local UOP=$(echo $OP | tr '[:lower:]' '[:upper:]' | tr '\\-' '\\_')\n-        local V=\"CFG_${UOP}\"\n-        eval $V=\"$DEFAULT\"\n-        for arg in $CFG_ARGS\n-        do\n-            if echo \"$arg\" | grep -q -- \"--$OP=\"\n-            then\n-                val=$(echo \"$arg\" | cut -f2 -d=)\n-                eval $V=$val\n-            fi\n-        done\n-        putvar $V\n-    else\n-        if [ -z \"$DEFAULT\" ]\n-        then\n-            DEFAULT=\"<none>\"\n-        fi\n-        OP=\"${OP}=[${DEFAULT}]\"\n-        printf \"    --%-30s %s\\n\" \"$OP\" \"$DOC\"\n-    fi\n-}\n-\n-opt() {\n-    BOOL_OPTIONS=\"$BOOL_OPTIONS $1\"\n-\n-    local OP=$1\n-    local DEFAULT=$2\n-    shift\n-    shift\n-    local DOC=\"$*\"\n-    local FLAG=\"\"\n-\n-    if [ $DEFAULT -eq 0 ]\n-    then\n-        FLAG=\"enable\"\n-    else\n-        FLAG=\"disable\"\n-        DOC=\"don't $DOC\"\n-    fi\n-\n-    if [ $HELP -eq 0 ]\n-    then\n-        for arg in $CFG_ARGS\n-        do\n-            if [ \"$arg\" = \"--${FLAG}-${OP}\" ]\n-            then\n-                OP=$(echo $OP | tr 'a-z-' 'A-Z_')\n-                FLAG=$(echo $FLAG | tr 'a-z' 'A-Z')\n-                local V=\"CFG_${FLAG}_${OP}\"\n-                eval $V=1\n-                putvar $V\n-            fi\n-        done\n-    else\n-        if [ ! -z \"$META\" ]\n-        then\n-            OP=\"$OP=<$META>\"\n-        fi\n-        printf \"    --%-30s %s\\n\" \"$FLAG-$OP\" \"$DOC\"\n-     fi\n-}\n-\n-flag() {\n-    BOOL_OPTIONS=\"$BOOL_OPTIONS $1\"\n-\n-    local OP=$1\n-    shift\n-    local DOC=\"$*\"\n-\n-    if [ $HELP -eq 0 ]\n-    then\n-        for arg in $CFG_ARGS\n-        do\n-            if [ \"$arg\" = \"--${OP}\" ]\n-            then\n-                OP=$(echo $OP | tr 'a-z-' 'A-Z_')\n-                local V=\"CFG_${OP}\"\n-                eval $V=1\n-                putvar $V\n-            fi\n-        done\n-    else\n-        if [ ! -z \"$META\" ]\n-        then\n-            OP=\"$OP=<$META>\"\n-        fi\n-        printf \"    --%-30s %s\\n\" \"$OP\" \"$DOC\"\n-     fi\n-}\n-\n-validate_opt () {\n-    for arg in $CFG_ARGS\n-    do\n-        isArgValid=0\n-        for option in $BOOL_OPTIONS\n-        do\n-            if test --disable-$option = $arg\n-            then\n-                isArgValid=1\n-            fi\n-            if test --enable-$option = $arg\n-            then\n-                isArgValid=1\n-            fi\n-            if test --$option = $arg\n-            then\n-                isArgValid=1\n-            fi\n-        done\n-        for option in $VAL_OPTIONS\n-        do\n-            if echo \"$arg\" | grep -q -- \"--$option=\"\n-            then\n-                isArgValid=1\n-            fi\n-        done\n-        if [ \"$arg\" = \"--help\" ]\n-        then\n-            echo\n-            echo \"No more help available for Configure options,\"\n-            echo \"check the Wiki or join our IRC channel\"\n-            break\n-        else\n-            if test $isArgValid -eq 0\n-            then\n-                err \"Option '$arg' is not recognized\"\n-            fi\n-        fi\n-    done\n-}\n-\n-absolutify() {\n-    FILE_PATH=\"${1}\"\n-    FILE_PATH_DIRNAME=\"$(dirname ${FILE_PATH})\"\n-    FILE_PATH_BASENAME=\"$(basename ${FILE_PATH})\"\n-    FILE_ABS_PATH=\"$(cd ${FILE_PATH_DIRNAME} && pwd)\"\n-    FILE_PATH=\"${FILE_ABS_PATH}/${FILE_PATH_BASENAME}\"\n-    # This is the return value\n-    ABSOLUTIFIED=\"${FILE_PATH}\"\n-}\n-\n-msg \"looking for install programs\"\n-need_cmd mkdir\n-need_cmd printf\n-need_cmd cut\n-need_cmd grep\n-need_cmd uname\n-need_cmd tr\n-need_cmd sed\n-\n-CFG_SRC_DIR=\"$(cd $(dirname $0) && pwd)\"\n-CFG_SELF=\"$0\"\n-CFG_ARGS=\"$@\"\n-\n-HELP=0\n-if [ \"$1\" = \"--help\" ]\n-then\n-    HELP=1\n-    shift\n-    echo\n-    echo \"Usage: $CFG_SELF [options]\"\n-    echo\n-    echo \"Options:\"\n-    echo\n-else\n-    step_msg \"processing $CFG_SELF args\"\n-fi\n-\n-# Check for mingw or cygwin in order to special case $CFG_LIBDIR_RELATIVE.\n-# This logic is duplicated from configure in order to get the correct libdir\n-# for Windows installs.\n-CFG_OSTYPE=$(uname -s)\n-\n-case $CFG_OSTYPE in\n-\n-    MINGW32*)\n-        CFG_OSTYPE=pc-mingw32\n-        ;;\n-\n-    MINGW64*)\n-        # msys2, MSYSTEM=MINGW64\n-        CFG_OSTYPE=w64-mingw32\n-        ;;\n-\n-# Thad's Cygwin identifers below\n-\n-#   Vista 32 bit\n-    CYGWIN_NT-6.0)\n-        CFG_OSTYPE=pc-mingw32\n-        ;;\n-\n-#   Vista 64 bit\n-    CYGWIN_NT-6.0-WOW64)\n-        CFG_OSTYPE=w64-mingw32\n-        ;;\n-\n-#   Win 7 32 bit\n-    CYGWIN_NT-6.1)\n-        CFG_OSTYPE=pc-mingw32\n-        ;;\n-\n-#   Win 7 64 bit\n-    CYGWIN_NT-6.1-WOW64)\n-        CFG_OSTYPE=w64-mingw32\n-        ;;\n-esac\n-\n-OPTIONS=\"\"\n-BOOL_OPTIONS=\"\"\n-VAL_OPTIONS=\"\"\n-\n-# On windows we just store the libraries in the bin directory because\n-# there's no rpath. This is where the build system itself puts libraries;\n-# --libdir is used to configure the installation directory.\n-# FIXME: Thise needs to parameterized over target triples. Do it in platform.mk\n-CFG_LIBDIR_RELATIVE=lib\n-if [ \"$CFG_OSTYPE\" = \"pc-mingw32\" ] || [ \"$CFG_OSTYPE\" = \"w64-mingw32\" ]\n-then\n-    CFG_LIBDIR_RELATIVE=bin\n-fi\n-\n-if [ \"$CFG_OSTYPE\" = \"pc-mingw32\" ] || [ \"$CFG_OSTYPE\" = \"w64-mingw32\" ]\n-then\n-    CFG_LD_PATH_VAR=PATH\n-    CFG_OLD_LD_PATH_VAR=$PATH\n-elif [ \"$CFG_OSTYPE\" = \"Darwin\" ]\n-then\n-    CFG_LD_PATH_VAR=DYLD_LIBRARY_PATH\n-    CFG_OLD_LD_PATH_VAR=$DYLD_LIBRARY_PATH\n-else\n-    CFG_LD_PATH_VAR=LD_LIBRARY_PATH\n-    CFG_OLD_LD_PATH_VAR=$LD_LIBRARY_PATH\n-fi\n-\n-flag uninstall \"only uninstall from the installation prefix\"\n-opt verify 1 \"verify that the installed binaries run correctly\"\n-valopt prefix \"/usr/local\" \"set installation prefix\"\n-# NB This is exactly the same definition as in `configure`.\n-valopt libdir \"${CFG_PREFIX}/${CFG_LIBDIR_RELATIVE}\" \"install libraries\"\n-case \"$CFG_LIBDIR\" in\n-    \"$CFG_PREFIX\"/*) CAT_INC=2;;\n-    \"$CFG_PREFIX\"*)  CAT_INC=1;;\n-    *)\n-        err \"libdir must begin with the prefix. Use --prefix to set it accordingly.\";;\n-esac\n-CFG_LIBDIR_RELATIVE=`echo ${CFG_LIBDIR} | cut -c$((${#CFG_PREFIX}+${CAT_INC}))-`\n-\n-valopt mandir \"${CFG_PREFIX}/share/man\" \"install man pages in PATH\"\n-\n-if [ $HELP -eq 1 ]\n-then\n-    echo\n-    exit 0\n-fi\n-\n-step_msg \"validating $CFG_SELF args\"\n-validate_opt\n-\n-\n-# OK, let's get installing ...\n-\n-# Sanity check: can we run the binaries?\n-if [ -z \"${CFG_DISABLE_VERIFY}\" ]\n-then\n-    # Don't do this if uninstalling. Failure here won't help in any way.\n-    if [ -z \"${CFG_UNINSTALL}\" ]\n-    then\n-        msg \"verifying platform can run binaries\"\n-        export $CFG_LD_PATH_VAR=\"${CFG_SRC_DIR}/lib:$CFG_OLD_LD_PATH_VAR\"\n-        \"${CFG_SRC_DIR}/bin/rustc\" --version > /dev/null\n-        if [ $? -ne 0 ]\n-        then\n-            err \"can't execute rustc binary on this platform\"\n-        fi\n-        export $CFG_LD_PATH_VAR=$CFG_OLD_LD_PATH_VAR\n-    fi\n-fi\n-\n-# Sanity check: can we can write to the destination?\n-msg \"verifying destination is writable\"\n-umask 022 && mkdir -p \"${CFG_LIBDIR}\"\n-need_ok \"can't write to destination. consider \\`sudo\\`.\"\n-touch \"${CFG_LIBDIR}/rust-install-probe\" > /dev/null\n-if [ $? -ne 0 ]\n-then\n-    err \"can't write to destination. consider \\`sudo\\`.\"\n-fi\n-rm -f \"${CFG_LIBDIR}/rust-install-probe\"\n-need_ok \"failed to remove install probe\"\n-\n-# Sanity check: don't install to the directory containing the installer.\n-# That would surely cause chaos.\n-msg \"verifying destination is not the same as source\"\n-INSTALLER_DIR=\"$(cd $(dirname $0) && pwd)\"\n-PREFIX_DIR=\"$(cd ${CFG_PREFIX} && pwd)\"\n-if [ \"${INSTALLER_DIR}\" = \"${PREFIX_DIR}\" ]\n-then\n-    err \"can't install to same directory as installer\"\n-fi\n-\n-# Using an absolute path to libdir in a few places so that the status\n-# messages are consistently using absolute paths.\n-absolutify \"${CFG_LIBDIR}\"\n-ABS_LIBDIR=\"${ABSOLUTIFIED}\"\n-\n-# The file name of the manifest we're going to create during install\n-INSTALLED_MANIFEST=\"${ABS_LIBDIR}/rustlib/manifest\"\n-\n-# First, uninstall from the installation prefix.\n-# Errors are warnings - try to rm everything in the manifest even if some fail.\n-if [ -f \"${INSTALLED_MANIFEST}\" ]\n-then\n-    # Iterate through installed manifest and remove files\n-    while read p; do\n-        # The installed manifest contains absolute paths\n-        msg \"removing $p\"\n-        if [ -f \"$p\" ]\n-        then\n-            rm -f \"$p\"\n-            if [ $? -ne 0 ]\n-            then\n-                warn \"failed to remove $p\"\n-            fi\n-        else\n-            warn \"supposedly installed file $p does not exist!\"\n-        fi\n-    done < \"${INSTALLED_MANIFEST}\"\n-\n-    # If we fail to remove rustlib below, then the installed manifest will\n-    # still be full; the installed manifest needs to be empty before install.\n-    msg \"removing ${INSTALLED_MANIFEST}\"\n-    rm -f \"${INSTALLED_MANIFEST}\"\n-    # For the above reason, this is a hard error\n-    need_ok \"failed to remove installed manifest\"\n-\n-    # Remove 'rustlib' directory\n-    msg \"removing ${ABS_LIBDIR}/rustlib\"\n-    rm -Rf \"${ABS_LIBDIR}/rustlib\"\n-    if [ $? -ne 0 ]\n-    then\n-        warn \"failed to remove rustlib\"\n-    fi\n-else\n-    # There's no manifest. If we were asked to uninstall, then that's a problem.\n-    if [ -n \"${CFG_UNINSTALL}\" ]\n-    then\n-        err \"unable to find installation manifest at ${CFG_LIBDIR}/rustlib\"\n-    fi\n-fi\n-\n-# If we're only uninstalling then exit\n-if [ -n \"${CFG_UNINSTALL}\" ]\n-then\n-    echo\n-    echo \"    Rust is uninstalled. Have a nice day.\"\n-    echo\n-    exit 0\n-fi\n-\n-# Create the installed manifest, which we will fill in with absolute file paths\n-mkdir -p \"${CFG_LIBDIR}/rustlib\"\n-need_ok \"failed to create rustlib\"\n-touch \"${INSTALLED_MANIFEST}\"\n-need_ok \"failed to create installed manifest\"\n-\n-# Now install, iterate through the new manifest and copy files\n-while read p; do\n-\n-    # Decide the destination of the file\n-    FILE_INSTALL_PATH=\"${CFG_PREFIX}/$p\"\n-\n-    if echo \"$p\" | grep \"^${CFG_LIBDIR_RELATIVE}/\" > /dev/null\n-    then\n-        pp=`echo $p | sed \"s%^${CFG_LIBDIR_RELATIVE}/%%\"`\n-        FILE_INSTALL_PATH=\"${CFG_LIBDIR}/$pp\"\n-    fi\n-\n-    if echo \"$p\" | grep \"^share/man/\" > /dev/null\n-    then\n-        pp=`echo $p | sed 's/^share\\/man\\///'`\n-        FILE_INSTALL_PATH=\"${CFG_MANDIR}/$pp\"\n-    fi\n-\n-    # Make sure there's a directory for it\n-    umask 022 && mkdir -p \"$(dirname ${FILE_INSTALL_PATH})\"\n-    need_ok \"directory creation failed\"\n-\n-    # Make the path absolute so we can uninstall it later without\n-    # starting from the installation cwd\n-    absolutify \"${FILE_INSTALL_PATH}\"\n-    FILE_INSTALL_PATH=\"${ABSOLUTIFIED}\"\n-\n-    # Install the file\n-    msg \"${FILE_INSTALL_PATH}\"\n-    if echo \"$p\" | grep \"^bin/\" > /dev/null\n-    then\n-        install -m755 \"${CFG_SRC_DIR}/$p\" \"${FILE_INSTALL_PATH}\"\n-    else\n-        install -m644 \"${CFG_SRC_DIR}/$p\" \"${FILE_INSTALL_PATH}\"\n-    fi\n-    need_ok \"file creation failed\"\n-\n-    # Update the manifest\n-    echo \"${FILE_INSTALL_PATH}\" >> \"${INSTALLED_MANIFEST}\"\n-    need_ok \"failed to update manifest\"\n-\n-# The manifest lists all files to install\n-done < \"${CFG_SRC_DIR}/${CFG_LIBDIR_RELATIVE}/rustlib/manifest.in\"\n-\n-# Run ldconfig to make dynamic libraries available to the linker\n-if [ \"$CFG_OSTYPE\" = \"Linux\" ]\n-    then\n-    ldconfig\n-    if [ $? -ne 0 ]\n-    then\n-        warn \"failed to run ldconfig.\"\n-        warn \"this may happen when not installing as root and may be fine\"\n-    fi\n-fi\n-\n-# Sanity check: can we run the installed binaries?\n-#\n-# As with the verification above, make sure the right LD_LIBRARY_PATH-equivalent\n-# is in place. Try first without this variable, and if that fails try again with\n-# the variable. If the second time tries, print a hopefully helpful message to\n-# add something to the appropriate environment variable.\n-if [ -z \"${CFG_DISABLE_VERIFY}\" ]\n-then\n-    msg \"verifying installed binaries are executable\"\n-    \"${CFG_PREFIX}/bin/rustc\" --version 2> /dev/null 1> /dev/null\n-    if [ $? -ne 0 ]\n-    then\n-        export $CFG_LD_PATH_VAR=\"${CFG_PREFIX}/lib:$CFG_OLD_LD_PATH_VAR\"\n-        \"${CFG_PREFIX}/bin/rustc\" --version > /dev/null\n-        if [ $? -ne 0 ]\n-        then\n-            ERR=\"can't execute installed rustc binary. \"\n-            ERR=\"${ERR}installation may be broken. \"\n-            ERR=\"${ERR}if this is expected then rerun install.sh with \\`--disable-verify\\` \"\n-            ERR=\"${ERR}or \\`make install\\` with \\`--disable-verify-install\\`\"\n-            err \"${ERR}\"\n-        else\n-            echo\n-            echo \"    Note: please ensure '${CFG_PREFIX}/lib' is added to ${CFG_LD_PATH_VAR}\"\n-        fi\n-    fi\n-fi\n-\n-echo\n-echo \"    Rust is ready to roll.\"\n-echo\n-\n-"}, {"sha": "7669df36b041d9282aea7e22d7b0f771d7332e86", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -38,10 +38,8 @@\n     \"rt/isaac/randport.cpp\", # public domain\n     \"rt/isaac/rand.h\", # public domain\n     \"rt/isaac/standard.h\", # public domain\n-    \"libsync/mpsc_queue.rs\", # BSD\n-    \"libsync/spsc_queue.rs\", # BSD\n-    \"libsync/mpmc_bounded_queue.rs\", # BSD\n-    \"libsync/mpsc_intrusive.rs\", # BSD\n+    \"libstd/comm/mpsc_queue.rs\", # BSD\n+    \"libstd/comm/spsc_queue.rs\", # BSD\n     \"test/bench/shootout-binarytrees.rs\", # BSD\n     \"test/bench/shootout-chameneos-redux.rs\", # BSD\n     \"test/bench/shootout-fannkuch-redux.rs\", # BSD"}, {"sha": "f4f1a5121d1957a06862c97efa11f89a4fa25c5d", "filename": "src/etc/lldb_rust_formatters.py", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -43,8 +43,6 @@ def print_struct_val(val, internal_dict):\n     return print_struct_val_starting_from(0, val, internal_dict)\n \n def print_vec_slice_val(val, internal_dict):\n-  output = \"&[\"\n-\n   length = val.GetChildAtIndex(1).GetValueAsUnsigned()\n \n   data_ptr_val = val.GetChildAtIndex(0)\n@@ -56,16 +54,12 @@ def print_vec_slice_val(val, internal_dict):\n \n   start_address = data_ptr_val.GetValueAsUnsigned()\n \n-  for i in range(length):\n+  def render_element(i):\n     address = start_address + i * element_type_size\n-    element_val = val.CreateValueFromAddress( val.GetName() + (\"[%s]\" % i), address, element_type )\n-    output += print_val(element_val, internal_dict)\n-\n-    if i != length - 1:\n-      output += \", \"\n+    element_val = val.CreateValueFromAddress( val.GetName() + (\"[%s]\" % i), address, element_type)\n+    return print_val(element_val, internal_dict)\n \n-  output += \"]\"\n-  return output\n+  return \"&[%s]\" % (', '.join([render_element(i) for i in range(length)]))\n \n def print_struct_val_starting_from(field_start_index, val, internal_dict):\n   '''\n@@ -75,49 +69,46 @@ def print_struct_val_starting_from(field_start_index, val, internal_dict):\n   assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n \n   t = val.GetType()\n-  has_field_names = type_has_field_names(t)\n   type_name = extract_type_name(t.GetName())\n-  output = \"\"\n+  num_children = val.num_children\n \n-  if not type_name.startswith(\"(\"):\n-    # this is a tuple, so don't print the type name\n-    output += type_name\n+  if (num_children - field_start_index) == 0:\n+    # The only field of this struct is the enum discriminant\n+    return type_name\n+\n+  has_field_names = type_has_field_names(t)\n \n   if has_field_names:\n-    output += \" { \\n\"\n+      template = \"%(type_name)s {\\n%(body)s\\n}\"\n+      separator = \", \\n\"\n   else:\n-    output += \"(\"\n+      template = \"%(type_name)s(%(body)s)\"\n+      separator = \", \"\n \n-  num_children = val.num_children\n+  if type_name.startswith(\"(\"):\n+    # this is a tuple, so don't print the type name\n+    type_name = \"\"\n \n-  for child_index in range(field_start_index, num_children):\n+  def render_child(child_index):\n+    this = \"\"\n     if has_field_names:\n       field_name = t.GetFieldAtIndex(child_index).GetName()\n-      output += field_name + \": \"\n+      this += field_name + \": \"\n \n     field_val = val.GetChildAtIndex(child_index)\n-    output += print_val(field_val, internal_dict)\n+    return this + print_val(field_val, internal_dict)\n \n-    if child_index != num_children - 1:\n-      output += \", \"\n+  body = separator.join([render_child(idx) for idx in range(field_start_index, num_children)])\n \n-    if has_field_names:\n-      output += \"\\n\"\n-\n-  if has_field_names:\n-    output += \"}\"\n-  else:\n-    output += \")\"\n-\n-  return output\n+  return template % {\"type_name\": type_name,\n+                     \"body\": body}\n \n \n def print_enum_val(val, internal_dict):\n   '''Prints an enum value with Rust syntax'''\n \n   assert val.GetType().GetTypeClass() == lldb.eTypeClassUnion\n \n-\n   if val.num_children == 1:\n     # This is either an enum with just one variant, or it is an Option-like enum\n     # where the discriminant is encoded in a non-nullable pointer field. We find\n@@ -147,9 +138,14 @@ def print_enum_val(val, internal_dict):\n         return \"<invalid enum encoding: %s>\" % first_variant_name\n \n       # Read the discriminant\n-      disr_val = val.GetChildAtIndex(0).GetChildAtIndex(disr_field_index).GetValueAsUnsigned()\n+      disr_val = val.GetChildAtIndex(0).GetChildAtIndex(disr_field_index)\n \n-      if disr_val == 0:\n+      # If the discriminant field is a fat pointer we have to consider the\n+      # first word as the true discriminant\n+      if disr_val.GetType().GetTypeClass() == lldb.eTypeClassStruct:\n+          disr_val = disr_val.GetChildAtIndex(0)\n+\n+      if disr_val.GetValueAsUnsigned() == 0:\n         # Null case: Print the name of the null-variant\n         null_variant_name = first_variant_name[last_separator_index + 1:]\n         return null_variant_name\n@@ -243,3 +239,5 @@ def is_vec_slice(val):\n \n   type_name = extract_type_name(ty.GetName()).replace(\"&'static\", \"&\").replace(\" \", \"\")\n   return type_name.startswith(\"&[\") and type_name.endswith(\"]\")\n+\n+# vi: sw=2:ts=2"}, {"sha": "95e647c91cfe60ce71ae2cd2fa748fb52c9b0375", "filename": "src/etc/make-win-dist.py", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Fmake-win-dist.py", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Fmake-win-dist.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmake-win-dist.py?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -8,6 +8,12 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n+# Script parameters:\n+#     argv[1] = rust component root,\n+#     argv[2] = gcc component root,\n+#     argv[3] = target triple\n+# The first two correspond to the two installable components defined in the setup script.\n+\n import sys, os, shutil, subprocess\n \n def find_files(files, path):\n@@ -22,7 +28,7 @@ def find_files(files, path):\n             raise Exception(\"Could not find '%s' in %s\" % (fname, path))\n     return found\n \n-def make_win_dist(dist_root, target_triple):\n+def make_win_dist(rust_root, gcc_root, target_triple):\n     # Ask gcc where it keeps its stuff\n     gcc_out = subprocess.check_output([\"gcc.exe\", \"-print-search-dirs\"])\n     bin_path = os.environ[\"PATH\"].split(os.pathsep)\n@@ -90,29 +96,29 @@ def make_win_dist(dist_root, target_triple):\n     target_libs = find_files(target_libs, lib_path)\n \n     # Copy runtime dlls next to rustc.exe\n-    dist_bin_dir = os.path.join(dist_root, \"bin\")\n+    dist_bin_dir = os.path.join(rust_root, \"bin\")\n     for src in rustc_dlls:\n         shutil.copy(src, dist_bin_dir)\n \n     # Copy platform tools to platform-specific bin directory\n-    target_bin_dir = os.path.join(dist_root, \"bin\", \"rustlib\", target_triple, \"bin\")\n+    target_bin_dir = os.path.join(gcc_root, \"bin\", \"rustlib\", target_triple, \"bin\")\n     if not os.path.exists(target_bin_dir):\n         os.makedirs(target_bin_dir)\n     for src in target_tools:\n         shutil.copy(src, target_bin_dir)\n \n-    # Copy platform libs to platform-spcific lib directory\n-    target_lib_dir = os.path.join(dist_root, \"bin\", \"rustlib\", target_triple, \"lib\")\n+    # Copy platform libs to platform-specific lib directory\n+    target_lib_dir = os.path.join(gcc_root, \"bin\", \"rustlib\", target_triple, \"lib\")\n     if not os.path.exists(target_lib_dir):\n         os.makedirs(target_lib_dir)\n     for src in target_libs:\n         shutil.copy(src, target_lib_dir)\n \n     # Copy license files\n-    lic_dir = os.path.join(dist_root, \"bin\", \"third-party\")\n+    lic_dir = os.path.join(rust_root, \"bin\", \"third-party\")\n     if os.path.exists(lic_dir):\n         shutil.rmtree(lic_dir) # copytree() won't overwrite existing files\n     shutil.copytree(os.path.join(os.path.dirname(__file__), \"third-party\"), lic_dir)\n \n if __name__==\"__main__\":\n-    make_win_dist(sys.argv[1], sys.argv[2])\n+    make_win_dist(sys.argv[1], sys.argv[2], sys.argv[3])"}, {"sha": "834ba074c62102ecf51184434f4b96fedc5f3648", "filename": "src/etc/mklldeps.py", "status": "modified", "additions": 40, "deletions": 61, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Fmklldeps.py", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Fmklldeps.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmklldeps.py?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -19,6 +19,7 @@\n components = sys.argv[2].split(' ')\n components = [i for i in components if i]  # ignore extra whitespaces\n enable_static = sys.argv[3]\n+llconfig = sys.argv[4]\n \n f.write(\"\"\"// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n@@ -44,69 +45,47 @@ def run(args):\n         sys.exit(1)\n     return out\n \n-for llconfig in sys.argv[4:]:\n-    f.write(\"\\n\")\n-\n-    out = run([llconfig, '--host-target'])\n-    arch, os = out.split('-', 1)\n-    arch = 'x86' if arch == 'i686' or arch == 'i386' else arch\n-    if 'darwin' in os:\n-        os = 'macos'\n-    elif 'linux' in os:\n-        os = 'linux'\n-    elif 'freebsd' in os:\n-        os = 'freebsd'\n-    elif 'dragonfly' in os:\n-        os = 'dragonfly'\n-    elif 'android' in os:\n-        os = 'android'\n-    elif 'win' in os or 'mingw' in os:\n-        os = 'windows'\n-    cfg = [\n-        \"target_arch = \\\"\" + arch + \"\\\"\",\n-        \"target_os = \\\"\" + os + \"\\\"\",\n-    ]\n-\n-    f.write(\"#[cfg(all(\" + ', '.join(cfg) + \"))]\\n\")\n-\n-    version = run([llconfig, '--version']).strip()\n-\n-    # LLVM libs\n-    if version < '3.5':\n-      args = [llconfig, '--libs']\n-    else:\n-      args = [llconfig, '--libs', '--system-libs']\n-    args.extend(components)\n-    out = run(args)\n-    for lib in out.strip().replace(\"\\n\", ' ').split(' '):\n-        lib = lib.strip()[2:] # chop of the leading '-l'\n-        f.write(\"#[link(name = \\\"\" + lib + \"\\\"\")\n-        # LLVM libraries are all static libraries\n-        if 'LLVM' in lib:\n-            f.write(\", kind = \\\"static\\\"\")\n-        f.write(\")]\\n\")\n-\n-    # llvm-config before 3.5 didn't have a system-libs flag\n-    if version < '3.5':\n-      if os == 'win32':\n+f.write(\"\\n\")\n+\n+version = run([llconfig, '--version']).strip()\n+\n+# LLVM libs\n+if version < '3.5':\n+    args = [llconfig, '--libs']\n+else:\n+    args = [llconfig, '--libs', '--system-libs']\n+\n+args.extend(components)\n+out = run(args)\n+for lib in out.strip().replace(\"\\n\", ' ').split(' '):\n+    lib = lib.strip()[2:] # chop of the leading '-l'\n+    f.write(\"#[link(name = \\\"\" + lib + \"\\\"\")\n+    # LLVM libraries are all static libraries\n+    if 'LLVM' in lib:\n+        f.write(\", kind = \\\"static\\\"\")\n+    f.write(\")]\\n\")\n+\n+# llvm-config before 3.5 didn't have a system-libs flag\n+if version < '3.5':\n+    if os == 'win32':\n         f.write(\"#[link(name = \\\"imagehlp\\\")]\")\n \n-    # LLVM ldflags\n-    out = run([llconfig, '--ldflags'])\n-    for lib in out.strip().split(' '):\n-        if lib[:2] == \"-l\":\n-            f.write(\"#[link(name = \\\"\" + lib[2:] + \"\\\")]\\n\")\n-\n-    # C++ runtime library\n-    out = run([llconfig, '--cxxflags'])\n-    if enable_static == '1':\n-      assert('stdlib=libc++' not in out)\n-      f.write(\"#[link(name = \\\"stdc++\\\", kind = \\\"static\\\")]\\n\")\n-    else:\n-      if 'stdlib=libc++' in out:\n+# LLVM ldflags\n+out = run([llconfig, '--ldflags'])\n+for lib in out.strip().split(' '):\n+    if lib[:2] == \"-l\":\n+        f.write(\"#[link(name = \\\"\" + lib[2:] + \"\\\")]\\n\")\n+\n+# C++ runtime library\n+out = run([llconfig, '--cxxflags'])\n+if enable_static == '1':\n+    assert('stdlib=libc++' not in out)\n+    f.write(\"#[link(name = \\\"stdc++\\\", kind = \\\"static\\\")]\\n\")\n+else:\n+    if 'stdlib=libc++' in out:\n         f.write(\"#[link(name = \\\"c++\\\")]\\n\")\n-      else:\n+    else:\n         f.write(\"#[link(name = \\\"stdc++\\\")]\\n\")\n \n-    # Attach everything to an extern block\n-    f.write(\"extern {}\\n\")\n+# Attach everything to an extern block\n+f.write(\"extern {}\\n\")"}, {"sha": "43df6256e0b7ec8ca61b4830f3f38ed3044b87ca", "filename": "src/etc/pkg/rust.iss", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Fpkg%2Frust.iss", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Fpkg%2Frust.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fpkg%2Frust.iss?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -14,6 +14,7 @@ AppPublisherURL=http://www.rust-lang.org\n VersionInfoVersion={#CFG_VERSION_WIN}\n LicenseFile=LICENSE.txt\n \n+PrivilegesRequired=lowest\n DisableWelcomePage=true\n DisableProgramGroupPage=true\n DisableReadyPage=true\n@@ -22,7 +23,7 @@ DisableStartupPrompt=true\n OutputDir=.\\dist\\\n SourceDir=.\\\n OutputBaseFilename={#CFG_PACKAGE_NAME}-{#CFG_BUILD}\n-DefaultDirName={pf32}\\Rust\n+DefaultDirName={sd}\\Rust\n \n Compression=lzma2/ultra\n InternalCompressLevel=ultra\n@@ -37,13 +38,18 @@ Uninstallable=yes\n [Tasks]\n Name: modifypath; Description: &Add {app}\\bin to your PATH (recommended)\n \n+[Components]\n+Name: rust; Description: \"Rust compiler and standard crates\"; Types: full compact custom; Flags: fixed\n+Name: gcc; Description: \"Linker and platform libraries\"; Types: full\n+\n [Files]\n-Source: \"tmp/dist/win/*.*\" ; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs\n+Source: \"tmp/dist/win/rust/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rust\n+Source: \"tmp/dist/win/gcc/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: gcc\n \n [Code]\n const\n \tModPathName = 'modifypath';\n-\tModPathType = 'system';\n+\tModPathType = 'user';\n \n function ModPathDir(): TArrayOfString;\n begin"}, {"sha": "ea7f51c86f81754141e47940abe12ae2445863e2", "filename": "src/etc/regex-match-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Fregex-match-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Fregex-match-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fregex-match-tests.py?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -63,7 +63,7 @@ def read_tests(f):\n def test_tostr(t):\n     lineno, pat, text, groups = t\n     options = map(group_tostr, groups)\n-    return 'mat!(match_%s, r\"%s\", r\"%s\", %s)' \\\n+    return 'mat!{match_%s, r\"%s\", r\"%s\", %s}' \\\n            % (lineno, pat, '' if text == \"NULL\" else text, ', '.join(options))\n \n "}, {"sha": "42902b06aee13637bc432039a93bcac16123de6b", "filename": "src/etc/rust-lldb", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Frust-lldb", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Frust-lldb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-lldb?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -0,0 +1,30 @@\n+#!/bin/sh\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# Exit if anything fails\n+set -e\n+\n+# Create a tempfile containing the LLDB script we want to execute on startup\n+TMPFILE=`mktemp /tmp/rust-lldb-commands.XXXXXX`\n+\n+# Make sure to delete the tempfile no matter what\n+trap \"rm -f $TMPFILE; exit\" INT TERM EXIT\n+\n+# Find out where to look for the pretty printer Python module\n+RUSTC_SYSROOT=`rustc --print sysroot`\n+\n+# Write the LLDB script to the tempfile\n+echo \"command script import \\\"$RUSTC_SYSROOT/lib/rustlib/etc/lldb_rust_formatters.py\\\"\" >> $TMPFILE\n+echo \"type summary add --no-value --python-function lldb_rust_formatters.print_val -x \\\".*\\\" --category Rust\" >> $TMPFILE\n+echo \"type category enable Rust\" >> $TMPFILE\n+\n+# Call LLDB with the script added to the argument list\n+lldb --source-before-file=\"$TMPFILE\" \"$@\""}, {"sha": "35ff1199b526672ed5182146e5f2f947b4eb50fb", "filename": "src/etc/rustup.sh", "status": "modified", "additions": 86, "deletions": 61, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frustup.sh?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -188,7 +188,7 @@ flag() {\n      fi\n }\n \n-validate_opt () {\n+validate_opt() {\n     for arg in $CFG_ARGS\n     do\n         isArgValid=0\n@@ -242,6 +242,8 @@ create_tmp_dir() {\n }\n \n probe_need CFG_CURL  curl\n+probe_need CFG_TAR   tar\n+probe_need CFG_FILE  file\n \n CFG_SRC_DIR=\"$(cd $(dirname $0) && pwd)/\"\n CFG_SELF=\"$0\"\n@@ -370,7 +372,7 @@ esac\n # Detect 64 bit linux systems with 32 bit userland and force 32 bit compilation\n if [ $CFG_OSTYPE = unknown-linux-gnu -a $CFG_CPUTYPE = x86_64 ]\n then\n-    file -L \"$SHELL\" | grep -q \"x86[_-]64\"\n+    \"${CFG_FILE}\" -L \"$SHELL\" | grep -q \"x86[_-]64\"\n     if [ $? != 0 ]; then\n         CFG_CPUTYPE=i686\n     fi\n@@ -400,83 +402,106 @@ esac\n \n msg \"host triple: ${HOST_TRIPLE}\"\n \n-PACKAGE_NAME=rust-nightly\n-PACKAGE_NAME_AND_TRIPLE=\"${PACKAGE_NAME}-${HOST_TRIPLE}\"\n-TARBALL_NAME=\"${PACKAGE_NAME_AND_TRIPLE}.tar.gz\"\n-REMOTE_TARBALL=\"https://static.rust-lang.org/dist/${TARBALL_NAME}\"\n-TMP_DIR=`mktemp -d 2>/dev/null || mktemp -d -t 'mytmpdir' 2>/dev/null` || TMP_DIR=$(create_tmp_dir)\n-LOCAL_TARBALL=\"${TMP_DIR}/${TARBALL_NAME}\"\n-LOCAL_INSTALL_DIR=\"${TMP_DIR}/${PACKAGE_NAME_AND_TRIPLE}\"\n-LOCAL_INSTALL_SCRIPT=\"${LOCAL_INSTALL_DIR}/install.sh\"\n+CFG_INSTALL_FLAGS=\"\"\n+if [ -n \"${CFG_UNINSTALL}\" ]\n+then\n+    CFG_INSTALL_FLAGS=\"${CFG_INSTALL_FLAGS} --uninstall\"\n+fi\n+\n+if [ -n \"${CFG_PREFIX}\" ]\n+then\n+    CFG_INSTALL_FLAGS=\"${CFG_INSTALL_FLAGS} --prefix=${CFG_PREFIX}\"\n+fi\n+\n+CFG_TMP_DIR=`mktemp -d 2>/dev/null || mktemp -d -t 'mytmpdir' 2>/dev/null` || CFG_TMP_DIR=$(create_tmp_dir)\n+\n+RUST_URL=\"https://static.rust-lang.org/dist\"\n+RUST_PACKAGE_NAME=rust-nightly\n+RUST_PACKAGE_NAME_AND_TRIPLE=\"${RUST_PACKAGE_NAME}-${HOST_TRIPLE}\"\n+RUST_TARBALL_NAME=\"${RUST_PACKAGE_NAME_AND_TRIPLE}.tar.gz\"\n+RUST_LOCAL_INSTALL_DIR=\"${CFG_TMP_DIR}/${RUST_PACKAGE_NAME_AND_TRIPLE}\"\n+RUST_LOCAL_INSTALL_SCRIPT=\"${RUST_LOCAL_INSTALL_DIR}/install.sh\"\n \n+CARGO_URL=\"https://static.rust-lang.org/cargo-dist\"\n CARGO_PACKAGE_NAME=cargo-nightly\n CARGO_PACKAGE_NAME_AND_TRIPLE=\"${CARGO_PACKAGE_NAME}-${HOST_TRIPLE}\"\n CARGO_TARBALL_NAME=\"${CARGO_PACKAGE_NAME_AND_TRIPLE}.tar.gz\"\n-CARGO_REMOTE_TARBALL=\"https://static.rust-lang.org/cargo-dist/${CARGO_TARBALL_NAME}\"\n-CARGO_LOCAL_TARBALL=\"${TMP_DIR}/${CARGO_TARBALL_NAME}\"\n-CARGO_LOCAL_INSTALL_DIR=\"${TMP_DIR}/${CARGO_PACKAGE_NAME_AND_TRIPLE}\"\n+CARGO_LOCAL_INSTALL_DIR=\"${CFG_TMP_DIR}/${CARGO_PACKAGE_NAME_AND_TRIPLE}\"\n CARGO_LOCAL_INSTALL_SCRIPT=\"${CARGO_LOCAL_INSTALL_DIR}/install.sh\"\n \n-msg \"downloading rust installer\"\n-\"${CFG_CURL}\" \"${REMOTE_TARBALL}\" > \"${LOCAL_TARBALL}\"\n-if [ $? -ne 0 ]\n-then\n-        rm -Rf \"${TMP_DIR}\"\n-        err \"failed to download installer\"\n-fi\n+# Fetch the package.\n+download_package() {\n+    remote_tarball=\"$1\"\n+    local_tarball=\"$2\"\n \n-if [ -z \"${CFG_DISABLE_CARGO}\" ]; then\n-    msg \"downloading cargo installer\"\n-    \"${CFG_CURL}\" \"${CARGO_REMOTE_TARBALL}\" > \"${CARGO_LOCAL_TARBALL}\"\n+    msg \"Downloading ${remote_tarball} to ${local_tarball}\"\n+\n+    \"${CFG_CURL}\" -f -o \"${local_tarball}\" \"${remote_tarball}\"\n     if [ $? -ne 0 ]\n     then\n-            rm -Rf \"${TMP_DIR}\"\n-            err \"failed to download cargo installer\"\n+        rm -Rf \"${CFG_TMP_DIR}\"\n+        err \"failed to download installer\"\n     fi\n-fi\n+}\n \n+# Wrap all the commands needed to install a package.\n+install_package() {\n+    tarball_name=\"$1\"\n+    install_script=\"$2\"\n \n-(cd \"${TMP_DIR}\" && tar xzf \"${TARBALL_NAME}\")\n-if [ $? -ne 0 ]\n-then\n-        rm -Rf \"${TMP_DIR}\"\n+    msg \"Extracting ${tarball_name}\"\n+    (cd \"${CFG_TMP_DIR}\" && \"${CFG_TAR}\" -xzf \"${tarball_name}\")\n+    if [ $? -ne 0 ]; then\n+        rm -Rf \"${CFG_TMP_DIR}\"\n         err \"failed to unpack installer\"\n-fi\n+    fi\n \n-MAYBE_UNINSTALL=\n-if [ -n \"${CFG_UNINSTALL}\" ]\n-then\n-        MAYBE_UNINSTALL=\"--uninstall\"\n-fi\n+    sh \"${install_script}\" \"${CFG_INSTALL_FLAGS}\"\n+    if [ $? -ne 0 ]\n+    then\n+        rm -Rf \"${CFG_TMP_DIR}\"\n+        err \"failed to install Rust\"\n+    fi\n+}\n \n-MAYBE_PREFIX=\n-if [ -n \"${CFG_PREFIX}\" ]\n-then\n-        MAYBE_PREFIX=\"--prefix=${CFG_PREFIX}\"\n-fi\n+# It's possible that curl could be interrupted partway though downloading\n+# `rustup.sh`, truncating the file. This could be especially bad if we were in\n+# the middle of a line that would run \"rm -rf \". To protect against this, we\n+# wrap up the `rustup.sh` destructive functionality in this helper function,\n+# which we call as the last thing we do. This means we will not do anything\n+# unless we have the entire file downloaded.\n+install_packages() {\n+    rm -Rf \"${CFG_TMP_DIR}\"\n+    need_ok \"failed to remove temporary installation directory\"\n \n-sh \"${LOCAL_INSTALL_SCRIPT}\" \"${MAYBE_UNINSTALL}\" \"${MAYBE_PREFIX}\"\n-if [ $? -ne 0 ]\n-then\n-        rm -Rf \"${TMP_DIR}\"\n-        err \"failed to install Rust\"\n-fi\n+    mkdir -p \"${CFG_TMP_DIR}\"\n+    need_ok \"failed to create create temporary installation directory\"\n \n-if [ -z \"${CFG_DISABLE_CARGO}\" ]; then\n-    (cd \"${TMP_DIR}\" && tar xzf \"${CARGO_TARBALL_NAME}\")\n-    if [ $? -ne 0 ]\n-    then\n-            rm -Rf \"${TMP_DIR}\"\n-            err \"failed to unpack cargo installer\"\n+    RUST_LOCAL_TARBALL=\"${CFG_TMP_DIR}/${RUST_TARBALL_NAME}\"\n+    CARGO_LOCAL_TARBALL=\"${CFG_TMP_DIR}/${CARGO_TARBALL_NAME}\"\n+\n+    download_package \\\n+        \"${RUST_URL}/${RUST_TARBALL_NAME}\" \\\n+        \"${RUST_LOCAL_TARBALL}\"\n+\n+    if [ -z \"${CFG_DISABLE_CARGO}\" ]; then\n+        download_package \\\n+            \"${CARGO_URL}/${CARGO_TARBALL_NAME}\" \\\n+            \"${CARGO_LOCAL_TARBALL}\"\n     fi\n \n-    sh \"${CARGO_LOCAL_INSTALL_SCRIPT}\" \"${MAYBE_UNINSTALL}\" \"${MAYBE_PREFIX}\"\n-    if [ $? -ne 0 ]\n-    then\n-            rm -Rf \"${TMP_DIR}\"\n-            err \"failed to install Cargo\"\n+    install_package \\\n+        \"${RUST_TARBALL_NAME}\" \\\n+        \"${RUST_LOCAL_INSTALL_SCRIPT}\"\n+\n+    if [ -z \"${CFG_DISABLE_CARGO}\" ]; then\n+        install_package \\\n+            \"${CARGO_TARBALL_NAME}\" \\\n+            \"${CARGO_LOCAL_INSTALL_SCRIPT}\"\n     fi\n-fi\n \n-rm -Rf \"${TMP_DIR}\"\n-need_ok \"couldn't rm temporary installation directory\"\n+    rm -Rf \"${CFG_TMP_DIR}\"\n+    need_ok \"couldn't rm temporary installation directory\"\n+}\n+\n+install_packages"}, {"sha": "63f1b3dcd4414f2fd4ec946acb3d5ab3db7ccf26", "filename": "src/etc/unicode.py", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -283,17 +283,13 @@ def load_east_asian_width(want_widths, except_cats):\n     return widths\n \n def escape_char(c):\n-    if c <= 0x7f:\n-        return \"'\\\\x%2.2x'\" % c\n-    if c <= 0xffff:\n-        return \"'\\\\u%4.4x'\" % c\n-    return \"'\\\\U%8.8x'\" % c\n+    return \"'\\\\u{%x}'\" % c\n \n def emit_bsearch_range_table(f):\n     f.write(\"\"\"\n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n-    use core::cmp::{Equal, Less, Greater};\n-    use core::slice::SlicePrelude;\n+    use core::cmp::Ordering::{Equal, Less, Greater};\n+    use core::slice::SliceExt;\n     r.binary_search(|&(lo,hi)| {\n         if lo <= c && c <= hi { Equal }\n         else if hi < c { Less }\n@@ -350,23 +346,23 @@ def emit_regex_module(f, cats, w_data):\n def emit_conversions_module(f, lowerupper, upperlower):\n     f.write(\"pub mod conversions {\")\n     f.write(\"\"\"\n-    use core::cmp::{Equal, Less, Greater};\n-    use core::slice::SlicePrelude;\n-    use core::tuple::Tuple2;\n-    use core::option::{Option, Some, None};\n+    use core::cmp::Ordering::{Equal, Less, Greater};\n+    use core::slice::SliceExt;\n+    use core::option::Option;\n+    use core::option::Option::{Some, None};\n     use core::slice;\n \n     pub fn to_lower(c: char) -> char {\n         match bsearch_case_table(c, LuLl_table) {\n           None        => c,\n-          Some(index) => LuLl_table[index].val1()\n+          Some(index) => LuLl_table[index].1\n         }\n     }\n \n     pub fn to_upper(c: char) -> char {\n         match bsearch_case_table(c, LlLu_table) {\n             None        => c,\n-            Some(index) => LlLu_table[index].val1()\n+            Some(index) => LlLu_table[index].1\n         }\n     }\n \n@@ -376,8 +372,8 @@ def emit_conversions_module(f, lowerupper, upperlower):\n             else if key < c { Less }\n             else { Greater }\n         }) {\n-            slice::Found(i) => Some(i),\n-            slice::NotFound(_) => None,\n+            slice::BinarySearchResult::Found(i) => Some(i),\n+            slice::BinarySearchResult::NotFound(_) => None,\n         }\n     }\n \n@@ -390,7 +386,8 @@ def emit_conversions_module(f, lowerupper, upperlower):\n \n def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n     f.write(\"\"\"pub mod grapheme {\n-    use core::slice::SlicePrelude;\n+    use core::kinds::Copy;\n+    use core::slice::SliceExt;\n     pub use self::GraphemeCat::*;\n     use core::slice;\n \n@@ -402,18 +399,20 @@ def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n         f.write(\"        GC_\" + cat + \",\\n\")\n     f.write(\"\"\"    }\n \n+    impl Copy for GraphemeCat {}\n+\n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, GraphemeCat)]) -> GraphemeCat {\n-        use core::cmp::{Equal, Less, Greater};\n+        use core::cmp::Ordering::{Equal, Less, Greater};\n         match r.binary_search(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            slice::Found(idx) => {\n+            slice::BinarySearchResult::Found(idx) => {\n                 let (_, _, cat) = r[idx];\n                 cat\n             }\n-            slice::NotFound(_) => GC_Any\n+            slice::BinarySearchResult::NotFound(_) => GC_Any\n         }\n     }\n \n@@ -430,22 +429,23 @@ def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n \n def emit_charwidth_module(f, width_table):\n     f.write(\"pub mod charwidth {\\n\")\n-    f.write(\"    use core::option::{Option, Some, None};\\n\")\n-    f.write(\"    use core::slice::SlicePrelude;\\n\")\n+    f.write(\"    use core::option::Option;\\n\")\n+    f.write(\"    use core::option::Option::{Some, None};\\n\")\n+    f.write(\"    use core::slice::SliceExt;\\n\")\n     f.write(\"    use core::slice;\\n\")\n     f.write(\"\"\"\n     fn bsearch_range_value_table(c: char, is_cjk: bool, r: &'static [(char, char, u8, u8)]) -> u8 {\n-        use core::cmp::{Equal, Less, Greater};\n+        use core::cmp::Ordering::{Equal, Less, Greater};\n         match r.binary_search(|&(lo, hi, _, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            slice::Found(idx) => {\n+            slice::BinarySearchResult::Found(idx) => {\n                 let (_, _, r_ncjk, r_cjk) = r[idx];\n                 if is_cjk { r_cjk } else { r_ncjk }\n             }\n-            slice::NotFound(_) => 1\n+            slice::BinarySearchResult::NotFound(_) => 1\n         }\n     }\n \"\"\")\n@@ -530,19 +530,19 @@ def comp_pfun(char):\n \n     f.write(\"\"\"\n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n-        use core::cmp::{Equal, Less, Greater};\n-        use core::slice::SlicePrelude;\n+        use core::cmp::Ordering::{Equal, Less, Greater};\n+        use core::slice::SliceExt;\n         use core::slice;\n         match r.binary_search(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            slice::Found(idx) => {\n+            slice::BinarySearchResult::Found(idx) => {\n                 let (_, _, result) = r[idx];\n                 result\n             }\n-            slice::NotFound(_) => 0\n+            slice::BinarySearchResult::NotFound(_) => 0\n         }\n     }\\n\n \"\"\")\n@@ -611,7 +611,7 @@ def optimize_width_table(wtable):\n             unicode_version = re.search(pattern, readme.read()).groups()\n         rf.write(\"\"\"\n /// The version of [Unicode](http://www.unicode.org/)\n-/// that the `UnicodeChar` and `UnicodeStrSlice` traits are based on.\n+/// that the `UnicodeChar` and `UnicodeStrPrelude` traits are based on.\n pub const UNICODE_VERSION: (uint, uint, uint) = (%s, %s, %s);\n \"\"\" % unicode_version)\n         (canon_decomp, compat_decomp, gencats, combines,"}, {"sha": "9e663eb0317efcb47352dae8fb93f38ef8ec51f5", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -24,7 +24,7 @@ syn keyword   rustKeyword     continue\n syn keyword   rustKeyword     extern nextgroup=rustExternCrate,rustObsoleteExternMod skipwhite skipempty\n syn keyword   rustKeyword     fn nextgroup=rustFuncName skipwhite skipempty\n syn keyword   rustKeyword     for in if impl let\n-syn keyword   rustKeyword     loop once proc pub\n+syn keyword   rustKeyword     loop once pub\n syn keyword   rustKeyword     return super\n syn keyword   rustKeyword     unsafe virtual where while\n syn keyword   rustKeyword     use nextgroup=rustModPath skipwhite skipempty\n@@ -90,7 +90,7 @@ syn keyword rustTrait Clone\n syn keyword rustTrait PartialEq PartialOrd Eq Ord\n syn keyword rustEnum Ordering Equiv\n syn keyword rustEnumVariant Less Equal Greater\n-syn keyword rustTrait FromIterator Extend ExactSize\n+syn keyword rustTrait FromIterator Extend ExactSizeIterator\n syn keyword rustTrait Iterator DoubleEndedIterator\n syn keyword rustTrait RandomAccessIterator CloneableIterator\n syn keyword rustTrait OrdIterator MutableDoubleEndedIterator\n@@ -151,6 +151,7 @@ syn match     rustMacro       '#\\w\\(\\w\\)*' contains=rustAssert,rustPanic\n syn match     rustEscapeError   display contained /\\\\./\n syn match     rustEscape        display contained /\\\\\\([nrt0\\\\'\"]\\|x\\x\\{2}\\)/\n syn match     rustEscapeUnicode display contained /\\\\\\(u\\x\\{4}\\|U\\x\\{8}\\)/\n+syn match     rustEscapeUnicode display contained /\\\\u{\\x\\{1,6}}/\n syn match     rustStringContinuation display contained /\\\\\\n\\s*/\n syn region    rustString      start=+b\"+ skip=+\\\\\\\\\\|\\\\\"+ end=+\"+ contains=rustEscape,rustEscapeError,rustStringContinuation\n syn region    rustString      start=+\"+ skip=+\\\\\\\\\\|\\\\\"+ end=+\"+ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustStringContinuation,@Spell\n@@ -187,7 +188,7 @@ syn match   rustCharacterInvalid   display contained /b\\?'\\zs[\\n\\r\\t']\\ze'/\n \" The groups negated here add up to 0-255 but nothing else (they do not seem to go beyond ASCII).\n syn match   rustCharacterInvalidUnicode   display contained /b'\\zs[^[:cntrl:][:graph:][:alnum:][:space:]]\\ze'/\n syn match   rustCharacter   /b'\\([^\\\\]\\|\\\\\\(.\\|x\\x\\{2}\\)\\)'/ contains=rustEscape,rustEscapeError,rustCharacterInvalid,rustCharacterInvalidUnicode\n-syn match   rustCharacter   /'\\([^\\\\]\\|\\\\\\(.\\|x\\x\\{2}\\|u\\x\\{4}\\|U\\x\\{8}\\)\\)'/ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustCharacterInvalid\n+syn match   rustCharacter   /'\\([^\\\\]\\|\\\\\\(.\\|x\\x\\{2}\\|u\\x\\{4}\\|U\\x\\{8}\\|u{\\x\\{1,6}}\\)\\)'/ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustCharacterInvalid\n \n syn region rustCommentLine                                        start=\"//\"                      end=\"$\"   contains=rustTodo,@Spell\n syn region rustCommentLineDoc                                     start=\"//\\%(//\\@!\\|!\\)\"         end=\"$\"   contains=rustTodo,@Spell"}, {"sha": "f7b19cf6fbf5e06ef290bbbe45878b1659f9ac36", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -173,10 +173,10 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>) -> TokenAn\n     );\n \n     let m = re.captures(s).expect(format!(\"The regex didn't match {}\", s).as_slice());\n-    let start = m.name(\"start\");\n-    let end = m.name(\"end\");\n-    let toknum = m.name(\"toknum\");\n-    let content = m.name(\"content\");\n+    let start = m.name(\"start\").unwrap_or(\"\");\n+    let end = m.name(\"end\").unwrap_or(\"\");\n+    let toknum = m.name(\"toknum\").unwrap_or(\"\");\n+    let content = m.name(\"content\").unwrap_or(\"\");\n \n     let proto_tok = tokens.get(toknum).expect(format!(\"didn't find token {} in the map\",\n                                                               toknum).as_slice());"}, {"sha": "893c9d250b7237cae7fa3aff45f0de81f3ce985e", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 389, "deletions": 79, "changes": 468, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -10,10 +10,65 @@\n \n #![stable]\n \n-//! Concurrency-enabled mechanisms for sharing mutable and/or immutable state\n-//! between tasks.\n+//! Threadsafe reference-counted boxes (the `Arc<T>` type).\n+//!\n+//! The `Arc<T>` type provides shared ownership of an immutable value. Destruction is\n+//! deterministic, and will occur as soon as the last owner is gone. It is marked as `Send` because\n+//! it uses atomic reference counting.\n+//!\n+//! If you do not need thread-safety, and just need shared ownership, consider the [`Rc<T>`\n+//! type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but does not use atomics, making it\n+//! both thread-unsafe as well as significantly faster when updating the reference count.\n+//!\n+//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer to the box. A\n+//! `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but will return `None` if the value\n+//! has already been dropped.\n+//!\n+//! For example, a tree with parent pointers can be represented by putting the nodes behind strong\n+//! `Arc<T>` pointers, and then storing the parent pointers as `Weak<T>` pointers.\n+//!\n+//! # Examples\n+//!\n+//! Sharing some immutable data between tasks:\n+//!\n+//! ```\n+//! use std::sync::Arc;\n+//! use std::thread::Thread;\n+//!\n+//! let five = Arc::new(5i);\n+//!\n+//! for i in range(0u, 10) {\n+//!     let five = five.clone();\n+//!\n+//!     Thread::spawn(move || {\n+//!         println!(\"{}\", five);\n+//!     }).detach();\n+//! }\n+//! ```\n+//!\n+//! Sharing mutable data safely between tasks with a `Mutex`:\n+//!\n+//! ```\n+//! use std::sync::{Arc, Mutex};\n+//! use std::thread::Thread;\n+//!\n+//! let five = Arc::new(Mutex::new(5i));\n+//!\n+//! for _ in range(0u, 10) {\n+//!     let five = five.clone();\n+//!\n+//!     Thread::spawn(move || {\n+//!         let mut number = five.lock();\n+//!\n+//!         *number += 1;\n+//!\n+//!         println!(\"{}\", *number); // prints 6\n+//!     }).detach();\n+//! }\n+//! ```\n \n use core::atomic;\n+use core::borrow::BorrowFrom;\n use core::clone::Clone;\n use core::fmt::{mod, Show};\n use core::cmp::{Eq, Ord, PartialEq, PartialOrd, Ordering};\n@@ -22,7 +77,8 @@ use core::kinds::{Sync, Send};\n use core::mem::{min_align_of, size_of, drop};\n use core::mem;\n use core::ops::{Drop, Deref};\n-use core::option::{Some, None, Option};\n+use core::option::Option;\n+use core::option::Option::{Some, None};\n use core::ptr::RawPtr;\n use core::ptr;\n use heap::deallocate;\n@@ -31,12 +87,12 @@ use heap::deallocate;\n ///\n /// # Example\n ///\n-/// In this example, a large vector of floats is shared between several tasks.\n-/// With simple pipes, without `Arc`, a copy would have to be made for each\n-/// task.\n+/// In this example, a large vector of floats is shared between several tasks. With simple pipes,\n+/// without `Arc`, a copy would have to be made for each task.\n ///\n /// ```rust\n /// use std::sync::Arc;\n+/// use std::thread::Thread;\n ///\n /// fn main() {\n ///     let numbers = Vec::from_fn(100, |i| i as f32);\n@@ -45,11 +101,11 @@ use heap::deallocate;\n ///     for _ in range(0u, 10) {\n ///         let child_numbers = shared_numbers.clone();\n ///\n-///         spawn(proc() {\n+///         Thread::spawn(move || {\n ///             let local_numbers = child_numbers.as_slice();\n ///\n ///             // Work with the local numbers\n-///         });\n+///         }).detach();\n ///     }\n /// }\n /// ```\n@@ -63,8 +119,8 @@ pub struct Arc<T> {\n \n /// A weak pointer to an `Arc`.\n ///\n-/// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n-/// used to break cycles between `Arc` pointers.\n+/// Weak pointers will not keep the data inside of the `Arc` alive, and can be used to break cycles\n+/// between `Arc` pointers.\n #[unsafe_no_drop_flag]\n #[experimental = \"Weak pointers may not belong in this module.\"]\n pub struct Weak<T> {\n@@ -80,7 +136,15 @@ struct ArcInner<T> {\n }\n \n impl<T: Sync + Send> Arc<T> {\n-    /// Creates an atomically reference counted wrapper.\n+    /// Constructs a new `Arc<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn new(data: T) -> Arc<T> {\n@@ -94,11 +158,17 @@ impl<T: Sync + Send> Arc<T> {\n         Arc { _ptr: unsafe { mem::transmute(x) } }\n     }\n \n-    /// Downgrades a strong pointer to a weak pointer.\n+    /// Downgrades the `Arc<T>` to a `Weak<T>` reference.\n+    ///\n+    /// # Examples\n     ///\n-    /// Weak pointers will not keep the data alive. Once all strong references\n-    /// to the underlying data have been dropped, the data itself will be\n-    /// destroyed.\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// let weak_five = five.downgrade();\n+    /// ```\n     #[experimental = \"Weak pointers may not belong in this module.\"]\n     pub fn downgrade(&self) -> Weak<T> {\n         // See the clone() impl for why this is relaxed\n@@ -110,40 +180,61 @@ impl<T: Sync + Send> Arc<T> {\n impl<T> Arc<T> {\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n-        // This unsafety is ok because while this arc is alive we're guaranteed\n-        // that the inner pointer is valid. Furthermore, we know that the\n-        // `ArcInner` structure itself is `Sync` because the inner data is\n-        // `Sync` as well, so we're ok loaning out an immutable pointer to\n-        // these contents.\n+        // This unsafety is ok because while this arc is alive we're guaranteed that the inner\n+        // pointer is valid. Furthermore, we know that the `ArcInner` structure itself is `Sync`\n+        // because the inner data is `Sync` as well, so we're ok loaning out an immutable pointer\n+        // to these contents.\n         unsafe { &*self._ptr }\n     }\n }\n \n-#[unstable = \"waiting on stability of Clone\"]\n+/// Get the number of weak references to this value.\n+#[inline]\n+#[experimental]\n+pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(atomic::SeqCst) - 1 }\n+\n+/// Get the number of strong references to this value.\n+#[inline]\n+#[experimental]\n+pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(atomic::SeqCst) }\n+\n+#[stable]\n impl<T> Clone for Arc<T> {\n-    /// Duplicate an atomically reference counted wrapper.\n+    /// Makes a clone of the `Arc<T>`.\n+    ///\n+    /// This increases the strong reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n     ///\n-    /// The resulting two `Arc` objects will point to the same underlying data\n-    /// object. However, one of the `Arc` objects can be sent to another task,\n-    /// allowing them to share the underlying data.\n+    /// five.clone();\n+    /// ```\n     #[inline]\n     fn clone(&self) -> Arc<T> {\n-        // Using a relaxed ordering is alright here, as knowledge of the\n-        // original reference prevents other threads from erroneously deleting\n-        // the object.\n+        // Using a relaxed ordering is alright here, as knowledge of the original reference\n+        // prevents other threads from erroneously deleting the object.\n         //\n-        // As explained in the [Boost documentation][1], Increasing the\n-        // reference counter can always be done with memory_order_relaxed: New\n-        // references to an object can only be formed from an existing\n-        // reference, and passing an existing reference from one thread to\n-        // another must already provide any required synchronization.\n+        // As explained in the [Boost documentation][1], Increasing the reference counter can\n+        // always be done with memory_order_relaxed: New references to an object can only be formed\n+        // from an existing reference, and passing an existing reference from one thread to another\n+        // must already provide any required synchronization.\n         //\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n         self.inner().strong.fetch_add(1, atomic::Relaxed);\n         Arc { _ptr: self._ptr }\n     }\n }\n \n+impl<T> BorrowFrom<Arc<T>> for T {\n+    fn borrow_from(owned: &Arc<T>) -> &T {\n+        &**owned\n+    }\n+}\n+\n #[experimental = \"Deref is experimental.\"]\n impl<T> Deref<T> for Arc<T> {\n     #[inline]\n@@ -153,26 +244,33 @@ impl<T> Deref<T> for Arc<T> {\n }\n \n impl<T: Send + Sync + Clone> Arc<T> {\n-    /// Acquires a mutable pointer to the inner contents by guaranteeing that\n-    /// the reference count is one (no sharing is possible).\n+    /// Make a mutable reference from the given `Arc<T>`.\n+    ///\n+    /// This is also referred to as a copy-on-write operation because the inner data is cloned if\n+    /// the reference count is greater than one.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n     ///\n-    /// This is also referred to as a copy-on-write operation because the inner\n-    /// data is cloned if the reference count is greater than one.\n+    /// let mut five = Arc::new(5i);\n+    ///\n+    /// let mut_five = five.make_unique();\n+    /// ```\n     #[inline]\n     #[experimental]\n     pub fn make_unique(&mut self) -> &mut T {\n-        // Note that we hold a strong reference, which also counts as\n-        // a weak reference, so we only clone if there is an\n-        // additional reference of either kind.\n+        // Note that we hold a strong reference, which also counts as a weak reference, so we only\n+        // clone if there is an additional reference of either kind.\n         if self.inner().strong.load(atomic::SeqCst) != 1 ||\n            self.inner().weak.load(atomic::SeqCst) != 1 {\n             *self = Arc::new((**self).clone())\n         }\n-        // This unsafety is ok because we're guaranteed that the pointer\n-        // returned is the *only* pointer that will ever be returned to T. Our\n-        // reference count is guaranteed to be 1 at this point, and we required\n-        // the Arc itself to be `mut`, so we're returning the only possible\n-        // reference to the inner data.\n+        // This unsafety is ok because we're guaranteed that the pointer returned is the *only*\n+        // pointer that will ever be returned to T. Our reference count is guaranteed to be 1 at\n+        // this point, and we required the Arc itself to be `mut`, so we're returning the only\n+        // possible reference to the inner data.\n         let inner = unsafe { &mut *self._ptr };\n         &mut inner.data\n     }\n@@ -181,38 +279,59 @@ impl<T: Send + Sync + Clone> Arc<T> {\n #[unsafe_destructor]\n #[experimental = \"waiting on stability of Drop\"]\n impl<T: Sync + Send> Drop for Arc<T> {\n+    /// Drops the `Arc<T>`.\n+    ///\n+    /// This will decrement the strong reference count. If the strong reference count becomes zero\n+    /// and the only other references are `Weak<T>` ones, `drop`s the inner value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// {\n+    ///     let five = Arc::new(5i);\n+    ///\n+    ///     // stuff\n+    ///\n+    ///     drop(five); // explict drop\n+    /// }\n+    /// {\n+    ///     let five = Arc::new(5i);\n+    ///\n+    ///     // stuff\n+    ///\n+    /// } // implicit drop\n+    /// ```\n     fn drop(&mut self) {\n-        // This structure has #[unsafe_no_drop_flag], so this drop glue may run\n-        // more than once (but it is guaranteed to be zeroed after the first if\n-        // it's run more than once)\n+        // This structure has #[unsafe_no_drop_flag], so this drop glue may run more than once (but\n+        // it is guaranteed to be zeroed after the first if it's run more than once)\n         if self._ptr.is_null() { return }\n \n-        // Because `fetch_sub` is already atomic, we do not need to synchronize\n-        // with other threads unless we are going to delete the object. This\n-        // same logic applies to the below `fetch_sub` to the `weak` count.\n+        // Because `fetch_sub` is already atomic, we do not need to synchronize with other threads\n+        // unless we are going to delete the object. This same logic applies to the below\n+        // `fetch_sub` to the `weak` count.\n         if self.inner().strong.fetch_sub(1, atomic::Release) != 1 { return }\n \n-        // This fence is needed to prevent reordering of use of the data and\n-        // deletion of the data. Because it is marked `Release`, the\n-        // decreasing of the reference count synchronizes with this `Acquire`\n-        // fence. This means that use of the data happens before decreasing\n-        // the reference count, which happens before this fence, which\n-        // happens before the deletion of the data.\n+        // This fence is needed to prevent reordering of use of the data and deletion of the data.\n+        // Because it is marked `Release`, the decreasing of the reference count synchronizes with\n+        // this `Acquire` fence. This means that use of the data happens before decreasing the\n+        // reference count, which happens before this fence, which happens before the deletion of\n+        // the data.\n         //\n         // As explained in the [Boost documentation][1],\n         //\n-        // It is important to enforce any possible access to the object in\n-        // one thread (through an existing reference) to *happen before*\n-        // deleting the object in a different thread. This is achieved by a\n-        // \"release\" operation after dropping a reference (any access to the\n-        // object through this reference must obviously happened before),\n-        // and an \"acquire\" operation before deleting the object.\n+        // > It is important to enforce any possible access to the object in one thread (through an\n+        // > existing reference) to *happen before* deleting the object in a different thread. This\n+        // > is achieved by a \"release\" operation after dropping a reference (any access to the\n+        // > object through this reference must obviously happened before), and an \"acquire\"\n+        // > operation before deleting the object.\n         //\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n         atomic::fence(atomic::Acquire);\n \n-        // Destroy the data at this time, even though we may not free the box\n-        // allocation itself (there may still be weak pointers lying around).\n+        // Destroy the data at this time, even though we may not free the box allocation itself\n+        // (there may still be weak pointers lying around).\n         unsafe { drop(ptr::read(&self.inner().data)); }\n \n         if self.inner().weak.fetch_sub(1, atomic::Release) == 1 {\n@@ -225,14 +344,26 @@ impl<T: Sync + Send> Drop for Arc<T> {\n \n #[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T: Sync + Send> Weak<T> {\n-    /// Attempts to upgrade this weak reference to a strong reference.\n+    /// Upgrades a weak reference to a strong reference.\n+    ///\n+    /// Upgrades the `Weak<T>` reference to an `Arc<T>`, if possible.\n+    ///\n+    /// Returns `None` if there were no strong references and the data was destroyed.\n+    ///\n+    /// # Examples\n     ///\n-    /// This method will not upgrade this reference if the strong reference count has already\n-    /// reached 0, but if there are still other active strong references this function will return\n-    /// a new strong reference to the data.\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// let weak_five = five.downgrade();\n+    ///\n+    /// let strong_five: Option<Arc<_>> = weak_five.upgrade();\n+    /// ```\n     pub fn upgrade(&self) -> Option<Arc<T>> {\n-        // We use a CAS loop to increment the strong count instead of a\n-        // fetch_add because once the count hits 0 is must never be above 0.\n+        // We use a CAS loop to increment the strong count instead of a fetch_add because once the\n+        // count hits 0 is must never be above 0.\n         let inner = self.inner();\n         loop {\n             let n = inner.strong.load(atomic::SeqCst);\n@@ -251,6 +382,19 @@ impl<T: Sync + Send> Weak<T> {\n \n #[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T: Sync + Send> Clone for Weak<T> {\n+    /// Makes a clone of the `Weak<T>`.\n+    ///\n+    /// This increases the weak reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let weak_five = Arc::new(5i).downgrade();\n+    ///\n+    /// weak_five.clone();\n+    /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n         // See comments in Arc::clone() for why this is relaxed\n@@ -262,13 +406,37 @@ impl<T: Sync + Send> Clone for Weak<T> {\n #[unsafe_destructor]\n #[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T: Sync + Send> Drop for Weak<T> {\n+    /// Drops the `Weak<T>`.\n+    ///\n+    /// This will decrement the weak reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// {\n+    ///     let five = Arc::new(5i);\n+    ///     let weak_five = five.downgrade();\n+    ///\n+    ///     // stuff\n+    ///\n+    ///     drop(weak_five); // explict drop\n+    /// }\n+    /// {\n+    ///     let five = Arc::new(5i);\n+    ///     let weak_five = five.downgrade();\n+    ///\n+    ///     // stuff\n+    ///\n+    /// } // implicit drop\n+    /// ```\n     fn drop(&mut self) {\n         // see comments above for why this check is here\n         if self._ptr.is_null() { return }\n \n-        // If we find out that we were the last weak pointer, then its time to\n-        // deallocate the data entirely. See the discussion in Arc::drop() about\n-        // the memory orderings\n+        // If we find out that we were the last weak pointer, then its time to deallocate the data\n+        // entirely. See the discussion in Arc::drop() about the memory orderings\n         if self.inner().weak.fetch_sub(1, atomic::Release) == 1 {\n             atomic::fence(atomic::Acquire);\n             unsafe { deallocate(self._ptr as *mut u8, size_of::<ArcInner<T>>(),\n@@ -279,18 +447,114 @@ impl<T: Sync + Send> Drop for Weak<T> {\n \n #[unstable = \"waiting on PartialEq\"]\n impl<T: PartialEq> PartialEq for Arc<T> {\n+    /// Equality for two `Arc<T>`s.\n+    ///\n+    /// Two `Arc<T>`s are equal if their inner value are equal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// five == Arc::new(5i);\n+    /// ```\n     fn eq(&self, other: &Arc<T>) -> bool { *(*self) == *(*other) }\n+\n+    /// Inequality for two `Arc<T>`s.\n+    ///\n+    /// Two `Arc<T>`s are unequal if their inner value are unequal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// five != Arc::new(5i);\n+    /// ```\n     fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }\n }\n #[unstable = \"waiting on PartialOrd\"]\n impl<T: PartialOrd> PartialOrd for Arc<T> {\n+    /// Partial comparison for two `Arc<T>`s.\n+    ///\n+    /// The two are compared by calling `partial_cmp()` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// five.partial_cmp(&Arc::new(5i));\n+    /// ```\n     fn partial_cmp(&self, other: &Arc<T>) -> Option<Ordering> {\n         (**self).partial_cmp(&**other)\n     }\n+\n+    /// Less-than comparison for two `Arc<T>`s.\n+    ///\n+    /// The two are compared by calling `<` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// five < Arc::new(5i);\n+    /// ```\n     fn lt(&self, other: &Arc<T>) -> bool { *(*self) < *(*other) }\n+\n+    /// 'Less-than or equal to' comparison for two `Arc<T>`s.\n+    ///\n+    /// The two are compared by calling `<=` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// five <= Arc::new(5i);\n+    /// ```\n     fn le(&self, other: &Arc<T>) -> bool { *(*self) <= *(*other) }\n-    fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n+\n+    /// Greater-than comparison for two `Arc<T>`s.\n+    ///\n+    /// The two are compared by calling `>` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// five > Arc::new(5i);\n+    /// ```\n     fn gt(&self, other: &Arc<T>) -> bool { *(*self) > *(*other) }\n+\n+    /// 'Greater-than or equal to' comparison for two `Arc<T>`s.\n+    ///\n+    /// The two are compared by calling `>=` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// five >= Arc::new(5i);\n+    /// ```\n+    fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n }\n #[unstable = \"waiting on Ord\"]\n impl<T: Ord> Ord for Arc<T> {\n@@ -305,7 +569,9 @@ impl<T: fmt::Show> fmt::Show for Arc<T> {\n     }\n }\n \n+#[stable]\n impl<T: Default + Sync + Send> Default for Arc<T> {\n+    #[stable]\n     fn default() -> Arc<T> { Arc::new(Default::default()) }\n }\n \n@@ -316,12 +582,13 @@ mod tests {\n     use std::comm::channel;\n     use std::mem::drop;\n     use std::ops::Drop;\n-    use std::option::{Option, Some, None};\n+    use std::option::Option;\n+    use std::option::Option::{Some, None};\n     use std::str::Str;\n     use std::sync::atomic;\n     use std::task;\n     use std::vec::Vec;\n-    use super::{Arc, Weak};\n+    use super::{Arc, Weak, weak_count, strong_count};\n     use std::sync::Mutex;\n \n     struct Canary(*mut atomic::AtomicUint);\n@@ -346,7 +613,7 @@ mod tests {\n \n         let (tx, rx) = channel();\n \n-        task::spawn(proc() {\n+        task::spawn(move || {\n             let arc_v: Arc<Vec<int>> = rx.recv();\n             assert_eq!((*arc_v)[3], 4);\n         });\n@@ -465,10 +732,53 @@ mod tests {\n         drop(arc_weak);\n     }\n \n+    #[test]\n+    fn test_strong_count() {\n+        let a = Arc::new(0u32);\n+        assert!(strong_count(&a) == 1);\n+        let w = a.downgrade();\n+        assert!(strong_count(&a) == 1);\n+        let b = w.upgrade().expect(\"\");\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&a) == 2);\n+        drop(w);\n+        drop(a);\n+        assert!(strong_count(&b) == 1);\n+        let c = b.clone();\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&c) == 2);\n+    }\n+\n+    #[test]\n+    fn test_weak_count() {\n+        let a = Arc::new(0u32);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n+        let w = a.downgrade();\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 1);\n+        let x = w.clone();\n+        assert!(weak_count(&a) == 2);\n+        drop(w);\n+        drop(x);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n+        let c = a.clone();\n+        assert!(strong_count(&a) == 2);\n+        assert!(weak_count(&a) == 0);\n+        let d = c.downgrade();\n+        assert!(weak_count(&c) == 1);\n+        assert!(strong_count(&c) == 2);\n+\n+        drop(a);\n+        drop(c);\n+        drop(d);\n+    }\n+\n     #[test]\n     fn show_arc() {\n         let a = Arc::new(5u32);\n-        assert!(format!(\"{}\", a).as_slice() == \"5\")\n+        assert!(format!(\"{}\", a) == \"5\")\n     }\n \n     // Make sure deriving works with Arc<T>"}, {"sha": "5fd234192c515f9f879e580748d9c9f149140244", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -15,12 +15,14 @@ use core::clone::Clone;\n use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n-use core::intrinsics;\n+use core::hash::{mod, Hash};\n use core::kinds::Sized;\n use core::mem;\n use core::option::Option;\n use core::raw::TraitObject;\n-use core::result::{Ok, Err, Result};\n+use core::result::Result;\n+use core::result::Result::{Ok, Err};\n+use core::ops::{Deref, DerefMut};\n \n /// A value that represents the global exchange heap. This is the default\n /// place that the `box` keyword allocates into when no place is supplied.\n@@ -44,15 +46,19 @@ pub static HEAP: () = ();\n #[unstable = \"custom allocators will add an additional type parameter (with default)\"]\n pub struct Box<T>(*mut T);\n \n+#[stable]\n impl<T: Default> Default for Box<T> {\n+    #[stable]\n     fn default() -> Box<T> { box Default::default() }\n }\n \n+#[stable]\n impl<T> Default for Box<[T]> {\n+    #[stable]\n     fn default() -> Box<[T]> { box [] }\n }\n \n-#[unstable]\n+#[stable]\n impl<T: Clone> Clone for Box<T> {\n     /// Returns a copy of the owned box.\n     #[inline]\n@@ -93,6 +99,14 @@ impl<Sized? T: Ord> Ord for Box<T> {\n }\n impl<Sized? T: Eq> Eq for Box<T> {}\n \n+impl<S: hash::Writer, Sized? T: Hash<S>> Hash<S> for Box<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (**self).hash(state);\n+    }\n+}\n+\n+\n /// Extension methods for an owning `Any` trait object.\n #[unstable = \"post-DST and coherence changes, this will not be a trait but \\\n               rather a direct `impl` on `Box<Any>`\"]\n@@ -104,17 +118,14 @@ pub trait BoxAny {\n }\n \n #[stable]\n-impl BoxAny for Box<Any+'static> {\n+impl BoxAny for Box<Any> {\n     #[inline]\n-    fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any+'static>> {\n+    fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n                 let to: TraitObject =\n-                    *mem::transmute::<&Box<Any>, &TraitObject>(&self);\n-\n-                // Prevent destructor on self being run\n-                intrinsics::forget(self);\n+                    mem::transmute::<Box<Any>, TraitObject>(self);\n \n                 // Extract the data pointer\n                 Ok(mem::transmute(to.data))\n@@ -137,6 +148,14 @@ impl fmt::Show for Box<Any+'static> {\n     }\n }\n \n+impl<Sized? T> Deref<T> for Box<T> {\n+    fn deref(&self) -> &T { &**self }\n+}\n+\n+impl<Sized? T> DerefMut<T> for Box<T> {\n+    fn deref_mut(&mut self) -> &mut T { &mut **self }\n+}\n+\n #[cfg(test)]\n mod test {\n     #[test]\n@@ -173,14 +192,20 @@ mod test {\n         let b = box Test as Box<Any>;\n         let a_str = a.to_str();\n         let b_str = b.to_str();\n-        assert_eq!(a_str.as_slice(), \"Box<Any>\");\n-        assert_eq!(b_str.as_slice(), \"Box<Any>\");\n+        assert_eq!(a_str, \"Box<Any>\");\n+        assert_eq!(b_str, \"Box<Any>\");\n \n         let a = &8u as &Any;\n         let b = &Test as &Any;\n         let s = format!(\"{}\", a);\n-        assert_eq!(s.as_slice(), \"&Any\");\n+        assert_eq!(s, \"&Any\");\n         let s = format!(\"{}\", b);\n-        assert_eq!(s.as_slice(), \"&Any\");\n+        assert_eq!(s, \"&Any\");\n+    }\n+\n+    #[test]\n+    fn deref() {\n+        fn homura<T: Deref<i32>>(_: T) { }\n+        homura(box 765i32);\n     }\n }"}, {"sha": "c6b6a784f06e3f912f085a9f1d0cc0e6f3f30426", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 57, "deletions": 4, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -123,9 +123,62 @@ const MIN_ALIGN: uint = 8;\n           target_arch = \"x86_64\"))]\n const MIN_ALIGN: uint = 16;\n \n-#[cfg(jemalloc)]\n+#[cfg(external_funcs)]\n mod imp {\n-    use core::option::{None, Option};\n+    extern {\n+        fn rust_allocate(size: uint, align: uint) -> *mut u8;\n+        fn rust_deallocate(ptr: *mut u8, old_size: uint, align: uint);\n+        fn rust_reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8;\n+        fn rust_reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint,\n+                                   align: uint) -> uint;\n+        fn rust_usable_size(size: uint, align: uint) -> uint;\n+        fn rust_stats_print();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+        rust_allocate(size, align)\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint,\n+                                     align: uint) -> uint {\n+        rust_reallocate_inplace(ptr, old_size, size, align)\n+    }\n+\n+    #[inline]\n+    pub unsafe fn deallocate(ptr: *mut u8, old_size: uint, align: uint) {\n+        rust_deallocate(ptr, old_size, align)\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint,\n+                                     align: uint) -> uint {\n+        rust_reallocate_inplace(ptr, old_size, size, align)\n+    }\n+\n+    #[inline]\n+    pub fn usable_size(size: uint, align: uint) -> uint {\n+        unsafe { rust_usable_size(size, align) }\n+    }\n+\n+    #[inline]\n+    pub fn stats_print() {\n+        unsafe { rust_stats_print() }\n+    }\n+}\n+\n+#[cfg(external_crate)]\n+mod imp {\n+    extern crate external;\n+    pub use self::external::{allocate, deallocate, reallocate_inplace, reallocate};\n+    pub use self::external::{usable_size, stats_print};\n+}\n+\n+#[cfg(all(not(external_funcs), not(external_crate), jemalloc))]\n+mod imp {\n+    use core::option::Option;\n+    use core::option::Option::None;\n     use core::ptr::{null_mut, null};\n     use core::num::Int;\n     use libc::{c_char, c_int, c_void, size_t};\n@@ -199,7 +252,7 @@ mod imp {\n     }\n }\n \n-#[cfg(all(not(jemalloc), unix))]\n+#[cfg(all(not(external_funcs), not(external_crate), not(jemalloc), unix))]\n mod imp {\n     use core::cmp;\n     use core::ptr;\n@@ -260,7 +313,7 @@ mod imp {\n     pub fn stats_print() {}\n }\n \n-#[cfg(all(not(jemalloc), windows))]\n+#[cfg(all(not(external_funcs), not(external_crate), not(jemalloc), windows))]\n mod imp {\n     use libc::{c_void, size_t};\n     use libc;"}, {"sha": "61b5d43d1cb5011449f3e216135d14ff73a3112f", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -58,14 +58,13 @@\n \n #![crate_name = \"alloc\"]\n #![experimental]\n-#![license = \"MIT/ASL2\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![no_std]\n-#![feature(lang_items, phase, unsafe_destructor)]\n+#![feature(lang_items, phase, unsafe_destructor, default_type_params)]\n \n #[phase(plugin, link)]\n extern crate core;"}, {"sha": "dfa55848c90dadf65bd4bb8ed596b55e3c550115", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 378, "deletions": 79, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -8,27 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Task-local reference-counted boxes (the `Rc` type).\n+//! Task-local reference-counted boxes (the `Rc<T>` type).\n //!\n-//! The `Rc` type provides shared ownership of an immutable value. Destruction is\n-//! deterministic, and will occur as soon as the last owner is gone. It is marked\n-//! as non-sendable because it avoids the overhead of atomic reference counting.\n+//! The `Rc<T>` type provides shared ownership of an immutable value. Destruction is deterministic,\n+//! and will occur as soon as the last owner is gone. It is marked as non-sendable because it\n+//! avoids the overhead of atomic reference counting.\n //!\n-//! The `downgrade` method can be used to create a non-owning `Weak` pointer to the\n-//! box. A `Weak` pointer can be upgraded to an `Rc` pointer, but will return\n-//! `None` if the value has already been freed.\n+//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer to the box. A\n+//! `Weak<T>` pointer can be upgraded to an `Rc<T>` pointer, but will return `None` if the value\n+//! has already been dropped.\n //!\n-//! For example, a tree with parent pointers can be represented by putting the\n-//! nodes behind strong `Rc` pointers, and then storing the parent pointers as\n-//! `Weak` pointers.\n+//! For example, a tree with parent pointers can be represented by putting the nodes behind strong\n+//! `Rc<T>` pointers, and then storing the parent pointers as `Weak<T>` pointers.\n //!\n //! # Examples\n //!\n-//! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.\n-//! We want to have our `Gadget`s point to their `Owner`. We can't do this with\n-//! unique ownership, because more than one gadget may belong to the same\n-//! `Owner`. `Rc` allows us to share an `Owner` between multiple `Gadget`s, and\n-//! have the `Owner` kept alive as long as any `Gadget` points at it.\n+//! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.  We want to have our\n+//! `Gadget`s point to their `Owner`. We can't do this with unique ownership, because more than one\n+//! gadget may belong to the same `Owner`. `Rc<T>` allows us to share an `Owner` between multiple\n+//! `Gadget`s, and have the `Owner` remain allocated as long as any `Gadget` points at it.\n //!\n //! ```rust\n //! use std::rc::Rc;\n@@ -51,7 +49,7 @@\n //!     );\n //!\n //!     // Create Gadgets belonging to gadget_owner. To increment the reference\n-//!     // count we clone the Rc object.\n+//!     // count we clone the `Rc<T>` object.\n //!     let gadget1 = Gadget { id: 1, owner: gadget_owner.clone() };\n //!     let gadget2 = Gadget { id: 2, owner: gadget_owner.clone() };\n //!\n@@ -60,8 +58,8 @@\n //!     // Despite dropping gadget_owner, we're still able to print out the name of\n //!     // the Owner of the Gadgets. This is because we've only dropped the\n //!     // reference count object, not the Owner it wraps. As long as there are\n-//!     // other Rc objects pointing at the same Owner, it will stay alive. Notice\n-//!     // that the Rc wrapper around Gadget.owner gets automatically dereferenced\n+//!     // other `Rc<T>` objects pointing at the same Owner, it will remain allocated. Notice\n+//!     // that the `Rc<T>` wrapper around Gadget.owner gets automatically dereferenced\n //!     // for us.\n //!     println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n //!     println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n@@ -72,23 +70,19 @@\n //! }\n //! ```\n //!\n-//! If our requirements change, and we also need to be able to traverse from\n-//! Owner \u2192\u00a0Gadget, we will run into problems: an `Rc` pointer from Owner \u2192\u00a0Gadget\n-//! introduces a cycle between the objects. This means that their reference counts\n-//! can never reach 0, and the objects will stay alive: a memory leak. In order to\n-//! get around this, we can use `Weak` pointers. These are reference counted\n-//! pointers that don't keep an object alive if there are no normal `Rc` (or\n-//! *strong*) pointers left.\n+//! If our requirements change, and we also need to be able to traverse from Owner \u2192\u00a0Gadget, we\n+//! will run into problems: an `Rc<T>` pointer from Owner \u2192\u00a0Gadget introduces a cycle between the\n+//! objects. This means that their reference counts can never reach 0, and the objects will remain\n+//! allocated: a memory leak. In order to get around this, we can use `Weak<T>` pointers. These\n+//! pointers don't contribute to the total count.\n //!\n-//! Rust actually makes it somewhat difficult to produce this loop in the first\n-//! place: in order to end up with two objects that point at each other, one of\n-//! them needs to be mutable. This is problematic because `Rc` enforces memory\n-//! safety by only giving out shared references to the object it wraps, and these\n-//! don't allow direct mutation. We need to wrap the part of the object we wish to\n-//! mutate in a `RefCell`, which provides *interior mutability*: a method to\n-//! achieve mutability through a shared reference. `RefCell` enforces Rust's\n-//! borrowing rules at runtime. Read the `Cell` documentation for more details on\n-//! interior mutability.\n+//! Rust actually makes it somewhat difficult to produce this loop in the first place: in order to\n+//! end up with two objects that point at each other, one of them needs to be mutable. This is\n+//! problematic because `Rc<T>` enforces memory safety by only giving out shared references to the\n+//! object it wraps, and these don't allow direct mutation. We need to wrap the part of the object\n+//! we wish to mutate in a `RefCell`, which provides *interior mutability*: a method to achieve\n+//! mutability through a shared reference. `RefCell` enforces Rust's borrowing rules at runtime.\n+//! Read the `Cell` documentation for more details on interior mutability.\n //!\n //! ```rust\n //! use std::rc::Rc;\n@@ -131,34 +125,38 @@\n //!     for gadget_opt in gadget_owner.gadgets.borrow().iter() {\n //!\n //!         // gadget_opt is a Weak<Gadget>. Since weak pointers can't guarantee\n-//!         // that their object is still alive, we need to call upgrade() on them\n+//!         // that their object is still allocated, we need to call upgrade() on them\n //!         // to turn them into a strong reference. This returns an Option, which\n //!         // contains a reference to our object if it still exists.\n //!         let gadget = gadget_opt.upgrade().unwrap();\n //!         println!(\"Gadget {} owned by {}\", gadget.id, gadget.owner.name);\n //!     }\n //!\n //!     // At the end of the method, gadget_owner, gadget1 and gadget2 get\n-//!     // destroyed. There are now no strong (Rc) references to the gadgets.\n+//!     // destroyed. There are now no strong (`Rc<T>`) references to the gadgets.\n //!     // Once they get destroyed, the Gadgets get destroyed. This zeroes the\n //!     // reference count on Gadget Man, so he gets destroyed as well.\n //! }\n //! ```\n \n #![stable]\n \n+use core::borrow::BorrowFrom;\n use core::cell::Cell;\n use core::clone::Clone;\n use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n+use core::hash::{mod, Hash};\n use core::kinds::marker;\n use core::mem::{transmute, min_align_of, size_of, forget};\n use core::ops::{Deref, Drop};\n-use core::option::{Option, Some, None};\n+use core::option::Option;\n+use core::option::Option::{Some, None};\n use core::ptr;\n use core::ptr::RawPtr;\n-use core::result::{Result, Ok, Err};\n+use core::result::Result;\n+use core::result::Result::{Ok, Err};\n \n use heap::deallocate;\n \n@@ -169,27 +167,35 @@ struct RcBox<T> {\n }\n \n /// An immutable reference-counted pointer type.\n+///\n+/// See the [module level documentation](../index.html) for more details.\n #[unsafe_no_drop_flag]\n #[stable]\n pub struct Rc<T> {\n-    // FIXME #12808: strange names to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n+    // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n+    // type via Deref\n     _ptr: *mut RcBox<T>,\n     _nosend: marker::NoSend,\n     _noshare: marker::NoSync\n }\n \n impl<T> Rc<T> {\n-    /// Constructs a new reference-counted pointer.\n+    /// Constructs a new `Rc<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    /// ```\n     #[stable]\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n-                // there is an implicit weak pointer owned by all the\n-                // strong pointers, which ensures that the weak\n-                // destructor never frees the allocation while the\n-                // strong destructor is running, even if the weak\n-                // pointer is stored inside the strong one.\n+                // there is an implicit weak pointer owned by all the strong pointers, which\n+                // ensures that the weak destructor never frees the allocation while the strong\n+                // destructor is running, even if the weak pointer is stored inside the strong one.\n                 _ptr: transmute(box RcBox {\n                     value: value,\n                     strong: Cell::new(1),\n@@ -201,7 +207,17 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    /// Downgrades the reference-counted pointer to a weak reference.\n+    /// Downgrades the `Rc<T>` to a `Weak<T>` reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// let weak_five = five.downgrade();\n+    /// ```\n     #[experimental = \"Weak pointers may not belong in this module\"]\n     pub fn downgrade(&self) -> Weak<T> {\n         self.inc_weak();\n@@ -213,28 +229,46 @@ impl<T> Rc<T> {\n     }\n }\n \n-/// Returns true if the `Rc` currently has unique ownership.\n+/// Get the number of weak references to this value.\n+#[inline]\n+#[experimental]\n+pub fn weak_count<T>(this: &Rc<T>) -> uint { this.weak() - 1 }\n+\n+/// Get the number of strong references to this value.\n+#[inline]\n+#[experimental]\n+pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n+\n+/// Returns true if there are no other `Rc` or `Weak<T>` values that share the same inner value.\n ///\n-/// Unique ownership means that there are no other `Rc` or `Weak` values\n-/// that share the same contents.\n+/// # Examples\n+///\n+/// ```\n+/// use std::rc;\n+/// use std::rc::Rc;\n+///\n+/// let five = Rc::new(5i);\n+///\n+/// rc::is_unique(&five);\n+/// ```\n #[inline]\n #[experimental]\n pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n-    // note that we hold both a strong and a weak reference\n-    rc.strong() == 1 && rc.weak() == 1\n+    weak_count(rc) == 0 && strong_count(rc) == 1\n }\n \n-/// Unwraps the contained value if the `Rc` has unique ownership.\n+/// Unwraps the contained value if the `Rc<T>` is unique.\n ///\n-/// If the `Rc` does not have unique ownership, `Err` is returned with the\n-/// same `Rc`.\n+/// If the `Rc<T>` is not unique, an `Err` is returned with the same `Rc<T>`.\n ///\n /// # Example\n ///\n /// ```\n /// use std::rc::{mod, Rc};\n+///\n /// let x = Rc::new(3u);\n /// assert_eq!(rc::try_unwrap(x), Ok(3u));\n+///\n /// let x = Rc::new(4u);\n /// let _y = x.clone();\n /// assert_eq!(rc::try_unwrap(x), Err(Rc::new(4u)));\n@@ -257,18 +291,19 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n     }\n }\n \n-/// Returns a mutable reference to the contained value if the `Rc` has\n-/// unique ownership.\n+/// Returns a mutable reference to the contained value if the `Rc<T>` is unique.\n ///\n-/// Returns `None` if the `Rc` does not have unique ownership.\n+/// Returns `None` if the `Rc<T>` is not unique.\n ///\n /// # Example\n ///\n /// ```\n /// use std::rc::{mod, Rc};\n+///\n /// let mut x = Rc::new(3u);\n /// *rc::get_mut(&mut x).unwrap() = 4u;\n /// assert_eq!(*x, 4u);\n+///\n /// let _y = x.clone();\n /// assert!(rc::get_mut(&mut x).is_none());\n /// ```\n@@ -284,30 +319,43 @@ pub fn get_mut<'a, T>(rc: &'a mut Rc<T>) -> Option<&'a mut T> {\n }\n \n impl<T: Clone> Rc<T> {\n-    /// Acquires a mutable pointer to the inner contents by guaranteeing that\n-    /// the reference count is one (no sharing is possible).\n+    /// Make a mutable reference from the given `Rc<T>`.\n+    ///\n+    /// This is also referred to as a copy-on-write operation because the inner data is cloned if\n+    /// the reference count is greater than one.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n     ///\n-    /// This is also referred to as a copy-on-write operation because the inner\n-    /// data is cloned if the reference count is greater than one.\n+    /// let mut five = Rc::new(5i);\n+    ///\n+    /// let mut_five = five.make_unique();\n+    /// ```\n     #[inline]\n     #[experimental]\n     pub fn make_unique(&mut self) -> &mut T {\n         if !is_unique(self) {\n             *self = Rc::new((**self).clone())\n         }\n-        // This unsafety is ok because we're guaranteed that the pointer\n-        // returned is the *only* pointer that will ever be returned to T. Our\n-        // reference count is guaranteed to be 1 at this point, and we required\n-        // the Rc itself to be `mut`, so we're returning the only possible\n-        // reference to the inner data.\n+        // This unsafety is ok because we're guaranteed that the pointer returned is the *only*\n+        // pointer that will ever be returned to T. Our reference count is guaranteed to be 1 at\n+        // this point, and we required the `Rc<T>` itself to be `mut`, so we're returning the only\n+        // possible reference to the inner value.\n         let inner = unsafe { &mut *self._ptr };\n         &mut inner.value\n     }\n }\n \n+impl<T> BorrowFrom<Rc<T>> for T {\n+    fn borrow_from(owned: &Rc<T>) -> &T {\n+        &**owned\n+    }\n+}\n+\n #[experimental = \"Deref is experimental.\"]\n impl<T> Deref<T> for Rc<T> {\n-    /// Borrows the value contained in the reference-counted pointer.\n     #[inline(always)]\n     fn deref(&self) -> &T {\n         &self.inner().value\n@@ -317,15 +365,39 @@ impl<T> Deref<T> for Rc<T> {\n #[unsafe_destructor]\n #[experimental = \"Drop is experimental.\"]\n impl<T> Drop for Rc<T> {\n+    /// Drops the `Rc<T>`.\n+    ///\n+    /// This will decrement the strong reference count. If the strong reference count becomes zero\n+    /// and the only other references are `Weak<T>` ones, `drop`s the inner value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// {\n+    ///     let five = Rc::new(5i);\n+    ///\n+    ///     // stuff\n+    ///\n+    ///     drop(five); // explict drop\n+    /// }\n+    /// {\n+    ///     let five = Rc::new(5i);\n+    ///\n+    ///     // stuff\n+    ///\n+    /// } // implicit drop\n+    /// ```\n     fn drop(&mut self) {\n         unsafe {\n             if !self._ptr.is_null() {\n                 self.dec_strong();\n                 if self.strong() == 0 {\n                     ptr::read(&**self); // destroy the contained object\n \n-                    // remove the implicit \"strong weak\" pointer now\n-                    // that we've destroyed the contents.\n+                    // remove the implicit \"strong weak\" pointer now that we've destroyed the\n+                    // contents.\n                     self.dec_weak();\n \n                     if self.weak() == 0 {\n@@ -338,8 +410,21 @@ impl<T> Drop for Rc<T> {\n     }\n }\n \n-#[unstable = \"Clone is unstable.\"]\n+#[stable]\n impl<T> Clone for Rc<T> {\n+    /// Makes a clone of the `Rc<T>`.\n+    ///\n+    /// This increases the strong reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five.clone();\n+    /// ```\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n         self.inc_strong();\n@@ -349,16 +434,54 @@ impl<T> Clone for Rc<T> {\n \n #[stable]\n impl<T: Default> Default for Rc<T> {\n+    /// Creates a new `Rc<T>`, with the `Default` value for `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    /// use std::default::Default;\n+    ///\n+    /// let x: Rc<int> = Default::default();\n+    /// ```\n     #[inline]\n+    #[stable]\n     fn default() -> Rc<T> {\n         Rc::new(Default::default())\n     }\n }\n \n #[unstable = \"PartialEq is unstable.\"]\n impl<T: PartialEq> PartialEq for Rc<T> {\n+    /// Equality for two `Rc<T>`s.\n+    ///\n+    /// Two `Rc<T>`s are equal if their inner value are equal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five == Rc::new(5i);\n+    /// ```\n     #[inline(always)]\n     fn eq(&self, other: &Rc<T>) -> bool { **self == **other }\n+\n+    /// Inequality for two `Rc<T>`s.\n+    ///\n+    /// Two `Rc<T>`s are unequal if their inner value are unequal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five != Rc::new(5i);\n+    /// ```\n     #[inline(always)]\n     fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n }\n@@ -368,38 +491,128 @@ impl<T: Eq> Eq for Rc<T> {}\n \n #[unstable = \"PartialOrd is unstable.\"]\n impl<T: PartialOrd> PartialOrd for Rc<T> {\n+    /// Partial comparison for two `Rc<T>`s.\n+    ///\n+    /// The two are compared by calling `partial_cmp()` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five.partial_cmp(&Rc::new(5i));\n+    /// ```\n     #[inline(always)]\n     fn partial_cmp(&self, other: &Rc<T>) -> Option<Ordering> {\n         (**self).partial_cmp(&**other)\n     }\n \n+    /// Less-than comparison for two `Rc<T>`s.\n+    ///\n+    /// The two are compared by calling `<` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five < Rc::new(5i);\n+    /// ```\n     #[inline(always)]\n     fn lt(&self, other: &Rc<T>) -> bool { **self < **other }\n \n+    /// 'Less-than or equal to' comparison for two `Rc<T>`s.\n+    ///\n+    /// The two are compared by calling `<=` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five <= Rc::new(5i);\n+    /// ```\n     #[inline(always)]\n     fn le(&self, other: &Rc<T>) -> bool { **self <= **other }\n \n+    /// Greater-than comparison for two `Rc<T>`s.\n+    ///\n+    /// The two are compared by calling `>` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five > Rc::new(5i);\n+    /// ```\n     #[inline(always)]\n     fn gt(&self, other: &Rc<T>) -> bool { **self > **other }\n \n+    /// 'Greater-than or equal to' comparison for two `Rc<T>`s.\n+    ///\n+    /// The two are compared by calling `>=` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five >= Rc::new(5i);\n+    /// ```\n     #[inline(always)]\n     fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n }\n \n #[unstable = \"Ord is unstable.\"]\n impl<T: Ord> Ord for Rc<T> {\n+    /// Comparison for two `Rc<T>`s.\n+    ///\n+    /// The two are compared by calling `cmp()` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// five.partial_cmp(&Rc::new(5i));\n+    /// ```\n     #[inline]\n     fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n \n+// FIXME (#18248) Make `T` `Sized?`\n+impl<S: hash::Writer, T: Hash<S>> Hash<S> for Rc<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (**self).hash(state);\n+    }\n+}\n+\n #[experimental = \"Show is experimental.\"]\n impl<T: fmt::Show> fmt::Show for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         (**self).fmt(f)\n     }\n }\n \n-/// A weak reference to a reference-counted pointer.\n+/// A weak version of `Rc<T>`.\n+///\n+/// Weak references do not count when determining if the inner value should be dropped.\n+///\n+/// See the [module level documentation](../index.html) for more.\n #[unsafe_no_drop_flag]\n #[experimental = \"Weak pointers may not belong in this module.\"]\n pub struct Weak<T> {\n@@ -414,8 +627,21 @@ pub struct Weak<T> {\n impl<T> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n     ///\n-    /// Returns `None` if there were no strong references and the data was\n-    /// destroyed.\n+    /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n+    ///\n+    /// Returns `None` if there were no strong references and the data was destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5i);\n+    ///\n+    /// let weak_five = five.downgrade();\n+    ///\n+    /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n+    /// ```\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n         if self.strong() == 0 {\n             None\n@@ -429,12 +655,37 @@ impl<T> Weak<T> {\n #[unsafe_destructor]\n #[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T> Drop for Weak<T> {\n+    /// Drops the `Weak<T>`.\n+    ///\n+    /// This will decrement the weak reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// {\n+    ///     let five = Rc::new(5i);\n+    ///     let weak_five = five.downgrade();\n+    ///\n+    ///     // stuff\n+    ///\n+    ///     drop(weak_five); // explict drop\n+    /// }\n+    /// {\n+    ///     let five = Rc::new(5i);\n+    ///     let weak_five = five.downgrade();\n+    ///\n+    ///     // stuff\n+    ///\n+    /// } // implicit drop\n+    /// ```\n     fn drop(&mut self) {\n         unsafe {\n             if !self._ptr.is_null() {\n                 self.dec_weak();\n-                // the weak count starts at 1, and will only go to\n-                // zero if all the strong pointers have disappeared.\n+                // the weak count starts at 1, and will only go to zero if all the strong pointers\n+                // have disappeared.\n                 if self.weak() == 0 {\n                     deallocate(self._ptr as *mut u8, size_of::<RcBox<T>>(),\n                                min_align_of::<RcBox<T>>())\n@@ -446,6 +697,19 @@ impl<T> Drop for Weak<T> {\n \n #[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T> Clone for Weak<T> {\n+    /// Makes a clone of the `Weak<T>`.\n+    ///\n+    /// This increases the weak reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let weak_five = Rc::new(5i).downgrade();\n+    ///\n+    /// weak_five.clone();\n+    /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n         self.inc_weak();\n@@ -489,10 +753,11 @@ impl<T> RcBoxPtr<T> for Weak<T> {\n #[cfg(test)]\n #[allow(experimental)]\n mod tests {\n-    use super::{Rc, Weak};\n+    use super::{Rc, Weak, weak_count, strong_count};\n     use std::cell::RefCell;\n-    use std::option::{Option, Some, None};\n-    use std::result::{Err, Ok};\n+    use std::option::Option;\n+    use std::option::Option::{Some, None};\n+    use std::result::Result::{Err, Ok};\n     use std::mem::drop;\n     use std::clone::Clone;\n \n@@ -566,6 +831,40 @@ mod tests {\n         assert!(super::is_unique(&x));\n     }\n \n+    #[test]\n+    fn test_strong_count() {\n+        let a = Rc::new(0u32);\n+        assert!(strong_count(&a) == 1);\n+        let w = a.downgrade();\n+        assert!(strong_count(&a) == 1);\n+        let b = w.upgrade().expect(\"upgrade of live rc failed\");\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&a) == 2);\n+        drop(w);\n+        drop(a);\n+        assert!(strong_count(&b) == 1);\n+        let c = b.clone();\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&c) == 2);\n+    }\n+\n+    #[test]\n+    fn test_weak_count() {\n+        let a = Rc::new(0u32);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n+        let w = a.downgrade();\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 1);\n+        drop(w);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n+        let c = a.clone();\n+        assert!(strong_count(&a) == 2);\n+        assert!(weak_count(&a) == 0);\n+        drop(c);\n+    }\n+\n     #[test]\n     fn try_unwrap() {\n         let x = Rc::new(3u);"}, {"sha": "1f4df1fd0a5a28e1199ac28ca10c0ec90bc39433", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -23,12 +23,12 @@\n #![experimental]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n-#![license = \"MIT/ASL2\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(unsafe_destructor)]\n+#![feature(unboxed_closures)]\n #![allow(missing_docs)]\n \n extern crate alloc;\n@@ -210,7 +210,7 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_copy<T>(&self, op: || -> T) -> &mut T {\n+    fn alloc_copy<T, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n         unsafe {\n             let ptr = self.alloc_copy_inner(mem::size_of::<T>(),\n                                             mem::min_align_of::<T>());\n@@ -264,7 +264,7 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_noncopy<T>(&self, op: || -> T) -> &mut T {\n+    fn alloc_noncopy<T, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n         unsafe {\n             let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n@@ -288,7 +288,7 @@ impl Arena {\n     /// Allocates a new item in the arena, using `op` to initialize the value,\n     /// and returns a reference to it.\n     #[inline]\n-    pub fn alloc<T>(&self, op: || -> T) -> &mut T {\n+    pub fn alloc<T, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n         unsafe {\n             if intrinsics::needs_drop::<T>() {\n                 self.alloc_noncopy(op)\n@@ -340,7 +340,7 @@ fn test_arena_destructors_fail() {\n         arena.alloc(|| { [0u8, 1u8, 2u8] });\n     }\n     // Now, panic while allocating\n-    arena.alloc::<Rc<int>>(|| {\n+    arena.alloc::<Rc<int>, _>(|| {\n         panic!();\n     });\n }\n@@ -467,7 +467,7 @@ impl<T> TypedArena<T> {\n         }\n \n         let ptr: &mut T = unsafe {\n-            let ptr: &mut T = mem::transmute(self.ptr);\n+            let ptr: &mut T = mem::transmute(self.ptr.clone());\n             ptr::write(ptr, object);\n             self.ptr.set(self.ptr.get().offset(1));\n             ptr"}, {"sha": "fbaebd0125d0d3e9e1def4d2573c33ab0958a486", "filename": "src/libcollections/bench.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbench.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -8,14 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::prelude::*;\n+use prelude::*;\n use std::rand;\n use std::rand::Rng;\n use test::Bencher;\n \n-pub fn insert_rand_n<M>(n: uint, map: &mut M, b: &mut Bencher,\n-                        insert: |&mut M, uint|,\n-                        remove: |&mut M, uint|) {\n+pub fn insert_rand_n<M, I, R>(n: uint,\n+                              map: &mut M,\n+                              b: &mut Bencher,\n+                              mut insert: I,\n+                              mut remove: R) where\n+    I: FnMut(&mut M, uint),\n+    R: FnMut(&mut M, uint),\n+{\n     // setup\n     let mut rng = rand::weak_rng();\n \n@@ -31,9 +36,14 @@ pub fn insert_rand_n<M>(n: uint, map: &mut M, b: &mut Bencher,\n     })\n }\n \n-pub fn insert_seq_n<M>(n: uint, map: &mut M, b: &mut Bencher,\n-                       insert: |&mut M, uint|,\n-                       remove: |&mut M, uint|) {\n+pub fn insert_seq_n<M, I, R>(n: uint,\n+                             map: &mut M,\n+                             b: &mut Bencher,\n+                             mut insert: I,\n+                             mut remove: R) where\n+    I: FnMut(&mut M, uint),\n+    R: FnMut(&mut M, uint),\n+{\n     // setup\n     for i in range(0u, n) {\n         insert(map, i * 2);\n@@ -48,9 +58,14 @@ pub fn insert_seq_n<M>(n: uint, map: &mut M, b: &mut Bencher,\n     })\n }\n \n-pub fn find_rand_n<M, T>(n: uint, map: &mut M, b: &mut Bencher,\n-                         insert: |&mut M, uint|,\n-                         find: |&M, uint| -> T) {\n+pub fn find_rand_n<M, T, I, F>(n: uint,\n+                               map: &mut M,\n+                               b: &mut Bencher,\n+                               mut insert: I,\n+                               mut find: F) where\n+    I: FnMut(&mut M, uint),\n+    F: FnMut(&M, uint) -> T,\n+{\n     // setup\n     let mut rng = rand::weak_rng();\n     let mut keys = Vec::from_fn(n, |_| rng.gen::<uint>() % n);\n@@ -70,9 +85,14 @@ pub fn find_rand_n<M, T>(n: uint, map: &mut M, b: &mut Bencher,\n     })\n }\n \n-pub fn find_seq_n<M, T>(n: uint, map: &mut M, b: &mut Bencher,\n-                        insert: |&mut M, uint|,\n-                        find: |&M, uint| -> T) {\n+pub fn find_seq_n<M, T, I, F>(n: uint,\n+                              map: &mut M,\n+                              b: &mut Bencher,\n+                              mut insert: I,\n+                              mut find: F) where\n+    I: FnMut(&mut M, uint),\n+    F: FnMut(&M, uint) -> T,\n+{\n     // setup\n     for i in range(0u, n) {\n         insert(map, i);"}, {"sha": "589e580cc912129fa5257763c567c7a0210be787", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 260, "deletions": 122, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -10,12 +10,12 @@\n \n //! A priority queue implemented with a binary heap.\n //!\n-//! Insertions have `O(log n)` time complexity and checking or popping the largest element is\n-//! `O(1)`. Converting a vector to a priority queue can be done in-place, and has `O(n)`\n+//! Insertion and popping the largest element have `O(log n)` time complexity. Checking the largest\n+//! element is `O(1)`. Converting a vector to a priority queue can be done in-place, and has `O(n)`\n //! complexity. A priority queue can also be converted to a sorted vector in-place, allowing it to\n //! be used for an `O(n log n)` in-place heapsort.\n //!\n-//! # Example\n+//! # Examples\n //!\n //! This is a larger example which implements [Dijkstra's algorithm][dijkstra]\n //! to solve the [shortest path problem][sssp] on a [directed graph][dir_graph].\n@@ -29,7 +29,7 @@\n //! use std::collections::BinaryHeap;\n //! use std::uint;\n //!\n-//! #[deriving(Eq, PartialEq)]\n+//! #[deriving(Copy, Eq, PartialEq)]\n //! struct State {\n //!     cost: uint,\n //!     position: uint\n@@ -68,15 +68,15 @@\n //!     // dist[node] = current shortest distance from `start` to `node`\n //!     let mut dist = Vec::from_elem(adj_list.len(), uint::MAX);\n //!\n-//!     let mut pq = BinaryHeap::new();\n+//!     let mut heap = BinaryHeap::new();\n //!\n //!     // We're at `start`, with a zero cost\n //!     dist[start] = 0u;\n-//!     pq.push(State { cost: 0u, position: start });\n+//!     heap.push(State { cost: 0u, position: start });\n //!\n //!     // Examine the frontier with lower cost nodes first (min-heap)\n //!     loop {\n-//!         let State { cost, position } = match pq.pop() {\n+//!         let State { cost, position } = match heap.pop() {\n //!             None => break, // empty\n //!             Some(s) => s\n //!         };\n@@ -94,7 +94,7 @@\n //!\n //!             // If so, add it to the frontier and continue\n //!             if next.cost < dist[next.position] {\n-//!                 pq.push(next);\n+//!                 heap.push(next);\n //!                 // Relaxation, we have now found a better way\n //!                 dist[next.position] = next.cost;\n //!             }\n@@ -160,9 +160,7 @@ use core::mem::{zeroed, replace, swap};\n use core::ptr;\n \n use slice;\n-use vec::Vec;\n-\n-// FIXME(conventions): implement into_iter\n+use vec::{mod, Vec};\n \n /// A priority queue implemented with a binary heap.\n ///\n@@ -172,19 +170,21 @@ pub struct BinaryHeap<T> {\n     data: Vec<T>,\n }\n \n+#[stable]\n impl<T: Ord> Default for BinaryHeap<T> {\n     #[inline]\n+    #[stable]\n     fn default() -> BinaryHeap<T> { BinaryHeap::new() }\n }\n \n impl<T: Ord> BinaryHeap<T> {\n     /// Creates an empty `BinaryHeap` as a max-heap.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq: BinaryHeap<uint> = BinaryHeap::new();\n+    /// let heap: BinaryHeap<uint> = BinaryHeap::new();\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> BinaryHeap<T> { BinaryHeap{data: vec!(),} }\n@@ -194,11 +194,11 @@ impl<T: Ord> BinaryHeap<T> {\n     /// so that the `BinaryHeap` does not have to be reallocated\n     /// until it contains at least that many values.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(10u);\n+    /// let heap: BinaryHeap<uint> = BinaryHeap::with_capacity(10u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n@@ -208,11 +208,11 @@ impl<T: Ord> BinaryHeap<T> {\n     /// Creates a `BinaryHeap` from a vector. This is sometimes called\n     /// `heapifying` the vector.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq = BinaryHeap::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n+    /// let heap = BinaryHeap::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n     /// ```\n     pub fn from_vec(xs: Vec<T>) -> BinaryHeap<T> {\n         let mut q = BinaryHeap{data: xs,};\n@@ -227,51 +227,73 @@ impl<T: Ord> BinaryHeap<T> {\n     /// An iterator visiting all values in underlying vector, in\n     /// arbitrary order.\n     ///\n-    /// # Example\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n+    ///\n+    /// // Print 1, 2, 3, 4 in arbitrary order\n+    /// for x in heap.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter { iter: self.data.iter() }\n+    }\n+\n+    /// Creates a consuming iterator, that is, one that moves each value out of\n+    /// the binary heap in arbitrary order.  The binary heap cannot be used\n+    /// after calling this.\n+    ///\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let pq = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order\n-    /// for x in pq.iter() {\n+    /// for x in pq.into_iter() {\n+    ///     // x has type int, not &int\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n-        Items { iter: self.data.iter() }\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        IntoIter { iter: self.data.into_iter() }\n     }\n \n     /// Returns the greatest item in a queue, or `None` if it is empty.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n-    /// assert_eq!(pq.top(), None);\n+    /// let mut heap = BinaryHeap::new();\n+    /// assert_eq!(heap.peek(), None);\n     ///\n-    /// pq.push(1i);\n-    /// pq.push(5i);\n-    /// pq.push(2i);\n-    /// assert_eq!(pq.top(), Some(&5i));\n+    /// heap.push(1i);\n+    /// heap.push(5i);\n+    /// heap.push(2i);\n+    /// assert_eq!(heap.peek(), Some(&5i));\n     ///\n     /// ```\n-    pub fn top<'a>(&'a self) -> Option<&'a T> {\n-        if self.is_empty() { None } else { Some(&self.data[0]) }\n+    #[stable]\n+    pub fn peek(&self) -> Option<&T> {\n+        self.data.get(0)\n     }\n \n     /// Returns the number of elements the queue can hold without reallocating.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(100u);\n-    /// assert!(pq.capacity() >= 100u);\n+    /// let heap: BinaryHeap<uint> = BinaryHeap::with_capacity(100u);\n+    /// assert!(heap.capacity() >= 100u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n@@ -287,14 +309,14 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// Panics if the new capacity overflows `uint`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq: BinaryHeap<uint> = BinaryHeap::new();\n-    /// pq.reserve_exact(100u);\n-    /// assert!(pq.capacity() >= 100u);\n+    /// let mut heap: BinaryHeap<uint> = BinaryHeap::new();\n+    /// heap.reserve_exact(100u);\n+    /// assert!(heap.capacity() >= 100u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve_exact(&mut self, additional: uint) { self.data.reserve_exact(additional) }\n@@ -306,14 +328,14 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// Panics if the new capacity overflows `uint`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq: BinaryHeap<uint> = BinaryHeap::new();\n-    /// pq.reserve(100u);\n-    /// assert!(pq.capacity() >= 100u);\n+    /// let mut heap: BinaryHeap<uint> = BinaryHeap::new();\n+    /// heap.reserve(100u);\n+    /// assert!(heap.capacity() >= 100u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve(&mut self, additional: uint) {\n@@ -329,16 +351,16 @@ impl<T: Ord> BinaryHeap<T> {\n     /// Removes the greatest item from a queue and returns it, or `None` if it\n     /// is empty.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::from_vec(vec![1i, 3]);\n+    /// let mut heap = BinaryHeap::from_vec(vec![1i, 3]);\n     ///\n-    /// assert_eq!(pq.pop(), Some(3i));\n-    /// assert_eq!(pq.pop(), Some(1i));\n-    /// assert_eq!(pq.pop(), None);\n+    /// assert_eq!(heap.pop(), Some(3i));\n+    /// assert_eq!(heap.pop(), Some(1i));\n+    /// assert_eq!(heap.pop(), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn pop(&mut self) -> Option<T> {\n@@ -356,66 +378,72 @@ impl<T: Ord> BinaryHeap<T> {\n \n     /// Pushes an item onto the queue.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n-    /// pq.push(3i);\n-    /// pq.push(5i);\n-    /// pq.push(1i);\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.push(3i);\n+    /// heap.push(5i);\n+    /// heap.push(1i);\n     ///\n-    /// assert_eq!(pq.len(), 3);\n-    /// assert_eq!(pq.top(), Some(&5i));\n+    /// assert_eq!(heap.len(), 3);\n+    /// assert_eq!(heap.peek(), Some(&5i));\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push(&mut self, item: T) {\n+        let old_len = self.len();\n         self.data.push(item);\n-        let new_len = self.len() - 1;\n-        self.siftup(0, new_len);\n+        self.siftup(0, old_len);\n     }\n \n     /// Pushes an item onto a queue then pops the greatest item off the queue in\n     /// an optimized fashion.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n-    /// pq.push(1i);\n-    /// pq.push(5i);\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.push(1i);\n+    /// heap.push(5i);\n     ///\n-    /// assert_eq!(pq.push_pop(3i), 5);\n-    /// assert_eq!(pq.push_pop(9i), 9);\n-    /// assert_eq!(pq.len(), 2);\n-    /// assert_eq!(pq.top(), Some(&3i));\n+    /// assert_eq!(heap.push_pop(3i), 5);\n+    /// assert_eq!(heap.push_pop(9i), 9);\n+    /// assert_eq!(heap.len(), 2);\n+    /// assert_eq!(heap.peek(), Some(&3i));\n     /// ```\n     pub fn push_pop(&mut self, mut item: T) -> T {\n-        if !self.is_empty() && *self.top().unwrap() > item {\n-            swap(&mut item, &mut self.data[0]);\n-            self.siftdown(0);\n+        match self.data.get_mut(0) {\n+            None => return item,\n+            Some(top) => if *top > item {\n+                swap(&mut item, top);\n+            } else {\n+                return item;\n+            },\n         }\n+\n+        self.siftdown(0);\n         item\n     }\n \n     /// Pops the greatest item off a queue then pushes an item onto the queue in\n     /// an optimized fashion. The push is done regardless of whether the queue\n     /// was empty.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n+    /// let mut heap = BinaryHeap::new();\n     ///\n-    /// assert_eq!(pq.replace(1i), None);\n-    /// assert_eq!(pq.replace(3i), Some(1i));\n-    /// assert_eq!(pq.len(), 1);\n-    /// assert_eq!(pq.top(), Some(&3i));\n+    /// assert_eq!(heap.replace(1i), None);\n+    /// assert_eq!(heap.replace(3i), Some(1i));\n+    /// assert_eq!(heap.len(), 1);\n+    /// assert_eq!(heap.peek(), Some(&3i));\n     /// ```\n     pub fn replace(&mut self, mut item: T) -> Option<T> {\n         if !self.is_empty() {\n@@ -431,45 +459,44 @@ impl<T: Ord> BinaryHeap<T> {\n     /// Consumes the `BinaryHeap` and returns the underlying vector\n     /// in arbitrary order.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let pq = BinaryHeap::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n-    /// let vec = pq.into_vec();\n+    /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n+    /// let vec = heap.into_vec();\n     ///\n     /// // Will print in some order\n     /// for x in vec.iter() {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    pub fn into_vec(self) -> Vec<T> { let BinaryHeap{data: v} = self; v }\n+    pub fn into_vec(self) -> Vec<T> { self.data }\n \n     /// Consumes the `BinaryHeap` and returns a vector in sorted\n     /// (ascending) order.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::from_vec(vec![1i, 2, 4, 5, 7]);\n-    /// pq.push(6);\n-    /// pq.push(3);\n+    /// let mut heap = BinaryHeap::from_vec(vec![1i, 2, 4, 5, 7]);\n+    /// heap.push(6);\n+    /// heap.push(3);\n     ///\n-    /// let vec = pq.into_sorted_vec();\n+    /// let vec = heap.into_sorted_vec();\n     /// assert_eq!(vec, vec![1i, 2, 3, 4, 5, 6, 7]);\n     /// ```\n-    pub fn into_sorted_vec(self) -> Vec<T> {\n-        let mut q = self;\n-        let mut end = q.len();\n+    pub fn into_sorted_vec(mut self) -> Vec<T> {\n+        let mut end = self.len();\n         while end > 1 {\n             end -= 1;\n-            q.data.as_mut_slice().swap(0, end);\n-            q.siftdown_range(0, end)\n+            self.data.swap(0, end);\n+            self.siftdown_range(0, end)\n         }\n-        q.into_vec()\n+        self.into_vec()\n     }\n \n     // The implementations of siftup and siftdown use unsafe blocks in\n@@ -530,28 +557,83 @@ impl<T: Ord> BinaryHeap<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n+    /// Clears the queue, returning an iterator over the removed elements.\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n+        Drain {\n+            iter: self.data.drain(),\n+        }\n+    }\n+\n     /// Drops all items from the queue.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn clear(&mut self) { self.data.truncate(0) }\n+    pub fn clear(&mut self) { self.drain(); }\n }\n \n /// `BinaryHeap` iterator.\n-pub struct Items <'a, T:'a> {\n-    iter: slice::Items<'a, T>,\n+pub struct Iter <'a, T: 'a> {\n+    iter: slice::Iter<'a, T>,\n }\n \n-impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n+impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<(&'a T)> { self.iter.next() }\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n+impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n+}\n+\n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n+\n+/// An iterator that moves out of a `BinaryHeap`.\n+pub struct IntoIter<T> {\n+    iter: vec::IntoIter<T>,\n+}\n+\n+impl<T> Iterator<T> for IntoIter<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<T> { self.iter.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+}\n+\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n+\n+/// An iterator that drains a `BinaryHeap`.\n+pub struct Drain<'a, T: 'a> {\n+    iter: vec::Drain<'a, T>,\n+}\n+\n+impl<'a, T: 'a> Iterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<T> { self.iter.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<'a, T: 'a> DoubleEndedIterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+}\n+\n+impl<'a, T: 'a> ExactSizeIterator<T> for Drain<'a, T> {}\n+\n impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n-    fn from_iter<Iter: Iterator<T>>(mut iter: Iter) -> BinaryHeap<T> {\n-        let vec: Vec<T> = iter.collect();\n-        BinaryHeap::from_vec(vec)\n+    fn from_iter<Iter: Iterator<T>>(iter: Iter) -> BinaryHeap<T> {\n+        BinaryHeap::from_vec(iter.collect())\n     }\n }\n \n@@ -569,31 +651,77 @@ impl<T: Ord> Extend<T> for BinaryHeap<T> {\n \n #[cfg(test)]\n mod tests {\n-    use std::prelude::*;\n+    use prelude::*;\n \n     use super::BinaryHeap;\n-    use vec::Vec;\n \n     #[test]\n     fn test_iterator() {\n         let data = vec!(5i, 9, 3);\n         let iterout = [9i, 5, 3];\n-        let pq = BinaryHeap::from_vec(data);\n+        let heap = BinaryHeap::from_vec(data);\n         let mut i = 0;\n-        for el in pq.iter() {\n+        for el in heap.iter() {\n             assert_eq!(*el, iterout[i]);\n             i += 1;\n         }\n     }\n \n     #[test]\n-    fn test_top_and_pop() {\n+    fn test_iterator_reverse() {\n+        let data = vec!(5i, 9, 3);\n+        let iterout = vec!(3i, 5, 9);\n+        let pq = BinaryHeap::from_vec(data);\n+\n+        let v: Vec<int> = pq.iter().rev().map(|&x| x).collect();\n+        assert_eq!(v, iterout);\n+    }\n+\n+    #[test]\n+    fn test_move_iter() {\n+        let data = vec!(5i, 9, 3);\n+        let iterout = vec!(9i, 5, 3);\n+        let pq = BinaryHeap::from_vec(data);\n+\n+        let v: Vec<int> = pq.into_iter().collect();\n+        assert_eq!(v, iterout);\n+    }\n+\n+    #[test]\n+    fn test_move_iter_size_hint() {\n+        let data = vec!(5i, 9);\n+        let pq = BinaryHeap::from_vec(data);\n+\n+        let mut it = pq.into_iter();\n+\n+        assert_eq!(it.size_hint(), (2, Some(2)));\n+        assert_eq!(it.next(), Some(9i));\n+\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(it.next(), Some(5i));\n+\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert_eq!(it.next(), None);\n+    }\n+\n+    #[test]\n+    fn test_move_iter_reverse() {\n+        let data = vec!(5i, 9, 3);\n+        let iterout = vec!(3i, 5, 9);\n+        let pq = BinaryHeap::from_vec(data);\n+\n+        let v: Vec<int> = pq.into_iter().rev().collect();\n+        assert_eq!(v, iterout);\n+    }\n+\n+    #[test]\n+    fn test_peek_and_pop() {\n         let data = vec!(2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1);\n         let mut sorted = data.clone();\n         sorted.sort();\n         let mut heap = BinaryHeap::from_vec(data);\n         while !heap.is_empty() {\n-            assert_eq!(heap.top().unwrap(), sorted.last().unwrap());\n+            assert_eq!(heap.peek().unwrap(), sorted.last().unwrap());\n             assert_eq!(heap.pop().unwrap(), sorted.pop().unwrap());\n         }\n     }\n@@ -602,44 +730,44 @@ mod tests {\n     fn test_push() {\n         let mut heap = BinaryHeap::from_vec(vec!(2i, 4, 9));\n         assert_eq!(heap.len(), 3);\n-        assert!(*heap.top().unwrap() == 9);\n+        assert!(*heap.peek().unwrap() == 9);\n         heap.push(11);\n         assert_eq!(heap.len(), 4);\n-        assert!(*heap.top().unwrap() == 11);\n+        assert!(*heap.peek().unwrap() == 11);\n         heap.push(5);\n         assert_eq!(heap.len(), 5);\n-        assert!(*heap.top().unwrap() == 11);\n+        assert!(*heap.peek().unwrap() == 11);\n         heap.push(27);\n         assert_eq!(heap.len(), 6);\n-        assert!(*heap.top().unwrap() == 27);\n+        assert!(*heap.peek().unwrap() == 27);\n         heap.push(3);\n         assert_eq!(heap.len(), 7);\n-        assert!(*heap.top().unwrap() == 27);\n+        assert!(*heap.peek().unwrap() == 27);\n         heap.push(103);\n         assert_eq!(heap.len(), 8);\n-        assert!(*heap.top().unwrap() == 103);\n+        assert!(*heap.peek().unwrap() == 103);\n     }\n \n     #[test]\n     fn test_push_unique() {\n         let mut heap = BinaryHeap::from_vec(vec!(box 2i, box 4, box 9));\n         assert_eq!(heap.len(), 3);\n-        assert!(*heap.top().unwrap() == box 9);\n+        assert!(*heap.peek().unwrap() == box 9);\n         heap.push(box 11);\n         assert_eq!(heap.len(), 4);\n-        assert!(*heap.top().unwrap() == box 11);\n+        assert!(*heap.peek().unwrap() == box 11);\n         heap.push(box 5);\n         assert_eq!(heap.len(), 5);\n-        assert!(*heap.top().unwrap() == box 11);\n+        assert!(*heap.peek().unwrap() == box 11);\n         heap.push(box 27);\n         assert_eq!(heap.len(), 6);\n-        assert!(*heap.top().unwrap() == box 27);\n+        assert!(*heap.peek().unwrap() == box 27);\n         heap.push(box 3);\n         assert_eq!(heap.len(), 7);\n-        assert!(*heap.top().unwrap() == box 27);\n+        assert!(*heap.peek().unwrap() == box 27);\n         heap.push(box 103);\n         assert_eq!(heap.len(), 8);\n-        assert!(*heap.top().unwrap() == box 103);\n+        assert!(*heap.peek().unwrap() == box 103);\n     }\n \n     #[test]\n@@ -676,8 +804,8 @@ mod tests {\n         v.sort();\n         data.sort();\n \n-        assert_eq!(v.as_slice(), data.as_slice());\n-        assert_eq!(heap.into_sorted_vec().as_slice(), data.as_slice());\n+        assert_eq!(v, data);\n+        assert_eq!(heap.into_sorted_vec(), data);\n     }\n \n     #[test]\n@@ -699,30 +827,40 @@ mod tests {\n \n     #[test]\n     fn test_empty_pop() {\n-        let mut heap: BinaryHeap<int> = BinaryHeap::new();\n+        let mut heap = BinaryHeap::<int>::new();\n         assert!(heap.pop().is_none());\n     }\n \n     #[test]\n-    fn test_empty_top() {\n-        let empty: BinaryHeap<int> = BinaryHeap::new();\n-        assert!(empty.top().is_none());\n+    fn test_empty_peek() {\n+        let empty = BinaryHeap::<int>::new();\n+        assert!(empty.peek().is_none());\n     }\n \n     #[test]\n     fn test_empty_replace() {\n-        let mut heap: BinaryHeap<int> = BinaryHeap::new();\n-        heap.replace(5).is_none();\n+        let mut heap = BinaryHeap::<int>::new();\n+        assert!(heap.replace(5).is_none());\n     }\n \n     #[test]\n     fn test_from_iter() {\n         let xs = vec!(9u, 8, 7, 6, 5, 4, 3, 2, 1);\n \n-        let mut q: BinaryHeap<uint> = xs.as_slice().iter().rev().map(|&x| x).collect();\n+        let mut q: BinaryHeap<uint> = xs.iter().rev().map(|&x| x).collect();\n \n         for &x in xs.iter() {\n             assert_eq!(q.pop().unwrap(), x);\n         }\n     }\n+\n+    #[test]\n+    fn test_drain() {\n+        let mut q: BinaryHeap<_> =\n+            [9u, 8, 7, 6, 5, 4, 3, 2, 1].iter().cloned().collect();\n+\n+        assert_eq!(q.drain().take(5).count(), 5);\n+\n+        assert!(q.is_empty());\n+    }\n }"}, {"sha": "430d7210bf69b105be1a6ef4032974562548213b", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 1045, "deletions": 837, "changes": 1882, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "65c644da3d8926dee83b3556c87237424f45ecce", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 485, "deletions": 273, "changes": 758, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -20,15 +20,21 @@ pub use self::Entry::*;\n use core::prelude::*;\n \n use self::StackOp::*;\n-use super::node::*;\n+use super::node::{mod, Node, Found, GoDown};\n+use super::node::{Traversal, MutTraversal, MoveTraversal};\n+use super::node::TraversalItem::{mod, Elem, Edge};\n+use super::node::ForceResult::{Leaf, Internal};\n use core::borrow::BorrowFrom;\n use std::hash::{Writer, Hash};\n use core::default::Default;\n use core::{iter, fmt, mem};\n use core::fmt::Show;\n+use core::iter::Map;\n \n use ring_buf::RingBuf;\n \n+use self::Continuation::{Continue, Finished};\n+\n // FIXME(conventions): implement bounded iterators\n \n /// A map based on a B-Tree.\n@@ -82,33 +88,37 @@ pub struct BTreeMap<K, V> {\n }\n \n /// An abstract base over-which all other BTree iterators are built.\n-struct AbsEntries<T> {\n+struct AbsIter<T> {\n     lca: T,\n     left: RingBuf<T>,\n     right: RingBuf<T>,\n     size: uint,\n }\n \n /// An iterator over a BTreeMap's entries.\n-pub struct Entries<'a, K: 'a, V: 'a> {\n-    inner: AbsEntries<Traversal<'a, K, V>>\n+pub struct Iter<'a, K: 'a, V: 'a> {\n+    inner: AbsIter<Traversal<'a, K, V>>\n }\n \n /// A mutable iterator over a BTreeMap's entries.\n-pub struct MutEntries<'a, K: 'a, V: 'a> {\n-    inner: AbsEntries<MutTraversal<'a, K, V>>\n+pub struct IterMut<'a, K: 'a, V: 'a> {\n+    inner: AbsIter<MutTraversal<'a, K, V>>\n }\n \n /// An owning iterator over a BTreeMap's entries.\n-pub struct MoveEntries<K, V> {\n-    inner: AbsEntries<MoveTraversal<K, V>>\n+pub struct IntoIter<K, V> {\n+    inner: AbsIter<MoveTraversal<K, V>>\n }\n \n /// An iterator over a BTreeMap's keys.\n-pub type Keys<'a, K, V> = iter::Map<'static, (&'a K, &'a V), &'a K, Entries<'a, K, V>>;\n+pub struct Keys<'a, K: 'a, V: 'a> {\n+    inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+}\n \n /// An iterator over a BTreeMap's values.\n-pub type Values<'a, K, V> = iter::Map<'static, (&'a K, &'a V), &'a V, Entries<'a, K, V>>;\n+pub struct Values<'a, K: 'a, V: 'a> {\n+    inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+}\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n pub enum Entry<'a, K:'a, V:'a> {\n@@ -121,12 +131,12 @@ pub enum Entry<'a, K:'a, V:'a> {\n /// A vacant Entry.\n pub struct VacantEntry<'a, K:'a, V:'a> {\n     key: K,\n-    stack: stack::SearchStack<'a, K, V>,\n+    stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n \n /// An occupied Entry.\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n-    stack: stack::SearchStack<'a, K, V>,\n+    stack: stack::SearchStack<'a, K, V, node::handle::KV, node::handle::LeafOrInternal>,\n }\n \n impl<K: Ord, V> BTreeMap<K, V> {\n@@ -152,7 +162,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     /// Clears the map, removing all values.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeMap;\n@@ -188,7 +198,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// The key may be any borrowed form of the map's key type, but the ordering\n     /// on the borrowed form *must* match the ordering on the key type.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeMap;\n@@ -202,12 +212,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn get<Sized? Q>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n         let mut cur_node = &self.root;\n         loop {\n-            match cur_node.search(key) {\n-                Found(i) => return cur_node.val(i),\n-                GoDown(i) => match cur_node.edge(i) {\n-                    None => return None,\n-                    Some(next_node) => {\n-                        cur_node = next_node;\n+            match Node::search(cur_node, key) {\n+                Found(handle) => return Some(handle.into_kv().1),\n+                GoDown(handle) => match handle.force() {\n+                    Leaf(_) => return None,\n+                    Internal(internal_handle) => {\n+                        cur_node = internal_handle.into_edge();\n                         continue;\n                     }\n                 }\n@@ -220,7 +230,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// The key may be any borrowed form of the map's key type, but the ordering\n     /// on the borrowed form *must* match the ordering on the key type.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeMap;\n@@ -246,7 +256,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// The key may be any borrowed form of the map's key type, but the ordering\n     /// on the borrowed form *must* match the ordering on the key type.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeMap;\n@@ -266,12 +276,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let mut temp_node = &mut self.root;\n         loop {\n             let cur_node = temp_node;\n-            match cur_node.search(key) {\n-                Found(i) => return cur_node.val_mut(i),\n-                GoDown(i) => match cur_node.edge_mut(i) {\n-                    None => return None,\n-                    Some(next_node) => {\n-                        temp_node = next_node;\n+            match Node::search(cur_node, key) {\n+                Found(handle) => return Some(handle.into_kv_mut().1),\n+                GoDown(handle) => match handle.force() {\n+                    Leaf(_) => return None,\n+                    Internal(internal_handle) => {\n+                        temp_node = internal_handle.into_edge_mut();\n                         continue;\n                     }\n                 }\n@@ -314,7 +324,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// Inserts a key-value pair from the map. If the key already had a value\n     /// present in the map, that value is returned. Otherwise, `None` is returned.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeMap;\n@@ -328,7 +338,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn insert(&mut self, key: K, mut value: V) -> Option<V> {\n+    pub fn insert(&mut self, mut key: K, mut value: V) -> Option<V> {\n         // This is a stack of rawptrs to nodes paired with indices, respectively\n         // representing the nodes and edges of our search path. We have to store rawptrs\n         // because as far as Rust is concerned, we can mutate aliased data with such a\n@@ -347,30 +357,39 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let mut stack = stack::PartialSearchStack::new(self);\n \n         loop {\n-            // Same basic logic as found in `find`, but with PartialSearchStack mediating the\n-            // actual nodes for us\n-            match stack.next().search(&key) {\n-                Found(i) => unsafe {\n-                    // Perfect match, swap the values and return the old one\n-                    let next = stack.into_next();\n-                    mem::swap(next.unsafe_val_mut(i), &mut value);\n-                    return Some(value);\n-                },\n-                GoDown(i) => {\n-                    // We need to keep searching, try to get the search stack\n-                    // to go down further\n-                    stack = match stack.push(i) {\n-                        stack::Done(new_stack) => {\n-                            // We've reached a leaf, perform the insertion here\n-                            new_stack.insert(key, value);\n-                            return None;\n-                        }\n-                        stack::Grew(new_stack) => {\n-                            // We've found the subtree to insert this key/value pair in,\n-                            // keep searching\n-                            new_stack\n+            let result = stack.with(move |pusher, node| {\n+                // Same basic logic as found in `find`, but with PartialSearchStack mediating the\n+                // actual nodes for us\n+                return match Node::search(node, &key) {\n+                    Found(mut handle) => {\n+                        // Perfect match, swap the values and return the old one\n+                        mem::swap(handle.val_mut(), &mut value);\n+                        Finished(Some(value))\n+                    },\n+                    GoDown(handle) => {\n+                        // We need to keep searching, try to get the search stack\n+                        // to go down further\n+                        match handle.force() {\n+                            Leaf(leaf_handle) => {\n+                                // We've reached a leaf, perform the insertion here\n+                                pusher.seal(leaf_handle).insert(key, value);\n+                                Finished(None)\n+                            }\n+                            Internal(internal_handle) => {\n+                                // We've found the subtree to insert this key/value pair in,\n+                                // keep searching\n+                                Continue((pusher.push(internal_handle), key, value))\n+                            }\n                         }\n-                    };\n+                    }\n+                }\n+            });\n+            match result {\n+                Finished(ret) => { return ret; },\n+                Continue((new_stack, renewed_key, renewed_val)) => {\n+                    stack = new_stack;\n+                    key = renewed_key;\n+                    value = renewed_val;\n                 }\n             }\n         }\n@@ -423,7 +442,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// The key may be any borrowed form of the map's key type, but the ordering\n     /// on the borrowed form *must* match the ordering on the key type.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeMap;\n@@ -438,65 +457,102 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n-            match stack.next().search(key) {\n-                Found(i) => {\n-                    // Perfect match. Terminate the stack here, and remove the entry\n-                    return Some(stack.seal(i).remove());\n-                },\n-                GoDown(i) => {\n-                    // We need to keep searching, try to go down the next edge\n-                    stack = match stack.push(i) {\n-                        stack::Done(_) => return None, // We're at a leaf; the key isn't in here\n-                        stack::Grew(new_stack) => {\n-                            new_stack\n+            let result = stack.with(move |pusher, node| {\n+                return match Node::search(node, key) {\n+                    Found(handle) => {\n+                        // Perfect match. Terminate the stack here, and remove the entry\n+                        Finished(Some(pusher.seal(handle).remove()))\n+                    },\n+                    GoDown(handle) => {\n+                        // We need to keep searching, try to go down the next edge\n+                        match handle.force() {\n+                            // We're at a leaf; the key isn't in here\n+                            Leaf(_) => Finished(None),\n+                            Internal(internal_handle) => Continue(pusher.push(internal_handle))\n                         }\n-                    };\n+                    }\n                 }\n+            });\n+            match result {\n+                Finished(ret) => return ret,\n+                Continue(new_stack) => stack = new_stack\n             }\n         }\n     }\n }\n \n+/// A helper enum useful for deciding whether to continue a loop since we can't\n+/// return from a closure\n+enum Continuation<A, B> {\n+    Continue(A),\n+    Finished(B)\n+}\n+\n /// The stack module provides a safe interface for constructing and manipulating a stack of ptrs\n /// to nodes. By using this module much better safety guarantees can be made, and more search\n /// boilerplate gets cut out.\n mod stack {\n-    pub use self::PushResult::*;\n     use core::prelude::*;\n+    use core::kinds::marker;\n+    use core::mem;\n     use super::BTreeMap;\n-    use super::super::node::*;\n+    use super::super::node::{mod, Node, Fit, Split, Internal, Leaf};\n+    use super::super::node::handle;\n     use vec::Vec;\n \n-    type StackItem<K, V> = (*mut Node<K, V>, uint);\n+    /// A generic mutable reference, identical to `&mut` except for the fact that its lifetime\n+    /// parameter is invariant. This means that wherever an `IdRef` is expected, only an `IdRef`\n+    /// with the exact requested lifetime can be used. This is in contrast to normal references,\n+    /// where `&'static` can be used in any function expecting any lifetime reference.\n+    pub struct IdRef<'id, T: 'id> {\n+        inner: &'id mut T,\n+        marker: marker::InvariantLifetime<'id>\n+    }\n+\n+    impl<'id, T> Deref<T> for IdRef<'id, T> {\n+        fn deref(&self) -> &T {\n+            &*self.inner\n+        }\n+    }\n+\n+    impl<'id, T> DerefMut<T> for IdRef<'id, T> {\n+        fn deref_mut(&mut self) -> &mut T {\n+            &mut *self.inner\n+        }\n+    }\n+\n+    type StackItem<K, V> = node::Handle<*mut Node<K, V>, handle::Edge, handle::Internal>;\n     type Stack<K, V> = Vec<StackItem<K, V>>;\n \n-    /// A PartialSearchStack handles the construction of a search stack.\n+    /// A `PartialSearchStack` handles the construction of a search stack.\n     pub struct PartialSearchStack<'a, K:'a, V:'a> {\n         map: &'a mut BTreeMap<K, V>,\n         stack: Stack<K, V>,\n         next: *mut Node<K, V>,\n     }\n \n-    /// A SearchStack represents a full path to an element of interest. It provides methods\n-    /// for manipulating the element at the top of its stack.\n-    pub struct SearchStack<'a, K:'a, V:'a> {\n+    /// A `SearchStack` represents a full path to an element or an edge of interest. It provides\n+    /// methods depending on the type of what the path points to for removing an element, inserting\n+    /// a new element, and manipulating to element at the top of the stack.\n+    pub struct SearchStack<'a, K:'a, V:'a, Type, NodeType> {\n         map: &'a mut BTreeMap<K, V>,\n         stack: Stack<K, V>,\n-        top: StackItem<K, V>,\n+        top: node::Handle<*mut Node<K, V>, Type, NodeType>,\n     }\n \n-    /// The result of asking a PartialSearchStack to push another node onto itself. Either it\n-    /// Grew, in which case it's still Partial, or it found its last node was actually a leaf, in\n-    /// which case it seals itself and yields a complete SearchStack.\n-    pub enum PushResult<'a, K:'a, V:'a> {\n-        Grew(PartialSearchStack<'a, K, V>),\n-        Done(SearchStack<'a, K, V>),\n+    /// A `PartialSearchStack` that doesn't hold a a reference to the next node, and is just\n+    /// just waiting for a `Handle` to that next node to be pushed. See `PartialSearchStack::with`\n+    /// for more details.\n+    pub struct Pusher<'id, 'a, K:'a, V:'a> {\n+        map: &'a mut BTreeMap<K, V>,\n+        stack: Stack<K, V>,\n+        marker: marker::InvariantLifetime<'id>\n     }\n \n     impl<'a, K, V> PartialSearchStack<'a, K, V> {\n         /// Creates a new PartialSearchStack from a BTreeMap by initializing the stack with the\n         /// root of the tree.\n-        pub fn new<'a>(map: &'a mut BTreeMap<K, V>) -> PartialSearchStack<'a, K, V> {\n+        pub fn new(map: &'a mut BTreeMap<K, V>) -> PartialSearchStack<'a, K, V> {\n             let depth = map.depth;\n \n             PartialSearchStack {\n@@ -506,179 +562,122 @@ mod stack {\n             }\n         }\n \n-        /// Pushes the requested child of the stack's current top on top of the stack. If the child\n-        /// exists, then a new PartialSearchStack is yielded. Otherwise, a full SearchStack is\n-        /// yielded.\n-        pub fn push(self, edge: uint) -> PushResult<'a, K, V> {\n-            let map = self.map;\n-            let mut stack = self.stack;\n-            let next_ptr = self.next;\n-            let next_node = unsafe {\n-                &mut *next_ptr\n+        /// Breaks up the stack into a `Pusher` and the next `Node`, allowing the given closure\n+        /// to interact with, search, and finally push the `Node` onto the stack. The passed in\n+        /// closure must be polymorphic on the `'id` lifetime parameter, as this statically\n+        /// ensures that only `Handle`s from the correct `Node` can be pushed.\n+        ///\n+        /// The reason this works is that the `Pusher` has an `'id` parameter, and will only accept\n+        /// handles with the same `'id`. The closure could only get references with that lifetime\n+        /// through its arguments or through some other `IdRef` that it has lying around. However,\n+        /// no other `IdRef` could possibly work - because the `'id` is held in an invariant\n+        /// parameter, it would need to have precisely the correct lifetime, which would mean that\n+        /// at least one of the calls to `with` wouldn't be properly polymorphic, wanting a\n+        /// specific lifetime instead of the one that `with` chooses to give it.\n+        ///\n+        /// See also Haskell's `ST` monad, which uses a similar trick.\n+        pub fn with<T, F: for<'id> FnOnce(Pusher<'id, 'a, K, V>,\n+                                          IdRef<'id, Node<K, V>>) -> T>(self, closure: F) -> T {\n+            let pusher = Pusher {\n+                map: self.map,\n+                stack: self.stack,\n+                marker: marker::InvariantLifetime\n+            };\n+            let node = IdRef {\n+                inner: unsafe { &mut *self.next },\n+                marker: marker::InvariantLifetime\n             };\n-            let to_insert = (next_ptr, edge);\n-            match next_node.edge_mut(edge) {\n-                None => Done(SearchStack {\n-                    map: map,\n-                    stack: stack,\n-                    top: to_insert,\n-                }),\n-                Some(node) => {\n-                    stack.push(to_insert);\n-                    Grew(PartialSearchStack {\n-                        map: map,\n-                        stack: stack,\n-                        next: node as *mut _,\n-                    })\n-                },\n-            }\n-        }\n \n-        /// Converts the stack into a mutable reference to its top.\n-        pub fn into_next(self) -> &'a mut Node<K, V> {\n-            unsafe {\n-                &mut *self.next\n-            }\n+            closure(pusher, node)\n         }\n+    }\n \n-        /// Gets the top of the stack.\n-        pub fn next(&self) -> &Node<K, V> {\n-            unsafe {\n-                &*self.next\n+    impl<'id, 'a, K, V> Pusher<'id, 'a, K, V> {\n+        /// Pushes the requested child of the stack's current top on top of the stack. If the child\n+        /// exists, then a new PartialSearchStack is yielded. Otherwise, a VacantSearchStack is\n+        /// yielded.\n+        pub fn push(mut self, mut edge: node::Handle<IdRef<'id, Node<K, V>>,\n+                                                     handle::Edge,\n+                                                     handle::Internal>)\n+                    -> PartialSearchStack<'a, K, V> {\n+            self.stack.push(edge.as_raw());\n+            PartialSearchStack {\n+                map: self.map,\n+                stack: self.stack,\n+                next: edge.edge_mut() as *mut _,\n             }\n         }\n \n         /// Converts the PartialSearchStack into a SearchStack.\n-        pub fn seal(self, index: uint) -> SearchStack<'a, K, V> {\n+        pub fn seal<Type, NodeType>\n+                   (self, mut handle: node::Handle<IdRef<'id, Node<K, V>>, Type, NodeType>)\n+                    -> SearchStack<'a, K, V, Type, NodeType> {\n             SearchStack {\n                 map: self.map,\n                 stack: self.stack,\n-                top: (self.next as *mut _, index),\n+                top: handle.as_raw(),\n             }\n         }\n     }\n \n-    impl<'a, K, V> SearchStack<'a, K, V> {\n+    impl<'a, K, V, NodeType> SearchStack<'a, K, V, handle::KV, NodeType> {\n         /// Gets a reference to the value the stack points to.\n         pub fn peek(&self) -> &V {\n-            let (node_ptr, index) = self.top;\n-            unsafe {\n-                (*node_ptr).val(index).unwrap()\n-            }\n+            unsafe { self.top.from_raw().into_kv().1 }\n         }\n \n         /// Gets a mutable reference to the value the stack points to.\n         pub fn peek_mut(&mut self) -> &mut V {\n-            let (node_ptr, index) = self.top;\n-            unsafe {\n-                (*node_ptr).val_mut(index).unwrap()\n-            }\n+            unsafe { self.top.from_raw_mut().into_kv_mut().1 }\n         }\n \n         /// Converts the stack into a mutable reference to the value it points to, with a lifetime\n         /// tied to the original tree.\n-        pub fn into_top(self) -> &'a mut V {\n-            let (node_ptr, index) = self.top;\n-            unsafe {\n-                (*node_ptr).val_mut(index).unwrap()\n-            }\n-        }\n-\n-        /// Inserts the key and value into the top element in the stack, and if that node has to\n-        /// split recursively inserts the split contents into the next element stack until\n-        /// splits stop.\n-        ///\n-        /// Assumes that the stack represents a search path from the root to a leaf.\n-        ///\n-        /// An &mut V is returned to the inserted value, for callers that want a reference to this.\n-        pub fn insert(self, key: K, val: V) -> &'a mut V {\n+        pub fn into_top(mut self) -> &'a mut V {\n             unsafe {\n-                let map = self.map;\n-                map.length += 1;\n-\n-                let mut stack = self.stack;\n-                // Insert the key and value into the leaf at the top of the stack\n-                let (node, index) = self.top;\n-                let (mut insertion, inserted_ptr) = {\n-                    (*node).insert_as_leaf(index, key, val)\n-                };\n-\n-                loop {\n-                    match insertion {\n-                        Fit => {\n-                            // The last insertion went off without a hitch, no splits! We can stop\n-                            // inserting now.\n-                            return &mut *inserted_ptr;\n-                        }\n-                        Split(key, val, right) => match stack.pop() {\n-                            // The last insertion triggered a split, so get the next element on the\n-                            // stack to recursively insert the split node into.\n-                            None => {\n-                                // The stack was empty; we've split the root, and need to make a\n-                                // a new one. This is done in-place because we can't move the\n-                                // root out of a reference to the tree.\n-                                Node::make_internal_root(&mut map.root, map.b, key, val, right);\n-\n-                                map.depth += 1;\n-                                return &mut *inserted_ptr;\n-                            }\n-                            Some((node, index)) => {\n-                                // The stack wasn't empty, do the insertion and recurse\n-                                insertion = (*node).insert_as_internal(index, key, val, right);\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                }\n+                mem::copy_mut_lifetime(\n+                    self.map,\n+                    self.top.from_raw_mut().val_mut()\n+                )\n             }\n         }\n+    }\n \n+    impl<'a, K, V> SearchStack<'a, K, V, handle::KV, handle::Leaf> {\n         /// Removes the key and value in the top element of the stack, then handles underflows as\n         /// described in BTree's pop function.\n-        pub fn remove(mut self) -> V {\n-            // Ensure that the search stack goes to a leaf. This is necessary to perform deletion\n-            // in a BTree. Note that this may put the tree in an inconsistent state (further\n-            // described in leafify's comments), but this is immediately fixed by the\n-            // removing the value we want to remove\n-            self.leafify();\n-\n-            let map = self.map;\n-            map.length -= 1;\n-\n-            let mut stack = self.stack;\n+        fn remove_leaf(mut self) -> V {\n+            self.map.length -= 1;\n \n             // Remove the key-value pair from the leaf that this search stack points to.\n             // Then, note if the leaf is underfull, and promptly forget the leaf and its ptr\n             // to avoid ownership issues.\n             let (value, mut underflow) = unsafe {\n-                let (leaf_ptr, index) = self.top;\n-                let leaf = &mut *leaf_ptr;\n-                let (_key, value) = leaf.remove_as_leaf(index);\n-                let underflow = leaf.is_underfull();\n+                let (_, value) = self.top.from_raw_mut().remove_as_leaf();\n+                let underflow = self.top.from_raw().node().is_underfull();\n                 (value, underflow)\n             };\n \n             loop {\n-                match stack.pop() {\n+                match self.stack.pop() {\n                     None => {\n                         // We've reached the root, so no matter what, we're done. We manually\n                         // access the root via the tree itself to avoid creating any dangling\n                         // pointers.\n-                        if map.root.len() == 0 && !map.root.is_leaf() {\n+                        if self.map.root.len() == 0 && !self.map.root.is_leaf() {\n                             // We've emptied out the root, so make its only child the new root.\n                             // If it's a leaf, we just let it become empty.\n-                            map.depth -= 1;\n-                            map.root = map.root.pop_edge().unwrap();\n+                            self.map.depth -= 1;\n+                            self.map.root.hoist_lone_child();\n                         }\n                         return value;\n                     }\n-                    Some((parent_ptr, index)) => {\n+                    Some(mut handle) => {\n                         if underflow {\n                             // Underflow! Handle it!\n                             unsafe {\n-                                let parent = &mut *parent_ptr;\n-                                parent.handle_underflow(index);\n-                                underflow = parent.is_underfull();\n+                                handle.from_raw_mut().handle_underflow();\n+                                underflow = handle.from_raw().node().is_underfull();\n                             }\n                         } else {\n                             // All done!\n@@ -688,45 +687,120 @@ mod stack {\n                 }\n             }\n         }\n+    }\n+\n+    impl<'a, K, V> SearchStack<'a, K, V, handle::KV, handle::LeafOrInternal> {\n+        /// Removes the key and value in the top element of the stack, then handles underflows as\n+        /// described in BTree's pop function.\n+        pub fn remove(self) -> V {\n+            // Ensure that the search stack goes to a leaf. This is necessary to perform deletion\n+            // in a BTree. Note that this may put the tree in an inconsistent state (further\n+            // described in into_leaf's comments), but this is immediately fixed by the\n+            // removing the value we want to remove\n+            self.into_leaf().remove_leaf()\n+        }\n \n         /// Subroutine for removal. Takes a search stack for a key that might terminate at an\n         /// internal node, and mutates the tree and search stack to *make* it a search stack\n         /// for that same key that *does* terminates at a leaf. If the mutation occurs, then this\n         /// leaves the tree in an inconsistent state that must be repaired by the caller by\n         /// removing the entry in question. Specifically the key-value pair and its successor will\n         /// become swapped.\n-        fn leafify(&mut self) {\n+        fn into_leaf(mut self) -> SearchStack<'a, K, V, handle::KV, handle::Leaf> {\n             unsafe {\n-                let (node_ptr, index) = self.top;\n-                // First, get ptrs to the found key-value pair\n-                let node = &mut *node_ptr;\n-                let (key_ptr, val_ptr) = {\n-                    (node.unsafe_key_mut(index) as *mut _,\n-                     node.unsafe_val_mut(index) as *mut _)\n-                };\n+                let mut top_raw = self.top;\n+                let mut top = top_raw.from_raw_mut();\n+\n+                let key_ptr = top.key_mut() as *mut _;\n+                let val_ptr = top.val_mut() as *mut _;\n \n                 // Try to go into the right subtree of the found key to find its successor\n-                match node.edge_mut(index + 1) {\n-                    None => {\n+                match top.force() {\n+                    Leaf(mut leaf_handle) => {\n                         // We're a proper leaf stack, nothing to do\n+                        return SearchStack {\n+                            map: self.map,\n+                            stack: self.stack,\n+                            top: leaf_handle.as_raw()\n+                        }\n                     }\n-                    Some(mut temp_node) => {\n+                    Internal(mut internal_handle) => {\n+                        let mut right_handle = internal_handle.right_edge();\n+\n                         //We're not a proper leaf stack, let's get to work.\n-                        self.stack.push((node_ptr, index + 1));\n+                        self.stack.push(right_handle.as_raw());\n+\n+                        let mut temp_node = right_handle.edge_mut();\n                         loop {\n                             // Walk into the smallest subtree of this node\n                             let node = temp_node;\n-                            let node_ptr = node as *mut _;\n-\n-                            if node.is_leaf() {\n-                                // This node is a leaf, do the swap and return\n-                                self.top = (node_ptr, 0);\n-                                node.unsafe_swap(0, &mut *key_ptr, &mut *val_ptr);\n-                                break;\n-                            } else {\n-                                // This node is internal, go deeper\n-                                self.stack.push((node_ptr, 0));\n-                                temp_node = node.unsafe_edge_mut(0);\n+\n+                            match node.kv_handle(0).force() {\n+                                Leaf(mut handle) => {\n+                                    // This node is a leaf, do the swap and return\n+                                    mem::swap(handle.key_mut(), &mut *key_ptr);\n+                                    mem::swap(handle.val_mut(), &mut *val_ptr);\n+                                    return SearchStack {\n+                                        map: self.map,\n+                                        stack: self.stack,\n+                                        top: handle.as_raw()\n+                                    }\n+                                },\n+                                Internal(kv_handle) => {\n+                                    // This node is internal, go deeper\n+                                    let mut handle = kv_handle.into_left_edge();\n+                                    self.stack.push(handle.as_raw());\n+                                    temp_node = handle.into_edge_mut();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    impl<'a, K, V> SearchStack<'a, K, V, handle::Edge, handle::Leaf> {\n+        /// Inserts the key and value into the top element in the stack, and if that node has to\n+        /// split recursively inserts the split contents into the next element stack until\n+        /// splits stop.\n+        ///\n+        /// Assumes that the stack represents a search path from the root to a leaf.\n+        ///\n+        /// An &mut V is returned to the inserted value, for callers that want a reference to this.\n+        pub fn insert(mut self, key: K, val: V) -> &'a mut V {\n+            unsafe {\n+                self.map.length += 1;\n+\n+                // Insert the key and value into the leaf at the top of the stack\n+                let (mut insertion, inserted_ptr) = self.top.from_raw_mut()\n+                                                        .insert_as_leaf(key, val);\n+\n+                loop {\n+                    match insertion {\n+                        Fit => {\n+                            // The last insertion went off without a hitch, no splits! We can stop\n+                            // inserting now.\n+                            return &mut *inserted_ptr;\n+                        }\n+                        Split(key, val, right) => match self.stack.pop() {\n+                            // The last insertion triggered a split, so get the next element on the\n+                            // stack to recursively insert the split node into.\n+                            None => {\n+                                // The stack was empty; we've split the root, and need to make a\n+                                // a new one. This is done in-place because we can't move the\n+                                // root out of a reference to the tree.\n+                                Node::make_internal_root(&mut self.map.root, self.map.b,\n+                                                         key, val, right);\n+\n+                                self.map.depth += 1;\n+                                return &mut *inserted_ptr;\n+                            }\n+                            Some(mut handle) => {\n+                                // The stack wasn't empty, do the insertion and recurse\n+                                insertion = handle.from_raw_mut()\n+                                                  .insert_as_internal(key, val, right);\n+                                continue;\n                             }\n                         }\n                     }\n@@ -761,7 +835,9 @@ impl<S: Writer, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     }\n }\n \n+#[stable]\n impl<K: Ord, V> Default for BTreeMap<K, V> {\n+    #[stable]\n     fn default() -> BTreeMap<K, V> {\n         BTreeMap::new()\n     }\n@@ -853,7 +929,7 @@ enum StackOp<T> {\n }\n \n impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n-        Iterator<(K, V)> for AbsEntries<T> {\n+        Iterator<(K, V)> for AbsIter<T> {\n     // This function is pretty long, but only because there's a lot of cases to consider.\n     // Our iterator represents two search paths, left and right, to the smallest and largest\n     // elements we have yet to yield. lca represents the least common ancestor of these two paths,\n@@ -863,7 +939,7 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n     // Note that the design of these iterators permits an *arbitrary* initial pair of min and max,\n     // making these arbitrary sub-range iterators. However the logic to construct these paths\n     // efficiently is fairly involved, so this is a FIXME. The sub-range iterators also wouldn't be\n-    // able to accurately predict size, so those iterators can't implement ExactSize.\n+    // able to accurately predict size, so those iterators can't implement ExactSizeIterator.\n     fn next(&mut self) -> Option<(K, V)> {\n         loop {\n             // We want the smallest element, so try to get the top of the left stack\n@@ -919,7 +995,7 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n }\n \n impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n-        DoubleEndedIterator<(K, V)> for AbsEntries<T> {\n+        DoubleEndedIterator<(K, V)> for AbsIter<T> {\n     // next_back is totally symmetric to next\n     fn next_back(&mut self) -> Option<(K, V)> {\n         loop {\n@@ -956,36 +1032,55 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n     }\n }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n+impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n }\n-impl<'a, K, V> ExactSize<(&'a K, &'a V)> for Entries<'a, K, V> {}\n+impl<'a, K, V> ExactSizeIterator<(&'a K, &'a V)> for Iter<'a, K, V> {}\n \n \n-impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n }\n-impl<'a, K, V> ExactSize<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {}\n+impl<'a, K, V> ExactSizeIterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {}\n \n \n-impl<K, V> Iterator<(K, V)> for MoveEntries<K, V> {\n+impl<K, V> Iterator<(K, V)> for IntoIter<K, V> {\n     fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<K, V> DoubleEndedIterator<(K, V)> for MoveEntries<K, V> {\n+impl<K, V> DoubleEndedIterator<(K, V)> for IntoIter<K, V> {\n     fn next_back(&mut self) -> Option<(K, V)> { self.inner.next_back() }\n }\n-impl<K, V> ExactSize<(K, V)> for MoveEntries<K, V> {}\n+impl<K, V> ExactSizeIterator<(K, V)> for IntoIter<K, V> {}\n \n \n+impl<'a, K, V> Iterator<&'a K> for Keys<'a, K, V> {\n+    fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+impl<'a, K, V> DoubleEndedIterator<&'a K> for Keys<'a, K, V> {\n+    fn next_back(&mut self) -> Option<(&'a K)> { self.inner.next_back() }\n+}\n+impl<'a, K, V> ExactSizeIterator<&'a K> for Keys<'a, K, V> {}\n+\n+\n+impl<'a, K, V> Iterator<&'a V> for Values<'a, K, V> {\n+    fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+impl<'a, K, V> DoubleEndedIterator<&'a V> for Values<'a, K, V> {\n+    fn next_back(&mut self) -> Option<(&'a V)> { self.inner.next_back() }\n+}\n+impl<'a, K, V> ExactSizeIterator<&'a V> for Values<'a, K, V> {}\n+\n \n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n@@ -1026,11 +1121,29 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1u, \"a\");\n+    /// map.insert(2u, \"b\");\n+    /// map.insert(3u, \"c\");\n+    ///\n+    /// for (key, value) in map.iter() {\n+    ///     println!(\"{}: {}\", key, value);\n+    /// }\n+    ///\n+    /// let (first_key, first_value) = map.iter().next().unwrap();\n+    /// assert_eq!((*first_key, *first_value), (1u, \"a\"));\n+    /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n+    pub fn iter<'a>(&'a self) -> Iter<'a, K, V> {\n         let len = self.len();\n-        Entries {\n-            inner: AbsEntries {\n+        Iter {\n+            inner: AbsIter {\n                 lca: Traverse::traverse(&self.root),\n                 left: RingBuf::new(),\n                 right: RingBuf::new(),\n@@ -1040,11 +1153,29 @@ impl<K, V> BTreeMap<K, V> {\n     }\n \n     /// Gets a mutable iterator over the entries of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(\"a\", 1u);\n+    /// map.insert(\"b\", 2u);\n+    /// map.insert(\"c\", 3u);\n+    ///\n+    /// // add 10 to the value if the key isn't \"a\"\n+    /// for (key, value) in map.iter_mut() {\n+    ///     if key != &\"a\" {\n+    ///         *value += 10;\n+    ///     }\n+    /// }\n+    /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n+    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, K, V> {\n         let len = self.len();\n-        MutEntries {\n-            inner: AbsEntries {\n+        IterMut {\n+            inner: AbsIter {\n                 lca: Traverse::traverse(&mut self.root),\n                 left: RingBuf::new(),\n                 right: RingBuf::new(),\n@@ -1054,11 +1185,26 @@ impl<K, V> BTreeMap<K, V> {\n     }\n \n     /// Gets an owning iterator over the entries of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1u, \"a\");\n+    /// map.insert(2u, \"b\");\n+    /// map.insert(3u, \"c\");\n+    ///\n+    /// for (key, value) in map.into_iter() {\n+    ///     println!(\"{}: {}\", key, value);\n+    /// }\n+    /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveEntries<K, V> {\n+    pub fn into_iter(self) -> IntoIter<K, V> {\n         let len = self.len();\n-        MoveEntries {\n-            inner: AbsEntries {\n+        IntoIter {\n+            inner: AbsIter {\n                 lca: Traverse::traverse(self.root),\n                 left: RingBuf::new(),\n                 right: RingBuf::new(),\n@@ -1068,20 +1214,52 @@ impl<K, V> BTreeMap<K, V> {\n     }\n \n     /// Gets an iterator over the keys of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1u, \"a\");\n+    /// a.insert(2u, \"b\");\n+    ///\n+    /// let keys: Vec<uint> = a.keys().cloned().collect();\n+    /// assert_eq!(keys, vec![1u,2,]);\n+    /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n-        self.iter().map(|(k, _)| k)\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((&'a K, &'a V)) -> &'a K = first; // coerce to fn pointer\n+\n+        Keys { inner: self.iter().map(first) }\n     }\n \n     /// Gets an iterator over the values of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1u, \"a\");\n+    /// a.insert(2u, \"b\");\n+    ///\n+    /// let values: Vec<&str> = a.values().cloned().collect();\n+    /// assert_eq!(values, vec![\"a\",\"b\"]);\n+    /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n-        self.iter().map(|(_, v)| v)\n+        fn second<A, B>((_, b): (A, B)) -> B { b }\n+        let second: fn((&'a K, &'a V)) -> &'a V = second; // coerce to fn pointer\n+\n+        Values { inner: self.iter().map(second) }\n     }\n \n     /// Return the number of elements in the map.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeMap;\n@@ -1096,7 +1274,7 @@ impl<K, V> BTreeMap<K, V> {\n \n     /// Return true if the map contains no elements.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeMap;\n@@ -1112,31 +1290,65 @@ impl<K, V> BTreeMap<K, V> {\n \n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n-    pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V> {\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut count: BTreeMap<&str, uint> = BTreeMap::new();\n+    ///\n+    /// // count the number of occurrences of letters in the vec\n+    /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"].iter() {\n+    ///     match count.entry(*x) {\n+    ///         Entry::Vacant(view) => {\n+    ///             view.set(1);\n+    ///         },\n+    ///         Entry::Occupied(mut view) => {\n+    ///             let v = view.get_mut();\n+    ///             *v += 1;\n+    ///         },\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(count[\"a\"], 3u);\n+    /// ```\n+    pub fn entry<'a>(&'a mut self, mut key: K) -> Entry<'a, K, V> {\n         // same basic logic of `swap` and `pop`, blended together\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n-            match stack.next().search(&key) {\n-                Found(i) => {\n-                    // Perfect match\n-                    return Occupied(OccupiedEntry {\n-                        stack: stack.seal(i)\n-                    });\n-                },\n-                GoDown(i) => {\n-                    stack = match stack.push(i) {\n-                        stack::Done(new_stack) => {\n-                            // Not in the tree, but we've found where it goes\n-                            return Vacant(VacantEntry {\n-                                stack: new_stack,\n-                                key: key,\n-                            });\n-                        }\n-                        stack::Grew(new_stack) => {\n-                            // We've found the subtree this key must go in\n-                            new_stack\n+            let result = stack.with(move |pusher, node| {\n+                return match Node::search(node, &key) {\n+                    Found(handle) => {\n+                        // Perfect match\n+                        Finished(Occupied(OccupiedEntry {\n+                            stack: pusher.seal(handle)\n+                        }))\n+                    },\n+                    GoDown(handle) => {\n+                        match handle.force() {\n+                            Leaf(leaf_handle) => {\n+                                Finished(Vacant(VacantEntry {\n+                                    stack: pusher.seal(leaf_handle),\n+                                    key: key,\n+                                }))\n+                            },\n+                            Internal(internal_handle) => {\n+                                Continue((\n+                                    pusher.push(internal_handle),\n+                                    key\n+                                ))\n+                            }\n                         }\n-                    };\n+                    }\n+                }\n+            });\n+            match result {\n+                Finished(finished) => return finished,\n+                Continue((new_stack, renewed_key)) => {\n+                    stack = new_stack;\n+                    key = renewed_key;\n                 }\n             }\n         }\n@@ -1149,7 +1361,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n #[cfg(test)]\n mod test {\n-    use std::prelude::*;\n+    use prelude::*;\n \n     use super::{BTreeMap, Occupied, Vacant};\n \n@@ -1351,7 +1563,7 @@ mod test {\n \n #[cfg(test)]\n mod bench {\n-    use std::prelude::*;\n+    use prelude::*;\n     use std::rand::{weak_rng, Rng};\n     use test::{Bencher, black_box};\n "}, {"sha": "2c3c546fdb7ff9c924984e491c4e625e6b17443b", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1163, "deletions": 293, "changes": 1456, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -13,16 +13,15 @@\n \n pub use self::InsertionResult::*;\n pub use self::SearchResult::*;\n+pub use self::ForceResult::*;\n pub use self::TraversalItem::*;\n \n use core::prelude::*;\n \n-use core::{slice, mem, ptr};\n+use core::{slice, mem, ptr, cmp, num, raw};\n use core::iter::Zip;\n use core::borrow::BorrowFrom;\n-\n-use vec;\n-use vec::Vec;\n+use alloc::heap;\n \n /// Represents the result of an Insertion: either the item fit, or the node had to split\n pub enum InsertionResult<K, V> {\n@@ -33,86 +32,517 @@ pub enum InsertionResult<K, V> {\n }\n \n /// Represents the result of a search for a key in a single node\n-pub enum SearchResult {\n+pub enum SearchResult<NodeRef> {\n     /// The element was found at the given index\n-    Found(uint),\n+    Found(Handle<NodeRef, handle::KV, handle::LeafOrInternal>),\n     /// The element wasn't found, but if it's anywhere, it must be beyond this edge\n-    GoDown(uint),\n+    GoDown(Handle<NodeRef, handle::Edge, handle::LeafOrInternal>),\n }\n \n /// A B-Tree Node. We keep keys/edges/values separate to optimize searching for keys.\n-#[deriving(Clone)]\n+#[unsafe_no_drop_flag]\n pub struct Node<K, V> {\n-    // FIXME(Gankro): This representation is super safe and easy to reason about, but painfully\n-    // inefficient. As three Vecs, each node consists of *9* words: (ptr, cap, size) * 3. In\n-    // theory, if we take full control of allocation like HashMap's RawTable does,\n-    // and restrict leaves to max size 256 (not unreasonable for a btree node) we can cut\n-    // this down to just (ptr, cap: u8, size: u8, is_leaf: bool). With generic\n-    // integer arguments, cap can even move into the type, reducing this just to\n-    // (ptr, size, is_leaf). This could also have cache benefits for very small nodes, as keys\n-    // could bleed into edges and vals.\n+    // To avoid the need for multiple allocations, we allocate a single buffer with enough space\n+    // for `capacity` keys, `capacity` values, and (in internal nodes) `capacity + 1` edges.\n+    // Despite this, we store three separate pointers to the three \"chunks\" of the buffer because\n+    // the performance drops significantly if the locations of the vals and edges need to be\n+    // recalculated upon access.\n     //\n-    // However doing this would require a fair amount of code to reimplement all\n-    // the Vec logic and iterators. It would also use *way* more unsafe code, which sucks and is\n-    // hard. For now, we accept this cost in the name of correctness and simplicity.\n+    // These will never be null during normal usage of a `Node`. However, to avoid the need for a\n+    // drop flag, `Node::drop` zeroes `keys`, signaling that the `Node` has already been cleaned\n+    // up.\n+    keys: *mut K,\n+    vals: *mut V,\n+\n+    // In leaf nodes, this will be null, and no space will be allocated for edges.\n+    edges: *mut Node<K, V>,\n+\n+    // At any given time, there will be `_len` keys, `_len` values, and (in an internal node)\n+    // `_len + 1` edges. In a leaf node, there will never be any edges.\n     //\n-    // As a compromise, keys and vals could be merged into one Vec<(K, V)>, which would shave\n-    // off 3 words, but possibly hurt our cache efficiency during search, which only cares about\n-    // keys. This would also avoid the Zip we use in our iterator implementations. This is\n-    // probably worth investigating.\n+    // Note: instead of accessing this field directly, please call the `len()` method, which should\n+    // be more stable in the face of representation changes.\n+    _len: uint,\n+\n+    // FIXME(gereeter) It shouldn't be necessary to store the capacity in every node, as it should\n+    // be constant throughout the tree. Once a solution to this is found, it might be possible to\n+    // also pass down the offsets into the buffer that vals and edges are stored at, removing the\n+    // need for those two pointers.\n     //\n-    // Note that this space waste is especially tragic since we store the Nodes by value in their\n-    // parent's edges Vec, so unoccupied spaces in the edges Vec are quite large, and we have\n-    // to shift around a lot more bits during insertion/removal.\n+    // Note: instead of accessing this field directly, please call the `capacity()` method, which\n+    // should be more stable in the face of representation changes.\n+    _capacity: uint,\n+}\n+\n+/// Rounds up to a multiple of a power of two. Returns the closest multiple\n+/// of `target_alignment` that is higher or equal to `unrounded`.\n+///\n+/// # Panics\n+///\n+/// Fails if `target_alignment` is not a power of two.\n+#[inline]\n+fn round_up_to_next(unrounded: uint, target_alignment: uint) -> uint {\n+    assert!(num::UnsignedInt::is_power_of_two(target_alignment));\n+    (unrounded + target_alignment - 1) & !(target_alignment - 1)\n+}\n+\n+#[test]\n+fn test_rounding() {\n+    assert_eq!(round_up_to_next(0, 4), 0);\n+    assert_eq!(round_up_to_next(1, 4), 4);\n+    assert_eq!(round_up_to_next(2, 4), 4);\n+    assert_eq!(round_up_to_next(3, 4), 4);\n+    assert_eq!(round_up_to_next(4, 4), 4);\n+    assert_eq!(round_up_to_next(5, 4), 8);\n+}\n+\n+// Returns a tuple of (val_offset, edge_offset),\n+// from the start of a mallocated array.\n+#[inline]\n+fn calculate_offsets(keys_size: uint,\n+                     vals_size: uint, vals_align: uint,\n+                     edges_align: uint)\n+                     -> (uint, uint) {\n+    let vals_offset = round_up_to_next(keys_size, vals_align);\n+    let end_of_vals = vals_offset + vals_size;\n+\n+    let edges_offset = round_up_to_next(end_of_vals, edges_align);\n+\n+    (vals_offset, edges_offset)\n+}\n+\n+// Returns a tuple of (minimum required alignment, array_size),\n+// from the start of a mallocated array.\n+#[inline]\n+fn calculate_allocation(keys_size: uint, keys_align: uint,\n+                        vals_size: uint, vals_align: uint,\n+                        edges_size: uint, edges_align: uint)\n+                        -> (uint, uint) {\n+    let (_, edges_offset) = calculate_offsets(keys_size,\n+                                              vals_size, vals_align,\n+                                                         edges_align);\n+    let end_of_edges = edges_offset + edges_size;\n+\n+    let min_align = cmp::max(keys_align, cmp::max(vals_align, edges_align));\n+\n+    (min_align, end_of_edges)\n+}\n+\n+#[test]\n+fn test_offset_calculation() {\n+    assert_eq!(calculate_allocation(128, 8, 15, 1, 4, 4), (8, 148));\n+    assert_eq!(calculate_allocation(3, 1, 2, 1, 1, 1), (1, 6));\n+    assert_eq!(calculate_allocation(6, 2, 12, 4, 24, 8), (8, 48));\n+    assert_eq!(calculate_offsets(128, 15, 1, 4), (128, 144));\n+    assert_eq!(calculate_offsets(3, 2, 1, 1), (3, 5));\n+    assert_eq!(calculate_offsets(6, 12, 4, 8), (8, 24));\n+}\n+\n+fn calculate_allocation_generic<K, V>(capacity: uint, is_leaf: bool) -> (uint, uint) {\n+    let (keys_size, keys_align) = (capacity * mem::size_of::<K>(), mem::min_align_of::<K>());\n+    let (vals_size, vals_align) = (capacity * mem::size_of::<V>(), mem::min_align_of::<V>());\n+    let (edges_size, edges_align) = if is_leaf {\n+        (0, 1)\n+    } else {\n+        ((capacity + 1) * mem::size_of::<Node<K, V>>(), mem::min_align_of::<Node<K, V>>())\n+    };\n+\n+    calculate_allocation(\n+            keys_size, keys_align,\n+            vals_size, vals_align,\n+            edges_size, edges_align\n+    )\n+}\n+\n+fn calculate_offsets_generic<K, V>(capacity: uint, is_leaf: bool) -> (uint, uint) {\n+    let keys_size = capacity * mem::size_of::<K>();\n+    let vals_size = capacity * mem::size_of::<V>();\n+    let vals_align = mem::min_align_of::<V>();\n+    let edges_align = if is_leaf {\n+        1\n+    } else {\n+        mem::min_align_of::<Node<K, V>>()\n+    };\n+\n+    calculate_offsets(\n+            keys_size,\n+            vals_size, vals_align,\n+                       edges_align\n+    )\n+}\n+\n+/// An iterator over a slice that owns the elements of the slice but not the allocation.\n+struct RawItems<T> {\n+    head: *const T,\n+    tail: *const T,\n+}\n+\n+impl<T> RawItems<T> {\n+    unsafe fn from_slice(slice: &[T]) -> RawItems<T> {\n+        RawItems::from_parts(slice.as_ptr(), slice.len())\n+    }\n+\n+    unsafe fn from_parts(ptr: *const T, len: uint) -> RawItems<T> {\n+        if mem::size_of::<T>() == 0 {\n+            RawItems {\n+                head: ptr,\n+                tail: (ptr as uint + len) as *const T,\n+            }\n+        } else {\n+            RawItems {\n+                head: ptr,\n+                tail: ptr.offset(len as int),\n+            }\n+        }\n+    }\n+\n+    unsafe fn push(&mut self, val: T) {\n+        ptr::write(self.tail as *mut T, val);\n+\n+        if mem::size_of::<T>() == 0 {\n+            self.tail = (self.tail as uint + 1) as *const T;\n+        } else {\n+            self.tail = self.tail.offset(1);\n+        }\n+    }\n+}\n+\n+impl<T> Iterator<T> for RawItems<T> {\n+    fn next(&mut self) -> Option<T> {\n+        if self.head == self.tail {\n+            None\n+        } else {\n+            unsafe {\n+                let ret = Some(ptr::read(self.head));\n+\n+                if mem::size_of::<T>() == 0 {\n+                    self.head = (self.head as uint + 1) as *const T;\n+                } else {\n+                    self.head = self.head.offset(1);\n+                }\n+\n+                ret\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> DoubleEndedIterator<T> for RawItems<T> {\n+    fn next_back(&mut self) -> Option<T> {\n+        if self.head == self.tail {\n+            None\n+        } else {\n+            unsafe {\n+                if mem::size_of::<T>() == 0 {\n+                    self.tail = (self.tail as uint - 1) as *const T;\n+                } else {\n+                    self.tail = self.tail.offset(-1);\n+                }\n+\n+                Some(ptr::read(self.tail))\n+            }\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for RawItems<T> {\n+    fn drop(&mut self) {\n+        for _ in *self {}\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<K, V> Drop for Node<K, V> {\n+    fn drop(&mut self) {\n+        if self.keys.is_null() {\n+            // We have already cleaned up this node.\n+            return;\n+        }\n+\n+        // Do the actual cleanup.\n+        unsafe {\n+            drop(RawItems::from_slice(self.keys()));\n+            drop(RawItems::from_slice(self.vals()));\n+            drop(RawItems::from_slice(self.edges()));\n \n-    keys: Vec<K>,\n-    edges: Vec<Node<K, V>>,\n-    vals: Vec<V>,\n+            self.destroy();\n+        }\n+\n+        self.keys = ptr::null_mut();\n+    }\n+}\n+\n+impl<K, V> Node<K, V> {\n+    /// Make a new internal node. The caller must initialize the result to fix the invariant that\n+    /// there are `len() + 1` edges.\n+    unsafe fn new_internal(capacity: uint) -> Node<K, V> {\n+        let (alignment, size) = calculate_allocation_generic::<K, V>(capacity, false);\n+\n+        let buffer = heap::allocate(size, alignment);\n+        if buffer.is_null() { ::alloc::oom(); }\n+\n+        let (vals_offset, edges_offset) = calculate_offsets_generic::<K, V>(capacity, false);\n+\n+        Node {\n+            keys: buffer as *mut K,\n+            vals: buffer.offset(vals_offset as int) as *mut V,\n+            edges: buffer.offset(edges_offset as int) as *mut Node<K, V>,\n+            _len: 0,\n+            _capacity: capacity,\n+        }\n+    }\n+\n+    /// Make a new leaf node\n+    fn new_leaf(capacity: uint) -> Node<K, V> {\n+        let (alignment, size) = calculate_allocation_generic::<K, V>(capacity, true);\n+\n+        let buffer = unsafe { heap::allocate(size, alignment) };\n+        if buffer.is_null() { ::alloc::oom(); }\n+\n+        let (vals_offset, _) = calculate_offsets_generic::<K, V>(capacity, true);\n+\n+        Node {\n+            keys: buffer as *mut K,\n+            vals: unsafe { buffer.offset(vals_offset as int) as *mut V },\n+            edges: ptr::null_mut(),\n+            _len: 0,\n+            _capacity: capacity,\n+        }\n+    }\n+\n+    unsafe fn destroy(&mut self) {\n+        let (alignment, size) =\n+                calculate_allocation_generic::<K, V>(self.capacity(), self.is_leaf());\n+        heap::deallocate(self.keys as *mut u8, size, alignment);\n+    }\n+\n+    #[inline]\n+    pub fn as_slices<'a>(&'a self) -> (&'a [K], &'a [V]) {\n+        unsafe {(\n+            mem::transmute(raw::Slice {\n+                data: self.keys as *const K,\n+                len: self.len()\n+            }),\n+            mem::transmute(raw::Slice {\n+                data: self.vals as *const V,\n+                len: self.len()\n+            })\n+        )}\n+    }\n+\n+    #[inline]\n+    pub fn as_slices_mut<'a>(&'a mut self) -> (&'a mut [K], &'a mut [V]) {\n+        unsafe { mem::transmute(self.as_slices()) }\n+    }\n+\n+    #[inline]\n+    pub fn as_slices_internal<'a>(&'a self) -> (&'a [K], &'a [V], &'a [Node<K, V>]) {\n+        let (keys, vals) = self.as_slices();\n+        let edges: &[_] = if self.is_leaf() {\n+            &[]\n+        } else {\n+            unsafe {\n+                mem::transmute(raw::Slice {\n+                    data: self.edges as *const Node<K, V>,\n+                    len: self.len() + 1\n+                })\n+            }\n+        };\n+        (keys, vals, edges)\n+    }\n+\n+    #[inline]\n+    pub fn as_slices_internal_mut<'a>(&'a mut self) -> (&'a mut [K], &'a mut [V],\n+                                                        &'a mut [Node<K, V>]) {\n+        unsafe { mem::transmute(self.as_slices_internal()) }\n+    }\n+\n+    #[inline]\n+    pub fn keys<'a>(&'a self) -> &'a [K] {\n+        self.as_slices().0\n+    }\n+\n+    #[inline]\n+    pub fn keys_mut<'a>(&'a mut self) -> &'a mut [K] {\n+        self.as_slices_mut().0\n+    }\n+\n+    #[inline]\n+    pub fn vals<'a>(&'a self) -> &'a [V] {\n+        self.as_slices().1\n+    }\n+\n+    #[inline]\n+    pub fn vals_mut<'a>(&'a mut self) -> &'a mut [V] {\n+        self.as_slices_mut().1\n+    }\n+\n+    #[inline]\n+    pub fn edges<'a>(&'a self) -> &'a [Node<K, V>] {\n+        self.as_slices_internal().2\n+    }\n+\n+    #[inline]\n+    pub fn edges_mut<'a>(&'a mut self) -> &'a mut [Node<K, V>] {\n+        self.as_slices_internal_mut().2\n+    }\n+}\n+\n+// FIXME(gereeter) Write an efficient clone_from\n+#[stable]\n+impl<K: Clone, V: Clone> Clone for Node<K, V> {\n+    fn clone(&self) -> Node<K, V> {\n+        let mut ret = if self.is_leaf() {\n+            Node::new_leaf(self.capacity())\n+        } else {\n+            unsafe { Node::new_internal(self.capacity()) }\n+        };\n+\n+        unsafe {\n+            // For failure safety\n+            let mut keys = RawItems::from_parts(ret.keys().as_ptr(), 0);\n+            let mut vals = RawItems::from_parts(ret.vals().as_ptr(), 0);\n+            let mut edges = RawItems::from_parts(ret.edges().as_ptr(), 0);\n+\n+            for key in self.keys().iter() {\n+                keys.push(key.clone())\n+            }\n+            for val in self.vals().iter() {\n+                vals.push(val.clone())\n+            }\n+            for edge in self.edges().iter() {\n+                edges.push(edge.clone())\n+            }\n+\n+            mem::forget(keys);\n+            mem::forget(vals);\n+            mem::forget(edges);\n+\n+            ret._len = self.len();\n+        }\n+\n+        ret\n+    }\n+}\n+\n+/// A reference to something in the middle of a `Node`. There are two `Type`s of `Handle`s,\n+/// namely `KV` handles, which point to key/value pairs, and `Edge` handles, which point to edges\n+/// before or after key/value pairs. Methods are provided for removing pairs, inserting into edges,\n+/// accessing the stored values, and moving around the `Node`.\n+///\n+/// This handle is generic, and can take any sort of reference to a `Node`. The reason for this is\n+/// two-fold. First of all, it reduces the amount of repetitive code, implementing functions that\n+/// don't need mutability on both mutable and immutable references. Secondly and more importantly,\n+/// this allows users of the `Handle` API to associate metadata with the reference. This is used in\n+/// `BTreeMap` to give `Node`s temporary \"IDs\" that persist to when the `Node` is used in a\n+/// `Handle`.\n+///\n+/// # A note on safety\n+///\n+/// Unfortunately, the extra power afforded by being generic also means that safety can technically\n+/// be broken. For sensible implementations of `Deref` and `DerefMut`, these handles are perfectly\n+/// safe. As long as repeatedly calling `.deref()` results in the same Node being returned each\n+/// time, everything should work fine. However, if the `Deref` implementation swaps in multiple\n+/// different nodes, then the indices that are assumed to be in bounds suddenly stop being so. For\n+/// example:\n+///\n+/// ```rust,ignore\n+/// struct Nasty<'a> {\n+///     first: &'a Node<uint, uint>,\n+///     second: &'a Node<uint, uint>,\n+///     flag: &'a Cell<bool>,\n+/// }\n+///\n+/// impl<'a> Deref<Node<uint, uint>> for Nasty<'a> {\n+///     fn deref(&self) -> &Node<uint, uint> {\n+///         if self.flag.get() {\n+///             &*self.second\n+///         } else {\n+///             &*self.first\n+///         }\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let flag = Cell::new(false);\n+///     let mut small_node = Node::make_leaf_root(3);\n+///     let mut large_node = Node::make_leaf_root(100);\n+///\n+///     for i in range(0, 100) {\n+///         // Insert to the end\n+///         large_node.edge_handle(i).insert_as_leaf(i, i);\n+///     }\n+///\n+///     let nasty = Nasty {\n+///         first: &large_node,\n+///         second: &small_node,\n+///         flag: &flag\n+///     }\n+///\n+///     // The handle points at index 75.\n+///     let handle = Node::search(nasty, 75);\n+///\n+///     // Now the handle still points at index 75, but on the small node, which has no index 75.\n+///     flag.set(true);\n+///\n+///     println!(\"Uninitialized memory: {}\", handle.into_kv());\n+/// }\n+/// ```\n+#[deriving(Copy)]\n+pub struct Handle<NodeRef, Type, NodeType> {\n+    node: NodeRef,\n+    index: uint\n+}\n+\n+pub mod handle {\n+    // Handle types.\n+    pub enum KV {}\n+    pub enum Edge {}\n+\n+    // Handle node types.\n+    pub enum LeafOrInternal {}\n+    pub enum Leaf {}\n+    pub enum Internal {}\n }\n \n impl<K: Ord, V> Node<K, V> {\n     /// Searches for the given key in the node. If it finds an exact match,\n     /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n-    pub fn search<Sized? Q>(&self, key: &Q) -> SearchResult where Q: BorrowFrom<K> + Ord {\n+    pub fn search<Sized? Q, NodeRef: Deref<Node<K, V>>>(node: NodeRef, key: &Q)\n+                  -> SearchResult<NodeRef> where Q: BorrowFrom<K> + Ord {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n         // worse for uints.\n-        self.search_linear(key)\n+        let (found, index) = node.search_linear(key);\n+        if found {\n+            Found(Handle {\n+                node: node,\n+                index: index\n+            })\n+        } else {\n+            GoDown(Handle {\n+                node: node,\n+                index: index\n+            })\n+        }\n     }\n \n-    fn search_linear<Sized? Q>(&self, key: &Q) -> SearchResult where Q: BorrowFrom<K> + Ord {\n-        for (i, k) in self.keys.iter().enumerate() {\n+    fn search_linear<Sized? Q>(&self, key: &Q) -> (bool, uint) where Q: BorrowFrom<K> + Ord {\n+        for (i, k) in self.keys().iter().enumerate() {\n             match key.cmp(BorrowFrom::borrow_from(k)) {\n                 Greater => {},\n-                Equal => return Found(i),\n-                Less => return GoDown(i),\n+                Equal => return (true, i),\n+                Less => return (false, i),\n             }\n         }\n-        GoDown(self.len())\n+        (false, self.len())\n     }\n }\n \n // Public interface\n impl <K, V> Node<K, V> {\n-    /// Make a new internal node\n-    pub fn new_internal(capacity: uint) -> Node<K, V> {\n-        Node {\n-            keys: Vec::with_capacity(capacity),\n-            vals: Vec::with_capacity(capacity),\n-            edges: Vec::with_capacity(capacity + 1),\n-        }\n-    }\n-\n-    /// Make a new leaf node\n-    pub fn new_leaf(capacity: uint) -> Node<K, V> {\n-        Node {\n-            keys: Vec::with_capacity(capacity),\n-            vals: Vec::with_capacity(capacity),\n-            edges: Vec::new(),\n-        }\n-    }\n-\n     /// Make a leaf root from scratch\n     pub fn make_leaf_root(b: uint) -> Node<K, V> {\n         Node::new_leaf(capacity_from_b(b))\n@@ -121,28 +551,29 @@ impl <K, V> Node<K, V> {\n     /// Make an internal root and swap it with an old root\n     pub fn make_internal_root(left_and_out: &mut Node<K,V>, b: uint, key: K, value: V,\n             right: Node<K,V>) {\n-        let mut node = Node::new_internal(capacity_from_b(b));\n-        mem::swap(left_and_out, &mut node);\n-        left_and_out.keys.push(key);\n-        left_and_out.vals.push(value);\n-        left_and_out.edges.push(node);\n-        left_and_out.edges.push(right);\n+        let node = mem::replace(left_and_out, unsafe { Node::new_internal(capacity_from_b(b)) });\n+        left_and_out._len = 1;\n+        unsafe {\n+            ptr::write(left_and_out.keys_mut().unsafe_mut(0), key);\n+            ptr::write(left_and_out.vals_mut().unsafe_mut(0), value);\n+            ptr::write(left_and_out.edges_mut().unsafe_mut(0), node);\n+            ptr::write(left_and_out.edges_mut().unsafe_mut(1), right);\n+        }\n     }\n \n-\n     /// How many key-value pairs the node contains\n     pub fn len(&self) -> uint {\n-        self.keys.len()\n+        self._len\n     }\n \n     /// How many key-value pairs the node can fit\n     pub fn capacity(&self) -> uint {\n-        self.keys.capacity()\n+        self._capacity\n     }\n \n     /// If the node has any children\n     pub fn is_leaf(&self) -> bool {\n-        self.edges.is_empty()\n+        self.edges.is_null()\n     }\n \n     /// if the node has too few elements\n@@ -154,336 +585,695 @@ impl <K, V> Node<K, V> {\n     pub fn is_full(&self) -> bool {\n         self.len() == self.capacity()\n     }\n+}\n \n-    /// Swap the given key-value pair with the key-value pair stored in the node's index,\n-    /// without checking bounds.\n-    pub unsafe fn unsafe_swap(&mut self, index: uint, key: &mut K, val: &mut V) {\n-        mem::swap(self.keys.as_mut_slice().unsafe_mut(index), key);\n-        mem::swap(self.vals.as_mut_slice().unsafe_mut(index), val);\n+impl<K, V, NodeRef: Deref<Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, NodeType> {\n+    /// Returns a reference to the node that contains the pointed-to edge or key/value pair. This\n+    /// is very different from `edge` and `edge_mut` because those return children of the node\n+    /// returned by `node`.\n+    pub fn node(&self) -> &Node<K, V> {\n+        &*self.node\n     }\n+}\n \n-    /// Get the node's key mutably without any bounds checks.\n-    pub unsafe fn unsafe_key_mut(&mut self, index: uint) -> &mut K {\n-        self.keys.as_mut_slice().unsafe_mut(index)\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, NodeType> {\n+    /// Converts a handle into one that stores the same information using a raw pointer. This can\n+    /// be useful in conjunction with `from_raw` when the type system is insufficient for\n+    /// determining the lifetimes of the nodes.\n+    pub fn as_raw(&mut self) -> Handle<*mut Node<K, V>, Type, NodeType> {\n+        Handle {\n+            node: &mut *self.node as *mut _,\n+            index: self.index\n+        }\n     }\n+}\n \n-    /// Get the node's value at the given index\n-    pub fn val(&self, index: uint) -> Option<&V> {\n-        self.vals.as_slice().get(index)\n+impl<K, V, Type, NodeType> Handle<*mut Node<K, V>, Type, NodeType> {\n+    /// Converts from a handle stored with a raw pointer, which isn't directly usable, to a handle\n+    /// stored with a reference. This is an unsafe inverse of `as_raw`, and together they allow\n+    /// unsafely extending the lifetime of the reference to the `Node`.\n+    pub unsafe fn from_raw<'a>(&'a self) -> Handle<&'a Node<K, V>, Type, NodeType> {\n+        Handle {\n+            node: &*self.node,\n+            index: self.index\n+        }\n     }\n \n-    /// Get the node's value at the given index\n-    pub fn val_mut(&mut self, index: uint) -> Option<&mut V> {\n-        self.vals.as_mut_slice().get_mut(index)\n+    /// Converts from a handle stored with a raw pointer, which isn't directly usable, to a handle\n+    /// stored with a mutable reference. This is an unsafe inverse of `as_raw`, and together they\n+    /// allow unsafely extending the lifetime of the reference to the `Node`.\n+    pub unsafe fn from_raw_mut<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, Type, NodeType> {\n+        Handle {\n+            node: &mut *self.node,\n+            index: self.index\n+        }\n     }\n+}\n \n-    /// Get the node's value mutably without any bounds checks.\n-    pub unsafe fn unsafe_val_mut(&mut self, index: uint) -> &mut V {\n-        self.vals.as_mut_slice().unsafe_mut(index)\n+impl<'a, K: 'a, V: 'a> Handle<&'a Node<K, V>, handle::Edge, handle::Internal> {\n+    /// Turns the handle into a reference to the edge it points at. This is necessary because the\n+    /// returned pointer has a larger lifetime than what would be returned by `edge` or `edge_mut`,\n+    /// making it more suitable for moving down a chain of nodes.\n+    pub fn into_edge(self) -> &'a Node<K, V> {\n+        unsafe {\n+            self.node.edges().unsafe_get(self.index)\n+        }\n     }\n+}\n \n-    /// Get the node's edge at the given index\n-    pub fn edge(&self, index: uint) -> Option<&Node<K,V>> {\n-        self.edges.as_slice().get(index)\n+impl<'a, K: 'a, V: 'a> Handle<&'a mut Node<K, V>, handle::Edge, handle::Internal> {\n+    /// Turns the handle into a mutable reference to the edge it points at. This is necessary\n+    /// because the returned pointer has a larger lifetime than what would be returned by\n+    /// `edge_mut`, making it more suitable for moving down a chain of nodes.\n+    pub fn into_edge_mut(self) -> &'a mut Node<K, V> {\n+        unsafe {\n+            self.node.edges_mut().unsafe_mut(self.index)\n+        }\n     }\n+}\n \n-    /// Get the node's edge mutably at the given index\n-    pub fn edge_mut(&mut self, index: uint) -> Option<&mut Node<K,V>> {\n-        self.edges.as_mut_slice().get_mut(index)\n-    }\n+impl<K, V, NodeRef: Deref<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n+    // This doesn't exist because there are no uses for it,\n+    // but is fine to add, analagous to edge_mut.\n+    //\n+    // /// Returns a reference to the edge pointed-to by this handle. This should not be\n+    // /// confused with `node`, which references the parent node of what is returned here.\n+    // pub fn edge(&self) -> &Node<K, V>\n+}\n \n-    /// Get the node's edge mutably without any bounds checks.\n-    pub unsafe fn unsafe_edge_mut(&mut self, index: uint) -> &mut Node<K,V> {\n-        self.edges.as_mut_slice().unsafe_mut(index)\n-    }\n+pub enum ForceResult<NodeRef, Type> {\n+    Leaf(Handle<NodeRef, Type, handle::Leaf>),\n+    Internal(Handle<NodeRef, Type, handle::Internal>)\n+}\n \n-    /// Pop an edge off the end of the node\n-    pub fn pop_edge(&mut self) -> Option<Node<K,V>> {\n-        self.edges.pop()\n+impl<K, V, NodeRef: Deref<Node<K, V>>, Type> Handle<NodeRef, Type, handle::LeafOrInternal> {\n+    /// Figure out whether this handle is pointing to something in a leaf node or to something in\n+    /// an internal node, clarifying the type according to the result.\n+    pub fn force(self) -> ForceResult<NodeRef, Type> {\n+        if self.node.is_leaf() {\n+            Leaf(Handle {\n+                node: self.node,\n+                index: self.index\n+            })\n+        } else {\n+            Internal(Handle {\n+                node: self.node,\n+                index: self.index\n+            })\n+        }\n     }\n+}\n \n-    /// Try to insert this key-value pair at the given index in this internal node\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Leaf> {\n+    /// Tries to insert this key-value pair at the given index in this leaf node\n     /// If the node is full, we have to split it.\n     ///\n     /// Returns a *mut V to the inserted value, because the caller may want this when\n     /// they're done mutating the tree, but we don't want to borrow anything for now.\n-    pub fn insert_as_leaf(&mut self, index: uint, key: K, value: V) ->\n+    pub fn insert_as_leaf(mut self, key: K, value: V) ->\n             (InsertionResult<K, V>, *mut V) {\n-        if !self.is_full() {\n+        if !self.node.is_full() {\n             // The element can fit, just insert it\n-            self.insert_fit_as_leaf(index, key, value);\n-            (Fit, unsafe { self.unsafe_val_mut(index) as *mut _ })\n+            (Fit, unsafe { self.node.insert_kv(self.index, key, value) as *mut _ })\n         } else {\n             // The element can't fit, this node is full. Split it into two nodes.\n-            let (new_key, new_val, mut new_right) = self.split();\n-            let left_len = self.len();\n-\n-            let ptr = if index <= left_len {\n-                self.insert_fit_as_leaf(index, key, value);\n-                unsafe { self.unsafe_val_mut(index) as *mut _ }\n-            } else {\n-                new_right.insert_fit_as_leaf(index - left_len - 1, key, value);\n-                unsafe { new_right.unsafe_val_mut(index - left_len - 1) as *mut _ }\n-            };\n+            let (new_key, new_val, mut new_right) = self.node.split();\n+            let left_len = self.node.len();\n+\n+            let ptr = unsafe {\n+                if self.index <= left_len {\n+                    self.node.insert_kv(self.index, key, value)\n+                } else {\n+                    // We need to subtract 1 because in splitting we took out new_key and new_val.\n+                    // Just being in the right node means we are past left_len k/v pairs in the\n+                    // left node and 1 k/v pair in the parent node.\n+                    new_right.insert_kv(self.index - left_len - 1, key, value)\n+                }\n+            } as *mut _;\n \n             (Split(new_key, new_val, new_right), ptr)\n         }\n     }\n+}\n \n-    /// Try to insert this key-value pair at the given index in this internal node\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n+    /// Returns a mutable reference to the edge pointed-to by this handle. This should not be\n+    /// confused with `node`, which references the parent node of what is returned here.\n+    pub fn edge_mut(&mut self) -> &mut Node<K, V> {\n+        unsafe {\n+            self.node.edges_mut().unsafe_mut(self.index)\n+        }\n+    }\n+\n+    /// Tries to insert this key-value pair at the given index in this internal node\n     /// If the node is full, we have to split it.\n-    pub fn insert_as_internal(&mut self, index: uint, key: K, value: V, right: Node<K, V>)\n+    pub fn insert_as_internal(mut self, key: K, value: V, right: Node<K, V>)\n             -> InsertionResult<K, V> {\n-        if !self.is_full() {\n+        if !self.node.is_full() {\n             // The element can fit, just insert it\n-            self.insert_fit_as_internal(index, key, value, right);\n+            unsafe {\n+                self.node.insert_kv(self.index, key, value);\n+                self.node.insert_edge(self.index + 1, right); // +1 to insert to the right\n+            }\n             Fit\n         } else {\n             // The element can't fit, this node is full. Split it into two nodes.\n-            let (new_key, new_val, mut new_right) = self.split();\n-            let left_len = self.len();\n-\n-            if index <= left_len {\n-                self.insert_fit_as_internal(index, key, value, right);\n+            let (new_key, new_val, mut new_right) = self.node.split();\n+            let left_len = self.node.len();\n+\n+            if self.index <= left_len {\n+                unsafe {\n+                    self.node.insert_kv(self.index, key, value);\n+                    self.node.insert_edge(self.index + 1, right); // +1 to insert to the right\n+                }\n             } else {\n-                new_right.insert_fit_as_internal(index - left_len - 1, key, value, right);\n+                unsafe {\n+                    // The -1 here is for the same reason as in insert_as_internal - because we\n+                    // split, there are actually left_len + 1 k/v pairs before the right node, with\n+                    // the extra 1 being put in the parent.\n+                    new_right.insert_kv(self.index - left_len - 1, key, value);\n+                    new_right.insert_edge(self.index - left_len, right);\n+                }\n             }\n \n             Split(new_key, new_val, new_right)\n         }\n     }\n \n-    /// Remove the key-value pair at the given index\n-    pub fn remove_as_leaf(&mut self, index: uint) -> (K, V) {\n-        match (self.keys.remove(index), self.vals.remove(index)) {\n-            (Some(k), Some(v)) => (k, v),\n-            _ => unreachable!(),\n-        }\n-    }\n-\n     /// Handle an underflow in this node's child. We favour handling \"to the left\" because we know\n     /// we're empty, but our neighbour can be full. Handling to the left means when we choose to\n     /// steal, we pop off the end of our neighbour (always fast) and \"unshift\" ourselves\n     /// (always slow, but at least faster since we know we're half-empty).\n     /// Handling \"to the right\" reverses these roles. Of course, we merge whenever possible\n     /// because we want dense nodes, and merging is about equal work regardless of direction.\n-    pub fn handle_underflow(&mut self, underflowed_child_index: uint) {\n-        assert!(underflowed_child_index <= self.len());\n+    pub fn handle_underflow(mut self) {\n         unsafe {\n-            if underflowed_child_index > 0 {\n-                self.handle_underflow_to_left(underflowed_child_index);\n+            if self.index > 0 {\n+                self.handle_underflow_to_left();\n             } else {\n-                self.handle_underflow_to_right(underflowed_child_index);\n+                self.handle_underflow_to_right();\n             }\n         }\n     }\n \n-    pub fn iter<'a>(&'a self) -> Traversal<'a, K, V> {\n-        let is_leaf = self.is_leaf();\n-        Traversal {\n-            elems: self.keys.as_slice().iter().zip(self.vals.as_slice().iter()),\n-            edges: self.edges.as_slice().iter(),\n-            head_is_edge: true,\n-            tail_is_edge: true,\n-            has_edges: !is_leaf,\n+    /// Right is underflowed. Tries to steal from left,\n+    /// but merges left and right if left is low too.\n+    unsafe fn handle_underflow_to_left(&mut self) {\n+        let left_len = self.node.edges()[self.index - 1].len();\n+        if left_len > min_load_from_capacity(self.node.capacity()) {\n+            self.left_kv().steal_rightward();\n+        } else {\n+            self.left_kv().merge_children();\n         }\n     }\n \n-    pub fn iter_mut<'a>(&'a mut self) -> MutTraversal<'a, K, V> {\n-        let is_leaf = self.is_leaf();\n-        MutTraversal {\n-            elems: self.keys.as_slice().iter().zip(self.vals.as_mut_slice().iter_mut()),\n-            edges: self.edges.as_mut_slice().iter_mut(),\n-            head_is_edge: true,\n-            tail_is_edge: true,\n-            has_edges: !is_leaf,\n+    /// Left is underflowed. Tries to steal from the right,\n+    /// but merges left and right if right is low too.\n+    unsafe fn handle_underflow_to_right(&mut self) {\n+        let right_len = self.node.edges()[self.index + 1].len();\n+        if right_len > min_load_from_capacity(self.node.capacity()) {\n+            self.right_kv().steal_leftward();\n+        } else {\n+            self.right_kv().merge_children();\n         }\n     }\n+}\n \n-    pub fn into_iter(self) -> MoveTraversal<K, V> {\n-        let is_leaf = self.is_leaf();\n-        MoveTraversal {\n-            elems: self.keys.into_iter().zip(self.vals.into_iter()),\n-            edges: self.edges.into_iter(),\n-            head_is_edge: true,\n-            tail_is_edge: true,\n-            has_edges: !is_leaf,\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, handle::Edge, NodeType> {\n+    /// Gets the handle pointing to the key/value pair just to the left of the pointed-to edge.\n+    /// This is unsafe because the handle might point to the first edge in the node, which has no\n+    /// pair to its left.\n+    unsafe fn left_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::KV, NodeType> {\n+        Handle {\n+            node: &mut *self.node,\n+            index: self.index - 1\n+        }\n+    }\n+\n+    /// Gets the handle pointing to the key/value pair just to the right of the pointed-to edge.\n+    /// This is unsafe because the handle might point to the last edge in the node, which has no\n+    /// pair to its right.\n+    unsafe fn right_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::KV, NodeType> {\n+        Handle {\n+            node: &mut *self.node,\n+            index: self.index\n         }\n     }\n }\n \n-// Private implementation details\n-impl<K, V> Node<K, V> {\n-    /// Make a node from its raw components\n-    fn from_vecs(keys: Vec<K>, vals: Vec<V>, edges: Vec<Node<K, V>>) -> Node<K, V> {\n-        Node {\n-            keys: keys,\n-            vals: vals,\n-            edges: edges,\n+impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a Node<K, V>, handle::KV, NodeType> {\n+    /// Turns the handle into references to the key and value it points at. This is necessary\n+    /// because the returned pointers have larger lifetimes than what would be returned by `key`\n+    /// or `val`.\n+    pub fn into_kv(self) -> (&'a K, &'a V) {\n+        let (keys, vals) = self.node.as_slices();\n+        unsafe {\n+            (\n+                keys.unsafe_get(self.index),\n+                vals.unsafe_get(self.index)\n+            )\n         }\n     }\n+}\n \n-    /// We have somehow verified that this key-value pair will fit in this internal node,\n-    /// so insert under that assumption.\n-    fn insert_fit_as_leaf(&mut self, index: uint, key: K, val: V) {\n-        self.keys.insert(index, key);\n-        self.vals.insert(index, val);\n+impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType> {\n+    /// Turns the handle into mutable references to the key and value it points at. This is\n+    /// necessary because the returned pointers have larger lifetimes than what would be returned\n+    /// by `key_mut` or `val_mut`.\n+    pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) {\n+        let (keys, vals) = self.node.as_slices_mut();\n+        unsafe {\n+            (\n+                keys.unsafe_mut(self.index),\n+                vals.unsafe_mut(self.index)\n+            )\n+        }\n     }\n \n-    /// We have somehow verified that this key-value pair will fit in this internal node,\n-    /// so insert under that assumption\n-    fn insert_fit_as_internal(&mut self, index: uint, key: K, val: V, right: Node<K, V>) {\n-        self.keys.insert(index, key);\n-        self.vals.insert(index, val);\n-        self.edges.insert(index + 1, right);\n+    /// Convert this handle into one pointing at the edge immediately to the left of the key/value\n+    /// pair pointed-to by this handle. This is useful because it returns a reference with larger\n+    /// lifetime than `left_edge`.\n+    pub fn into_left_edge(self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n+        Handle {\n+            node: &mut *self.node,\n+            index: self.index\n+        }\n     }\n+}\n \n-    /// Node is full, so split it into two nodes, and yield the middle-most key-value pair\n-    /// because we have one too many, and our parent now has one too few\n-    fn split(&mut self) -> (K, V, Node<K, V>) {\n-        let r_keys = split(&mut self.keys);\n-        let r_vals = split(&mut self.vals);\n-        let r_edges = if self.edges.is_empty() {\n-            Vec::new()\n-        } else {\n-            split(&mut self.edges)\n-        };\n+impl<'a, K: 'a, V: 'a, NodeRef: Deref<Node<K, V>> + 'a, NodeType> Handle<NodeRef, handle::KV,\n+                                                                         NodeType> {\n+    // These are fine to include, but are currently unneeded.\n+    //\n+    // /// Returns a reference to the key pointed-to by this handle. This doesn't return a\n+    // /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n+    // /// handle.\n+    // pub fn key(&'a self) -> &'a K {\n+    //     unsafe { self.node.keys().unsafe_get(self.index) }\n+    // }\n+    //\n+    // /// Returns a reference to the value pointed-to by this handle. This doesn't return a\n+    // /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n+    // /// handle.\n+    // pub fn val(&'a self) -> &'a V {\n+    //     unsafe { self.node.vals().unsafe_get(self.index) }\n+    // }\n+}\n \n-        let right = Node::from_vecs(r_keys, r_vals, r_edges);\n-        // Pop it\n-        let key = self.keys.pop().unwrap();\n-        let val = self.vals.pop().unwrap();\n+impl<'a, K: 'a, V: 'a, NodeRef: DerefMut<Node<K, V>> + 'a, NodeType> Handle<NodeRef, handle::KV,\n+                                                                            NodeType> {\n+    /// Returns a mutable reference to the key pointed-to by this handle. This doesn't return a\n+    /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n+    /// handle.\n+    pub fn key_mut(&'a mut self) -> &'a mut K {\n+        unsafe { self.node.keys_mut().unsafe_mut(self.index) }\n+    }\n \n-        (key, val, right)\n+    /// Returns a mutable reference to the value pointed-to by this handle. This doesn't return a\n+    /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n+    /// handle.\n+    pub fn val_mut(&'a mut self) -> &'a mut V {\n+        unsafe { self.node.vals_mut().unsafe_mut(self.index) }\n     }\n+}\n \n-    /// Right is underflowed. Try to steal from left,\n-    /// but merge left and right if left is low too.\n-    unsafe fn handle_underflow_to_left(&mut self, underflowed_child_index: uint) {\n-        let left_len = self.edges[underflowed_child_index - 1].len();\n-        if left_len > min_load_from_capacity(self.capacity()) {\n-            self.steal_to_left(underflowed_child_index);\n-        } else {\n-            self.merge_children(underflowed_child_index - 1);\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, handle::KV, NodeType> {\n+    /// Gets the handle pointing to the edge immediately to the left of the key/value pair pointed\n+    /// to by this handle.\n+    pub fn left_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n+        Handle {\n+            node: &mut *self.node,\n+            index: self.index\n         }\n     }\n \n-    /// Left is underflowed. Try to steal from the right,\n-    /// but merge left and right if right is low too.\n-    unsafe fn handle_underflow_to_right(&mut self, underflowed_child_index: uint) {\n-        let right_len = self.edges[underflowed_child_index + 1].len();\n-        if right_len > min_load_from_capacity(self.capacity()) {\n-            self.steal_to_right(underflowed_child_index);\n-        } else {\n-            self.merge_children(underflowed_child_index);\n+    /// Gets the handle pointing to the edge immediately to the right of the key/value pair pointed\n+    /// to by this handle.\n+    pub fn right_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n+        Handle {\n+            node: &mut *self.node,\n+            index: self.index + 1\n         }\n     }\n+}\n+\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::KV, handle::Leaf> {\n+    /// Removes the key/value pair at the handle's location.\n+    ///\n+    /// # Panics (in debug build)\n+    ///\n+    /// Panics if the node containing the pair is not a leaf node.\n+    pub fn remove_as_leaf(mut self) -> (K, V) {\n+        unsafe { self.node.remove_kv(self.index) }\n+    }\n+}\n \n+impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::KV, handle::Internal> {\n     /// Steal! Stealing is roughly analogous to a binary tree rotation.\n     /// In this case, we're \"rotating\" right.\n-    unsafe fn steal_to_left(&mut self, underflowed_child_index: uint) {\n+    unsafe fn steal_rightward(&mut self) {\n         // Take the biggest stuff off left\n         let (mut key, mut val, edge) = {\n-            let left = self.unsafe_edge_mut(underflowed_child_index - 1);\n-            match (left.keys.pop(), left.vals.pop(), left.edges.pop()) {\n-                (Some(k), Some(v), e) => (k, v, e),\n-                _ => unreachable!(),\n-            }\n+            let mut left_handle = self.left_edge();\n+            let left = left_handle.edge_mut();\n+            let (key, val) = left.pop_kv();\n+            let edge = if left.is_leaf() {\n+                None\n+            } else {\n+                Some(left.pop_edge())\n+            };\n+\n+            (key, val, edge)\n         };\n \n         // Swap the parent's separating key-value pair with left's\n-        self.unsafe_swap(underflowed_child_index - 1, &mut key, &mut val);\n+        mem::swap(&mut key, self.key_mut());\n+        mem::swap(&mut val, self.val_mut());\n \n         // Put them at the start of right\n-        {\n-            let right = self.unsafe_edge_mut(underflowed_child_index);\n-            right.keys.insert(0, key);\n-            right.vals.insert(0, val);\n-            match edge {\n-                None => {}\n-                Some(e) => right.edges.insert(0, e)\n-            }\n+        let mut right_handle = self.right_edge();\n+        let right = right_handle.edge_mut();\n+        right.insert_kv(0, key, val);\n+        match edge {\n+            Some(edge) => right.insert_edge(0, edge),\n+            None => {}\n         }\n     }\n \n     /// Steal! Stealing is roughly analogous to a binary tree rotation.\n     /// In this case, we're \"rotating\" left.\n-    unsafe fn steal_to_right(&mut self, underflowed_child_index: uint) {\n+    unsafe fn steal_leftward(&mut self) {\n         // Take the smallest stuff off right\n         let (mut key, mut val, edge) = {\n-            let right = self.unsafe_edge_mut(underflowed_child_index + 1);\n-            match (right.keys.remove(0), right.vals.remove(0), right.edges.remove(0)) {\n-                (Some(k), Some(v), e) => (k, v, e),\n-                _ => unreachable!(),\n-            }\n+            let mut right_handle = self.right_edge();\n+            let right = right_handle.edge_mut();\n+            let (key, val) = right.remove_kv(0);\n+            let edge = if right.is_leaf() {\n+                None\n+            } else {\n+                Some(right.remove_edge(0))\n+            };\n+\n+            (key, val, edge)\n         };\n \n         // Swap the parent's separating key-value pair with right's\n-        self.unsafe_swap(underflowed_child_index, &mut key, &mut val);\n+        mem::swap(&mut key, self.key_mut());\n+        mem::swap(&mut val, self.val_mut());\n \n         // Put them at the end of left\n-        {\n-            let left = self.unsafe_edge_mut(underflowed_child_index);\n-            left.keys.push(key);\n-            left.vals.push(val);\n-            match edge {\n-                None => {}\n-                Some(e) => left.edges.push(e)\n-            }\n+        let mut left_handle = self.left_edge();\n+        let left = left_handle.edge_mut();\n+        left.push_kv(key, val);\n+        match edge {\n+            Some(edge) => left.push_edge(edge),\n+            None => {}\n         }\n     }\n \n-    /// Merge! Left and right will be smooshed into one node, along with the key-value\n+    /// Merge! Smooshes left and right into one node, along with the key-value\n     /// pair that separated them in their parent.\n-    unsafe fn merge_children(&mut self, left_index: uint) {\n+    unsafe fn merge_children(mut self) {\n         // Permanently remove right's index, and the key-value pair that separates\n         // left and right\n-        let (key, val, right) = {\n-            match (self.keys.remove(left_index),\n-                self.vals.remove(left_index),\n-                self.edges.remove(left_index + 1)) {\n-                (Some(k), Some(v), Some(e)) => (k, v, e),\n-                _ => unreachable!(),\n-            }\n-        };\n+        let (key, val) = self.node.remove_kv(self.index);\n+        let right = self.node.remove_edge(self.index + 1);\n \n         // Give left right's stuff.\n-        let left = self.unsafe_edge_mut(left_index);\n-        left.absorb(key, val, right);\n+        self.left_edge().edge_mut()\n+            .absorb(key, val, right);\n     }\n+}\n \n-    /// Take all the values from right, separated by the given key and value\n-    fn absorb(&mut self, key: K, val: V, right: Node<K, V>) {\n-        // Just as a sanity check, make sure we can fit this guy in\n-        debug_assert!(self.len() + right.len() <= self.capacity())\n+impl<K, V> Node<K, V> {\n+    /// Returns the mutable handle pointing to the key/value pair at a given index.\n+    ///\n+    /// # Panics (in debug build)\n+    ///\n+    /// Panics if the given index is out of bounds.\n+    pub fn kv_handle(&mut self, index: uint) -> Handle<&mut Node<K, V>, handle::KV,\n+                                                       handle::LeafOrInternal> {\n+        // Necessary for correctness, but in a private module\n+        debug_assert!(index < self.len(), \"kv_handle index out of bounds\");\n+        Handle {\n+            node: self,\n+            index: index\n+        }\n+    }\n \n-        self.keys.push(key);\n-        self.vals.push(val);\n-        self.keys.extend(right.keys.into_iter());\n-        self.vals.extend(right.vals.into_iter());\n-        self.edges.extend(right.edges.into_iter());\n+    pub fn iter<'a>(&'a self) -> Traversal<'a, K, V> {\n+        let is_leaf = self.is_leaf();\n+        let (keys, vals, edges) = self.as_slices_internal();\n+        Traversal {\n+            inner: ElemsAndEdges(\n+                keys.iter().zip(vals.iter()),\n+                edges.iter()\n+            ),\n+            head_is_edge: true,\n+            tail_is_edge: true,\n+            has_edges: !is_leaf,\n+        }\n+    }\n+\n+    pub fn iter_mut<'a>(&'a mut self) -> MutTraversal<'a, K, V> {\n+        let is_leaf = self.is_leaf();\n+        let (keys, vals, edges) = self.as_slices_internal_mut();\n+        MutTraversal {\n+            inner: ElemsAndEdges(\n+                keys.iter().zip(vals.iter_mut()),\n+                edges.iter_mut()\n+            ),\n+            head_is_edge: true,\n+            tail_is_edge: true,\n+            has_edges: !is_leaf,\n+        }\n+    }\n+\n+    pub fn into_iter(self) -> MoveTraversal<K, V> {\n+        unsafe {\n+            let ret = MoveTraversal {\n+                inner: MoveTraversalImpl {\n+                    keys: RawItems::from_slice(self.keys()),\n+                    vals: RawItems::from_slice(self.vals()),\n+                    edges: RawItems::from_slice(self.edges()),\n+\n+                    ptr: self.keys as *mut u8,\n+                    capacity: self.capacity(),\n+                    is_leaf: self.is_leaf()\n+                },\n+                head_is_edge: true,\n+                tail_is_edge: true,\n+                has_edges: !self.is_leaf(),\n+            };\n+            mem::forget(self);\n+            ret\n+        }\n+    }\n+\n+    /// When a node has no keys or values and only a single edge, extract that edge.\n+    pub fn hoist_lone_child(&mut self) {\n+        // Necessary for correctness, but in a private module\n+        debug_assert!(self.len() == 0);\n+        debug_assert!(!self.is_leaf());\n+\n+        unsafe {\n+            let ret = ptr::read(self.edges().unsafe_get(0));\n+            self.destroy();\n+            ptr::write(self, ret);\n+        }\n     }\n }\n \n-/// Takes a Vec, and splits half the elements into a new one.\n-fn split<T>(left: &mut Vec<T>) -> Vec<T> {\n-    // This function is intended to be called on a full Vec of size 2B - 1 (keys, values),\n-    // or 2B (edges). In the former case, left should get B elements, and right should get\n-    // B - 1. In the latter case, both should get B. Therefore, we can just always take the last\n-    // size / 2 elements from left, and put them on right. This also ensures this method is\n-    // safe, even if the Vec isn't full. Just uninteresting for our purposes.\n-    let len = left.len();\n-    let right_len = len / 2;\n-    let left_len = len - right_len;\n-    let mut right = Vec::with_capacity(left.capacity());\n-    unsafe {\n-        let left_ptr = left.as_slice().unsafe_get(left_len) as *const _;\n-        let right_ptr = right.as_mut_slice().as_mut_ptr();\n-        ptr::copy_nonoverlapping_memory(right_ptr, left_ptr, right_len);\n-        left.set_len(left_len);\n-        right.set_len(right_len);\n+// Vector functions (all unchecked)\n+impl<K, V> Node<K, V> {\n+    // This must be followed by push_edge on an internal node.\n+    #[inline]\n+    unsafe fn push_kv(&mut self, key: K, val: V) {\n+        let len = self.len();\n+\n+        ptr::write(self.keys_mut().unsafe_mut(len), key);\n+        ptr::write(self.vals_mut().unsafe_mut(len), val);\n+\n+        self._len += 1;\n+    }\n+\n+    // This can only be called immediately after a call to push_kv.\n+    #[inline]\n+    unsafe fn push_edge(&mut self, edge: Node<K, V>) {\n+        let len = self.len();\n+\n+        ptr::write(self.edges_mut().unsafe_mut(len), edge);\n+    }\n+\n+    // This must be followed by insert_edge on an internal node.\n+    #[inline]\n+    unsafe fn insert_kv(&mut self, index: uint, key: K, val: V) -> &mut V {\n+        ptr::copy_memory(\n+            self.keys_mut().as_mut_ptr().offset(index as int + 1),\n+            self.keys().as_ptr().offset(index as int),\n+            self.len() - index\n+        );\n+        ptr::copy_memory(\n+            self.vals_mut().as_mut_ptr().offset(index as int + 1),\n+            self.vals().as_ptr().offset(index as int),\n+            self.len() - index\n+        );\n+\n+        ptr::write(self.keys_mut().unsafe_mut(index), key);\n+        ptr::write(self.vals_mut().unsafe_mut(index), val);\n+\n+        self._len += 1;\n+\n+        self.vals_mut().unsafe_mut(index)\n+    }\n+\n+    // This can only be called immediately after a call to insert_kv.\n+    #[inline]\n+    unsafe fn insert_edge(&mut self, index: uint, edge: Node<K, V>) {\n+        ptr::copy_memory(\n+            self.edges_mut().as_mut_ptr().offset(index as int + 1),\n+            self.edges().as_ptr().offset(index as int),\n+            self.len() - index\n+        );\n+        ptr::write(self.edges_mut().unsafe_mut(index), edge);\n+    }\n+\n+    // This must be followed by pop_edge on an internal node.\n+    #[inline]\n+    unsafe fn pop_kv(&mut self) -> (K, V) {\n+        let key = ptr::read(self.keys().unsafe_get(self.len() - 1));\n+        let val = ptr::read(self.vals().unsafe_get(self.len() - 1));\n+\n+        self._len -= 1;\n+\n+        (key, val)\n+    }\n+\n+    // This can only be called immediately after a call to pop_kv.\n+    #[inline]\n+    unsafe fn pop_edge(&mut self) -> Node<K, V> {\n+        let edge = ptr::read(self.edges().unsafe_get(self.len() + 1));\n+\n+        edge\n+    }\n+\n+    // This must be followed by remove_edge on an internal node.\n+    #[inline]\n+    unsafe fn remove_kv(&mut self, index: uint) -> (K, V) {\n+        let key = ptr::read(self.keys().unsafe_get(index));\n+        let val = ptr::read(self.vals().unsafe_get(index));\n+\n+        ptr::copy_memory(\n+            self.keys_mut().as_mut_ptr().offset(index as int),\n+            self.keys().as_ptr().offset(index as int + 1),\n+            self.len() - index - 1\n+        );\n+        ptr::copy_memory(\n+            self.vals_mut().as_mut_ptr().offset(index as int),\n+            self.vals().as_ptr().offset(index as int + 1),\n+            self.len() - index - 1\n+        );\n+\n+        self._len -= 1;\n+\n+        (key, val)\n+    }\n+\n+    // This can only be called immediately after a call to remove_kv.\n+    #[inline]\n+    unsafe fn remove_edge(&mut self, index: uint) -> Node<K, V> {\n+        let edge = ptr::read(self.edges().unsafe_get(index));\n+\n+        ptr::copy_memory(\n+            self.edges_mut().as_mut_ptr().offset(index as int),\n+            self.edges().as_ptr().offset(index as int + 1),\n+            self.len() - index + 1\n+        );\n+\n+        edge\n+    }\n+}\n+\n+// Private implementation details\n+impl<K, V> Node<K, V> {\n+    /// Node is full, so split it into two nodes, and yield the middle-most key-value pair\n+    /// because we have one too many, and our parent now has one too few\n+    fn split(&mut self) -> (K, V, Node<K, V>) {\n+        // Necessary for correctness, but in a private funtion\n+        debug_assert!(self.len() > 0);\n+\n+        let mut right = if self.is_leaf() {\n+            Node::new_leaf(self.capacity())\n+        } else {\n+            unsafe { Node::new_internal(self.capacity()) }\n+        };\n+\n+        unsafe {\n+            right._len = self.len() / 2;\n+            let right_offset = self.len() - right.len();\n+            ptr::copy_nonoverlapping_memory(\n+                right.keys_mut().as_mut_ptr(),\n+                self.keys().as_ptr().offset(right_offset as int),\n+                right.len()\n+            );\n+            ptr::copy_nonoverlapping_memory(\n+                right.vals_mut().as_mut_ptr(),\n+                self.vals().as_ptr().offset(right_offset as int),\n+                right.len()\n+            );\n+            if !self.is_leaf() {\n+                ptr::copy_nonoverlapping_memory(\n+                    right.edges_mut().as_mut_ptr(),\n+                    self.edges().as_ptr().offset(right_offset as int),\n+                    right.len() + 1\n+                );\n+            }\n+\n+            let key = ptr::read(self.keys().unsafe_get(right_offset - 1));\n+            let val = ptr::read(self.vals().unsafe_get(right_offset - 1));\n+\n+            self._len = right_offset - 1;\n+\n+            (key, val, right)\n+        }\n+    }\n+\n+    /// Take all the values from right, seperated by the given key and value\n+    fn absorb(&mut self, key: K, val: V, mut right: Node<K, V>) {\n+        // Necessary for correctness, but in a private function\n+        // Just as a sanity check, make sure we can fit this guy in\n+        debug_assert!(self.len() + right.len() <= self.capacity());\n+        debug_assert!(self.is_leaf() == right.is_leaf());\n+\n+        unsafe {\n+            let old_len = self.len();\n+            self._len += right.len() + 1;\n+\n+            ptr::write(self.keys_mut().unsafe_mut(old_len), key);\n+            ptr::write(self.vals_mut().unsafe_mut(old_len), val);\n+\n+            ptr::copy_nonoverlapping_memory(\n+                self.keys_mut().as_mut_ptr().offset(old_len as int + 1),\n+                right.keys().as_ptr(),\n+                right.len()\n+            );\n+            ptr::copy_nonoverlapping_memory(\n+                self.vals_mut().as_mut_ptr().offset(old_len as int + 1),\n+                right.vals().as_ptr(),\n+                right.len()\n+            );\n+            if !self.is_leaf() {\n+                ptr::copy_nonoverlapping_memory(\n+                    self.edges_mut().as_mut_ptr().offset(old_len as int + 1),\n+                    right.edges().as_ptr(),\n+                    right.len() + 1\n+                );\n+            }\n+\n+            right.destroy();\n+            mem::forget(right);\n+        }\n     }\n-    right\n }\n \n /// Get the capacity of a node from the order of the parent B-Tree\n@@ -497,10 +1287,89 @@ fn min_load_from_capacity(cap: uint) -> uint {\n     cap / 2\n }\n \n+/// A trait for pairs of `Iterator`s, one over edges and the other over key/value pairs. This is\n+/// necessary, as the `MoveTraversalImpl` needs to have a destructor that deallocates the `Node`,\n+/// and a pair of `Iterator`s would require two independent destructors.\n+trait TraversalImpl<K, V, E> {\n+    fn next_kv(&mut self) -> Option<(K, V)>;\n+    fn next_kv_back(&mut self) -> Option<(K, V)>;\n+\n+    fn next_edge(&mut self) -> Option<E>;\n+    fn next_edge_back(&mut self) -> Option<E>;\n+}\n+\n+/// A `TraversalImpl` that actually is backed by two iterators. This works in the non-moving case,\n+/// as no deallocation needs to be done.\n+struct ElemsAndEdges<Elems, Edges>(Elems, Edges);\n+\n+impl<K, V, E, Elems: DoubleEndedIterator<(K, V)>, Edges: DoubleEndedIterator<E>>\n+        TraversalImpl<K, V, E> for ElemsAndEdges<Elems, Edges> {\n+\n+    fn next_kv(&mut self) -> Option<(K, V)> { self.0.next() }\n+    fn next_kv_back(&mut self) -> Option<(K, V)> { self.0.next_back() }\n+\n+    fn next_edge(&mut self) -> Option<E> { self.1.next() }\n+    fn next_edge_back(&mut self) -> Option<E> { self.1.next_back() }\n+}\n+\n+/// A `TraversalImpl` taking a `Node` by value.\n+struct MoveTraversalImpl<K, V> {\n+    keys: RawItems<K>,\n+    vals: RawItems<V>,\n+    edges: RawItems<Node<K, V>>,\n+\n+    // For deallocation when we are done iterating.\n+    ptr: *mut u8,\n+    capacity: uint,\n+    is_leaf: bool\n+}\n+\n+impl<K, V> TraversalImpl<K, V, Node<K, V>> for MoveTraversalImpl<K, V> {\n+    fn next_kv(&mut self) -> Option<(K, V)> {\n+        match (self.keys.next(), self.vals.next()) {\n+            (Some(k), Some(v)) => Some((k, v)),\n+            _ => None\n+        }\n+    }\n+\n+    fn next_kv_back(&mut self) -> Option<(K, V)> {\n+        match (self.keys.next_back(), self.vals.next_back()) {\n+            (Some(k), Some(v)) => Some((k, v)),\n+            _ => None\n+        }\n+    }\n+\n+    fn next_edge(&mut self) -> Option<Node<K, V>> {\n+        // Necessary for correctness, but in a private module\n+        debug_assert!(!self.is_leaf);\n+        self.edges.next()\n+    }\n+\n+    fn next_edge_back(&mut self) -> Option<Node<K, V>> {\n+        // Necessary for correctness, but in a private module\n+        debug_assert!(!self.is_leaf);\n+        self.edges.next_back()\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<K, V> Drop for MoveTraversalImpl<K, V> {\n+    fn drop(&mut self) {\n+        // We need to cleanup the stored values manually, as the RawItems destructor would run\n+        // after our deallocation.\n+        for _ in self.keys {}\n+        for _ in self.vals {}\n+        for _ in self.edges {}\n+\n+        let (alignment, size) =\n+                calculate_allocation_generic::<K, V>(self.capacity, self.is_leaf);\n+        unsafe { heap::deallocate(self.ptr, size, alignment) };\n+    }\n+}\n+\n /// An abstraction over all the different kinds of traversals a node supports\n-struct AbsTraversal<Elems, Edges> {\n-    elems: Elems,\n-    edges: Edges,\n+struct AbsTraversal<Impl> {\n+    inner: Impl,\n     head_is_edge: bool,\n     tail_is_edge: bool,\n     has_edges: bool,\n@@ -513,44 +1382,45 @@ pub enum TraversalItem<K, V, E> {\n }\n \n /// A traversal over a node's entries and edges\n-pub type Traversal<'a, K, V> = AbsTraversal<Zip<slice::Items<'a, K>, slice::Items<'a, V>>,\n-                                            slice::Items<'a, Node<K, V>>>;\n+pub type Traversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Iter<'a, K>,\n+                                                              slice::Iter<'a, V>>,\n+                                                              slice::Iter<'a, Node<K, V>>>>;\n \n /// A mutable traversal over a node's entries and edges\n-pub type MutTraversal<'a, K, V> = AbsTraversal<Zip<slice::Items<'a, K>, slice::MutItems<'a, V>>,\n-                                               slice::MutItems<'a, Node<K, V>>>;\n+pub type MutTraversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Iter<'a, K>,\n+                                                                 slice::IterMut<'a, V>>,\n+                                                                 slice::IterMut<'a, Node<K, V>>>>;\n \n /// An owning traversal over a node's entries and edges\n-pub type MoveTraversal<K, V> = AbsTraversal<Zip<vec::MoveItems<K>, vec::MoveItems<V>>,\n-                                                vec::MoveItems<Node<K, V>>>;\n+pub type MoveTraversal<K, V> = AbsTraversal<MoveTraversalImpl<K, V>>;\n \n \n-impl<K, V, E, Elems: Iterator<(K, V)>, Edges: Iterator<E>>\n-        Iterator<TraversalItem<K, V, E>> for AbsTraversal<Elems, Edges> {\n+impl<K, V, E, Impl: TraversalImpl<K, V, E>>\n+        Iterator<TraversalItem<K, V, E>> for AbsTraversal<Impl> {\n \n     fn next(&mut self) -> Option<TraversalItem<K, V, E>> {\n         let head_is_edge = self.head_is_edge;\n         self.head_is_edge = !head_is_edge;\n \n         if head_is_edge && self.has_edges {\n-            self.edges.next().map(|node| Edge(node))\n+            self.inner.next_edge().map(|node| Edge(node))\n         } else {\n-            self.elems.next().map(|(k, v)| Elem(k, v))\n+            self.inner.next_kv().map(|(k, v)| Elem(k, v))\n         }\n     }\n }\n \n-impl<K, V, E, Elems: DoubleEndedIterator<(K, V)>, Edges: DoubleEndedIterator<E>>\n-        DoubleEndedIterator<TraversalItem<K, V, E>> for AbsTraversal<Elems, Edges> {\n+impl<K, V, E, Impl: TraversalImpl<K, V, E>>\n+        DoubleEndedIterator<TraversalItem<K, V, E>> for AbsTraversal<Impl> {\n \n     fn next_back(&mut self) -> Option<TraversalItem<K, V, E>> {\n         let tail_is_edge = self.tail_is_edge;\n         self.tail_is_edge = !tail_is_edge;\n \n         if tail_is_edge && self.has_edges {\n-            self.edges.next_back().map(|node| Edge(node))\n+            self.inner.next_edge_back().map(|node| Edge(node))\n         } else {\n-            self.elems.next_back().map(|(k, v)| Elem(k, v))\n+            self.inner.next_kv_back().map(|(k, v)| Elem(k, v))\n         }\n     }\n }"}, {"sha": "2935692ed1580d9537b1cb5d0f0a900e6b4bdf5a", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 275, "deletions": 55, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -13,16 +13,15 @@\n \n use core::prelude::*;\n \n-use btree_map::{BTreeMap, Keys, MoveEntries};\n+use btree_map::{BTreeMap, Keys};\n use std::hash::Hash;\n use core::borrow::BorrowFrom;\n use core::default::Default;\n-use core::{iter, fmt};\n-use core::iter::Peekable;\n+use core::fmt;\n+use core::iter::{Peekable, Map};\n use core::fmt::Show;\n \n // FIXME(conventions): implement bounded iterators\n-// FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n \n /// A set based on a B-Tree.\n ///\n@@ -34,37 +33,49 @@ pub struct BTreeSet<T>{\n }\n \n /// An iterator over a BTreeSet's items.\n-pub type Items<'a, T> = Keys<'a, T, ()>;\n+pub struct Iter<'a, T: 'a> {\n+    iter: Keys<'a, T, ()>\n+}\n \n /// An owning iterator over a BTreeSet's items.\n-pub type MoveItems<T> = iter::Map<'static, (T, ()), T, MoveEntries<T, ()>>;\n+pub struct IntoIter<T> {\n+    iter: Map<(T, ()), T, ::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n+}\n \n /// A lazy iterator producing elements in the set difference (in-order).\n-pub struct DifferenceItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+pub struct Difference<'a, T:'a> {\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n-pub struct SymDifferenceItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+pub struct SymmetricDifference<'a, T:'a> {\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n-pub struct IntersectionItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+pub struct Intersection<'a, T:'a> {\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n-pub struct UnionItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+pub struct Union<'a, T:'a> {\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n impl<T: Ord> BTreeSet<T> {\n     /// Makes a new BTreeSet with a reasonable choice of B.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set: BTreeSet<int> = BTreeSet::new();\n+    /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::new() }\n@@ -80,48 +91,143 @@ impl<T: Ord> BTreeSet<T> {\n \n impl<T> BTreeSet<T> {\n     /// Gets an iterator over the BTreeSet's contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let set: BTreeSet<uint> = [1u, 2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// for x in set.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let v: Vec<uint> = set.iter().map(|&x| x).collect();\n+    /// assert_eq!(v, vec![1u,2,3,4]);\n+    /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n-        self.map.keys()\n+    pub fn iter<'a>(&'a self) -> Iter<'a, T> {\n+        Iter { iter: self.map.keys() }\n     }\n \n     /// Gets an iterator for moving out the BtreeSet's contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let set: BTreeSet<uint> = [1u, 2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// let v: Vec<uint> = set.into_iter().collect();\n+    /// assert_eq!(v, vec![1u,2,3,4]);\n+    /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n-        self.map.into_iter().map(|(k, _)| k)\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((T, ())) -> T = first; // coerce to fn pointer\n+\n+        IntoIter { iter: self.map.into_iter().map(first) }\n     }\n }\n \n impl<T: Ord> BTreeSet<T> {\n     /// Visits the values representing the difference, in ascending order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut a = BTreeSet::new();\n+    /// a.insert(1u);\n+    /// a.insert(2u);\n+    ///\n+    /// let mut b = BTreeSet::new();\n+    /// b.insert(2u);\n+    /// b.insert(3u);\n+    ///\n+    /// let diff: Vec<uint> = a.difference(&b).cloned().collect();\n+    /// assert_eq!(diff, vec![1u]);\n+    /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> DifferenceItems<'a, T> {\n-        DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n+        Difference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the symmetric difference, in ascending order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut a = BTreeSet::new();\n+    /// a.insert(1u);\n+    /// a.insert(2u);\n+    ///\n+    /// let mut b = BTreeSet::new();\n+    /// b.insert(2u);\n+    /// b.insert(3u);\n+    ///\n+    /// let sym_diff: Vec<uint> = a.symmetric_difference(&b).cloned().collect();\n+    /// assert_eq!(sym_diff, vec![1u,3]);\n+    /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n-        -> SymDifferenceItems<'a, T> {\n-        SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+        -> SymmetricDifference<'a, T> {\n+        SymmetricDifference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the intersection, in ascending order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut a = BTreeSet::new();\n+    /// a.insert(1u);\n+    /// a.insert(2u);\n+    ///\n+    /// let mut b = BTreeSet::new();\n+    /// b.insert(2u);\n+    /// b.insert(3u);\n+    ///\n+    /// let intersection: Vec<uint> = a.intersection(&b).cloned().collect();\n+    /// assert_eq!(intersection, vec![2u]);\n+    /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n-        -> IntersectionItems<'a, T> {\n-        IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+        -> Intersection<'a, T> {\n+        Intersection{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the union, in ascending order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut a = BTreeSet::new();\n+    /// a.insert(1u);\n+    ///\n+    /// let mut b = BTreeSet::new();\n+    /// b.insert(2u);\n+    ///\n+    /// let union: Vec<uint> = a.union(&b).cloned().collect();\n+    /// assert_eq!(union, vec![1u,2]);\n+    /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> UnionItems<'a, T> {\n-        UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n+        Union{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Return the number of elements in the set\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeSet;\n@@ -136,7 +242,7 @@ impl<T: Ord> BTreeSet<T> {\n \n     /// Returns true if the set contains no elements\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeSet;\n@@ -151,7 +257,7 @@ impl<T: Ord> BTreeSet<T> {\n \n     /// Clears the set, removing all values.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeSet;\n@@ -172,7 +278,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// but the ordering on the borrowed form *must* match the\n     /// ordering on the value type.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeSet;\n@@ -189,7 +295,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeSet;\n@@ -210,7 +316,7 @@ impl<T: Ord> BTreeSet<T> {\n \n     /// Returns `true` if the set is a subset of another.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeSet;\n@@ -252,7 +358,7 @@ impl<T: Ord> BTreeSet<T> {\n \n     /// Returns `true` if the set is a superset of another.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeSet;\n@@ -277,7 +383,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// Adds a value to the set. Returns `true` if the value was not already\n     /// present in the set.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeSet;\n@@ -300,7 +406,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// but the ordering on the borrowed form *must* match the\n     /// ordering on the value type.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeSet;\n@@ -334,12 +440,98 @@ impl<T: Ord> Extend<T> for BTreeSet<T> {\n     }\n }\n \n+#[stable]\n impl<T: Ord> Default for BTreeSet<T> {\n+    #[stable]\n     fn default() -> BTreeSet<T> {\n         BTreeSet::new()\n     }\n }\n \n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n+    /// Returns the difference of `self` and `rhs` as a new `BTreeSet<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let a: BTreeSet<int> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: BTreeSet<int> = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let result: BTreeSet<int> = &a - &b;\n+    /// let result_vec: Vec<int> = result.into_iter().collect();\n+    /// assert_eq!(result_vec, vec![1, 2]);\n+    /// ```\n+    fn sub(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n+        self.difference(rhs).cloned().collect()\n+    }\n+}\n+\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n+    /// Returns the symmetric difference of `self` and `rhs` as a new `BTreeSet<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let a: BTreeSet<int> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: BTreeSet<int> = vec![2, 3, 4].into_iter().collect();\n+    ///\n+    /// let result: BTreeSet<int> = &a ^ &b;\n+    /// let result_vec: Vec<int> = result.into_iter().collect();\n+    /// assert_eq!(result_vec, vec![1, 4]);\n+    /// ```\n+    fn bitxor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n+        self.symmetric_difference(rhs).cloned().collect()\n+    }\n+}\n+\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n+    /// Returns the intersection of `self` and `rhs` as a new `BTreeSet<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let a: BTreeSet<int> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: BTreeSet<int> = vec![2, 3, 4].into_iter().collect();\n+    ///\n+    /// let result: BTreeSet<int> = &a & &b;\n+    /// let result_vec: Vec<int> = result.into_iter().collect();\n+    /// assert_eq!(result_vec, vec![2, 3]);\n+    /// ```\n+    fn bitand(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n+        self.intersection(rhs).cloned().collect()\n+    }\n+}\n+\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n+    /// Returns the union of `self` and `rhs` as a new `BTreeSet<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let a: BTreeSet<int> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: BTreeSet<int> = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let result: BTreeSet<int> = &a | &b;\n+    /// let result_vec: Vec<int> = result.into_iter().collect();\n+    /// assert_eq!(result_vec, vec![1, 2, 3, 4, 5]);\n+    /// ```\n+    fn bitor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n+        self.union(rhs).cloned().collect()\n+    }\n+}\n+\n impl<T: Show> Show for BTreeSet<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{{\"));\n@@ -353,6 +545,25 @@ impl<T: Show> Show for BTreeSet<T> {\n     }\n }\n \n+impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n+    fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n+}\n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n+\n+\n+impl<T> Iterator<T> for IntoIter<T> {\n+    fn next(&mut self) -> Option<T> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n+    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+}\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n+\n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n                         short: Ordering, long: Ordering) -> Ordering {\n@@ -363,7 +574,7 @@ fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for DifferenceItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for Difference<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n@@ -375,7 +586,7 @@ impl<'a, T: Ord> Iterator<&'a T> for DifferenceItems<'a, T> {\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for SymmetricDifference<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n@@ -387,7 +598,7 @@ impl<'a, T: Ord> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for IntersectionItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for Intersection<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             let o_cmp = match (self.a.peek(), self.b.peek()) {\n@@ -405,7 +616,7 @@ impl<'a, T: Ord> Iterator<&'a T> for IntersectionItems<'a, T> {\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for UnionItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for Union<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n@@ -420,7 +631,7 @@ impl<'a, T: Ord> Iterator<&'a T> for UnionItems<'a, T> {\n \n #[cfg(test)]\n mod test {\n-    use std::prelude::*;\n+    use prelude::*;\n \n     use super::BTreeSet;\n     use std::hash;\n@@ -451,22 +662,31 @@ mod test {\n       assert!(hash::hash(&x) == hash::hash(&y));\n     }\n \n-    fn check(a: &[int],\n-             b: &[int],\n-             expected: &[int],\n-             f: |&BTreeSet<int>, &BTreeSet<int>, f: |&int| -> bool| -> bool) {\n+    struct Counter<'a, 'b> {\n+        i: &'a mut uint,\n+        expected: &'b [int],\n+    }\n+\n+    impl<'a, 'b, 'c> FnMut(&'c int) -> bool for Counter<'a, 'b> {\n+        extern \"rust-call\" fn call_mut(&mut self, (&x,): (&'c int,)) -> bool {\n+            assert_eq!(x, self.expected[*self.i]);\n+            *self.i += 1;\n+            true\n+        }\n+    }\n+\n+    fn check<F>(a: &[int], b: &[int], expected: &[int], f: F) where\n+        // FIXME Replace Counter with `Box<FnMut(_) -> _>`\n+        F: FnOnce(&BTreeSet<int>, &BTreeSet<int>, Counter) -> bool,\n+    {\n         let mut set_a = BTreeSet::new();\n         let mut set_b = BTreeSet::new();\n \n         for x in a.iter() { assert!(set_a.insert(*x)) }\n         for y in b.iter() { assert!(set_b.insert(*y)) }\n \n         let mut i = 0;\n-        f(&set_a, &set_b, |x| {\n-            assert_eq!(*x, expected[i]);\n-            i += 1;\n-            true\n-        });\n+        f(&set_a, &set_b, Counter { i: &mut i, expected: expected });\n         assert_eq!(i, expected.len());\n     }\n \n@@ -580,7 +800,7 @@ mod test {\n \n         let set_str = format!(\"{}\", set);\n \n-        assert!(set_str == \"{1, 2}\".to_string());\n-        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n+        assert!(set_str == \"{1, 2}\");\n+        assert_eq!(format!(\"{}\", empty), \"{}\");\n     }\n }"}, {"sha": "de2a7307440120f4d9f84a6daa51120628a3ad49", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 65, "deletions": 59, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -10,10 +10,8 @@\n \n //! A doubly-linked list with owned nodes.\n //!\n-//! The `DList` allows pushing and popping elements at either end.\n-//!\n-//! `DList` implements the trait `Deque`. It should be imported with\n-//! `use collections::Deque`.\n+//! The `DList` allows pushing and popping elements at either end and is thus\n+//! efficiently usable as a double-ended queue.\n \n // DList is constructed like a singly-linked list over the field `next`.\n // including the last link being None; each Node owns its `next` field.\n@@ -39,7 +37,12 @@ pub struct DList<T> {\n }\n \n type Link<T> = Option<Box<Node<T>>>;\n-struct Rawlink<T> { p: *mut T }\n+\n+struct Rawlink<T> {\n+    p: *mut T,\n+}\n+\n+impl<T> Copy for Rawlink<T> {}\n \n struct Node<T> {\n     next: Link<T>,\n@@ -48,19 +51,21 @@ struct Node<T> {\n }\n \n /// An iterator over references to the items of a `DList`.\n-pub struct Items<'a, T:'a> {\n+pub struct Iter<'a, T:'a> {\n     head: &'a Link<T>,\n     tail: Rawlink<Node<T>>,\n     nelem: uint,\n }\n \n // FIXME #11820: the &'a Option<> of the Link stops clone working.\n-impl<'a, T> Clone for Items<'a, T> {\n-    fn clone(&self) -> Items<'a, T> { *self }\n+impl<'a, T> Clone for Iter<'a, T> {\n+    fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n+impl<'a,T> Copy for Iter<'a,T> {}\n+\n /// An iterator over mutable references to the items of a `DList`.\n-pub struct MutItems<'a, T:'a> {\n+pub struct IterMut<'a, T:'a> {\n     list: &'a mut DList<T>,\n     head: Rawlink<Node<T>>,\n     tail: Rawlink<Node<T>>,\n@@ -69,7 +74,7 @@ pub struct MutItems<'a, T:'a> {\n \n /// An iterator over mutable references to the items of a `DList`.\n #[deriving(Clone)]\n-pub struct MoveItems<T> {\n+pub struct IntoIter<T> {\n     list: DList<T>\n }\n \n@@ -187,8 +192,10 @@ impl<T> DList<T> {\n     }\n }\n \n+#[stable]\n impl<T> Default for DList<T> {\n     #[inline]\n+    #[stable]\n     fn default() -> DList<T> { DList::new() }\n }\n \n@@ -204,7 +211,7 @@ impl<T> DList<T> {\n     ///\n     /// If the list is empty, does nothing.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::collections::DList;\n@@ -231,7 +238,7 @@ impl<T> DList<T> {\n     ///\n     /// If the list is empty, does nothing.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::collections::DList;\n@@ -258,7 +265,7 @@ impl<T> DList<T> {\n     ///\n     /// This operation should compute in O(1) time.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::collections::DList;\n@@ -299,7 +306,7 @@ impl<T> DList<T> {\n     ///\n     /// This operation should compute in O(1) time.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::collections::DList;\n@@ -328,7 +335,7 @@ impl<T> DList<T> {\n     ///\n     /// This operation should compute in O(N) time.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::collections::DList;\n@@ -346,18 +353,16 @@ impl<T> DList<T> {\n     ///     println!(\"{}\", e); // prints 2, then 4, then 11, then 7, then 8\n     /// }\n     /// ```\n-    pub fn insert_when(&mut self, elt: T, f: |&T, &T| -> bool) {\n-        {\n-            let mut it = self.iter_mut();\n-            loop {\n-                match it.peek_next() {\n-                    None => break,\n-                    Some(x) => if f(x, &elt) { break }\n-                }\n-                it.next();\n+    pub fn insert_when<F>(&mut self, elt: T, mut f: F) where F: FnMut(&T, &T) -> bool {\n+        let mut it = self.iter_mut();\n+        loop {\n+            match it.peek_next() {\n+                None => break,\n+                Some(x) => if f(x, &elt) { break }\n             }\n-            it.insert_next(elt);\n+            it.next();\n         }\n+        it.insert_next(elt);\n     }\n \n     /// Merges `other` into this `DList`, using the function `f`.\n@@ -366,7 +371,7 @@ impl<T> DList<T> {\n     /// put `a` in the result if `f(a, b)` is true, and otherwise `b`.\n     ///\n     /// This operation should compute in O(max(N, M)) time.\n-    pub fn merge(&mut self, mut other: DList<T>, f: |&T, &T| -> bool) {\n+    pub fn merge<F>(&mut self, mut other: DList<T>, mut f: F) where F: FnMut(&T, &T) -> bool {\n         {\n             let mut it = self.iter_mut();\n             loop {\n@@ -389,19 +394,19 @@ impl<T> DList<T> {\n     /// Provides a forward iterator.\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n-        Items{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n+    pub fn iter<'a>(&'a self) -> Iter<'a, T> {\n+        Iter{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n     /// Provides a forward iterator with mutable references.\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n+    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         let head_raw = match self.list_head {\n             Some(ref mut h) => Rawlink::some(&mut **h),\n             None => Rawlink::none(),\n         };\n-        MutItems{\n+        IterMut{\n             nelem: self.len(),\n             head: head_raw,\n             tail: self.list_tail,\n@@ -412,8 +417,8 @@ impl<T> DList<T> {\n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n-        MoveItems{list: self}\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        IntoIter{list: self}\n     }\n \n     /// Returns `true` if the `DList` is empty.\n@@ -446,31 +451,31 @@ impl<T> DList<T> {\n     /// Provides a reference to the front element, or `None` if the list is\n     /// empty.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn front(&self) -> Option<&T> {\n         self.list_head.as_ref().map(|head| &head.value)\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the list\n     /// is empty.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         self.list_head.as_mut().map(|head| &mut head.value)\n     }\n \n     /// Provides a reference to the back element, or `None` if the list is\n     /// empty.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn back(&self) -> Option<&T> {\n         self.list_tail.resolve_immut().as_ref().map(|tail| &tail.value)\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n     /// is empty.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         self.list_tail.resolve().map(|tail| &mut tail.value)\n     }\n@@ -500,7 +505,7 @@ impl<T> DList<T> {\n \n     /// Appends an element to the back of a list\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::collections::DList;\n@@ -524,7 +529,7 @@ impl<T> DList<T> {\n     /// Removes the last element from a list and returns it, or `None` if\n     /// it is empty.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::collections::DList;\n@@ -574,7 +579,7 @@ impl<T> Drop for DList<T> {\n }\n \n \n-impl<'a, A> Iterator<&'a A> for Items<'a, A> {\n+impl<'a, A> Iterator<&'a A> for Iter<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a A> {\n         if self.nelem == 0 {\n@@ -593,7 +598,7 @@ impl<'a, A> Iterator<&'a A> for Items<'a, A> {\n     }\n }\n \n-impl<'a, A> DoubleEndedIterator<&'a A> for Items<'a, A> {\n+impl<'a, A> DoubleEndedIterator<&'a A> for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> {\n         if self.nelem == 0 {\n@@ -607,9 +612,9 @@ impl<'a, A> DoubleEndedIterator<&'a A> for Items<'a, A> {\n     }\n }\n \n-impl<'a, A> ExactSize<&'a A> for Items<'a, A> {}\n+impl<'a, A> ExactSizeIterator<&'a A> for Iter<'a, A> {}\n \n-impl<'a, A> Iterator<&'a mut A> for MutItems<'a, A> {\n+impl<'a, A> Iterator<&'a mut A> for IterMut<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut A> {\n         if self.nelem == 0 {\n@@ -631,7 +636,7 @@ impl<'a, A> Iterator<&'a mut A> for MutItems<'a, A> {\n     }\n }\n \n-impl<'a, A> DoubleEndedIterator<&'a mut A> for MutItems<'a, A> {\n+impl<'a, A> DoubleEndedIterator<&'a mut A> for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> {\n         if self.nelem == 0 {\n@@ -645,7 +650,7 @@ impl<'a, A> DoubleEndedIterator<&'a mut A> for MutItems<'a, A> {\n     }\n }\n \n-impl<'a, A> ExactSize<&'a mut A> for MutItems<'a, A> {}\n+impl<'a, A> ExactSizeIterator<&'a mut A> for IterMut<'a, A> {}\n \n /// Allows mutating a `DList` while iterating.\n pub trait ListInsertion<A> {\n@@ -659,8 +664,8 @@ pub trait ListInsertion<A> {\n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A>;\n }\n \n-// private methods for MutItems\n-impl<'a, A> MutItems<'a, A> {\n+// private methods for IterMut\n+impl<'a, A> IterMut<'a, A> {\n     fn insert_next_node(&mut self, mut ins_node: Box<Node<A>>) {\n         // Insert before `self.head` so that it is between the\n         // previously yielded element and self.head.\n@@ -682,22 +687,22 @@ impl<'a, A> MutItems<'a, A> {\n     }\n }\n \n-impl<'a, A> ListInsertion<A> for MutItems<'a, A> {\n+impl<'a, A> ListInsertion<A> for IterMut<'a, A> {\n     #[inline]\n     fn insert_next(&mut self, elt: A) {\n         self.insert_next_node(box Node::new(elt))\n     }\n \n     #[inline]\n-    fn peek_next<'a>(&'a mut self) -> Option<&'a mut A> {\n+    fn peek_next(&mut self) -> Option<&mut A> {\n         if self.nelem == 0 {\n             return None\n         }\n         self.head.resolve().map(|head| &mut head.value)\n     }\n }\n \n-impl<A> Iterator<A> for MoveItems<A> {\n+impl<A> Iterator<A> for IntoIter<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.list.pop_front() }\n \n@@ -707,7 +712,7 @@ impl<A> Iterator<A> for MoveItems<A> {\n     }\n }\n \n-impl<A> DoubleEndedIterator<A> for MoveItems<A> {\n+impl<A> DoubleEndedIterator<A> for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }\n@@ -753,6 +758,7 @@ impl<A: Ord> Ord for DList<A> {\n     }\n }\n \n+#[stable]\n impl<A: Clone> Clone for DList<A> {\n     fn clone(&self) -> DList<A> {\n         self.iter().map(|x| x.clone()).collect()\n@@ -783,14 +789,14 @@ impl<S: Writer, A: Hash<S>> Hash<S> for DList<A> {\n \n #[cfg(test)]\n mod tests {\n-    use std::prelude::*;\n+    use prelude::*;\n     use std::rand;\n     use std::hash;\n+    use std::task::spawn;\n     use test::Bencher;\n     use test;\n \n     use super::{DList, Node, ListInsertion};\n-    use vec::Vec;\n \n     pub fn check_links<T>(list: &DList<T>) {\n         let mut len = 0u;\n@@ -926,7 +932,7 @@ mod tests {\n         let mut m = list_from(v.as_slice());\n         m.prepend(list_from(u.as_slice()));\n         check_links(&m);\n-        u.extend(v.as_slice().iter().map(|&b| b));\n+        u.extend(v.iter().map(|&b| b));\n         assert_eq!(u.len(), m.len());\n         for elt in u.into_iter() {\n             assert_eq!(m.pop_front(), Some(elt))\n@@ -945,15 +951,15 @@ mod tests {\n         let mut m = list_from(v.as_slice());\n         m.rotate_backward(); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n-        assert_eq!(v.iter().collect::<Vec<&int>>(), m.iter().collect());\n+        assert_eq!(v.iter().collect::<Vec<&int>>(), m.iter().collect::<Vec<_>>());\n         m.rotate_forward(); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n         m.pop_front(); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n         m.rotate_backward(); check_links(&m);\n         m.push_front(9); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n-        assert_eq!(vec![3i,9,5,1,2], m.into_iter().collect());\n+        assert_eq!(vec![3i,9,5,1,2], m.into_iter().collect::<Vec<_>>());\n     }\n \n     #[test]\n@@ -1130,10 +1136,10 @@ mod tests {\n     #[test]\n     fn test_send() {\n         let n = list_from(&[1i,2,3]);\n-        spawn(proc() {\n+        spawn(move || {\n             check_links(&n);\n             let a: &[_] = &[&1,&2,&3];\n-            assert_eq!(a, n.iter().collect::<Vec<&int>>().as_slice());\n+            assert_eq!(a, n.iter().collect::<Vec<&int>>());\n         });\n     }\n \n@@ -1224,12 +1230,12 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let list: DList<int> = range(0i, 10).collect();\n-        assert!(list.to_string().as_slice() == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        assert!(list.to_string() == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let list: DList<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                    .map(|&s| s)\n                                                                    .collect();\n-        assert!(list.to_string().as_slice() == \"[just, one, test, more]\");\n+        assert!(list.to_string() == \"[just, one, test, more]\");\n     }\n \n     #[cfg(test)]"}, {"sha": "fd04ce94247b7f2a352556dc0c6d519a4b4f3fae", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 66, "deletions": 64, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -20,13 +20,15 @@ use core::num::Int;\n // FIXME(contentions): implement union family of methods? (general design may be wrong here)\n \n #[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-/// A specialized `Set` implementation to use enum types.\n+/// A specialized set implementation to use enum types.\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set\n     // for which no variant exists\n     bits: uint\n }\n \n+impl<E> Copy for EnumSet<E> {}\n+\n impl<E:CLike+fmt::Show> fmt::Show for EnumSet<E> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"{{\"));\n@@ -42,27 +44,25 @@ impl<E:CLike+fmt::Show> fmt::Show for EnumSet<E> {\n     }\n }\n \n-/**\n-An interface for casting C-like enum to uint and back.\n-A typically implementation is as below.\n-\n-```{rust,ignore}\n-#[repr(uint)]\n-enum Foo {\n-    A, B, C\n-}\n-\n-impl CLike for Foo {\n-    fn to_uint(&self) -> uint {\n-        *self as uint\n-    }\n-\n-    fn from_uint(v: uint) -> Foo {\n-        unsafe { mem::transmute(v) }\n-    }\n-}\n-```\n-*/\n+/// An interface for casting C-like enum to uint and back.\n+/// A typically implementation is as below.\n+///\n+/// ```{rust,ignore}\n+/// #[repr(uint)]\n+/// enum Foo {\n+///     A, B, C\n+/// }\n+///\n+/// impl CLike for Foo {\n+///     fn to_uint(&self) -> uint {\n+///         *self as uint\n+///     }\n+///\n+///     fn from_uint(v: uint) -> Foo {\n+///         unsafe { mem::transmute(v) }\n+///     }\n+/// }\n+/// ```\n pub trait CLike {\n     /// Converts a C-like enum to a `uint`.\n     fn to_uint(&self) -> uint;\n@@ -178,48 +178,48 @@ impl<E:CLike> EnumSet<E> {\n \n     /// Returns an iterator over an `EnumSet`.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter(&self) -> Items<E> {\n-        Items::new(self.bits)\n+    pub fn iter(&self) -> Iter<E> {\n+        Iter::new(self.bits)\n     }\n }\n \n impl<E:CLike> Sub<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn sub(&self, e: &EnumSet<E>) -> EnumSet<E> {\n+    fn sub(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits & !e.bits}\n     }\n }\n \n impl<E:CLike> BitOr<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn bitor(&self, e: &EnumSet<E>) -> EnumSet<E> {\n+    fn bitor(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits | e.bits}\n     }\n }\n \n impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn bitand(&self, e: &EnumSet<E>) -> EnumSet<E> {\n+    fn bitand(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits & e.bits}\n     }\n }\n \n impl<E:CLike> BitXor<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn bitxor(&self, e: &EnumSet<E>) -> EnumSet<E> {\n+    fn bitxor(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits ^ e.bits}\n     }\n }\n \n /// An iterator over an EnumSet\n-pub struct Items<E> {\n+pub struct Iter<E> {\n     index: uint,\n     bits: uint,\n }\n \n-impl<E:CLike> Items<E> {\n-    fn new(bits: uint) -> Items<E> {\n-        Items { index: 0, bits: bits }\n+impl<E:CLike> Iter<E> {\n+    fn new(bits: uint) -> Iter<E> {\n+        Iter { index: 0, bits: bits }\n     }\n }\n \n-impl<E:CLike> Iterator<E> for Items<E> {\n+impl<E:CLike> Iterator<E> for Iter<E> {\n     fn next(&mut self) -> Option<E> {\n         if self.bits == 0 {\n             return None;\n@@ -259,13 +259,13 @@ impl<E:CLike> Extend<E> for EnumSet<E> {\n \n #[cfg(test)]\n mod test {\n-    use std::prelude::*;\n     use self::Foo::*;\n-    use std::mem;\n+    use prelude::*;\n+    use core::mem;\n \n     use super::{EnumSet, CLike};\n \n-    #[deriving(PartialEq, Show)]\n+    #[deriving(Copy, PartialEq, Show)]\n     #[repr(uint)]\n     enum Foo {\n         A, B, C\n@@ -290,11 +290,11 @@ mod test {\n     #[test]\n     fn test_show() {\n         let mut e = EnumSet::new();\n-        assert_eq!(\"{}\", e.to_string().as_slice());\n+        assert_eq!(\"{}\", e.to_string());\n         e.insert(A);\n-        assert_eq!(\"{A}\", e.to_string().as_slice());\n+        assert_eq!(\"{A}\", e.to_string());\n         e.insert(C);\n-        assert_eq!(\"{A, C}\", e.to_string().as_slice());\n+        assert_eq!(\"{A, C}\", e.to_string());\n     }\n \n     #[test]\n@@ -373,7 +373,7 @@ mod test {\n \n         assert!(e1.is_subset(&e2));\n         assert!(e2.is_superset(&e1));\n-        assert!(!e3.is_superset(&e2))\n+        assert!(!e3.is_superset(&e2));\n         assert!(!e2.is_superset(&e3))\n     }\n \n@@ -399,24 +399,24 @@ mod test {\n     fn test_iterator() {\n         let mut e1: EnumSet<Foo> = EnumSet::new();\n \n-        let elems: Vec<Foo> = e1.iter().collect();\n-        assert!(elems.is_empty())\n+        let elems: ::vec::Vec<Foo> = e1.iter().collect();\n+        assert!(elems.is_empty());\n \n         e1.insert(A);\n-        let elems = e1.iter().collect();\n-        assert_eq!(vec![A], elems)\n+        let elems: ::vec::Vec<_> = e1.iter().collect();\n+        assert_eq!(vec![A], elems);\n \n         e1.insert(C);\n-        let elems = e1.iter().collect();\n-        assert_eq!(vec![A,C], elems)\n+        let elems: ::vec::Vec<_> = e1.iter().collect();\n+        assert_eq!(vec![A,C], elems);\n \n         e1.insert(C);\n-        let elems = e1.iter().collect();\n-        assert_eq!(vec![A,C], elems)\n+        let elems: ::vec::Vec<_> = e1.iter().collect();\n+        assert_eq!(vec![A,C], elems);\n \n         e1.insert(B);\n-        let elems = e1.iter().collect();\n-        assert_eq!(vec![A,B,C], elems)\n+        let elems: ::vec::Vec<_> = e1.iter().collect();\n+        assert_eq!(vec![A,B,C], elems);\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -433,42 +433,43 @@ mod test {\n         e2.insert(C);\n \n         let e_union = e1 | e2;\n-        let elems = e_union.iter().collect();\n-        assert_eq!(vec![A,B,C], elems)\n+        let elems: ::vec::Vec<_> = e_union.iter().collect();\n+        assert_eq!(vec![A,B,C], elems);\n \n         let e_intersection = e1 & e2;\n-        let elems = e_intersection.iter().collect();\n-        assert_eq!(vec![C], elems)\n+        let elems: ::vec::Vec<_> = e_intersection.iter().collect();\n+        assert_eq!(vec![C], elems);\n \n         // Another way to express intersection\n         let e_intersection = e1 - (e1 - e2);\n-        let elems = e_intersection.iter().collect();\n-        assert_eq!(vec![C], elems)\n+        let elems: ::vec::Vec<_> = e_intersection.iter().collect();\n+        assert_eq!(vec![C], elems);\n \n         let e_subtract = e1 - e2;\n-        let elems = e_subtract.iter().collect();\n-        assert_eq!(vec![A], elems)\n+        let elems: ::vec::Vec<_> = e_subtract.iter().collect();\n+        assert_eq!(vec![A], elems);\n \n         // Bitwise XOR of two sets, aka symmetric difference\n         let e_symmetric_diff = e1 ^ e2;\n-        let elems = e_symmetric_diff.iter().collect();\n-        assert_eq!(vec![A,B], elems)\n+        let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n+        assert_eq!(vec![A,B], elems);\n \n         // Another way to express symmetric difference\n         let e_symmetric_diff = (e1 - e2) | (e2 - e1);\n-        let elems = e_symmetric_diff.iter().collect();\n-        assert_eq!(vec![A,B], elems)\n+        let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n+        assert_eq!(vec![A,B], elems);\n \n         // Yet another way to express symmetric difference\n         let e_symmetric_diff = (e1 | e2) - (e1 & e2);\n-        let elems = e_symmetric_diff.iter().collect();\n-        assert_eq!(vec![A,B], elems)\n+        let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n+        assert_eq!(vec![A,B], elems);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_overflow() {\n         #[allow(dead_code)]\n+        #[deriving(Copy)]\n         #[repr(uint)]\n         enum Bar {\n             V00, V01, V02, V03, V04, V05, V06, V07, V08, V09,\n@@ -479,6 +480,7 @@ mod test {\n             V50, V51, V52, V53, V54, V55, V56, V57, V58, V59,\n             V60, V61, V62, V63, V64, V65, V66, V67, V68, V69,\n         }\n+\n         impl CLike for Bar {\n             fn to_uint(&self) -> uint {\n                 *self as uint"}, {"sha": "b1ff3da947b70b96fa4dd83d030494c3db5918a6", "filename": "src/libcollections/hash/mod.rs", "status": "removed", "additions": 0, "deletions": 385, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e", "patch": "@@ -1,385 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * Generic hashing support.\n- *\n- * This module provides a generic way to compute the hash of a value. The\n- * simplest way to make a type hashable is to use `#[deriving(Hash)]`:\n- *\n- * # Example\n- *\n- * ```rust\n- * use std::hash;\n- * use std::hash::Hash;\n- *\n- * #[deriving(Hash)]\n- * struct Person {\n- *     id: uint,\n- *     name: String,\n- *     phone: u64,\n- * }\n- *\n- * let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n- * let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n- *\n- * assert!(hash::hash(&person1) != hash::hash(&person2));\n- * ```\n- *\n- * If you need more control over how a value is hashed, you need to implement\n- * the trait `Hash`:\n- *\n- * ```rust\n- * use std::hash;\n- * use std::hash::Hash;\n- * use std::hash::sip::SipState;\n- *\n- * struct Person {\n- *     id: uint,\n- *     name: String,\n- *     phone: u64,\n- * }\n- *\n- * impl Hash for Person {\n- *     fn hash(&self, state: &mut SipState) {\n- *         self.id.hash(state);\n- *         self.phone.hash(state);\n- *     }\n- * }\n- *\n- * let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n- * let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n- *\n- * assert!(hash::hash(&person1) == hash::hash(&person2));\n- * ```\n- */\n-\n-#![allow(unused_must_use)]\n-\n-use core::prelude::*;\n-\n-use alloc::boxed::Box;\n-use alloc::rc::Rc;\n-use core::intrinsics::TypeId;\n-use core::mem;\n-use core::num::Int;\n-\n-use vec::Vec;\n-\n-/// Reexport the `sip::hash` function as our default hasher.\n-pub use self::sip::hash as hash;\n-\n-pub mod sip;\n-\n-/// A hashable type. The `S` type parameter is an abstract hash state that is\n-/// used by the `Hash` to compute the hash. It defaults to\n-/// `std::hash::sip::SipState`.\n-pub trait Hash<S = sip::SipState> for Sized? {\n-    /// Computes the hash of a value.\n-    fn hash(&self, state: &mut S);\n-}\n-\n-/// A trait that computes a hash for a value. The main users of this trait are\n-/// containers like `HashMap`, which need a generic way hash multiple types.\n-pub trait Hasher<S> {\n-    /// Compute the hash of a value.\n-    fn hash<Sized? T: Hash<S>>(&self, value: &T) -> u64;\n-}\n-\n-pub trait Writer {\n-    fn write(&mut self, bytes: &[u8]);\n-}\n-\n-//////////////////////////////////////////////////////////////////////////////\n-\n-macro_rules! impl_hash {\n-    ($ty:ident, $uty:ident) => {\n-        impl<S: Writer> Hash<S> for $ty {\n-            #[inline]\n-            fn hash(&self, state: &mut S) {\n-                let a: [u8, ..::core::$ty::BYTES] = unsafe {\n-                    mem::transmute((*self as $uty).to_le() as $ty)\n-                };\n-                state.write(a.as_slice())\n-            }\n-        }\n-    }\n-}\n-\n-impl_hash!(u8, u8)\n-impl_hash!(u16, u16)\n-impl_hash!(u32, u32)\n-impl_hash!(u64, u64)\n-impl_hash!(uint, uint)\n-impl_hash!(i8, u8)\n-impl_hash!(i16, u16)\n-impl_hash!(i32, u32)\n-impl_hash!(i64, u64)\n-impl_hash!(int, uint)\n-\n-impl<S: Writer> Hash<S> for bool {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (*self as u8).hash(state);\n-    }\n-}\n-\n-impl<S: Writer> Hash<S> for char {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (*self as u32).hash(state);\n-    }\n-}\n-\n-impl<S: Writer> Hash<S> for str {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        state.write(self.as_bytes());\n-        0xffu8.hash(state)\n-    }\n-}\n-\n-macro_rules! impl_hash_tuple(\n-    () => (\n-        impl<S: Writer> Hash<S> for () {\n-            #[inline]\n-            fn hash(&self, state: &mut S) {\n-                state.write(&[]);\n-            }\n-        }\n-    );\n-\n-    ( $($name:ident)+) => (\n-        impl<S: Writer, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n-            #[inline]\n-            #[allow(non_snake_case)]\n-            fn hash(&self, state: &mut S) {\n-                match *self {\n-                    ($(ref $name,)*) => {\n-                        $(\n-                            $name.hash(state);\n-                        )*\n-                    }\n-                }\n-            }\n-        }\n-    );\n-)\n-\n-impl_hash_tuple!()\n-impl_hash_tuple!(A)\n-impl_hash_tuple!(A B)\n-impl_hash_tuple!(A B C)\n-impl_hash_tuple!(A B C D)\n-impl_hash_tuple!(A B C D E)\n-impl_hash_tuple!(A B C D E F)\n-impl_hash_tuple!(A B C D E F G)\n-impl_hash_tuple!(A B C D E F G H)\n-impl_hash_tuple!(A B C D E F G H I)\n-impl_hash_tuple!(A B C D E F G H I J)\n-impl_hash_tuple!(A B C D E F G H I J K)\n-impl_hash_tuple!(A B C D E F G H I J K L)\n-\n-impl<S: Writer, T: Hash<S>> Hash<S> for [T] {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.len().hash(state);\n-        for elt in self.iter() {\n-            elt.hash(state);\n-        }\n-    }\n-}\n-\n-\n-impl<S: Writer, T: Hash<S>> Hash<S> for Vec<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.as_slice().hash(state);\n-    }\n-}\n-\n-impl<'a, S: Writer, Sized? T: Hash<S>> Hash<S> for &'a T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-\n-impl<'a, S: Writer, Sized? T: Hash<S>> Hash<S> for &'a mut T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-\n-impl<S: Writer, Sized? T: Hash<S>> Hash<S> for Box<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-\n-// FIXME (#18248) Make `T` `Sized?`\n-impl<S: Writer, T: Hash<S>> Hash<S> for Rc<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-\n-impl<S: Writer, T: Hash<S>> Hash<S> for Option<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        match *self {\n-            Some(ref x) => {\n-                0u8.hash(state);\n-                x.hash(state);\n-            }\n-            None => {\n-                1u8.hash(state);\n-            }\n-        }\n-    }\n-}\n-\n-impl<S: Writer, T> Hash<S> for *const T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        // NB: raw-pointer Hash does _not_ dereference\n-        // to the target; it just gives you the pointer-bytes.\n-        (*self as uint).hash(state);\n-    }\n-}\n-\n-impl<S: Writer, T> Hash<S> for *mut T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        // NB: raw-pointer Hash does _not_ dereference\n-        // to the target; it just gives you the pointer-bytes.\n-        (*self as uint).hash(state);\n-    }\n-}\n-\n-impl<S: Writer> Hash<S> for TypeId {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.hash().hash(state)\n-    }\n-}\n-\n-impl<S: Writer, T: Hash<S>, U: Hash<S>> Hash<S> for Result<T, U> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        match *self {\n-            Ok(ref t) => { 1u.hash(state); t.hash(state); }\n-            Err(ref t) => { 2u.hash(state); t.hash(state); }\n-        }\n-    }\n-}\n-\n-//////////////////////////////////////////////////////////////////////////////\n-\n-#[cfg(test)]\n-mod tests {\n-    use core::kinds::Sized;\n-    use std::mem;\n-\n-    use slice::SlicePrelude;\n-    use super::{Hash, Hasher, Writer};\n-\n-    struct MyWriterHasher;\n-\n-    impl Hasher<MyWriter> for MyWriterHasher {\n-        fn hash<Sized? T: Hash<MyWriter>>(&self, value: &T) -> u64 {\n-            let mut state = MyWriter { hash: 0 };\n-            value.hash(&mut state);\n-            state.hash\n-        }\n-    }\n-\n-    struct MyWriter {\n-        hash: u64,\n-    }\n-\n-    impl Writer for MyWriter {\n-        // Most things we'll just add up the bytes.\n-        fn write(&mut self, buf: &[u8]) {\n-            for byte in buf.iter() {\n-                self.hash += *byte as u64;\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_writer_hasher() {\n-        use alloc::boxed::Box;\n-\n-        let hasher = MyWriterHasher;\n-\n-        assert_eq!(hasher.hash(&()), 0);\n-\n-        assert_eq!(hasher.hash(&5u8), 5);\n-        assert_eq!(hasher.hash(&5u16), 5);\n-        assert_eq!(hasher.hash(&5u32), 5);\n-        assert_eq!(hasher.hash(&5u64), 5);\n-        assert_eq!(hasher.hash(&5u), 5);\n-\n-        assert_eq!(hasher.hash(&5i8), 5);\n-        assert_eq!(hasher.hash(&5i16), 5);\n-        assert_eq!(hasher.hash(&5i32), 5);\n-        assert_eq!(hasher.hash(&5i64), 5);\n-        assert_eq!(hasher.hash(&5i), 5);\n-\n-        assert_eq!(hasher.hash(&false), 0);\n-        assert_eq!(hasher.hash(&true), 1);\n-\n-        assert_eq!(hasher.hash(&'a'), 97);\n-\n-        let s: &str = \"a\";\n-        assert_eq!(hasher.hash(& s), 97 + 0xFF);\n-        // FIXME (#18283) Enable test\n-        //let s: Box<str> = box \"a\";\n-        //assert_eq!(hasher.hash(& s), 97 + 0xFF);\n-        let cs: &[u8] = &[1u8, 2u8, 3u8];\n-        assert_eq!(hasher.hash(& cs), 9);\n-        let cs: Box<[u8]> = box [1u8, 2u8, 3u8];\n-        assert_eq!(hasher.hash(& cs), 9);\n-\n-        // FIXME (#18248) Add tests for hashing Rc<str> and Rc<[T]>\n-\n-        unsafe {\n-            let ptr: *const int = mem::transmute(5i);\n-            assert_eq!(hasher.hash(&ptr), 5);\n-        }\n-\n-        unsafe {\n-            let ptr: *mut int = mem::transmute(5i);\n-            assert_eq!(hasher.hash(&ptr), 5);\n-        }\n-    }\n-\n-    struct Custom {\n-        hash: u64\n-    }\n-\n-    impl Hash<u64> for Custom {\n-        fn hash(&self, state: &mut u64) {\n-            *state = self.hash;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_custom_state() {\n-        let custom = Custom { hash: 5 };\n-        let mut state = 0;\n-        custom.hash(&mut state);\n-        assert_eq!(state, 5);\n-    }\n-}"}, {"sha": "363d30abd0347b02eef24cd234b3abb6a1c08dc7", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 42, "deletions": 26, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -16,15 +16,15 @@\n #![crate_name = \"collections\"]\n #![experimental]\n #![crate_type = \"rlib\"]\n-#![license = \"MIT/ASL2\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![allow(unknown_features)]\n #![feature(macro_rules, default_type_params, phase, globs)]\n-#![feature(unsafe_destructor, import_shadowing, slicing_syntax)]\n+#![feature(unsafe_destructor, slicing_syntax)]\n+#![feature(unboxed_closures)]\n #![no_std]\n \n #[phase(plugin, link)] extern crate core;\n@@ -46,10 +46,6 @@ pub use dlist::DList;\n pub use enum_set::EnumSet;\n pub use ring_buf::RingBuf;\n pub use string::String;\n-pub use tree_map::TreeMap;\n-pub use tree_set::TreeSet;\n-pub use trie_map::TrieMap;\n-pub use trie_set::TrieSet;\n pub use vec::Vec;\n pub use vec_map::VecMap;\n \n@@ -61,13 +57,10 @@ mod btree;\n pub mod dlist;\n pub mod enum_set;\n pub mod ring_buf;\n-mod tree;\n-mod trie;\n pub mod slice;\n pub mod str;\n pub mod string;\n pub mod vec;\n-pub mod hash;\n pub mod vec_map;\n \n pub mod bitv {\n@@ -78,22 +71,6 @@ pub mod bitv_set {\n     pub use bit::{BitvSet, BitPositions, TwoBitPositions};\n }\n \n-pub mod tree_map {\n-    pub use tree::map::*;\n-}\n-\n-pub mod tree_set {\n-    pub use tree::set::*;\n-}\n-\n-pub mod trie_map {\n-    pub use trie::map::*;\n-}\n-\n-pub mod trie_set {\n-    pub use trie::set::*;\n-}\n-\n pub mod btree_map {\n     pub use btree::map::*;\n }\n@@ -115,5 +92,44 @@ mod std {\n     pub use core::option;   // necessary for panic!()\n     pub use core::clone;    // deriving(Clone)\n     pub use core::cmp;      // deriving(Eq, Ord, etc.)\n-    pub use hash;           // deriving(Hash)\n+    pub use core::kinds;    // deriving(Copy)\n+    pub use core::hash;     // deriving(Hash)\n+}\n+\n+#[cfg(test)]\n+mod prelude {\n+    // from core.\n+    pub use core::borrow::IntoCow;\n+    pub use core::char::Char;\n+    pub use core::clone::Clone;\n+    pub use core::cmp::{PartialEq, Eq, Equiv, PartialOrd, Ord};\n+    pub use core::cmp::Ordering::{Less, Equal, Greater};\n+    pub use core::iter::range;\n+    pub use core::iter::{FromIterator, Extend, IteratorExt};\n+    pub use core::iter::{Iterator, DoubleEndedIterator, RandomAccessIterator};\n+    pub use core::iter::{IteratorCloneExt, CloneIteratorExt, DoubleEndedIteratorExt};\n+    pub use core::iter::{IteratorOrdExt, MutableDoubleEndedIterator, ExactSizeIterator};\n+    pub use core::kinds::{Copy, Send, Sized, Sync};\n+    pub use core::mem::drop;\n+    pub use core::ops::{Drop, Fn, FnMut, FnOnce};\n+    pub use core::option::Option;\n+    pub use core::option::Option::{Some, None};\n+    pub use core::ptr::RawPtr;\n+    pub use core::result::Result;\n+    pub use core::result::Result::{Ok, Err};\n+\n+    // in core and collections (may differ).\n+    pub use slice::{PartialEqSliceExt, OrdSliceExt};\n+    pub use slice::{AsSlice, SliceExt};\n+    pub use str::{from_str, Str};\n+\n+    // from other crates.\n+    pub use alloc::boxed::Box;\n+    pub use unicode::char::UnicodeChar;\n+\n+    // from collections.\n+    pub use slice::{CloneSliceExt, VectorVector};\n+    pub use str::{IntoMaybeOwned, StrVector};\n+    pub use string::{String, ToString};\n+    pub use vec::Vec;\n }"}, {"sha": "ce4b1e467739e05498036d7b5c070e03a729dadf", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -11,12 +11,13 @@\n #![macro_escape]\n \n /// Creates a `std::vec::Vec` containing the arguments.\n-macro_rules! vec(\n+macro_rules! vec {\n     ($($e:expr),*) => ({\n         // leading _ to allow empty construction without a warning.\n         let mut _temp = ::vec::Vec::new();\n         $(_temp.push($e);)*\n         _temp\n     });\n     ($($e:expr),+,) => (vec!($($e),+))\n-)\n+}\n+"}, {"sha": "2715ff0678af73a1c82807d5842aebfbbe2456e3", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 856, "deletions": 69, "changes": 925, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -11,7 +11,6 @@\n //! This crate implements a double-ended queue with `O(1)` amortized inserts and removals from both\n //! ends of the container. It also has `O(1)` indexing like a vector. The contained elements are\n //! not required to be copyable, and the queue will be sendable if the contained type is sendable.\n-//! Its interface `Deque` is defined in `collections`.\n \n use core::prelude::*;\n \n@@ -34,10 +33,8 @@ static MINIMUM_CAPACITY: uint = 2u;\n \n // FIXME(conventions): implement shrink_to_fit. Awkward with the current design, but it should\n // be scrapped anyway. Defer to rewrite?\n-// FIXME(conventions): implement into_iter\n \n-\n-/// `RingBuf` is a circular buffer that implements `Deque`.\n+/// `RingBuf` is a circular buffer, which can be used as a double-ended queue efficiently.\n pub struct RingBuf<T> {\n     // tail and head are pointers into the buffer. Tail always points\n     // to the first element that could be read, Head always points\n@@ -51,6 +48,7 @@ pub struct RingBuf<T> {\n     ptr: *mut T\n }\n \n+#[stable]\n impl<T: Clone> Clone for RingBuf<T> {\n     fn clone(&self) -> RingBuf<T> {\n         self.iter().map(|t| t.clone()).collect()\n@@ -71,15 +69,23 @@ impl<T> Drop for RingBuf<T> {\n     }\n }\n \n+#[stable]\n impl<T> Default for RingBuf<T> {\n+    #[stable]\n     #[inline]\n     fn default() -> RingBuf<T> { RingBuf::new() }\n }\n \n impl<T> RingBuf<T> {\n     /// Turn ptr into a slice\n     #[inline]\n-    unsafe fn buffer_as_slice(&self) -> &[T] {\n+    unsafe fn buffer_as_slice<'a>(&'a self) -> &'a [T] {\n+        mem::transmute(RawSlice { data: self.ptr as *const T, len: self.cap })\n+    }\n+\n+    /// Turn ptr into a mut slice\n+    #[inline]\n+    unsafe fn buffer_as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         mem::transmute(RawSlice { data: self.ptr as *const T, len: self.cap })\n     }\n \n@@ -102,6 +108,19 @@ impl<T> RingBuf<T> {\n     /// Returns the index in the underlying buffer for a given logical element index.\n     #[inline]\n     fn wrap_index(&self, idx: uint) -> uint { wrap_index(idx, self.cap) }\n+\n+    /// Copies a contiguous block of memory len long from src to dst\n+    #[inline]\n+    unsafe fn copy(&self, dst: uint, src: uint, len: uint) {\n+        debug_assert!(dst + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n+                      self.cap);\n+        debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n+                      self.cap);\n+        ptr::copy_memory(\n+            self.ptr.offset(dst as int),\n+            self.ptr.offset(src as int) as *const T,\n+            len);\n+    }\n }\n \n impl<T> RingBuf<T> {\n@@ -139,7 +158,7 @@ impl<T> RingBuf<T> {\n \n     /// Retrieves an element in the `RingBuf` by index.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::collections::RingBuf;\n@@ -162,7 +181,7 @@ impl<T> RingBuf<T> {\n \n     /// Retrieves an element in the `RingBuf` mutably by index.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::collections::RingBuf;\n@@ -196,7 +215,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// Fails if there is no element with either index.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::collections::RingBuf;\n@@ -209,6 +228,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf[0], 5);\n     /// assert_eq!(buf[2], 3);\n     /// ```\n+    #[stable]\n     pub fn swap(&mut self, i: uint, j: uint) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n@@ -222,7 +242,7 @@ impl<T> RingBuf<T> {\n     /// Returns the number of elements the `RingBuf` can hold without\n     /// reallocating.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::RingBuf;\n@@ -245,7 +265,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// Panics if the new capacity overflows `uint`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::RingBuf;\n@@ -266,7 +286,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// Panics if the new capacity overflows `uint`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::RingBuf;\n@@ -344,7 +364,7 @@ impl<T> RingBuf<T> {\n \n     /// Returns a front-to-back iterator.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::collections::RingBuf;\n@@ -357,17 +377,17 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), b);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter(&self) -> Items<T> {\n-        Items {\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter {\n             tail: self.tail,\n             head: self.head,\n             ring: unsafe { self.buffer_as_slice() }\n         }\n     }\n \n-    /// Returns a front-to-back iterator which returns mutable references.\n+    /// Returns a front-to-back iterator that returns mutable references.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::collections::RingBuf;\n@@ -383,20 +403,69 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n-        MutItems {\n+    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n+        IterMut {\n             tail: self.tail,\n             head: self.head,\n             cap: self.cap,\n             ptr: self.ptr,\n             marker: marker::ContravariantLifetime::<'a>,\n-            marker2: marker::NoCopy\n+        }\n+    }\n+\n+    /// Consumes the list into an iterator yielding elements by value.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        IntoIter {\n+            inner: self,\n+        }\n+    }\n+\n+    /// Returns a pair of slices which contain, in order, the contents of the\n+    /// `RingBuf`.\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn as_slices<'a>(&'a self) -> (&'a [T], &'a [T]) {\n+        unsafe {\n+            let contiguous = self.is_contiguous();\n+            let buf = self.buffer_as_slice();\n+            if contiguous {\n+                let (empty, buf) = buf.split_at(0);\n+                (buf[self.tail..self.head], empty)\n+            } else {\n+                let (mid, right) = buf.split_at(self.tail);\n+                let (left, _) = mid.split_at(self.head);\n+                (right, left)\n+            }\n+        }\n+    }\n+\n+    /// Returns a pair of slices which contain, in order, the contents of the\n+    /// `RingBuf`.\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn as_mut_slices<'a>(&'a mut self) -> (&'a mut [T], &'a mut [T]) {\n+        unsafe {\n+            let contiguous = self.is_contiguous();\n+            let head = self.head;\n+            let tail = self.tail;\n+            let buf = self.buffer_as_mut_slice();\n+\n+            if contiguous {\n+                let (empty, buf) = buf.split_at_mut(0);\n+                (buf[mut tail..head], empty)\n+            } else {\n+                let (mid, right) = buf.split_at_mut(tail);\n+                let (left, _) = mid.split_at_mut(head);\n+\n+                (right, left)\n+            }\n         }\n     }\n \n     /// Returns the number of elements in the `RingBuf`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::RingBuf;\n@@ -411,7 +480,7 @@ impl<T> RingBuf<T> {\n \n     /// Returns true if the buffer contains no elements\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::RingBuf;\n@@ -424,9 +493,30 @@ impl<T> RingBuf<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n+    /// Creates a draining iterator that clears the `RingBuf` and iterates over\n+    /// the removed items from start to end.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut v = RingBuf::new();\n+    /// v.push_back(1i);\n+    /// assert_eq!(v.drain().next(), Some(1));\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n+        Drain {\n+            inner: self,\n+        }\n+    }\n+\n     /// Clears the buffer, removing all values.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::RingBuf;\n@@ -437,16 +527,15 @@ impl<T> RingBuf<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[inline]\n     pub fn clear(&mut self) {\n-        while self.pop_front().is_some() {}\n-        self.head = 0;\n-        self.tail = 0;\n+        self.drain();\n     }\n \n     /// Provides a reference to the front element, or `None` if the sequence is\n     /// empty.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::RingBuf;\n@@ -458,15 +547,15 @@ impl<T> RingBuf<T> {\n     /// d.push_back(2i);\n     /// assert_eq!(d.front(), Some(&1i));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn front(&self) -> Option<&T> {\n         if !self.is_empty() { Some(&self[0]) } else { None }\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the\n     /// sequence is empty.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::RingBuf;\n@@ -482,15 +571,15 @@ impl<T> RingBuf<T> {\n     /// }\n     /// assert_eq!(d.front(), Some(&9i));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         if !self.is_empty() { Some(&mut self[0]) } else { None }\n     }\n \n     /// Provides a reference to the back element, or `None` if the sequence is\n     /// empty.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::RingBuf;\n@@ -502,15 +591,15 @@ impl<T> RingBuf<T> {\n     /// d.push_back(2i);\n     /// assert_eq!(d.back(), Some(&2i));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn back(&self) -> Option<&T> {\n         if !self.is_empty() { Some(&self[self.len() - 1]) } else { None }\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the\n     /// sequence is empty.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::RingBuf;\n@@ -526,7 +615,7 @@ impl<T> RingBuf<T> {\n     /// }\n     /// assert_eq!(d.back(), Some(&9i));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         let len = self.len();\n         if !self.is_empty() { Some(&mut self[len - 1]) } else { None }\n@@ -535,7 +624,7 @@ impl<T> RingBuf<T> {\n     /// Removes the first element and returns it, or `None` if the sequence is\n     /// empty.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::RingBuf;\n@@ -561,7 +650,7 @@ impl<T> RingBuf<T> {\n \n     /// Inserts an element first in the sequence.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::collections::RingBuf;\n@@ -591,7 +680,7 @@ impl<T> RingBuf<T> {\n \n     /// Appends an element to the back of a buffer\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::collections::RingBuf;\n@@ -622,7 +711,7 @@ impl<T> RingBuf<T> {\n     /// Removes the last element from a buffer and returns it, or `None` if\n     /// it is empty.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::collections::RingBuf;\n@@ -643,6 +732,380 @@ impl<T> RingBuf<T> {\n             unsafe { Some(self.buffer_read(head)) }\n         }\n     }\n+\n+    #[inline]\n+    fn is_contiguous(&self) -> bool {\n+        self.tail <= self.head\n+    }\n+\n+    /// Inserts an element at position `i` within the ringbuf. Whichever\n+    /// end is closer to the insertion point will be moved to make room,\n+    /// and all the affected elements will be moved to new positions.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `i` is greater than ringbuf's length\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// buf.push_back(10i);\n+    /// buf.push_back(12);\n+    /// buf.insert(1,11);\n+    /// assert_eq!(Some(&11), buf.get(1));\n+    /// ```\n+    pub fn insert(&mut self, i: uint, t: T) {\n+        assert!(i <= self.len(), \"index out of bounds\");\n+        if self.is_full() {\n+            self.reserve(1);\n+            debug_assert!(!self.is_full());\n+        }\n+\n+        // Move the least number of elements in the ring buffer and insert\n+        // the given object\n+        //\n+        // At most len/2 - 1 elements will be moved. O(min(n, n-i))\n+        //\n+        // There are three main cases:\n+        //  Elements are contiguous\n+        //      - special case when tail is 0\n+        //  Elements are discontiguous and the insert is in the tail section\n+        //  Elements are discontiguous and the insert is in the head section\n+        //\n+        // For each of those there are two more cases:\n+        //  Insert is closer to tail\n+        //  Insert is closer to head\n+        //\n+        // Key: H - self.head\n+        //      T - self.tail\n+        //      o - Valid element\n+        //      I - Insertion element\n+        //      A - The element that should be after the insertion point\n+        //      M - Indicates element was moved\n+\n+        let idx = self.wrap_index(self.tail + i);\n+\n+        let distance_to_tail = i;\n+        let distance_to_head = self.len() - i;\n+\n+        let contiguous = self.is_contiguous();\n+\n+        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n+            (true, true, _) if i == 0 => {\n+                // push_front\n+                //\n+                //       T\n+                //       I             H\n+                //      [A o o o o o o . . . . . . . . .]\n+                //\n+                //                       H         T\n+                //      [A o o o o o o o . . . . . I]\n+                //\n+\n+                self.tail = self.wrap_index(self.tail - 1);\n+            },\n+            (true, true, _) => unsafe {\n+                // contiguous, insert closer to tail:\n+                //\n+                //             T   I         H\n+                //      [. . . o o A o o o o . . . . . .]\n+                //\n+                //           T               H\n+                //      [. . o o I A o o o o . . . . . .]\n+                //           M M\n+                //\n+                // contiguous, insert closer to tail and tail is 0:\n+                //\n+                //\n+                //       T   I         H\n+                //      [o o A o o o o . . . . . . . . .]\n+                //\n+                //                       H             T\n+                //      [o I A o o o o o . . . . . . . o]\n+                //       M                             M\n+\n+                let new_tail = self.wrap_index(self.tail - 1);\n+\n+                self.copy(new_tail, self.tail, 1);\n+                // Already moved the tail, so we only copy `i - 1` elements.\n+                self.copy(self.tail, self.tail + 1, i - 1);\n+\n+                self.tail = new_tail;\n+            },\n+            (true, false, _) => unsafe {\n+                //  contiguous, insert closer to head:\n+                //\n+                //             T       I     H\n+                //      [. . . o o o o A o o . . . . . .]\n+                //\n+                //             T               H\n+                //      [. . . o o o o I A o o . . . . .]\n+                //                       M M M\n+\n+                self.copy(idx + 1, idx, self.head - idx);\n+                self.head = self.wrap_index(self.head + 1);\n+            },\n+            (false, true, true) => unsafe {\n+                // discontiguous, insert closer to tail, tail section:\n+                //\n+                //                   H         T   I\n+                //      [o o o o o o . . . . . o o A o o]\n+                //\n+                //                   H       T\n+                //      [o o o o o o . . . . o o I A o o]\n+                //                           M M\n+\n+                self.copy(self.tail - 1, self.tail, i);\n+                self.tail -= 1;\n+            },\n+            (false, false, true) => unsafe {\n+                // discontiguous, insert closer to head, tail section:\n+                //\n+                //           H             T         I\n+                //      [o o . . . . . . . o o o o o A o]\n+                //\n+                //             H           T\n+                //      [o o o . . . . . . o o o o o I A]\n+                //       M M M                         M\n+\n+                // copy elements up to new head\n+                self.copy(1, 0, self.head);\n+\n+                // copy last element into empty spot at bottom of buffer\n+                self.copy(0, self.cap - 1, 1);\n+\n+                // move elements from idx to end forward not including ^ element\n+                self.copy(idx + 1, idx, self.cap - 1 - idx);\n+\n+                self.head += 1;\n+            },\n+            (false, true, false) if idx == 0 => unsafe {\n+                // discontiguous, insert is closer to tail, head section,\n+                // and is at index zero in the internal buffer:\n+                //\n+                //       I                   H     T\n+                //      [A o o o o o o o o o . . . o o o]\n+                //\n+                //                           H   T\n+                //      [A o o o o o o o o o . . o o o I]\n+                //                               M M M\n+\n+                // copy elements up to new tail\n+                self.copy(self.tail - 1, self.tail, self.cap - self.tail);\n+\n+                // copy last element into empty spot at bottom of buffer\n+                self.copy(self.cap - 1, 0, 1);\n+\n+                self.tail -= 1;\n+            },\n+            (false, true, false) => unsafe {\n+                // discontiguous, insert closer to tail, head section:\n+                //\n+                //             I             H     T\n+                //      [o o o A o o o o o o . . . o o o]\n+                //\n+                //                           H   T\n+                //      [o o I A o o o o o o . . o o o o]\n+                //       M M                     M M M M\n+\n+                // copy elements up to new tail\n+                self.copy(self.tail - 1, self.tail, self.cap - self.tail);\n+\n+                // copy last element into empty spot at bottom of buffer\n+                self.copy(self.cap - 1, 0, 1);\n+\n+                // move elements from idx-1 to end forward not including ^ element\n+                self.copy(0, 1, idx - 1);\n+\n+                self.tail -= 1;\n+            },\n+            (false, false, false) => unsafe {\n+                // discontiguous, insert closer to head, head section:\n+                //\n+                //               I     H           T\n+                //      [o o o o A o o . . . . . . o o o]\n+                //\n+                //                     H           T\n+                //      [o o o o I A o o . . . . . o o o]\n+                //                 M M M\n+\n+                self.copy(idx + 1, idx, self.head - idx);\n+                self.head += 1;\n+            }\n+        }\n+\n+        // tail might've been changed so we need to recalculate\n+        let new_idx = self.wrap_index(self.tail + i);\n+        unsafe {\n+            self.buffer_write(new_idx, t);\n+        }\n+    }\n+\n+    /// Removes and returns the element at position `i` from the ringbuf.\n+    /// Whichever end is closer to the removal point will be moved to make\n+    /// room, and all the affected elements will be moved to new positions.\n+    /// Returns `None` if `i` is out of bounds.\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// buf.push_back(5i);\n+    /// buf.push_back(10i);\n+    /// buf.push_back(12i);\n+    /// buf.push_back(15);\n+    /// buf.remove(2);\n+    /// assert_eq!(Some(&15), buf.get(2));\n+    /// ```\n+    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n+    pub fn remove(&mut self, i: uint) -> Option<T> {\n+        if self.is_empty() || self.len() <= i {\n+            return None;\n+        }\n+\n+        // There are three main cases:\n+        //  Elements are contiguous\n+        //  Elements are discontiguous and the removal is in the tail section\n+        //  Elements are discontiguous and the removal is in the head section\n+        //      - special case when elements are technically contiguous,\n+        //        but self.head = 0\n+        //\n+        // For each of those there are two more cases:\n+        //  Insert is closer to tail\n+        //  Insert is closer to head\n+        //\n+        // Key: H - self.head\n+        //      T - self.tail\n+        //      o - Valid element\n+        //      x - Element marked for removal\n+        //      R - Indicates element that is being removed\n+        //      M - Indicates element was moved\n+\n+        let idx = self.wrap_index(self.tail + i);\n+\n+        let elem = unsafe {\n+            Some(self.buffer_read(idx))\n+        };\n+\n+        let distance_to_tail = i;\n+        let distance_to_head = self.len() - i;\n+\n+        let contiguous = self.tail <= self.head;\n+\n+        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n+            (true, true, _) => unsafe {\n+                // contiguous, remove closer to tail:\n+                //\n+                //             T   R         H\n+                //      [. . . o o x o o o o . . . . . .]\n+                //\n+                //               T           H\n+                //      [. . . . o o o o o o . . . . . .]\n+                //               M M\n+\n+                self.copy(self.tail + 1, self.tail, i);\n+                self.tail += 1;\n+            },\n+            (true, false, _) => unsafe {\n+                // contiguous, remove closer to head:\n+                //\n+                //             T       R     H\n+                //      [. . . o o o o x o o . . . . . .]\n+                //\n+                //             T           H\n+                //      [. . . o o o o o o . . . . . . .]\n+                //                     M M\n+\n+                self.copy(idx, idx + 1, self.head - idx - 1);\n+                self.head -= 1;\n+            },\n+            (false, true, true) => unsafe {\n+                // discontiguous, remove closer to tail, tail section:\n+                //\n+                //                   H         T   R\n+                //      [o o o o o o . . . . . o o x o o]\n+                //\n+                //                   H           T\n+                //      [o o o o o o . . . . . . o o o o]\n+                //                               M M\n+\n+                self.copy(self.tail + 1, self.tail, i);\n+                self.tail = self.wrap_index(self.tail + 1);\n+            },\n+            (false, false, false) => unsafe {\n+                // discontiguous, remove closer to head, head section:\n+                //\n+                //               R     H           T\n+                //      [o o o o x o o . . . . . . o o o]\n+                //\n+                //                   H             T\n+                //      [o o o o o o . . . . . . . o o o]\n+                //               M M\n+\n+                self.copy(idx, idx + 1, self.head - idx - 1);\n+                self.head -= 1;\n+            },\n+            (false, false, true) => unsafe {\n+                // discontiguous, remove closer to head, tail section:\n+                //\n+                //             H           T         R\n+                //      [o o o . . . . . . o o o o o x o]\n+                //\n+                //           H             T\n+                //      [o o . . . . . . . o o o o o o o]\n+                //       M M                         M M\n+                //\n+                // or quasi-discontiguous, remove next to head, tail section:\n+                //\n+                //       H                 T         R\n+                //      [. . . . . . . . . o o o o o x o]\n+                //\n+                //                         T           H\n+                //      [. . . . . . . . . o o o o o o .]\n+                //                                   M\n+\n+                // draw in elements in the tail section\n+                self.copy(idx, idx + 1, self.cap - idx - 1);\n+\n+                // Prevents underflow.\n+                if self.head != 0 {\n+                    // copy first element into empty spot\n+                    self.copy(self.cap - 1, 0, 1);\n+\n+                    // move elements in the head section backwards\n+                    self.copy(0, 1, self.head - 1);\n+                }\n+\n+                self.head = self.wrap_index(self.head - 1);\n+            },\n+            (false, true, false) => unsafe {\n+                // discontiguous, remove closer to tail, head section:\n+                //\n+                //           R               H     T\n+                //      [o o x o o o o o o o . . . o o o]\n+                //\n+                //                           H       T\n+                //      [o o o o o o o o o o . . . . o o]\n+                //       M M M                       M M\n+\n+                // draw in elements up to idx\n+                self.copy(1, 0, idx);\n+\n+                // copy last element into empty spot\n+                self.copy(0, self.cap - 1, 1);\n+\n+                // move elements from tail to end forward, excluding the last one\n+                self.copy(self.tail + 1, self.tail, self.cap - self.tail - 1);\n+\n+                self.tail = self.wrap_index(self.tail + 1);\n+            }\n+        }\n+\n+        return elem;\n+    }\n }\n \n /// Returns the index in the underlying buffer for a given logical element index.\n@@ -660,13 +1123,13 @@ fn count(tail: uint, head: uint, size: uint) -> uint {\n }\n \n /// `RingBuf` iterator.\n-pub struct Items<'a, T:'a> {\n+pub struct Iter<'a, T:'a> {\n     ring: &'a [T],\n     tail: uint,\n     head: uint\n }\n \n-impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n+impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n         if self.tail == self.head {\n@@ -684,7 +1147,7 @@ impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n         if self.tail == self.head {\n@@ -695,10 +1158,9 @@ impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n     }\n }\n \n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n-impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n-\n-impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (len, _) = self.size_hint();\n@@ -716,32 +1178,29 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     }\n }\n \n-// FIXME This was implemented differently from Items because of a problem\n+// FIXME This was implemented differently from Iter because of a problem\n //       with returning the mutable reference. I couldn't find a way to\n //       make the lifetime checker happy so, but there should be a way.\n /// `RingBuf` mutable iterator.\n-pub struct MutItems<'a, T:'a> {\n+pub struct IterMut<'a, T:'a> {\n     ptr: *mut T,\n     tail: uint,\n     head: uint,\n     cap: uint,\n     marker: marker::ContravariantLifetime<'a>,\n-    marker2: marker::NoCopy\n }\n \n-impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n+impl<'a, T> Iterator<&'a mut T> for IterMut<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut T> {\n         if self.tail == self.head {\n             return None;\n         }\n         let tail = self.tail;\n         self.tail = wrap_index(self.tail + 1, self.cap);\n-        if mem::size_of::<T>() != 0 {\n-            unsafe { Some(&mut *self.ptr.offset(tail as int)) }\n-        } else {\n-            // use a non-zero pointer\n-            Some(unsafe { mem::transmute(1u) })\n+\n+        unsafe {\n+            Some(&mut *self.ptr.offset(tail as int))\n         }\n     }\n \n@@ -752,27 +1211,90 @@ impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a mut T> for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> {\n         if self.tail == self.head {\n             return None;\n         }\n         self.head = wrap_index(self.head - 1, self.cap);\n-        unsafe { Some(&mut *self.ptr.offset(self.head as int)) }\n+\n+        unsafe {\n+            Some(&mut *self.ptr.offset(self.head as int))\n+        }\n     }\n }\n \n-impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n+\n+// A by-value RingBuf iterator\n+pub struct IntoIter<T> {\n+    inner: RingBuf<T>,\n+}\n+\n+impl<T> Iterator<T> for IntoIter<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.pop_front()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let len = self.inner.len();\n+        (len, Some(len))\n+    }\n+}\n+\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        self.inner.pop_back()\n+    }\n+}\n+\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n+\n+/// A draining RingBuf iterator\n+pub struct Drain<'a, T: 'a> {\n+    inner: &'a mut RingBuf<T>,\n+}\n+\n+#[unsafe_destructor]\n+impl<'a, T: 'a> Drop for Drain<'a, T> {\n+    fn drop(&mut self) {\n+        for _ in *self {}\n+        self.inner.head = 0;\n+        self.inner.tail = 0;\n+    }\n+}\n+\n+impl<'a, T: 'a> Iterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.pop_front()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let len = self.inner.len();\n+        (len, Some(len))\n+    }\n+}\n+\n+impl<'a, T: 'a> DoubleEndedIterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        self.inner.pop_back()\n+    }\n+}\n+\n+impl<'a, T: 'a> ExactSizeIterator<T> for Drain<'a, T> {}\n \n impl<A: PartialEq> PartialEq for RingBuf<A> {\n     fn eq(&self, other: &RingBuf<A>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n     }\n-    fn ne(&self, other: &RingBuf<A>) -> bool {\n-        !self.eq(other)\n-    }\n }\n \n impl<A: Eq> Eq for RingBuf<A> {}\n@@ -847,14 +1369,15 @@ impl<T: fmt::Show> fmt::Show for RingBuf<T> {\n mod tests {\n     use self::Taggy::*;\n     use self::Taggypar::*;\n+    use prelude::*;\n+    use core::cmp;\n+    use core::iter;\n     use std::fmt::Show;\n-    use std::prelude::*;\n     use std::hash;\n     use test::Bencher;\n     use test;\n \n     use super::RingBuf;\n-    use vec::Vec;\n \n     #[test]\n     #[allow(deprecated)]\n@@ -1069,7 +1592,6 @@ mod tests {\n         })\n     }\n \n-\n     #[deriving(Clone, PartialEq, Show)]\n     enum Taggy {\n         One(int),\n@@ -1212,15 +1734,15 @@ mod tests {\n         }\n         {\n             let b: &[_] = &[&0,&1,&2,&3,&4];\n-            assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), b);\n+            assert_eq!(d.iter().collect::<Vec<&int>>(), b);\n         }\n \n         for i in range(6i, 9) {\n             d.push_front(i);\n         }\n         {\n             let b: &[_] = &[&8,&7,&6,&0,&1,&2,&3,&4];\n-            assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), b);\n+            assert_eq!(d.iter().collect::<Vec<&int>>(), b);\n         }\n \n         let mut it = d.iter();\n@@ -1243,14 +1765,14 @@ mod tests {\n         }\n         {\n             let b: &[_] = &[&4,&3,&2,&1,&0];\n-            assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), b);\n+            assert_eq!(d.iter().rev().collect::<Vec<&int>>(), b);\n         }\n \n         for i in range(6i, 9) {\n             d.push_front(i);\n         }\n         let b: &[_] = &[&4,&3,&2,&1,&0,&6,&7,&8];\n-        assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), b);\n+        assert_eq!(d.iter().rev().collect::<Vec<&int>>(), b);\n     }\n \n     #[test]\n@@ -1314,15 +1836,141 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_into_iter() {\n+\n+        // Empty iter\n+        {\n+            let d: RingBuf<int> = RingBuf::new();\n+            let mut iter = d.into_iter();\n+\n+            assert_eq!(iter.size_hint(), (0, Some(0)));\n+            assert_eq!(iter.next(), None);\n+            assert_eq!(iter.size_hint(), (0, Some(0)));\n+        }\n+\n+        // simple iter\n+        {\n+            let mut d = RingBuf::new();\n+            for i in range(0i, 5) {\n+                d.push_back(i);\n+            }\n+\n+            let b = vec![0,1,2,3,4];\n+            assert_eq!(d.into_iter().collect::<Vec<int>>(), b);\n+        }\n+\n+        // wrapped iter\n+        {\n+            let mut d = RingBuf::new();\n+            for i in range(0i, 5) {\n+                d.push_back(i);\n+            }\n+            for i in range(6, 9) {\n+                d.push_front(i);\n+            }\n+\n+            let b = vec![8,7,6,0,1,2,3,4];\n+            assert_eq!(d.into_iter().collect::<Vec<int>>(), b);\n+        }\n+\n+        // partially used\n+        {\n+            let mut d = RingBuf::new();\n+            for i in range(0i, 5) {\n+                d.push_back(i);\n+            }\n+            for i in range(6, 9) {\n+                d.push_front(i);\n+            }\n+\n+            let mut it = d.into_iter();\n+            assert_eq!(it.size_hint(), (8, Some(8)));\n+            assert_eq!(it.next(), Some(8));\n+            assert_eq!(it.size_hint(), (7, Some(7)));\n+            assert_eq!(it.next_back(), Some(4));\n+            assert_eq!(it.size_hint(), (6, Some(6)));\n+            assert_eq!(it.next(), Some(7));\n+            assert_eq!(it.size_hint(), (5, Some(5)));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_drain() {\n+\n+        // Empty iter\n+        {\n+            let mut d: RingBuf<int> = RingBuf::new();\n+\n+            {\n+                let mut iter = d.drain();\n+\n+                assert_eq!(iter.size_hint(), (0, Some(0)));\n+                assert_eq!(iter.next(), None);\n+                assert_eq!(iter.size_hint(), (0, Some(0)));\n+            }\n+\n+            assert!(d.is_empty());\n+        }\n+\n+        // simple iter\n+        {\n+            let mut d = RingBuf::new();\n+            for i in range(0i, 5) {\n+                d.push_back(i);\n+            }\n+\n+            assert_eq!(d.drain().collect::<Vec<int>>(), [0, 1, 2, 3, 4]);\n+            assert!(d.is_empty());\n+        }\n+\n+        // wrapped iter\n+        {\n+            let mut d = RingBuf::new();\n+            for i in range(0i, 5) {\n+                d.push_back(i);\n+            }\n+            for i in range(6, 9) {\n+                d.push_front(i);\n+            }\n+\n+            assert_eq!(d.drain().collect::<Vec<int>>(), [8,7,6,0,1,2,3,4]);\n+            assert!(d.is_empty());\n+        }\n+\n+        // partially used\n+        {\n+            let mut d = RingBuf::new();\n+            for i in range(0i, 5) {\n+                d.push_back(i);\n+            }\n+            for i in range(6, 9) {\n+                d.push_front(i);\n+            }\n+\n+            {\n+                let mut it = d.drain();\n+                assert_eq!(it.size_hint(), (8, Some(8)));\n+                assert_eq!(it.next(), Some(8));\n+                assert_eq!(it.size_hint(), (7, Some(7)));\n+                assert_eq!(it.next_back(), Some(4));\n+                assert_eq!(it.size_hint(), (6, Some(6)));\n+                assert_eq!(it.next(), Some(7));\n+                assert_eq!(it.size_hint(), (5, Some(5)));\n+            }\n+            assert!(d.is_empty());\n+        }\n+    }\n+\n     #[test]\n     fn test_from_iter() {\n-        use std::iter;\n+        use core::iter;\n         let v = vec!(1i,2,3,4,5,6,7);\n         let deq: RingBuf<int> = v.iter().map(|&x| x).collect();\n         let u: Vec<int> = deq.iter().map(|&x| x).collect();\n         assert_eq!(u, v);\n \n-        let mut seq = iter::count(0u, 2).take(256);\n+        let seq = iter::count(0u, 2).take(256);\n         let deq: RingBuf<uint> = seq.collect();\n         for (i, &x) in deq.iter().enumerate() {\n             assert_eq!(2*i, x);\n@@ -1402,12 +2050,12 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let ringbuf: RingBuf<int> = range(0i, 10).collect();\n-        assert!(format!(\"{}\", ringbuf).as_slice() == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        assert!(format!(\"{}\", ringbuf) == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let ringbuf: RingBuf<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                         .map(|&s| s)\n                                                                         .collect();\n-        assert!(format!(\"{}\", ringbuf).as_slice() == \"[just, one, test, more]\");\n+        assert!(format!(\"{}\", ringbuf) == \"[just, one, test, more]\");\n     }\n \n     #[test]\n@@ -1574,4 +2222,143 @@ mod tests {\n         assert_eq!(ring.get_mut(1), Some(&mut 2));\n         assert_eq!(ring.get_mut(2), None);\n     }\n+\n+    #[test]\n+    fn test_insert() {\n+        // This test checks that every single combination of tail position, length, and\n+        // insertion position is tested. Capacity 15 should be large enough to cover every case.\n+\n+        let mut tester = RingBuf::with_capacity(15);\n+        // can't guarantee we got 15, so have to get what we got.\n+        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+        // this test isn't covering what it wants to\n+        let cap = tester.capacity();\n+\n+\n+        // len is the length *after* insertion\n+        for len in range(1, cap) {\n+            // 0, 1, 2, .., len - 1\n+            let expected = iter::count(0, 1).take(len).collect();\n+            for tail_pos in range(0, cap) {\n+                for to_insert in range(0, len) {\n+                    tester.tail = tail_pos;\n+                    tester.head = tail_pos;\n+                    for i in range(0, len) {\n+                        if i != to_insert {\n+                            tester.push_back(i);\n+                        }\n+                    }\n+                    tester.insert(to_insert, to_insert);\n+                    assert!(tester.tail < tester.cap);\n+                    assert!(tester.head < tester.cap);\n+                    assert_eq!(tester, expected);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_remove() {\n+        // This test checks that every single combination of tail position, length, and\n+        // removal position is tested. Capacity 15 should be large enough to cover every case.\n+\n+        let mut tester = RingBuf::with_capacity(15);\n+        // can't guarantee we got 15, so have to get what we got.\n+        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+        // this test isn't covering what it wants to\n+        let cap = tester.capacity();\n+\n+        // len is the length *after* removal\n+        for len in range(0, cap - 1) {\n+            // 0, 1, 2, .., len - 1\n+            let expected = iter::count(0, 1).take(len).collect();\n+            for tail_pos in range(0, cap) {\n+                for to_remove in range(0, len + 1) {\n+                    tester.tail = tail_pos;\n+                    tester.head = tail_pos;\n+                    for i in range(0, len) {\n+                        if i == to_remove {\n+                            tester.push_back(1234);\n+                        }\n+                        tester.push_back(i);\n+                    }\n+                    if to_remove == len {\n+                        tester.push_back(1234);\n+                    }\n+                    tester.remove(to_remove);\n+                    assert!(tester.tail < tester.cap);\n+                    assert!(tester.head < tester.cap);\n+                    assert_eq!(tester, expected);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_front() {\n+        let mut ring = RingBuf::new();\n+        ring.push_back(10i);\n+        ring.push_back(20i);\n+        assert_eq!(ring.front(), Some(&10));\n+        ring.pop_front();\n+        assert_eq!(ring.front(), Some(&20));\n+        ring.pop_front();\n+        assert_eq!(ring.front(), None);\n+    }\n+\n+    #[test]\n+    fn test_as_slices() {\n+        let mut ring: RingBuf<int> = RingBuf::with_capacity(127);\n+        let cap = ring.capacity() as int;\n+        let first = cap/2;\n+        let last  = cap - first;\n+        for i in range(0, first) {\n+            ring.push_back(i);\n+\n+            let (left, right) = ring.as_slices();\n+            let expected: Vec<_> = range(0, i+1).collect();\n+            assert_eq!(left, expected);\n+            assert_eq!(right, []);\n+        }\n+\n+        for j in range(-last, 0) {\n+            ring.push_front(j);\n+            let (left, right) = ring.as_slices();\n+            let expected_left: Vec<_> = range(-last, j+1).rev().collect();\n+            let expected_right: Vec<_> = range(0, first).collect();\n+            assert_eq!(left, expected_left);\n+            assert_eq!(right, expected_right);\n+        }\n+\n+        assert_eq!(ring.len() as int, cap);\n+        assert_eq!(ring.capacity() as int, cap);\n+    }\n+\n+    #[test]\n+    fn test_as_mut_slices() {\n+        let mut ring: RingBuf<int> = RingBuf::with_capacity(127);\n+        let cap = ring.capacity() as int;\n+        let first = cap/2;\n+        let last  = cap - first;\n+        for i in range(0, first) {\n+            ring.push_back(i);\n+\n+            let (left, right) = ring.as_mut_slices();\n+            let expected: Vec<_> = range(0, i+1).collect();\n+            assert_eq!(left, expected);\n+            assert_eq!(right, []);\n+        }\n+\n+        for j in range(-last, 0) {\n+            ring.push_front(j);\n+            let (left, right) = ring.as_mut_slices();\n+            let expected_left: Vec<_> = range(-last, j+1).rev().collect();\n+            let expected_right: Vec<_> = range(0, first).collect();\n+            assert_eq!(left, expected_left);\n+            assert_eq!(right, expected_right);\n+        }\n+\n+        assert_eq!(ring.len() as int, cap);\n+        assert_eq!(ring.capacity() as int, cap);\n+    }\n }"}, {"sha": "d6d94f57acf45b88c6739aa9c3736980c833a799", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 785, "deletions": 108, "changes": 893, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -37,13 +37,13 @@\n //!\n //! ## Structs\n //!\n-//! There are several structs that are useful for slices, such as `Items`, which\n+//! There are several structs that are useful for slices, such as `Iter`, which\n //! represents iteration over a slice.\n //!\n //! ## Traits\n //!\n //! A number of traits add methods that allow you to accomplish tasks\n-//! with slices, the most important being `SlicePrelude`. Other traits\n+//! with slices, the most important being `SliceExt`. Other traits\n //! apply only to slices of elements satisfying certain bounds (like\n //! `Ord`).\n //!\n@@ -87,26 +87,28 @@\n \n #![doc(primitive = \"slice\")]\n \n-use self::Direction::*;\n use alloc::boxed::Box;\n-use core::borrow::{BorrowFrom, BorrowFromMut};\n+use core::borrow::{BorrowFrom, BorrowFromMut, ToOwned};\n use core::cmp;\n+use core::iter::{range_step, MultiplicativeIterator};\n use core::kinds::Sized;\n use core::mem::size_of;\n use core::mem;\n-use core::prelude::{Clone, Greater, Iterator, Less, None, Option};\n+use core::ops::FnMut;\n+use core::prelude::{Clone, Greater, Iterator, IteratorExt, Less, None, Option};\n use core::prelude::{Ord, Ordering, RawPtr, Some, range};\n use core::ptr;\n-use core::iter::{range_step, MultiplicativeIterator};\n+use core::slice as core_slice;\n+use self::Direction::*;\n \n use vec::Vec;\n \n-pub use core::slice::{Chunks, AsSlice, SlicePrelude, PartialEqSlicePrelude};\n-pub use core::slice::{OrdSlicePrelude, SlicePrelude, Items, MutItems};\n+pub use core::slice::{Chunks, AsSlice, SplitsN, Windows};\n+pub use core::slice::{Iter, IterMut, PartialEqSliceExt};\n pub use core::slice::{ImmutableIntSlice, MutableIntSlice};\n pub use core::slice::{MutSplits, MutChunks, Splits};\n-pub use core::slice::{bytes, mut_ref_slice, ref_slice, CloneSlicePrelude};\n-pub use core::slice::{Found, NotFound};\n+pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n+pub use core::slice::{from_raw_buf, from_raw_mut_buf, BinarySearchResult};\n \n // Functional utilities\n \n@@ -175,9 +177,11 @@ impl ElementSwaps {\n     }\n }\n \n+#[deriving(Copy)]\n enum Direction { Pos, Neg }\n \n /// An `Index` and `Direction` together.\n+#[deriving(Copy)]\n struct SizeDirection {\n     size: uint,\n     dir: Direction,\n@@ -201,7 +205,7 @@ impl Iterator<(uint, uint)> for ElementSwaps {\n         match max {\n             Some((i, sd)) => {\n                 let j = new_pos(i, sd.dir);\n-                self.sdir.as_mut_slice().swap(i, j);\n+                self.sdir.swap(i, j);\n \n                 // Swap the direction of each larger SizeDirection\n                 for x in self.sdir.iter_mut() {\n@@ -256,7 +260,7 @@ impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n             Some((0,0)) => Some(self.v.clone()),\n             Some((a, b)) => {\n                 let elt = self.v.clone();\n-                self.v.as_mut_slice().swap(a, b);\n+                self.v.swap(a, b);\n                 Some(elt)\n             }\n         }\n@@ -269,12 +273,12 @@ impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n }\n \n /// Extension methods for boxed slices.\n-pub trait BoxedSlicePrelude<T> {\n+pub trait BoxedSliceExt<T> {\n     /// Convert `self` into a vector without clones or allocation.\n     fn into_vec(self) -> Vec<T>;\n }\n \n-impl<T> BoxedSlicePrelude<T> for Box<[T]> {\n+impl<T> BoxedSliceExt<T> for Box<[T]> {\n     #[experimental]\n     fn into_vec(mut self) -> Vec<T> {\n         unsafe {\n@@ -286,18 +290,18 @@ impl<T> BoxedSlicePrelude<T> for Box<[T]> {\n }\n \n /// Allocating extension methods for slices containing `Clone` elements.\n-pub trait CloneSliceAllocPrelude<T> for Sized? {\n+pub trait CloneSliceExt<T> for Sized? {\n     /// Copies `self` into a new `Vec`.\n     fn to_vec(&self) -> Vec<T>;\n \n     /// Partitions the vector into two vectors `(a, b)`, where all\n     /// elements of `a` satisfy `f` and all elements of `b` do not.\n-    fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>);\n+    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool;\n \n     /// Creates an iterator that yields every possible permutation of the\n     /// vector in succession.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// let v = [1i, 2, 3];\n@@ -308,7 +312,7 @@ pub trait CloneSliceAllocPrelude<T> for Sized? {\n     /// }\n     /// ```\n     ///\n-    /// # Example 2: iterating through permutations one by one.\n+    /// Iterating through permutations one by one.\n     ///\n     /// ```rust\n     /// let v = [1i, 2, 3];\n@@ -319,9 +323,28 @@ pub trait CloneSliceAllocPrelude<T> for Sized? {\n     /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n     /// ```\n     fn permutations(&self) -> Permutations<T>;\n+\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut dst = [0i, 0, 0];\n+    /// let src = [1i, 2];\n+    ///\n+    /// assert!(dst.clone_from_slice(&src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n+    ///\n+    /// let src2 = [3i, 4, 5, 6];\n+    /// assert!(dst.clone_from_slice(&src2) == 3);\n+    /// assert!(dst == [3i, 4, 5]);\n+    /// ```\n+    fn clone_from_slice(&mut self, &[T]) -> uint;\n }\n \n-impl<T: Clone> CloneSliceAllocPrelude<T> for [T] {\n+impl<T: Clone> CloneSliceExt<T> for [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n     fn to_vec(&self) -> Vec<T> {\n@@ -332,7 +355,7 @@ impl<T: Clone> CloneSliceAllocPrelude<T> for [T] {\n \n \n     #[inline]\n-    fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n+    fn partitioned<F>(&self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n         let mut lefts  = Vec::new();\n         let mut rights = Vec::new();\n \n@@ -355,9 +378,12 @@ impl<T: Clone> CloneSliceAllocPrelude<T> for [T] {\n         }\n     }\n \n+    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n+        core_slice::CloneSliceExt::clone_from_slice(self, src)\n+    }\n }\n \n-fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n+fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n     let len = v.len() as int;\n     let buf_v = v.as_mut_ptr();\n \n@@ -399,7 +425,7 @@ fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     }\n }\n \n-fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n+fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n     // warning: this wildly uses unsafe.\n     static BASE_INSERTION: uint = 32;\n     static LARGE_INSERTION: uint = 16;\n@@ -562,12 +588,12 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n \n /// Allocating extension methods for slices on Ord values.\n #[experimental = \"likely to merge with other traits\"]\n-pub trait OrdSliceAllocPrelude<T> for Sized? {\n+pub trait OrdSliceExt<T> for Sized? {\n     /// Sorts the slice, in place.\n     ///\n     /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// let mut v = [-5i, 4, 1, -3, 2];\n@@ -577,26 +603,102 @@ pub trait OrdSliceAllocPrelude<T> for Sized? {\n     /// ```\n     #[experimental]\n     fn sort(&mut self);\n-}\n \n-impl<T: Ord> OrdSliceAllocPrelude<T> for [T] {\n+    /// Binary search a sorted slice for a given element.\n+    ///\n+    /// If the value is found then `Found` is returned, containing the\n+    /// index of the matching element; if the value is not found then\n+    /// `NotFound` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Example\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n+    ///\n+    /// ```rust\n+    /// use std::slice::BinarySearchResult::{Found, NotFound};\n+    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n+    ///\n+    /// assert_eq!(s.binary_search_elem(&13),  Found(9));\n+    /// assert_eq!(s.binary_search_elem(&4),   NotFound(7));\n+    /// assert_eq!(s.binary_search_elem(&100), NotFound(13));\n+    /// let r = s.binary_search_elem(&1);\n+    /// assert!(match r { Found(1...4) => true, _ => false, });\n+    /// ```\n+    #[unstable = \"name likely to change\"]\n+    fn binary_search_elem(&self, x: &T) -> BinarySearchResult;\n+\n+    /// Mutates the slice to the next lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// last-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [0i, 1, 2];\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [1i, 0, 2];\n+    /// assert!(v == b);\n+    /// ```\n     #[experimental]\n+    fn next_permutation(&mut self) -> bool;\n+\n+    /// Mutates the slice to the previous lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// first-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [1i, 0, 2];\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 1, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[experimental]\n+    fn prev_permutation(&mut self) -> bool;\n+}\n+\n+impl<T: Ord> OrdSliceExt<T> for [T] {\n     #[inline]\n     fn sort(&mut self) {\n         self.sort_by(|a, b| a.cmp(b))\n     }\n+\n+    fn binary_search_elem(&self, x: &T) -> BinarySearchResult {\n+        core_slice::OrdSliceExt::binary_search_elem(self, x)\n+    }\n+\n+    fn next_permutation(&mut self) -> bool {\n+        core_slice::OrdSliceExt::next_permutation(self)\n+    }\n+\n+    fn prev_permutation(&mut self) -> bool {\n+        core_slice::OrdSliceExt::prev_permutation(self)\n+    }\n }\n \n /// Allocating extension methods for slices.\n #[experimental = \"likely to merge with other traits\"]\n-pub trait SliceAllocPrelude<T> for Sized? {\n+pub trait SliceExt<T> for Sized? {\n     /// Sorts the slice, in place, using `compare` to compare\n     /// elements.\n     ///\n     /// This sort is `O(n log n)` worst-case and stable, but allocates\n     /// approximately `2 * n`, where `n` is the length of `self`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// let mut v = [5i, 4, 1, 3, 2];\n@@ -607,7 +709,7 @@ pub trait SliceAllocPrelude<T> for Sized? {\n     /// v.sort_by(|a, b| b.cmp(a));\n     /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n-    fn sort_by(&mut self, compare: |&T, &T| -> Ordering);\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering;\n \n     /// Consumes `src` and moves as many elements as it can into `self`\n     /// from the range [start,end).\n@@ -621,7 +723,7 @@ pub trait SliceAllocPrelude<T> for Sized? {\n     /// * start - The index into `src` to start copying from\n     /// * end - The index into `src` to stop copying from\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// let mut a = [1i, 2, 3, 4, 5];\n@@ -631,11 +733,378 @@ pub trait SliceAllocPrelude<T> for Sized? {\n     /// assert!(a == [6i, 7, 8, 4, 5]);\n     /// ```\n     fn move_from(&mut self, src: Vec<T>, start: uint, end: uint) -> uint;\n+\n+    /// Returns a subslice spanning the interval [`start`, `end`).\n+    ///\n+    /// Panics when the end of the new slice lies beyond the end of the\n+    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n+    ///\n+    /// Slicing with `start` equal to `end` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n+    fn slice(&self, start: uint, end: uint) -> &[T];\n+\n+    /// Returns a subslice from `start` to the end of the slice.\n+    ///\n+    /// Panics when `start` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing from `self.len()` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n+    fn slice_from(&self, start: uint) -> &[T];\n+\n+    /// Returns a subslice from the start of the slice to `end`.\n+    ///\n+    /// Panics when `end` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing to `0` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n+    fn slice_to(&self, end: uint) -> &[T];\n+\n+    /// Divides one slice into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// Panics if `mid > len`.\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn split_at(&self, mid: uint) -> (&[T], &[T]);\n+\n+    /// Returns an iterator over the slice\n+    #[unstable = \"iterator type may change\"]\n+    fn iter(&self) -> Iter<T>;\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`.  The matched element is not contained in the subslices.\n+    #[unstable = \"iterator type may change, waiting on unboxed closures\"]\n+    fn split<F>(&self, pred: F) -> Splits<T, F>\n+                where F: FnMut(&T) -> bool;\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// not contained in the subslices.\n+    #[unstable = \"iterator type may change\"]\n+    fn splitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n+                 where F: FnMut(&T) -> bool;\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    #[unstable = \"iterator type may change\"]\n+    fn rsplitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n+                  where F: FnMut(&T) -> bool;\n+\n+    /// Returns an iterator over all contiguous windows of length\n+    /// `size`. The windows overlap. If the slice is shorter than\n+    /// `size`, the iterator returns no values.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n+    /// `[3,4]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1i, 2, 3, 4];\n+    /// for win in v.windows(2) {\n+    ///     println!(\"{}\", win);\n+    /// }\n+    /// ```\n+    #[unstable = \"iterator type may change\"]\n+    fn windows(&self, size: uint) -> Windows<T>;\n+\n+    /// Returns an iterator over `size` elements of the slice at a\n+    /// time. The chunks do not overlap. If `size` does not divide the\n+    /// length of the slice, then the last chunk will not have length\n+    /// `size`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// Print the slice two elements at a time (i.e. `[1,2]`,\n+    /// `[3,4]`, `[5]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1i, 2, 3, 4, 5];\n+    /// for win in v.chunks(2) {\n+    ///     println!(\"{}\", win);\n+    /// }\n+    /// ```\n+    #[unstable = \"iterator type may change\"]\n+    fn chunks(&self, size: uint) -> Chunks<T>;\n+\n+    /// Returns the element of a slice at the given index, or `None` if the\n+    /// index is out of bounds.\n+    #[unstable = \"waiting on final collection conventions\"]\n+    fn get(&self, index: uint) -> Option<&T>;\n+\n+    /// Returns the first element of a slice, or `None` if it is empty.\n+    #[unstable = \"name may change\"]\n+    fn head(&self) -> Option<&T>;\n+\n+    /// Returns all but the first element of a slice.\n+    #[unstable = \"name may change\"]\n+    fn tail(&self) -> &[T];\n+\n+    /// Returns all but the last element of a slice.\n+    #[unstable = \"name may change\"]\n+    fn init(&self) -> &[T];\n+\n+    /// Returns the last element of a slice, or `None` if it is empty.\n+    #[unstable = \"name may change\"]\n+    fn last(&self) -> Option<&T>;\n+\n+    /// Returns a pointer to the element at the given index, without doing\n+    /// bounds checking.\n+    #[unstable]\n+    unsafe fn unsafe_get(&self, index: uint) -> &T;\n+\n+    /// Returns an unsafe pointer to the slice's buffer\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the slice may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[unstable]\n+    fn as_ptr(&self) -> *const T;\n+\n+    /// Binary search a sorted slice with a comparator function.\n+    ///\n+    /// The comparator function should implement an order consistent\n+    /// with the sort order of the underlying slice, returning an\n+    /// order code that indicates whether its argument is `Less`,\n+    /// `Equal` or `Greater` the desired target.\n+    ///\n+    /// If a matching value is found then returns `Found`, containing\n+    /// the index for the matched element; if no match is found then\n+    /// `NotFound` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Example\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n+    ///\n+    /// ```rust\n+    /// use std::slice::BinarySearchResult::{Found, NotFound};\n+    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n+    ///\n+    /// let seek = 13;\n+    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), Found(9));\n+    /// let seek = 4;\n+    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), NotFound(7));\n+    /// let seek = 100;\n+    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), NotFound(13));\n+    /// let seek = 1;\n+    /// let r = s.binary_search(|probe| probe.cmp(&seek));\n+    /// assert!(match r { Found(1...4) => true, _ => false, });\n+    /// ```\n+    #[unstable = \"waiting on unboxed closures\"]\n+    fn binary_search<F>(&self, f: F) -> BinarySearchResult\n+                        where F: FnMut(&T) -> Ordering;\n+\n+    /// Return the number of elements in the slice\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let a = [1i, 2, 3];\n+    /// assert_eq!(a.len(), 3);\n+    /// ```\n+    #[experimental = \"not triaged yet\"]\n+    fn len(&self) -> uint;\n+\n+    /// Returns true if the slice has a length of 0\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let a = [1i, 2, 3];\n+    /// assert!(!a.is_empty());\n+    /// ```\n+    #[inline]\n+    #[experimental = \"not triaged yet\"]\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n+    /// Returns a mutable reference to the element at the given index,\n+    /// or `None` if the index is out of bounds\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn get_mut(&mut self, index: uint) -> Option<&mut T>;\n+\n+    /// Work with `self` as a mut slice.\n+    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n+    fn as_mut_slice(&mut self) -> &mut [T];\n+\n+    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n+    ///\n+    /// Panics when the end of the new slice lies beyond the end of the\n+    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n+    ///\n+    /// Slicing with `start` equal to `end` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T];\n+\n+    /// Returns a mutable subslice from `start` to the end of the slice.\n+    ///\n+    /// Panics when `start` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing from `self.len()` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn slice_from_mut(&mut self, start: uint) -> &mut [T];\n+\n+    /// Returns a mutable subslice from the start of the slice to `end`.\n+    ///\n+    /// Panics when `end` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing to `0` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn slice_to_mut(&mut self, end: uint) -> &mut [T];\n+\n+    /// Returns an iterator that allows modifying each value\n+    #[unstable = \"waiting on iterator type name conventions\"]\n+    fn iter_mut(&mut self) -> IterMut<T>;\n+\n+    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n+    #[unstable = \"name may change\"]\n+    fn head_mut(&mut self) -> Option<&mut T>;\n+\n+    /// Returns all but the first element of a mutable slice\n+    #[unstable = \"name may change\"]\n+    fn tail_mut(&mut self) -> &mut [T];\n+\n+    /// Returns all but the last element of a mutable slice\n+    #[unstable = \"name may change\"]\n+    fn init_mut(&mut self) -> &mut [T];\n+\n+    /// Returns a mutable pointer to the last item in the slice.\n+    #[unstable = \"name may change\"]\n+    fn last_mut(&mut self) -> Option<&mut T>;\n+\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`.  The matched element is not contained in the subslices.\n+    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n+    fn split_mut<F>(&mut self, pred: F) -> MutSplits<T, F>\n+                    where F: FnMut(&T) -> bool;\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// not contained in the subslices.\n+    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n+    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n+                     where F: FnMut(&T) -> bool;\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n+    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n+                      where F: FnMut(&T) -> bool;\n+\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n+    /// The chunks are mutable and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last chunk will not\n+    /// have length `chunk_size`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    #[unstable = \"waiting on iterator type name conventions\"]\n+    fn chunks_mut(&mut self, chunk_size: uint) -> MutChunks<T>;\n+\n+    /// Swaps two elements in a slice.\n+    ///\n+    /// Panics if `a` or `b` are out of bounds.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * a - The index of the first element\n+    /// * b - The index of the second element\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n+    /// v.swap(1, 3);\n+    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// ```\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn swap(&mut self, a: uint, b: uint);\n+\n+    /// Divides one `&mut` into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// Panics if `mid > len`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1i, 2, 3, 4, 5, 6];\n+    ///\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// {\n+    ///    let (left, right) = v.split_at_mut(0);\n+    ///    assert!(left == []);\n+    ///    assert!(right == [1i, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(2);\n+    ///     assert!(left == [1i, 2]);\n+    ///     assert!(right == [3i, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(6);\n+    ///     assert!(left == [1i, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == []);\n+    /// }\n+    /// ```\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]);\n+\n+    /// Reverse the order of elements in a slice, in place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1i, 2, 3];\n+    /// v.reverse();\n+    /// assert!(v == [3i, 2, 1]);\n+    /// ```\n+    #[experimental = \"may be moved to iterators instead\"]\n+    fn reverse(&mut self);\n+\n+    /// Returns an unsafe mutable pointer to the element in index\n+    #[experimental = \"waiting on unsafe conventions\"]\n+    unsafe fn unsafe_mut(&mut self, index: uint) -> &mut T;\n+\n+    /// Return an unsafe mutable pointer to the slice's buffer.\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the slice may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[inline]\n+    #[unstable]\n+    fn as_mut_ptr(&mut self) -> *mut T;\n }\n \n-impl<T> SliceAllocPrelude<T> for [T] {\n+impl<T> SliceExt<T> for [T] {\n     #[inline]\n-    fn sort_by(&mut self, compare: |&T, &T| -> Ordering) {\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n         merge_sort(self, compare)\n     }\n \n@@ -646,6 +1115,208 @@ impl<T> SliceAllocPrelude<T> for [T] {\n         }\n         cmp::min(self.len(), end-start)\n     }\n+\n+    #[inline]\n+    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n+        core_slice::SliceExt::slice(self, start, end)\n+    }\n+\n+    #[inline]\n+    fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n+        core_slice::SliceExt::slice_from(self, start)\n+    }\n+\n+    #[inline]\n+    fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n+        core_slice::SliceExt::slice_to(self, end)\n+    }\n+\n+    #[inline]\n+    fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]) {\n+        core_slice::SliceExt::split_at(self, mid)\n+    }\n+\n+    #[inline]\n+    fn iter<'a>(&'a self) -> Iter<'a, T> {\n+        core_slice::SliceExt::iter(self)\n+    }\n+\n+    #[inline]\n+    fn split<F>(&self, pred: F) -> Splits<T, F>\n+                where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::split(self, pred)\n+    }\n+\n+    #[inline]\n+    fn splitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n+                 where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::splitn(self, n, pred)\n+    }\n+\n+    #[inline]\n+    fn rsplitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n+                  where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::rsplitn(self, n, pred)\n+    }\n+\n+    #[inline]\n+    fn windows<'a>(&'a self, size: uint) -> Windows<'a, T> {\n+        core_slice::SliceExt::windows(self, size)\n+    }\n+\n+    #[inline]\n+    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T> {\n+        core_slice::SliceExt::chunks(self, size)\n+    }\n+\n+    #[inline]\n+    fn get<'a>(&'a self, index: uint) -> Option<&'a T> {\n+        core_slice::SliceExt::get(self, index)\n+    }\n+\n+    #[inline]\n+    fn head<'a>(&'a self) -> Option<&'a T> {\n+        core_slice::SliceExt::head(self)\n+    }\n+\n+    #[inline]\n+    fn tail<'a>(&'a self) -> &'a [T] {\n+        core_slice::SliceExt::tail(self)\n+    }\n+\n+    #[inline]\n+    fn init<'a>(&'a self) -> &'a [T] {\n+        core_slice::SliceExt::init(self)\n+    }\n+\n+    #[inline]\n+    fn last<'a>(&'a self) -> Option<&'a T> {\n+        core_slice::SliceExt::last(self)\n+    }\n+\n+    #[inline]\n+    unsafe fn unsafe_get<'a>(&'a self, index: uint) -> &'a T {\n+        core_slice::SliceExt::unsafe_get(self, index)\n+    }\n+\n+    #[inline]\n+    fn as_ptr(&self) -> *const T {\n+        core_slice::SliceExt::as_ptr(self)\n+    }\n+\n+    #[inline]\n+    fn binary_search<F>(&self, f: F) -> BinarySearchResult\n+                        where F: FnMut(&T) -> Ordering {\n+        core_slice::SliceExt::binary_search(self, f)\n+    }\n+\n+    #[inline]\n+    fn len(&self) -> uint {\n+        core_slice::SliceExt::len(self)\n+    }\n+\n+    #[inline]\n+    fn is_empty(&self) -> bool {\n+        core_slice::SliceExt::is_empty(self)\n+    }\n+\n+    #[inline]\n+    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T> {\n+        core_slice::SliceExt::get_mut(self, index)\n+    }\n+\n+    #[inline]\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        core_slice::SliceExt::as_mut_slice(self)\n+    }\n+\n+    #[inline]\n+    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T] {\n+        core_slice::SliceExt::slice_mut(self, start, end)\n+    }\n+\n+    #[inline]\n+    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n+        core_slice::SliceExt::slice_from_mut(self, start)\n+    }\n+\n+    #[inline]\n+    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n+        core_slice::SliceExt::slice_to_mut(self, end)\n+    }\n+\n+    #[inline]\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n+        core_slice::SliceExt::iter_mut(self)\n+    }\n+\n+    #[inline]\n+    fn head_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        core_slice::SliceExt::head_mut(self)\n+    }\n+\n+    #[inline]\n+    fn tail_mut<'a>(&'a mut self) -> &'a mut [T] {\n+        core_slice::SliceExt::tail_mut(self)\n+    }\n+\n+    #[inline]\n+    fn init_mut<'a>(&'a mut self) -> &'a mut [T] {\n+        core_slice::SliceExt::init_mut(self)\n+    }\n+\n+    #[inline]\n+    fn last_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        core_slice::SliceExt::last_mut(self)\n+    }\n+\n+    #[inline]\n+    fn split_mut<F>(&mut self, pred: F) -> MutSplits<T, F>\n+                    where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::split_mut(self, pred)\n+    }\n+\n+    #[inline]\n+    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n+                     where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::splitn_mut(self, n, pred)\n+    }\n+\n+    #[inline]\n+    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n+                      where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::rsplitn_mut(self, n, pred)\n+    }\n+\n+    #[inline]\n+    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> MutChunks<'a, T> {\n+        core_slice::SliceExt::chunks_mut(self, chunk_size)\n+    }\n+\n+    #[inline]\n+    fn swap(&mut self, a: uint, b: uint) {\n+        core_slice::SliceExt::swap(self, a, b)\n+    }\n+\n+    #[inline]\n+    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n+        core_slice::SliceExt::split_at_mut(self, mid)\n+    }\n+\n+    #[inline]\n+    fn reverse(&mut self) {\n+        core_slice::SliceExt::reverse(self)\n+    }\n+\n+    #[inline]\n+    unsafe fn unsafe_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n+        core_slice::SliceExt::unsafe_mut(self, index)\n+    }\n+\n+    #[inline]\n+    fn as_mut_ptr(&mut self) -> *mut T {\n+        core_slice::SliceExt::as_mut_ptr(self)\n+    }\n }\n \n #[unstable = \"trait is unstable\"]\n@@ -658,6 +1329,11 @@ impl<T> BorrowFromMut<Vec<T>> for [T] {\n     fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned[mut] }\n }\n \n+#[unstable = \"trait is unstable\"]\n+impl<T: Clone> ToOwned<Vec<T>> for [T] {\n+    fn to_owned(&self) -> Vec<T> { self.to_vec() }\n+}\n+\n /// Unsafe operations\n pub mod raw {\n     pub use core::slice::raw::{buf_as_slice, mut_buf_as_slice};\n@@ -666,18 +1342,14 @@ pub mod raw {\n \n #[cfg(test)]\n mod tests {\n-    extern crate rustrt;\n-\n-    use std::cell::Cell;\n-    use std::default::Default;\n-    use std::mem;\n-    use std::prelude::*;\n+    use std::boxed::Box;\n+    use prelude::*;\n+    use core::cell::Cell;\n+    use core::default::Default;\n+    use core::mem;\n     use std::rand::{Rng, task_rng};\n     use std::rc::Rc;\n-    use std::rt;\n-    use slice::*;\n-\n-    use vec::Vec;\n+    use super::ElementSwaps;\n \n     fn square(n: uint) -> uint { n * n }\n \n@@ -774,11 +1446,11 @@ mod tests {\n     #[test]\n     fn test_head_mut() {\n         let mut a = vec![];\n-        assert_eq!(a.as_mut_slice().head_mut(), None);\n+        assert_eq!(a.head_mut(), None);\n         a = vec![11i];\n-        assert_eq!(*a.as_mut_slice().head_mut().unwrap(), 11);\n+        assert_eq!(*a.head_mut().unwrap(), 11);\n         a = vec![11i, 12];\n-        assert_eq!(*a.as_mut_slice().head_mut().unwrap(), 11);\n+        assert_eq!(*a.head_mut().unwrap(), 11);\n     }\n \n     #[test]\n@@ -795,10 +1467,10 @@ mod tests {\n     fn test_tail_mut() {\n         let mut a = vec![11i];\n         let b: &mut [int] = &mut [];\n-        assert!(a.as_mut_slice().tail_mut() == b);\n+        assert!(a.tail_mut() == b);\n         a = vec![11i, 12];\n         let b: &mut [int] = &mut [12];\n-        assert!(a.as_mut_slice().tail_mut() == b);\n+        assert!(a.tail_mut() == b);\n     }\n \n     #[test]\n@@ -812,7 +1484,7 @@ mod tests {\n     #[should_fail]\n     fn test_tail_mut_empty() {\n         let mut a: Vec<int> = vec![];\n-        a.as_mut_slice().tail_mut();\n+        a.tail_mut();\n     }\n \n     #[test]\n@@ -829,10 +1501,10 @@ mod tests {\n     fn test_init_mut() {\n         let mut a = vec![11i];\n         let b: &mut [int] = &mut [];\n-        assert!(a.as_mut_slice().init_mut() == b);\n+        assert!(a.init_mut() == b);\n         a = vec![11i, 12];\n         let b: &mut [int] = &mut [11];\n-        assert!(a.as_mut_slice().init_mut() == b);\n+        assert!(a.init_mut() == b);\n     }\n \n     #[test]\n@@ -846,7 +1518,7 @@ mod tests {\n     #[should_fail]\n     fn test_init_mut_empty() {\n         let mut a: Vec<int> = vec![];\n-        a.as_mut_slice().init_mut();\n+        a.init_mut();\n     }\n \n     #[test]\n@@ -862,11 +1534,11 @@ mod tests {\n     #[test]\n     fn test_last_mut() {\n         let mut a = vec![];\n-        assert_eq!(a.as_mut_slice().last_mut(), None);\n+        assert_eq!(a.last_mut(), None);\n         a = vec![11i];\n-        assert_eq!(*a.as_mut_slice().last_mut().unwrap(), 11);\n+        assert_eq!(*a.last_mut().unwrap(), 11);\n         a = vec![11i, 12];\n-        assert_eq!(*a.as_mut_slice().last_mut().unwrap(), 12);\n+        assert_eq!(*a.last_mut().unwrap(), 12);\n     }\n \n     #[test]\n@@ -951,9 +1623,10 @@ mod tests {\n     #[test]\n     fn test_swap_remove_noncopyable() {\n         // Tests that we don't accidentally run destructors twice.\n-        let mut v = vec![rustrt::exclusive::Exclusive::new(()),\n-                         rustrt::exclusive::Exclusive::new(()),\n-                         rustrt::exclusive::Exclusive::new(())];\n+        let mut v = Vec::new();\n+        v.push(box 0u8);\n+        v.push(box 0u8);\n+        v.push(box 0u8);\n         let mut _e = v.swap_remove(0);\n         assert_eq!(v.len(), 2);\n         _e = v.swap_remove(1);\n@@ -1058,7 +1731,7 @@ mod tests {\n         v2.dedup();\n         /*\n          * If the boxed pointers were leaked or otherwise misused, valgrind\n-         * and/or rustrt should raise errors.\n+         * and/or rt should raise errors.\n          */\n     }\n \n@@ -1072,7 +1745,7 @@ mod tests {\n         v2.dedup();\n         /*\n          * If the pointers were leaked or otherwise misused, valgrind and/or\n-         * rustrt should raise errors.\n+         * rt should raise errors.\n          */\n     }\n \n@@ -1294,13 +1967,13 @@ mod tests {\n                                       .collect::<Vec<uint>>();\n                 let mut v1 = v.clone();\n \n-                v.as_mut_slice().sort();\n+                v.sort();\n                 assert!(v.as_slice().windows(2).all(|w| w[0] <= w[1]));\n \n-                v1.as_mut_slice().sort_by(|a, b| a.cmp(b));\n+                v1.sort_by(|a, b| a.cmp(b));\n                 assert!(v1.as_slice().windows(2).all(|w| w[0] <= w[1]));\n \n-                v1.as_mut_slice().sort_by(|a, b| b.cmp(a));\n+                v1.sort_by(|a, b| b.cmp(a));\n                 assert!(v1.as_slice().windows(2).all(|w| w[0] >= w[1]));\n             }\n         }\n@@ -1477,11 +2150,17 @@ mod tests {\n             fn clone(&self) -> S {\n                 self.f.set(self.f.get() + 1);\n                 if self.f.get() == 10 { panic!() }\n-                S { f: self.f, boxes: self.boxes.clone() }\n+                S {\n+                    f: self.f.clone(),\n+                    boxes: self.boxes.clone(),\n+                }\n             }\n         }\n \n-        let s = S { f: Cell::new(0), boxes: (box 0, Rc::new(0)) };\n+        let s = S {\n+            f: Cell::new(0),\n+            boxes: (box 0, Rc::new(0)),\n+        };\n         let _ = Vec::from_elem(100, s);\n     }\n \n@@ -1647,62 +2326,62 @@ mod tests {\n         let xs = &[1i,2,3,4,5];\n \n         let splits: &[&[int]] = &[&[1], &[3], &[5]];\n-        assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[], &[2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 1).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 1).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[1,2,3,4], &[]];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 10).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 10).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[], &[], &[], &[], &[], &[]];\n-        assert_eq!(xs.split(|_| true).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|_| true).collect::<Vec<&[int]>>(),\n                    splits);\n \n         let xs: &[int] = &[];\n         let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>().as_slice(), splits);\n+        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>(), splits);\n     }\n \n     #[test]\n     fn test_splitnator() {\n         let xs = &[1i,2,3,4,5];\n \n         let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[1], &[3,4,5]];\n-        assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[], &[], &[], &[4,5]];\n-        assert_eq!(xs.splitn(3, |_| true).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.splitn(3, |_| true).collect::<Vec<&[int]>>(),\n                    splits);\n \n         let xs: &[int] = &[];\n         let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), splits);\n+        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<&[int]>>(), splits);\n     }\n \n     #[test]\n     fn test_splitnator_mut() {\n         let xs = &mut [1i,2,3,4,5];\n \n         let splits: &[&mut [int]] = &[&mut [1,2,3,4,5]];\n-        assert_eq!(xs.splitn_mut(0, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>().as_slice(),\n+        assert_eq!(xs.splitn_mut(0, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>(),\n                    splits);\n         let splits: &[&mut [int]] = &[&mut [1], &mut [3,4,5]];\n-        assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>().as_slice(),\n+        assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>(),\n                    splits);\n         let splits: &[&mut [int]] = &[&mut [], &mut [], &mut [], &mut [4,5]];\n-        assert_eq!(xs.splitn_mut(3, |_| true).collect::<Vec<&mut [int]>>().as_slice(),\n+        assert_eq!(xs.splitn_mut(3, |_| true).collect::<Vec<&mut [int]>>(),\n                    splits);\n \n         let xs: &mut [int] = &mut [];\n         let splits: &[&mut [int]] = &[&mut []];\n-        assert_eq!(xs.splitn_mut(1, |x| *x == 5).collect::<Vec<&mut [int]>>().as_slice(),\n+        assert_eq!(xs.splitn_mut(1, |x| *x == 5).collect::<Vec<&mut [int]>>(),\n                    splits);\n     }\n \n@@ -1711,50 +2390,50 @@ mod tests {\n         let xs = &[1i,2,3,4,5];\n \n         let splits: &[&[int]] = &[&[5], &[3], &[1]];\n-        assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[2,3,4,5], &[]];\n-        assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[], &[1,2,3,4]];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<&[int]>>(),\n                    splits);\n \n         let xs: &[int] = &[];\n         let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>().as_slice(), splits);\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>(), splits);\n     }\n \n     #[test]\n     fn test_rsplitnator() {\n         let xs = &[1,2,3,4,5];\n \n         let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[5], &[1,2,3]];\n-        assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[], &[], &[], &[1,2]];\n-        assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<&[int]>>(),\n                    splits);\n \n         let xs: &[int] = &[];\n         let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), splits);\n+        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[int]>>(), splits);\n     }\n \n     #[test]\n     fn test_windowsator() {\n         let v = &[1i,2,3,4];\n \n         let wins: &[&[int]] = &[&[1,2], &[2,3], &[3,4]];\n-        assert_eq!(v.windows(2).collect::<Vec<&[int]>>().as_slice(), wins);\n+        assert_eq!(v.windows(2).collect::<Vec<&[int]>>(), wins);\n         let wins: &[&[int]] = &[&[1i,2,3], &[2,3,4]];\n-        assert_eq!(v.windows(3).collect::<Vec<&[int]>>().as_slice(), wins);\n+        assert_eq!(v.windows(3).collect::<Vec<&[int]>>(), wins);\n         assert!(v.windows(6).next().is_none());\n     }\n \n@@ -1770,14 +2449,14 @@ mod tests {\n         let v = &[1i,2,3,4,5];\n \n         let chunks: &[&[int]] = &[&[1i,2], &[3,4], &[5]];\n-        assert_eq!(v.chunks(2).collect::<Vec<&[int]>>().as_slice(), chunks);\n+        assert_eq!(v.chunks(2).collect::<Vec<&[int]>>(), chunks);\n         let chunks: &[&[int]] = &[&[1i,2,3], &[4,5]];\n-        assert_eq!(v.chunks(3).collect::<Vec<&[int]>>().as_slice(), chunks);\n+        assert_eq!(v.chunks(3).collect::<Vec<&[int]>>(), chunks);\n         let chunks: &[&[int]] = &[&[1i,2,3,4,5]];\n-        assert_eq!(v.chunks(6).collect::<Vec<&[int]>>().as_slice(), chunks);\n+        assert_eq!(v.chunks(6).collect::<Vec<&[int]>>(), chunks);\n \n         let chunks: &[&[int]] = &[&[5i], &[3,4], &[1,2]];\n-        assert_eq!(v.chunks(2).rev().collect::<Vec<&[int]>>().as_slice(), chunks);\n+        assert_eq!(v.chunks(2).rev().collect::<Vec<&[int]>>(), chunks);\n         let mut it = v.chunks(2);\n         assert_eq!(it.indexable(), 3);\n         let chunk: &[int] = &[1,2];\n@@ -1831,22 +2510,22 @@ mod tests {\n                 assert_eq!(format!(\"{}\", x), x_str);\n                 assert_eq!(format!(\"{}\", x.as_slice()), x_str);\n             })\n-        )\n+        );\n         let empty: Vec<int> = vec![];\n-        test_show_vec!(empty, \"[]\".to_string());\n-        test_show_vec!(vec![1i], \"[1]\".to_string());\n-        test_show_vec!(vec![1i, 2, 3], \"[1, 2, 3]\".to_string());\n+        test_show_vec!(empty, \"[]\");\n+        test_show_vec!(vec![1i], \"[1]\");\n+        test_show_vec!(vec![1i, 2, 3], \"[1, 2, 3]\");\n         test_show_vec!(vec![vec![], vec![1u], vec![1u, 1u]],\n-                       \"[[], [1], [1, 1]]\".to_string());\n+                       \"[[], [1], [1, 1]]\");\n \n         let empty_mut: &mut [int] = &mut[];\n-        test_show_vec!(empty_mut, \"[]\".to_string());\n+        test_show_vec!(empty_mut, \"[]\");\n         let v: &mut[int] = &mut[1];\n-        test_show_vec!(v, \"[1]\".to_string());\n+        test_show_vec!(v, \"[1]\");\n         let v: &mut[int] = &mut[1, 2, 3];\n-        test_show_vec!(v, \"[1, 2, 3]\".to_string());\n+        test_show_vec!(v, \"[1, 2, 3]\");\n         let v: &mut [&mut[uint]] = &mut[&mut[], &mut[1u], &mut[1u, 1u]];\n-        test_show_vec!(v, \"[[], [1], [1, 1]]\".to_string());\n+        test_show_vec!(v, \"[[], [1], [1, 1]]\");\n     }\n \n     #[test]\n@@ -2076,20 +2755,18 @@ mod tests {\n     fn test_to_vec() {\n         let xs = box [1u, 2, 3];\n         let ys = xs.to_vec();\n-        assert_eq!(ys.as_slice(), [1u, 2, 3].as_slice());\n+        assert_eq!(ys, [1u, 2, 3]);\n     }\n }\n \n #[cfg(test)]\n mod bench {\n-    use std::prelude::*;\n+    use prelude::*;\n+    use core::mem;\n+    use core::ptr;\n     use std::rand::{weak_rng, Rng};\n-    use std::mem;\n-    use std::ptr;\n     use test::{Bencher, black_box};\n \n-    use vec::Vec;\n-\n     #[bench]\n     fn iterator(b: &mut Bencher) {\n         // peculiar numbers to stop LLVM from optimising the summation"}, {"sha": "5feae5e558edfd3baf28197a1b29ad16628792cb", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1644, "deletions": 562, "changes": 2206, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "6c2659b13f7207b8e6206b26c5169deb801ccdb8", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 357, "deletions": 154, "changes": 511, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "patch": "@@ -14,23 +14,23 @@\n \n use core::prelude::*;\n \n+use core::borrow::{Cow, IntoCow};\n use core::default::Default;\n use core::fmt;\n+use core::hash;\n use core::mem;\n use core::ptr;\n use core::ops;\n-// FIXME: ICE's abound if you import the `Slice` type while importing `Slice` trait\n use core::raw::Slice as RawSlice;\n+use unicode::str as unicode_str;\n+use unicode::str::Utf16Item;\n \n-use hash;\n-use slice::CloneSliceAllocPrelude;\n-use str;\n-use str::{CharRange, FromStr, StrAllocating, MaybeOwned, Owned};\n-use str::Slice as MaybeOwnedSlice; // So many `Slice`s...\n+use slice::CloneSliceExt;\n+use str::{mod, CharRange, FromStr, Utf8Error};\n use vec::{DerefVec, Vec, as_vec};\n \n /// A growable string stored as a UTF-8 encoded buffer.\n-#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n+#[deriving(Clone, PartialOrd, Eq, Ord)]\n #[stable]\n pub struct String {\n     vec: Vec<u8>,\n@@ -39,7 +39,7 @@ pub struct String {\n impl String {\n     /// Creates a new string buffer initialized with the empty string.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut s = String::new();\n@@ -56,7 +56,7 @@ impl String {\n     /// The string will be able to hold exactly `capacity` bytes without\n     /// reallocating. If `capacity` is 0, the string will not allocate.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut s = String::with_capacity(10);\n@@ -71,7 +71,7 @@ impl String {\n \n     /// Creates a new string buffer from the given string.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let s = String::from_str(\"hello\");\n@@ -86,44 +86,49 @@ impl String {\n     /// Returns the vector as a string buffer, if possible, taking care not to\n     /// copy it.\n     ///\n-    /// Returns `Err` with the original vector if the vector contains invalid\n-    /// UTF-8.\n+    /// # Failure\n     ///\n-    /// # Example\n+    /// If the given vector is not valid UTF-8, then the original vector and the\n+    /// corresponding error is returned.\n+    ///\n+    /// # Examples\n     ///\n     /// ```rust\n+    /// # #![allow(deprecated)]\n+    /// use std::str::Utf8Error;\n+    ///\n     /// let hello_vec = vec![104, 101, 108, 108, 111];\n     /// let s = String::from_utf8(hello_vec);\n     /// assert_eq!(s, Ok(\"hello\".to_string()));\n     ///\n     /// let invalid_vec = vec![240, 144, 128];\n     /// let s = String::from_utf8(invalid_vec);\n-    /// assert_eq!(s, Err(vec![240, 144, 128]));\n+    /// assert_eq!(s, Err((vec![240, 144, 128], Utf8Error::TooShort)));\n     /// ```\n     #[inline]\n     #[unstable = \"error type may change\"]\n-    pub fn from_utf8(vec: Vec<u8>) -> Result<String, Vec<u8>> {\n-        if str::is_utf8(vec.as_slice()) {\n-            Ok(String { vec: vec })\n-        } else {\n-            Err(vec)\n+    pub fn from_utf8(vec: Vec<u8>) -> Result<String, (Vec<u8>, Utf8Error)> {\n+        match str::from_utf8(vec.as_slice()) {\n+            Ok(..) => Ok(String { vec: vec }),\n+            Err(e) => Err((vec, e))\n         }\n     }\n \n     /// Converts a vector of bytes to a new UTF-8 string.\n     /// Any invalid UTF-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// let input = b\"Hello \\xF0\\x90\\x80World\";\n     /// let output = String::from_utf8_lossy(input);\n-    /// assert_eq!(output.as_slice(), \"Hello \\uFFFDWorld\");\n+    /// assert_eq!(output.as_slice(), \"Hello \\u{FFFD}World\");\n     /// ```\n     #[unstable = \"return type may change\"]\n-    pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n-        if str::is_utf8(v) {\n-            return MaybeOwnedSlice(unsafe { mem::transmute(v) })\n+    pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> CowString<'a> {\n+        match str::from_utf8(v) {\n+            Ok(s) => return Cow::Borrowed(s),\n+            Err(..) => {}\n         }\n \n         static TAG_CONT_U8: u8 = 128u8;\n@@ -167,12 +172,12 @@ impl String {\n                     subseqidx = i;\n                     res.as_mut_vec().push_all(REPLACEMENT);\n                 }\n-            }))\n+            }));\n \n             if byte < 128u8 {\n                 // subseqidx handles this\n             } else {\n-                let w = str::utf8_char_width(byte);\n+                let w = unicode_str::utf8_char_width(byte);\n \n                 match w {\n                     2 => {\n@@ -234,13 +239,13 @@ impl String {\n                 res.as_mut_vec().push_all(v[subseqidx..total])\n             };\n         }\n-        Owned(res.into_string())\n+        Cow::Owned(res)\n     }\n \n     /// Decode a UTF-16 encoded vector `v` into a `String`, returning `None`\n     /// if `v` contains any invalid data.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// // \ud834\udd1emusic\n@@ -255,10 +260,10 @@ impl String {\n     #[unstable = \"error value in return may change\"]\n     pub fn from_utf16(v: &[u16]) -> Option<String> {\n         let mut s = String::with_capacity(v.len());\n-        for c in str::utf16_items(v) {\n+        for c in unicode_str::utf16_items(v) {\n             match c {\n-                str::ScalarValue(c) => s.push(c),\n-                str::LoneSurrogate(_) => return None\n+                Utf16Item::ScalarValue(c) => s.push(c),\n+                Utf16Item::LoneSurrogate(_) => return None\n             }\n         }\n         Some(s)\n@@ -267,24 +272,25 @@ impl String {\n     /// Decode a UTF-16 encoded vector `v` into a string, replacing\n     /// invalid data with the replacement character (U+FFFD).\n     ///\n-    /// # Example\n+    /// # Examples\n+    ///\n     /// ```rust\n     /// // \ud834\udd1emus<invalid>ic<invalid>\n     /// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n     ///           0x0073, 0xDD1E, 0x0069, 0x0063,\n     ///           0xD834];\n     ///\n     /// assert_eq!(String::from_utf16_lossy(v),\n-    ///            \"\ud834\udd1emus\\uFFFDic\\uFFFD\".to_string());\n+    ///            \"\ud834\udd1emus\\u{FFFD}ic\\u{FFFD}\".to_string());\n     /// ```\n     #[stable]\n     pub fn from_utf16_lossy(v: &[u16]) -> String {\n-        str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n+        unicode_str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n     }\n \n     /// Convert a vector of `char`s to a `String`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// let chars = &['h', 'e', 'l', 'l', 'o'];\n@@ -297,9 +303,55 @@ impl String {\n         chs.iter().map(|c| *c).collect()\n     }\n \n+    /// Creates a new `String` from a length, capacity, and pointer.\n+    ///\n+    /// This is unsafe because:\n+    /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`;\n+    /// * We assume that the `Vec` contains valid UTF-8.\n+    #[inline]\n+    #[unstable = \"function just moved from string::raw\"]\n+    pub unsafe fn from_raw_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n+        String {\n+            vec: Vec::from_raw_parts(buf, length, capacity),\n+        }\n+    }\n+\n+    /// Creates a `String` from a null-terminated `*const u8` buffer.\n+    ///\n+    /// This function is unsafe because we dereference memory until we find the\n+    /// NUL character, which is not guaranteed to be present. Additionally, the\n+    /// slice is not checked to see whether it contains valid UTF-8\n+    #[unstable = \"just renamed from `mod raw`\"]\n+    pub unsafe fn from_raw_buf(buf: *const u8) -> String {\n+        String::from_str(str::from_c_str(buf as *const i8))\n+    }\n+\n+    /// Creates a `String` from a `*const u8` buffer of the given length.\n+    ///\n+    /// This function is unsafe because it blindly assumes the validity of the\n+    /// pointer `buf` for `len` bytes of memory. This function will copy the\n+    /// memory from `buf` into a new allocation (owned by the returned\n+    /// `String`).\n+    ///\n+    /// This function is also unsafe because it does not validate that the\n+    /// buffer is valid UTF-8 encoded data.\n+    #[unstable = \"just renamed from `mod raw`\"]\n+    pub unsafe fn from_raw_buf_len(buf: *const u8, len: uint) -> String {\n+        String::from_utf8_unchecked(Vec::from_raw_buf(buf, len))\n+    }\n+\n+    /// Converts a vector of bytes to a new `String` without checking if\n+    /// it contains valid UTF-8. This is unsafe because it assumes that\n+    /// the UTF-8-ness of the vector has already been validated.\n+    #[inline]\n+    #[unstable = \"awaiting stabilization\"]\n+    pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {\n+        String { vec: bytes }\n+    }\n+\n     /// Return the underlying byte buffer, encoded as UTF-8.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let s = String::from_str(\"hello\");\n@@ -314,7 +366,7 @@ impl String {\n \n     /// Creates a string buffer by repeating a character `length` times.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let s = String::from_char(5, 'a');\n@@ -340,7 +392,7 @@ impl String {\n \n     /// Pushes the given string onto this string buffer.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"foo\");\n@@ -355,7 +407,7 @@ impl String {\n \n     /// Pushes `ch` onto the given string `count` times.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"foo\");\n@@ -372,7 +424,7 @@ impl String {\n \n     /// Returns the number of bytes that this string buffer can hold without reallocating.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let s = String::with_capacity(10);\n@@ -397,7 +449,7 @@ impl String {\n     ///\n     /// Panics if the new capacity overflows `uint`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut s = String::new();\n@@ -421,7 +473,7 @@ impl String {\n     ///\n     /// Panics if the new capacity overflows `uint`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut s = String::new();\n@@ -436,7 +488,7 @@ impl String {\n \n     /// Shrinks the capacity of this string buffer to match its length.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"foo\");\n@@ -453,7 +505,7 @@ impl String {\n \n     /// Adds the given character to the end of the string.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"abc\");\n@@ -465,6 +517,11 @@ impl String {\n     #[inline]\n     #[stable = \"function just renamed from push_char\"]\n     pub fn push(&mut self, ch: char) {\n+        if (ch as u32) < 0x80 {\n+            self.vec.push(ch as u8);\n+            return;\n+        }\n+\n         let cur_len = self.len();\n         // This may use up to 4 bytes.\n         self.vec.reserve(4);\n@@ -483,7 +540,7 @@ impl String {\n \n     /// Works with the underlying buffer as a byte slice.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let s = String::from_str(\"hello\");\n@@ -503,7 +560,7 @@ impl String {\n     /// Panics if `new_len` > current length,\n     /// or if `new_len` is not a character boundary.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"hello\");\n@@ -513,14 +570,14 @@ impl String {\n     #[inline]\n     #[unstable = \"the panic conventions for strings are under development\"]\n     pub fn truncate(&mut self, new_len: uint) {\n-        assert!(self.as_slice().is_char_boundary(new_len));\n+        assert!(self.is_char_boundary(new_len));\n         self.vec.truncate(new_len)\n     }\n \n     /// Removes the last character from the string buffer and returns it.\n     /// Returns `None` if this string buffer is empty.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"foo\");\n@@ -537,7 +594,7 @@ impl String {\n             return None\n         }\n \n-        let CharRange {ch, next} = self.as_slice().char_range_at_reverse(len);\n+        let CharRange {ch, next} = self.char_range_at_reverse(len);\n         unsafe {\n             self.vec.set_len(next);\n         }\n@@ -557,7 +614,7 @@ impl String {\n     /// If `idx` does not lie on a character boundary, then this function will\n     /// panic.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"foo\");\n@@ -572,7 +629,7 @@ impl String {\n         let len = self.len();\n         if idx >= len { return None }\n \n-        let CharRange { ch, next } = self.as_slice().char_range_at(idx);\n+        let CharRange { ch, next } = self.char_range_at(idx);\n         unsafe {\n             ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as int),\n                              self.vec.as_ptr().offset(next as int),\n@@ -597,7 +654,7 @@ impl String {\n     pub fn insert(&mut self, idx: uint, ch: char) {\n         let len = self.len();\n         assert!(idx <= len);\n-        assert!(self.as_slice().is_char_boundary(idx));\n+        assert!(self.is_char_boundary(idx));\n         self.vec.reserve(4);\n         let mut bits = [0, ..4];\n         let amt = ch.encode_utf8(&mut bits).unwrap();\n@@ -618,7 +675,7 @@ impl String {\n     /// This is unsafe because it does not check\n     /// to ensure that the resulting string will be valid UTF-8.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"hello\");\n@@ -636,7 +693,7 @@ impl String {\n \n     /// Return the number of bytes in this string.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let a = \"foo\".to_string();\n@@ -648,7 +705,7 @@ impl String {\n \n     /// Returns true if the string contains no bytes\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut v = String::new();\n@@ -660,7 +717,7 @@ impl String {\n \n     /// Truncates the string, returning it to 0 length.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut s = \"foo\".to_string();\n@@ -683,36 +740,94 @@ impl FromIterator<char> for String {\n     }\n }\n \n+#[experimental = \"waiting on FromIterator stabilization\"]\n+impl<'a> FromIterator<&'a str> for String {\n+    fn from_iter<I:Iterator<&'a str>>(iterator: I) -> String {\n+        let mut buf = String::new();\n+        buf.extend(iterator);\n+        buf\n+    }\n+}\n+\n #[experimental = \"waiting on Extend stabilization\"]\n impl Extend<char> for String {\n     fn extend<I:Iterator<char>>(&mut self, mut iterator: I) {\n+        let (lower_bound, _) = iterator.size_hint();\n+        self.reserve(lower_bound);\n         for ch in iterator {\n             self.push(ch)\n         }\n     }\n }\n \n-#[experimental = \"waiting on Str stabilization\"]\n-impl Str for String {\n+#[experimental = \"waiting on Extend stabilization\"]\n+impl<'a> Extend<&'a str> for String {\n+    fn extend<I: Iterator<&'a str>>(&mut self, mut iterator: I) {\n+        // A guess that at least one byte per iterator element will be needed.\n+        let (lower_bound, _) = iterator.size_hint();\n+        self.reserve(lower_bound);\n+        for s in iterator {\n+            self.push_str(s)\n+        }\n+    }\n+}\n+\n+impl PartialEq for String {\n     #[inline]\n-    #[stable]\n-    fn as_slice<'a>(&'a self) -> &'a str {\n-        unsafe {\n-            mem::transmute(self.vec.as_slice())\n+    fn eq(&self, other: &String) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &String) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+macro_rules! impl_eq {\n+    ($lhs:ty, $rhs: ty) => {\n+        impl<'a> PartialEq<$rhs> for $lhs {\n+            #[inline]\n+            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+\n+        impl<'a> PartialEq<$lhs> for $rhs {\n+            #[inline]\n+            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&**self, &**other) }\n         }\n+\n     }\n }\n \n-#[experimental = \"waiting on StrAllocating stabilization\"]\n-impl StrAllocating for String {\n+impl_eq! { String, &'a str }\n+impl_eq! { CowString<'a>, String }\n+\n+impl<'a, 'b> PartialEq<&'b str> for CowString<'a> {\n     #[inline]\n-    fn into_string(self) -> String {\n-        self\n+    fn eq(&self, other: &&'b str) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &&'b str) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n+    #[inline]\n+    fn eq(&self, other: &CowString<'a>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &CowString<'a>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+#[experimental = \"waiting on Str stabilization\"]\n+#[allow(deprecated)]\n+impl Str for String {\n+    #[inline]\n+    #[stable]\n+    fn as_slice<'a>(&'a self) -> &'a str {\n+        unsafe { mem::transmute(self.vec.as_slice()) }\n     }\n }\n \n #[stable]\n impl Default for String {\n+    #[stable]\n     fn default() -> String {\n         String::new()\n     }\n@@ -721,19 +836,20 @@ impl Default for String {\n #[experimental = \"waiting on Show stabilization\"]\n impl fmt::Show for String {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.as_slice().fmt(f)\n+        (**self).fmt(f)\n     }\n }\n \n #[experimental = \"waiting on Hash stabilization\"]\n impl<H: hash::Writer> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n-        self.as_slice().hash(hasher)\n+        (**self).hash(hasher)\n     }\n }\n \n-#[experimental = \"waiting on Equiv stabilization\"]\n+#[allow(deprecated)]\n+#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n impl<'a, S: Str> Equiv<S> for String {\n     #[inline]\n     fn equiv(&self, other: &S) -> bool {\n@@ -742,18 +858,17 @@ impl<'a, S: Str> Equiv<S> for String {\n }\n \n #[experimental = \"waiting on Add stabilization\"]\n-impl<S: Str> Add<S, String> for String {\n-    fn add(&self, other: &S) -> String {\n-        let mut s = String::from_str(self.as_slice());\n-        s.push_str(other.as_slice());\n-        return s;\n+impl<'a> Add<&'a str, String> for String {\n+    fn add(mut self, other: &str) -> String {\n+        self.push_str(other);\n+        self\n     }\n }\n \n impl ops::Slice<uint, str> for String {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a str {\n-        self.as_slice()\n+        unsafe { mem::transmute(self.vec.as_slice()) }\n     }\n \n     #[inline]\n@@ -774,7 +889,9 @@ impl ops::Slice<uint, str> for String {\n \n #[experimental = \"waiting on Deref stabilization\"]\n impl ops::Deref<str> for String {\n-    fn deref<'a>(&'a self) -> &'a str { self.as_slice() }\n+    fn deref<'a>(&'a self) -> &'a str {\n+        unsafe { mem::transmute(self.vec[]) }\n+    }\n }\n \n /// Wrapper type providing a `&String` reference via `Deref`.\n@@ -790,6 +907,19 @@ impl<'a> Deref<String> for DerefString<'a> {\n }\n \n /// Convert a string slice to a wrapper type providing a `&String` reference.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::string::as_string;\n+///\n+/// fn string_consumer(s: String) {\n+///     assert_eq!(s, \"foo\".to_string());\n+/// }\n+///\n+/// let string = as_string(\"foo\").clone();\n+/// string_consumer(string);\n+/// ```\n #[experimental]\n pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {\n     DerefString { x: as_vec(x.as_bytes()) }\n@@ -822,13 +952,21 @@ impl<T: fmt::Show> ToString for T {\n     }\n }\n \n+impl IntoCow<'static, String, str> for String {\n+    fn into_cow(self) -> CowString<'static> {\n+        Cow::Owned(self)\n+    }\n+}\n+\n+impl<'a> IntoCow<'a, String, str> for &'a str {\n+    fn into_cow(self) -> CowString<'a> {\n+        Cow::Borrowed(self)\n+    }\n+}\n+\n /// Unsafe operations\n-#[unstable = \"waiting on raw module conventions\"]\n+#[deprecated]\n pub mod raw {\n-    use core::mem;\n-    use core::ptr::RawPtr;\n-    use core::raw::Slice;\n-\n     use super::String;\n     use vec::Vec;\n \n@@ -838,58 +976,62 @@ pub mod raw {\n     /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`;\n     /// * We assume that the `Vec` contains valid UTF-8.\n     #[inline]\n+    #[deprecated = \"renamed to String::from_raw_parts\"]\n     pub unsafe fn from_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n-        String {\n-            vec: Vec::from_raw_parts(buf, length, capacity),\n-        }\n+        String::from_raw_parts(buf, length, capacity)\n     }\n \n     /// Creates a `String` from a `*const u8` buffer of the given length.\n     ///\n     /// This function is unsafe because of two reasons:\n+    ///\n     /// * A raw pointer is dereferenced and transmuted to `&[u8]`;\n     /// * The slice is not checked to see whether it contains valid UTF-8.\n+    #[deprecated = \"renamed to String::from_raw_buf_len\"]\n     pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> String {\n-        use slice::CloneSliceAllocPrelude;\n-        let slice: &[u8] = mem::transmute(Slice {\n-            data: buf,\n-            len: len,\n-        });\n-        self::from_utf8(slice.to_vec())\n+        String::from_raw_buf_len(buf, len)\n     }\n \n     /// Creates a `String` from a null-terminated `*const u8` buffer.\n     ///\n     /// This function is unsafe because we dereference memory until we find the NUL character,\n     /// which is not guaranteed to be present. Additionally, the slice is not checked to see\n     /// whether it contains valid UTF-8\n+    #[deprecated = \"renamed to String::from_raw_buf\"]\n     pub unsafe fn from_buf(buf: *const u8) -> String {\n-        let mut len = 0;\n-        while *buf.offset(len) != 0 {\n-            len += 1;\n-        }\n-        self::from_buf_len(buf, len as uint)\n+        String::from_raw_buf(buf)\n     }\n \n     /// Converts a vector of bytes to a new `String` without checking if\n     /// it contains valid UTF-8. This is unsafe because it assumes that\n     /// the UTF-8-ness of the vector has already been validated.\n     #[inline]\n+    #[deprecated = \"renamed to String::from_utf8_unchecked\"]\n     pub unsafe fn from_utf8(bytes: Vec<u8>) -> String {\n-        String { vec: bytes }\n+        String::from_utf8_unchecked(bytes)\n+    }\n+}\n+\n+/// A clone-on-write string\n+#[stable]\n+pub type CowString<'a> = Cow<'a, String, str>;\n+\n+#[allow(deprecated)]\n+impl<'a> Str for CowString<'a> {\n+    #[inline]\n+    fn as_slice<'b>(&'b self) -> &'b str {\n+        (**self).as_slice()\n     }\n }\n \n #[cfg(test)]\n mod tests {\n-    use std::prelude::*;\n+    use prelude::*;\n     use test::Bencher;\n \n+    use str::{StrExt, Utf8Error};\n     use str;\n-    use str::{Str, StrPrelude, Owned};\n-    use super::{as_string, String, ToString};\n-    use vec::Vec;\n-    use slice::CloneSliceAllocPrelude;\n+    use super::as_string;\n \n     #[test]\n     fn test_as_string() {\n@@ -906,52 +1048,56 @@ mod tests {\n     #[test]\n     fn test_from_utf8() {\n         let xs = b\"hello\".to_vec();\n-        assert_eq!(String::from_utf8(xs), Ok(String::from_str(\"hello\")));\n+        assert_eq!(String::from_utf8(xs),\n+                   Ok(String::from_str(\"hello\")));\n \n         let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes().to_vec();\n-        assert_eq!(String::from_utf8(xs), Ok(String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\")));\n+        assert_eq!(String::from_utf8(xs),\n+                   Ok(String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\")));\n \n         let xs = b\"hello\\xFF\".to_vec();\n         assert_eq!(String::from_utf8(xs),\n-                   Err(b\"hello\\xFF\".to_vec()));\n+                   Err((b\"hello\\xFF\".to_vec(), Utf8Error::TooShort)));\n     }\n \n     #[test]\n     fn test_from_utf8_lossy() {\n         let xs = b\"hello\";\n-        assert_eq!(String::from_utf8_lossy(xs), str::Slice(\"hello\"));\n+        let ys: str::CowString = \"hello\".into_cow();\n+        assert_eq!(String::from_utf8_lossy(xs), ys);\n \n         let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n-        assert_eq!(String::from_utf8_lossy(xs), str::Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+        let ys: str::CowString = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".into_cow();\n+        assert_eq!(String::from_utf8_lossy(xs), ys);\n \n         let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n         assert_eq!(String::from_utf8_lossy(xs),\n-                   Owned(String::from_str(\"Hello\\uFFFD There\\uFFFD Goodbye\")));\n+                   String::from_str(\"Hello\\u{FFFD} There\\u{FFFD} Goodbye\").into_cow());\n \n         let xs = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n         assert_eq!(String::from_utf8_lossy(xs),\n-                   Owned(String::from_str(\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\")));\n+                   String::from_str(\"Hello\\u{FFFD}\\u{FFFD} There\\u{FFFD} Goodbye\").into_cow());\n \n         let xs = b\"\\xF5foo\\xF5\\x80bar\";\n         assert_eq!(String::from_utf8_lossy(xs),\n-                   Owned(String::from_str(\"\\uFFFDfoo\\uFFFD\\uFFFDbar\")));\n+                   String::from_str(\"\\u{FFFD}foo\\u{FFFD}\\u{FFFD}bar\").into_cow());\n \n         let xs = b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\";\n         assert_eq!(String::from_utf8_lossy(xs),\n-                   Owned(String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\")));\n+                   String::from_str(\"\\u{FFFD}foo\\u{FFFD}bar\\u{FFFD}baz\").into_cow());\n \n         let xs = b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\";\n         assert_eq!(String::from_utf8_lossy(xs),\n-                   Owned(String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\")));\n+                   String::from_str(\"\\u{FFFD}foo\\u{FFFD}bar\\u{FFFD}\\u{FFFD}baz\").into_cow());\n \n         let xs = b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\";\n-        assert_eq!(String::from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\\n-                                               foo\\U00010000bar\")));\n+        assert_eq!(String::from_utf8_lossy(xs), String::from_str(\"\\u{FFFD}\\u{FFFD}\\u{FFFD}\\u{FFFD}\\\n+                                               foo\\u{10000}bar\").into_cow());\n \n         // surrogates\n         let xs = b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\";\n-        assert_eq!(String::from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFD\\uFFFD\\uFFFDfoo\\\n-                                               \\uFFFD\\uFFFD\\uFFFDbar\")));\n+        assert_eq!(String::from_utf8_lossy(xs), String::from_str(\"\\u{FFFD}\\u{FFFD}\\u{FFFD}foo\\\n+                                               \\u{FFFD}\\u{FFFD}\\u{FFFD}bar\").into_cow());\n     }\n \n     #[test]\n@@ -993,22 +1139,22 @@ mod tests {\n                 0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n                 0x000a_u16 ]),\n              // Issue #12318, even-numbered non-BMP planes\n-             (String::from_str(\"\\U00020000\"),\n+             (String::from_str(\"\\u{20000}\"),\n               vec![0xD840, 0xDC00])];\n \n         for p in pairs.iter() {\n             let (s, u) = (*p).clone();\n-            let s_as_utf16 = s.as_slice().utf16_units().collect::<Vec<u16>>();\n+            let s_as_utf16 = s.utf16_units().collect::<Vec<u16>>();\n             let u_as_string = String::from_utf16(u.as_slice()).unwrap();\n \n-            assert!(str::is_utf16(u.as_slice()));\n+            assert!(::unicode::str::is_utf16(u.as_slice()));\n             assert_eq!(s_as_utf16, u);\n \n             assert_eq!(u_as_string, s);\n             assert_eq!(String::from_utf16_lossy(u.as_slice()), s);\n \n             assert_eq!(String::from_utf16(s_as_utf16.as_slice()).unwrap(), s);\n-            assert_eq!(u_as_string.as_slice().utf16_units().collect::<Vec<u16>>(), u);\n+            assert_eq!(u_as_string.utf16_units().collect::<Vec<u16>>(), u);\n         }\n     }\n \n@@ -1031,16 +1177,17 @@ mod tests {\n     fn test_from_utf16_lossy() {\n         // completely positive cases tested above.\n         // lead + eof\n-        assert_eq!(String::from_utf16_lossy(&[0xD800]), String::from_str(\"\\uFFFD\"));\n+        assert_eq!(String::from_utf16_lossy(&[0xD800]), String::from_str(\"\\u{FFFD}\"));\n         // lead + lead\n-        assert_eq!(String::from_utf16_lossy(&[0xD800, 0xD800]), String::from_str(\"\\uFFFD\\uFFFD\"));\n+        assert_eq!(String::from_utf16_lossy(&[0xD800, 0xD800]),\n+                   String::from_str(\"\\u{FFFD}\\u{FFFD}\"));\n \n         // isolated trail\n-        assert_eq!(String::from_utf16_lossy(&[0x0061, 0xDC00]), String::from_str(\"a\\uFFFD\"));\n+        assert_eq!(String::from_utf16_lossy(&[0x0061, 0xDC00]), String::from_str(\"a\\u{FFFD}\"));\n \n         // general\n         assert_eq!(String::from_utf16_lossy(&[0xD800, 0xd801, 0xdc8b, 0xD800]),\n-                   String::from_str(\"\\uFFFD\ud801\udc8b\\uFFFD\"));\n+                   String::from_str(\"\\u{FFFD}\ud801\udc8b\\u{FFFD}\"));\n     }\n \n     #[test]\n@@ -1068,18 +1215,18 @@ mod tests {\n             let mv = s.as_mut_vec();\n             mv.push_all(&[b'D']);\n         }\n-        assert_eq!(s.as_slice(), \"ABCD\");\n+        assert_eq!(s, \"ABCD\");\n     }\n \n     #[test]\n     fn test_push_str() {\n         let mut s = String::new();\n         s.push_str(\"\");\n-        assert_eq!(s.as_slice().slice_from(0), \"\");\n+        assert_eq!(s.slice_from(0), \"\");\n         s.push_str(\"abc\");\n-        assert_eq!(s.as_slice().slice_from(0), \"abc\");\n+        assert_eq!(s.slice_from(0), \"abc\");\n         s.push_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(s.as_slice().slice_from(0), \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        assert_eq!(s.slice_from(0), \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n     }\n \n     #[test]\n@@ -1090,7 +1237,7 @@ mod tests {\n         data.push('\u00a2'); // 2 byte\n         data.push('\u20ac'); // 3 byte\n         data.push('\ud852\udf62'); // 4 byte\n-        assert_eq!(data.as_slice(), \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\");\n+        assert_eq!(data, \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\");\n     }\n \n     #[test]\n@@ -1101,24 +1248,24 @@ mod tests {\n         assert_eq!(data.pop().unwrap(), '\u00a2'); // 2 bytes\n         assert_eq!(data.pop().unwrap(), 'b'); // 1 bytes\n         assert_eq!(data.pop().unwrap(), '\u534e');\n-        assert_eq!(data.as_slice(), \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n+        assert_eq!(data, \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n     }\n \n     #[test]\n     fn test_str_truncate() {\n         let mut s = String::from_str(\"12345\");\n         s.truncate(5);\n-        assert_eq!(s.as_slice(), \"12345\");\n+        assert_eq!(s, \"12345\");\n         s.truncate(3);\n-        assert_eq!(s.as_slice(), \"123\");\n+        assert_eq!(s, \"123\");\n         s.truncate(0);\n-        assert_eq!(s.as_slice(), \"\");\n+        assert_eq!(s, \"\");\n \n         let mut s = String::from_str(\"12345\");\n-        let p = s.as_slice().as_ptr();\n+        let p = s.as_ptr();\n         s.truncate(3);\n         s.push_str(\"6\");\n-        let p_ = s.as_slice().as_ptr();\n+        let p_ = s.as_ptr();\n         assert_eq!(p_, p);\n     }\n \n@@ -1132,7 +1279,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_str_truncate_split_codepoint() {\n-        let mut s = String::from_str(\"\\u00FC\"); // \u00fc\n+        let mut s = String::from_str(\"\\u{FC}\"); // \u00fc\n         s.truncate(1);\n     }\n \n@@ -1141,28 +1288,28 @@ mod tests {\n         let mut s = String::from_str(\"12345\");\n         s.clear();\n         assert_eq!(s.len(), 0);\n-        assert_eq!(s.as_slice(), \"\");\n+        assert_eq!(s, \"\");\n     }\n \n     #[test]\n     fn test_str_add() {\n         let a = String::from_str(\"12345\");\n         let b = a + \"2\";\n-        let b = b + String::from_str(\"2\");\n+        let b = b + \"2\";\n         assert_eq!(b.len(), 7);\n-        assert_eq!(b.as_slice(), \"1234522\");\n+        assert_eq!(b, \"1234522\");\n     }\n \n     #[test]\n     fn remove() {\n         let mut s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\".to_string();;\n         assert_eq!(s.remove(0), Some('\u0e28'));\n         assert_eq!(s.len(), 33);\n-        assert_eq!(s.as_slice(), \"\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\");\n+        assert_eq!(s, \"\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\");\n         assert_eq!(s.remove(33), None);\n         assert_eq!(s.remove(300), None);\n         assert_eq!(s.remove(17), Some('\u1ec7'));\n-        assert_eq!(s.as_slice(), \"\u0e44\u0e17\u0e22\u4e2d\u534eVit Nam; foobar\");\n+        assert_eq!(s, \"\u0e44\u0e17\u0e22\u4e2d\u534eVit Nam; foobar\");\n     }\n \n     #[test] #[should_fail]\n@@ -1174,9 +1321,9 @@ mod tests {\n     fn insert() {\n         let mut s = \"foobar\".to_string();\n         s.insert(0, '\u1ec7');\n-        assert_eq!(s.as_slice(), \"\u1ec7foobar\");\n+        assert_eq!(s, \"\u1ec7foobar\");\n         s.insert(6, '\u0e22');\n-        assert_eq!(s.as_slice(), \"\u1ec7foo\u0e22bar\");\n+        assert_eq!(s, \"\u1ec7foo\u0e22bar\");\n     }\n \n     #[test] #[should_fail] fn insert_bad1() { \"\".to_string().insert(1, 't'); }\n@@ -1193,24 +1340,45 @@ mod tests {\n \n     #[test]\n     fn test_simple_types() {\n-        assert_eq!(1i.to_string(), \"1\".to_string());\n-        assert_eq!((-1i).to_string(), \"-1\".to_string());\n-        assert_eq!(200u.to_string(), \"200\".to_string());\n-        assert_eq!(2u8.to_string(), \"2\".to_string());\n-        assert_eq!(true.to_string(), \"true\".to_string());\n-        assert_eq!(false.to_string(), \"false\".to_string());\n-        assert_eq!(().to_string(), \"()\".to_string());\n-        assert_eq!((\"hi\".to_string()).to_string(), \"hi\".to_string());\n+        assert_eq!(1i.to_string(), \"1\");\n+        assert_eq!((-1i).to_string(), \"-1\");\n+        assert_eq!(200u.to_string(), \"200\");\n+        assert_eq!(2u8.to_string(), \"2\");\n+        assert_eq!(true.to_string(), \"true\");\n+        assert_eq!(false.to_string(), \"false\");\n+        assert_eq!(().to_string(), \"()\");\n+        assert_eq!((\"hi\".to_string()).to_string(), \"hi\");\n     }\n \n     #[test]\n     fn test_vectors() {\n         let x: Vec<int> = vec![];\n-        assert_eq!(x.to_string(), \"[]\".to_string());\n-        assert_eq!((vec![1i]).to_string(), \"[1]\".to_string());\n-        assert_eq!((vec![1i, 2, 3]).to_string(), \"[1, 2, 3]\".to_string());\n+        assert_eq!(x.to_string(), \"[]\");\n+        assert_eq!((vec![1i]).to_string(), \"[1]\");\n+        assert_eq!((vec![1i, 2, 3]).to_string(), \"[1, 2, 3]\");\n         assert!((vec![vec![], vec![1i], vec![1i, 1]]).to_string() ==\n-               \"[[], [1], [1, 1]]\".to_string());\n+               \"[[], [1], [1, 1]]\");\n+    }\n+\n+    #[test]\n+    fn test_from_iterator() {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_string();\n+        let t = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let u = \"Vi\u1ec7t Nam\";\n+\n+        let a: String = s.chars().collect();\n+        assert_eq!(s, a);\n+\n+        let mut b = t.to_string();\n+        b.extend(u.chars());\n+        assert_eq!(s, b);\n+\n+        let c: String = vec![t, u].into_iter().collect();\n+        assert_eq!(s, c);\n+\n+        let mut d = t.to_string();\n+        d.extend(vec![u].into_iter());\n+        assert_eq!(s, d);\n     }\n \n     #[bench]\n@@ -1229,6 +1397,41 @@ mod tests {\n         });\n     }\n \n+    const REPETITIONS: u64 = 10_000;\n+\n+    #[bench]\n+    fn bench_push_str_one_byte(b: &mut Bencher) {\n+        b.bytes = REPETITIONS;\n+        b.iter(|| {\n+            let mut r = String::new();\n+            for _ in range(0, REPETITIONS) {\n+                r.push_str(\"a\")\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_push_char_one_byte(b: &mut Bencher) {\n+        b.bytes = REPETITIONS;\n+        b.iter(|| {\n+            let mut r = String::new();\n+            for _ in range(0, REPETITIONS) {\n+                r.push('a')\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_push_char_two_bytes(b: &mut Bencher) {\n+        b.bytes = REPETITIONS * 2;\n+        b.iter(|| {\n+            let mut r = String::new();\n+            for _ in range(0, REPETITIONS) {\n+                r.push('\u00e2')\n+            }\n+        });\n+    }\n+\n     #[bench]\n     fn from_utf8_lossy_100_ascii(b: &mut Bencher) {\n         let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\"}, {"sha": "119268c27eeac9814637396c4481a2af7240c269", "filename": "src/libcollections/tree/map.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcollections%2Ftree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcollections%2Ftree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmap.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "20823a2affc7f5d73fd887a23bf81b9b932089d2", "filename": "src/libcollections/tree/mod.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcollections%2Ftree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcollections%2Ftree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmod.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "6988b929df689ef3b1d259ab5c7fe22bda90f574", "filename": "src/libcollections/tree/set.rs", "status": "removed", "additions": 0, "deletions": 985, "changes": 985, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcollections%2Ftree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcollections%2Ftree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fset.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "672ddab4d87e097c875c5723d44388b58f282ecb", "filename": "src/libcollections/trie/map.rs", "status": "removed", "additions": 0, "deletions": 1953, "changes": 1953, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcollections%2Ftrie%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcollections%2Ftrie%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmap.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "9dcb182cd267570b259926cb1993bfbdc0f27527", "filename": "src/libcollections/trie/mod.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcollections%2Ftrie%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcollections%2Ftrie%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmod.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "f40c0db5edf99691211ee0e7604e7a049c4ba8a8", "filename": "src/libcollections/trie/set.rs", "status": "removed", "additions": 0, "deletions": 474, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcollections%2Ftrie%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcollections%2Ftrie%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fset.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "fa0e4a2340e2aac37cad0a601e384b6efd4b44aa", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 499, "deletions": 184, "changes": 683, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "659c68c42ddac8c18e7b6e04edaffb0857c7688f", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 163, "deletions": 79, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "75feb4d88289e5faf1343176b6eb3c1f3b7327ee", "filename": "src/libcore/any.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "e85a132ed363f5a2e6c85dceef701117913118ef", "filename": "src/libcore/array.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "f6bc4dbde387ae35a13bcf88ee1439ef8f2b9077", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "9bbcf67773ebbc966bc9081ea1bde77e0dbf34de", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 118, "deletions": 9, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "b45424a5eed3f7d4209e62880fd653eed298cbe5", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 108, "deletions": 70, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "9c12b3f68d3de71603f732bdb14a3448d88c554c", "filename": "src/libcore/char.rs", "status": "modified", "additions": 79, "deletions": 83, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "686ccf6f1a2513c25e2c7dfd5aa2265d11b90ccb", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "ca523db214b0c50b444b8abad74e90a422a41ba5", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 54, "deletions": 37, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "0632ffd9c698cc6ca9357dad52231941d5041d25", "filename": "src/libcore/default.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "2b48b2bf81afbd25563ac6b1a07697ebbb239784", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 65, "deletions": 76, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "55a87973e0f5c2d7767182e80f727d9e4a11aa3d", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 45, "deletions": 42, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "fb26450ec758e063bb726af2811b2162ec81a958", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 94, "deletions": 59, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "cd8f226172a66e49ecbd1b0b3d398dbf29f992cb", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "35dd0390f30872bb64709c3a0ec882e127434e9d", "filename": "src/libcore/fmt/rt.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "c1aa605a4558b05e15fe0b244703c4d6b38011b0", "filename": "src/libcore/hash/mod.rs", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "ab6b0986c686df72b92a04b0aa93a2faa7d06cf6", "filename": "src/libcore/hash/sip.rs", "status": "renamed", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "previous_filename": "src/libcollections/hash/sip.rs"}, {"sha": "950c47c636987082964acdc9c679c0da12994cac", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "9c3e53a1aceebd7437ddff9b107fe2dbee7d247a", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 666, "deletions": 236, "changes": 902, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "b0f46e3d68c908a1850962274d83ba5007f03945", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "9de723f38ee97fbd45ff614c9a60cc35c41085b8", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "7ce1da7d2d0f27aefdadade836ae38e5f506d28c", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "2620928acc1acca5070786ac304568f20dbb194d", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 148, "deletions": 49, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "d8b22a085aa94da348aa26ead942c511cb1d335c", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "a3f5c2df91fac8e839cdca30e7d6a4487c1c646e", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "97de61d7e272eebb0becea999c7f39770bda8a96", "filename": "src/libcore/num/float_macros.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat_macros.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "eb2a4c3835d5a2c7c259b88d6f13ce893f922ee3", "filename": "src/libcore/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "849fa205756bb048ae65622a1ad349601690586c", "filename": "src/libcore/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "b6cba728e447f635de7626fb1b722983d3fb54ad", "filename": "src/libcore/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "fd0759898ea2d0c74bfee6f3c9c4d2073bdc2c7f", "filename": "src/libcore/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "91c5e4163f9e598ded24217da81749c648309a81", "filename": "src/libcore/num/int.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "522eab9180c86bce7bc2c85d575ccb143c922630", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "0d2ce4f60718f8faba2e1a961c3e0c9cf8dc2fae", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 168, "deletions": 174, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "730a24a963a561f4ad6d8a92eea36c7939ead959", "filename": "src/libcore/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "f308122af438dfc74a5727b3872daee8dc108786", "filename": "src/libcore/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "a55868eb7468fa6c60a55f4347f9f2e6cc5b7096", "filename": "src/libcore/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "8643f8ad6502865d480f1871d57fd22afd7b0692", "filename": "src/libcore/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "35739f68da9697af17efd96a5321b23afc112a56", "filename": "src/libcore/num/uint.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "82eca0d46598204a08f0aa63ce0f447207f76f10", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "0cd8c1d69d1a1e06677f75856dcbe7df4702e570", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 783, "deletions": 698, "changes": 1481, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "d831a57893bd77754980a174b6ff9d9452e507c4", "filename": "src/libcore/option.rs", "status": "modified", "additions": 109, "deletions": 45, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "f6abc8da79c0c9d1ddb6bbea9445d4f56a7f035b", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "b226d4a6de45d1e5e0e6665a6910e21558db048f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 116, "deletions": 45, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "d70c96d8c16623cee38642b472bc447ae3a2aa1a", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "8014b4dc89d70e10faf55286c45e1bc71885e157", "filename": "src/libcore/result.rs", "status": "modified", "additions": 109, "deletions": 71, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "0b0e6ff95c6599925c4823328d05913039d9d52b", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "26684864c4c49fac5caa115c34853204e1b9355b", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 289, "deletions": 526, "changes": 815, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "204ffae6cbd54818ac21e2b4296fc0c43af590d4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 261, "deletions": 910, "changes": 1171, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "a92914c99e35b7b5a83af0619864b772eccb976d", "filename": "src/libcore/tuple.rs", "status": "added", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "56ea7a4e7a1e98f724d6b50ea07b86d8d91b8f33", "filename": "src/libcore/tuple/mod.rs", "status": "removed", "additions": 0, "deletions": 323, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcore%2Ftuple%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibcore%2Ftuple%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple%2Fmod.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "54da6264bb0491e1f947250c7f723c2c73ebe557", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "bed38f8c29666babdd7549f4b60fb17e7b10614f", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "979ddaecb4ae3087d809ba0a8b986f1f778e975e", "filename": "src/libcoretest/finally.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffinally.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "1e28933becd6ec6808011712ca09e77f76aac57d", "filename": "src/libcoretest/fmt/num.rs", "status": "modified", "additions": 107, "deletions": 107, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "23f9be124dadb74f86c3ca5eee52eb2833e01a41", "filename": "src/libcoretest/hash/mod.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "8801c2975c8f285feb95562eb573c9004e46c336", "filename": "src/libcoretest/hash/sip.rs", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fsip.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "dbbbaa5892cc4bd77b101479162d84235c703539", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "44029ebb7fa0f95e0121f99e8664230b3aac6d40", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "75ddfd5413b31e2c10fc051c0a53c85ab88015c1", "filename": "src/libcoretest/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "7435831ac6dba26fa851d9ae98f962e467a47437", "filename": "src/libcoretest/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi16.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "3b3407e1ada520a373f5163bebc829742fbfa944", "filename": "src/libcoretest/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi32.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "9e1aec256eed0ad4afe35b811a99385f465c002a", "filename": "src/libcoretest/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi64.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "f72244239b2606fee16fecd4bfae67ff637cef47", "filename": "src/libcoretest/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi8.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "be8dfd02ee196bf25ea73f4603e49fc1e0b4ad01", "filename": "src/libcoretest/num/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "55e0f10c8655c4f873a02479aebf65a824dd99a8", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "acc593d7be9c0d8d2ee6261aaa051d362956e5e5", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "8455207583cc182d162cdbccbaa53b8eb6029280", "filename": "src/libcoretest/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu16.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "b44e60f6529791036b5e02483e9d0c0eb9ecf4ee", "filename": "src/libcoretest/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu32.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "ffcd1015d58d63f10049f2a234869eed26375095", "filename": "src/libcoretest/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu64.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "4ee14e22f2d576fbe0cf31b9857d8e07cfafe6c5", "filename": "src/libcoretest/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu8.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "395e55cf255d248bce8a47b2f69ee2a132d94657", "filename": "src/libcoretest/num/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "b21ac11e6a0b5832908252a91b34c770ca0fb8b4", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "a8889ce9e348bd00c059582b506a45e479d68350", "filename": "src/libcoretest/ops.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fops.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "86fc25c9d918c2b765a2fe26645e0ec299668e0e", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "415cd4e7dcfb80a75c05be7cf77452d6062bf703", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "987da903211170bac275d898a2da6b6d4223a878", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "63d6e14a4a6b88165b72589aa0158a184777fe2b", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "f7b714757f8da4ed21074e835a7acf283588911a", "filename": "src/libcoretest/tuple.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibcoretest%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ftuple.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "2c8e5638e4949206aea08522c732f7f3c0031024", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "c284fb7c9e338b9e561b49d64eb1ca2eabfde6f8", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "0426f269376216340c144e3b255bca04b35ae11a", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 144, "deletions": 165, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "ce3df1090bd58c756f1336604d2a1bca0930e577", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 332, "deletions": 303, "changes": 635, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "88483b6c935435dc440afb03026c995fb4743af0", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "6ab00cfe8fa6a616cd67b54deec98bb7013065ef", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 202, "deletions": 183, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "2b25a64affee313ad36a9904e5818ae49e423826", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "97301628a4512aa6f65cf37740e2bde2b1c5046b", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "8b2cfcd420ac1011c610dd17237b3ef62389ff9e", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "6fc92e1e94fcbdcbbedbf74b2e326b50bf8dff99", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "431a530726a083291ab0a38cf547e304d3d191cb", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "58125c67fdae9edef566e871a5a96de8d1ff453a", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "16413af626739ed8fa65817f20d3aba8573359d3", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "3cb1f51a6a80102d472271934b1d7780983c14bd", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "514ff81da518ec789c5614c169b197aa7a9887b0", "filename": "src/librand/lib.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "3b38fde3884f1996a199d0bc603d76fe6e2e68bb", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "94a11c040e49758e7a8f34e1cafc7a84310b6aa1", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "19e79b1eb7b2d4cf7bca0c6b7e91c023c81e7599", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 162, "deletions": 138, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "9ad02afee993478314f4457ab12e33d223695186", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "0cd8df73c37ce6af7718692bd9df7e19a2d8a056", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "4383192edafb05485f4984190b8ee7c6c17edaf9", "filename": "src/libregex/re.rs", "status": "modified", "additions": 57, "deletions": 54, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "0c204f759e6adb7b99f0951ac03db70c8c51359a", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "7508f4c50a2c313ff373fee34e22901c9565e005", "filename": "src/libregex/test/matches.rs", "status": "modified", "additions": 349, "deletions": 349, "changes": 698, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Ftest%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Ftest%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fmatches.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "14156647191248e2102840eb8a57131c971be0df", "filename": "src/libregex/test/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "2f66d483d80009a903829a891770ba0a2865a8b1", "filename": "src/libregex/test/tests.rs", "status": "modified", "additions": 117, "deletions": 117, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Ftest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Ftest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Ftests.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "990d5a159f60d879216efd4df4350d6a6b77b1b3", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "bf1095d21b2f5ac69a9875ca6bb721c814425908", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "4c3cb99f64d06dcfd7f97f95dcf0aaa5187989a5", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 90, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "4647c92e3d1e8a09e25d7e8098acaf593a63f027", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "0fd69ea25bc0d1361edec3b515047fa2ee3a3294", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 412, "deletions": 291, "changes": 703, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "ffae485364a8625bbc9d3d22cffda256b3aac743", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 57, "deletions": 95, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "009a1d444dc137b1e5574fdb07d994e959f5346f", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "03e436e98df46390e753c9294c5c2aafe9af7518", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "98b57511957f605000ce7a9caa0ae569ec469d19", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "13342bf82cfea7bf7128989ea282b5621d095467", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "d5247472c34478fab57665d22a8d91d91c042b28", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "f05607a999b668eea80d3fd6348d80872ed618a4", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 126, "deletions": 97, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "6782b3a74813e668e9aa680018ca9f1fd1753ec6", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 185, "deletions": 163, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "0b859abc531c8f4be5ceac4cc1bfae32e978592f", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "5f554eb9c1e5c0dc577490f68704a11816d3356d", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 36, "deletions": 48, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "61ea93a9fdd1be38338597e2c0ccb33d35cb05e1", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 73, "deletions": 32, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "7fa23620af4b63e0abbd2b6be7b35738bed31b33", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 149, "deletions": 116, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "060e2f67faf988a0c6266b86f0fdca155ca8e43d", "filename": "src/librustc/middle/astconv_util.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "e8627dfa64b0bdc5e11e79e03f2256658b65c88e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 215, "deletions": 165, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "882b6bc842644d760c168a0ac8b6216c3ccf4d1b", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "removed", "additions": 0, "deletions": 1056, "changes": 1056, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "f50790f7e9b15a56442a3032003376ce20b83ab4", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "13bd22a67c410dc2da59f07d217198f41037e568", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "e1c5906f0fb83f5d49f33959a89b806697f5e60b", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "e08dd64d4d4111480a01152c283d299668bb6da1", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "5a08d7c179d1cc238466f96fb534182a8ea0ebb7", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "da1bd09ceffddcbffc99c71daf513ad76bda9f2c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 99, "deletions": 49, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "a14307b90ee837f21677e48f508a9fa1f7e3784b", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "6ff34d625005f19807b91fc95e36869ad43d9eeb", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "c36b4aa7f231e741c9135470c919429d6259b5b6", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "5b89912dd03fcadec6cd0f130a82ad7dc44bf1d7", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 47, "deletions": 33, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "a2d417ca345d8830312762bbffcf30f09d92b83b", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "939775e7507130eeec8b011f904d370eb5beb696", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "a54bc4a945ae25f29104334a38d8d70e8b57341e", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 63, "deletions": 5, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "6b56ece28bdb2e30968a38e13bbfffc17c316621", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "52899aaba412f8f4fdd4f961c4d04b428299b809", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "417e5336249840c9eb67aabab6a177fca6076254", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "bf939e98338629daecd0c57f32b04e17702ac14d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 370, "deletions": 72, "changes": 442, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "62cf47da687019317fe1408baabaa5e96216ddda", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "06e6ef30f74dacadc64ff42e6d1f5e6a3443498d", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 84, "deletions": 49, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "ec83b8fae9b7c6d23a2d35f89d7f3d9bdc87d783", "filename": "src/librustc/middle/infer/coercion.rs", "status": "renamed", "additions": 184, "deletions": 191, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "previous_filename": "src/librustc/middle/typeck/infer/coercion.rs"}, {"sha": "14687b8fd75c61ef645743eae55ac8f9e74a18e8", "filename": "src/librustc/middle/infer/combine.rs", "status": "renamed", "additions": 135, "deletions": 44, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "previous_filename": "src/librustc/middle/typeck/infer/combine.rs"}, {"sha": "0e3cc5f68c868c86b00e12cb906a0da5bfc5dc71", "filename": "src/librustc/middle/infer/doc.rs", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fdoc.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "2a4d20f4dd3799ccdbe7b0fac6dad97333e92d4c", "filename": "src/librustc/middle/infer/equate.rs", "status": "renamed", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "previous_filename": "src/librustc/middle/typeck/infer/equate.rs"}, {"sha": "b57b5554ed64ffc25de74b50b76c201e6d959915", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "renamed", "additions": 151, "deletions": 177, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "previous_filename": "src/librustc/middle/typeck/infer/error_reporting.rs"}, {"sha": "a8bf7546559fdf3835388ce4fc11af17d2bd1251", "filename": "src/librustc/middle/infer/freshen.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "434be32fe5fa70162c642c910e716ca9c7acf0e5", "filename": "src/librustc/middle/infer/glb.rs", "status": "renamed", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "previous_filename": "src/librustc/middle/typeck/infer/glb.rs"}, {"sha": "f6f254c0e8dfce198a1162bcc7a38e06126b315a", "filename": "src/librustc/middle/infer/higher_ranked/doc.rs", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fdoc.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "2a19f37e7d41514c27792fa87a1aed1886ce23c5", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "added", "additions": 614, "deletions": 0, "changes": 614, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "dd514ebee524af9dee0e77f7584c7b6a40e837dc", "filename": "src/librustc/middle/infer/lattice.rs", "status": "renamed", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "previous_filename": "src/librustc/middle/typeck/infer/lattice.rs"}, {"sha": "f4909b2889163c73217538da16a65489c0375da9", "filename": "src/librustc/middle/infer/lub.rs", "status": "renamed", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "previous_filename": "src/librustc/middle/typeck/infer/lub.rs"}, {"sha": "07823779216d96cbe6015f4385348eac6f9e8f20", "filename": "src/librustc/middle/infer/mod.rs", "status": "renamed", "additions": 236, "deletions": 174, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "previous_filename": "src/librustc/middle/typeck/infer/mod.rs"}, {"sha": "686174b73060b85d762c831303ba1b166feb349a", "filename": "src/librustc/middle/infer/region_inference/doc.rs", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fdoc.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "0ca1a593ce7fe55491440554e9e7d8d0789e3317", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "661f7e56429ee63d4922a59ded88b8dbcf84dd90", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "renamed", "additions": 81, "deletions": 84, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "previous_filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs"}, {"sha": "12400de31ed9e5a3ad886bd845920214239a22a4", "filename": "src/librustc/middle/infer/resolve.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "2b8adfb7c1eeb880d1d48663d93c74d23646fa81", "filename": "src/librustc/middle/infer/sub.rs", "status": "renamed", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "previous_filename": "src/librustc/middle/typeck/infer/sub.rs"}, {"sha": "5e857154871ead14d95c9dbf6c5928e8facf460b", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "renamed", "additions": 52, "deletions": 14, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "previous_filename": "src/librustc/middle/typeck/infer/type_variable.rs"}, {"sha": "0b81823e9ed1a32a29e7c108ed9cbd800e294a7a", "filename": "src/librustc/middle/infer/unify.rs", "status": "renamed", "additions": 55, "deletions": 99, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "previous_filename": "src/librustc/middle/typeck/infer/unify.rs"}, {"sha": "6acbc98b4b27b651ec4f2bb04eb4aea44f381d9a", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "ca3087f08c4105606db9cc829bf51f79b12e30cb", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "f59a67e2e806dcf1556acd1179244303180b7fdb", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 183, "deletions": 186, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "932a124ed339b19ea9e03dc342a3a27645b4e86b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 158, "deletions": 144, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "0a6c29d1cb65a154e4bf4461d515e4ece52316e6", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "6f63ae166fe417e7c798572b636f22edd6dbfd69", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 145, "deletions": 124, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "4d83075480bcc0877dda9a089efeb2a46c6fa19c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "a6a6703353cd1ca12911f72ea3b6fb101eab43c8", "filename": "src/librustc/middle/recursion_limit.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "8df78281cc227e9bf1f092b400ddf6ddf67d5fbc", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 102, "deletions": 144, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "28cb80df7713bb49441d6727237611abc959fe42", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 178, "deletions": 113, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "d793f49efe5e8cf640d608d99cdf4261015816d3", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 62, "deletions": 30, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "6ae639e0313e0adaa7bd8e88b764f42586f649cb", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 90, "deletions": 104, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "d48685ce27d89fe6c92d87a4cc8b63c372b59574", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "80697cb3a41db7ffe7e02debc682e996eb3441c9", "filename": "src/librustc/middle/traits/doc.rs", "status": "modified", "additions": 115, "deletions": 5, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "72e4eb5d1d63478843221fddd6d6c2e64d5f6aa2", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 273, "deletions": 73, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "8028971a46346270ba41d91bfa83dae77c25d327", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 161, "deletions": 200, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "f849f4c9b937ef247db7b096c2420ec4c66cc288", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 677, "deletions": 771, "changes": 1448, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "27824ba5c6e77b13b6b0043615692e924927462b", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 206, "deletions": 176, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "9c1259f41202e6fc9bc7b4886319bc8b0d192229", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1425, "deletions": 854, "changes": 2279, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "a35ea30b217913ac4e789ef1062620250570b66f", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 179, "deletions": 210, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "8c691e02ca9d053f12bd5c195ea05b931ebf7a5d", "filename": "src/librustc/middle/typeck/check/method/doc.rs", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fdoc.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "886550a3b246149c874ebd6dc3acf8ae45597d84", "filename": "src/librustc/middle/typeck/infer/doc.rs", "status": "removed", "additions": 0, "deletions": 251, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "4c4452ac892361e4af91dd6eb450e044135d2f1d", "filename": "src/librustc/middle/typeck/infer/higher_ranked/doc.rs", "status": "removed", "additions": 0, "deletions": 415, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fdoc.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "812aa5c55572814c22e4df034da1b32fbc31d5b9", "filename": "src/librustc/middle/typeck/infer/higher_ranked/mod.rs", "status": "removed", "additions": 0, "deletions": 448, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "40b41deeb2b66096cf78ddd979c994846d543224", "filename": "src/librustc/middle/typeck/infer/region_inference/doc.rs", "status": "removed", "additions": 0, "deletions": 378, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "cf5efd188ed96ed8724cf8628e9e9f8dcb40b7af", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "removed", "additions": 0, "deletions": 259, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "5907a2bb9b61d945d2eee360d7ea99653f65d937", "filename": "src/librustc/middle/typeck/infer/skolemize.rs", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f827d33cab1be648120fc8ac34651d9cc079b5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs?ref=8f827d33cab1be648120fc8ac34651d9cc079b5e"}, {"sha": "892a8004fec1c99ecd4efae1b9d22fc7f6125de0", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "a8018662d292f204b5ead25144eecc5b5c418900", "filename": "src/librustc/plugin/build.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fplugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fplugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fbuild.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "a2e334543206cc68ea6ed35e75639b9f3f64e246", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "8dd60880cdd56022773879ed502dcce3bc4ed8f7", "filename": "src/librustc/plugin/mod.rs", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fplugin%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fplugin%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "6629f6620d4847e28996d88795cc8a863bf6be3d", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 437, "deletions": 136, "changes": 573, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "37bdd1673e9ca3cb69b439e8bd8dffda0544603c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "e1448364a9e05a7c36028d5dbe0bfdbdaa8ea646", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 47, "deletions": 37, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "24e9883744407b9ebb698e2caa6f4f6a8278cdda", "filename": "src/librustc/util/lev_distance.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "2b05961bb6a05c0951ecffd48180465914335b11", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "a02004e6d18a3a2aa673322d5e3bcd1ade3269ef", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 186, "deletions": 113, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "749c39d7a6b92219591dac776430ff97d6686bb9", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "2f6efbc85a2647f1e6f588d4171a564f394a1696", "filename": "src/librustc_back/abi.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fabi.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "0bd4265e487a64f25fa19a7d2f022879e7481fae", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "ea4d5c820f8b8796afb5faca1cdc134553a3d350", "filename": "src/librustc_back/arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farm.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "d7deb09985f78203cb4e3e7ad2fa99d964c7a0f7", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "cb547df7d9cd83a9cc8a710eb586730431d2e899", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "1056ac928e687e7f996c9c5830c3225bb4144c8e", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 49, "deletions": 34, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "074341ccff49db6fbb6ce235df1461ca63e8cf23", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "c68e9055269c0fca8e3278c39f5f94079c992eee", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "99a25bebf40ab4999fd95c84a204cd86314b32be", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}, {"sha": "568bb023b68a28f9aae4a60ad84d5ac24c3be447", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "renamed", "additions": 124, "deletions": 109, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114", "previous_filename": "src/librustc/middle/borrowck/check_loans.rs"}, {"sha": "c6db5340f0f511d9e6865516368908a347b68185", "filename": "src/librustc_borrowck/borrowck/doc.rs", "status": "added", "additions": 1222, "deletions": 0, "changes": 1222, "blob_url": "https://github.com/rust-lang/rust/blob/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_borrowck%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0128159c95d0544e0c30b8b52ce3e7ce348fc114/src%2Flibrustc_borrowck%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fdoc.rs?ref=0128159c95d0544e0c30b8b52ce3e7ce348fc114"}]}