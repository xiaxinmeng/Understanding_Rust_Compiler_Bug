{"sha": "4b128624ed44223b7d0b61438b0d02fc91419e43", "node_id": "C_kwDOAAsO6NoAKDRiMTI4NjI0ZWQ0NDIyM2I3ZDBiNjE0MzhiMGQwMmZjOTE0MTllNDM", "commit": {"author": {"name": "J-ZhengLi", "email": "lizheng135@huawei.com", "date": "2022-03-17T15:06:31Z"}, "committer": {"name": "J-ZhengLi", "email": "lizheng135@huawei.com", "date": "2022-03-17T15:06:31Z"}, "message": "fix #8551, add test cases, and some code improvement", "tree": {"sha": "42deee3e621a72dc9534d4c67e8262531ccf405b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42deee3e621a72dc9534d4c67e8262531ccf405b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b128624ed44223b7d0b61438b0d02fc91419e43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b128624ed44223b7d0b61438b0d02fc91419e43", "html_url": "https://github.com/rust-lang/rust/commit/4b128624ed44223b7d0b61438b0d02fc91419e43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b128624ed44223b7d0b61438b0d02fc91419e43/comments", "author": {"login": "J-ZhengLi", "id": 32276130, "node_id": "MDQ6VXNlcjMyMjc2MTMw", "avatar_url": "https://avatars.githubusercontent.com/u/32276130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/J-ZhengLi", "html_url": "https://github.com/J-ZhengLi", "followers_url": "https://api.github.com/users/J-ZhengLi/followers", "following_url": "https://api.github.com/users/J-ZhengLi/following{/other_user}", "gists_url": "https://api.github.com/users/J-ZhengLi/gists{/gist_id}", "starred_url": "https://api.github.com/users/J-ZhengLi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/J-ZhengLi/subscriptions", "organizations_url": "https://api.github.com/users/J-ZhengLi/orgs", "repos_url": "https://api.github.com/users/J-ZhengLi/repos", "events_url": "https://api.github.com/users/J-ZhengLi/events{/privacy}", "received_events_url": "https://api.github.com/users/J-ZhengLi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "J-ZhengLi", "id": 32276130, "node_id": "MDQ6VXNlcjMyMjc2MTMw", "avatar_url": "https://avatars.githubusercontent.com/u/32276130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/J-ZhengLi", "html_url": "https://github.com/J-ZhengLi", "followers_url": "https://api.github.com/users/J-ZhengLi/followers", "following_url": "https://api.github.com/users/J-ZhengLi/following{/other_user}", "gists_url": "https://api.github.com/users/J-ZhengLi/gists{/gist_id}", "starred_url": "https://api.github.com/users/J-ZhengLi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/J-ZhengLi/subscriptions", "organizations_url": "https://api.github.com/users/J-ZhengLi/orgs", "repos_url": "https://api.github.com/users/J-ZhengLi/repos", "events_url": "https://api.github.com/users/J-ZhengLi/events{/privacy}", "received_events_url": "https://api.github.com/users/J-ZhengLi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2909b33a243591cec6a5d6d51dc6e1684809aeac", "url": "https://api.github.com/repos/rust-lang/rust/commits/2909b33a243591cec6a5d6d51dc6e1684809aeac", "html_url": "https://github.com/rust-lang/rust/commit/2909b33a243591cec6a5d6d51dc6e1684809aeac"}], "stats": {"total": 256, "additions": 185, "deletions": 71}, "files": [{"sha": "e93b494653fc05923feecace84790bb7606d6122", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b128624ed44223b7d0b61438b0d02fc91419e43/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b128624ed44223b7d0b61438b0d02fc91419e43/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=4b128624ed44223b7d0b61438b0d02fc91419e43", "patch": "@@ -667,7 +667,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                     overlapping_arms::check(cx, ex, arms);\n                     match_wild_enum::check(cx, ex, arms);\n                     match_as_ref::check(cx, ex, arms, expr);\n-                    needless_match::check_match(cx, ex, arms);\n+                    needless_match::check_match(cx, ex, arms, expr);\n \n                     if self.infallible_destructuring_match_linted {\n                         self.infallible_destructuring_match_linted = false;"}, {"sha": "2830ae1f61d58abb04974af07429c1f1d67d6aca", "filename": "clippy_lints/src/matches/needless_match.rs", "status": "modified", "additions": 73, "deletions": 35, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/4b128624ed44223b7d0b61438b0d02fc91419e43/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b128624ed44223b7d0b61438b0d02fc91419e43/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=4b128624ed44223b7d0b61438b0d02fc91419e43", "patch": "@@ -1,37 +1,25 @@\n use super::NEEDLESS_MATCH;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{eq_expr_value, get_parent_expr, higher, is_else_clause, is_lang_ctor, peel_blocks_with_stmt};\n+use clippy_utils::ty::{is_type_diagnostic_item, same_type_and_consts};\n+use clippy_utils::{\n+    eq_expr_value, get_parent_expr_for_hir, get_parent_node, higher, is_else_clause, is_lang_ctor,\n+    peel_blocks_with_stmt,\n+};\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, Pat, PatKind, Path, PathSegment, QPath};\n+use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, FnRetTy, Node, Pat, PatKind, Path, PathSegment, QPath};\n use rustc_lint::LateContext;\n use rustc_span::sym;\n+use rustc_typeck::hir_ty_to_ty;\n \n-pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n-    // This is for avoiding collision with `match_single_binding`.\n-    if arms.len() < 2 {\n-        return;\n-    }\n-\n-    for arm in arms {\n-        if let PatKind::Wild = arm.pat.kind {\n-            let ret_expr = strip_return(arm.body);\n-            if !eq_expr_value(cx, ex, ret_expr) {\n-                return;\n-            }\n-        } else if !pat_same_as_expr(arm.pat, peel_blocks_with_stmt(arm.body)) {\n-            return;\n-        }\n-    }\n-\n-    if let Some(match_expr) = get_parent_expr(cx, ex) {\n+pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    if arms.len() > 1 && !is_coercion_casting(cx, ex, expr) && check_all_arms(cx, ex, arms) {\n         let mut applicability = Applicability::MachineApplicable;\n         span_lint_and_sugg(\n             cx,\n             NEEDLESS_MATCH,\n-            match_expr.span,\n+            expr.span,\n             \"this match expression is unnecessary\",\n             \"replace it with\",\n             snippet_with_applicability(cx, ex.span, \"..\", &mut applicability).to_string(),\n@@ -60,11 +48,8 @@ pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n /// }\n /// ```\n pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>) {\n-    if_chain! {\n-        if let Some(ref if_let) = higher::IfLet::hir(cx, ex);\n-        if !is_else_clause(cx.tcx, ex);\n-        if check_if_let(cx, if_let);\n-        then {\n+    if let Some(ref if_let) = higher::IfLet::hir(cx, ex) {\n+        if !is_else_clause(cx.tcx, ex) && !is_coercion_casting(cx, if_let.let_expr, ex) && check_if_let(cx, if_let) {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n@@ -79,6 +64,19 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>) {\n     }\n }\n \n+fn check_all_arms(cx: &LateContext<'_>, match_expr: &Expr<'_>, arms: &[Arm<'_>]) -> bool {\n+    for arm in arms {\n+        let arm_expr = peel_blocks_with_stmt(arm.body);\n+        if let PatKind::Wild = arm.pat.kind {\n+            return eq_expr_value(cx, match_expr, strip_return(arm_expr));\n+        } else if !pat_same_as_expr(arm.pat, arm_expr) {\n+            return false;\n+        }\n+    }\n+\n+    true\n+}\n+\n fn check_if_let(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool {\n     if let Some(if_else) = if_let.if_else {\n         if !pat_same_as_expr(if_let.let_pat, peel_blocks_with_stmt(if_let.if_then)) {\n@@ -101,12 +99,12 @@ fn check_if_let(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool {\n                 if let ExprKind::Path(ref qpath) = ret.kind {\n                     return is_lang_ctor(cx, qpath, OptionNone) || eq_expr_value(cx, if_let.let_expr, ret);\n                 }\n-            } else {\n-                return eq_expr_value(cx, if_let.let_expr, ret);\n+                return true;\n             }\n-            return true;\n+            return eq_expr_value(cx, if_let.let_expr, ret);\n         }\n     }\n+\n     false\n }\n \n@@ -119,14 +117,52 @@ fn strip_return<'hir>(expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n     }\n }\n \n+/// Manually check for coercion casting by checking if the type of the match operand or let expr\n+/// differs with the assigned local variable or the funtion return type.\n+fn is_coercion_casting(cx: &LateContext<'_>, match_expr: &Expr<'_>, expr: &Expr<'_>) -> bool {\n+    if let Some(p_node) = get_parent_node(cx.tcx, expr.hir_id) {\n+        match p_node {\n+            // Compare match_expr ty with local in `let local = match match_expr {..}`\n+            Node::Local(local) => {\n+                let results = cx.typeck_results();\n+                return !same_type_and_consts(results.node_type(local.hir_id), results.expr_ty(match_expr));\n+            },\n+            // compare match_expr ty with RetTy in `fn foo() -> RetTy`\n+            Node::Item(..) => {\n+                if let Some(fn_decl) = p_node.fn_decl() {\n+                    if let FnRetTy::Return(ret_ty) = fn_decl.output {\n+                        return !same_type_and_consts(\n+                            hir_ty_to_ty(cx.tcx, ret_ty),\n+                            cx.typeck_results().expr_ty(match_expr),\n+                        );\n+                    }\n+                }\n+            },\n+            // check the parent expr for this whole block `{ match match_expr {..} }`\n+            Node::Block(block) => {\n+                if let Some(block_parent_expr) = get_parent_expr_for_hir(cx, block.hir_id) {\n+                    return is_coercion_casting(cx, match_expr, block_parent_expr);\n+                }\n+            },\n+            // recursively call on `if xxx {..}` etc.\n+            Node::Expr(p_expr) => {\n+                return is_coercion_casting(cx, match_expr, p_expr);\n+            },\n+            _ => {},\n+        }\n+    }\n+\n+    false\n+}\n+\n fn pat_same_as_expr(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n     let expr = strip_return(expr);\n     match (&pat.kind, &expr.kind) {\n         // Example: `Some(val) => Some(val)`\n         (PatKind::TupleStruct(QPath::Resolved(_, path), tuple_params, _), ExprKind::Call(call_expr, call_params)) => {\n             if let ExprKind::Path(QPath::Resolved(_, call_path)) = call_expr.kind {\n-                return has_identical_segments(path.segments, call_path.segments)\n-                    && has_same_non_ref_symbols(tuple_params, call_params);\n+                return same_segments(path.segments, call_path.segments)\n+                    && same_non_ref_symbols(tuple_params, call_params);\n             }\n         },\n         // Example: `val => val`\n@@ -145,7 +181,7 @@ fn pat_same_as_expr(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n         },\n         // Example: `Custom::TypeA => Custom::TypeB`, or `None => None`\n         (PatKind::Path(QPath::Resolved(_, p_path)), ExprKind::Path(QPath::Resolved(_, e_path))) => {\n-            return has_identical_segments(p_path.segments, e_path.segments);\n+            return same_segments(p_path.segments, e_path.segments);\n         },\n         // Example: `5 => 5`\n         (PatKind::Lit(pat_lit_expr), ExprKind::Lit(expr_spanned)) => {\n@@ -159,19 +195,21 @@ fn pat_same_as_expr(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n     false\n }\n \n-fn has_identical_segments(left_segs: &[PathSegment<'_>], right_segs: &[PathSegment<'_>]) -> bool {\n+fn same_segments(left_segs: &[PathSegment<'_>], right_segs: &[PathSegment<'_>]) -> bool {\n     if left_segs.len() != right_segs.len() {\n         return false;\n     }\n+\n     for i in 0..left_segs.len() {\n         if left_segs[i].ident.name != right_segs[i].ident.name {\n             return false;\n         }\n     }\n+\n     true\n }\n \n-fn has_same_non_ref_symbols(pats: &[Pat<'_>], exprs: &[Expr<'_>]) -> bool {\n+fn same_non_ref_symbols(pats: &[Pat<'_>], exprs: &[Expr<'_>]) -> bool {\n     if pats.len() != exprs.len() {\n         return false;\n     }"}, {"sha": "d55dd589a54643c1c1cf298c872318eff5a39ade", "filename": "tests/ui/needless_match.fixed", "status": "modified", "additions": 52, "deletions": 14, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4b128624ed44223b7d0b61438b0d02fc91419e43/tests%2Fui%2Fneedless_match.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4b128624ed44223b7d0b61438b0d02fc91419e43/tests%2Fui%2Fneedless_match.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.fixed?ref=4b128624ed44223b7d0b61438b0d02fc91419e43", "patch": "@@ -60,8 +60,26 @@ fn result_match() {\n     };\n }\n \n-fn if_let_option() -> Option<i32> {\n-    Some(1)\n+fn if_let_option() {\n+    let _ = Some(1);\n+\n+    fn do_something() {}\n+\n+    // Don't trigger\n+    let _ = if let Some(a) = Some(1) {\n+        Some(a)\n+    } else {\n+        do_something();\n+        None\n+    };\n+\n+    // Don't trigger\n+    let _ = if let Some(a) = Some(1) {\n+        do_something();\n+        Some(a)\n+    } else {\n+        None\n+    };\n }\n \n fn if_let_result() {\n@@ -122,25 +140,45 @@ mod issue8542 {\n             _ => ce,\n         };\n     }\n+}\n \n-    fn if_let_test() {\n-        fn do_something() {}\n+/// Lint triggered when type coercions happen.\n+/// Do NOT trigger on any of these.\n+mod issue8551 {\n+    trait Trait {}\n+    struct Struct;\n+    impl Trait for Struct {}\n+\n+    fn optmap(s: Option<&Struct>) -> Option<&dyn Trait> {\n+        match s {\n+            Some(s) => Some(s),\n+            None => None,\n+        }\n+    }\n \n-        // Don't trigger\n-        let _ = if let Some(a) = Some(1) {\n-            Some(a)\n-        } else {\n-            do_something();\n-            None\n+    fn lint_tests() {\n+        let option: Option<&Struct> = None;\n+        let _: Option<&dyn Trait> = match option {\n+            Some(s) => Some(s),\n+            None => None,\n         };\n \n-        // Don't trigger\n-        let _ = if let Some(a) = Some(1) {\n-            do_something();\n-            Some(a)\n+        let _: Option<&dyn Trait> = if true {\n+            match option {\n+                Some(s) => Some(s),\n+                None => None,\n+            }\n         } else {\n             None\n         };\n+\n+        let result: Result<&Struct, i32> = Err(0);\n+        let _: Result<&dyn Trait, i32> = match result {\n+            Ok(s) => Ok(s),\n+            Err(e) => Err(e),\n+        };\n+\n+        let _: Option<&dyn Trait> = if let Some(s) = option { Some(s) } else { None };\n     }\n }\n "}, {"sha": "f3c7ee01a47a97afc3b7b9a7724ff52c577028bb", "filename": "tests/ui/needless_match.rs", "status": "modified", "additions": 52, "deletions": 14, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4b128624ed44223b7d0b61438b0d02fc91419e43/tests%2Fui%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b128624ed44223b7d0b61438b0d02fc91419e43/tests%2Fui%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.rs?ref=4b128624ed44223b7d0b61438b0d02fc91419e43", "patch": "@@ -83,8 +83,26 @@ fn result_match() {\n     };\n }\n \n-fn if_let_option() -> Option<i32> {\n-    if let Some(a) = Some(1) { Some(a) } else { None }\n+fn if_let_option() {\n+    let _ = if let Some(a) = Some(1) { Some(a) } else { None };\n+\n+    fn do_something() {}\n+\n+    // Don't trigger\n+    let _ = if let Some(a) = Some(1) {\n+        Some(a)\n+    } else {\n+        do_something();\n+        None\n+    };\n+\n+    // Don't trigger\n+    let _ = if let Some(a) = Some(1) {\n+        do_something();\n+        Some(a)\n+    } else {\n+        None\n+    };\n }\n \n fn if_let_result() {\n@@ -159,25 +177,45 @@ mod issue8542 {\n             _ => ce,\n         };\n     }\n+}\n \n-    fn if_let_test() {\n-        fn do_something() {}\n+/// Lint triggered when type coercions happen.\n+/// Do NOT trigger on any of these.\n+mod issue8551 {\n+    trait Trait {}\n+    struct Struct;\n+    impl Trait for Struct {}\n+\n+    fn optmap(s: Option<&Struct>) -> Option<&dyn Trait> {\n+        match s {\n+            Some(s) => Some(s),\n+            None => None,\n+        }\n+    }\n \n-        // Don't trigger\n-        let _ = if let Some(a) = Some(1) {\n-            Some(a)\n-        } else {\n-            do_something();\n-            None\n+    fn lint_tests() {\n+        let option: Option<&Struct> = None;\n+        let _: Option<&dyn Trait> = match option {\n+            Some(s) => Some(s),\n+            None => None,\n         };\n \n-        // Don't trigger\n-        let _ = if let Some(a) = Some(1) {\n-            do_something();\n-            Some(a)\n+        let _: Option<&dyn Trait> = if true {\n+            match option {\n+                Some(s) => Some(s),\n+                None => None,\n+            }\n         } else {\n             None\n         };\n+\n+        let result: Result<&Struct, i32> = Err(0);\n+        let _: Result<&dyn Trait, i32> = match result {\n+            Ok(s) => Ok(s),\n+            Err(e) => Err(e),\n+        };\n+\n+        let _: Option<&dyn Trait> = if let Some(s) = option { Some(s) } else { None };\n     }\n }\n "}, {"sha": "34c5226f06057611d9eb87ac5c631b4d241850e8", "filename": "tests/ui/needless_match.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b128624ed44223b7d0b61438b0d02fc91419e43/tests%2Fui%2Fneedless_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b128624ed44223b7d0b61438b0d02fc91419e43/tests%2Fui%2Fneedless_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.stderr?ref=4b128624ed44223b7d0b61438b0d02fc91419e43", "patch": "@@ -66,25 +66,25 @@ LL | |     };\n    | |_____^ help: replace it with: `func_ret_err(0_i32)`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:87:5\n+  --> $DIR/needless_match.rs:87:13\n    |\n-LL |     if let Some(a) = Some(1) { Some(a) } else { None }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `Some(1)`\n+LL |     let _ = if let Some(a) = Some(1) { Some(a) } else { None };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `Some(1)`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:92:31\n+  --> $DIR/needless_match.rs:110:31\n    |\n LL |     let _: Result<i32, i32> = if let Err(e) = x { Err(e) } else { x };\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:93:31\n+  --> $DIR/needless_match.rs:111:31\n    |\n LL |     let _: Result<i32, i32> = if let Ok(val) = x { Ok(val) } else { x };\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:99:21\n+  --> $DIR/needless_match.rs:117:21\n    |\n LL |       let _: Simple = if let Simple::A = x {\n    |  _____________________^\n@@ -97,7 +97,7 @@ LL | |     };\n    | |_____^ help: replace it with: `x`\n \n error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:138:26\n+  --> $DIR/needless_match.rs:156:26\n    |\n LL |           let _: Complex = match ce {\n    |  __________________________^"}]}