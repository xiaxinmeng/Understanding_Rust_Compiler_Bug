{"sha": "7e0c3de4c473c3779046951abec46517fdba8cc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlMGMzZGU0YzQ3M2MzNzc5MDQ2OTUxYWJlYzQ2NTE3ZmRiYThjYzk=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-02-19T03:48:36Z"}, "committer": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-02-20T16:40:01Z"}, "message": "Remove `else`, unindent.", "tree": {"sha": "ff7f0fc431419bfcddcb192e3d26b7e5a1c65c7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff7f0fc431419bfcddcb192e3d26b7e5a1c65c7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e0c3de4c473c3779046951abec46517fdba8cc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e0c3de4c473c3779046951abec46517fdba8cc9", "html_url": "https://github.com/rust-lang/rust/commit/7e0c3de4c473c3779046951abec46517fdba8cc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e0c3de4c473c3779046951abec46517fdba8cc9/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfebdeaaccee40e060708d6b60c4abbe9edf72bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfebdeaaccee40e060708d6b60c4abbe9edf72bb", "html_url": "https://github.com/rust-lang/rust/commit/cfebdeaaccee40e060708d6b60c4abbe9edf72bb"}], "stats": {"total": 219, "additions": 109, "deletions": 110}, "files": [{"sha": "411e986f62d900e21622cd072fc5778f9db97e6a", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 109, "deletions": 110, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/7e0c3de4c473c3779046951abec46517fdba8cc9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0c3de4c473c3779046951abec46517fdba8cc9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=7e0c3de4c473c3779046951abec46517fdba8cc9", "patch": "@@ -525,127 +525,126 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         lint_id)\n                         .emit();\n                     return;\n-                } else {\n-                    match obligation.predicate {\n-                        ty::Predicate::Trait(ref trait_predicate) => {\n-                            let trait_predicate =\n-                                self.resolve_type_vars_if_possible(trait_predicate);\n+                }\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(ref trait_predicate) => {\n+                        let trait_predicate =\n+                            self.resolve_type_vars_if_possible(trait_predicate);\n \n-                            if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n-                                return;\n+                        if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n+                            return;\n+                        } else {\n+                            let trait_ref = trait_predicate.to_poly_trait_ref();\n+                            let (post_message, pre_message) = match self.get_parent_trait_ref(\n+                                &obligation.cause.code)\n+                            {\n+                                Some(t) => {\n+                                    (format!(\" in `{}`\", t), format!(\"within `{}`, \", t))\n+                                }\n+                                None => (String::new(), String::new()),\n+                            };\n+                            let mut err = struct_span_err!(\n+                                self.tcx.sess,\n+                                span,\n+                                E0277,\n+                                \"the trait bound `{}` is not satisfied{}\",\n+                                trait_ref.to_predicate(),\n+                                post_message);\n+                            err.span_label(span,\n+                                            &format!(\"{}the trait `{}` is not \\\n+                                                        implemented for `{}`\",\n+                                                    pre_message,\n+                                                    trait_ref,\n+                                                    trait_ref.self_ty()));\n+\n+                            // Try to report a help message\n+\n+                            if !trait_ref.has_infer_types() &&\n+                                self.predicate_can_apply(trait_ref) {\n+                                // If a where-clause may be useful, remind the\n+                                // user that they can add it.\n+                                //\n+                                // don't display an on-unimplemented note, as\n+                                // these notes will often be of the form\n+                                //     \"the type `T` can't be frobnicated\"\n+                                // which is somewhat confusing.\n+                                err.help(&format!(\"consider adding a `where {}` bound\",\n+                                                    trait_ref.to_predicate()));\n+                            } else if let Some(s) = self.on_unimplemented_note(trait_ref,\n+                                                                                obligation) {\n+                                // If it has a custom \"#[rustc_on_unimplemented]\"\n+                                // error message, let's display it!\n+                                err.note(&s);\n                             } else {\n-                                let trait_ref = trait_predicate.to_poly_trait_ref();\n-                                let (post_message, pre_message) = match self.get_parent_trait_ref(\n-                                    &obligation.cause.code)\n-                                {\n-                                    Some(t) => {\n-                                        (format!(\" in `{}`\", t), format!(\"within `{}`, \", t))\n-                                    }\n-                                    None => (String::new(), String::new()),\n-                                };\n-                                let mut err = struct_span_err!(\n-                                    self.tcx.sess,\n-                                    span,\n-                                    E0277,\n-                                    \"the trait bound `{}` is not satisfied{}\",\n-                                    trait_ref.to_predicate(),\n-                                    post_message);\n-                                err.span_label(span,\n-                                               &format!(\"{}the trait `{}` is not \\\n-                                                         implemented for `{}`\",\n-                                                        pre_message,\n-                                                        trait_ref,\n-                                                        trait_ref.self_ty()));\n-\n-                                // Try to report a help message\n-\n-                                if !trait_ref.has_infer_types() &&\n-                                    self.predicate_can_apply(trait_ref) {\n-                                    // If a where-clause may be useful, remind the\n-                                    // user that they can add it.\n-                                    //\n-                                    // don't display an on-unimplemented note, as\n-                                    // these notes will often be of the form\n-                                    //     \"the type `T` can't be frobnicated\"\n-                                    // which is somewhat confusing.\n-                                    err.help(&format!(\"consider adding a `where {}` bound\",\n-                                                      trait_ref.to_predicate()));\n-                                } else if let Some(s) = self.on_unimplemented_note(trait_ref,\n-                                                                                   obligation) {\n-                                    // If it has a custom \"#[rustc_on_unimplemented]\"\n-                                    // error message, let's display it!\n-                                    err.note(&s);\n-                                } else {\n-                                    // If we can't show anything useful, try to find\n-                                    // similar impls.\n-                                    let impl_candidates =\n-                                        self.find_similar_impl_candidates(trait_ref);\n-                                    if impl_candidates.len() > 0 {\n-                                        self.report_similar_impl_candidates(trait_ref, &mut err);\n-                                    }\n+                                // If we can't show anything useful, try to find\n+                                // similar impls.\n+                                let impl_candidates =\n+                                    self.find_similar_impl_candidates(trait_ref);\n+                                if impl_candidates.len() > 0 {\n+                                    self.report_similar_impl_candidates(trait_ref, &mut err);\n                                 }\n-                                err\n                             }\n+                            err\n                         }\n+                    }\n \n-                        ty::Predicate::Equate(ref predicate) => {\n-                            let predicate = self.resolve_type_vars_if_possible(predicate);\n-                            let err = self.equality_predicate(&obligation.cause,\n-                                                              &predicate).err().unwrap();\n-                            struct_span_err!(self.tcx.sess, span, E0278,\n-                                \"the requirement `{}` is not satisfied (`{}`)\",\n-                                predicate, err)\n-                        }\n+                    ty::Predicate::Equate(ref predicate) => {\n+                        let predicate = self.resolve_type_vars_if_possible(predicate);\n+                        let err = self.equality_predicate(&obligation.cause,\n+                                                            &predicate).err().unwrap();\n+                        struct_span_err!(self.tcx.sess, span, E0278,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate, err)\n+                    }\n \n-                        ty::Predicate::RegionOutlives(ref predicate) => {\n-                            let predicate = self.resolve_type_vars_if_possible(predicate);\n-                            let err = self.region_outlives_predicate(&obligation.cause,\n-                                                                     &predicate).err().unwrap();\n-                            struct_span_err!(self.tcx.sess, span, E0279,\n-                                \"the requirement `{}` is not satisfied (`{}`)\",\n-                                predicate, err)\n-                        }\n+                    ty::Predicate::RegionOutlives(ref predicate) => {\n+                        let predicate = self.resolve_type_vars_if_possible(predicate);\n+                        let err = self.region_outlives_predicate(&obligation.cause,\n+                                                                    &predicate).err().unwrap();\n+                        struct_span_err!(self.tcx.sess, span, E0279,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate, err)\n+                    }\n \n-                        ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n-                            let predicate =\n-                                self.resolve_type_vars_if_possible(&obligation.predicate);\n-                            struct_span_err!(self.tcx.sess, span, E0280,\n-                                \"the requirement `{}` is not satisfied\",\n-                                predicate)\n-                        }\n+                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                        let predicate =\n+                            self.resolve_type_vars_if_possible(&obligation.predicate);\n+                        struct_span_err!(self.tcx.sess, span, E0280,\n+                            \"the requirement `{}` is not satisfied\",\n+                            predicate)\n+                    }\n \n-                        ty::Predicate::ObjectSafe(trait_def_id) => {\n-                            let violations = self.tcx.object_safety_violations(trait_def_id);\n-                            self.tcx.report_object_safety_error(span,\n-                                                                trait_def_id,\n-                                                                violations)\n-                        }\n+                    ty::Predicate::ObjectSafe(trait_def_id) => {\n+                        let violations = self.tcx.object_safety_violations(trait_def_id);\n+                        self.tcx.report_object_safety_error(span,\n+                                                            trait_def_id,\n+                                                            violations)\n+                    }\n \n-                        ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-                            let found_kind = self.closure_kind(closure_def_id).unwrap();\n-                            let closure_span = self.tcx.hir.span_if_local(closure_def_id).unwrap();\n-                            let mut err = struct_span_err!(\n-                                self.tcx.sess, closure_span, E0525,\n-                                \"expected a closure that implements the `{}` trait, \\\n-                                 but this closure only implements `{}`\",\n-                                kind,\n-                                found_kind);\n-                            err.span_note(\n-                                obligation.cause.span,\n-                                &format!(\"the requirement to implement \\\n-                                          `{}` derives from here\", kind));\n-                            err.emit();\n-                            return;\n-                        }\n+                    ty::Predicate::ClosureKind(closure_def_id, kind) => {\n+                        let found_kind = self.closure_kind(closure_def_id).unwrap();\n+                        let closure_span = self.tcx.hir.span_if_local(closure_def_id).unwrap();\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess, closure_span, E0525,\n+                            \"expected a closure that implements the `{}` trait, \\\n+                                but this closure only implements `{}`\",\n+                            kind,\n+                            found_kind);\n+                        err.span_note(\n+                            obligation.cause.span,\n+                            &format!(\"the requirement to implement \\\n+                                        `{}` derives from here\", kind));\n+                        err.emit();\n+                        return;\n+                    }\n \n-                        ty::Predicate::WellFormed(ty) => {\n-                            // WF predicates cannot themselves make\n-                            // errors. They can only block due to\n-                            // ambiguity; otherwise, they always\n-                            // degenerate into other obligations\n-                            // (which may fail).\n-                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n-                        }\n+                    ty::Predicate::WellFormed(ty) => {\n+                        // WF predicates cannot themselves make\n+                        // errors. They can only block due to\n+                        // ambiguity; otherwise, they always\n+                        // degenerate into other obligations\n+                        // (which may fail).\n+                        span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n                     }\n                 }\n             }"}]}