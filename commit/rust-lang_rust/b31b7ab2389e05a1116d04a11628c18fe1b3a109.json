{"sha": "b31b7ab2389e05a1116d04a11628c18fe1b3a109", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMWI3YWIyMzg5ZTA1YTExMTZkMDRhMTE2MjhjMThmZTFiM2ExMDk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-19T10:19:37Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-19T10:44:51Z"}, "message": "slightly cleanup macro tests", "tree": {"sha": "dce8c4d0f1332fe4eb8ee99198d4e5b627f6d03b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dce8c4d0f1332fe4eb8ee99198d4e5b627f6d03b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b31b7ab2389e05a1116d04a11628c18fe1b3a109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b31b7ab2389e05a1116d04a11628c18fe1b3a109", "html_url": "https://github.com/rust-lang/rust/commit/b31b7ab2389e05a1116d04a11628c18fe1b3a109", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b31b7ab2389e05a1116d04a11628c18fe1b3a109/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c35ef7e1ed97172ab644248185b75dceebb0d35a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c35ef7e1ed97172ab644248185b75dceebb0d35a", "html_url": "https://github.com/rust-lang/rust/commit/c35ef7e1ed97172ab644248185b75dceebb0d35a"}], "stats": {"total": 344, "additions": 159, "deletions": 185}, "files": [{"sha": "f34ab52e198660d7e7f415f23473b1c6d682b910", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 159, "deletions": 185, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/b31b7ab2389e05a1116d04a11628c18fe1b3a109/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31b7ab2389e05a1116d04a11628c18fe1b3a109/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=b31b7ab2389e05a1116d04a11628c18fe1b3a109", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{ast, AstNode, NodeOrToken};\n+use ra_syntax::{ast, AstNode, NodeOrToken, WalkEvent};\n use test_utils::assert_eq_text;\n \n use super::*;\n@@ -78,159 +78,57 @@ macro_rules! impl_froms {\n impl_froms!(TokenTree: Leaf, Subtree);\n \"#;\n \n-    let source_file = ast::SourceFile::parse(macro_definition).ok().unwrap();\n-    let macro_definition =\n-        source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-\n-    let source_file = ast::SourceFile::parse(macro_invocation).ok().unwrap();\n-    let macro_invocation =\n-        source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-\n-    let (definition_tt, _) = ast_to_token_tree(&macro_definition.token_tree().unwrap()).unwrap();\n-    let (invocation_tt, _) = ast_to_token_tree(&macro_invocation.token_tree().unwrap()).unwrap();\n-    let rules = crate::MacroRules::parse(&definition_tt).unwrap();\n-    let expansion = rules.expand(&invocation_tt).unwrap();\n+    let rules = create_rules(macro_definition);\n+    let expansion = expand(&rules, macro_invocation);\n     assert_eq!(\n         expansion.to_string(),\n         \"impl From <Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree ::Leaf (it)}} \\\n          impl From <Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree ::Subtree (it)}}\"\n     )\n }\n \n-pub(crate) fn create_rules(macro_definition: &str) -> MacroRules {\n-    let source_file = ast::SourceFile::parse(macro_definition).ok().unwrap();\n-    let macro_definition =\n-        source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-\n-    let (definition_tt, _) = ast_to_token_tree(&macro_definition.token_tree().unwrap()).unwrap();\n-    crate::MacroRules::parse(&definition_tt).unwrap()\n-}\n-\n-pub(crate) fn expand(rules: &MacroRules, invocation: &str) -> tt::Subtree {\n-    let source_file = ast::SourceFile::parse(invocation).ok().unwrap();\n-    let macro_invocation =\n-        source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-\n-    let (invocation_tt, _) = ast_to_token_tree(&macro_invocation.token_tree().unwrap()).unwrap();\n-\n-    rules.expand(&invocation_tt).unwrap()\n-}\n-\n-pub(crate) fn expand_to_items(rules: &MacroRules, invocation: &str) -> ast::MacroItems {\n-    let expanded = expand(rules, invocation);\n-    token_tree_to_items(&expanded).unwrap().tree()\n-}\n-\n-#[allow(unused)]\n-pub(crate) fn expand_to_stmts(rules: &MacroRules, invocation: &str) -> ast::MacroStmts {\n-    let expanded = expand(rules, invocation);\n-    token_tree_to_macro_stmts(&expanded).unwrap().tree()\n-}\n-\n-pub(crate) fn expand_to_expr(rules: &MacroRules, invocation: &str) -> ast::Expr {\n-    let expanded = expand(rules, invocation);\n-    token_tree_to_expr(&expanded).unwrap().tree()\n-}\n-\n-pub(crate) fn text_to_tokentree(text: &str) -> tt::Subtree {\n-    // wrap the given text to a macro call\n-    let wrapped = format!(\"wrap_macro!( {} )\", text);\n-    let wrapped = ast::SourceFile::parse(&wrapped);\n-    let wrapped = wrapped.tree().syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-    let mut wrapped = ast_to_token_tree(&wrapped).unwrap().0;\n-    wrapped.delimiter = tt::Delimiter::None;\n-\n-    wrapped\n-}\n-\n-pub(crate) enum MacroKind {\n-    Items,\n-    Stmts,\n-}\n-\n-use ra_syntax::WalkEvent;\n-\n-pub fn debug_dump_ignore_spaces(node: &ra_syntax::SyntaxNode) -> String {\n-    use std::fmt::Write;\n-\n-    let mut level = 0;\n-    let mut buf = String::new();\n-    macro_rules! indent {\n-        () => {\n-            for _ in 0..level {\n-                buf.push_str(\"  \");\n-            }\n-        };\n-    }\n-\n-    for event in node.preorder_with_tokens() {\n-        match event {\n-            WalkEvent::Enter(element) => {\n-                match element {\n-                    NodeOrToken::Node(node) => {\n-                        indent!();\n-                        writeln!(buf, \"{:?}\", node.kind()).unwrap();\n-                    }\n-                    NodeOrToken::Token(token) => match token.kind() {\n-                        ra_syntax::SyntaxKind::WHITESPACE => {}\n-                        _ => {\n-                            indent!();\n-                            writeln!(buf, \"{:?}\", token.kind()).unwrap();\n-                        }\n-                    },\n-                }\n-                level += 1;\n+#[test]\n+fn test_expr_order() {\n+    let rules = create_rules(\n+        r#\"\n+        macro_rules! foo {\n+            ($ i:expr) => {\n+                 fn bar() { $ i * 2; }\n             }\n-            WalkEvent::Leave(_) => level -= 1,\n         }\n-    }\n-\n-    buf\n-}\n-\n-pub(crate) fn assert_expansion(\n-    kind: MacroKind,\n-    rules: &MacroRules,\n-    invocation: &str,\n-    expected: &str,\n-) -> tt::Subtree {\n-    let expanded = expand(rules, invocation);\n-    assert_eq!(expanded.to_string(), expected);\n-\n-    let expected = expected.replace(\"$crate\", \"C_C__C\");\n-\n-    // wrap the given text to a macro call\n-    let expected = text_to_tokentree(&expected);\n-    let (expanded_tree, expected_tree) = match kind {\n-        MacroKind::Items => {\n-            let expanded_tree = token_tree_to_items(&expanded).unwrap().tree();\n-            let expected_tree = token_tree_to_items(&expected).unwrap().tree();\n-\n-            (\n-                debug_dump_ignore_spaces(expanded_tree.syntax()).trim().to_string(),\n-                debug_dump_ignore_spaces(expected_tree.syntax()).trim().to_string(),\n-            )\n-        }\n-\n-        MacroKind::Stmts => {\n-            let expanded_tree = token_tree_to_macro_stmts(&expanded).unwrap().tree();\n-            let expected_tree = token_tree_to_macro_stmts(&expected).unwrap().tree();\n-\n-            (\n-                debug_dump_ignore_spaces(expanded_tree.syntax()).trim().to_string(),\n-                debug_dump_ignore_spaces(expected_tree.syntax()).trim().to_string(),\n-            )\n-        }\n-    };\n-\n-    let expected_tree = expected_tree.replace(\"C_C__C\", \"$crate\");\n-    assert_eq!(\n-        expanded_tree, expected_tree,\n-        \"\\nleft:\\n{}\\nright:\\n{}\",\n-        expanded_tree, expected_tree,\n+\"#,\n     );\n+    let expanded = expand(&rules, \"foo! { 1 + 1}\");\n+    let tree = token_tree_to_items(&expanded).unwrap().tree();\n \n-    expanded\n+    let dump = format!(\"{:#?}\", tree.syntax());\n+    assert_eq_text!(\n+        dump.trim(),\n+        r#\"MACRO_ITEMS@[0; 15)\n+  FN_DEF@[0; 15)\n+    FN_KW@[0; 2) \"fn\"\n+    NAME@[2; 5)\n+      IDENT@[2; 5) \"bar\"\n+    PARAM_LIST@[5; 7)\n+      L_PAREN@[5; 6) \"(\"\n+      R_PAREN@[6; 7) \")\"\n+    BLOCK_EXPR@[7; 15)\n+      BLOCK@[7; 15)\n+        L_CURLY@[7; 8) \"{\"\n+        EXPR_STMT@[8; 14)\n+          BIN_EXPR@[8; 13)\n+            BIN_EXPR@[8; 11)\n+              LITERAL@[8; 9)\n+                INT_NUMBER@[8; 9) \"1\"\n+              PLUS@[9; 10) \"+\"\n+              LITERAL@[10; 11)\n+                INT_NUMBER@[10; 11) \"1\"\n+            STAR@[11; 12) \"*\"\n+            LITERAL@[12; 13)\n+              INT_NUMBER@[12; 13) \"2\"\n+          SEMI@[13; 14) \";\"\n+        R_CURLY@[14; 15) \"}\"\"#,\n+    );\n }\n \n #[test]\n@@ -704,47 +602,6 @@ fn test_expr() {\n     );\n }\n \n-#[test]\n-fn test_expr_order() {\n-    let rules = create_rules(\n-        r#\"\n-        macro_rules! foo {\n-            ($ i:expr) => {\n-                 fn bar() { $ i * 2; }\n-            }\n-        }\n-\"#,\n-    );\n-    let dump = format!(\"{:#?}\", expand_to_items(&rules, \"foo! { 1 + 1  }\").syntax());\n-    assert_eq_text!(\n-        dump.trim(),\n-        r#\"MACRO_ITEMS@[0; 15)\n-  FN_DEF@[0; 15)\n-    FN_KW@[0; 2) \"fn\"\n-    NAME@[2; 5)\n-      IDENT@[2; 5) \"bar\"\n-    PARAM_LIST@[5; 7)\n-      L_PAREN@[5; 6) \"(\"\n-      R_PAREN@[6; 7) \")\"\n-    BLOCK_EXPR@[7; 15)\n-      BLOCK@[7; 15)\n-        L_CURLY@[7; 8) \"{\"\n-        EXPR_STMT@[8; 14)\n-          BIN_EXPR@[8; 13)\n-            BIN_EXPR@[8; 11)\n-              LITERAL@[8; 9)\n-                INT_NUMBER@[8; 9) \"1\"\n-              PLUS@[9; 10) \"+\"\n-              LITERAL@[10; 11)\n-                INT_NUMBER@[10; 11) \"1\"\n-            STAR@[11; 12) \"*\"\n-            LITERAL@[12; 13)\n-              INT_NUMBER@[12; 13) \"2\"\n-          SEMI@[13; 14) \";\"\n-        R_CURLY@[14; 15) \"}\"\"#,\n-    );\n-}\n-\n #[test]\n fn test_last_expr() {\n     let rules = create_rules(\n@@ -1061,8 +918,11 @@ fn test_vec() {\n         r#\"{let mut v = Vec :: new () ; v . push (1u32) ; v . push (2) ; v}\"#,\n     );\n \n+    let expansion = expand(&rules, r#\"vec![1u32,2];\"#);\n+    let tree = token_tree_to_expr(&expansion).unwrap().tree();\n+\n     assert_eq!(\n-        format!(\"{:#?}\", expand_to_expr(&rules, r#\"vec![1u32,2];\"#).syntax()).trim(),\n+        format!(\"{:#?}\", tree.syntax()).trim(),\n         r#\"BLOCK_EXPR@[0; 45)\n   BLOCK@[0; 45)\n     L_CURLY@[0; 1) \"{\"\n@@ -1502,3 +1362,117 @@ macro_rules! delegate_impl {\n \n     assert_expansion(MacroKind::Items, &rules, r#\"delegate_impl ! {[G , & 'a mut G , deref] pub trait Data : GraphBase {@ section type type NodeWeight ;}}\"#, \"impl <> Data for & \\'a mut G where G : Data {}\");\n }\n+\n+pub(crate) fn create_rules(macro_definition: &str) -> MacroRules {\n+    let source_file = ast::SourceFile::parse(macro_definition).ok().unwrap();\n+    let macro_definition =\n+        source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n+\n+    let (definition_tt, _) = ast_to_token_tree(&macro_definition.token_tree().unwrap()).unwrap();\n+    crate::MacroRules::parse(&definition_tt).unwrap()\n+}\n+\n+pub(crate) fn expand(rules: &MacroRules, invocation: &str) -> tt::Subtree {\n+    let source_file = ast::SourceFile::parse(invocation).ok().unwrap();\n+    let macro_invocation =\n+        source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n+\n+    let (invocation_tt, _) = ast_to_token_tree(&macro_invocation.token_tree().unwrap()).unwrap();\n+\n+    rules.expand(&invocation_tt).unwrap()\n+}\n+\n+pub(crate) enum MacroKind {\n+    Items,\n+    Stmts,\n+}\n+\n+pub(crate) fn assert_expansion(\n+    kind: MacroKind,\n+    rules: &MacroRules,\n+    invocation: &str,\n+    expected: &str,\n+) -> tt::Subtree {\n+    let expanded = expand(rules, invocation);\n+    assert_eq!(expanded.to_string(), expected);\n+\n+    let expected = expected.replace(\"$crate\", \"C_C__C\");\n+\n+    // wrap the given text to a macro call\n+    let expected = {\n+        let wrapped = format!(\"wrap_macro!( {} )\", expected);\n+        let wrapped = ast::SourceFile::parse(&wrapped);\n+        let wrapped = wrapped.tree().syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        let mut wrapped = ast_to_token_tree(&wrapped).unwrap().0;\n+        wrapped.delimiter = tt::Delimiter::None;\n+        wrapped\n+    };\n+    let (expanded_tree, expected_tree) = match kind {\n+        MacroKind::Items => {\n+            let expanded_tree = token_tree_to_items(&expanded).unwrap().tree();\n+            let expected_tree = token_tree_to_items(&expected).unwrap().tree();\n+\n+            (\n+                debug_dump_ignore_spaces(expanded_tree.syntax()).trim().to_string(),\n+                debug_dump_ignore_spaces(expected_tree.syntax()).trim().to_string(),\n+            )\n+        }\n+\n+        MacroKind::Stmts => {\n+            let expanded_tree = token_tree_to_macro_stmts(&expanded).unwrap().tree();\n+            let expected_tree = token_tree_to_macro_stmts(&expected).unwrap().tree();\n+\n+            (\n+                debug_dump_ignore_spaces(expanded_tree.syntax()).trim().to_string(),\n+                debug_dump_ignore_spaces(expected_tree.syntax()).trim().to_string(),\n+            )\n+        }\n+    };\n+\n+    let expected_tree = expected_tree.replace(\"C_C__C\", \"$crate\");\n+    assert_eq!(\n+        expanded_tree, expected_tree,\n+        \"\\nleft:\\n{}\\nright:\\n{}\",\n+        expanded_tree, expected_tree,\n+    );\n+\n+    expanded\n+}\n+\n+pub fn debug_dump_ignore_spaces(node: &ra_syntax::SyntaxNode) -> String {\n+    use std::fmt::Write;\n+\n+    let mut level = 0;\n+    let mut buf = String::new();\n+    macro_rules! indent {\n+        () => {\n+            for _ in 0..level {\n+                buf.push_str(\"  \");\n+            }\n+        };\n+    }\n+\n+    for event in node.preorder_with_tokens() {\n+        match event {\n+            WalkEvent::Enter(element) => {\n+                match element {\n+                    NodeOrToken::Node(node) => {\n+                        indent!();\n+                        writeln!(buf, \"{:?}\", node.kind()).unwrap();\n+                    }\n+                    NodeOrToken::Token(token) => match token.kind() {\n+                        ra_syntax::SyntaxKind::WHITESPACE => {}\n+                        _ => {\n+                            indent!();\n+                            writeln!(buf, \"{:?}\", token.kind()).unwrap();\n+                        }\n+                    },\n+                }\n+                level += 1;\n+            }\n+            WalkEvent::Leave(_) => level -= 1,\n+        }\n+    }\n+\n+    buf\n+}"}]}