{"sha": "d785c8c447bd7f972e68e346a3f7b04c56ce486b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ODVjOGM0NDdiZDdmOTcyZTY4ZTM0NmEzZjdiMDRjNTZjZTQ4NmI=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2021-02-12T22:45:19Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2021-02-13T19:30:07Z"}, "message": "Remove unnecessary function parameters project.rs", "tree": {"sha": "33a23e7891df9ea355c73b9e81749723595fcfac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33a23e7891df9ea355c73b9e81749723595fcfac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d785c8c447bd7f972e68e346a3f7b04c56ce486b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d785c8c447bd7f972e68e346a3f7b04c56ce486b", "html_url": "https://github.com/rust-lang/rust/commit/d785c8c447bd7f972e68e346a3f7b04c56ce486b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d785c8c447bd7f972e68e346a3f7b04c56ce486b/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfee89f75545b4fadc559eee324afc8bb0bdc1be", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfee89f75545b4fadc559eee324afc8bb0bdc1be", "html_url": "https://github.com/rust-lang/rust/commit/dfee89f75545b4fadc559eee324afc8bb0bdc1be"}], "stats": {"total": 30, "additions": 9, "deletions": 21}, "files": [{"sha": "bfaca4215edb7684ad3ffc565f9b27120773285c", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d785c8c447bd7f972e68e346a3f7b04c56ce486b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d785c8c447bd7f972e68e346a3f7b04c56ce486b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=d785c8c447bd7f972e68e346a3f7b04c56ce486b", "patch": "@@ -741,11 +741,7 @@ fn project_type<'cx, 'tcx>(\n         return Err(ProjectionTyError::TraitSelectionError(SelectionError::Overflow));\n     }\n \n-    let obligation_trait_ref = &obligation.predicate.trait_ref(selcx.tcx());\n-\n-    debug!(?obligation_trait_ref);\n-\n-    if obligation_trait_ref.references_error() {\n+    if obligation.predicate.references_error() {\n         return Ok(ProjectedTy::Progress(Progress::error(selcx.tcx())));\n     }\n \n@@ -754,19 +750,19 @@ fn project_type<'cx, 'tcx>(\n     // Make sure that the following procedures are kept in order. ParamEnv\n     // needs to be first because it has highest priority, and Select checks\n     // the return value of push_candidate which assumes it's ran at last.\n-    assemble_candidates_from_param_env(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+    assemble_candidates_from_param_env(selcx, obligation, &mut candidates);\n \n-    assemble_candidates_from_trait_def(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+    assemble_candidates_from_trait_def(selcx, obligation, &mut candidates);\n \n-    assemble_candidates_from_object_ty(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+    assemble_candidates_from_object_ty(selcx, obligation, &mut candidates);\n \n     if let ProjectionTyCandidateSet::Single(ProjectionTyCandidate::Object(_)) = candidates {\n         // Avoid normalization cycle from selection (see\n         // `assemble_candidates_from_object_ty`).\n         // FIXME(lazy_normalization): Lazy normalization should save us from\n-        // having to do special case this.\n+        // having to special case this.\n     } else {\n-        assemble_candidates_from_impls(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+        assemble_candidates_from_impls(selcx, obligation, &mut candidates);\n     };\n \n     match candidates {\n@@ -792,14 +788,12 @@ fn project_type<'cx, 'tcx>(\n fn assemble_candidates_from_param_env<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_param_env(..)\");\n     assemble_candidates_from_predicates(\n         selcx,\n         obligation,\n-        obligation_trait_ref,\n         candidate_set,\n         ProjectionTyCandidate::ParamEnv,\n         obligation.param_env.caller_bounds().iter(),\n@@ -820,15 +814,14 @@ fn assemble_candidates_from_param_env<'cx, 'tcx>(\n fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_trait_def(..)\");\n \n     let tcx = selcx.tcx();\n     // Check whether the self-type is itself a projection.\n     // If so, extract what we know from the trait and try to come up with a good answer.\n-    let bounds = match *obligation_trait_ref.self_ty().kind() {\n+    let bounds = match *obligation.predicate.self_ty().kind() {\n         ty::Projection(ref data) => tcx.item_bounds(data.item_def_id).subst(tcx, data.substs),\n         ty::Opaque(def_id, substs) => tcx.item_bounds(def_id).subst(tcx, substs),\n         ty::Infer(ty::TyVar(_)) => {\n@@ -843,7 +836,6 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     assemble_candidates_from_predicates(\n         selcx,\n         obligation,\n-        obligation_trait_ref,\n         candidate_set,\n         ProjectionTyCandidate::TraitDef,\n         bounds.iter(),\n@@ -863,14 +855,13 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_object_ty(..)\");\n \n     let tcx = selcx.tcx();\n \n-    let self_ty = obligation_trait_ref.self_ty();\n+    let self_ty = obligation.predicate.self_ty();\n     let object_ty = selcx.infcx().shallow_resolve(self_ty);\n     let data = match object_ty.kind() {\n         ty::Dynamic(data, ..) => data,\n@@ -890,7 +881,6 @@ fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n     assemble_candidates_from_predicates(\n         selcx,\n         obligation,\n-        obligation_trait_ref,\n         candidate_set,\n         ProjectionTyCandidate::Object,\n         env_predicates,\n@@ -901,7 +891,6 @@ fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n     env_predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n@@ -947,14 +936,13 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n fn assemble_candidates_from_impls<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_impls\");\n \n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n-    let poly_trait_ref = ty::Binder::dummy(*obligation_trait_ref);\n+    let poly_trait_ref = obligation.predicate.trait_ref(selcx.tcx()).to_poly_trait_ref();\n     let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n     let _ = selcx.infcx().commit_if_ok(|_| {\n         let impl_source = match selcx.select(&trait_obligation) {"}]}