{"sha": "dcd84901c674eda61fefc363a0adc44790b4e24f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZDg0OTAxYzY3NGVkYTYxZmVmYzM2M2EwYWRjNDQ3OTBiNGUyNGY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-29T19:49:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-30T13:47:14Z"}, "message": "Remove TrByImplicitRef and source field on datums", "tree": {"sha": "3a71759717b4bdfedd161cb5a7e455ecd20dfd44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a71759717b4bdfedd161cb5a7e455ecd20dfd44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcd84901c674eda61fefc363a0adc44790b4e24f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd84901c674eda61fefc363a0adc44790b4e24f", "html_url": "https://github.com/rust-lang/rust/commit/dcd84901c674eda61fefc363a0adc44790b4e24f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcd84901c674eda61fefc363a0adc44790b4e24f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "682afcac5200019b363310f56cfabb78edea9397", "url": "https://api.github.com/repos/rust-lang/rust/commits/682afcac5200019b363310f56cfabb78edea9397", "html_url": "https://github.com/rust-lang/rust/commit/682afcac5200019b363310f56cfabb78edea9397"}], "stats": {"total": 201, "additions": 86, "deletions": 115}, "files": [{"sha": "22a487a41143ec86d19fd833c0299d3e3fd1ec91", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dcd84901c674eda61fefc363a0adc44790b4e24f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd84901c674eda61fefc363a0adc44790b4e24f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=dcd84901c674eda61fefc363a0adc44790b4e24f", "patch": "@@ -314,7 +314,6 @@ pub fn variant_opt(bcx: block, pat_id: ast::node_id)\n pub enum TransBindingMode {\n     TrByValue(/*ismove:*/ bool, /*llbinding:*/ ValueRef),\n     TrByRef,\n-    TrByImplicitRef\n }\n \n /**\n@@ -881,7 +880,7 @@ fn match_datum(bcx: block, val: ValueRef, pat_id: ast::node_id) -> Datum {\n     //! we should just pass around a Datum and be done with it.\n \n     let ty = node_id_type(bcx, pat_id);\n-    Datum {val: val, ty: ty, mode: datum::ByRef, source: RevokeClean}\n+    Datum {val: val, ty: ty, mode: datum::ByRef(RevokeClean)}\n }\n \n \n@@ -988,7 +987,7 @@ pub fn root_pats_as_necessary(mut bcx: block,\n         let pat_id = br.pats[col].id;\n         if pat_id != 0 {\n             let datum = Datum {val: val, ty: node_id_type(bcx, pat_id),\n-                               mode: ByRef, source: ZeroMem};\n+                               mode: ByRef(ZeroMem)};\n             bcx = datum.root_and_write_guard(bcx, br.pats[col].span, pat_id, 0);\n         }\n     }\n@@ -1146,7 +1145,7 @@ pub fn store_non_ref_bindings(bcx: block,\n             TrByValue(is_move, lldest) => {\n                 let llval = Load(bcx, binding_info.llmatch); // get a T*\n                 let datum = Datum {val: llval, ty: binding_info.ty,\n-                                   mode: ByRef, source: ZeroMem};\n+                                   mode: ByRef(ZeroMem)};\n                 bcx = {\n                     if is_move {\n                         datum.move_to(bcx, INIT, lldest)\n@@ -1161,7 +1160,7 @@ pub fn store_non_ref_bindings(bcx: block,\n                     temp_cleanups\n                 }\n             }\n-            TrByRef | TrByImplicitRef => {}\n+            TrByRef => {}\n         }\n     }\n     return bcx;\n@@ -1192,13 +1191,6 @@ pub fn insert_lllocals(bcx: block,\n             TrByRef => {\n                 binding_info.llmatch\n             }\n-\n-            // Ugly: for implicit ref, we actually want a T*, but\n-            // we have a T**, so we had to load.  This will go away\n-            // once implicit refs go away.\n-            TrByImplicitRef => {\n-                Load(bcx, binding_info.llmatch)\n-            }\n         };\n \n         bcx.fcx.lllocals.insert(binding_info.id,\n@@ -1254,7 +1246,7 @@ pub fn compile_guard(bcx: block,\n                 TrByValue(_, llval) => {\n                     bcx = glue::drop_ty(bcx, llval, binding_info.ty);\n                 }\n-                TrByRef | TrByImplicitRef => {}\n+                TrByRef => {}\n             }\n             bcx.fcx.lllocals.remove(&binding_info.id);\n         }\n@@ -1757,7 +1749,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n             if make_copy {\n                 let binding_ty = node_id_type(bcx, pat.id);\n                 let datum = Datum {val: val, ty: binding_ty,\n-                                   mode: ByRef, source: RevokeClean};\n+                                   mode: ByRef(RevokeClean)};\n                 let scratch = scratch_datum(bcx, binding_ty, false);\n                 datum.copy_to_datum(bcx, INIT, scratch);\n                 match binding_mode {"}, {"sha": "557388cf11cce87d1afe7e15357d8e20caa4a696", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcd84901c674eda61fefc363a0adc44790b4e24f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd84901c674eda61fefc363a0adc44790b4e24f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=dcd84901c674eda61fefc363a0adc44790b4e24f", "patch": "@@ -711,8 +711,7 @@ pub fn trans_arg_expr(bcx: block,\n                     DatumBlock {bcx: bcx,\n                                 datum: Datum {val: scratch,\n                                               ty: scratch_ty,\n-                                              mode: ByRef,\n-                                              source: RevokeClean}}\n+                                              mode: ByRef(RevokeClean)}}\n                 }\n                 _ => {\n                     bcx.sess().impossible_case(\n@@ -775,7 +774,7 @@ pub fn trans_arg_expr(bcx: block,\n \n                         match arg_datum.appropriate_mode() {\n                             ByValue => val = Load(bcx, scratch.val),\n-                            ByRef => val = scratch.val,\n+                            ByRef(_) => val = scratch.val,\n                         }\n                     }\n                 }"}, {"sha": "1a78019f289f0f9cfd688b154eea5cda8daab556", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcd84901c674eda61fefc363a0adc44790b4e24f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd84901c674eda61fefc363a0adc44790b4e24f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=dcd84901c674eda61fefc363a0adc44790b4e24f", "patch": "@@ -287,7 +287,7 @@ pub fn build_closure(bcx0: block,\n     for include_ret_handle.each |flagptr| {\n         // Flag indicating we have returned (a by-ref bool):\n         let flag_datum = Datum {val: *flagptr, ty: ty::mk_bool(),\n-                                mode: ByRef, source: ZeroMem};\n+                                mode: ByRef(ZeroMem)};\n         env_vals.push(EnvValue {action: EnvRef,\n                                 datum: flag_datum});\n \n@@ -299,7 +299,7 @@ pub fn build_closure(bcx0: block,\n         };\n         let ret_casted = PointerCast(bcx, ret_true, T_ptr(T_nil()));\n         let ret_datum = Datum {val: ret_casted, ty: ty::mk_nil(),\n-                               mode: ByRef, source: ZeroMem};\n+                               mode: ByRef(ZeroMem)};\n         env_vals.push(EnvValue {action: EnvRef,\n                                 datum: ret_datum});\n     }"}, {"sha": "692fbf47957188b30a9e2bc160100a7bbfee0451", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 59, "deletions": 69, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/dcd84901c674eda61fefc363a0adc44790b4e24f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd84901c674eda61fefc363a0adc44790b4e24f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=dcd84901c674eda61fefc363a0adc44790b4e24f", "patch": "@@ -44,15 +44,17 @@\n  * # Datum cleanup styles\n  *\n  * Each datum carries with it an idea of how its value will be cleaned\n- * up.  This is important after a move, because we need to know how to\n- * cancel the cleanup (since the value has been moved and therefore does\n- * not need to be freed).  There are two options:\n- *\n- * 1. `RevokeClean`: To cancel the cleanup, we invoke `revoke_clean()`.\n- *    This is used for temporary rvalues.\n- *\n- * 2. `ZeroMem`: To cancel the cleanup, we zero out the memory where\n- *    the value resides.  This is used for lvalues.\n+ * up.  This is primarily determined by the mode: a `ByValue` datum\n+ * will always be cleaned up by revoking cleanup using\n+ * `revoke_clean()`, because there is no other option. By ref datums\n+ * can sometimes be cleaned up via `revoke_clean` (in particular,\n+ * by-ref datums that originated from rvalues), but sometimes they\n+ * must be zeroed. This is indicated by the `DatumCleanup`\n+ * parameter. Note that zeroing a by-ref datum *always works* to\n+ * cancel the cleanup, but using `revoke_clean` is preferable since\n+ * there is no runtime cost. Some older parts of the code (notably\n+ * `match_`, at least at the time of this writing) rely on this and\n+ * only use zeroing.\n  *\n  * # Copying, moving, and storing\n  *\n@@ -125,54 +127,44 @@ pub struct Datum {\n \n     /// Indicates whether this is by-ref or by-value.\n     mode: DatumMode,\n-\n-    /// How did this value originate?  This is particularly important\n-    /// if the value is MOVED or prematurely DROPPED, because it\n-    /// describes how to cancel the cleanup that was scheduled before.\n-    /// See the def'n of the `DatumCleanup` type.\n-    source: DatumCleanup\n }\n \n pub struct DatumBlock {\n     bcx: block,\n     datum: Datum,\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum DatumMode {\n-    /// `val` is a pointer to the actual value (and thus has type *T)\n-    ByRef,\n+    /// `val` is a pointer to the actual value (and thus has type *T).\n+    /// The argument indicates how to cancel cleanup of this datum if\n+    /// the value is moved elsewhere, which can either be by zeroing\n+    /// the memory or by canceling a registered cleanup.\n+    ByRef(DatumCleanup),\n \n     /// `val` is the actual value (*only used for immediates* like ints, ptrs)\n     ByValue,\n }\n \n pub impl DatumMode {\n     fn is_by_ref(&self) -> bool {\n-        match *self { ByRef => true, ByValue => false }\n+        match *self { ByRef(_) => true, ByValue => false }\n     }\n \n     fn is_by_value(&self) -> bool {\n-        match *self { ByRef => false, ByValue => true }\n-    }\n-}\n-\n-impl to_bytes::IterBytes for DatumMode {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as uint).iter_bytes(lsb0, f)\n+        match *self { ByRef(_) => false, ByValue => true }\n     }\n }\n \n /// See `Datum cleanup styles` section at the head of this module.\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum DatumCleanup {\n     RevokeClean,\n     ZeroMem\n }\n \n pub fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum {\n-    return Datum {val: val, ty: ty,\n-                  mode: ByValue, source: RevokeClean};\n+    return Datum {val: val, ty: ty, mode: ByValue};\n }\n \n pub fn immediate_rvalue_bcx(bcx: block,\n@@ -195,7 +187,7 @@ pub fn scratch_datum(bcx: block, ty: ty::t, zero: bool) -> Datum {\n \n     let llty = type_of::type_of(bcx.ccx(), ty);\n     let scratch = alloca_maybe_zeroed(bcx, llty, zero);\n-    Datum { val: scratch, ty: ty, mode: ByRef, source: RevokeClean }\n+    Datum { val: scratch, ty: ty, mode: ByRef(RevokeClean) }\n }\n \n pub fn appropriate_mode(ty: ty::t) -> DatumMode {\n@@ -210,7 +202,7 @@ pub fn appropriate_mode(ty: ty::t) -> DatumMode {\n     } else if ty::type_is_immediate(ty) {\n         ByValue\n     } else {\n-        ByRef\n+        ByRef(RevokeClean)\n     }\n }\n \n@@ -289,7 +281,7 @@ pub impl Datum {\n             ty::type_needs_drop(bcx.tcx(), self.ty)\n         {\n             match self.mode {\n-                ByRef => {\n+                ByRef(_) => {\n                     let cast = PointerCast(bcx, dst, val_ty(self.val));\n                     let cmp = ICmp(bcx, lib::llvm::IntNE, cast, self.val);\n                     do with_cond(bcx, cmp) |bcx| {\n@@ -324,7 +316,7 @@ pub impl Datum {\n             ByValue => {\n                 Store(bcx, self.val, dst);\n             }\n-            ByRef => {\n+            ByRef(_) => {\n                 memcpy_ty(bcx, dst, self.val, self.ty);\n             }\n         }\n@@ -352,7 +344,7 @@ pub impl Datum {\n         }\n \n         match self.mode {\n-            ByRef => {\n+            ByRef(_) => {\n                 memcpy_ty(bcx, dst, self.val, self.ty);\n             }\n             ByValue => {\n@@ -367,28 +359,32 @@ pub impl Datum {\n \n     fn add_clean(&self, bcx: block) {\n         /*!\n-         *\n          * Schedules this datum for cleanup in `bcx`.  The datum\n-         * must be an rvalue. */\n+         * must be an rvalue.\n+         */\n \n-        assert_eq!(self.source, RevokeClean);\n         match self.mode {\n             ByValue => {\n                 add_clean_temp_immediate(bcx, self.val, self.ty);\n             }\n-            ByRef => {\n+            ByRef(RevokeClean) => {\n                 add_clean_temp_mem(bcx, self.val, self.ty);\n             }\n+            ByRef(ZeroMem) => {\n+                bcx.tcx().sess.bug(\n+                    fmt!(\"Cannot add clean to a 'zero-mem' datum\"));\n+            }\n         }\n     }\n \n     fn cancel_clean(&self, bcx: block) {\n         if ty::type_needs_drop(bcx.tcx(), self.ty) {\n-            match self.source {\n-                RevokeClean => {\n+            match self.mode {\n+                ByValue |\n+                ByRef(RevokeClean) => {\n                     revoke_clean(bcx, self.val);\n                 }\n-                ZeroMem => {\n+                ByRef(ZeroMem) => {\n                     // Lvalues which potentially need to be dropped\n                     // must be passed by ref, so that we can zero them\n                     // out.\n@@ -400,11 +396,10 @@ pub impl Datum {\n     }\n \n     fn to_str(&self, ccx: &CrateContext) -> ~str {\n-        fmt!(\"Datum { val=%s, ty=%s, mode=%?, source=%? }\",\n+        fmt!(\"Datum { val=%s, ty=%s, mode=%? }\",\n              val_str(ccx.tn, self.val),\n              ty_to_str(ccx.tcx, self.ty),\n-             self.mode,\n-             self.source)\n+             self.mode)\n     }\n \n     fn to_value_datum(&self, bcx: block) -> Datum {\n@@ -417,9 +412,9 @@ pub impl Datum {\n \n         match self.mode {\n             ByValue => *self,\n-            ByRef => {\n+            ByRef(_) => {\n                 Datum {val: self.to_value_llval(bcx), mode: ByValue,\n-                       ty: self.ty, source: RevokeClean}\n+                       ty: self.ty}\n             }\n         }\n     }\n@@ -434,7 +429,7 @@ pub impl Datum {\n         } else {\n             match self.mode {\n                 ByValue => self.val,\n-                ByRef => {\n+                ByRef(_) => {\n                     if ty::type_is_bool(self.ty) {\n                         LoadRangeAssert(bcx, self.val, 0, 2, lib::llvm::True)\n                     } else {\n@@ -447,24 +442,24 @@ pub impl Datum {\n \n     fn to_ref_datum(&self, bcx: block) -> Datum {\n         /*!\n-         *\n          * Yields a by-ref form of this datum.  This may involve\n          * creation of a temporary stack slot.  The value returned by\n          * this function is not separately rooted from this datum, so\n-         * it will not live longer than the current datum. */\n+         * it will not live longer than the current datum.\n+         */\n \n         match self.mode {\n-            ByRef => *self,\n+            ByRef(_) => *self,\n             ByValue => {\n-                Datum {val: self.to_ref_llval(bcx), mode: ByRef,\n-                       ty: self.ty, source: RevokeClean}\n+                Datum {val: self.to_ref_llval(bcx), mode: ByRef(RevokeClean),\n+                       ty: self.ty}\n             }\n         }\n     }\n \n     fn to_ref_llval(&self, bcx: block) -> ValueRef {\n         match self.mode {\n-            ByRef => self.val,\n+            ByRef(_) => self.val,\n             ByValue => {\n                 if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n                     C_null(T_ptr(type_of::type_of(bcx.ccx(), self.ty)))\n@@ -490,7 +485,7 @@ pub impl Datum {\n \n         match self.appropriate_mode() {\n             ByValue => self.to_value_llval(bcx),\n-            ByRef => self.to_ref_llval(bcx)\n+            ByRef(_) => self.to_ref_llval(bcx)\n         }\n     }\n \n@@ -501,7 +496,7 @@ pub impl Datum {\n \n         match self.appropriate_mode() {\n             ByValue => self.to_value_datum(bcx),\n-            ByRef => self.to_ref_datum(bcx)\n+            ByRef(_) => self.to_ref_datum(bcx)\n         }\n     }\n \n@@ -512,9 +507,8 @@ pub impl Datum {\n         let base_val = self.to_ref_llval(bcx);\n         Datum {\n             val: gep(base_val),\n-            mode: ByRef,\n+            mode: ByRef(source),\n             ty: ty,\n-            source: source\n         }\n     }\n \n@@ -524,7 +518,7 @@ pub impl Datum {\n         }\n \n         return match self.mode {\n-            ByRef => glue::drop_ty(bcx, self.val, self.ty),\n+            ByRef(_) => glue::drop_ty(bcx, self.val, self.ty),\n             ByValue => glue::drop_ty_immediate(bcx, self.val, self.ty)\n         };\n     }\n@@ -546,7 +540,7 @@ pub impl Datum {\n \n         let ptr = self.to_value_llval(bcx);\n         let body = opaque_box_body(bcx, content_ty, ptr);\n-        Datum {val: body, ty: content_ty, mode: ByRef, source: ZeroMem}\n+        Datum {val: body, ty: content_ty, mode: ByRef(ZeroMem)}\n     }\n \n     fn to_rptr(&self, bcx: block) -> Datum {\n@@ -561,8 +555,7 @@ pub impl Datum {\n         let llval = self.to_ref_llval(bcx);\n         let rptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::re_static,\n                                       self.ty);\n-        Datum {val: llval, ty: rptr_ty,\n-               mode: ByValue, source: RevokeClean}\n+        Datum {val: llval, ty: rptr_ty, mode: ByValue}\n     }\n \n     fn try_deref(&self,\n@@ -606,16 +599,15 @@ pub impl Datum {\n                 let repr = adt::represent_type(ccx, self.ty);\n                 let ty = ty::subst(ccx.tcx, substs, variants[0].args[0]);\n                 return match self.mode {\n-                    ByRef => {\n+                    ByRef(_) => {\n                         // Recast lv.val as a pointer to the newtype\n                         // rather than a ptr to the enum type.\n                         (\n                             Some(Datum {\n                                 val: adt::trans_field_ptr(bcx, repr, self.val,\n                                                     0, 0),\n                                 ty: ty,\n-                                mode: ByRef,\n-                                source: ZeroMem\n+                                mode: ByRef(ZeroMem)\n                             }),\n                             bcx\n                         )\n@@ -645,7 +637,7 @@ pub impl Datum {\n                 let repr = adt::represent_type(ccx, self.ty);\n                 let ty = fields[0].mt.ty;\n                 return match self.mode {\n-                    ByRef => {\n+                    ByRef(_) => {\n                         // Recast lv.val as a pointer to the newtype rather\n                         // than a pointer to the struct type.\n                         // FIXME #6572: This isn't correct for structs with\n@@ -655,8 +647,7 @@ pub impl Datum {\n                                 val: adt::trans_field_ptr(bcx, repr, self.val,\n                                                     0, 0),\n                                 ty: ty,\n-                                mode: ByRef,\n-                                source: ZeroMem\n+                                mode: ByRef(ZeroMem)\n                             }),\n                             bcx\n                         )\n@@ -683,8 +674,7 @@ pub impl Datum {\n             Datum {\n                 val: lv.to_value_llval(bcx),\n                 ty: ty,\n-                mode: ByRef,\n-                source: ZeroMem // *p is an lvalue\n+                mode: ByRef(ZeroMem)\n             }\n         }\n     }"}, {"sha": "a7d064dde46f53b94e5b53f6017a032dab94ee83", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dcd84901c674eda61fefc363a0adc44790b4e24f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd84901c674eda61fefc363a0adc44790b4e24f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=dcd84901c674eda61fefc363a0adc44790b4e24f", "patch": "@@ -247,7 +247,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         // must patchup the type.\n         DatumBlock {bcx: bcx,\n                     datum: Datum {val: datum.val, ty: adjusted_ty,\n-                                  mode: datum.mode, source: datum.source}}\n+                                  mode: datum.mode}}\n     }\n \n     fn auto_slice(bcx: block,\n@@ -793,8 +793,7 @@ fn trans_def_datum_unadjusted(bcx: block,\n             bcx: bcx,\n             datum: Datum {val: llval,\n                           ty: rust_ty,\n-                          mode: ByValue,\n-                          source: RevokeClean}\n+                          mode: ByValue}\n         };\n     }\n }\n@@ -920,8 +919,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n             bcx: bcx,\n             datum: Datum {val: elt,\n                           ty: vt.unit_ty,\n-                          mode: ByRef,\n-                          source: ZeroMem}\n+                          mode: ByRef(ZeroMem)}\n         };\n     }\n \n@@ -988,8 +986,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                     bcx: bcx,\n                     datum: Datum {val: val,\n                                   ty: const_ty,\n-                                  mode: ByRef,\n-                                  source: ZeroMem}\n+                                  mode: ByRef(ZeroMem)}\n                 }\n             }\n             _ => {\n@@ -1014,8 +1011,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n                     Datum {\n                         val: val,\n                         ty: local_ty,\n-                        mode: ByRef,\n-                        source: ZeroMem\n+                        mode: ByRef(ZeroMem)\n                     }\n                 }\n                 None => {\n@@ -1052,8 +1048,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n             Datum {\n                 val: casted_val,\n                 ty: self_info.t,\n-                mode: ByRef,\n-                source: ZeroMem\n+                mode: ByRef(ZeroMem)\n             }\n         }\n         _ => {\n@@ -1066,7 +1061,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n                   table: &HashMap<ast::node_id, local_val>,\n                   nid: ast::node_id) -> Datum {\n         let (v, mode) = match table.find(&nid) {\n-            Some(&local_mem(v)) => (v, ByRef),\n+            Some(&local_mem(v)) => (v, ByRef(ZeroMem)),\n             Some(&local_imm(v)) => (v, ByValue),\n             None => {\n                 bcx.sess().bug(fmt!(\n@@ -1082,7 +1077,6 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n             val: v,\n             ty: ty,\n             mode: mode,\n-            source: ZeroMem\n         }\n     }\n }"}, {"sha": "ae68a28de97df51fd2676061d8ed7fb60a466aa3", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dcd84901c674eda61fefc363a0adc44790b4e24f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd84901c674eda61fefc363a0adc44790b4e24f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=dcd84901c674eda61fefc363a0adc44790b4e24f", "patch": "@@ -692,19 +692,15 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                   fcx.llretptr.get());\n         }\n         ~\"move_val\" => {\n-            // Create a datum reflecting the value being moved:\n-            //\n-            // - the datum will be by ref if the value is non-immediate;\n-            //\n-            // - the datum has a RevokeClean source because, that way,\n-            //   the `move_to()` method does not feel compelled to\n-            //   zero out the memory where the datum resides.  Zeroing\n-            //   is not necessary since, for intrinsics, there is no\n-            //   cleanup to concern ourselves with.\n+            // Create a datum reflecting the value being moved.\n+            // Use `appropriate_mode` so that the datum is by ref\n+            // if the value is non-immediate. Note that, with\n+            // intrinsics, there are no argument cleanups to\n+            // concern ourselves with.\n             let tp_ty = substs.tys[0];\n             let mode = appropriate_mode(tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n-                             ty: tp_ty, mode: mode, source: RevokeClean};\n+                             ty: tp_ty, mode: mode};\n             bcx = src.move_to(bcx, DROP_EXISTING,\n                               get_param(decl, first_real_arg));\n         }\n@@ -713,7 +709,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let tp_ty = substs.tys[0];\n             let mode = appropriate_mode(tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n-                             ty: tp_ty, mode: mode, source: RevokeClean};\n+                             ty: tp_ty, mode: mode};\n             bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n         }\n         ~\"min_align_of\" => {\n@@ -832,7 +828,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                 }\n             });\n             let datum = Datum {val: get_param(decl, first_real_arg),\n-                               mode: ByRef, ty: fty, source: ZeroMem};\n+                               mode: ByRef(ZeroMem), ty: fty};\n             let arg_vals = ~[frameaddress_val];\n             bcx = trans_call_inner(\n                 bcx, None, fty, ty::mk_nil(),"}, {"sha": "023d931a60b95e9dad0f0825903ad7184bb53899", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcd84901c674eda61fefc363a0adc44790b4e24f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd84901c674eda61fefc363a0adc44790b4e24f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=dcd84901c674eda61fefc363a0adc44790b4e24f", "patch": "@@ -197,7 +197,7 @@ pub fn trans_method_callee(bcx: block,\n     // Replace method_self with method_static here.\n     let mut origin = mentry.origin;\n     match origin {\n-        typeck::method_self(copy trait_id, copy method_index) => {\n+        typeck::method_self(trait_id, method_index) => {\n             // Get the ID of the impl we're inside.\n             let impl_def_id = bcx.fcx.impl_id.get();\n \n@@ -445,7 +445,7 @@ pub fn method_ty_param_count(ccx: @CrateContext, m_id: ast::def_id,\n                                             _, _)) => {\n                 m.generics.ty_params.len()\n             }\n-            copy e => fail!(\"method_ty_param_count %?\", e)\n+            ref e => fail!(\"method_ty_param_count %?\", *e)\n         }\n     } else {\n         csearch::get_type_param_count(ccx.sess.cstore, m_id) -"}]}