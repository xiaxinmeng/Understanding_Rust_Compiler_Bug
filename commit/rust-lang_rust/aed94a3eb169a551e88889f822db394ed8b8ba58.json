{"sha": "aed94a3eb169a551e88889f822db394ed8b8ba58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZDk0YTNlYjE2OWE1NTFlODg4ODlmODIyZGIzOTRlZDhiOGJhNTg=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-07T22:35:57Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-07T22:35:57Z"}, "message": "Merge pull request #4372 from apasel422/fmt2\n\nModernize core::extfmt::ct", "tree": {"sha": "a99934e745341138f83ccc9be0ed9b125d4775be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a99934e745341138f83ccc9be0ed9b125d4775be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aed94a3eb169a551e88889f822db394ed8b8ba58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aed94a3eb169a551e88889f822db394ed8b8ba58", "html_url": "https://github.com/rust-lang/rust/commit/aed94a3eb169a551e88889f822db394ed8b8ba58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aed94a3eb169a551e88889f822db394ed8b8ba58/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53f41f07ce2811a975ea6362d6a07b070d4bdf77", "url": "https://api.github.com/repos/rust-lang/rust/commits/53f41f07ce2811a975ea6362d6a07b070d4bdf77", "html_url": "https://github.com/rust-lang/rust/commit/53f41f07ce2811a975ea6362d6a07b070d4bdf77"}, {"sha": "1d4c5d90bde5b96cbb0fe55605e11b0f85aefbb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d4c5d90bde5b96cbb0fe55605e11b0f85aefbb6", "html_url": "https://github.com/rust-lang/rust/commit/1d4c5d90bde5b96cbb0fe55605e11b0f85aefbb6"}], "stats": {"total": 433, "additions": 281, "deletions": 152}, "files": [{"sha": "312fc18a033c1b23532a7648cca731a8a37c85d6", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 281, "deletions": 152, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/aed94a3eb169a551e88889f822db394ed8b8ba58/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aed94a3eb169a551e88889f822db394ed8b8ba58/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=aed94a3eb169a551e88889f822db394ed8b8ba58", "patch": "@@ -102,8 +102,13 @@ pub mod ct {\n     use str;\n     use vec;\n \n+    #[deriving_eq]\n     pub enum Signedness { Signed, Unsigned, }\n+\n+    #[deriving_eq]\n     pub enum Caseness { CaseUpper, CaseLower, }\n+\n+    #[deriving_eq]\n     pub enum Ty {\n         TyBool,\n         TyStr,\n@@ -115,218 +120,342 @@ pub mod ct {\n         TyFloat,\n         TyPoly,\n     }\n+\n+    #[deriving_eq]\n     pub enum Flag {\n         FlagLeftJustify,\n         FlagLeftZeroPad,\n         FlagSpaceForSign,\n         FlagSignAlways,\n         FlagAlternate,\n     }\n+\n+    #[deriving_eq]\n     pub enum Count {\n         CountIs(uint),\n         CountIsParam(uint),\n         CountIsNextParam,\n         CountImplied,\n     }\n \n-    // A formatted conversion from an expression to a string\n-    pub type Conv =\n-        {param: Option<uint>,\n-         flags: ~[Flag],\n-         width: Count,\n-         precision: Count,\n-         ty: Ty};\n+    #[deriving_eq]\n+    struct Parsed<T> {\n+        val: T,\n+        next: uint\n+    }\n \n+    impl<T> Parsed<T> {\n+        static pure fn new(val: T, next: uint) -> Parsed<T> {\n+            Parsed {val: val, next: next}\n+        }\n+    }\n+\n+    // A formatted conversion from an expression to a string\n+    #[deriving_eq]\n+    pub struct Conv {\n+        param: Option<uint>,\n+        flags: ~[Flag],\n+        width: Count,\n+        precision: Count,\n+        ty: Ty\n+    }\n \n     // A fragment of the output sequence\n+    #[deriving_eq]\n     pub enum Piece { PieceString(~str), PieceConv(Conv), }\n-    pub type ErrorFn = fn@(&str) -> ! ;\n+\n+    pub type ErrorFn = @fn(&str) -> !;\n \n     pub fn parse_fmt_string(s: &str, err: ErrorFn) -> ~[Piece] {\n-        let mut pieces: ~[Piece] = ~[];\n-        let lim = str::len(s);\n-        let mut buf = ~\"\";\n-        fn flush_buf(buf: ~str, pieces: &mut ~[Piece]) -> ~str {\n-            if buf.len() > 0 {\n-                let piece = PieceString(move buf);\n-                pieces.push(move piece);\n+        fn push_slice(ps: &mut ~[Piece], s: &str, from: uint, to: uint) {\n+            if to > from {\n+                ps.push(PieceString(s.slice(from, to)));\n             }\n-            return ~\"\";\n         }\n+\n+        let lim = s.len();\n+        let mut h = 0;\n         let mut i = 0;\n+        let mut pieces = ~[];\n+\n         while i < lim {\n-            let size = str::utf8_char_width(s[i]);\n-            let curr = str::slice(s, i, i+size);\n-            if curr == ~\"%\" {\n+            if s[i] == '%' as u8 {\n                 i += 1;\n+\n                 if i >= lim {\n                     err(~\"unterminated conversion at end of string\");\n-                }\n-                let curr2 = str::slice(s, i, i+1);\n-                if curr2 == ~\"%\" {\n-                    buf += curr2;\n+                } else if s[i] == '%' as u8 {\n+                    push_slice(&mut pieces, s, h, i);\n                     i += 1;\n                 } else {\n-                    buf = flush_buf(move buf, &mut pieces);\n-                    let rs = parse_conversion(s, i, lim, err);\n-                    pieces.push(copy rs.piece);\n-                    i = rs.next;\n+                    push_slice(&mut pieces, s, h, i - 1);\n+                    let Parsed {val, next} = parse_conversion(s, i, lim, err);\n+                    pieces.push(val);\n+                    i = next;\n                 }\n-            } else { buf += curr; i += size; }\n+\n+                h = i;\n+            } else {\n+                i += str::utf8_char_width(s[i]);\n+            }\n         }\n-        flush_buf(move buf, &mut pieces);\n-        move pieces\n+\n+        push_slice(&mut pieces, s, h, i);\n+        pieces\n     }\n-    pub fn peek_num(s: &str, i: uint, lim: uint) ->\n-       Option<{num: uint, next: uint}> {\n-        let mut j = i;\n-        let mut accum = 0u;\n+\n+    pub fn peek_num(s: &str, i: uint, lim: uint) -> Option<Parsed<uint>> {\n+        let mut i = i;\n+        let mut accum = 0;\n         let mut found = false;\n-        while j < lim {\n-            match char::to_digit(s[j] as char, 10) {\n+\n+        while i < lim {\n+            match char::to_digit(s[i] as char, 10) {\n                 Some(x) => {\n                     found = true;\n                     accum *= 10;\n                     accum += x;\n-                    j += 1;\n-                },\n+                    i += 1;\n+                }\n                 None => break\n             }\n         }\n+\n         if found {\n-            Some({num: accum, next: j})\n+            Some(Parsed::new(accum, i))\n         } else {\n             None\n         }\n     }\n-    pub fn parse_conversion(s: &str, i: uint, lim: uint,\n-                            err: ErrorFn) ->\n-       {piece: Piece, next: uint} {\n-        let parm = parse_parameter(s, i, lim);\n-        let flags = parse_flags(s, parm.next, lim);\n-        let width = parse_count(s, flags.next, lim);\n+\n+    pub fn parse_conversion(s: &str, i: uint, lim: uint, err: ErrorFn) ->\n+        Parsed<Piece> {\n+        let param = parse_parameter(s, i, lim);\n+        // avoid copying ~[Flag] by destructuring\n+        let Parsed {val: flags_val, next: flags_next} = parse_flags(s,\n+            param.next, lim);\n+        let width = parse_count(s, flags_next, lim);\n         let prec = parse_precision(s, width.next, lim);\n         let ty = parse_type(s, prec.next, lim, err);\n-        return {piece:\n-                 PieceConv({param: parm.param,\n-                             flags: copy flags.flags,\n-                             width: width.count,\n-                             precision: prec.count,\n-                             ty: ty.ty}),\n-             next: ty.next};\n+\n+        Parsed::new(PieceConv(Conv {\n+            param: param.val,\n+            flags: flags_val,\n+            width: width.val,\n+            precision: prec.val,\n+            ty: ty.val}), ty.next)\n     }\n+\n     pub fn parse_parameter(s: &str, i: uint, lim: uint) ->\n-       {param: Option<uint>, next: uint} {\n-        if i >= lim { return {param: None, next: i}; }\n-        let num = peek_num(s, i, lim);\n-        return match num {\n-              None => {param: None, next: i},\n-              Some(t) => {\n-                let n = t.num;\n-                let j = t.next;\n-                if j < lim && s[j] == '$' as u8 {\n-                    {param: Some(n), next: j + 1}\n-                } else { {param: None, next: i} }\n-              }\n+        Parsed<Option<uint>> {\n+        if i >= lim { return Parsed::new(None, i); }\n+\n+        match peek_num(s, i, lim) {\n+            Some(num) if num.next < lim && s[num.next] == '$' as u8 =>\n+                Parsed::new(Some(num.val), num.next + 1),\n+            _ => Parsed::new(None, i)\n+        }\n+    }\n+\n+    pub fn parse_flags(s: &str, i: uint, lim: uint) -> Parsed<~[Flag]> {\n+        let mut i = i;\n+        let mut flags = ~[];\n+\n+        while i < lim {\n+            let f = match s[i] {\n+                '-' as u8 => FlagLeftJustify,\n+                '0' as u8 => FlagLeftZeroPad,\n+                ' ' as u8 => FlagSpaceForSign,\n+                '+' as u8 => FlagSignAlways,\n+                '#' as u8 => FlagAlternate,\n+                _ => break\n             };\n+\n+            flags.push(f);\n+            i += 1;\n+        }\n+\n+        Parsed::new(flags, i)\n     }\n-    pub fn parse_flags(s: &str, i: uint, lim: uint) ->\n-       {flags: ~[Flag], next: uint} {\n-        let noflags: ~[Flag] = ~[];\n-        if i >= lim { return {flags: move noflags, next: i}; }\n-\n-        fn more(f: Flag, s: &str, i: uint, lim: uint) ->\n-           {flags: ~[Flag], next: uint} {\n-            let next = parse_flags(s, i + 1u, lim);\n-            let rest = copy next.flags;\n-            let j = next.next;\n-            let curr: ~[Flag] = ~[f];\n-            return {flags: vec::append(move curr, rest), next: j};\n+\n+    pub fn parse_count(s: &str, i: uint, lim: uint) -> Parsed<Count> {\n+        if i >= lim {\n+            Parsed::new(CountImplied, i)\n+        } else if s[i] == '*' as u8 {\n+            let param = parse_parameter(s, i + 1, lim);\n+            let j = param.next;\n+\n+            match param.val {\n+                None => Parsed::new(CountIsNextParam, j),\n+                Some(n) => Parsed::new(CountIsParam(n), j)\n+            }\n+        } else {\n+            match peek_num(s, i, lim) {\n+                None => Parsed::new(CountImplied, i),\n+                Some(num) => Parsed::new(CountIs(num.val), num.next)\n+            }\n         }\n-        // Unfortunate, but because s is borrowed, can't use a closure\n-     //   fn more(f: Flag, s: &str) { more_(f, s, i, lim); }\n-        let f = s[i];\n-        return if f == '-' as u8 {\n-                more(FlagLeftJustify, s, i, lim)\n-            } else if f == '0' as u8 {\n-                more(FlagLeftZeroPad, s, i, lim)\n-            } else if f == ' ' as u8 {\n-                more(FlagSpaceForSign, s, i, lim)\n-            } else if f == '+' as u8 {\n-                more(FlagSignAlways, s, i, lim)\n-            } else if f == '#' as u8 {\n-                more(FlagAlternate, s, i, lim)\n-            } else { {flags: move noflags, next: i} };\n-    }\n-        pub fn parse_count(s: &str, i: uint, lim: uint)\n-        -> {count: Count, next: uint} {\n-        return if i >= lim {\n-                {count: CountImplied, next: i}\n-            } else if s[i] == '*' as u8 {\n-                let param = parse_parameter(s, i + 1, lim);\n-                let j = param.next;\n-                match param.param {\n-                  None => {count: CountIsNextParam, next: j},\n-                  Some(n) => {count: CountIsParam(n), next: j}\n-                }\n-            } else {\n-                let num = peek_num(s, i, lim);\n-                match num {\n-                  None => {count: CountImplied, next: i},\n-                  Some(num) => {\n-                    count: CountIs(num.num),\n-                    next: num.next\n-                  }\n-                }\n-            };\n     }\n-    pub fn parse_precision(s: &str, i: uint, lim: uint) ->\n-       {count: Count, next: uint} {\n-        return if i >= lim {\n-                {count: CountImplied, next: i}\n-            } else if s[i] == '.' as u8 {\n-                let count = parse_count(s, i + 1u, lim);\n \n+    pub fn parse_precision(s: &str, i: uint, lim: uint) -> Parsed<Count> {\n+        if i < lim && s[i] == '.' as u8 {\n+            let count = parse_count(s, i + 1, lim);\n \n-                // If there were no digits specified, i.e. the precision\n-                // was \".\", then the precision is 0\n-                match count.count {\n-                  CountImplied => {count: CountIs(0), next: count.next},\n-                  _ => count\n-                }\n-            } else { {count: CountImplied, next: i} };\n+            // If there were no digits specified, i.e. the precision\n+            // was \".\", then the precision is 0\n+            match count.val {\n+                CountImplied => Parsed::new(CountIs(0), count.next),\n+                _ => count\n+            }\n+        } else {\n+            Parsed::new(CountImplied, i)\n+        }\n     }\n+\n     pub fn parse_type(s: &str, i: uint, lim: uint, err: ErrorFn) ->\n-       {ty: Ty, next: uint} {\n+        Parsed<Ty> {\n         if i >= lim { err(~\"missing type in conversion\"); }\n-        let tstr = str::slice(s, i, i+1u);\n+\n         // FIXME (#2249): Do we really want two signed types here?\n         // How important is it to be printf compatible?\n-        let t =\n-            if tstr == ~\"b\" {\n-                TyBool\n-            } else if tstr == ~\"s\" {\n-                TyStr\n-            } else if tstr == ~\"c\" {\n-                TyChar\n-            } else if tstr == ~\"d\" || tstr == ~\"i\" {\n-                TyInt(Signed)\n-            } else if tstr == ~\"u\" {\n-                TyInt(Unsigned)\n-            } else if tstr == ~\"x\" {\n-                TyHex(CaseLower)\n-            } else if tstr == ~\"X\" {\n-                TyHex(CaseUpper)\n-            } else if tstr == ~\"t\" {\n-                TyBits\n-            } else if tstr == ~\"o\" {\n-                TyOctal\n-            } else if tstr == ~\"f\" {\n-                TyFloat\n-            } else if tstr == ~\"?\" {\n-                TyPoly\n-            } else { err(~\"unknown type in conversion: \" + tstr) };\n-        return {ty: t, next: i + 1u};\n+        let t = match s[i] {\n+            'b' as u8 => TyBool,\n+            's' as u8 => TyStr,\n+            'c' as u8 => TyChar,\n+            'd' as u8 | 'i' as u8 => TyInt(Signed),\n+            'u' as u8 => TyInt(Unsigned),\n+            'x' as u8 => TyHex(CaseLower),\n+            'X' as u8 => TyHex(CaseUpper),\n+            't' as u8 => TyBits,\n+            'o' as u8 => TyOctal,\n+            'f' as u8 => TyFloat,\n+            '?' as u8 => TyPoly,\n+            _ => err(~\"unknown type in conversion: \" + s.substr(i, 1))\n+        };\n+\n+        Parsed::new(t, i + 1)\n+    }\n+\n+    #[cfg(test)]\n+    fn die(s: &str) -> ! { fail s.to_owned() }\n+\n+    #[test]\n+    fn test_parse_count() {\n+        fn test(s: &str, count: Count, next: uint) -> bool {\n+            parse_count(s, 0, s.len()) == Parsed::new(count, next)\n+        }\n+\n+        assert test(\"\", CountImplied, 0);\n+        assert test(\"*\", CountIsNextParam, 1);\n+        assert test(\"*1\", CountIsNextParam, 1);\n+        assert test(\"*1$\", CountIsParam(1), 3);\n+        assert test(\"123\", CountIs(123), 3);\n+    }\n+\n+    #[test]\n+    fn test_parse_flags() {\n+        fn pack(fs: &[Flag]) -> uint {\n+            fs.foldl(0, |&p, &f| p | (1 << f as uint))\n+        }\n+\n+        fn test(s: &str, flags: &[Flag], next: uint) {\n+            let f = parse_flags(s, 0, s.len());\n+            assert pack(f.val) == pack(flags);\n+            assert f.next == next;\n+        }\n+\n+        test(\"\", [], 0);\n+        test(\"!#-+ 0\", [], 0);\n+        test(\"#-+\", [FlagAlternate, FlagLeftJustify, FlagSignAlways], 3);\n+        test(\" 0\", [FlagSpaceForSign, FlagLeftZeroPad], 2);\n+    }\n+\n+    #[test]\n+    fn test_parse_fmt_string() {\n+        assert parse_fmt_string(\"foo %s bar\", die) == ~[\n+            PieceString(~\"foo \"),\n+            PieceConv(Conv {param: None, flags: ~[], width: CountImplied,\n+                            precision: CountImplied, ty: TyStr}),\n+            PieceString(~\" bar\")];\n+\n+        assert parse_fmt_string(\"%s\", die) == ~[\n+            PieceConv(Conv {param: None, flags: ~[], width: CountImplied,\n+                            precision: CountImplied, ty: TyStr })];\n+\n+        assert parse_fmt_string(\"%%%%\", die) == ~[\n+            PieceString(~\"%\"), PieceString(~\"%\")];\n+    }\n+\n+    #[test]\n+    fn test_parse_parameter() {\n+        fn test(s: &str, param: Option<uint>, next: uint) -> bool {\n+            parse_parameter(s, 0, s.len()) == Parsed::new(param, next)\n+        }\n+\n+        assert test(\"\", None, 0);\n+        assert test(\"foo\", None, 0);\n+        assert test(\"123\", None, 0);\n+        assert test(\"123$\", Some(123), 4);\n+    }\n+\n+    #[test]\n+    fn test_parse_precision() {\n+        fn test(s: &str, count: Count, next: uint) -> bool {\n+            parse_precision(s, 0, s.len()) == Parsed::new(count, next)\n+        }\n+\n+        assert test(\"\", CountImplied, 0);\n+        assert test(\".\", CountIs(0), 1);\n+        assert test(\".*\", CountIsNextParam, 2);\n+        assert test(\".*1\", CountIsNextParam, 2);\n+        assert test(\".*1$\", CountIsParam(1), 4);\n+        assert test(\".123\", CountIs(123), 4);\n+    }\n+\n+    #[test]\n+    fn test_parse_type() {\n+        fn test(s: &str, ty: Ty) -> bool {\n+            parse_type(s, 0, s.len(), die) == Parsed::new(ty, 1)\n+        }\n+\n+        assert test(\"b\", TyBool);\n+        assert test(\"c\", TyChar);\n+        assert test(\"d\", TyInt(Signed));\n+        assert test(\"f\", TyFloat);\n+        assert test(\"i\", TyInt(Signed));\n+        assert test(\"o\", TyOctal);\n+        assert test(\"s\", TyStr);\n+        assert test(\"t\", TyBits);\n+        assert test(\"x\", TyHex(CaseLower));\n+        assert test(\"X\", TyHex(CaseUpper));\n+        assert test(\"?\", TyPoly);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_parse_type_missing() {\n+        parse_type(\"\", 0, 0, die);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_parse_type_unknown() {\n+        parse_type(\"!\", 0, 1, die);\n+    }\n+\n+    #[test]\n+    fn test_peek_num() {\n+        let s1 = \"\";\n+        assert peek_num(s1, 0, s1.len()).is_none();\n+\n+        let s2 = \"foo\";\n+        assert peek_num(s2, 0, s2.len()).is_none();\n+\n+        let s3 = \"123\";\n+        assert peek_num(s3, 0, s3.len()) == Some(Parsed::new(123, 3));\n+\n+        let s4 = \"123foo\";\n+        assert peek_num(s4, 0, s4.len()) == Some(Parsed::new(123, 3));\n     }\n }\n "}]}