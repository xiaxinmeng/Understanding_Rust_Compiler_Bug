{"sha": "695dee063bcd40f154bb27b7beafcb3d4dd775ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NWRlZTA2M2JjZDQwZjE1NGJiMjdiN2JlYWZjYjNkNGRkNzc1YWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-06-03T21:54:08Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-07-05T21:37:01Z"}, "message": "rustc: Implement the #[global_allocator] attribute\n\nThis PR is an implementation of [RFC 1974] which specifies a new method of\ndefining a global allocator for a program. This obsoletes the old\n`#![allocator]` attribute and also removes support for it.\n\n[RFC 1974]: https://github.com/rust-lang/rfcs/pull/197\n\nThe new `#[global_allocator]` attribute solves many issues encountered with the\n`#![allocator]` attribute such as composition and restrictions on the crate\ngraph itself. The compiler now has much more control over the ABI of the\nallocator and how it's implemented, allowing much more freedom in terms of how\nthis feature is implemented.\n\ncc #27389", "tree": {"sha": "8ac64f40091434e679b4221343dce7447c4f1236", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ac64f40091434e679b4221343dce7447c4f1236"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/695dee063bcd40f154bb27b7beafcb3d4dd775ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/695dee063bcd40f154bb27b7beafcb3d4dd775ac", "html_url": "https://github.com/rust-lang/rust/commit/695dee063bcd40f154bb27b7beafcb3d4dd775ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/695dee063bcd40f154bb27b7beafcb3d4dd775ac/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c225c4d1732537aff63dd97c2b7ac681fd3d188", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c225c4d1732537aff63dd97c2b7ac681fd3d188", "html_url": "https://github.com/rust-lang/rust/commit/4c225c4d1732537aff63dd97c2b7ac681fd3d188"}], "stats": {"total": 3997, "additions": 2828, "deletions": 1169}, "files": [{"sha": "cb3efea0d9f016e479491f0f4e7c31d86676e40e", "filename": "src/Cargo.lock", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -43,6 +43,8 @@ dependencies = [\n name = \"alloc_jemalloc\"\n version = \"0.0.0\"\n dependencies = [\n+ \"alloc 0.0.0\",\n+ \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -53,6 +55,7 @@ dependencies = [\n name = \"alloc_system\"\n version = \"0.0.0\"\n dependencies = [\n+ \"alloc 0.0.0\",\n  \"core 0.0.0\",\n  \"libc 0.0.0\",\n ]\n@@ -1127,10 +1130,21 @@ name = \"rustc-serialize\"\n version = \"0.3.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"rustc_allocator\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_asan\"\n version = \"0.0.0\"\n dependencies = [\n+ \"alloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1205,6 +1219,7 @@ dependencies = [\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro_plugin 0.0.0\",\n  \"rustc 0.0.0\",\n+ \"rustc_allocator 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_borrowck 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n@@ -1273,6 +1288,7 @@ dependencies = [\n name = \"rustc_lsan\"\n version = \"0.0.0\"\n dependencies = [\n+ \"alloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1317,6 +1333,7 @@ dependencies = [\n name = \"rustc_msan\"\n version = \"0.0.0\"\n dependencies = [\n+ \"alloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1399,6 +1416,7 @@ dependencies = [\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_allocator 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\","}, {"sha": "2023d758fe3ded19516c5b15a78ac1c196daebe3", "filename": "src/doc/unstable-book/src/language-features/allocator-internals.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fallocator-internals.md", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fallocator-internals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fallocator-internals.md?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,7 @@\n+# `allocator_internals`\n+\n+This feature does not have a tracking issue, it is an unstable implementation\n+detail of the `global_allocator` feature not intended for use outside the\n+compiler.\n+\n+------------------------"}, {"sha": "cfcf8e22d7088f3d676dbcc0de2efb09c3f447f8", "filename": "src/doc/unstable-book/src/language-features/allocator.md", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fallocator.md", "raw_url": "https://github.com/rust-lang/rust/raw/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fallocator.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fallocator.md?ref=4c225c4d1732537aff63dd97c2b7ac681fd3d188", "patch": "@@ -1,119 +0,0 @@\n-# `allocator`\n-\n-The tracking issue for this feature is: [#27389]\n-\n-[#27389]: https://github.com/rust-lang/rust/issues/27389\n-\n-------------------------\n-\n-Sometimes even the choices of jemalloc vs the system allocator aren't enough and\n-an entirely new custom allocator is required. In this you'll write your own\n-crate which implements the allocator API (e.g. the same as `alloc_system` or\n-`alloc_jemalloc`). As an example, let's take a look at a simplified and\n-annotated version of `alloc_system`\n-\n-```rust,no_run\n-# // Only needed for rustdoc --test down below.\n-# #![feature(lang_items)]\n-// The compiler needs to be instructed that this crate is an allocator in order\n-// to realize that when this is linked in another allocator like jemalloc should\n-// not be linked in.\n-#![feature(allocator)]\n-#![allocator]\n-\n-// Allocators are not allowed to depend on the standard library which in turn\n-// requires an allocator in order to avoid circular dependencies. This crate,\n-// however, can use all of libcore.\n-#![no_std]\n-\n-// Let's give a unique name to our custom allocator:\n-#![crate_name = \"my_allocator\"]\n-#![crate_type = \"rlib\"]\n-\n-// Our system allocator will use the in-tree libc crate for FFI bindings. Note\n-// that currently the external (crates.io) libc cannot be used because it links\n-// to the standard library (e.g. `#![no_std]` isn't stable yet), so that's why\n-// this specifically requires the in-tree version.\n-#![feature(libc)]\n-extern crate libc;\n-\n-// Listed below are the five allocation functions currently required by custom\n-// allocators. Their signatures and symbol names are not currently typechecked\n-// by the compiler, but this is a future extension and are required to match\n-// what is found below.\n-//\n-// Note that the standard `malloc` and `realloc` functions do not provide a way\n-// to communicate alignment so this implementation would need to be improved\n-// with respect to alignment in that aspect.\n-\n-#[no_mangle]\n-pub extern fn __rust_allocate(size: usize, _align: usize) -> *mut u8 {\n-    unsafe { libc::malloc(size as libc::size_t) as *mut u8 }\n-}\n-\n-#[no_mangle]\n-pub extern fn __rust_allocate_zeroed(size: usize, _align: usize) -> *mut u8 {\n-    unsafe { libc::calloc(size as libc::size_t, 1) as *mut u8 }\n-}\n-\n-#[no_mangle]\n-pub extern fn __rust_deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {\n-    unsafe { libc::free(ptr as *mut libc::c_void) }\n-}\n-\n-#[no_mangle]\n-pub extern fn __rust_reallocate(ptr: *mut u8, _old_size: usize, size: usize,\n-                                _align: usize) -> *mut u8 {\n-    unsafe {\n-        libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n-    }\n-}\n-\n-#[no_mangle]\n-pub extern fn __rust_reallocate_inplace(_ptr: *mut u8, old_size: usize,\n-                                        _size: usize, _align: usize) -> usize {\n-    old_size // This api is not supported by libc.\n-}\n-\n-#[no_mangle]\n-pub extern fn __rust_usable_size(size: usize, _align: usize) -> usize {\n-    size\n-}\n-\n-# // Only needed to get rustdoc to test this:\n-# fn main() {}\n-# #[lang = \"panic_fmt\"] fn panic_fmt() {}\n-# #[lang = \"eh_personality\"] fn eh_personality() {}\n-# #[lang = \"eh_unwind_resume\"] extern fn eh_unwind_resume() {}\n-# #[no_mangle] pub extern fn rust_eh_register_frames () {}\n-# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}\n-```\n-\n-After we compile this crate, it can be used as follows:\n-\n-```rust,ignore\n-extern crate my_allocator;\n-\n-fn main() {\n-    let a = Box::new(8); // Allocates memory via our custom allocator crate.\n-    println!(\"{}\", a);\n-}\n-```\n-\n-## Custom allocator limitations\n-\n-There are a few restrictions when working with custom allocators which may cause\n-compiler errors:\n-\n-* Any one artifact may only be linked to at most one allocator. Binaries,\n-  dylibs, and staticlibs must link to exactly one allocator, and if none have\n-  been explicitly chosen the compiler will choose one. On the other hand rlibs\n-  do not need to link to an allocator (but still can).\n-\n-* A consumer of an allocator is tagged with `#![needs_allocator]` (e.g. the\n-  `liballoc` crate currently) and an `#[allocator]` crate cannot transitively\n-  depend on a crate which needs an allocator (e.g. circular dependencies are not\n-  allowed). This basically means that allocators must restrict themselves to\n-  libcore currently.\n-\n-"}, {"sha": "2eae40aef349e5ae619060f59c3cab67386f0568", "filename": "src/doc/unstable-book/src/language-features/global-allocator.md", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,71 @@\n+# `global_allocator`\n+\n+The tracking issue for this feature is: [#27389]\n+\n+[#27389]: https://github.com/rust-lang/rust/issues/27389\n+\n+------------------------\n+\n+Rust programs may need to change the allocator that they're running with from\n+time to time. This use case is distinct from an allocator-per-collection (e.g. a\n+`Vec` with a custom allocator) and instead is more related to changing the\n+global default allocator, e.g. what `Vec<T>` uses by default.\n+\n+Currently Rust programs don't have a specified global allocator. The compiler\n+may link to a version of [jemalloc] on some platforms, but this is not\n+guaranteed. Libraries, however, like cdylibs and staticlibs are guaranteed\n+to use the \"system allocator\" which means something like `malloc` on Unixes and\n+`HeapAlloc` on Windows.\n+\n+[jemalloc]: https://github.com/jemalloc/jemalloc\n+\n+The `#[global_allocator]` attribute, however, allows configuring this choice.\n+You can use this to implement a completely custom global allocator to route all\n+default allocation requests to a custom object. Defined in [RFC 1974] usage\n+looks like:\n+\n+[RFC 1974]: https://github.com/rust-lang/rfcs/pull/1974\n+\n+```rust\n+#![feature(global_allocator, heap_api)]\n+\n+use std::heap::{Alloc, System, Layout, AllocErr};\n+\n+struct MyAllocator;\n+\n+unsafe impl<'a> Alloc for &'a MyAllocator {\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+        System.alloc(layout)\n+    }\n+\n+    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+        System.dealloc(ptr, layout)\n+    }\n+}\n+\n+#[global_allocator]\n+static GLOBAL: MyAllocator = MyAllocator;\n+\n+fn main() {\n+    // This `Vec` will allocate memory through `GLOBAL` above\n+    let mut v = Vec::new();\n+    v.push(1);\n+}\n+```\n+\n+And that's it! The `#[global_allocator]` attribute is applied to a `static`\n+which implements the `Alloc` trait in the `std::heap` module. Note, though,\n+that the implementation is defined for `&MyAllocator`, not just `MyAllocator`.\n+You may wish, however, to also provide `Alloc for MyAllocator` for other use\n+cases.\n+\n+A crate can only have one instance of `#[global_allocator]` and this instance\n+may be loaded through a dependency. For example `#[global_allocator]` above\n+could have been placed in one of the dependencies loaded through `extern crate`.\n+\n+Note that `Alloc` itself is an `unsafe` trait, with much documentation on the\n+trait itself about usage and for implementors. Extra care should be taken when\n+implementing a global allocator as well as the allocator may be called from many\n+portions of the standard library, such as the panicking routine. As a result it\n+is highly recommended to not panic during allocation and work in as many\n+situations with as few dependencies as possible as well."}, {"sha": "ca5388b47014781dc3b2c25fd1213a0c2339890b", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -13,7 +13,7 @@\n                       slightly, especially to possibly take into account the \\\n                       types being stored to make room for a future \\\n                       tracing garbage collector\",\n-            issue = \"27700\")]\n+            issue = \"32838\")]\n \n use core::cmp;\n use core::fmt;\n@@ -73,6 +73,7 @@ impl Layout {\n     /// * `size`, when rounded up to the nearest multiple of `align`,\n     ///    must not overflow (i.e. the rounded value must be less than\n     ///    `usize::MAX`).\n+    #[inline]\n     pub fn from_size_align(size: usize, align: usize) -> Option<Layout> {\n         if !align.is_power_of_two() {\n             return None;\n@@ -96,13 +97,28 @@ impl Layout {\n             return None;\n         }\n \n-        Some(Layout { size: size, align: align })\n+        unsafe {\n+            Some(Layout::from_size_align_unchecked(size, align))\n+        }\n+    }\n+\n+    /// Creates a layout, bypassing all checks.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe as it does not verify that `align` is a power of\n+    /// two nor that `size` aligned to `align` fits within the address space.\n+    #[inline]\n+    pub unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Layout {\n+        Layout { size: size, align: align }\n     }\n \n     /// The minimum size in bytes for a memory block of this layout.\n+    #[inline]\n     pub fn size(&self) -> usize { self.size }\n \n     /// The minimum byte alignment for a memory block of this layout.\n+    #[inline]\n     pub fn align(&self) -> usize { self.align }\n \n     /// Constructs a `Layout` suitable for holding a value of type `T`.\n@@ -135,6 +151,7 @@ impl Layout {\n     ///\n     /// Panics if the combination of `self.size` and the given `align`\n     /// violates the conditions listed in `from_size_align`.\n+    #[inline]\n     pub fn align_to(&self, align: usize) -> Self {\n         Layout::from_size_align(self.size, cmp::max(self.align, align)).unwrap()\n     }\n@@ -155,6 +172,7 @@ impl Layout {\n     /// to be less than or equal to the alignment of the starting\n     /// address for the whole allocated block of memory. One way to\n     /// satisfy this constraint is to ensure `align <= self.align`.\n+    #[inline]\n     pub fn padding_needed_for(&self, align: usize) -> usize {\n         let len = self.size();\n \n@@ -556,6 +574,7 @@ pub unsafe trait Alloc {\n     /// However, for clients that do not wish to track the capacity\n     /// returned by `alloc_excess` locally, this method is likely to\n     /// produce useful results.\n+    #[inline]\n     fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n         (layout.size(), layout.size())\n     }"}, {"sha": "d9edf50b9c8ec28b18a4afd04abf40b7934d391a", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -23,7 +23,6 @@ use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::borrow;\n use core::fmt;\n use core::cmp::Ordering;\n-use core::mem::{align_of_val, size_of_val};\n use core::intrinsics::abort;\n use core::mem;\n use core::mem::uninitialized;\n@@ -34,7 +33,8 @@ use core::marker::Unsize;\n use core::hash::{Hash, Hasher};\n use core::{isize, usize};\n use core::convert::From;\n-use heap::deallocate;\n+\n+use heap::{Heap, Alloc, Layout};\n \n /// A soft limit on the amount of references that may be made to an `Arc`.\n ///\n@@ -503,7 +503,7 @@ impl<T: ?Sized> Arc<T> {\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n-            deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n+            Heap.dealloc(ptr as *mut u8, Layout::for_value(&*ptr))\n         }\n     }\n \n@@ -1007,7 +1007,9 @@ impl<T: ?Sized> Drop for Weak<T> {\n         // ref, which can only happen after the lock is released.\n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n-            unsafe { deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr)) }\n+            unsafe {\n+                Heap.dealloc(ptr as *mut u8, Layout::for_value(&*ptr))\n+            }\n         }\n     }\n }"}, {"sha": "76cf10f0d55ea9ecded8f6184986edd40b05fb95", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -55,7 +55,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use heap;\n+use heap::{Heap, Layout, Alloc};\n use raw_vec::RawVec;\n \n use core::any::Any;\n@@ -135,8 +135,7 @@ pub struct Box<T: ?Sized>(Unique<T>);\n #[allow(missing_debug_implementations)]\n pub struct IntermediateBox<T: ?Sized> {\n     ptr: *mut u8,\n-    size: usize,\n-    align: usize,\n+    layout: Layout,\n     marker: marker::PhantomData<*mut T>,\n }\n \n@@ -156,23 +155,21 @@ unsafe fn finalize<T>(b: IntermediateBox<T>) -> Box<T> {\n }\n \n fn make_place<T>() -> IntermediateBox<T> {\n-    let size = mem::size_of::<T>();\n-    let align = mem::align_of::<T>();\n+    let layout = Layout::new::<T>();\n \n-    let p = if size == 0 {\n+    let p = if layout.size() == 0 {\n         mem::align_of::<T>() as *mut u8\n     } else {\n-        let p = unsafe { heap::allocate(size, align) };\n-        if p.is_null() {\n-            panic!(\"Box make_place allocation failure.\");\n+        unsafe {\n+            Heap.alloc(layout.clone()).unwrap_or_else(|err| {\n+                Heap.oom(err)\n+            })\n         }\n-        p\n     };\n \n     IntermediateBox {\n         ptr: p,\n-        size: size,\n-        align: align,\n+        layout: layout,\n         marker: marker::PhantomData,\n     }\n }\n@@ -221,8 +218,10 @@ impl<T> Placer<T> for ExchangeHeapSingleton {\n            issue = \"27779\")]\n impl<T: ?Sized> Drop for IntermediateBox<T> {\n     fn drop(&mut self) {\n-        if self.size > 0 {\n-            unsafe { heap::deallocate(self.ptr, self.size, self.align) }\n+        if self.layout.size() > 0 {\n+            unsafe {\n+                Heap.dealloc(self.ptr, self.layout.clone())\n+            }\n         }\n     }\n }"}, {"sha": "0eaff6f2192c8a22281b7db3da8498e8963af22c", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -48,7 +48,7 @@ use core::ptr::{self, Unique};\n use core::slice;\n \n use boxed::Box;\n-use heap;\n+use heap::{Heap, Alloc, Layout};\n \n const B: usize = 6;\n pub const MIN_LEN: usize = B - 1;\n@@ -254,11 +254,7 @@ impl<K, V> Root<K, V> {\n         self.as_mut().as_leaf_mut().parent = ptr::null();\n \n         unsafe {\n-            heap::deallocate(\n-                top,\n-                mem::size_of::<InternalNode<K, V>>(),\n-                mem::align_of::<InternalNode<K, V>>()\n-            );\n+            Heap.dealloc(top, Layout::new::<InternalNode<K, V>>());\n         }\n     }\n }\n@@ -445,7 +441,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n     > {\n         let ptr = self.as_leaf() as *const LeafNode<K, V> as *const u8 as *mut u8;\n         let ret = self.ascend().ok();\n-        heap::deallocate(ptr, mem::size_of::<LeafNode<K, V>>(), mem::align_of::<LeafNode<K, V>>());\n+        Heap.dealloc(ptr, Layout::new::<LeafNode<K, V>>());\n         ret\n     }\n }\n@@ -466,11 +462,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n     > {\n         let ptr = self.as_internal() as *const InternalNode<K, V> as *const u8 as *mut u8;\n         let ret = self.ascend().ok();\n-        heap::deallocate(\n-            ptr,\n-            mem::size_of::<InternalNode<K, V>>(),\n-            mem::align_of::<InternalNode<K, V>>()\n-        );\n+        Heap.dealloc(ptr, Layout::new::<InternalNode<K, V>>());\n         ret\n     }\n }\n@@ -1252,16 +1244,14 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                     ).correct_parent_link();\n                 }\n \n-                heap::deallocate(\n+                Heap.dealloc(\n                     right_node.node.get() as *mut u8,\n-                    mem::size_of::<InternalNode<K, V>>(),\n-                    mem::align_of::<InternalNode<K, V>>()\n+                    Layout::new::<InternalNode<K, V>>(),\n                 );\n             } else {\n-                heap::deallocate(\n+                Heap.dealloc(\n                     right_node.node.get() as *mut u8,\n-                    mem::size_of::<LeafNode<K, V>>(),\n-                    mem::align_of::<LeafNode<K, V>>()\n+                    Layout::new::<LeafNode<K, V>>(),\n                 );\n             }\n "}, {"sha": "1d959ac5bf6dcaf06a2a4dea32bb69ee38b1067e", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 171, "deletions": 182, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -8,207 +8,212 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"heap_api\",\n+#![unstable(feature = \"allocator_api\",\n             reason = \"the precise API and guarantees it provides may be tweaked \\\n                       slightly, especially to possibly take into account the \\\n                       types being stored to make room for a future \\\n                       tracing garbage collector\",\n-            issue = \"27700\")]\n+            issue = \"32838\")]\n \n-use allocator::{Alloc, AllocErr, CannotReallocInPlace, Layout};\n-use core::{isize, usize, cmp, ptr};\n use core::intrinsics::{min_align_of_val, size_of_val};\n+use core::mem::{self, ManuallyDrop};\n+use core::usize;\n \n-#[allow(improper_ctypes)]\n-extern \"C\" {\n-    #[allocator]\n-    fn __rust_allocate(size: usize, align: usize) -> *mut u8;\n-    fn __rust_allocate_zeroed(size: usize, align: usize) -> *mut u8;\n-    fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize);\n-    fn __rust_reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8;\n-    fn __rust_reallocate_inplace(ptr: *mut u8,\n-                                 old_size: usize,\n-                                 size: usize,\n-                                 align: usize)\n-                                 -> usize;\n-    fn __rust_usable_size(size: usize, align: usize) -> usize;\n+pub use allocator::*;\n+#[doc(hidden)]\n+pub mod __core {\n+    pub use core::*;\n }\n \n-#[inline(always)]\n-fn check_size_and_alignment(size: usize, align: usize) {\n-    debug_assert!(size != 0);\n-    debug_assert!(size <= isize::MAX as usize,\n-                  \"Tried to allocate too much: {} bytes\",\n-                  size);\n-    debug_assert!(usize::is_power_of_two(align),\n-                  \"Invalid alignment of allocation: {}\",\n-                  align);\n+extern \"Rust\" {\n+    #[allocator]\n+    fn __rust_alloc(size: usize, align: usize, err: *mut u8) -> *mut u8;\n+    fn __rust_oom(err: *const u8) -> !;\n+    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n+    fn __rust_usable_size(layout: *const u8,\n+                          min: *mut usize,\n+                          max: *mut usize);\n+    fn __rust_realloc(ptr: *mut u8,\n+                      old_size: usize,\n+                      old_align: usize,\n+                      new_size: usize,\n+                      new_align: usize,\n+                      err: *mut u8) -> *mut u8;\n+    fn __rust_alloc_zeroed(size: usize, align: usize, err: *mut u8) -> *mut u8;\n+    fn __rust_alloc_excess(size: usize,\n+                           align: usize,\n+                           excess: *mut usize,\n+                           err: *mut u8) -> *mut u8;\n+    fn __rust_realloc_excess(ptr: *mut u8,\n+                             old_size: usize,\n+                             old_align: usize,\n+                             new_size: usize,\n+                             new_align: usize,\n+                             excess: *mut usize,\n+                             err: *mut u8) -> *mut u8;\n+    fn __rust_grow_in_place(ptr: *mut u8,\n+                            old_size: usize,\n+                            old_align: usize,\n+                            new_size: usize,\n+                            new_align: usize) -> u8;\n+    fn __rust_shrink_in_place(ptr: *mut u8,\n+                              old_size: usize,\n+                              old_align: usize,\n+                              new_size: usize,\n+                              new_align: usize) -> u8;\n }\n \n #[derive(Copy, Clone, Default, Debug)]\n-pub struct HeapAlloc;\n+pub struct Heap;\n \n-unsafe impl Alloc for HeapAlloc {\n+unsafe impl Alloc for Heap {\n+    #[inline]\n     unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-        let addr = allocate(layout.size(), layout.align());\n-        if addr.is_null() {\n-            Err(AllocErr::Exhausted { request: layout })\n+        let mut err = ManuallyDrop::new(mem::uninitialized::<AllocErr>());\n+        let ptr = __rust_alloc(layout.size(),\n+                               layout.align(),\n+                               &mut *err as *mut AllocErr as *mut u8);\n+        if ptr.is_null() {\n+            Err(ManuallyDrop::into_inner(err))\n         } else {\n-            Ok(addr)\n+            Ok(ptr)\n         }\n     }\n \n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-        let addr = allocate_zeroed(layout.size(), layout.align());\n-        if addr.is_null() {\n-            Err(AllocErr::Exhausted { request: layout })\n-        } else {\n-            Ok(addr)\n+    #[inline]\n+    fn oom(&mut self, err: AllocErr) -> ! {\n+        unsafe {\n+            __rust_oom(&err as *const AllocErr as *const u8)\n         }\n     }\n \n+    #[inline]\n     unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-        deallocate(ptr, layout.size(), layout.align());\n+        __rust_dealloc(ptr, layout.size(), layout.align())\n     }\n \n+    #[inline]\n     fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n-        (layout.size(), usable_size(layout.size(), layout.align()))\n+        let mut min = 0;\n+        let mut max = 0;\n+        unsafe {\n+            __rust_usable_size(layout as *const Layout as *const u8,\n+                               &mut min,\n+                               &mut max);\n+        }\n+        (min, max)\n     }\n \n+    #[inline]\n     unsafe fn realloc(&mut self,\n                       ptr: *mut u8,\n                       layout: Layout,\n                       new_layout: Layout)\n                       -> Result<*mut u8, AllocErr>\n     {\n-        let old_size = layout.size();\n-        let new_size = new_layout.size();\n-        if layout.align() == new_layout.align() {\n-            let new_ptr = reallocate(ptr, old_size, new_size, layout.align());\n-            if new_ptr.is_null() {\n-                // We assume `reallocate` already tried alloc + copy +\n-                // dealloc fallback; thus pointless to repeat effort\n-                Err(AllocErr::Exhausted { request: new_layout })\n-            } else {\n-                Ok(new_ptr)\n-            }\n+        let mut err = ManuallyDrop::new(mem::uninitialized::<AllocErr>());\n+        let ptr = __rust_realloc(ptr,\n+                                 layout.size(),\n+                                 layout.align(),\n+                                 new_layout.size(),\n+                                 new_layout.align(),\n+                                 &mut *err as *mut AllocErr as *mut u8);\n+        if ptr.is_null() {\n+            Err(ManuallyDrop::into_inner(err))\n         } else {\n-            // if alignments don't match, fall back on alloc + copy + dealloc\n-            let result = self.alloc(new_layout);\n-            if let Ok(new_ptr) = result {\n-                ptr::copy_nonoverlapping(ptr as *const u8, new_ptr, cmp::min(old_size, new_size));\n-                self.dealloc(ptr, layout);\n-            }\n-            result\n+            mem::forget(err);\n+            Ok(ptr)\n         }\n     }\n \n+    #[inline]\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+        let mut err = ManuallyDrop::new(mem::uninitialized::<AllocErr>());\n+        let ptr = __rust_alloc_zeroed(layout.size(),\n+                                      layout.align(),\n+                                      &mut *err as *mut AllocErr as *mut u8);\n+        if ptr.is_null() {\n+            Err(ManuallyDrop::into_inner(err))\n+        } else {\n+            Ok(ptr)\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n+        let mut err = ManuallyDrop::new(mem::uninitialized::<AllocErr>());\n+        let mut size = 0;\n+        let ptr = __rust_alloc_excess(layout.size(),\n+                                      layout.align(),\n+                                      &mut size,\n+                                      &mut *err as *mut AllocErr as *mut u8);\n+        if ptr.is_null() {\n+            Err(ManuallyDrop::into_inner(err))\n+        } else {\n+            Ok(Excess(ptr, size))\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc_excess(&mut self,\n+                             ptr: *mut u8,\n+                             layout: Layout,\n+                             new_layout: Layout) -> Result<Excess, AllocErr> {\n+        let mut err = ManuallyDrop::new(mem::uninitialized::<AllocErr>());\n+        let mut size = 0;\n+        let ptr = __rust_realloc_excess(ptr,\n+                                        layout.size(),\n+                                        layout.align(),\n+                                        new_layout.size(),\n+                                        new_layout.align(),\n+                                        &mut size,\n+                                        &mut *err as *mut AllocErr as *mut u8);\n+        if ptr.is_null() {\n+            Err(ManuallyDrop::into_inner(err))\n+        } else {\n+            Ok(Excess(ptr, size))\n+        }\n+    }\n+\n+    #[inline]\n     unsafe fn grow_in_place(&mut self,\n                             ptr: *mut u8,\n                             layout: Layout,\n                             new_layout: Layout)\n                             -> Result<(), CannotReallocInPlace>\n     {\n-        // grow_in_place spec requires this, and the spec for reallocate_inplace\n-        // makes it hard to detect failure if it does not hold.\n         debug_assert!(new_layout.size() >= layout.size());\n-\n-        if layout.align() != new_layout.align() { // reallocate_inplace requires this.\n-            return Err(CannotReallocInPlace);\n+        debug_assert!(new_layout.align() == layout.align());\n+        let ret = __rust_grow_in_place(ptr,\n+                                       layout.size(),\n+                                       layout.align(),\n+                                       new_layout.size(),\n+                                       new_layout.align());\n+        if ret != 0 {\n+            Ok(())\n+        } else {\n+            Err(CannotReallocInPlace)\n         }\n-        let usable = reallocate_inplace(ptr, layout.size(), new_layout.size(), layout.align());\n-        if usable >= new_layout.size() { Ok(()) } else { Err(CannotReallocInPlace) }\n     }\n-}\n-\n-// FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias`\n \n-/// Return a pointer to `size` bytes of memory aligned to `align`.\n-///\n-/// On failure, return a null pointer.\n-///\n-/// Behavior is undefined if the requested size is 0 or the alignment is not a\n-/// power of 2. The alignment must be no larger than the largest supported page\n-/// size on the platform.\n-#[inline]\n-pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n-    check_size_and_alignment(size, align);\n-    __rust_allocate(size, align)\n-}\n-\n-/// Return a pointer to `size` bytes of memory aligned to `align` and\n-/// initialized to zeroes.\n-///\n-/// On failure, return a null pointer.\n-///\n-/// Behavior is undefined if the requested size is 0 or the alignment is not a\n-/// power of 2. The alignment must be no larger than the largest supported page\n-/// size on the platform.\n-#[inline]\n-pub unsafe fn allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n-    check_size_and_alignment(size, align);\n-    __rust_allocate_zeroed(size, align)\n-}\n-\n-/// Resize the allocation referenced by `ptr` to `size` bytes.\n-///\n-/// On failure, return a null pointer and leave the original allocation intact.\n-///\n-/// If the allocation was relocated, the memory at the passed-in pointer is\n-/// undefined after the call.\n-///\n-/// Behavior is undefined if the requested size is 0 or the alignment is not a\n-/// power of 2. The alignment must be no larger than the largest supported page\n-/// size on the platform.\n-///\n-/// The `old_size` and `align` parameters are the parameters that were used to\n-/// create the allocation referenced by `ptr`. The `old_size` parameter may be\n-/// any value in range_inclusive(requested_size, usable_size).\n-#[inline]\n-pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n-    check_size_and_alignment(size, align);\n-    __rust_reallocate(ptr, old_size, size, align)\n-}\n-\n-/// Resize the allocation referenced by `ptr` to `size` bytes.\n-///\n-/// If the operation succeeds, it returns `usable_size(size, align)` and if it\n-/// fails (or is a no-op) it returns `usable_size(old_size, align)`.\n-///\n-/// Behavior is undefined if the requested size is 0 or the alignment is not a\n-/// power of 2. The alignment must be no larger than the largest supported page\n-/// size on the platform.\n-///\n-/// The `old_size` and `align` parameters are the parameters that were used to\n-/// create the allocation referenced by `ptr`. The `old_size` parameter may be\n-/// any value in range_inclusive(requested_size, usable_size).\n-#[inline]\n-pub unsafe fn reallocate_inplace(ptr: *mut u8,\n-                                 old_size: usize,\n-                                 size: usize,\n-                                 align: usize)\n-                                 -> usize {\n-    check_size_and_alignment(size, align);\n-    __rust_reallocate_inplace(ptr, old_size, size, align)\n-}\n-\n-/// Deallocates the memory referenced by `ptr`.\n-///\n-/// The `ptr` parameter must not be null.\n-///\n-/// The `old_size` and `align` parameters are the parameters that were used to\n-/// create the allocation referenced by `ptr`. The `old_size` parameter may be\n-/// any value in range_inclusive(requested_size, usable_size).\n-#[inline]\n-pub unsafe fn deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n-    __rust_deallocate(ptr, old_size, align)\n-}\n-\n-/// Returns the usable size of an allocation created with the specified the\n-/// `size` and `align`.\n-#[inline]\n-pub fn usable_size(size: usize, align: usize) -> usize {\n-    unsafe { __rust_usable_size(size, align) }\n+    #[inline]\n+    unsafe fn shrink_in_place(&mut self,\n+                              ptr: *mut u8,\n+                              layout: Layout,\n+                              new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+        debug_assert!(new_layout.size() <= layout.size());\n+        debug_assert!(new_layout.align() == layout.align());\n+        let ret = __rust_shrink_in_place(ptr,\n+                                         layout.size(),\n+                                         layout.align(),\n+                                         new_layout.size(),\n+                                         new_layout.align());\n+        if ret != 0 {\n+            Ok(())\n+        } else {\n+            Err(CannotReallocInPlace)\n+        }\n+    }\n }\n \n /// An arbitrary non-null address to represent zero-size allocations.\n@@ -228,11 +233,10 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     if size == 0 {\n         align as *mut u8\n     } else {\n-        let ptr = allocate(size, align);\n-        if ptr.is_null() {\n-            ::oom()\n-        }\n-        ptr\n+        let layout = Layout::from_size_align_unchecked(size, align);\n+        Heap.alloc(layout).unwrap_or_else(|err| {\n+            Heap.oom(err)\n+        })\n     }\n }\n \n@@ -243,7 +247,8 @@ pub(crate) unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n     let align = min_align_of_val(&*ptr);\n     // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n     if size != 0 {\n-        deallocate(ptr as *mut u8, size, align);\n+        let layout = Layout::from_size_align_unchecked(size, align);\n+        Heap.dealloc(ptr as *mut u8, layout);\n     }\n }\n \n@@ -252,38 +257,22 @@ mod tests {\n     extern crate test;\n     use self::test::Bencher;\n     use boxed::Box;\n-    use heap;\n+    use heap::{Heap, Alloc, Layout};\n \n     #[test]\n     fn allocate_zeroed() {\n         unsafe {\n-            let size = 1024;\n-            let ptr = heap::allocate_zeroed(size, 1);\n-            if ptr.is_null() {\n-                ::oom()\n-            }\n+            let layout = Layout::from_size_align(1024, 1).unwrap();\n+            let ptr = Heap.alloc_zeroed(layout.clone())\n+                .unwrap_or_else(|e| Heap.oom(e));\n \n-            let end = ptr.offset(size as isize);\n+            let end = ptr.offset(layout.size() as isize);\n             let mut i = ptr;\n             while i < end {\n                 assert_eq!(*i, 0);\n                 i = i.offset(1);\n             }\n-            heap::deallocate(ptr, size, 1);\n-        }\n-    }\n-\n-    #[test]\n-    fn basic_reallocate_inplace_noop() {\n-        unsafe {\n-            let size = 4000;\n-            let ptr = heap::allocate(size, 8);\n-            if ptr.is_null() {\n-                ::oom()\n-            }\n-            let ret = heap::reallocate_inplace(ptr, size, size, 8);\n-            heap::deallocate(ptr, size, 8);\n-            assert_eq!(ret, heap::usable_size(size, 8));\n+            Heap.dealloc(ptr, layout);\n         }\n     }\n "}, {"sha": "b419aeb5ab5931e56eac4c565dfaeb670d9426b3", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -85,7 +85,7 @@\n #![cfg_attr(not(test), feature(slice_rotate))]\n #![cfg_attr(not(test), feature(str_checked_slicing))]\n #![cfg_attr(test, feature(rand, test))]\n-#![feature(allocator)]\n+#![cfg_attr(stage0, feature(allocator))]\n #![feature(allow_internal_unstable)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n@@ -124,6 +124,7 @@\n #![feature(unicode)]\n #![feature(unique)]\n #![feature(unsize)]\n+#![cfg_attr(not(stage0), feature(allocator_internals))]\n \n #![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol))]\n #![cfg_attr(test, feature(test, box_heap))]\n@@ -168,7 +169,6 @@ mod boxed_test;\n pub mod arc;\n pub mod rc;\n pub mod raw_vec;\n-pub mod oom;\n \n // collections modules\n pub mod binary_heap;\n@@ -260,8 +260,6 @@ trait SpecExtend<I: IntoIterator> {\n     fn spec_extend(&mut self, iter: I);\n }\n \n-pub use oom::oom;\n-\n #[doc(no_inline)]\n pub use binary_heap::BinaryHeap;\n #[doc(no_inline)]"}, {"sha": "3640156fec2ae2fc3bcc07a5bf0fb17ad13af169", "filename": "src/liballoc/oom.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Fliballoc%2Foom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Fliballoc%2Foom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Foom.rs?ref=4c225c4d1732537aff63dd97c2b7ac681fd3d188", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[cfg(target_has_atomic = \"ptr\")]\n-pub use self::imp::set_oom_handler;\n-use core::intrinsics;\n-\n-fn default_oom_handler() -> ! {\n-    // The default handler can't do much more since we can't assume the presence\n-    // of libc or any way of printing an error message.\n-    unsafe { intrinsics::abort() }\n-}\n-\n-/// Common out-of-memory routine\n-#[cold]\n-#[inline(never)]\n-#[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n-           issue = \"27700\")]\n-pub fn oom() -> ! {\n-    self::imp::oom()\n-}\n-\n-#[cfg(target_has_atomic = \"ptr\")]\n-mod imp {\n-    use core::mem;\n-    use core::sync::atomic::{AtomicPtr, Ordering};\n-\n-    static OOM_HANDLER: AtomicPtr<()> = AtomicPtr::new(super::default_oom_handler as *mut ());\n-\n-    #[inline(always)]\n-    pub fn oom() -> ! {\n-        let value = OOM_HANDLER.load(Ordering::SeqCst);\n-        let handler: fn() -> ! = unsafe { mem::transmute(value) };\n-        handler();\n-    }\n-\n-    /// Set a custom handler for out-of-memory conditions\n-    ///\n-    /// To avoid recursive OOM failures, it is critical that the OOM handler does\n-    /// not allocate any memory itself.\n-    #[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n-               issue = \"27700\")]\n-    pub fn set_oom_handler(handler: fn() -> !) {\n-        OOM_HANDLER.store(handler as *mut (), Ordering::SeqCst);\n-    }\n-}\n-\n-#[cfg(not(target_has_atomic = \"ptr\"))]\n-mod imp {\n-    #[inline(always)]\n-    pub fn oom() -> ! {\n-        super::default_oom_handler()\n-    }\n-}"}, {"sha": "d1aab4c70be4a9aa59a9142921febcb50c851adc", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -12,7 +12,7 @@ use allocator::{Alloc, Layout};\n use core::ptr::{self, Unique};\n use core::mem;\n use core::slice;\n-use heap::{HeapAlloc};\n+use heap::Heap;\n use super::boxed::Box;\n use core::ops::Drop;\n use core::cmp;\n@@ -45,7 +45,7 @@ use core::cmp;\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n #[allow(missing_debug_implementations)]\n-pub struct RawVec<T, A: Alloc = HeapAlloc> {\n+pub struct RawVec<T, A: Alloc = Heap> {\n     ptr: Unique<T>,\n     cap: usize,\n     a: A,\n@@ -112,14 +112,14 @@ impl<T, A: Alloc> RawVec<T, A> {\n     }\n }\n \n-impl<T> RawVec<T, HeapAlloc> {\n+impl<T> RawVec<T, Heap> {\n     /// Creates the biggest possible RawVec (on the system heap)\n     /// without allocating. If T has positive size, then this makes a\n     /// RawVec with capacity 0. If T has 0 size, then it it makes a\n     /// RawVec with capacity `usize::MAX`. Useful for implementing\n     /// delayed allocation.\n     pub fn new() -> Self {\n-        Self::new_in(HeapAlloc)\n+        Self::new_in(Heap)\n     }\n \n     /// Creates a RawVec (on the system heap) with exactly the\n@@ -139,13 +139,13 @@ impl<T> RawVec<T, HeapAlloc> {\n     /// Aborts on OOM\n     #[inline]\n     pub fn with_capacity(cap: usize) -> Self {\n-        RawVec::allocate_in(cap, false, HeapAlloc)\n+        RawVec::allocate_in(cap, false, Heap)\n     }\n \n     /// Like `with_capacity` but guarantees the buffer is zeroed.\n     #[inline]\n     pub fn with_capacity_zeroed(cap: usize) -> Self {\n-        RawVec::allocate_in(cap, true, HeapAlloc)\n+        RawVec::allocate_in(cap, true, Heap)\n     }\n }\n \n@@ -166,7 +166,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     }\n }\n \n-impl<T> RawVec<T, HeapAlloc> {\n+impl<T> RawVec<T, Heap> {\n     /// Reconstitutes a RawVec from a pointer, capacity.\n     ///\n     /// # Undefined Behavior\n@@ -178,7 +178,7 @@ impl<T> RawVec<T, HeapAlloc> {\n         RawVec {\n             ptr: Unique::new(ptr),\n             cap: cap,\n-            a: HeapAlloc,\n+            a: Heap,\n         }\n     }\n \n@@ -609,7 +609,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     }\n }\n \n-impl<T> RawVec<T, HeapAlloc> {\n+impl<T> RawVec<T, Heap> {\n     /// Converts the entire buffer into `Box<[T]>`.\n     ///\n     /// While it is not *strictly* Undefined Behavior to call\n@@ -693,13 +693,13 @@ mod tests {\n                 if size > self.fuel {\n                     return Err(AllocErr::Unsupported { details: \"fuel exhausted\" });\n                 }\n-                match HeapAlloc.alloc(layout) {\n+                match Heap.alloc(layout) {\n                     ok @ Ok(_) => { self.fuel -= size; ok }\n                     err @ Err(_) => err,\n                 }\n             }\n             unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-                HeapAlloc.dealloc(ptr, layout)\n+                Heap.dealloc(ptr, layout)\n             }\n         }\n "}, {"sha": "306136b21c84b2cb6013be9e4ccbe044c4923fb3", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -252,13 +252,13 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::marker;\n use core::marker::Unsize;\n-use core::mem::{self, align_of_val, forget, size_of, size_of_val, uninitialized};\n+use core::mem::{self, forget, size_of, size_of_val, uninitialized};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, Shared};\n use core::convert::From;\n \n-use heap::{allocate, deallocate, box_free};\n+use heap::{Heap, Alloc, Layout, box_free};\n use raw_vec::RawVec;\n \n struct RcBox<T: ?Sized> {\n@@ -461,7 +461,8 @@ impl<T> Rc<[T]> {\n             // FIXME(custom-DST): creating this invalid &[T] is dubiously defined,\n             // we should have a better way of getting the size/align\n             // of a DST from its unsized part.\n-            let ptr = allocate(size_of_val(&*ptr), align_of_val(&*ptr));\n+            let ptr = Heap.alloc(Layout::for_value(&*ptr))\n+                .unwrap_or_else(|e| Heap.oom(e));\n             let ptr: *mut RcBox<[T]> = mem::transmute([ptr as usize, value.len()]);\n \n             // Initialize the new RcBox.\n@@ -719,7 +720,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n                 self.dec_weak();\n \n                 if self.weak() == 0 {\n-                    deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n+                    Heap.dealloc(ptr as *mut u8, Layout::for_value(&*ptr));\n                 }\n             }\n         }\n@@ -1097,7 +1098,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n             // the weak count starts at 1, and will only go to zero if all\n             // the strong pointers have disappeared.\n             if self.weak() == 0 {\n-                deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n+                Heap.dealloc(ptr as *mut u8, Layout::for_value(&*ptr));\n             }\n         }\n     }"}, {"sha": "99c0bf2aaab4847865d398b07bda98e70bf77759", "filename": "src/liballoc_jemalloc/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc_jemalloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc_jemalloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2FCargo.toml?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -15,6 +15,10 @@ doc = false\n core = { path = \"../libcore\" }\n libc = { path = \"../rustc/libc_shim\" }\n \n+[target.'cfg(not(stage0))'.dependencies]\n+alloc = { path = \"../liballoc\" }\n+alloc_system = { path = \"../liballoc_system\" }\n+\n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n gcc = \"0.3.50\""}, {"sha": "72686ddcc09efda99db2c166730b71fe1eac759f", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 135, "deletions": 66, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -11,23 +11,36 @@\n #![crate_name = \"alloc_jemalloc\"]\n #![crate_type = \"rlib\"]\n #![no_std]\n-#![allocator]\n #![unstable(feature = \"alloc_jemalloc\",\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\",\n             issue = \"27783\")]\n #![deny(warnings)]\n-#![feature(allocator)]\n #![feature(libc)]\n #![feature(staged_api)]\n-\n+#![feature(linkage)]\n+#![cfg_attr(stage0, allocator)]\n+#![cfg_attr(stage0, feature(allocator))]\n+#![cfg_attr(not(stage0), feature(global_allocator))]\n+#![cfg_attr(all(not(stage0), not(dummy_jemalloc)), feature(allocator_api))]\n+#![cfg_attr(not(stage0), feature(alloc))]\n+#![cfg_attr(not(stage0), feature(alloc_system))]\n+#![cfg_attr(dummy_jemalloc, allow(dead_code))]\n+\n+#[cfg(not(stage0))]\n+extern crate alloc;\n+#[cfg(not(stage0))]\n+extern crate alloc_system;\n extern crate libc;\n \n-pub use imp::*;\n+#[cfg(all(not(stage0), not(dummy_jemalloc)))]\n+pub use contents::*;\n+#[cfg(all(not(stage0), not(dummy_jemalloc)))]\n+mod contents {\n+    use core::ptr;\n \n-// See comments in build.rs for why we sometimes build a crate that does nothing\n-#[cfg(not(dummy_jemalloc))]\n-mod imp {\n+    use alloc::heap::{Alloc, AllocErr, Layout};\n+    use alloc_system::System;\n     use libc::{c_int, c_void, size_t};\n \n     // Note that the symbols here are prefixed by default on macOS and Windows (we\n@@ -91,96 +104,152 @@ mod imp {\n         }\n     }\n \n-    #[no_mangle]\n-    pub extern \"C\" fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n-        let flags = align_to_flags(align);\n-        unsafe { mallocx(size as size_t, flags) as *mut u8 }\n-    }\n+    // for symbol names src/librustc/middle/allocator.rs\n+    // for signatures src/librustc_allocator/lib.rs\n \n-    #[no_mangle]\n-    pub extern \"C\" fn __rust_allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n-        if align <= MIN_ALIGN {\n-            unsafe { calloc(size as size_t, 1) as *mut u8 }\n-        } else {\n-            let flags = align_to_flags(align) | MALLOCX_ZERO;\n-            unsafe { mallocx(size as size_t, flags) as *mut u8 }\n-        }\n-    }\n+    // linkage directives are provided as part of the current compiler allocator\n+    // ABI\n \n     #[no_mangle]\n-    pub extern \"C\" fn __rust_reallocate(ptr: *mut u8,\n-                                        _old_size: usize,\n-                                        size: usize,\n-                                        align: usize)\n-                                        -> *mut u8 {\n+    #[linkage = \"external\"]\n+    pub unsafe extern fn __rde_alloc(size: usize,\n+                                     align: usize,\n+                                     err: *mut u8) -> *mut u8 {\n         let flags = align_to_flags(align);\n-        unsafe { rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8 }\n+        let ptr = mallocx(size as size_t, flags) as *mut u8;\n+        if ptr.is_null() {\n+            let layout = Layout::from_size_align_unchecked(size, align);\n+            ptr::write(err as *mut AllocErr,\n+                       AllocErr::Exhausted { request: layout });\n+        }\n+        ptr\n     }\n \n     #[no_mangle]\n-    pub extern \"C\" fn __rust_reallocate_inplace(ptr: *mut u8,\n-                                                _old_size: usize,\n-                                                size: usize,\n-                                                align: usize)\n-                                                -> usize {\n-        let flags = align_to_flags(align);\n-        unsafe { xallocx(ptr as *mut c_void, size as size_t, 0, flags) as usize }\n+    #[linkage = \"external\"]\n+    pub unsafe extern fn __rde_oom(err: *const u8) -> ! {\n+        System.oom((*(err as *const AllocErr)).clone())\n     }\n \n     #[no_mangle]\n-    pub extern \"C\" fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n+    #[linkage = \"external\"]\n+    pub unsafe extern fn __rde_dealloc(ptr: *mut u8,\n+                                       size: usize,\n+                                       align: usize) {\n         let flags = align_to_flags(align);\n-        unsafe { sdallocx(ptr as *mut c_void, old_size as size_t, flags) }\n+        sdallocx(ptr as *mut c_void, size, flags);\n     }\n \n     #[no_mangle]\n-    pub extern \"C\" fn __rust_usable_size(size: usize, align: usize) -> usize {\n-        let flags = align_to_flags(align);\n-        unsafe { nallocx(size as size_t, flags) as usize }\n-    }\n-}\n-\n-#[cfg(dummy_jemalloc)]\n-mod imp {\n-    fn bogus() -> ! {\n-        panic!(\"jemalloc is not implemented for this platform\");\n+    #[linkage = \"external\"]\n+    pub unsafe extern fn __rde_usable_size(layout: *const u8,\n+                                           min: *mut usize,\n+                                           max: *mut usize) {\n+        let layout = &*(layout as *const Layout);\n+        let flags = align_to_flags(layout.align());\n+        let size = nallocx(layout.size(), flags) as usize;\n+        *min = layout.size();\n+        if size > 0 {\n+            *max = size;\n+        } else {\n+            *max = layout.size();\n+        }\n     }\n \n     #[no_mangle]\n-    pub extern \"C\" fn __rust_allocate(_size: usize, _align: usize) -> *mut u8 {\n-        bogus()\n+    #[linkage = \"external\"]\n+    pub unsafe extern fn __rde_realloc(ptr: *mut u8,\n+                                       _old_size: usize,\n+                                       old_align: usize,\n+                                       new_size: usize,\n+                                       new_align: usize,\n+                                       err: *mut u8) -> *mut u8 {\n+        if new_align != old_align {\n+            ptr::write(err as *mut AllocErr,\n+                       AllocErr::Unsupported { details: \"can't change alignments\" });\n+            return 0 as *mut u8\n+        }\n+\n+        let flags = align_to_flags(new_align);\n+        let ptr = rallocx(ptr as *mut c_void, new_size, flags) as *mut u8;\n+        if ptr.is_null() {\n+            let layout = Layout::from_size_align_unchecked(new_size, new_align);\n+            ptr::write(err as *mut AllocErr,\n+                       AllocErr::Exhausted { request: layout });\n+        }\n+        ptr\n     }\n \n     #[no_mangle]\n-    pub extern \"C\" fn __rust_allocate_zeroed(_size: usize, _align: usize) -> *mut u8 {\n-        bogus()\n+    #[linkage = \"external\"]\n+    pub unsafe extern fn __rde_alloc_zeroed(size: usize,\n+                                            align: usize,\n+                                            err: *mut u8) -> *mut u8 {\n+        let ptr = if align <= MIN_ALIGN {\n+            calloc(size as size_t, 1) as *mut u8\n+        } else {\n+            let flags = align_to_flags(align) | MALLOCX_ZERO;\n+            mallocx(size as size_t, flags) as *mut u8\n+        };\n+        if ptr.is_null() {\n+            let layout = Layout::from_size_align_unchecked(size, align);\n+            ptr::write(err as *mut AllocErr,\n+                       AllocErr::Exhausted { request: layout });\n+        }\n+        ptr\n     }\n \n     #[no_mangle]\n-    pub extern \"C\" fn __rust_reallocate(_ptr: *mut u8,\n-                                        _old_size: usize,\n-                                        _size: usize,\n-                                        _align: usize)\n-                                        -> *mut u8 {\n-        bogus()\n+    #[linkage = \"external\"]\n+    pub unsafe extern fn __rde_alloc_excess(size: usize,\n+                                            align: usize,\n+                                            excess: *mut usize,\n+                                            err: *mut u8) -> *mut u8 {\n+        let p = __rde_alloc(size, align, err);\n+        if !p.is_null() {\n+            *excess = size;\n+        }\n+        return p\n     }\n \n     #[no_mangle]\n-    pub extern \"C\" fn __rust_reallocate_inplace(_ptr: *mut u8,\n-                                                _old_size: usize,\n-                                                _size: usize,\n-                                                _align: usize)\n-                                                -> usize {\n-        bogus()\n+    #[linkage = \"external\"]\n+    pub unsafe extern fn __rde_realloc_excess(ptr: *mut u8,\n+                                              old_size: usize,\n+                                              old_align: usize,\n+                                              new_size: usize,\n+                                              new_align: usize,\n+                                              excess: *mut usize,\n+                                              err: *mut u8) -> *mut u8 {\n+        let p = __rde_realloc(ptr, old_size, old_align, new_size, new_align, err);\n+        if !p.is_null() {\n+            *excess = new_size;\n+        }\n+        return p\n     }\n \n     #[no_mangle]\n-    pub extern \"C\" fn __rust_deallocate(_ptr: *mut u8, _old_size: usize, _align: usize) {\n-        bogus()\n+    #[linkage = \"external\"]\n+    pub unsafe extern fn __rde_grow_in_place(ptr: *mut u8,\n+                                             old_size: usize,\n+                                             old_align: usize,\n+                                             new_size: usize,\n+                                             new_align: usize) -> u8 {\n+        __rde_shrink_in_place(ptr, old_size, old_align, new_size, new_align)\n     }\n \n     #[no_mangle]\n-    pub extern \"C\" fn __rust_usable_size(_size: usize, _align: usize) -> usize {\n-        bogus()\n+    #[linkage = \"external\"]\n+    pub unsafe extern fn __rde_shrink_in_place(ptr: *mut u8,\n+                                               _old_size: usize,\n+                                               old_align: usize,\n+                                               new_size: usize,\n+                                               new_align: usize) -> u8 {\n+        if old_align == new_align {\n+            let flags = align_to_flags(new_align);\n+            (xallocx(ptr as *mut c_void, new_size, 0, flags) == new_size) as u8\n+        } else {\n+            0\n+        }\n     }\n }"}, {"sha": "f20be5fdf5f2b207e318abbd386b84feaacea821", "filename": "src/liballoc_system/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2FCargo.toml?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -12,3 +12,6 @@ doc = false\n [dependencies]\n core = { path = \"../libcore\" }\n libc = { path = \"../rustc/libc_shim\" }\n+\n+[target.'cfg(not(stage0))'.dependencies]\n+alloc = { path = \"../liballoc\" }"}, {"sha": "afecfc16f2c90c19d8580b0afd7c1c51c6d2260d", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 337, "deletions": 142, "changes": 479, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -11,13 +11,18 @@\n #![crate_name = \"alloc_system\"]\n #![crate_type = \"rlib\"]\n #![no_std]\n-#![allocator]\n #![deny(warnings)]\n #![unstable(feature = \"alloc_system\",\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\",\n             issue = \"27783\")]\n-#![feature(allocator)]\n+#![cfg_attr(stage0, allocator)]\n+#![cfg_attr(stage0, feature(allocator))]\n+#![cfg_attr(stage0, feature(core_intrinsics))]\n+#![cfg_attr(not(stage0), feature(global_allocator))]\n+#![cfg_attr(not(stage0), feature(allocator_api))]\n+#![cfg_attr(not(stage0), feature(alloc))]\n+#![cfg_attr(not(stage0), feature(core_intrinsics))]\n #![feature(staged_api)]\n #![cfg_attr(any(unix, target_os = \"redox\"), feature(libc))]\n \n@@ -39,62 +44,201 @@ const MIN_ALIGN: usize = 8;\n               target_arch = \"sparc64\")))]\n const MIN_ALIGN: usize = 16;\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n-    unsafe { imp::allocate(size, align) }\n-}\n+#[cfg(stage0)]\n+pub use old::*;\n+#[cfg(stage0)]\n+mod old;\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n-    unsafe { imp::allocate_zeroed(size, align) }\n-}\n+#[cfg(not(stage0))]\n+pub use new::System;\n+#[cfg(not(stage0))]\n+mod new {\n+    pub extern crate alloc;\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n-    unsafe { imp::deallocate(ptr, old_size, align) }\n-}\n+    use self::alloc::heap::{Alloc, AllocErr, Layout, Excess, CannotReallocInPlace};\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_reallocate(ptr: *mut u8,\n-                                    old_size: usize,\n-                                    size: usize,\n-                                    align: usize)\n-                                    -> *mut u8 {\n-    unsafe { imp::reallocate(ptr, old_size, size, align) }\n-}\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub struct System;\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_reallocate_inplace(ptr: *mut u8,\n-                                            old_size: usize,\n-                                            size: usize,\n-                                            align: usize)\n-                                            -> usize {\n-    unsafe { imp::reallocate_inplace(ptr, old_size, size, align) }\n-}\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    unsafe impl Alloc for System {\n+        #[inline]\n+        unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+            (&*self).alloc(layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn alloc_zeroed(&mut self, layout: Layout)\n+            -> Result<*mut u8, AllocErr>\n+        {\n+            (&*self).alloc_zeroed(layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+            (&*self).dealloc(ptr, layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn realloc(&mut self,\n+                          ptr: *mut u8,\n+                          old_layout: Layout,\n+                          new_layout: Layout) -> Result<*mut u8, AllocErr> {\n+            (&*self).realloc(ptr, old_layout, new_layout)\n+        }\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_usable_size(size: usize, align: usize) -> usize {\n-    imp::usable_size(size, align)\n+        fn oom(&mut self, err: AllocErr) -> ! {\n+            (&*self).oom(err)\n+        }\n+\n+        #[inline]\n+        fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n+            (&self).usable_size(layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n+            (&*self).alloc_excess(layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn realloc_excess(&mut self,\n+                                 ptr: *mut u8,\n+                                 layout: Layout,\n+                                 new_layout: Layout) -> Result<Excess, AllocErr> {\n+            (&*self).realloc_excess(ptr, layout, new_layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn grow_in_place(&mut self,\n+                                ptr: *mut u8,\n+                                layout: Layout,\n+                                new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+            (&*self).grow_in_place(ptr, layout, new_layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn shrink_in_place(&mut self,\n+                                  ptr: *mut u8,\n+                                  layout: Layout,\n+                                  new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+            (&*self).shrink_in_place(ptr, layout, new_layout)\n+        }\n+    }\n }\n \n-#[cfg(any(unix, target_os = \"redox\"))]\n-mod imp {\n+#[cfg(all(not(stage0), any(unix, target_os = \"redox\")))]\n+mod platform {\n     extern crate libc;\n \n     use core::cmp;\n     use core::ptr;\n+\n     use MIN_ALIGN;\n+    use new::System;\n+    use new::alloc::heap::{Alloc, AllocErr, Layout};\n+\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    unsafe impl<'a> Alloc for &'a System {\n+        #[inline]\n+        unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+            let ptr = if layout.align() <= MIN_ALIGN {\n+                libc::malloc(layout.size()) as *mut u8\n+            } else {\n+                aligned_malloc(&layout)\n+            };\n+            if !ptr.is_null() {\n+                Ok(ptr)\n+            } else {\n+                Err(AllocErr::Exhausted { request: layout })\n+            }\n+        }\n \n-    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n-        if align <= MIN_ALIGN {\n-            libc::malloc(size as libc::size_t) as *mut u8\n-        } else {\n-            aligned_malloc(size, align)\n+        #[inline]\n+        unsafe fn alloc_zeroed(&mut self, layout: Layout)\n+            -> Result<*mut u8, AllocErr>\n+        {\n+            if layout.align() <= MIN_ALIGN {\n+                let ptr = libc::calloc(layout.size(), 1) as *mut u8;\n+                if !ptr.is_null() {\n+                    Ok(ptr)\n+                } else {\n+                    Err(AllocErr::Exhausted { request: layout })\n+                }\n+            } else {\n+                let ret = self.alloc(layout.clone());\n+                if let Ok(ptr) = ret {\n+                    ptr::write_bytes(ptr, 0, layout.size());\n+                }\n+                ret\n+            }\n+        }\n+\n+        #[inline]\n+        unsafe fn dealloc(&mut self, ptr: *mut u8, _layout: Layout) {\n+            libc::free(ptr as *mut libc::c_void)\n+        }\n+\n+        #[inline]\n+        unsafe fn realloc(&mut self,\n+                          ptr: *mut u8,\n+                          old_layout: Layout,\n+                          new_layout: Layout) -> Result<*mut u8, AllocErr> {\n+            if old_layout.align() != new_layout.align() {\n+                return Err(AllocErr::Unsupported {\n+                    details: \"cannot change alignment on `realloc`\",\n+                })\n+            }\n+\n+            if new_layout.align() <= MIN_ALIGN {\n+                let ptr = libc::realloc(ptr as *mut libc::c_void, new_layout.size());\n+                if !ptr.is_null() {\n+                    Ok(ptr as *mut u8)\n+                } else {\n+                    Err(AllocErr::Exhausted { request: new_layout })\n+                }\n+            } else {\n+                let res = self.alloc(new_layout.clone());\n+                if let Ok(new_ptr) = res {\n+                    let size = cmp::min(old_layout.size(), new_layout.size());\n+                    ptr::copy_nonoverlapping(ptr, new_ptr, size);\n+                    self.dealloc(ptr, old_layout);\n+                }\n+                res\n+            }\n+        }\n+\n+        fn oom(&mut self, err: AllocErr) -> ! {\n+            use core::fmt::{self, Write};\n+\n+            // Print a message to stderr before aborting to assist with\n+            // debugging. It is critical that this code does not allocate any\n+            // memory since we are in an OOM situation. Any errors are ignored\n+            // while printing since there's nothing we can do about them and we\n+            // are about to exit anyways.\n+            drop(writeln!(Stderr, \"fatal runtime error: {}\", err));\n+            unsafe {\n+                ::core::intrinsics::abort();\n+            }\n+\n+            struct Stderr;\n+\n+            impl Write for Stderr {\n+                fn write_str(&mut self, s: &str) -> fmt::Result {\n+                    unsafe {\n+                        libc::write(libc::STDERR_FILENO,\n+                                    s.as_ptr() as *const libc::c_void,\n+                                    s.len());\n+                    }\n+                    Ok(())\n+                }\n+            }\n         }\n     }\n \n     #[cfg(any(target_os = \"android\", target_os = \"redox\"))]\n-    unsafe fn aligned_malloc(size: usize, align: usize) -> *mut u8 {\n+    #[inline]\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n         // On android we currently target API level 9 which unfortunately\n         // doesn't have the `posix_memalign` API used below. Instead we use\n         // `memalign`, but this unfortunately has the property on some systems\n@@ -112,87 +256,60 @@ mod imp {\n         // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n         // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n         //                                       /memory/aligned_memory.cc\n-        libc::memalign(align as libc::size_t, size as libc::size_t) as *mut u8\n+        libc::memalign(layout.align(), layout.size()) as *mut u8\n     }\n \n     #[cfg(not(any(target_os = \"android\", target_os = \"redox\")))]\n-    unsafe fn aligned_malloc(size: usize, align: usize) -> *mut u8 {\n+    #[inline]\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n         let mut out = ptr::null_mut();\n-        let ret = libc::posix_memalign(&mut out, align as libc::size_t, size as libc::size_t);\n+        let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n         if ret != 0 {\n             ptr::null_mut()\n         } else {\n             out as *mut u8\n         }\n     }\n-\n-    pub unsafe fn allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n-        if align <= MIN_ALIGN {\n-            libc::calloc(size as libc::size_t, 1) as *mut u8\n-        } else {\n-            let ptr = aligned_malloc(size, align);\n-            if !ptr.is_null() {\n-                ptr::write_bytes(ptr, 0, size);\n-            }\n-            ptr\n-        }\n-    }\n-\n-    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n-        if align <= MIN_ALIGN {\n-            libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n-        } else {\n-            let new_ptr = allocate(size, align);\n-            if !new_ptr.is_null() {\n-                ptr::copy(ptr, new_ptr, cmp::min(size, old_size));\n-                deallocate(ptr, old_size, align);\n-            }\n-            new_ptr\n-        }\n-    }\n-\n-    pub unsafe fn reallocate_inplace(_ptr: *mut u8,\n-                                     old_size: usize,\n-                                     _size: usize,\n-                                     _align: usize)\n-                                     -> usize {\n-        old_size\n-    }\n-\n-    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {\n-        libc::free(ptr as *mut libc::c_void)\n-    }\n-\n-    pub fn usable_size(size: usize, _align: usize) -> usize {\n-        size\n-    }\n }\n \n-#[cfg(windows)]\n+#[cfg(all(windows, not(stage0)))]\n #[allow(bad_style)]\n-mod imp {\n-    use core::cmp::min;\n-    use core::ptr::copy_nonoverlapping;\n+mod platform {\n+    use core::cmp;\n+    use core::ptr;\n+\n     use MIN_ALIGN;\n+    use new::System;\n+    use new::alloc::heap::{Alloc, AllocErr, Layout, CannotReallocInPlace};\n \n     type LPVOID = *mut u8;\n     type HANDLE = LPVOID;\n     type SIZE_T = usize;\n     type DWORD = u32;\n     type BOOL = i32;\n+    type LPDWORD = *mut DWORD;\n+    type LPOVERLAPPED = *mut u8;\n+\n+    const STD_ERROR_HANDLE: DWORD = -12i32 as DWORD;\n \n     extern \"system\" {\n         fn GetProcessHeap() -> HANDLE;\n         fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n         fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n         fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n         fn GetLastError() -> DWORD;\n+        fn WriteFile(hFile: HANDLE,\n+                     lpBuffer: LPVOID,\n+                     nNumberOfBytesToWrite: DWORD,\n+                     lpNumberOfBytesWritten: LPDWORD,\n+                     lpOverlapped: LPOVERLAPPED)\n+                     -> BOOL;\n+        fn GetStdHandle(which: DWORD) -> HANDLE;\n     }\n \n     #[repr(C)]\n     struct Header(*mut u8);\n \n-\n     const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n     const HEAP_REALLOC_IN_PLACE_ONLY: DWORD = 0x00000010;\n \n@@ -207,71 +324,149 @@ mod imp {\n     }\n \n     #[inline]\n-    unsafe fn allocate_with_flags(size: usize, align: usize, flags: DWORD) -> *mut u8 {\n-        if align <= MIN_ALIGN {\n-            HeapAlloc(GetProcessHeap(), flags, size as SIZE_T) as *mut u8\n+    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD)\n+        -> Result<*mut u8, AllocErr>\n+    {\n+        let ptr = if layout.align() <= MIN_ALIGN {\n+            HeapAlloc(GetProcessHeap(), flags, layout.size())\n         } else {\n-            let ptr = HeapAlloc(GetProcessHeap(), flags, (size + align) as SIZE_T) as *mut u8;\n+            let size = layout.size() + layout.align();\n+            let ptr = HeapAlloc(GetProcessHeap(), flags, size);\n             if ptr.is_null() {\n-                return ptr;\n+                ptr\n+            } else {\n+                align_ptr(ptr, layout.align())\n             }\n-            align_ptr(ptr, align)\n+        };\n+        if ptr.is_null() {\n+            Err(AllocErr::Exhausted { request: layout })\n+        } else {\n+            Ok(ptr as *mut u8)\n         }\n     }\n \n-    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n-        allocate_with_flags(size, align, 0)\n-    }\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    unsafe impl<'a> Alloc for &'a System {\n+        #[inline]\n+        unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+            allocate_with_flags(layout, 0)\n+        }\n \n-    pub unsafe fn allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n-        allocate_with_flags(size, align, HEAP_ZERO_MEMORY)\n-    }\n+        #[inline]\n+        unsafe fn alloc_zeroed(&mut self, layout: Layout)\n+            -> Result<*mut u8, AllocErr>\n+        {\n+            allocate_with_flags(layout, HEAP_ZERO_MEMORY)\n+        }\n \n-    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n-        if align <= MIN_ALIGN {\n-            HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, size as SIZE_T) as *mut u8\n-        } else {\n-            let new = allocate(size, align);\n-            if !new.is_null() {\n-                copy_nonoverlapping(ptr, new, min(size, old_size));\n-                deallocate(ptr, old_size, align);\n+        #[inline]\n+        unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+            if layout.align() <= MIN_ALIGN {\n+                let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n+                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n+                              GetLastError());\n+            } else {\n+                let header = get_header(ptr);\n+                let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n+                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n+                              GetLastError());\n             }\n-            new\n         }\n-    }\n \n-    pub unsafe fn reallocate_inplace(ptr: *mut u8,\n-                                     old_size: usize,\n-                                     size: usize,\n-                                     align: usize)\n-                                     -> usize {\n-        let new = if align <= MIN_ALIGN {\n-            HeapReAlloc(GetProcessHeap(),\n-                        HEAP_REALLOC_IN_PLACE_ONLY,\n-                        ptr as LPVOID,\n-                        size as SIZE_T) as *mut u8\n-        } else {\n-            let header = get_header(ptr);\n-            HeapReAlloc(GetProcessHeap(),\n-                        HEAP_REALLOC_IN_PLACE_ONLY,\n-                        header.0 as LPVOID,\n-                        size + align as SIZE_T) as *mut u8\n-        };\n-        if new.is_null() { old_size } else { size }\n-    }\n+        #[inline]\n+        unsafe fn realloc(&mut self,\n+                          ptr: *mut u8,\n+                          old_layout: Layout,\n+                          new_layout: Layout) -> Result<*mut u8, AllocErr> {\n+            if old_layout.align() != new_layout.align() {\n+                return Err(AllocErr::Unsupported {\n+                    details: \"cannot change alignment on `realloc`\",\n+                })\n+            }\n \n-    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, align: usize) {\n-        if align <= MIN_ALIGN {\n-            let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n-            debug_assert!(err != 0, \"Failed to free heap memory: {}\", GetLastError());\n-        } else {\n-            let header = get_header(ptr);\n-            let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n-            debug_assert!(err != 0, \"Failed to free heap memory: {}\", GetLastError());\n+            if new_layout.align() <= MIN_ALIGN {\n+                let ptr = HeapReAlloc(GetProcessHeap(),\n+                                      0,\n+                                      ptr as LPVOID,\n+                                      new_layout.size());\n+                if !ptr.is_null() {\n+                    Ok(ptr as *mut u8)\n+                } else {\n+                    Err(AllocErr::Exhausted { request: new_layout })\n+                }\n+            } else {\n+                let res = self.alloc(new_layout.clone());\n+                if let Ok(new_ptr) = res {\n+                    let size = cmp::min(old_layout.size(), new_layout.size());\n+                    ptr::copy_nonoverlapping(ptr, new_ptr, size);\n+                    self.dealloc(ptr, old_layout);\n+                }\n+                res\n+            }\n         }\n-    }\n \n-    pub fn usable_size(size: usize, _align: usize) -> usize {\n-        size\n+        #[inline]\n+        unsafe fn grow_in_place(&mut self,\n+                                ptr: *mut u8,\n+                                layout: Layout,\n+                                new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+            self.shrink_in_place(ptr, layout, new_layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn shrink_in_place(&mut self,\n+                                  ptr: *mut u8,\n+                                  old_layout: Layout,\n+                                  new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+            if old_layout.align() != new_layout.align() {\n+                return Err(CannotReallocInPlace)\n+            }\n+\n+            let new = if new_layout.align() <= MIN_ALIGN {\n+                HeapReAlloc(GetProcessHeap(),\n+                            HEAP_REALLOC_IN_PLACE_ONLY,\n+                            ptr as LPVOID,\n+                            new_layout.size())\n+            } else {\n+                let header = get_header(ptr);\n+                HeapReAlloc(GetProcessHeap(),\n+                            HEAP_REALLOC_IN_PLACE_ONLY,\n+                            header.0 as LPVOID,\n+                            new_layout.size() + new_layout.align())\n+            };\n+            if new.is_null() {\n+                Err(CannotReallocInPlace)\n+            } else {\n+                Ok(())\n+            }\n+        }\n+\n+        fn oom(&mut self, err: AllocErr) -> ! {\n+            use core::fmt::{self, Write};\n+\n+            // Same as with unix we ignore all errors here\n+            drop(writeln!(Stderr, \"fatal runtime error: {}\", err));\n+            unsafe {\n+                ::core::intrinsics::abort();\n+            }\n+\n+            struct Stderr;\n+\n+            impl Write for Stderr {\n+                fn write_str(&mut self, s: &str) -> fmt::Result {\n+                    unsafe {\n+                        // WriteFile silently fails if it is passed an invalid\n+                        // handle, so there is no need to check the result of\n+                        // GetStdHandle.\n+                        WriteFile(GetStdHandle(STD_ERROR_HANDLE),\n+                                  s.as_ptr() as LPVOID,\n+                                  s.len() as DWORD,\n+                                  ptr::null_mut(),\n+                                  ptr::null_mut());\n+                    }\n+                    Ok(())\n+                }\n+            }\n+        }\n     }\n }"}, {"sha": "80aa46075944cb293440f57ea50a459bcd8e7d0b", "filename": "src/liballoc_system/old.rs", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc_system%2Fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Fliballoc_system%2Fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Fold.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,268 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[no_mangle]\n+pub unsafe extern fn __rust_alloc(size: usize,\n+                                  align: usize,\n+                                  err: *mut u8) -> *mut u8 {\n+    let p = imp::allocate(size, align);\n+    if p.is_null() {\n+        __rust_oom(err);\n+    }\n+    p\n+}\n+\n+#[no_mangle]\n+pub unsafe extern fn __rust_oom(_err: *const u8) -> ! {\n+    ::core::intrinsics::abort()\n+}\n+\n+#[no_mangle]\n+pub unsafe extern fn __rust_dealloc(ptr: *mut u8,\n+                                    size: usize,\n+                                    align: usize) {\n+    imp::deallocate(ptr, size, align)\n+}\n+\n+#[no_mangle]\n+pub unsafe extern fn __rust_usable_size(size: usize,\n+                                        _align: usize,\n+                                        min: *mut usize,\n+                                        max: *mut usize) {\n+    *min = size;\n+    *max = size;\n+}\n+\n+#[no_mangle]\n+pub unsafe extern fn __rust_realloc(ptr: *mut u8,\n+                                    old_size: usize,\n+                                    old_align: usize,\n+                                    new_size: usize,\n+                                    new_align: usize,\n+                                    err: *mut u8) -> *mut u8 {\n+    if new_align != old_align {\n+        __rust_oom(err);\n+    }\n+    let p = imp::reallocate(ptr, old_size, new_size, new_align);\n+    if p.is_null() {\n+        __rust_oom(err);\n+    }\n+    p\n+}\n+\n+#[no_mangle]\n+pub unsafe extern fn __rust_alloc_zeroed(size: usize,\n+                                         align: usize,\n+                                         err: *mut u8) -> *mut u8 {\n+    let p = imp::allocate_zeroed(size, align);\n+    if p.is_null() {\n+        __rust_oom(err);\n+    }\n+    p\n+}\n+\n+#[no_mangle]\n+pub unsafe extern fn __rust_alloc_excess(_size: usize,\n+                                         _align: usize,\n+                                         _excess: *mut usize,\n+                                         err: *mut u8) -> *mut u8 {\n+    __rust_oom(err);\n+}\n+\n+#[no_mangle]\n+pub unsafe extern fn __rust_realloc_excess(_ptr: *mut u8,\n+                                           _old_size: usize,\n+                                           _old_align: usize,\n+                                           _new_size: usize,\n+                                           _new_align: usize,\n+                                           _excess: *mut usize,\n+                                           err: *mut u8) -> *mut u8 {\n+    __rust_oom(err);\n+}\n+\n+#[no_mangle]\n+pub unsafe extern fn __rust_grow_in_place(_ptr: *mut u8,\n+                                          _old_size: usize,\n+                                          _old_align: usize,\n+                                          _new_size: usize,\n+                                          _new_align: usize) -> u8 {\n+    0\n+}\n+\n+#[no_mangle]\n+pub unsafe extern fn __rust_shrink_in_place(_ptr: *mut u8,\n+                                            _old_size: usize,\n+                                            _old_align: usize,\n+                                            _new_size: usize,\n+                                            _new_align: usize) -> u8 {\n+    0\n+}\n+\n+#[cfg(any(unix, target_os = \"redox\"))]\n+mod imp {\n+    extern crate libc;\n+\n+    use core::cmp;\n+    use core::ptr;\n+    use MIN_ALIGN;\n+\n+    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n+        if align <= MIN_ALIGN {\n+            libc::malloc(size as libc::size_t) as *mut u8\n+        } else {\n+            aligned_malloc(size, align)\n+        }\n+    }\n+\n+    #[cfg(any(target_os = \"android\", target_os = \"redox\"))]\n+    unsafe fn aligned_malloc(size: usize, align: usize) -> *mut u8 {\n+        // On android we currently target API level 9 which unfortunately\n+        // doesn't have the `posix_memalign` API used below. Instead we use\n+        // `memalign`, but this unfortunately has the property on some systems\n+        // where the memory returned cannot be deallocated by `free`!\n+        //\n+        // Upon closer inspection, however, this appears to work just fine with\n+        // Android, so for this platform we should be fine to call `memalign`\n+        // (which is present in API level 9). Some helpful references could\n+        // possibly be chromium using memalign [1], attempts at documenting that\n+        // memalign + free is ok [2] [3], or the current source of chromium\n+        // which still uses memalign on android [4].\n+        //\n+        // [1]: https://codereview.chromium.org/10796020/\n+        // [2]: https://code.google.com/p/android/issues/detail?id=35391\n+        // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n+        // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n+        //                                       /memory/aligned_memory.cc\n+        libc::memalign(align as libc::size_t, size as libc::size_t) as *mut u8\n+    }\n+\n+    #[cfg(not(any(target_os = \"android\", target_os = \"redox\")))]\n+    unsafe fn aligned_malloc(size: usize, align: usize) -> *mut u8 {\n+        let mut out = ptr::null_mut();\n+        let ret = libc::posix_memalign(&mut out, align as libc::size_t, size as libc::size_t);\n+        if ret != 0 {\n+            ptr::null_mut()\n+        } else {\n+            out as *mut u8\n+        }\n+    }\n+\n+    pub unsafe fn allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n+        if align <= MIN_ALIGN {\n+            libc::calloc(size as libc::size_t, 1) as *mut u8\n+        } else {\n+            let ptr = aligned_malloc(size, align);\n+            if !ptr.is_null() {\n+                ptr::write_bytes(ptr, 0, size);\n+            }\n+            ptr\n+        }\n+    }\n+\n+    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n+        if align <= MIN_ALIGN {\n+            libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n+        } else {\n+            let new_ptr = allocate(size, align);\n+            if !new_ptr.is_null() {\n+                ptr::copy(ptr, new_ptr, cmp::min(size, old_size));\n+                deallocate(ptr, old_size, align);\n+            }\n+            new_ptr\n+        }\n+    }\n+\n+    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {\n+        libc::free(ptr as *mut libc::c_void)\n+    }\n+}\n+\n+#[cfg(windows)]\n+#[allow(bad_style)]\n+mod imp {\n+    use core::cmp::min;\n+    use core::ptr::copy_nonoverlapping;\n+    use MIN_ALIGN;\n+\n+    type LPVOID = *mut u8;\n+    type HANDLE = LPVOID;\n+    type SIZE_T = usize;\n+    type DWORD = u32;\n+    type BOOL = i32;\n+\n+    extern \"system\" {\n+        fn GetProcessHeap() -> HANDLE;\n+        fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n+        fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n+        fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n+        fn GetLastError() -> DWORD;\n+    }\n+\n+    #[repr(C)]\n+    struct Header(*mut u8);\n+\n+\n+    const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n+\n+    unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n+        &mut *(ptr as *mut Header).offset(-1)\n+    }\n+\n+    unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n+        let aligned = ptr.offset((align - (ptr as usize & (align - 1))) as isize);\n+        *get_header(aligned) = Header(ptr);\n+        aligned\n+    }\n+\n+    #[inline]\n+    unsafe fn allocate_with_flags(size: usize, align: usize, flags: DWORD) -> *mut u8 {\n+        if align <= MIN_ALIGN {\n+            HeapAlloc(GetProcessHeap(), flags, size as SIZE_T) as *mut u8\n+        } else {\n+            let ptr = HeapAlloc(GetProcessHeap(), flags, (size + align) as SIZE_T) as *mut u8;\n+            if ptr.is_null() {\n+                return ptr;\n+            }\n+            align_ptr(ptr, align)\n+        }\n+    }\n+\n+    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n+        allocate_with_flags(size, align, 0)\n+    }\n+\n+    pub unsafe fn allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n+        allocate_with_flags(size, align, HEAP_ZERO_MEMORY)\n+    }\n+\n+    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n+        if align <= MIN_ALIGN {\n+            HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, size as SIZE_T) as *mut u8\n+        } else {\n+            let new = allocate(size, align);\n+            if !new.is_null() {\n+                copy_nonoverlapping(ptr, new, min(size, old_size));\n+                deallocate(ptr, old_size, align);\n+            }\n+            new\n+        }\n+    }\n+\n+    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, align: usize) {\n+        if align <= MIN_ALIGN {\n+            let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n+            debug_assert!(err != 0, \"Failed to free heap memory: {}\", GetLastError());\n+        } else {\n+            let header = get_header(ptr);\n+            let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n+            debug_assert!(err != 0, \"Failed to free heap memory: {}\", GetLastError());\n+        }\n+    }\n+}"}, {"sha": "38143593eb12bd3d3147e23b23abfa3420de3475", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -23,13 +23,11 @@\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n        test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n #![no_std]\n-#![needs_allocator]\n #![deny(warnings)]\n \n #![feature(alloc)]\n #![feature(collections_range)]\n #![feature(macro_reexport)]\n-#![feature(needs_allocator)]\n #![feature(staged_api)]\n \n //! Collection types"}, {"sha": "efa6a6cccc2b6850583560a5ea2113f27a315b07", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -84,6 +84,7 @@ pub mod infer;\n pub mod lint;\n \n pub mod middle {\n+    pub mod allocator;\n     pub mod expr_use_visitor;\n     pub mod const_val;\n     pub mod cstore;"}, {"sha": "79a9ef0e8b577c18024ea1e4753786996c4b45a2", "filename": "src/librustc/middle/allocator.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc%2Fmiddle%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc%2Fmiddle%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fallocator.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[derive(Clone, Copy)]\n+pub enum AllocatorKind {\n+    Global,\n+    DefaultLib,\n+    DefaultExe,\n+}\n+\n+impl AllocatorKind {\n+    pub fn fn_name(&self, base: &str) -> String {\n+        match *self {\n+            AllocatorKind::Global => format!(\"__rg_{}\", base),\n+            AllocatorKind::DefaultLib => format!(\"__rdl_{}\", base),\n+            AllocatorKind::DefaultExe => format!(\"__rde_{}\", base),\n+        }\n+    }\n+}"}, {"sha": "77b4c977d289ecd2b62758e4ecccbcc3556735ee", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -287,6 +287,11 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n         return true;\n     }\n \n+    // Don't lint about global allocators\n+    if attr::contains_name(attrs, \"global_allocator\") {\n+        return true;\n+    }\n+\n     let dead_code = lint::builtin::DEAD_CODE.name_lower();\n     for attr in lint::gather_attrs(attrs) {\n         match attr {"}, {"sha": "9af93d0d494244591cac86d942c6e59327e35537", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -214,10 +214,9 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     //\n     // Things like allocators and panic runtimes may not have been activated\n     // quite yet, so do so here.\n-    activate_injected_dep(sess.injected_allocator.get(), &mut ret,\n-                          &|cnum| tcx.is_allocator(cnum.as_def_id()));\n     activate_injected_dep(sess.injected_panic_runtime.get(), &mut ret,\n                           &|cnum| tcx.is_panic_runtime(cnum.as_def_id()));\n+    activate_injected_allocator(sess, &mut ret);\n \n     // When dylib B links to dylib A, then when using B we must also link to A.\n     // It could be the case, however, that the rlib for A is present (hence we\n@@ -295,10 +294,9 @@ fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyLis\n     // Our allocator/panic runtime may not have been linked above if it wasn't\n     // explicitly linked, which is the case for any injected dependency. Handle\n     // that here and activate them.\n-    activate_injected_dep(sess.injected_allocator.get(), &mut ret,\n-                          &|cnum| tcx.is_allocator(cnum.as_def_id()));\n     activate_injected_dep(sess.injected_panic_runtime.get(), &mut ret,\n                           &|cnum| tcx.is_panic_runtime(cnum.as_def_id()));\n+    activate_injected_allocator(sess, &mut ret);\n \n     Some(ret)\n }\n@@ -331,30 +329,31 @@ fn activate_injected_dep(injected: Option<CrateNum>,\n     }\n }\n \n+fn activate_injected_allocator(sess: &session::Session,\n+                               list: &mut DependencyList) {\n+    let cnum = match sess.injected_allocator.get() {\n+        Some(cnum) => cnum,\n+        None => return,\n+    };\n+    let idx = cnum.as_usize() - 1;\n+    if list[idx] == Linkage::NotLinked {\n+        list[idx] = Linkage::Static;\n+    }\n+}\n+\n // After the linkage for a crate has been determined we need to verify that\n // there's only going to be one allocator in the output.\n fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n     let sess = &tcx.sess;\n     if list.len() == 0 {\n         return\n     }\n-    let mut allocator = None;\n     let mut panic_runtime = None;\n     for (i, linkage) in list.iter().enumerate() {\n         if let Linkage::NotLinked = *linkage {\n             continue\n         }\n         let cnum = CrateNum::new(i + 1);\n-        if tcx.is_allocator(cnum.as_def_id()) {\n-            if let Some(prev) = allocator {\n-                let prev_name = sess.cstore.crate_name(prev);\n-                let cur_name = sess.cstore.crate_name(cnum);\n-                sess.err(&format!(\"cannot link together two \\\n-                                   allocators: {} and {}\",\n-                                  prev_name, cur_name));\n-            }\n-            allocator = Some(cnum);\n-        }\n \n         if tcx.is_panic_runtime(cnum.as_def_id()) {\n             if let Some((prev, _)) = panic_runtime {"}, {"sha": "39a719faa123ecd46af046f7b7a13484c9b521e4", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -16,6 +16,7 @@ use hir::def_id::{CrateNum, DefIndex};\n \n use lint;\n use middle::cstore::CrateStore;\n+use middle::allocator::AllocatorKind;\n use middle::dependency_format;\n use session::search_paths::PathKind;\n use session::config::DebugInfoLevel;\n@@ -106,6 +107,7 @@ pub struct Session {\n     /// dependency if it didn't already find one, and this tracks what was\n     /// injected.\n     pub injected_allocator: Cell<Option<CrateNum>>,\n+    pub allocator_kind: Cell<Option<AllocatorKind>>,\n     pub injected_panic_runtime: Cell<Option<CrateNum>>,\n \n     /// Map from imported macro spans (which consist of\n@@ -140,6 +142,9 @@ pub struct Session {\n     /// Loaded up early on in the initialization of this `Session` to avoid\n     /// false positives about a job server in our environment.\n     pub jobserver_from_env: Option<Client>,\n+\n+    /// Metadata about the allocators for the current crate being compiled\n+    pub has_global_allocator: Cell<bool>,\n }\n \n pub struct PerfStats {\n@@ -715,6 +720,7 @@ pub fn build_session_(sopts: config::Options,\n         type_length_limit: Cell::new(1048576),\n         next_node_id: Cell::new(NodeId::new(1)),\n         injected_allocator: Cell::new(None),\n+        allocator_kind: Cell::new(None),\n         injected_panic_runtime: Cell::new(None),\n         imported_macro_spans: RefCell::new(HashMap::new()),\n         incr_comp_session: RefCell::new(IncrCompSession::NotInitialized),\n@@ -732,7 +738,6 @@ pub fn build_session_(sopts: config::Options,\n         print_fuel_crate: print_fuel_crate,\n         print_fuel: print_fuel,\n         out_of_fuel: Cell::new(false),\n-\n         // Note that this is unsafe because it may misinterpret file descriptors\n         // on Unix as jobserver file descriptors. We hopefully execute this near\n         // the beginning of the process though to ensure we don't get false\n@@ -750,6 +755,7 @@ pub fn build_session_(sopts: config::Options,\n             });\n             (*GLOBAL_JOBSERVER).clone()\n         },\n+        has_global_allocator: Cell::new(false),\n     };\n \n     sess"}, {"sha": "e3d1d8e32c4b72899b8021abe11d3a1982d52efd", "filename": "src/librustc_allocator/Cargo.toml", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_allocator%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_allocator%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2FCargo.toml?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,15 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_allocator\"\n+version = \"0.0.0\"\n+\n+[lib]\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+test = false\n+\n+[dependencies]\n+rustc = { path = \"../librustc\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n+syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "e942b7264c589ebf952988f4be92fd6cee29e2d5", "filename": "src/librustc_allocator/expand.rs", "status": "added", "additions": 498, "deletions": 0, "changes": 498, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,498 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::middle::allocator::AllocatorKind;\n+use rustc_errors;\n+use syntax::abi::Abi;\n+use syntax::ast::{Crate, Attribute, LitKind, StrStyle, ExprKind};\n+use syntax::ast::{Unsafety, Constness, Generics, Mutability, Ty, Mac, Arg};\n+use syntax::ast::{self, Ident, Item, ItemKind, TyKind, Visibility, Expr};\n+use syntax::attr;\n+use syntax::codemap::dummy_spanned;\n+use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n+use syntax::ext::base::ExtCtxt;\n+use syntax::ext::base::Resolver;\n+use syntax::ext::build::AstBuilder;\n+use syntax::ext::expand::ExpansionConfig;\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::fold::{self, Folder};\n+use syntax::parse::ParseSess;\n+use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n+use syntax::util::small_vector::SmallVector;\n+use syntax_pos::{Span, DUMMY_SP};\n+\n+use {AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n+\n+pub fn modify(sess: &ParseSess,\n+              resolver: &mut Resolver,\n+              krate: Crate,\n+              handler: &rustc_errors::Handler) -> ast::Crate {\n+    ExpandAllocatorDirectives {\n+        handler: handler,\n+        sess: sess,\n+        resolver: resolver,\n+        found: false,\n+    }.fold_crate(krate)\n+}\n+\n+struct ExpandAllocatorDirectives<'a> {\n+    found: bool,\n+    handler: &'a rustc_errors::Handler,\n+    sess: &'a ParseSess,\n+    resolver: &'a mut Resolver,\n+}\n+\n+impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n+    fn fold_item(&mut self, item: P<Item>) -> SmallVector<P<Item>> {\n+        let name = if attr::contains_name(&item.attrs, \"global_allocator\") {\n+            \"global_allocator\"\n+        } else {\n+            return fold::noop_fold_item(item, self)\n+        };\n+        match item.node {\n+            ItemKind::Static(..) => {}\n+            _ => {\n+                self.handler.span_err(item.span, \"allocators must be statics\");\n+                return SmallVector::one(item)\n+            }\n+        }\n+\n+        if self.found {\n+            self.handler.span_err(item.span, \"cannot define more than one \\\n+                                              #[global_allocator]\");\n+            return SmallVector::one(item)\n+        }\n+        self.found = true;\n+\n+        let mark = Mark::fresh(Mark::root());\n+        mark.set_expn_info(ExpnInfo {\n+            call_site: DUMMY_SP,\n+            callee: NameAndSpan {\n+                format: MacroAttribute(Symbol::intern(name)),\n+                span: None,\n+                allow_internal_unstable: true,\n+            }\n+        });\n+        let span = Span {\n+            ctxt: SyntaxContext::empty().apply_mark(mark),\n+            ..item.span\n+        };\n+        let ecfg = ExpansionConfig::default(name.to_string());\n+        let mut f = AllocFnFactory {\n+            span: span,\n+            kind: AllocatorKind::Global,\n+            global: item.ident,\n+            alloc: Ident::from_str(\"alloc\"),\n+            cx: ExtCtxt::new(self.sess, ecfg, self.resolver),\n+        };\n+        let super_path = f.cx.path(f.span, vec![\n+            Ident::from_str(\"super\"),\n+            f.global,\n+        ]);\n+        let mut items = vec![\n+            f.cx.item_extern_crate(f.span, f.alloc),\n+            f.cx.item_use_simple(f.span, Visibility::Inherited, super_path),\n+        ];\n+        for method in ALLOCATOR_METHODS {\n+            items.push(f.allocator_fn(method));\n+        }\n+        let name = f.kind.fn_name(\"allocator_abi\");\n+        let allocator_abi = Ident::with_empty_ctxt(Symbol::gensym(&name));\n+        let module = f.cx.item_mod(span, span, allocator_abi, Vec::new(), items);\n+        let module = f.cx.monotonic_expander().fold_item(module).pop().unwrap();\n+\n+        let mut ret = SmallVector::new();\n+        ret.push(item);\n+        ret.push(module);\n+        return ret\n+    }\n+\n+    fn fold_mac(&mut self, mac: Mac) -> Mac {\n+        fold::noop_fold_mac(mac, self)\n+    }\n+}\n+\n+struct AllocFnFactory<'a> {\n+    span: Span,\n+    kind: AllocatorKind,\n+    global: Ident,\n+    alloc: Ident,\n+    cx: ExtCtxt<'a>,\n+}\n+\n+impl<'a> AllocFnFactory<'a> {\n+    fn allocator_fn(&self, method: &AllocatorMethod) -> P<Item> {\n+        let mut abi_args = Vec::new();\n+        let mut i = 0;\n+        let ref mut mk = || {\n+            let name = Ident::from_str(&format!(\"arg{}\", i));\n+            i += 1;\n+            name\n+        };\n+        let args = method.inputs.iter().map(|ty| {\n+            self.arg_ty(ty, &mut abi_args, mk)\n+        }).collect();\n+        let result = self.call_allocator(method.name, args);\n+        let (output_ty, output_expr) =\n+            self.ret_ty(&method.output, &mut abi_args, mk, result);\n+        let kind = ItemKind::Fn(self.cx.fn_decl(abi_args, output_ty),\n+                                Unsafety::Unsafe,\n+                                dummy_spanned(Constness::NotConst),\n+                                Abi::Rust,\n+                                Generics::default(),\n+                                self.cx.block_expr(output_expr));\n+        self.cx.item(self.span,\n+                     Ident::from_str(&self.kind.fn_name(method.name)),\n+                     self.attrs(),\n+                     kind)\n+    }\n+\n+    fn call_allocator(&self, method: &str, mut args: Vec<P<Expr>>) -> P<Expr> {\n+        let method = self.cx.path(self.span, vec![\n+            self.alloc,\n+            Ident::from_str(\"heap\"),\n+            Ident::from_str(\"Alloc\"),\n+            Ident::from_str(method),\n+        ]);\n+        let method = self.cx.expr_path(method);\n+        let allocator = self.cx.path_ident(self.span, self.global);\n+        let allocator = self.cx.expr_path(allocator);\n+        let allocator = self.cx.expr_addr_of(self.span, allocator);\n+        let allocator = self.cx.expr_mut_addr_of(self.span, allocator);\n+        args.insert(0, allocator);\n+\n+        self.cx.expr_call(self.span, method, args)\n+    }\n+\n+    fn attrs(&self) -> Vec<Attribute> {\n+        let key = Symbol::intern(\"linkage\");\n+        let value = LitKind::Str(Symbol::intern(\"external\"), StrStyle::Cooked);\n+        let linkage = self.cx.meta_name_value(self.span, key, value);\n+\n+        let no_mangle = Symbol::intern(\"no_mangle\");\n+        let no_mangle = self.cx.meta_word(self.span, no_mangle);\n+        vec![\n+            self.cx.attribute(self.span, linkage),\n+            self.cx.attribute(self.span, no_mangle),\n+        ]\n+    }\n+\n+    fn arg_ty(&self,\n+              ty: &AllocatorTy,\n+              args: &mut Vec<Arg>,\n+              mut ident: &mut FnMut() -> Ident) -> P<Expr> {\n+        match *ty {\n+            AllocatorTy::Layout => {\n+                let usize = self.cx.path_ident(self.span, Ident::from_str(\"usize\"));\n+                let ty_usize = self.cx.ty_path(usize);\n+                let size = ident();\n+                let align = ident();\n+                args.push(self.cx.arg(self.span, size, ty_usize.clone()));\n+                args.push(self.cx.arg(self.span, align, ty_usize));\n+\n+                let layout_new = self.cx.path(self.span, vec![\n+                    self.alloc,\n+                    Ident::from_str(\"heap\"),\n+                    Ident::from_str(\"Layout\"),\n+                    Ident::from_str(\"from_size_align_unchecked\"),\n+                ]);\n+                let layout_new = self.cx.expr_path(layout_new);\n+                let size = self.cx.expr_ident(self.span, size);\n+                let align = self.cx.expr_ident(self.span, align);\n+                let layout = self.cx.expr_call(self.span,\n+                                               layout_new,\n+                                               vec![size, align]);\n+                layout\n+            }\n+\n+            AllocatorTy::LayoutRef => {\n+                let ident = ident();\n+                args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n+\n+                // Convert our `arg: *const u8` via:\n+                //\n+                //      &*(arg as *const Layout)\n+                let expr = self.cx.expr_ident(self.span, ident);\n+                let expr = self.cx.expr_cast(self.span, expr, self.layout_ptr());\n+                let expr = self.cx.expr_deref(self.span, expr);\n+                self.cx.expr_addr_of(self.span, expr)\n+            }\n+\n+            AllocatorTy::AllocErr => {\n+                // We're creating:\n+                //\n+                //      (*(arg as *const AllocErr)).clone()\n+                let ident = ident();\n+                args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n+                let expr = self.cx.expr_ident(self.span, ident);\n+                let expr = self.cx.expr_cast(self.span, expr, self.alloc_err_ptr());\n+                let expr = self.cx.expr_deref(self.span, expr);\n+                self.cx.expr_method_call(\n+                    self.span,\n+                    expr,\n+                    Ident::from_str(\"clone\"),\n+                    Vec::new()\n+                )\n+            }\n+\n+            AllocatorTy::Ptr => {\n+                let ident = ident();\n+                args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n+                self.cx.expr_ident(self.span, ident)\n+            }\n+\n+            AllocatorTy::ResultPtr |\n+            AllocatorTy::ResultExcess |\n+            AllocatorTy::ResultUnit |\n+            AllocatorTy::Bang |\n+            AllocatorTy::UsizePair |\n+            AllocatorTy::Unit => {\n+                panic!(\"can't convert AllocatorTy to an argument\")\n+            }\n+        }\n+    }\n+\n+    fn ret_ty(&self,\n+              ty: &AllocatorTy,\n+              args: &mut Vec<Arg>,\n+              mut ident: &mut FnMut() -> Ident,\n+              expr: P<Expr>) -> (P<Ty>, P<Expr>)\n+    {\n+        match *ty {\n+            AllocatorTy::UsizePair => {\n+                // We're creating:\n+                //\n+                //      let arg = #expr;\n+                //      *min = arg.0;\n+                //      *max = arg.1;\n+\n+                let min = ident();\n+                let max = ident();\n+\n+                args.push(self.cx.arg(self.span, min, self.ptr_usize()));\n+                args.push(self.cx.arg(self.span, max, self.ptr_usize()));\n+\n+                let ident = ident();\n+                let stmt = self.cx.stmt_let(self.span, false, ident, expr);\n+                let min = self.cx.expr_ident(self.span, min);\n+                let max = self.cx.expr_ident(self.span, max);\n+                let layout = self.cx.expr_ident(self.span, ident);\n+                let assign_min = self.cx.expr(self.span, ExprKind::Assign(\n+                    self.cx.expr_deref(self.span, min),\n+                    self.cx.expr_tup_field_access(self.span, layout.clone(), 0),\n+                ));\n+                let assign_min = self.cx.stmt_semi(assign_min);\n+                let assign_max = self.cx.expr(self.span, ExprKind::Assign(\n+                    self.cx.expr_deref(self.span, max),\n+                    self.cx.expr_tup_field_access(self.span, layout.clone(), 1),\n+                ));\n+                let assign_max = self.cx.stmt_semi(assign_max);\n+\n+                let stmts = vec![stmt, assign_min, assign_max];\n+                let block = self.cx.block(self.span, stmts);\n+                let ty_unit = self.cx.ty(self.span, TyKind::Tup(Vec::new()));\n+                (ty_unit, self.cx.expr_block(block))\n+            }\n+\n+            AllocatorTy::ResultExcess => {\n+                // We're creating:\n+                //\n+                //      match #expr {\n+                //          Ok(ptr) => {\n+                //              *excess = ptr.1;\n+                //              ptr.0\n+                //          }\n+                //          Err(e) => {\n+                //              ptr::write(err_ptr, e);\n+                //              0 as *mut u8\n+                //          }\n+                //      }\n+\n+                let excess_ptr = ident();\n+                args.push(self.cx.arg(self.span, excess_ptr, self.ptr_usize()));\n+                let excess_ptr = self.cx.expr_ident(self.span, excess_ptr);\n+\n+                let err_ptr = ident();\n+                args.push(self.cx.arg(self.span, err_ptr, self.ptr_u8()));\n+                let err_ptr = self.cx.expr_ident(self.span, err_ptr);\n+                let err_ptr = self.cx.expr_cast(self.span,\n+                                                err_ptr,\n+                                                self.alloc_err_ptr());\n+\n+                let name = ident();\n+                let ok_expr = {\n+                    let ptr = self.cx.expr_ident(self.span, name);\n+                    let write = self.cx.expr(self.span, ExprKind::Assign(\n+                        self.cx.expr_deref(self.span, excess_ptr),\n+                        self.cx.expr_tup_field_access(self.span, ptr.clone(), 1),\n+                    ));\n+                    let write = self.cx.stmt_semi(write);\n+                    let ret = self.cx.expr_tup_field_access(self.span,\n+                                                            ptr.clone(),\n+                                                            0);\n+                    let ret = self.cx.stmt_expr(ret);\n+                    let block = self.cx.block(self.span, vec![write, ret]);\n+                    self.cx.expr_block(block)\n+                };\n+                let pat = self.cx.pat_ident(self.span, name);\n+                let ok = self.cx.path_ident(self.span, Ident::from_str(\"Ok\"));\n+                let ok = self.cx.pat_tuple_struct(self.span, ok, vec![pat]);\n+                let ok = self.cx.arm(self.span, vec![ok], ok_expr);\n+\n+                let name = ident();\n+                let err_expr = {\n+                    let err = self.cx.expr_ident(self.span, name);\n+                    let write = self.cx.path(self.span, vec![\n+                        self.alloc,\n+                        Ident::from_str(\"heap\"),\n+                        Ident::from_str(\"__core\"),\n+                        Ident::from_str(\"ptr\"),\n+                        Ident::from_str(\"write\"),\n+                    ]);\n+                    let write = self.cx.expr_path(write);\n+                    let write = self.cx.expr_call(self.span, write,\n+                                                  vec![err_ptr, err]);\n+                    let write = self.cx.stmt_semi(write);\n+                    let null = self.cx.expr_usize(self.span, 0);\n+                    let null = self.cx.expr_cast(self.span, null, self.ptr_u8());\n+                    let null = self.cx.stmt_expr(null);\n+                    let block = self.cx.block(self.span, vec![write, null]);\n+                    self.cx.expr_block(block)\n+                };\n+                let pat = self.cx.pat_ident(self.span, name);\n+                let err = self.cx.path_ident(self.span, Ident::from_str(\"Err\"));\n+                let err = self.cx.pat_tuple_struct(self.span, err, vec![pat]);\n+                let err = self.cx.arm(self.span, vec![err], err_expr);\n+\n+                let expr = self.cx.expr_match(self.span, expr, vec![ok, err]);\n+                (self.ptr_u8(), expr)\n+            }\n+\n+            AllocatorTy::ResultPtr => {\n+                // We're creating:\n+                //\n+                //      match #expr {\n+                //          Ok(ptr) => ptr,\n+                //          Err(e) => {\n+                //              ptr::write(err_ptr, e);\n+                //              0 as *mut u8\n+                //          }\n+                //      }\n+\n+                let err_ptr = ident();\n+                args.push(self.cx.arg(self.span, err_ptr, self.ptr_u8()));\n+                let err_ptr = self.cx.expr_ident(self.span, err_ptr);\n+                let err_ptr = self.cx.expr_cast(self.span,\n+                                                err_ptr,\n+                                                self.alloc_err_ptr());\n+\n+                let name = ident();\n+                let ok_expr = self.cx.expr_ident(self.span, name);\n+                let pat = self.cx.pat_ident(self.span, name);\n+                let ok = self.cx.path_ident(self.span, Ident::from_str(\"Ok\"));\n+                let ok = self.cx.pat_tuple_struct(self.span, ok, vec![pat]);\n+                let ok = self.cx.arm(self.span, vec![ok], ok_expr);\n+\n+                let name = ident();\n+                let err_expr = {\n+                    let err = self.cx.expr_ident(self.span, name);\n+                    let write = self.cx.path(self.span, vec![\n+                        self.alloc,\n+                        Ident::from_str(\"heap\"),\n+                        Ident::from_str(\"__core\"),\n+                        Ident::from_str(\"ptr\"),\n+                        Ident::from_str(\"write\"),\n+                    ]);\n+                    let write = self.cx.expr_path(write);\n+                    let write = self.cx.expr_call(self.span, write,\n+                                                  vec![err_ptr, err]);\n+                    let write = self.cx.stmt_semi(write);\n+                    let null = self.cx.expr_usize(self.span, 0);\n+                    let null = self.cx.expr_cast(self.span, null, self.ptr_u8());\n+                    let null = self.cx.stmt_expr(null);\n+                    let block = self.cx.block(self.span, vec![write, null]);\n+                    self.cx.expr_block(block)\n+                };\n+                let pat = self.cx.pat_ident(self.span, name);\n+                let err = self.cx.path_ident(self.span, Ident::from_str(\"Err\"));\n+                let err = self.cx.pat_tuple_struct(self.span, err, vec![pat]);\n+                let err = self.cx.arm(self.span, vec![err], err_expr);\n+\n+                let expr = self.cx.expr_match(self.span, expr, vec![ok, err]);\n+                (self.ptr_u8(), expr)\n+            }\n+\n+            AllocatorTy::ResultUnit => {\n+                // We're creating:\n+                //\n+                //      #expr.is_ok() as u8\n+\n+                let cast = self.cx.expr_method_call(\n+                    self.span,\n+                    expr,\n+                    Ident::from_str(\"is_ok\"),\n+                    Vec::new()\n+                );\n+                let u8 = self.cx.path_ident(self.span, Ident::from_str(\"u8\"));\n+                let u8 = self.cx.ty_path(u8);\n+                let cast = self.cx.expr_cast(self.span, cast, u8.clone());\n+                (u8, cast)\n+            }\n+\n+            AllocatorTy::Bang => {\n+                (self.cx.ty(self.span, TyKind::Never), expr)\n+            }\n+\n+            AllocatorTy::Unit => {\n+                (self.cx.ty(self.span, TyKind::Tup(Vec::new())), expr)\n+            }\n+\n+            AllocatorTy::AllocErr |\n+            AllocatorTy::Layout |\n+            AllocatorTy::LayoutRef |\n+            AllocatorTy::Ptr => {\n+                panic!(\"can't convert AllocatorTy to an output\")\n+            }\n+        }\n+    }\n+\n+    fn ptr_u8(&self) -> P<Ty> {\n+        let u8 = self.cx.path_ident(self.span, Ident::from_str(\"u8\"));\n+        let ty_u8 = self.cx.ty_path(u8);\n+        self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n+    }\n+\n+    fn ptr_usize(&self) -> P<Ty> {\n+        let usize = self.cx.path_ident(self.span, Ident::from_str(\"usize\"));\n+        let ty_usize = self.cx.ty_path(usize);\n+        self.cx.ty_ptr(self.span, ty_usize, Mutability::Mutable)\n+    }\n+\n+    fn layout_ptr(&self) -> P<Ty> {\n+        let layout = self.cx.path(self.span, vec![\n+            self.alloc,\n+            Ident::from_str(\"heap\"),\n+            Ident::from_str(\"Layout\"),\n+        ]);\n+        let layout = self.cx.ty_path(layout);\n+        self.cx.ty_ptr(self.span, layout, Mutability::Mutable)\n+    }\n+\n+    fn alloc_err_ptr(&self) -> P<Ty> {\n+        let err = self.cx.path(self.span, vec![\n+            self.alloc,\n+            Ident::from_str(\"heap\"),\n+            Ident::from_str(\"AllocErr\"),\n+        ]);\n+        let err = self.cx.ty_path(err);\n+        self.cx.ty_ptr(self.span, err, Mutability::Mutable)\n+    }\n+}"}, {"sha": "d0ea40d1e361daad3a38f55200cdfcd32c0555b8", "filename": "src/librustc_allocator/lib.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_allocator%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_allocator%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Flib.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_private)]\n+\n+extern crate rustc;\n+extern crate rustc_errors;\n+extern crate syntax;\n+extern crate syntax_pos;\n+\n+pub mod expand;\n+\n+pub static ALLOCATOR_METHODS: &[AllocatorMethod] = &[\n+    AllocatorMethod {\n+        name: \"alloc\",\n+        inputs: &[AllocatorTy::Layout],\n+        output: AllocatorTy::ResultPtr,\n+        is_unsafe: true,\n+    },\n+    AllocatorMethod {\n+        name: \"oom\",\n+        inputs: &[AllocatorTy::AllocErr],\n+        output: AllocatorTy::Bang,\n+        is_unsafe: false,\n+    },\n+    AllocatorMethod {\n+        name: \"dealloc\",\n+        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout],\n+        output: AllocatorTy::Unit,\n+        is_unsafe: true,\n+    },\n+    AllocatorMethod {\n+        name: \"usable_size\",\n+        inputs: &[AllocatorTy::LayoutRef],\n+        output: AllocatorTy::UsizePair,\n+        is_unsafe: false,\n+    },\n+    AllocatorMethod {\n+        name: \"realloc\",\n+        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n+        output: AllocatorTy::ResultPtr,\n+        is_unsafe: true,\n+    },\n+    AllocatorMethod {\n+        name: \"alloc_zeroed\",\n+        inputs: &[AllocatorTy::Layout],\n+        output: AllocatorTy::ResultPtr,\n+        is_unsafe: true,\n+    },\n+    AllocatorMethod {\n+        name: \"alloc_excess\",\n+        inputs: &[AllocatorTy::Layout],\n+        output: AllocatorTy::ResultExcess,\n+        is_unsafe: true,\n+    },\n+    AllocatorMethod {\n+        name: \"realloc_excess\",\n+        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n+        output: AllocatorTy::ResultExcess,\n+        is_unsafe: true,\n+    },\n+    AllocatorMethod {\n+        name: \"grow_in_place\",\n+        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n+        output: AllocatorTy::ResultUnit,\n+        is_unsafe: true,\n+    },\n+    AllocatorMethod {\n+        name: \"shrink_in_place\",\n+        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n+        output: AllocatorTy::ResultUnit,\n+        is_unsafe: true,\n+    },\n+];\n+\n+pub struct AllocatorMethod {\n+    pub name: &'static str,\n+    pub inputs: &'static [AllocatorTy],\n+    pub output: AllocatorTy,\n+    pub is_unsafe: bool,\n+}\n+\n+pub enum AllocatorTy {\n+    AllocErr,\n+    Bang,\n+    Layout,\n+    LayoutRef,\n+    Ptr,\n+    ResultExcess,\n+    ResultPtr,\n+    ResultUnit,\n+    Unit,\n+    UsizePair,\n+}"}, {"sha": "8f8ef1cc4a0111165ced04bddc19f49a1078fe43", "filename": "src/librustc_asan/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_asan%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_asan%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2FCargo.toml?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -14,5 +14,6 @@ build_helper = { path = \"../build_helper\" }\n cmake = \"0.1.18\"\n \n [dependencies]\n+alloc = { path = \"../liballoc\" }\n alloc_system = { path = \"../liballoc_system\" }\n core = { path = \"../libcore\" }"}, {"sha": "e987b1f335e19c3b711a943e0f1f8e2205f8b9d6", "filename": "src/librustc_asan/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_asan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_asan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2Flib.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -11,10 +11,19 @@\n #![sanitizer_runtime]\n #![feature(sanitizer_runtime)]\n #![feature(alloc_system)]\n+#![cfg_attr(not(stage0), feature(allocator_api))]\n+#![cfg_attr(not(stage0), feature(global_allocator))]\n #![feature(staged_api)]\n #![no_std]\n #![unstable(feature = \"sanitizer_runtime_lib\",\n             reason = \"internal implementation detail of sanitizers\",\n             issue = \"0\")]\n \n extern crate alloc_system;\n+\n+#[cfg(not(stage0))]\n+use alloc_system::System;\n+\n+#[cfg(not(stage0))]\n+#[global_allocator]\n+static ALLOC: System = System;"}, {"sha": "c5427a13e4c7df44510a32ec669eb8d0d7945699", "filename": "src/librustc_back/target/aarch64_unknown_freebsd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_freebsd.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> TargetResult {\n     base.max_atomic_width = Some(128);\n \n     // see #36994\n-    base.exe_allocation_crate = \"alloc_system\".to_string();\n+    base.exe_allocation_crate = None;\n \n     Ok(Target {\n         llvm_target: \"aarch64-unknown-freebsd\".to_string(),"}, {"sha": "7c2c45a2843a7ccf8e9da14c8aef7a470ddaed12", "filename": "src/librustc_back/target/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> TargetResult {\n     base.max_atomic_width = Some(128);\n \n     // see #36994\n-    base.exe_allocation_crate = \"alloc_system\".to_string();\n+    base.exe_allocation_crate = None;\n \n     Ok(Target {\n         llvm_target: \"aarch64-unknown-linux-gnu\".to_string(),"}, {"sha": "5c4e01886a434366f9de5eb085b584aa26f9aec3", "filename": "src/librustc_back/target/bitrig_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -19,7 +19,6 @@ pub fn opts() -> TargetOptions {\n         linker_is_gnu: true,\n         has_rpath: true,\n         position_independent_executables: true,\n-        exe_allocation_crate: \"alloc_system\".to_string(),\n \n         .. Default::default()\n     }"}, {"sha": "63ccd21c220f32aa290583a2f3f8dbde66bb75ce", "filename": "src/librustc_back/target/fuchsia_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Ffuchsia_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Ffuchsia_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Ffuchsia_base.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -37,7 +37,6 @@ pub fn opts() -> TargetOptions {\n         has_rpath: true,\n         pre_link_args: args,\n         position_independent_executables: true,\n-        exe_allocation_crate: \"alloc_system\".to_string(),\n         has_elf_tls: true,\n         .. Default::default()\n     }"}, {"sha": "2d77902046109223ed6db1c777c6581fa0e8a71c", "filename": "src/librustc_back/target/mips64_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmips64_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmips64_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips64_unknown_linux_gnuabi64.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -29,7 +29,7 @@ pub fn target() -> TargetResult {\n             max_atomic_width: Some(64),\n \n             // see #36994\n-            exe_allocation_crate: \"alloc_system\".to_string(),\n+            exe_allocation_crate: None,\n \n             ..super::linux_base::opts()\n         },"}, {"sha": "c26780b9e65ce604e4df480a576980a4db114ce0", "filename": "src/librustc_back/target/mips64el_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmips64el_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmips64el_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips64el_unknown_linux_gnuabi64.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -29,7 +29,7 @@ pub fn target() -> TargetResult {\n             max_atomic_width: Some(64),\n \n             // see #36994\n-            exe_allocation_crate: \"alloc_system\".to_string(),\n+            exe_allocation_crate: None,\n \n             ..super::linux_base::opts()\n         },"}, {"sha": "24649851d76fd1b336fdd03ff37f27af224b9580", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -28,7 +28,7 @@ pub fn target() -> TargetResult {\n             max_atomic_width: Some(32),\n \n             // see #36994\n-            exe_allocation_crate: \"alloc_system\".to_string(),\n+            exe_allocation_crate: None,\n \n             ..super::linux_base::opts()\n         },"}, {"sha": "6303722945c9f3a4814157a903b4c74b507d45d7", "filename": "src/librustc_back/target/mips_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -28,7 +28,7 @@ pub fn target() -> TargetResult {\n             max_atomic_width: Some(32),\n \n             // see #36994\n-            exe_allocation_crate: \"alloc_system\".to_string(),\n+            exe_allocation_crate: None,\n \n             ..super::linux_base::opts()\n         }"}, {"sha": "1a7a56a9779218c52823912fa0ac720db4f40b86", "filename": "src/librustc_back/target/mips_unknown_linux_uclibc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_uclibc.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -28,7 +28,7 @@ pub fn target() -> TargetResult {\n             max_atomic_width: Some(32),\n \n             // see #36994\n-            exe_allocation_crate: \"alloc_system\".to_string(),\n+            exe_allocation_crate: None,\n \n             ..super::linux_base::opts()\n         },"}, {"sha": "cbf8339993c86f503ca60d0b3cd3e8885fdb6999", "filename": "src/librustc_back/target/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -29,7 +29,7 @@ pub fn target() -> TargetResult {\n             max_atomic_width: Some(32),\n \n             // see #36994\n-            exe_allocation_crate: \"alloc_system\".to_string(),\n+            exe_allocation_crate: None,\n \n             ..super::linux_base::opts()\n         },"}, {"sha": "b367bce75a1d944076f81d8716b7f47eaead6dbb", "filename": "src/librustc_back/target/mipsel_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -28,7 +28,7 @@ pub fn target() -> TargetResult {\n             max_atomic_width: Some(32),\n \n             // see #36994\n-            exe_allocation_crate: \"alloc_system\".to_string(),\n+            exe_allocation_crate: None,\n \n             ..super::linux_base::opts()\n         }"}, {"sha": "686dfbe987d10e3d90f6f9fc4009a98aae2b33c0", "filename": "src/librustc_back/target/mipsel_unknown_linux_uclibc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -29,7 +29,7 @@ pub fn target() -> TargetResult {\n             max_atomic_width: Some(32),\n \n             // see #36994\n-            exe_allocation_crate: \"alloc_system\".to_string(),\n+            exe_allocation_crate: None,\n \n             ..super::linux_base::opts()\n         },"}, {"sha": "983a98e350c6aaedf3344ac83e2c11b7eecd7fd0", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -378,9 +378,8 @@ pub struct TargetOptions {\n     /// `eh_unwind_resume` lang item.\n     pub custom_unwind_resume: bool,\n \n-    /// Default crate for allocation symbols to link against\n-    pub lib_allocation_crate: String,\n-    pub exe_allocation_crate: String,\n+    /// If necessary, a different crate to link exe allocators by default\n+    pub exe_allocation_crate: Option<String>,\n \n     /// Flag indicating whether ELF TLS (e.g. #[thread_local]) is available for\n     /// this target.\n@@ -457,8 +456,7 @@ impl Default for TargetOptions {\n             link_env: Vec::new(),\n             archive_format: \"gnu\".to_string(),\n             custom_unwind_resume: false,\n-            lib_allocation_crate: \"alloc_system\".to_string(),\n-            exe_allocation_crate: \"alloc_system\".to_string(),\n+            exe_allocation_crate: None,\n             allow_asm: true,\n             has_elf_tls: false,\n             obj_is_bitcode: false,\n@@ -682,8 +680,7 @@ impl Target {\n         key!(archive_format);\n         key!(allow_asm, bool);\n         key!(custom_unwind_resume, bool);\n-        key!(lib_allocation_crate);\n-        key!(exe_allocation_crate);\n+        key!(exe_allocation_crate, optional);\n         key!(has_elf_tls, bool);\n         key!(obj_is_bitcode, bool);\n         key!(no_integrated_as, bool);\n@@ -869,7 +866,6 @@ impl ToJson for Target {\n         target_option_val!(archive_format);\n         target_option_val!(allow_asm);\n         target_option_val!(custom_unwind_resume);\n-        target_option_val!(lib_allocation_crate);\n         target_option_val!(exe_allocation_crate);\n         target_option_val!(has_elf_tls);\n         target_option_val!(obj_is_bitcode);\n@@ -889,10 +885,10 @@ impl ToJson for Target {\n     }\n }\n \n-fn maybe_jemalloc() -> String {\n+fn maybe_jemalloc() -> Option<String> {\n     if cfg!(feature = \"jemalloc\") {\n-        \"alloc_jemalloc\".to_string()\n+        Some(\"alloc_jemalloc\".to_string())\n     } else {\n-        \"alloc_system\".to_string()\n+        None\n     }\n }"}, {"sha": "051028d5c4a7752840887313af6e8fc6762c300e", "filename": "src/librustc_back/target/openbsd_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -34,7 +34,6 @@ pub fn opts() -> TargetOptions {\n         is_like_openbsd: true,\n         pre_link_args: args,\n         position_independent_executables: true,\n-        exe_allocation_crate: \"alloc_system\".to_string(),\n         .. Default::default()\n     }\n }"}, {"sha": "718a79a685e066b066b645b33464678c1f54e4e6", "filename": "src/librustc_back/target/powerpc64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -18,7 +18,7 @@ pub fn target() -> TargetResult {\n     base.max_atomic_width = Some(64);\n \n     // see #36994\n-    base.exe_allocation_crate = \"alloc_system\".to_string();\n+    base.exe_allocation_crate = None;\n \n     Ok(Target {\n         llvm_target: \"powerpc64-unknown-linux-gnu\".to_string(),"}, {"sha": "5b50b96837fbe27a7ece78477d084a0005e2f098", "filename": "src/librustc_back/target/powerpc64le_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -18,7 +18,7 @@ pub fn target() -> TargetResult {\n     base.max_atomic_width = Some(64);\n \n     // see #36994\n-    base.exe_allocation_crate = \"alloc_system\".to_string();\n+    base.exe_allocation_crate = None;\n \n     Ok(Target {\n         llvm_target: \"powerpc64le-unknown-linux-gnu\".to_string(),"}, {"sha": "8d4ad5f0b447f87d163eb1fdddaed1cbc1a7a101", "filename": "src/librustc_back/target/powerpc_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -17,7 +17,7 @@ pub fn target() -> TargetResult {\n     base.max_atomic_width = Some(32);\n \n     // see #36994\n-    base.exe_allocation_crate = \"alloc_system\".to_string();\n+    base.exe_allocation_crate = None;\n \n     Ok(Target {\n         llvm_target: \"powerpc-unknown-linux-gnu\".to_string(),"}, {"sha": "2eae0a1240823c0553cf64f4dd97a02f5dacda17", "filename": "src/librustc_back/target/redox_base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -36,8 +36,6 @@ pub fn opts() -> TargetOptions {\n         eliminate_frame_pointer: false,\n         target_family: None,\n         linker_is_gnu: true,\n-        lib_allocation_crate: \"alloc_system\".to_string(),\n-        exe_allocation_crate: \"alloc_system\".to_string(),\n         has_elf_tls: true,\n         panic_strategy: PanicStrategy::Abort,\n         .. Default::default()"}, {"sha": "78a6bb7933d9539c6637b21a1fce2c8f828b2032", "filename": "src/librustc_back/target/s390x_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fs390x_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fs390x_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fs390x_unknown_linux_gnu.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -21,7 +21,7 @@ pub fn target() -> TargetResult {\n     base.features = \"-vector\".to_string();\n     base.max_atomic_width = Some(64);\n     // see #36994\n-    base.exe_allocation_crate = \"alloc_system\".to_string();\n+    base.exe_allocation_crate = None;\n \n     Ok(Target {\n         llvm_target: \"s390x-unknown-linux-gnu\".to_string(),"}, {"sha": "7f710ad402053cef9b9befe426461125a7819e93", "filename": "src/librustc_back/target/sparc64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fsparc64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fsparc64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fsparc64_unknown_linux_gnu.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -15,7 +15,7 @@ pub fn target() -> TargetResult {\n     let mut base = super::linux_base::opts();\n     base.cpu = \"v9\".to_string();\n     base.max_atomic_width = Some(64);\n-    base.exe_allocation_crate = \"alloc_system\".to_string();\n+    base.exe_allocation_crate = None;\n \n     Ok(Target {\n         llvm_target: \"sparc64-unknown-linux-gnu\".to_string(),"}, {"sha": "c07321e418e64eb5ebf3a4b07f556533591357f8", "filename": "src/librustc_back/target/windows_msvc_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -63,7 +63,6 @@ pub fn opts() -> TargetOptions {\n         is_like_windows: true,\n         is_like_msvc: true,\n         pre_link_args: args,\n-        exe_allocation_crate: \"alloc_system\".to_string(),\n \n         .. Default::default()\n     }"}, {"sha": "ec5cc197dfc1a642582759e123d61d213180a573", "filename": "src/librustc_back/target/x86_64_rumprun_netbsd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -24,7 +24,7 @@ pub fn target() -> TargetResult {\n     base.position_independent_executables = false;\n     base.disable_redzone = true;\n     base.no_default_libraries = false;\n-    base.exe_allocation_crate = \"alloc_system\".to_string();\n+    base.exe_allocation_crate = None;\n \n     Ok(Target {\n         llvm_target: \"x86_64-rumprun-netbsd\".to_string(),"}, {"sha": "def72752389e9cd7f1d1904b3be30745d606eaba", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -15,6 +15,7 @@ log = { version = \"0.3\", features = [\"release_max_level_info\"] }\n env_logger = { version = \"0.4\", default-features = false }\n proc_macro_plugin = { path = \"../libproc_macro_plugin\" }\n rustc = { path = \"../librustc\" }\n+rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_borrowck = { path = \"../librustc_borrowck\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }"}, {"sha": "daa5917cf324db580989f03881579d386a0e3899", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -27,6 +27,7 @@ use rustc::traits;\n use rustc::util::common::{ErrorReported, time};\n use rustc::util::nodemap::NodeSet;\n use rustc::util::fs::rename_or_copy_remove;\n+use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n use rustc_incremental::{self, IncrementalHashesMap};\n use rustc_resolve::{MakeGlobMap, Resolver};\n@@ -750,6 +751,13 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         });\n     }\n \n+    krate = time(time_passes, \"creating allocators\", || {\n+        allocator::expand::modify(&sess.parse_sess,\n+                                  &mut resolver,\n+                                  krate,\n+                                  sess.diagnostic())\n+    });\n+\n     after_expand(&krate)?;\n \n     if sess.opts.debugging_opts.input_stats {"}, {"sha": "add827536c8771d06661e424aedbc6f03739b885", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -34,6 +34,7 @@ extern crate graphviz;\n extern crate env_logger;\n extern crate libc;\n extern crate rustc;\n+extern crate rustc_allocator;\n extern crate rustc_back;\n extern crate rustc_borrowck;\n extern crate rustc_const_eval;"}, {"sha": "02d68a41b4cc4dbfb3a524522905999a4c1e5ae3", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -1071,7 +1071,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemFn(.., ref generics, _) => {\n-                if attr::contains_name(&it.attrs, \"no_mangle\") {\n+                if attr::contains_name(&it.attrs, \"no_mangle\") &&\n+                   !attr::contains_name(&it.attrs, \"linkage\") {\n                     if !cx.access_levels.is_reachable(it.id) {\n                         let msg = format!(\"function {} is marked #[no_mangle], but not exported\",\n                                           it.name);"}, {"sha": "9f0ee95b5a60e93de74a22bfe9521e14e170b5f2", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -698,6 +698,7 @@ extern \"C\" {\n     pub fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n     pub fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n     pub fn LLVMRustGetNamedValue(M: ModuleRef, Name: *const c_char) -> ValueRef;\n+    pub fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n \n     // Operations on functions\n     pub fn LLVMAddFunction(M: ModuleRef, Name: *const c_char, FunctionTy: TypeRef) -> ValueRef;"}, {"sha": "087c3162119432a60af7000c58fd7c654dd11c09", "filename": "src/librustc_lsan/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_lsan%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_lsan%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lsan%2FCargo.toml?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -14,5 +14,6 @@ build_helper = { path = \"../build_helper\" }\n cmake = \"0.1.18\"\n \n [dependencies]\n+alloc = { path = \"../liballoc\" }\n alloc_system = { path = \"../liballoc_system\" }\n core = { path = \"../libcore\" }"}, {"sha": "e987b1f335e19c3b711a943e0f1f8e2205f8b9d6", "filename": "src/librustc_lsan/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_lsan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_lsan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lsan%2Flib.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -11,10 +11,19 @@\n #![sanitizer_runtime]\n #![feature(sanitizer_runtime)]\n #![feature(alloc_system)]\n+#![cfg_attr(not(stage0), feature(allocator_api))]\n+#![cfg_attr(not(stage0), feature(global_allocator))]\n #![feature(staged_api)]\n #![no_std]\n #![unstable(feature = \"sanitizer_runtime_lib\",\n             reason = \"internal implementation detail of sanitizers\",\n             issue = \"0\")]\n \n extern crate alloc_system;\n+\n+#[cfg(not(stage0))]\n+use alloc_system::System;\n+\n+#[cfg(not(stage0))]\n+#[global_allocator]\n+static ALLOC: System = System;"}, {"sha": "ac39da48ac1fc3ce8798359eae3947b2933953cf", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 138, "deletions": 54, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -16,6 +16,7 @@ use schema::{CrateRoot, Tracked};\n \n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::svh::Svh;\n+use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::DepKind;\n use rustc::session::Session;\n use rustc::session::config::{Sanitizer, self};\n@@ -40,6 +41,7 @@ use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n use syntax::feature_gate::{self, GateIssue};\n use syntax::symbol::Symbol;\n+use syntax::visit;\n use syntax_pos::{Span, DUMMY_SP};\n use log;\n \n@@ -920,34 +922,28 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn inject_allocator_crate(&mut self) {\n-        // Make sure that we actually need an allocator, if none of our\n-        // dependencies need one then we definitely don't!\n-        //\n-        // Also, if one of our dependencies has an explicit allocator, then we\n-        // also bail out as we don't need to implicitly inject one.\n-        let mut needs_allocator = false;\n-        let mut found_required_allocator = false;\n+    fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n+        let has_global_allocator = has_global_allocator(krate);\n+        if has_global_allocator {\n+            self.sess.has_global_allocator.set(true);\n+        }\n+\n+        // Check to see if we actually need an allocator. This desire comes\n+        // about through the `#![needs_allocator]` attribute and is typically\n+        // written down in liballoc.\n+        let mut needs_allocator = attr::contains_name(&krate.attrs,\n+                                                      \"needs_allocator\");\n         let dep_graph = &self.sess.dep_graph;\n-        self.cstore.iter_crate_data(|cnum, data| {\n+        self.cstore.iter_crate_data(|_, data| {\n             needs_allocator = needs_allocator || data.needs_allocator(dep_graph);\n-            if data.is_allocator(dep_graph) {\n-                info!(\"{} required by rlib and is an allocator\", data.name());\n-                self.inject_dependency_if(cnum, \"an allocator\",\n-                                          &|data| data.needs_allocator(dep_graph));\n-                found_required_allocator = found_required_allocator ||\n-                    data.dep_kind.get() == DepKind::Explicit;\n-            }\n         });\n-        if !needs_allocator || found_required_allocator { return }\n+        if !needs_allocator {\n+            return\n+        }\n \n-        // At this point we've determined that we need an allocator and no\n-        // previous allocator has been activated. We look through our outputs of\n-        // crate types to see what kind of allocator types we may need.\n-        //\n-        // The main special output type here is that rlibs do **not** need an\n-        // allocator linked in (they're just object files), only final products\n-        // (exes, dylibs, staticlibs) need allocators.\n+        // At this point we've determined that we need an allocator. Let's see\n+        // if our compilation session actually needs an allocator based on what\n+        // we're emitting.\n         let mut need_lib_alloc = false;\n         let mut need_exe_alloc = false;\n         for ct in self.sess.crate_types.borrow().iter() {\n@@ -960,44 +956,132 @@ impl<'a> CrateLoader<'a> {\n                 config::CrateTypeRlib => {}\n             }\n         }\n-        if !need_lib_alloc && !need_exe_alloc { return }\n+        if !need_lib_alloc && !need_exe_alloc {\n+            return\n+        }\n \n-        // The default allocator crate comes from the custom target spec, and we\n-        // choose between the standard library allocator or exe allocator. This\n-        // distinction exists because the default allocator for binaries (where\n-        // the world is Rust) is different than library (where the world is\n-        // likely *not* Rust).\n-        //\n-        // If a library is being produced, but we're also flagged with `-C\n-        // prefer-dynamic`, then we interpret this as a *Rust* dynamic library\n-        // is being produced so we use the exe allocator instead.\n+        // Ok, we need an allocator. Not only that but we're actually going to\n+        // create an artifact that needs one linked in. Let's go find the one\n+        // that we're going to link in.\n         //\n-        // What this boils down to is:\n-        //\n-        // * Binaries use jemalloc\n-        // * Staticlibs and Rust dylibs use system malloc\n-        // * Rust dylibs used as dependencies to rust use jemalloc\n-        let name = if need_lib_alloc && !self.sess.opts.cg.prefer_dynamic {\n-            Symbol::intern(&self.sess.target.target.options.lib_allocation_crate)\n+        // First up we check for global allocators. Look at the crate graph here\n+        // and see what's a global allocator, including if we ourselves are a\n+        // global allocator.\n+        let dep_graph = &self.sess.dep_graph;\n+        let mut global_allocator = if has_global_allocator {\n+            Some(None)\n         } else {\n-            Symbol::intern(&self.sess.target.target.options.exe_allocation_crate)\n+            None\n         };\n-        let dep_kind = DepKind::Implicit;\n-        let (cnum, data) =\n-            self.resolve_crate(&None, name, name, None, DUMMY_SP, PathKind::Crate, dep_kind);\n+        self.cstore.iter_crate_data(|_, data| {\n+            if !data.has_global_allocator(dep_graph) {\n+                return\n+            }\n+            match global_allocator {\n+                Some(Some(other_crate)) => {\n+                    self.sess.err(&format!(\"the #[global_allocator] in {} \\\n+                                            conflicts with this global \\\n+                                            allocator in: {}\",\n+                                           other_crate,\n+                                           data.name()));\n+                }\n+                Some(None) => {\n+                    self.sess.err(&format!(\"the #[global_allocator] in this \\\n+                                            crate conflicts with global \\\n+                                            allocator in: {}\", data.name()));\n+                }\n+                None => global_allocator = Some(Some(data.name())),\n+            }\n+        });\n+        if global_allocator.is_some() {\n+            self.sess.allocator_kind.set(Some(AllocatorKind::Global));\n+            return\n+        }\n+\n+        // Ok we haven't found a global allocator but we still need an\n+        // allocator. At this point we'll either fall back to the \"library\n+        // allocator\" or the \"exe allocator\" depending on a few variables. Let's\n+        // figure out which one.\n+        //\n+        // Note that here we favor linking to the \"library allocator\" as much as\n+        // possible. If we're not creating rustc's version of libstd\n+        // (need_lib_alloc and prefer_dynamic) then we select `None`, and if the\n+        // exe allocation crate doesn't exist for this target then we also\n+        // select `None`.\n+        let exe_allocation_crate =\n+            if need_lib_alloc && !self.sess.opts.cg.prefer_dynamic {\n+                None\n+            } else {\n+                self.sess.target.target.options.exe_allocation_crate.as_ref()\n+            };\n+\n+        match exe_allocation_crate {\n+            // We've determined that we're injecting an \"exe allocator\" which\n+            // means that we're going to load up a whole new crate. An example\n+            // of this is that we're producing a normal binary on Linux which\n+            // means we need to load the `alloc_jemalloc` crate to link as an\n+            // allocator.\n+            Some(krate) => {\n+                self.sess.allocator_kind.set(Some(AllocatorKind::DefaultExe));\n+                let name = Symbol::intern(krate);\n+                let dep_kind = DepKind::Implicit;\n+                let (cnum, _data) =\n+                    self.resolve_crate(&None,\n+                                       name,\n+                                       name,\n+                                       None,\n+                                       DUMMY_SP,\n+                                       PathKind::Crate, dep_kind);\n+                self.sess.injected_allocator.set(Some(cnum));\n+            //     self.cstore.iter_crate_data(|_, data| {\n+            //         if !data.needs_allocator(dep_graph) {\n+            //             return\n+            //         }\n+            //         data.cnum_map.borrow_mut().push(cnum);\n+            //     });\n+            }\n \n-        // Sanity check the crate we loaded to ensure that it is indeed an\n-        // allocator.\n-        if !data.is_allocator(dep_graph) {\n-            self.sess.err(&format!(\"the allocator crate `{}` is not tagged \\\n-                                    with #![allocator]\", data.name()));\n+            // We're not actually going to inject an allocator, we're going to\n+            // require that something in our crate graph is the default lib\n+            // allocator. This is typically libstd, so this'll rarely be an\n+            // error.\n+            None => {\n+                self.sess.allocator_kind.set(Some(AllocatorKind::DefaultLib));\n+                let mut found_lib_allocator =\n+                    attr::contains_name(&krate.attrs, \"default_lib_allocator\");\n+                self.cstore.iter_crate_data(|_, data| {\n+                    if !found_lib_allocator {\n+                        if data.has_default_lib_allocator(dep_graph) {\n+                            found_lib_allocator = true;\n+                        }\n+                    }\n+                });\n+                if found_lib_allocator {\n+                    return\n+                }\n+                self.sess.err(\"no #[default_lib_allocator] found but one is \\\n+                               required; is libstd not linked?\");\n+            }\n         }\n \n-        self.sess.injected_allocator.set(Some(cnum));\n-        self.inject_dependency_if(cnum, \"an allocator\",\n-                                  &|data| data.needs_allocator(dep_graph));\n+        fn has_global_allocator(krate: &ast::Crate) -> bool {\n+            struct Finder(bool);\n+            let mut f = Finder(false);\n+            visit::walk_crate(&mut f, krate);\n+            return f.0;\n+\n+            impl<'ast> visit::Visitor<'ast> for Finder {\n+                fn visit_item(&mut self, i: &'ast ast::Item) {\n+                    if attr::contains_name(&i.attrs, \"global_allocator\") {\n+                        self.0 = true;\n+                    }\n+                    visit::walk_item(self, i)\n+                }\n+            }\n+        }\n     }\n \n+\n     fn inject_dependency_if(&self,\n                             krate: CrateNum,\n                             what: &str,\n@@ -1123,7 +1207,7 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n         // sanitizers force the use of the `alloc_system` allocator\n         self.inject_sanitizer_runtime();\n         self.inject_profiler_runtime();\n-        self.inject_allocator_crate();\n+        self.inject_allocator_crate(krate);\n         self.inject_panic_runtime(krate);\n \n         if log_enabled!(log::LogLevel::Info) {"}, {"sha": "fb43f91c46d7f02ff3f43af49bb1a00514aaad73", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -275,16 +275,27 @@ impl CrateMetadata {\n         self.root.disambiguator\n     }\n \n-    pub fn is_allocator(&self, dep_graph: &DepGraph) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n-        attr::contains_name(&attrs, \"allocator\")\n-    }\n-\n     pub fn needs_allocator(&self, dep_graph: &DepGraph) -> bool {\n         let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"needs_allocator\")\n     }\n \n+    pub fn has_global_allocator(&self, dep_graph: &DepGraph) -> bool {\n+        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::Krate);\n+        self.root\n+            .has_global_allocator\n+            .get(dep_graph, dep_node)\n+            .clone()\n+    }\n+\n+    pub fn has_default_lib_allocator(&self, dep_graph: &DepGraph) -> bool {\n+        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::Krate);\n+        self.root\n+            .has_default_lib_allocator\n+            .get(dep_graph, dep_node)\n+            .clone()\n+    }\n+\n     pub fn is_panic_runtime(&self, dep_graph: &DepGraph) -> bool {\n         let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"panic_runtime\")"}, {"sha": "35ce993d33557614cbf3682e39ea79b504234253", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -134,7 +134,6 @@ provide! { <'tcx> tcx, def_id, cdata,\n     is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n \n     dylib_dependency_formats => { Rc::new(cdata.get_dylib_dependency_formats(&tcx.dep_graph)) }\n-    is_allocator => { cdata.is_allocator(&tcx.dep_graph) }\n     is_panic_runtime => { cdata.is_panic_runtime(&tcx.dep_graph) }\n     extern_crate => { Rc::new(cdata.extern_crate.get()) }\n }"}, {"sha": "47f586ac895290126577448126a9871a407b4164", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -400,12 +400,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let tcx = self.tcx;\n         let link_meta = self.link_meta;\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeProcMacro);\n+        let has_default_lib_allocator =\n+            attr::contains_name(tcx.hir.krate_attrs(), \"default_lib_allocator\");\n+        let has_global_allocator = tcx.sess.has_global_allocator.get();\n         let root = self.lazy(&CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n             triple: tcx.sess.opts.target_triple.clone(),\n             hash: link_meta.crate_hash,\n             disambiguator: tcx.sess.local_crate_disambiguator(),\n             panic_strategy: Tracked::new(tcx.sess.panic_strategy()),\n+            has_global_allocator: Tracked::new(has_global_allocator),\n+            has_default_lib_allocator: Tracked::new(has_default_lib_allocator),\n             plugin_registrar_fn: tcx.sess\n                 .plugin_registrar_fn\n                 .get()"}, {"sha": "0b670121ba23b38f2a7318d7286ff9db8943762f", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -243,6 +243,8 @@ pub struct CrateRoot {\n     pub hash: hir::svh::Svh,\n     pub disambiguator: Symbol,\n     pub panic_strategy: Tracked<PanicStrategy>,\n+    pub has_global_allocator: Tracked<bool>,\n+    pub has_default_lib_allocator: Tracked<bool>,\n     pub plugin_registrar_fn: Option<DefIndex>,\n     pub macro_derive_registrar: Option<DefIndex>,\n "}, {"sha": "8d7279b29eb552db3ac95907a5926334d7044e97", "filename": "src/librustc_msan/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_msan%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_msan%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_msan%2FCargo.toml?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -14,5 +14,6 @@ build_helper = { path = \"../build_helper\" }\n cmake = \"0.1.18\"\n \n [dependencies]\n+alloc = { path = \"../liballoc\" }\n alloc_system = { path = \"../liballoc_system\" }\n core = { path = \"../libcore\" }"}, {"sha": "e987b1f335e19c3b711a943e0f1f8e2205f8b9d6", "filename": "src/librustc_msan/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_msan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_msan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_msan%2Flib.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -11,10 +11,19 @@\n #![sanitizer_runtime]\n #![feature(sanitizer_runtime)]\n #![feature(alloc_system)]\n+#![cfg_attr(not(stage0), feature(allocator_api))]\n+#![cfg_attr(not(stage0), feature(global_allocator))]\n #![feature(staged_api)]\n #![no_std]\n #![unstable(feature = \"sanitizer_runtime_lib\",\n             reason = \"internal implementation detail of sanitizers\",\n             issue = \"0\")]\n \n extern crate alloc_system;\n+\n+#[cfg(not(stage0))]\n+use alloc_system::System;\n+\n+#[cfg(not(stage0))]\n+#[global_allocator]\n+static ALLOC: System = System;"}, {"sha": "c7db2a9a8ae7ddaa86f5364a3257dd88895cd790", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -17,6 +17,7 @@ log = \"0.3\"\n owning_ref = \"0.3.3\"\n rustc-demangle = \"0.1.4\"\n rustc = { path = \"../librustc\" }\n+rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }"}, {"sha": "9abb6d66f9c0f6f210f9770c7540931bb4929899", "filename": "src/librustc_trans/allocator.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_trans%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_trans%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fallocator.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,117 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ffi::CString;\n+use std::ptr;\n+\n+use libc::c_uint;\n+use rustc::middle::allocator::AllocatorKind;\n+use rustc::ty::TyCtxt;\n+use rustc_allocator::{ALLOCATOR_METHODS, AllocatorTy};\n+\n+use ModuleLlvm;\n+use llvm::{self, False, True};\n+\n+pub unsafe fn trans(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind) {\n+    let llcx = mods.llcx;\n+    let llmod = mods.llmod;\n+    let usize = match &tcx.sess.target.target.target_pointer_width[..] {\n+        \"16\" => llvm::LLVMInt16TypeInContext(llcx),\n+        \"32\" => llvm::LLVMInt32TypeInContext(llcx),\n+        \"64\" => llvm::LLVMInt64TypeInContext(llcx),\n+        tws => bug!(\"Unsupported target word size for int: {}\", tws),\n+    };\n+    let i8 = llvm::LLVMInt8TypeInContext(llcx);\n+    let i8p = llvm::LLVMPointerType(i8, 0);\n+    let usizep = llvm::LLVMPointerType(usize, 0);\n+    let void = llvm::LLVMVoidTypeInContext(llcx);\n+\n+    for method in ALLOCATOR_METHODS {\n+        let mut args = Vec::new();\n+        for ty in method.inputs.iter() {\n+            match *ty {\n+                AllocatorTy::Layout => {\n+                    args.push(usize); // size\n+                    args.push(usize); // align\n+                }\n+                AllocatorTy::LayoutRef => args.push(i8p),\n+                AllocatorTy::Ptr => args.push(i8p),\n+                AllocatorTy::AllocErr => args.push(i8p),\n+\n+                AllocatorTy::Bang |\n+                AllocatorTy::ResultExcess |\n+                AllocatorTy::ResultPtr |\n+                AllocatorTy::ResultUnit |\n+                AllocatorTy::UsizePair |\n+                AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n+            }\n+        }\n+        let output = match method.output {\n+            AllocatorTy::UsizePair => {\n+                args.push(usizep); // min\n+                args.push(usizep); // max\n+                None\n+            }\n+            AllocatorTy::Bang => None,\n+            AllocatorTy::ResultExcess => {\n+                args.push(i8p); // excess_ptr\n+                args.push(i8p); // err_ptr\n+                Some(i8p)\n+            }\n+            AllocatorTy::ResultPtr => {\n+                args.push(i8p); // err_ptr\n+                Some(i8p)\n+            }\n+            AllocatorTy::ResultUnit => Some(i8),\n+            AllocatorTy::Unit => None,\n+\n+            AllocatorTy::AllocErr |\n+            AllocatorTy::Layout |\n+            AllocatorTy::LayoutRef |\n+            AllocatorTy::Ptr => panic!(\"invalid allocator output\"),\n+        };\n+        let ty = llvm::LLVMFunctionType(output.unwrap_or(void),\n+                                        args.as_ptr(),\n+                                        args.len() as c_uint,\n+                                        False);\n+        let name = CString::new(format!(\"__rust_{}\", method.name)).unwrap();\n+        let llfn = llvm::LLVMRustGetOrInsertFunction(llmod,\n+                                                     name.as_ptr(),\n+                                                     ty);\n+\n+        let callee = CString::new(kind.fn_name(method.name)).unwrap();\n+        let callee = llvm::LLVMRustGetOrInsertFunction(llmod,\n+                                                       callee.as_ptr(),\n+                                                       ty);\n+\n+        let llbb = llvm::LLVMAppendBasicBlockInContext(llcx,\n+                                                       llfn,\n+                                                       \"entry\\0\".as_ptr() as *const _);\n+\n+        let llbuilder = llvm::LLVMCreateBuilderInContext(llcx);\n+        llvm::LLVMPositionBuilderAtEnd(llbuilder, llbb);\n+        let args = args.iter().enumerate().map(|(i, _)| {\n+            llvm::LLVMGetParam(llfn, i as c_uint)\n+        }).collect::<Vec<_>>();\n+        let ret = llvm::LLVMRustBuildCall(llbuilder,\n+                                          callee,\n+                                          args.as_ptr(),\n+                                          args.len() as c_uint,\n+                                          ptr::null_mut(),\n+                                          \"\\0\".as_ptr() as *const _);\n+        llvm::LLVMSetTailCall(ret, True);\n+        if output.is_some() {\n+            llvm::LLVMBuildRet(llbuilder, ret);\n+        } else {\n+            llvm::LLVMBuildRetVoid(llbuilder);\n+        }\n+        llvm::LLVMDisposeBuilder(llbuilder);\n+    }\n+}"}, {"sha": "6f235ae5ee049897d9cb5aa451c3759e93591605", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -55,6 +55,10 @@ pub const METADATA_MODULE_NAME: &'static str = \"crate.metadata\";\n /// match up with `METADATA_MODULE_NAME`.\n pub const METADATA_OBJ_NAME: &'static str = \"crate.metadata.o\";\n \n+// same as for metadata above, but for allocator shim\n+pub const ALLOCATOR_MODULE_NAME: &'static str = \"crate.allocator\";\n+pub const ALLOCATOR_OBJ_NAME: &'static str = \"crate.allocator.o\";\n+\n // RLIB LLVM-BYTECODE OBJECT LAYOUT\n // Version 1\n // Bytes    Data\n@@ -240,6 +244,9 @@ pub fn link_binary(sess: &Session,\n             }\n         }\n         remove(sess, &outputs.with_extension(METADATA_OBJ_NAME));\n+        if trans.allocator_module.is_some() {\n+            remove(sess, &outputs.with_extension(ALLOCATOR_OBJ_NAME));\n+        }\n     }\n \n     out_filenames\n@@ -417,11 +424,21 @@ fn link_binary_output(sess: &Session,\n         let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n         match crate_type {\n             config::CrateTypeRlib => {\n-                link_rlib(sess, Some(trans), &objects, &out_filename,\n+                link_rlib(sess,\n+                          trans,\n+                          RlibFlavor::Normal,\n+                          &objects,\n+                          outputs,\n+                          &out_filename,\n                           tmpdir.path()).build();\n             }\n             config::CrateTypeStaticlib => {\n-                link_staticlib(sess, &objects, &out_filename, tmpdir.path());\n+                link_staticlib(sess,\n+                               trans,\n+                               outputs,\n+                               &objects,\n+                               &out_filename,\n+                               tmpdir.path());\n             }\n             _ => {\n                 link_natively(sess, crate_type, &objects, &out_filename, trans,\n@@ -477,15 +494,22 @@ fn emit_metadata<'a>(sess: &'a Session, trans: &CrateTranslation, out_filename:\n     }\n }\n \n+enum RlibFlavor {\n+    Normal,\n+    StaticlibBase,\n+}\n+\n // Create an 'rlib'\n //\n // An rlib in its current incarnation is essentially a renamed .a file. The\n // rlib primarily contains the object file of the crate, but it also contains\n // all of the object files from native libraries. This is done by unzipping\n // native libraries and inserting all of the contents into this archive.\n fn link_rlib<'a>(sess: &'a Session,\n-                 trans: Option<&CrateTranslation>, // None == no metadata/bytecode\n+                 trans: &CrateTranslation,\n+                 flavor: RlibFlavor,\n                  objects: &[PathBuf],\n+                 outputs: &OutputFilenames,\n                  out_filename: &Path,\n                  tmpdir: &Path) -> ArchiveBuilder<'a> {\n     info!(\"preparing rlib from {:?} to {:?}\", objects, out_filename);\n@@ -546,8 +570,8 @@ fn link_rlib<'a>(sess: &'a Session,\n     //\n     // Basically, all this means is that this code should not move above the\n     // code above.\n-    match trans {\n-        Some(trans) => {\n+    match flavor {\n+        RlibFlavor::Normal => {\n             // Instead of putting the metadata in an object file section, rlibs\n             // contain the metadata in a separate file. We use a temp directory\n             // here so concurrent builds in the same directory don't try to use\n@@ -620,7 +644,11 @@ fn link_rlib<'a>(sess: &'a Session,\n             }\n         }\n \n-        None => {}\n+        RlibFlavor::StaticlibBase => {\n+            if trans.allocator_module.is_some() {\n+                ab.add_file(&outputs.with_extension(ALLOCATOR_OBJ_NAME));\n+            }\n+        }\n     }\n \n     ab\n@@ -672,9 +700,19 @@ fn write_rlib_bytecode_object_v1(writer: &mut Write,\n // There's no need to include metadata in a static archive, so ensure to not\n // link in the metadata object file (and also don't prepare the archive with a\n // metadata file).\n-fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n+fn link_staticlib(sess: &Session,\n+                  trans: &CrateTranslation,\n+                  outputs: &OutputFilenames,\n+                  objects: &[PathBuf],\n+                  out_filename: &Path,\n                   tempdir: &Path) {\n-    let mut ab = link_rlib(sess, None, objects, out_filename, tempdir);\n+    let mut ab = link_rlib(sess,\n+                           trans,\n+                           RlibFlavor::StaticlibBase,\n+                           objects,\n+                           outputs,\n+                           out_filename,\n+                           tempdir);\n     let mut all_native_libs = vec![];\n \n     let res = each_linked_rlib(sess, &mut |cnum, path| {\n@@ -944,6 +982,10 @@ fn link_args(cmd: &mut Linker,\n         cmd.add_object(&outputs.with_extension(METADATA_OBJ_NAME));\n     }\n \n+    if trans.allocator_module.is_some() {\n+        cmd.add_object(&outputs.with_extension(ALLOCATOR_OBJ_NAME));\n+    }\n+\n     // Try to strip as much out of the generated object by removing unused\n     // sections if possible. See more comments in linker.rs\n     if !sess.opts.cg.link_dead_code {"}, {"sha": "52fe747858cc4ba26af551cdbafd13c03ee33b34", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -92,7 +92,6 @@ impl ExportedSymbols {\n             // Down below we'll hardwire all of the symbols to the `Rust` export\n             // level instead.\n             let special_runtime_crate =\n-                scx.tcx().is_allocator(cnum.as_def_id()) ||\n                 scx.tcx().is_panic_runtime(cnum.as_def_id()) ||\n                 scx.sess().cstore.is_compiler_builtins(cnum);\n "}, {"sha": "0c233dfe109bc3b86a654eb3ffe0a650da41ba1a", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -644,6 +644,7 @@ pub fn run_passes(sess: &Session,\n \n     let mut modules_config = ModuleConfig::new(tm, sess.opts.cg.passes.clone());\n     let mut metadata_config = ModuleConfig::new(tm, vec![]);\n+    let mut allocator_config = ModuleConfig::new(tm, vec![]);\n \n     if let Some(ref sanitizer) = sess.opts.debugging_opts.sanitizer {\n         match *sanitizer {\n@@ -674,6 +675,7 @@ pub fn run_passes(sess: &Session,\n         modules_config.emit_bc = true;\n         modules_config.emit_lto_bc = true;\n         metadata_config.emit_bc = true;\n+        allocator_config.emit_bc = true;\n     }\n \n     // Emit bitcode files for the crate if we're emitting an rlib.\n@@ -699,13 +701,15 @@ pub fn run_passes(sess: &Session,\n                 // in this case we still want the metadata object file.\n                 if !sess.opts.output_types.contains_key(&OutputType::Assembly) {\n                     metadata_config.emit_obj = true;\n+                    allocator_config.emit_obj = true;\n                 }\n             }\n             OutputType::Object => { modules_config.emit_obj = true; }\n             OutputType::Metadata => { metadata_config.emit_obj = true; }\n             OutputType::Exe => {\n                 modules_config.emit_obj = true;\n                 metadata_config.emit_obj = true;\n+                allocator_config.emit_obj = true;\n             },\n             OutputType::Mir => {}\n             OutputType::DepInfo => {}\n@@ -714,6 +718,7 @@ pub fn run_passes(sess: &Session,\n \n     modules_config.set_flags(sess, trans);\n     metadata_config.set_flags(sess, trans);\n+    allocator_config.set_flags(sess, trans);\n \n \n     // Populate a buffer with a list of codegen threads.  Items are processed in\n@@ -729,6 +734,14 @@ pub fn run_passes(sess: &Session,\n         work_items.push(work);\n     }\n \n+    if let Some(allocator) = trans.allocator_module.clone() {\n+        let work = build_work_item(sess,\n+                                   allocator,\n+                                   allocator_config.clone(),\n+                                   crate_output.clone());\n+        work_items.push(work);\n+    }\n+\n     for mtrans in trans.modules.iter() {\n         let work = build_work_item(sess,\n                                    mtrans.clone(),\n@@ -905,6 +918,13 @@ pub fn run_passes(sess: &Session,\n                                               Some(&trans.metadata_module.name));\n             remove(sess, &path);\n         }\n+        if allocator_config.emit_bc && !user_wants_bitcode {\n+            if let Some(ref module) = trans.allocator_module {\n+                let path = crate_output.temp_path(OutputType::Bitcode,\n+                                                  Some(&module.name));\n+                remove(sess, &path);\n+            }\n+        }\n     }\n \n     // We leave the following files around by default:"}, {"sha": "8298324e9968089749c5d802161b9613090656b2", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -47,6 +47,7 @@ use rustc::session::config::{self, NoDebugInfo, OutputFilenames};\n use rustc::session::Session;\n use rustc_incremental::IncrementalHashesMap;\n use abi;\n+use allocator;\n use mir::lvalue::LvalueRef;\n use attributes;\n use builder::Builder;\n@@ -1086,8 +1087,10 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             llmod: metadata_llmod,\n         }),\n     };\n+\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n+\n     // Skip crate items and just output metadata in -Z no-trans mode.\n     if tcx.sess.opts.debugging_opts.no_trans ||\n        !tcx.sess.opts.output_types.should_trans() {\n@@ -1097,6 +1100,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             crate_name: tcx.crate_name(LOCAL_CRATE),\n             modules: vec![],\n             metadata_module: metadata_module,\n+            allocator_module: None,\n             link: link_meta,\n             metadata: metadata,\n             exported_symbols: empty_exported_symbols,\n@@ -1296,6 +1300,41 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         create_imps(sess, &llvm_modules);\n     }\n \n+    // Translate an allocator shim, if any\n+    //\n+    // If LTO is enabled and we've got some previous LLVM module we translated\n+    // above, then we can just translate directly into that LLVM module. If not,\n+    // however, we need to create a separate module and trans into that. Note\n+    // that the separate translation is critical for the standard library where\n+    // the rlib's object file doesn't have allocator functions but the dylib\n+    // links in an object file that has allocator functions. When we're\n+    // compiling a final LTO artifact, though, there's no need to worry about\n+    // this as we're not working with this dual \"rlib/dylib\" functionality.\n+    let allocator_module = tcx.sess.allocator_kind.get().and_then(|kind| unsafe {\n+        if sess.lto() && llvm_modules.len() > 0 {\n+            time(tcx.sess.time_passes(), \"write allocator module\", || {\n+                allocator::trans(tcx, &llvm_modules[0], kind)\n+            });\n+            None\n+        } else {\n+            let (llcx, llmod) =\n+                context::create_context_and_module(tcx.sess, \"allocator\");\n+            let modules = ModuleLlvm {\n+                llmod: llmod,\n+                llcx: llcx,\n+            };\n+            time(tcx.sess.time_passes(), \"write allocator module\", || {\n+                allocator::trans(tcx, &modules, kind)\n+            });\n+\n+            Some(ModuleTranslation {\n+                name: link::ALLOCATOR_MODULE_NAME.to_string(),\n+                symbol_name_hash: 0, // we always rebuild allocator shims\n+                source: ModuleSource::Translated(modules),\n+            })\n+        }\n+    });\n+\n     let linker_info = LinkerInfo::new(&shared_ccx, &exported_symbols);\n \n     let subsystem = attr::first_attr_value_str_by_name(&krate.attrs,\n@@ -1313,6 +1352,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         crate_name: tcx.crate_name(LOCAL_CRATE),\n         modules: modules,\n         metadata_module: metadata_module,\n+        allocator_module: allocator_module,\n         link: link_meta,\n         metadata: metadata,\n         exported_symbols: exported_symbols,"}, {"sha": "5c76f778f8d63610553bd35a36eadc57e2d684e8", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -43,6 +43,7 @@ extern crate crossbeam;\n extern crate libc;\n extern crate owning_ref;\n #[macro_use] extern crate rustc;\n+extern crate rustc_allocator;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n extern crate rustc_incremental;\n@@ -84,6 +85,7 @@ mod diagnostics;\n \n mod abi;\n mod adt;\n+mod allocator;\n mod asm;\n mod assert_module_sources;\n mod attributes;\n@@ -163,6 +165,7 @@ pub struct CrateTranslation {\n     pub crate_name: Symbol,\n     pub modules: Vec<ModuleTranslation>,\n     pub metadata_module: ModuleTranslation,\n+    pub allocator_module: Option<ModuleTranslation>,\n     pub link: rustc::middle::cstore::LinkMeta,\n     pub metadata: rustc::middle::cstore::EncodedMetadata,\n     pub exported_symbols: back::symbol_export::ExportedSymbols,"}, {"sha": "06f4f7643ec830a57e9536a26fbb5fa97eb4aecf", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::heap::{allocate, deallocate};\n+use alloc::heap::{Heap, Alloc, Layout};\n \n use cmp;\n use hash::{BuildHasher, Hash, Hasher};\n@@ -781,10 +781,8 @@ impl<K, V> RawTable<K, V> {\n                     .expect(\"capacity overflow\"),\n                 \"capacity overflow\");\n \n-        let buffer = allocate(size, alignment);\n-        if buffer.is_null() {\n-            ::alloc::oom()\n-        }\n+        let buffer = Heap.alloc(Layout::from_size_align(size, alignment).unwrap())\n+            .unwrap_or_else(|e| Heap.oom(e));\n \n         let hashes = buffer.offset(hash_offset as isize) as *mut HashUint;\n \n@@ -1193,7 +1191,8 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n         debug_assert!(!oflo, \"should be impossible\");\n \n         unsafe {\n-            deallocate(self.hashes.ptr() as *mut u8, size, align);\n+            Heap.dealloc(self.hashes.ptr() as *mut u8,\n+                         Layout::from_size_align(size, align).unwrap());\n             // Remember how everything was allocated out of one buffer\n             // during initialization? We only need one call to free here.\n         }"}, {"sha": "d77f817659c566917f8e5548e1528fa8c02358fc", "filename": "src/libstd/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -224,7 +224,7 @@ impl Error for ! {\n \n #[unstable(feature = \"allocator_api\",\n            reason = \"the precise API and guarantees it provides may be tweaked.\",\n-           issue = \"27700\")]\n+           issue = \"32838\")]\n impl Error for allocator::AllocErr {\n     fn description(&self) -> &str {\n         allocator::AllocErr::description(self)\n@@ -233,7 +233,7 @@ impl Error for allocator::AllocErr {\n \n #[unstable(feature = \"allocator_api\",\n            reason = \"the precise API and guarantees it provides may be tweaked.\",\n-           issue = \"27700\")]\n+           issue = \"32838\")]\n impl Error for allocator::CannotReallocInPlace {\n     fn description(&self) -> &str {\n         allocator::CannotReallocInPlace::description(self)"}, {"sha": "83bd3b04b4de2439e80da4011bb9cabb682349ee", "filename": "src/libstd/heap.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibstd%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibstd%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fheap.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,165 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! dox\n+\n+#![unstable(issue = \"32838\", feature = \"allocator_api\")]\n+\n+pub use alloc::heap::{Heap, Alloc, Layout, Excess, CannotReallocInPlace, AllocErr};\n+#[cfg(not(stage0))]\n+pub use alloc_system::System;\n+\n+#[cfg(all(not(stage0), not(test)))]\n+#[doc(hidden)]\n+pub mod __default_lib_allocator {\n+    use super::{System, Layout, Alloc, AllocErr};\n+    use ptr;\n+\n+    // for symbol names src/librustc/middle/allocator.rs\n+    // for signatures src/librustc_allocator/lib.rs\n+\n+    // linkage directives are provided as part of the current compiler allocator\n+    // ABI\n+\n+    #[no_mangle]\n+    pub unsafe extern fn __rdl_alloc(size: usize,\n+                                     align: usize,\n+                                     err: *mut u8) -> *mut u8 {\n+        let layout = Layout::from_size_align_unchecked(size, align);\n+        match System.alloc(layout) {\n+            Ok(p) => p,\n+            Err(e) => {\n+                ptr::write(err as *mut AllocErr, e);\n+                0 as *mut u8\n+            }\n+        }\n+    }\n+\n+    #[no_mangle]\n+    pub unsafe extern fn __rdl_oom(err: *const u8) -> ! {\n+        System.oom((*(err as *const AllocErr)).clone())\n+    }\n+\n+    #[no_mangle]\n+    pub unsafe extern fn __rdl_dealloc(ptr: *mut u8,\n+                                       size: usize,\n+                                       align: usize) {\n+        System.dealloc(ptr, Layout::from_size_align_unchecked(size, align))\n+    }\n+\n+    #[no_mangle]\n+    pub unsafe extern fn __rdl_usable_size(layout: *const u8,\n+                                           min: *mut usize,\n+                                           max: *mut usize) {\n+        let pair = System.usable_size(&*(layout as *const Layout));\n+        *min = pair.0;\n+        *max = pair.1;\n+    }\n+\n+    #[no_mangle]\n+    pub unsafe extern fn __rdl_realloc(ptr: *mut u8,\n+                                       old_size: usize,\n+                                       old_align: usize,\n+                                       new_size: usize,\n+                                       new_align: usize,\n+                                       err: *mut u8) -> *mut u8 {\n+        let old_layout = Layout::from_size_align_unchecked(old_size, old_align);\n+        let new_layout = Layout::from_size_align_unchecked(new_size, new_align);\n+        match System.realloc(ptr, old_layout, new_layout) {\n+            Ok(p) => p,\n+            Err(e) => {\n+                ptr::write(err as *mut AllocErr, e);\n+                0 as *mut u8\n+            }\n+        }\n+    }\n+\n+    #[no_mangle]\n+    pub unsafe extern fn __rdl_alloc_zeroed(size: usize,\n+                                            align: usize,\n+                                            err: *mut u8) -> *mut u8 {\n+        let layout = Layout::from_size_align_unchecked(size, align);\n+        match System.alloc_zeroed(layout) {\n+            Ok(p) => p,\n+            Err(e) => {\n+                ptr::write(err as *mut AllocErr, e);\n+                0 as *mut u8\n+            }\n+        }\n+    }\n+\n+    #[no_mangle]\n+    pub unsafe extern fn __rdl_alloc_excess(size: usize,\n+                                            align: usize,\n+                                            excess: *mut usize,\n+                                            err: *mut u8) -> *mut u8 {\n+        let layout = Layout::from_size_align_unchecked(size, align);\n+        match System.alloc_excess(layout) {\n+            Ok(p) => {\n+                *excess = p.1;\n+                p.0\n+            }\n+            Err(e) => {\n+                ptr::write(err as *mut AllocErr, e);\n+                0 as *mut u8\n+            }\n+        }\n+    }\n+\n+    #[no_mangle]\n+    pub unsafe extern fn __rdl_realloc_excess(ptr: *mut u8,\n+                                              old_size: usize,\n+                                              old_align: usize,\n+                                              new_size: usize,\n+                                              new_align: usize,\n+                                              excess: *mut usize,\n+                                              err: *mut u8) -> *mut u8 {\n+        let old_layout = Layout::from_size_align_unchecked(old_size, old_align);\n+        let new_layout = Layout::from_size_align_unchecked(new_size, new_align);\n+        match System.realloc_excess(ptr, old_layout, new_layout) {\n+            Ok(p) => {\n+                *excess = p.1;\n+                p.0\n+            }\n+            Err(e) => {\n+                ptr::write(err as *mut AllocErr, e);\n+                0 as *mut u8\n+            }\n+        }\n+    }\n+\n+    #[no_mangle]\n+    pub unsafe extern fn __rdl_grow_in_place(ptr: *mut u8,\n+                                             old_size: usize,\n+                                             old_align: usize,\n+                                             new_size: usize,\n+                                             new_align: usize) -> u8 {\n+        let old_layout = Layout::from_size_align_unchecked(old_size, old_align);\n+        let new_layout = Layout::from_size_align_unchecked(new_size, new_align);\n+        match System.grow_in_place(ptr, old_layout, new_layout) {\n+            Ok(()) => 1,\n+            Err(_) => 0,\n+        }\n+    }\n+\n+    #[no_mangle]\n+    pub unsafe extern fn __rdl_shrink_in_place(ptr: *mut u8,\n+                                               old_size: usize,\n+                                               old_align: usize,\n+                                               new_size: usize,\n+                                               new_align: usize) -> u8 {\n+        let old_layout = Layout::from_size_align_unchecked(old_size, old_align);\n+        let new_layout = Layout::from_size_align_unchecked(new_size, new_align);\n+        match System.shrink_in_place(ptr, old_layout, new_layout) {\n+            Ok(()) => 1,\n+            Err(_) => 0,\n+        }\n+    }\n+}"}, {"sha": "c4bdf7c5b822b3ae15f8c0b50a4f393a4951ebc4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -230,11 +230,6 @@\n // Tell the compiler to link to either panic_abort or panic_unwind\n #![needs_panic_runtime]\n \n-// Always use alloc_system during stage0 since we don't know if the alloc_*\n-// crate the stage0 compiler will pick by default is available (most\n-// obviously, if the user has disabled jemalloc in `./configure`).\n-#![cfg_attr(any(stage0, feature = \"force_alloc_system\"), feature(alloc_system))]\n-\n // Turn warnings into errors, but only after stage0, where it can be useful for\n // code to emit warnings during language transitions\n #![deny(warnings)]\n@@ -246,6 +241,8 @@\n // compiler details that will never be stable\n #![feature(alloc)]\n #![feature(allocator_api)]\n+#![feature(alloc_system)]\n+#![feature(allocator_internals)]\n #![feature(allow_internal_unstable)]\n #![feature(asm)]\n #![feature(associated_consts)]\n@@ -322,6 +319,8 @@\n #![cfg_attr(test, feature(update_panic_count))]\n #![cfg_attr(test, feature(float_bits_conv))]\n \n+#![cfg_attr(not(stage0), default_lib_allocator)]\n+\n // Explicitly import the prelude. The compiler uses this same unstable attribute\n // to import the prelude implicitly when building crates that depend on std.\n #[prelude_import]\n@@ -342,15 +341,13 @@ extern crate core as __core;\n #[macro_use]\n #[macro_reexport(vec, format)]\n extern crate alloc;\n+extern crate alloc_system;\n extern crate std_unicode;\n extern crate libc;\n \n // We always need an unwinder currently for backtraces\n extern crate unwind;\n \n-#[cfg(any(stage0, feature = \"force_alloc_system\"))]\n-extern crate alloc_system;\n-\n // compiler-rt intrinsics\n extern crate compiler_builtins;\n \n@@ -465,6 +462,7 @@ pub mod path;\n pub mod process;\n pub mod sync;\n pub mod time;\n+pub mod heap;\n \n // Platform-abstraction modules\n #[macro_use]"}, {"sha": "46e5acdf3d22bdfd8d6216dbeb962b01849d23ec", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -59,8 +59,6 @@ pub mod stdio;\n \n #[cfg(not(test))]\n pub fn init() {\n-    use alloc::oom;\n-\n     // By default, some platforms will send a *signal* when an EPIPE error\n     // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n     // handler, causing it to kill the program, which isn't exactly what we\n@@ -72,24 +70,6 @@ pub fn init() {\n         reset_sigpipe();\n     }\n \n-    oom::set_oom_handler(oom_handler);\n-\n-    // A nicer handler for out-of-memory situations than the default one. This\n-    // one prints a message to stderr before aborting. It is critical that this\n-    // code does not allocate any memory since we are in an OOM situation. Any\n-    // errors are ignored while printing since there's nothing we can do about\n-    // them and we are about to exit anyways.\n-    fn oom_handler() -> ! {\n-        use intrinsics;\n-        let msg = \"fatal runtime error: out of memory\\n\";\n-        unsafe {\n-            libc::write(libc::STDERR_FILENO,\n-                        msg.as_ptr() as *const libc::c_void,\n-                        msg.len());\n-            intrinsics::abort();\n-        }\n-    }\n-\n     #[cfg(not(any(target_os = \"nacl\", target_os = \"emscripten\", target_os=\"fuchsia\")))]\n     unsafe fn reset_sigpipe() {\n         assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != libc::SIG_ERR);"}, {"sha": "ee58efc5144a822e77f4afde5ac57c744ef286b9", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -47,24 +47,6 @@ pub mod stdio;\n \n #[cfg(not(test))]\n pub fn init() {\n-    ::alloc::oom::set_oom_handler(oom_handler);\n-\n-    // See comment in sys/unix/mod.rs\n-    fn oom_handler() -> ! {\n-        use intrinsics;\n-        use ptr;\n-        let msg = \"fatal runtime error: out of memory\\n\";\n-        unsafe {\n-            // WriteFile silently fails if it is passed an invalid handle, so\n-            // there is no need to check the result of GetStdHandle.\n-            c::WriteFile(c::GetStdHandle(c::STD_ERROR_HANDLE),\n-                         msg.as_ptr() as c::LPVOID,\n-                         msg.len() as c::DWORD,\n-                         ptr::null_mut(),\n-                         ptr::null_mut());\n-            intrinsics::abort();\n-        }\n-    }\n }\n \n pub fn decode_error_kind(errno: i32) -> ErrorKind {"}, {"sha": "2cfb16169273f1da541037f0dfb2864f924c174e", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -249,6 +249,8 @@ pub trait AstBuilder {\n                 name: Ident, attrs: Vec<ast::Attribute>,\n                 items: Vec<P<ast::Item>>) -> P<ast::Item>;\n \n+    fn item_extern_crate(&self, span: Span, name: Ident) -> P<ast::Item>;\n+\n     fn item_static(&self,\n                    span: Span,\n                    name: Ident,\n@@ -1095,6 +1097,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         )\n     }\n \n+    fn item_extern_crate(&self, span: Span, name: Ident) -> P<ast::Item> {\n+        self.item(span, name, Vec::new(), ast::ItemKind::ExternCrate(None))\n+    }\n+\n     fn item_static(&self,\n                    span: Span,\n                    name: Ident,"}, {"sha": "0163bb3b1d05adb7a1659b7acb5b3eb5aae9c1ce", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -137,7 +137,6 @@ declare_features! (\n     (active, placement_in_syntax, \"1.0.0\", Some(27779)),\n     (active, unboxed_closures, \"1.0.0\", Some(29625)),\n \n-    (active, allocator, \"1.0.0\", Some(27389)),\n     (active, fundamental, \"1.0.0\", Some(29635)),\n     (active, main, \"1.0.0\", Some(29634)),\n     (active, needs_allocator, \"1.4.0\", Some(27389)),\n@@ -360,6 +359,10 @@ declare_features! (\n \n     // Allows unsized tuple coercion.\n     (active, unsized_tuple_coercion, \"1.20.0\", Some(42877)),\n+\n+    // global allocators and their internals\n+    (active, global_allocator, \"1.20.0\", None),\n+    (active, allocator_internals, \"1.20.0\", None),\n );\n \n declare_features! (\n@@ -379,6 +382,7 @@ declare_features! (\n     // rustc internal\n     (removed, unmarked_api, \"1.0.0\", None),\n     (removed, pushpop_unsafe, \"1.2.0\", None),\n+    (removed, allocator, \"1.0.0\", None),\n );\n \n declare_features! (\n@@ -585,16 +589,22 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                              \"the `#[rustc_on_unimplemented]` attribute \\\n                                               is an experimental feature\",\n                                              cfg_fn!(on_unimplemented))),\n-    (\"allocator\", Whitelisted, Gated(Stability::Unstable,\n-                                     \"allocator\",\n-                                     \"the `#[allocator]` attribute is an experimental feature\",\n-                                     cfg_fn!(allocator))),\n+    (\"global_allocator\", Normal, Gated(Stability::Unstable,\n+                                       \"global_allocator\",\n+                                       \"the `#[global_allocator]` attribute is \\\n+                                        an experimental feature\",\n+                                       cfg_fn!(global_allocator))),\n+    (\"default_lib_allocator\", Whitelisted, Gated(Stability::Unstable,\n+                                            \"allocator_internals\",\n+                                            \"the `#[default_lib_allocator]` \\\n+                                             attribute is an experimental feature\",\n+                                            cfg_fn!(allocator_internals))),\n     (\"needs_allocator\", Normal, Gated(Stability::Unstable,\n-                                      \"needs_allocator\",\n+                                      \"allocator_internals\",\n                                       \"the `#[needs_allocator]` \\\n                                        attribute is an experimental \\\n                                        feature\",\n-                                      cfg_fn!(needs_allocator))),\n+                                      cfg_fn!(allocator_internals))),\n     (\"panic_runtime\", Whitelisted, Gated(Stability::Unstable,\n                                          \"panic_runtime\",\n                                          \"the `#[panic_runtime]` attribute is \\"}, {"sha": "b2d4c1132951247e6a116aa5c8f6de8d96c9164e", "filename": "src/rustllvm/llvm-rebuild-trigger", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Frustllvm%2Fllvm-rebuild-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Frustllvm%2Fllvm-rebuild-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-rebuild-trigger?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -1,4 +1,8 @@\n # If this file is modified, then llvm will be (optionally) cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n+<<<<<<< 37849a002ed91ac2b80aeb2172364b4e19250e05\n 2017-06-27\n+=======\n+2017-06-26\n+>>>>>>> rustc: Implement the #[global_allocator] attribute"}, {"sha": "d8bbcd9b7328ee841d33e4c8eec79993a999ba4e", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -11,7 +11,7 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n-#![feature(allocator)]\n+#![feature(custom_attribute)]\n \n pub struct S {\n   _field: [i64; 4],"}, {"sha": "7f420ff735a3ef4d86739353f18030d879c39a3e", "filename": "src/test/compile-fail/allocator-depends-on-needs-allocators.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Fcompile-fail%2Fallocator-depends-on-needs-allocators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Fcompile-fail%2Fallocator-depends-on-needs-allocators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator-depends-on-needs-allocators.rs?ref=4c225c4d1732537aff63dd97c2b7ac681fd3d188", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: `allocator3` cannot depend on a crate that needs an allocator\n-// aux-build:needs_allocator.rs\n-// aux-build:allocator3.rs\n-\n-// The needs_allocator crate is a dependency of the allocator crate allocator3,\n-// which is not allowed\n-\n-extern crate allocator3;\n-\n-fn main() {\n-}"}, {"sha": "31009554c690d5b8657f89605a0d0ae4c245b4c5", "filename": "src/test/compile-fail/allocator-dylib-is-system.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Fcompile-fail%2Fallocator-dylib-is-system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Fcompile-fail%2Fallocator-dylib-is-system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator-dylib-is-system.rs?ref=4c225c4d1732537aff63dd97c2b7ac681fd3d188", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-musl no dylibs\n-// aux-build:allocator-dylib.rs\n-// aux-build:allocator1.rs\n-// no-prefer-dynamic\n-// error-pattern: cannot link together two allocators\n-\n-// Verify that the allocator for statically linked dynamic libraries is the\n-// system allocator. Do this by linking in jemalloc and making sure that we get\n-// an error.\n-\n-// ignore-emscripten FIXME: What \"other allocator\" should we use for emcc?\n-\n-#![feature(alloc_jemalloc)]\n-\n-extern crate allocator_dylib;\n-\n-// The main purpose of this test is to ensure that `alloc_jemalloc` **fails**\n-// here (specifically the jemalloc allocator), but currently jemalloc is\n-// disabled on quite a few platforms (bsds, emscripten, msvc, etc). To ensure\n-// that this just passes on those platforms we link in some other allocator to\n-// ensure we get the same error.\n-//\n-// So long as we CI linux/macOS we should be good.\n-#[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n-extern crate alloc_jemalloc;\n-#[cfg(not(any(target_os = \"linux\", target_os = \"macos\")))]\n-extern crate allocator1;\n-\n-fn main() {\n-    allocator_dylib::foo();\n-}"}, {"sha": "68e01bad96bb20ddb2703f0052ef2b9ee013260b", "filename": "src/test/compile-fail/allocator-rust-dylib-is-jemalloc.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Fcompile-fail%2Fallocator-rust-dylib-is-jemalloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Fcompile-fail%2Fallocator-rust-dylib-is-jemalloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator-rust-dylib-is-jemalloc.rs?ref=4c225c4d1732537aff63dd97c2b7ac681fd3d188", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-musl no dylibs\n-// aux-build:allocator-dylib2.rs\n-// aux-build:allocator1.rs\n-// error-pattern: cannot link together two allocators\n-\n-// Ensure that rust dynamic libraries use jemalloc as their allocator, verifying\n-// by linking in the system allocator here and ensuring that we get a complaint.\n-\n-// ignore-emscripten FIXME: What \"other allocator\" is correct for emscripten?\n-\n-#![feature(alloc_system)]\n-\n-extern crate allocator_dylib2;\n-\n-// The main purpose of this test is to ensure that `alloc_system` **fails**\n-// here (specifically the system allocator), but currently system is\n-// disabled on quite a few platforms (bsds, emscripten, msvc, etc). To ensure\n-// that this just passes on those platforms we link in some other allocator to\n-// ensure we get the same error.\n-//\n-// So long as we CI linux/macOS we should be good.\n-#[cfg(any(all(target_os = \"linux\", any(target_arch = \"x86\", target_arch = \"x86_64\")),\n-          target_os = \"macos\"))]\n-extern crate alloc_system;\n-#[cfg(not(any(all(target_os = \"linux\", any(target_arch = \"x86\", target_arch = \"x86_64\")),\n-              target_os = \"macos\")))]\n-extern crate allocator1;\n-\n-fn main() {\n-    allocator_dylib2::foo();\n-}"}, {"sha": "4761dc421d7f75042cb0d45b6901601436ddb467", "filename": "src/test/compile-fail/allocator/auxiliary/system-allocator.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Fallocator%2Fauxiliary%2Fsystem-allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Fallocator%2Fauxiliary%2Fsystem-allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Fauxiliary%2Fsystem-allocator.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,10 +10,10 @@\n \n // no-prefer-dynamic\n \n-#![feature(allocator)]\n-#![no_std]\n-#![allocator]\n+#![feature(global_allocator, allocator_api)]\n #![crate_type = \"rlib\"]\n \n-extern crate needs_allocator;\n+use std::heap::System;\n \n+#[global_allocator]\n+static A: System = System;", "previous_filename": "src/test/compile-fail/auxiliary/allocator3.rs"}, {"sha": "4761dc421d7f75042cb0d45b6901601436ddb467", "filename": "src/test/compile-fail/allocator/auxiliary/system-allocator2.rs", "status": "renamed", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Fallocator%2Fauxiliary%2Fsystem-allocator2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Fallocator%2Fauxiliary%2Fsystem-allocator2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Fauxiliary%2Fsystem-allocator2.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,7 +10,10 @@\n \n // no-prefer-dynamic\n \n-#![feature(allocator)]\n-#![allocator]\n+#![feature(global_allocator, allocator_api)]\n #![crate_type = \"rlib\"]\n-#![no_std]\n+\n+use std::heap::System;\n+\n+#[global_allocator]\n+static A: System = System;", "previous_filename": "src/test/compile-fail/auxiliary/allocator2.rs"}, {"sha": "50f82607b53f6c3d3789a2ad2b89329932e2e457", "filename": "src/test/compile-fail/allocator/function-allocator.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Fallocator%2Ffunction-allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Fallocator%2Ffunction-allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Ffunction-allocator.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(global_allocator)]\n+\n+#[global_allocator]\n+fn foo() {} //~ ERROR: allocators must be statics\n+\n+fn main() {}"}, {"sha": "e4301435063464613da66c09b594af45f7514215", "filename": "src/test/compile-fail/allocator/not-an-allocator.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Fallocator%2Fnot-an-allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Fallocator%2Fnot-an-allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Fnot-an-allocator.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(global_allocator, heap_api)]\n+\n+#[global_allocator]\n+static A: usize = 0;\n+//~^ the trait bound `&usize:\n+//~| the trait bound `&usize:\n+//~| the trait bound `&usize:\n+//~| the trait bound `&usize:\n+//~| the trait bound `&usize:\n+//~| the trait bound `&usize:\n+//~| the trait bound `&usize:\n+//~| the trait bound `&usize:\n+//~| the trait bound `&usize:\n+//~| the trait bound `&usize:\n+\n+fn main() {}"}, {"sha": "b46ba6334a2b43ce60552633953374157cf06b61", "filename": "src/test/compile-fail/allocator/two-allocators.rs", "status": "renamed", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: cannot link together two allocators\n+#![feature(global_allocator, allocator_api)]\n \n-// aux-build:allocator1.rs\n-// aux-build:allocator2.rs\n+use std::heap::System;\n \n-extern crate allocator1;\n-extern crate allocator2;\n+#[global_allocator]\n+static A: System = System;\n+#[global_allocator]\n+static B: System = System;\n+//~^ ERROR: cannot define more than one #[global_allocator]\n \n fn main() {}\n+", "previous_filename": "src/test/compile-fail/two-allocators.rs"}, {"sha": "e342c1f9c44e7e0357fd4979743adf8a71a3bd57", "filename": "src/test/compile-fail/allocator/two-allocators2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators2.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:system-allocator.rs\n+// no-prefer-dynamic\n+// error-pattern: the #[global_allocator] in\n+\n+#![feature(global_allocator, allocator_api)]\n+\n+extern crate system_allocator;\n+\n+use std::heap::System;\n+\n+#[global_allocator]\n+static A: System = System;\n+\n+fn main() {}\n+"}, {"sha": "c310d94f6dfd87efb23da2607fcaf7f7b4a80fe9", "filename": "src/test/compile-fail/allocator/two-allocators3.rs", "status": "renamed", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators3.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// aux-build:system-allocator.rs\n+// aux-build:system-allocator2.rs\n // no-prefer-dynamic\n+// error-pattern: the #[global_allocator] in\n \n-#![feature(alloc_system)]\n+#![feature(global_allocator)]\n \n-extern crate alloc_system;\n+extern crate system_allocator;\n+extern crate system_allocator2;\n \n-fn main() {\n-    println!(\"{:?}\", Box::new(3));\n-}\n+fn main() {}", "previous_filename": "src/test/run-pass/allocator-system.rs"}, {"sha": "b519a985ec5e7f3ed359caca12590922ae5d9f0d", "filename": "src/test/compile-fail/feature-gate-allocator_internals.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allocator_internals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allocator_internals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allocator_internals.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// no-prefer-dynamic\n+#![default_lib_allocator] //~ ERROR: attribute is an experimental feature\n \n-#![crate_type = \"dylib\"]\n+fn main() {}\n \n-pub fn foo() {}", "previous_filename": "src/test/compile-fail/auxiliary/allocator-dylib.rs"}, {"sha": "ff3c342f9e00343f223452e3ee15c2efeaf63f06", "filename": "src/test/compile-fail/feature-gate-global_allocator.rs", "status": "renamed", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Ffeature-gate-global_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Fcompile-fail%2Ffeature-gate-global_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-global_allocator.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// no-prefer-dynamic\n+#[global_allocator] //~ ERROR: attribute is an experimental feature\n+static A: usize = 0;\n \n-#![feature(allocator)]\n-#![allocator]\n-#![crate_type = \"rlib\"]\n-#![no_std]\n+fn main() {}", "previous_filename": "src/test/compile-fail/auxiliary/allocator1.rs"}, {"sha": "d6fcbcb513ae3d83656487d7888822d6706fb787", "filename": "src/test/compile-fail/two-allocators-2.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Fcompile-fail%2Ftwo-allocators-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Fcompile-fail%2Ftwo-allocators-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftwo-allocators-2.rs?ref=4c225c4d1732537aff63dd97c2b7ac681fd3d188", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: cannot link together two allocators: allocator1 and allocator2\n-// aux-build:allocator1.rs\n-// aux-build:allocator2.rs\n-\n-// Make sure we can't link together two explicit allocators.\n-\n-extern crate allocator1;\n-extern crate allocator2;\n-\n-fn main() {}\n-"}, {"sha": "965e4e0e2eabeb13e41302266846c3263c89ceb5", "filename": "src/test/compile-fail/two-allocators-3.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Fcompile-fail%2Ftwo-allocators-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Fcompile-fail%2Ftwo-allocators-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftwo-allocators-3.rs?ref=4c225c4d1732537aff63dd97c2b7ac681fd3d188", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// aux-build:allocator1.rs\n-// error-pattern: cannot link together two allocators\n-// ignore-musl no dylibs on musl yet\n-// ignore-emscripten\n-\n-// We're linking std dynamically (via -C prefer-dynamic for this test) which\n-// has an allocator and then we're also linking in a new allocator (allocator1)\n-// and this should be an error\n-\n-extern crate allocator1;\n-\n-fn main() {\n-}"}, {"sha": "13d8366c60ab943edc1aaaae89dedbf36a26478c", "filename": "src/test/run-make/no-duplicate-libs/Makefile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2FMakefile?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -4,9 +4,7 @@ ifdef IS_MSVC\n # FIXME(#27979)\n all:\n else\n-all:\n-\t$(RUSTC) foo.rs\n-\t$(RUSTC) bar.rs\n+all: $(call STATICLIB,foo) $(call STATICLIB,bar)\n \t$(RUSTC) main.rs\n \t$(call RUN,main)\n endif"}, {"sha": "b9dcd0f5e5eeb138d39724f8117cf0739c5fd017", "filename": "src/test/run-make/no-duplicate-libs/bar.c", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.c", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.c?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allocator] //~ ERROR: experimental feature\n+extern void foo();\n \n-fn main() {}\n+void bar() {\n+  foo();\n+}", "previous_filename": "src/test/compile-fail/feature-gate-allocator.rs"}, {"sha": "cb1c88689a89d0e37c53fe9509cfb35ed37e7744", "filename": "src/test/run-make/no-duplicate-libs/bar.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs?ref=4c225c4d1732537aff63dd97c2b7ac681fd3d188", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(lang_items, alloc_system, compiler_builtins_lib)]\n-#![crate_type = \"dylib\"]\n-#![no_std]\n-\n-extern crate alloc_system;\n-extern crate compiler_builtins;\n-\n-#[no_mangle]\n-pub extern fn bar() {}\n-\n-#[lang = \"eh_personality\"] fn eh_personality() {}\n-#[lang = \"eh_unwind_resume\"] fn eh_unwind_resume() {}\n-#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n-#[no_mangle] pub extern fn rust_eh_register_frames () {}\n-#[no_mangle] pub extern fn rust_eh_unregister_frames () {}"}, {"sha": "906cd5682b82dd222f66b80367ede25d3c5c8c00", "filename": "src/test/run-make/no-duplicate-libs/foo.c", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.c", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.c?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,5 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn foo() {}\n-\n+void foo() {}", "previous_filename": "src/test/compile-fail/auxiliary/allocator-dylib2.rs"}, {"sha": "214fb156c2d6309f50bc848acf9bd76960d71b6d", "filename": "src/test/run-make/no-duplicate-libs/foo.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs?ref=4c225c4d1732537aff63dd97c2b7ac681fd3d188", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(lang_items, alloc_system, compiler_builtins_lib)]\n-#![no_std]\n-#![crate_type = \"dylib\"]\n-\n-extern crate alloc_system;\n-extern crate compiler_builtins;\n-\n-#[no_mangle]\n-pub extern fn foo() {}\n-\n-#[lang = \"eh_personality\"] fn eh_personality() {}\n-#[lang = \"eh_unwind_resume\"] fn eh_unwind_resume() {}\n-#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n-#[no_mangle] pub extern fn rust_eh_register_frames () {}\n-#[no_mangle] pub extern fn rust_eh_unregister_frames () {}"}, {"sha": "824946fe9c2bdcd45179a43f06dd84e311551b27", "filename": "src/test/run-make/no-duplicate-libs/main.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fmain.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[link(name = \"foo\")]\n-#[link(name = \"bar\")]\n-#[link(name = \"foo\")]\n+#[link(name = \"foo\")] // linker should drop this library, no symbols used\n+#[link(name = \"bar\")] // symbol comes from this library\n+#[link(name = \"foo\")] // now linker picks up `foo` b/c `bar` library needs it\n extern {\n     fn bar();\n }"}, {"sha": "712fa2d6001774b23ddb64226629f413f4682443", "filename": "src/test/run-pass/allocator-alloc-one.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -8,20 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(alloc, allocator_api, heap_api, unique)]\n+#![feature(allocator_api, unique)]\n \n-extern crate alloc;\n-\n-use alloc::heap::HeapAlloc;\n-use alloc::allocator::Alloc;\n+use std::heap::{Heap, Alloc};\n \n fn main() {\n     unsafe {\n-        let ptr = HeapAlloc.alloc_one::<i32>().unwrap_or_else(|e| {\n-            HeapAlloc.oom(e)\n+        let ptr = Heap.alloc_one::<i32>().unwrap_or_else(|e| {\n+            Heap.oom(e)\n         });\n         *ptr.as_ptr() = 4;\n         assert_eq!(*ptr.as_ptr(), 4);\n-        HeapAlloc.dealloc_one(ptr);\n+        Heap.dealloc_one(ptr);\n     }\n }"}, {"sha": "0a02e8072b9b34bf56c98355c4fb4bd3aeca6981", "filename": "src/test/run-pass/allocator-default.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Frun-pass%2Fallocator-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Frun-pass%2Fallocator-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator-default.rs?ref=4c225c4d1732537aff63dd97c2b7ac681fd3d188", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(alloc_jemalloc)]\n-\n-#[cfg(any(all(target_os = \"linux\", any(target_arch = \"x86\", target_arch = \"x86_64\")),\n-          target_os = \"macos\"))]\n-extern crate alloc_jemalloc;\n-\n-fn main() {\n-    println!(\"{:?}\", Box::new(3));\n-}"}, {"sha": "ca2dbdf2b3de30a4a3672ecd389dc075889ca29c", "filename": "src/test/run-pass/allocator-override.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Frun-pass%2Fallocator-override.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c225c4d1732537aff63dd97c2b7ac681fd3d188/src%2Ftest%2Frun-pass%2Fallocator-override.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator-override.rs?ref=4c225c4d1732537aff63dd97c2b7ac681fd3d188", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// no-prefer-dynamic\n-// aux-build:allocator-dummy.rs\n-// ignore-emscripten\n-\n-#![feature(test)]\n-\n-extern crate allocator_dummy;\n-extern crate test;\n-\n-fn main() {\n-    unsafe {\n-        let before = allocator_dummy::HITS;\n-        let mut b = Box::new(3);\n-        test::black_box(&mut b); // Make sure the allocation is not optimized away\n-        assert_eq!(allocator_dummy::HITS - before, 1);\n-        drop(b);\n-        assert_eq!(allocator_dummy::HITS - before, 2);\n-    }\n-}"}, {"sha": "538f36faadf2c4f67796f4b135602d7231c152f4", "filename": "src/test/run-pass/allocator/auxiliary/custom-as-global.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom-as-global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom-as-global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom-as-global.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(global_allocator)]\n+#![crate_type = \"rlib\"]\n+\n+extern crate custom;\n+\n+use std::sync::atomic::{ATOMIC_USIZE_INIT, Ordering};\n+\n+use custom::A;\n+\n+#[global_allocator]\n+static ALLOCATOR: A = A(ATOMIC_USIZE_INIT);\n+\n+pub fn get() -> usize {\n+    ALLOCATOR.0.load(Ordering::SeqCst)\n+}"}, {"sha": "8f4fbcd5ab1c15d33d4df341ae531157ec31f98d", "filename": "src/test/run-pass/allocator/auxiliary/custom.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(heap_api, allocator_api)]\n+#![crate_type = \"rlib\"]\n+\n+use std::heap::{Alloc, System, AllocErr, Layout};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+pub struct A(pub AtomicUsize);\n+\n+unsafe impl<'a> Alloc for &'a A {\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+        self.0.fetch_add(1, Ordering::SeqCst);\n+        System.alloc(layout)\n+    }\n+\n+    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+        self.0.fetch_add(1, Ordering::SeqCst);\n+        System.dealloc(ptr, layout)\n+    }\n+}"}, {"sha": "e75a432710df2fe79d4e7ded0c2e888135d6fc10", "filename": "src/test/run-pass/allocator/auxiliary/helper.rs", "status": "renamed", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fhelper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fhelper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fhelper.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,7 +10,10 @@\n \n // no-prefer-dynamic\n \n-#![feature(needs_allocator)]\n-#![no_std]\n-#![needs_allocator]\n #![crate_type = \"rlib\"]\n+\n+use std::fmt;\n+\n+pub fn work_with(p: &fmt::Debug) {\n+    drop(p);\n+}", "previous_filename": "src/test/compile-fail/auxiliary/needs_allocator.rs"}, {"sha": "b46f024b5bff3b8538cae1d1d0af5654c2fd8745", "filename": "src/test/run-pass/allocator/custom.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:helper.rs\n+// no-prefer-dynamic\n+\n+#![feature(global_allocator, heap_api, allocator_api)]\n+\n+extern crate helper;\n+\n+use std::env;\n+use std::heap::{Heap, Alloc, System, Layout, AllocErr};\n+use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n+\n+static HITS: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+struct A;\n+\n+unsafe impl<'a> Alloc for &'a A {\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+        HITS.fetch_add(1, Ordering::SeqCst);\n+        System.alloc(layout)\n+    }\n+\n+    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+        HITS.fetch_add(1, Ordering::SeqCst);\n+        System.dealloc(ptr, layout)\n+    }\n+}\n+\n+#[global_allocator]\n+static GLOBAL: A = A;\n+\n+fn main() {\n+    env::set_var(\"FOO\", \"bar\");\n+    drop(env::var(\"FOO\"));\n+\n+    let n = HITS.load(Ordering::SeqCst);\n+    assert!(n > 0);\n+    unsafe {\n+        let layout = Layout::from_size_align(4, 2).unwrap();\n+\n+        let ptr = Heap.alloc(layout.clone()).unwrap();\n+        helper::work_with(&ptr);\n+        assert_eq!(HITS.load(Ordering::SeqCst), n + 1);\n+        Heap.dealloc(ptr, layout.clone());\n+        assert_eq!(HITS.load(Ordering::SeqCst), n + 2);\n+\n+        let s = String::with_capacity(10);\n+        helper::work_with(&s);\n+        assert_eq!(HITS.load(Ordering::SeqCst), n + 3);\n+        drop(s);\n+        assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n+\n+        let ptr = System.alloc(layout.clone()).unwrap();\n+        assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n+        helper::work_with(&ptr);\n+        System.dealloc(ptr, layout);\n+        assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n+    }\n+}"}, {"sha": "4b987b9223d6d542f06a4f4797ab0f6d3741ae87", "filename": "src/test/run-pass/allocator/xcrate-use.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:custom.rs\n+// aux-build:helper.rs\n+// no-prefer-dynamic\n+\n+#![feature(global_allocator, heap_api, allocator_api)]\n+\n+extern crate custom;\n+extern crate helper;\n+\n+use std::env;\n+use std::heap::{Heap, Alloc, System, Layout};\n+use std::sync::atomic::{Ordering, ATOMIC_USIZE_INIT};\n+\n+#[global_allocator]\n+static GLOBAL: custom::A = custom::A(ATOMIC_USIZE_INIT);\n+\n+fn main() {\n+    unsafe {\n+        let n = GLOBAL.0.load(Ordering::SeqCst);\n+        let layout = Layout::from_size_align(4, 2).unwrap();\n+\n+        let ptr = Heap.alloc(layout.clone()).unwrap();\n+        helper::work_with(&ptr);\n+        assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n+        Heap.dealloc(ptr, layout.clone());\n+        assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n+\n+        let ptr = System.alloc(layout.clone()).unwrap();\n+        assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n+        helper::work_with(&ptr);\n+        System.dealloc(ptr, layout);\n+        assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n+    }\n+}"}, {"sha": "7e6cd9fdf495088c224582fe1e87ff4a78eed2b0", "filename": "src/test/run-pass/allocator/xcrate-use2.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:custom.rs\n+// aux-build:custom-as-global.rs\n+// aux-build:helper.rs\n+// no-prefer-dynamic\n+\n+#![feature(heap_api, allocator_api)]\n+\n+extern crate custom;\n+extern crate custom_as_global;\n+extern crate helper;\n+\n+use std::env;\n+use std::heap::{Heap, Alloc, System, Layout};\n+use std::sync::atomic::{Ordering, ATOMIC_USIZE_INIT};\n+\n+static GLOBAL: custom::A = custom::A(ATOMIC_USIZE_INIT);\n+\n+fn main() {\n+    unsafe {\n+        let n = custom_as_global::get();\n+        let layout = Layout::from_size_align(4, 2).unwrap();\n+\n+        // Global allocator routes to the `custom_as_global` global\n+        let ptr = Heap.alloc(layout.clone()).unwrap();\n+        helper::work_with(&ptr);\n+        assert_eq!(custom_as_global::get(), n + 1);\n+        Heap.dealloc(ptr, layout.clone());\n+        assert_eq!(custom_as_global::get(), n + 2);\n+\n+        // Usage of the system allocator avoids all globals\n+        let ptr = System.alloc(layout.clone()).unwrap();\n+        helper::work_with(&ptr);\n+        assert_eq!(custom_as_global::get(), n + 2);\n+        System.dealloc(ptr, layout.clone());\n+        assert_eq!(custom_as_global::get(), n + 2);\n+\n+        // Usage of our personal allocator doesn't affect other instances\n+        let ptr = (&GLOBAL).alloc(layout.clone()).unwrap();\n+        helper::work_with(&ptr);\n+        assert_eq!(custom_as_global::get(), n + 2);\n+        assert_eq!(GLOBAL.0.load(Ordering::SeqCst), 1);\n+        (&GLOBAL).dealloc(ptr, layout);\n+        assert_eq!(custom_as_global::get(), n + 2);\n+        assert_eq!(GLOBAL.0.load(Ordering::SeqCst), 2);\n+    }\n+}\n+"}, {"sha": "6e5dccae0a07deb1dcd4614aa817628d7ec05eaf", "filename": "src/test/run-pass/lib-defaults.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Flib-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Flib-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-defaults.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -8,16 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// aux-build:clibrary.rs\n-// compile-flags: -lclibrary\n+// compile-flags: -lrust_test_helpers\n \n-#[link(name = \"clibrary\", kind = \"static\")]\n+#[link(name = \"rust_test_helpers\", kind = \"static\")]\n extern \"C\" {\n-    pub fn foo(x:i32) -> i32;\n+    pub fn rust_dbg_extern_identity_u32(x: u32) -> u32;\n }\n \n fn main() {\n     unsafe {\n-        foo(42);\n+        rust_dbg_extern_identity_u32(42);\n     }\n }"}, {"sha": "eddcd5a584a5d3d7cdb805d3afd1a24d7cc6b155", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 41, "deletions": 34, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -13,11 +13,9 @@\n // Ideally this would be revised to use no_std, but for now it serves\n // well enough to reproduce (and illustrate) the bug from #16687.\n \n-#![feature(heap_api, alloc, oom)]\n+#![feature(heap_api, allocator_api)]\n \n-extern crate alloc;\n-\n-use alloc::heap;\n+use std::heap::{Heap, Alloc, Layout};\n use std::ptr;\n \n fn main() {\n@@ -47,38 +45,39 @@ unsafe fn test_triangle() -> bool {\n \n     static PRINT : bool = false;\n \n-    unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n-        if PRINT { println!(\"allocate(size={} align={})\", size, align); }\n+    unsafe fn allocate(layout: Layout) -> *mut u8 {\n+        if PRINT {\n+            println!(\"allocate({:?})\", layout);\n+        }\n \n-        let ret = heap::allocate(size, align);\n-        if ret.is_null() { alloc::oom() }\n+        let ret = Heap.alloc(layout.clone()).unwrap_or_else(|e| Heap.oom(e));\n \n-        if PRINT { println!(\"allocate(size={} align={}) ret: 0x{:010x}\",\n-                            size, align, ret as usize);\n+        if PRINT {\n+            println!(\"allocate({:?}) = {:?}\", layout, ret);\n         }\n \n         ret\n     }\n-    unsafe fn deallocate(ptr: *mut u8, size: usize, align: usize) {\n-        if PRINT { println!(\"deallocate(ptr=0x{:010x} size={} align={})\",\n-                            ptr as usize, size, align);\n+\n+    unsafe fn deallocate(ptr: *mut u8, layout: Layout) {\n+        if PRINT {\n+            println!(\"deallocate({:?}, {:?}\", ptr, layout);\n         }\n \n-        heap::deallocate(ptr, size, align);\n+        Heap.dealloc(ptr, layout);\n     }\n-    unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n+\n+    unsafe fn reallocate(ptr: *mut u8, old: Layout, new: Layout) -> *mut u8 {\n         if PRINT {\n-            println!(\"reallocate(ptr=0x{:010x} old_size={} size={} align={})\",\n-                     ptr as usize, old_size, size, align);\n+            println!(\"reallocate({:?}, old={:?}, new={:?})\", ptr, old, new);\n         }\n \n-        let ret = heap::reallocate(ptr, old_size, size, align);\n-        if ret.is_null() { alloc::oom() }\n+        let ret = Heap.realloc(ptr, old.clone(), new.clone())\n+            .unwrap_or_else(|e| Heap.oom(e));\n \n         if PRINT {\n-            println!(\"reallocate(ptr=0x{:010x} old_size={} size={} align={}) \\\n-                      ret: 0x{:010x}\",\n-                     ptr as usize, old_size, size, align, ret as usize);\n+            println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\",\n+                     ptr, old, new, ret);\n         }\n         ret\n     }\n@@ -91,8 +90,8 @@ unsafe fn test_triangle() -> bool {\n     // way.)\n     for i in 0..COUNT / 2 {\n         let size = idx_to_size(i);\n-        ascend[2*i]   = allocate(size, ALIGN);\n-        ascend[2*i+1] = allocate(size, ALIGN);\n+        ascend[2*i]   = allocate(Layout::from_size_align(size, ALIGN).unwrap());\n+        ascend[2*i+1] = allocate(Layout::from_size_align(size, ALIGN).unwrap());\n     }\n \n     // Initialize each pair of rows to distinct value.\n@@ -112,8 +111,8 @@ unsafe fn test_triangle() -> bool {\n \n     for i in 0..COUNT / 2 {\n         let size = idx_to_size(i);\n-        deallocate(ascend[2*i], size, ALIGN);\n-        deallocate(ascend[2*i+1], size, ALIGN);\n+        deallocate(ascend[2*i], Layout::from_size_align(size, ALIGN).unwrap());\n+        deallocate(ascend[2*i+1], Layout::from_size_align(size, ALIGN).unwrap());\n     }\n \n     return true;\n@@ -124,59 +123,67 @@ unsafe fn test_triangle() -> bool {\n     // rows as we go.\n     unsafe fn test_1(ascend: &mut [*mut u8]) {\n         let new_size = idx_to_size(COUNT-1);\n+        let new = Layout::from_size_align(new_size, ALIGN).unwrap();\n         for i in 0..COUNT / 2 {\n             let (p0, p1, old_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n             assert!(old_size < new_size);\n+            let old = Layout::from_size_align(old_size, ALIGN).unwrap();\n \n-            ascend[2*i] = reallocate(p0, old_size, new_size, ALIGN);\n+            ascend[2*i] = reallocate(p0, old.clone(), new.clone());\n             sanity_check(&*ascend);\n \n-            ascend[2*i+1] = reallocate(p1, old_size, new_size, ALIGN);\n+            ascend[2*i+1] = reallocate(p1, old.clone(), new.clone());\n             sanity_check(&*ascend);\n         }\n     }\n \n     // Test 2: turn the square back into a triangle, top to bottom.\n     unsafe fn test_2(ascend: &mut [*mut u8]) {\n         let old_size = idx_to_size(COUNT-1);\n+        let old = Layout::from_size_align(old_size, ALIGN).unwrap();\n         for i in 0..COUNT / 2 {\n             let (p0, p1, new_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n             assert!(new_size < old_size);\n+            let new = Layout::from_size_align(new_size, ALIGN).unwrap();\n \n-            ascend[2*i] = reallocate(p0, old_size, new_size, ALIGN);\n+            ascend[2*i] = reallocate(p0, old.clone(), new.clone());\n             sanity_check(&*ascend);\n \n-            ascend[2*i+1] = reallocate(p1, old_size, new_size, ALIGN);\n+            ascend[2*i+1] = reallocate(p1, old.clone(), new.clone());\n             sanity_check(&*ascend);\n         }\n     }\n \n     // Test 3: turn triangle into a square, bottom to top.\n     unsafe fn test_3(ascend: &mut [*mut u8]) {\n         let new_size = idx_to_size(COUNT-1);\n+        let new = Layout::from_size_align(new_size, ALIGN).unwrap();\n         for i in (0..COUNT / 2).rev() {\n             let (p0, p1, old_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n             assert!(old_size < new_size);\n+            let old = Layout::from_size_align(old_size, ALIGN).unwrap();\n \n-            ascend[2*i+1] = reallocate(p1, old_size, new_size, ALIGN);\n+            ascend[2*i+1] = reallocate(p1, old.clone(), new.clone());\n             sanity_check(&*ascend);\n \n-            ascend[2*i] = reallocate(p0, old_size, new_size, ALIGN);\n+            ascend[2*i] = reallocate(p0, old.clone(), new.clone());\n             sanity_check(&*ascend);\n         }\n     }\n \n     // Test 4: turn the square back into a triangle, bottom to top.\n     unsafe fn test_4(ascend: &mut [*mut u8]) {\n         let old_size = idx_to_size(COUNT-1);\n+        let old = Layout::from_size_align(old_size, ALIGN).unwrap();\n         for i in (0..COUNT / 2).rev() {\n             let (p0, p1, new_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n             assert!(new_size < old_size);\n+            let new = Layout::from_size_align(new_size, ALIGN).unwrap();\n \n-            ascend[2*i+1] = reallocate(p1, old_size, new_size, ALIGN);\n+            ascend[2*i+1] = reallocate(p1, old.clone(), new.clone());\n             sanity_check(&*ascend);\n \n-            ascend[2*i] = reallocate(p0, old_size, new_size, ALIGN);\n+            ascend[2*i] = reallocate(p0, old.clone(), new.clone());\n             sanity_check(&*ascend);\n         }\n     }"}, {"sha": "26713a25543772034b15262a2cd83fe5538f2772", "filename": "src/test/run-pass/rfc1717/library-override.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Frfc1717%2Flibrary-override.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Frfc1717%2Flibrary-override.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc1717%2Flibrary-override.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -8,16 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// aux-build:clibrary.rs\n-// compile-flags: -lstatic=wronglibrary:clibrary\n+// compile-flags: -lstatic=wronglibrary:rust_test_helpers\n \n #[link(name = \"wronglibrary\", kind = \"dylib\")]\n extern \"C\" {\n-    pub fn foo(x:i32) -> i32;\n+    pub fn rust_dbg_extern_identity_u32(x: u32) -> u32;\n }\n \n fn main() {\n     unsafe {\n-        foo(42);\n+        rust_dbg_extern_identity_u32(42);\n     }\n }"}, {"sha": "bcbd3fd3786ab4555da1b24961e880db5728d7b6", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695dee063bcd40f154bb27b7beafcb3d4dd775ac/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=695dee063bcd40f154bb27b7beafcb3d4dd775ac", "patch": "@@ -10,32 +10,32 @@\n \n // Smallest \"hello world\" with a libc runtime\n \n-// pretty-expanded FIXME #23616\n // ignore-windows\n+// ignore-android\n \n #![feature(intrinsics, lang_items, start, no_core, alloc_system)]\n-#![no_core]\n+#![feature(global_allocator, allocator_api)]\n+#![no_std]\n \n extern crate alloc_system;\n \n-extern { fn puts(s: *const u8); }\n-extern \"rust-intrinsic\" { fn transmute<T, U>(t: T) -> U; }\n+use alloc_system::System;\n \n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"eh_unwind_resume\"] extern fn eh_unwind_resume() {}\n+#[global_allocator]\n+static A: System = System;\n+\n+extern {\n+    fn puts(s: *const u8);\n+}\n+\n+#[no_mangle]\n+#[lang = \"eh_personality\"] pub extern fn rust_eh_personality() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n-#[no_mangle] pub extern fn rust_eh_register_frames () {}\n-#[no_mangle] pub extern fn rust_eh_unregister_frames () {}\n \n #[start]\n fn main(_: isize, _: *const *const u8) -> isize {\n     unsafe {\n-        let (ptr, _): (*const u8, usize) = transmute(\"Hello!\\0\");\n-        puts(ptr);\n+        puts(\"Hello!\\0\".as_ptr() as *const u8);\n     }\n-    return 0;\n+    return 0\n }\n-\n-#[cfg(target_os = \"android\")]\n-#[link(name=\"gcc\")]\n-extern { }"}]}