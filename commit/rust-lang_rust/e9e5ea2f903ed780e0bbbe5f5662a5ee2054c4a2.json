{"sha": "e9e5ea2f903ed780e0bbbe5f5662a5ee2054c4a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5ZTVlYTJmOTAzZWQ3ODBlMGJiYmU1ZjU2NjJhNWVlMjA1NGM0YTI=", "commit": {"author": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-07-04T22:29:47Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-07-05T09:49:03Z"}, "message": "libcore: Fix Items iterator for zero sized types.", "tree": {"sha": "a0a716098a67f279e24a8861830e2abcfa3db862", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0a716098a67f279e24a8861830e2abcfa3db862"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9e5ea2f903ed780e0bbbe5f5662a5ee2054c4a2", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9e5ea2f903ed780e0bbbe5f5662a5ee2054c4a2", "html_url": "https://github.com/rust-lang/rust/commit/e9e5ea2f903ed780e0bbbe5f5662a5ee2054c4a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9e5ea2f903ed780e0bbbe5f5662a5ee2054c4a2/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f48cc740017bac1214030300435dfa95dbaa220b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f48cc740017bac1214030300435dfa95dbaa220b", "html_url": "https://github.com/rust-lang/rust/commit/f48cc740017bac1214030300435dfa95dbaa220b"}], "stats": {"total": 46, "additions": 28, "deletions": 18}, "files": [{"sha": "6e2dc95cfd6e506f47e519e726cfcb51cdff6eae", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9e5ea2f903ed780e0bbbe5f5662a5ee2054c4a2/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9e5ea2f903ed780e0bbbe5f5662a5ee2054c4a2/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=e9e5ea2f903ed780e0bbbe5f5662a5ee2054c4a2", "patch": "@@ -75,12 +75,10 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn new() -> Vec<T> {\n-        // If we have a 0-sized vector, then the base pointer should not be NULL\n-        // because an iterator over the slice will attempt to yield the base\n-        // pointer as the first element in the vector, but this will end up\n-        // being Some(NULL) which is optimized to None. So instead we set ptr\n-        // to some arbitrary non-null value which is fine since we never call\n-        // deallocate on the ptr if cap is 0.\n+        // We want ptr to never be NULL so instead we set it to some arbitrary\n+        // non-null value which is fine since we never call deallocate on the ptr\n+        // if cap is 0. The reason for this is because the pointer of a slice\n+        // being NULL would break the null pointer optimization for enums.\n         Vec { len: 0, cap: 0, ptr: &PTR_MARKER as *const _ as *mut T }\n     }\n "}, {"sha": "8197a7c2dcbe2dc3904f20d1fbbc3457a0f1f68a", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e9e5ea2f903ed780e0bbbe5f5662a5ee2054c4a2/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9e5ea2f903ed780e0bbbe5f5662a5ee2054c4a2/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=e9e5ea2f903ed780e0bbbe5f5662a5ee2054c4a2", "patch": "@@ -884,17 +884,20 @@ macro_rules! iterator {\n                     if self.ptr == self.end {\n                         None\n                     } else {\n-                        let old = self.ptr;\n-                        self.ptr = if mem::size_of::<T>() == 0 {\n+                        if mem::size_of::<T>() == 0 {\n                             // purposefully don't use 'ptr.offset' because for\n                             // vectors with 0-size elements this would return the\n                             // same pointer.\n-                            transmute(self.ptr as uint + 1)\n+                            self.ptr = transmute(self.ptr as uint + 1);\n+\n+                            // Use a non-null pointer value\n+                            Some(transmute(1u))\n                         } else {\n-                            self.ptr.offset(1)\n-                        };\n+                            let old = self.ptr;\n+                            self.ptr = self.ptr.offset(1);\n \n-                        Some(transmute(old))\n+                            Some(transmute(old))\n+                        }\n                     }\n                 }\n             }\n@@ -916,13 +919,17 @@ macro_rules! iterator {\n                     if self.end == self.ptr {\n                         None\n                     } else {\n-                        self.end = if mem::size_of::<T>() == 0 {\n+                        if mem::size_of::<T>() == 0 {\n                             // See above for why 'ptr.offset' isn't used\n-                            transmute(self.end as uint - 1)\n+                            self.end = transmute(self.end as uint - 1);\n+\n+                            // Use a non-null pointer value\n+                            Some(transmute(1u))\n                         } else {\n-                            self.end.offset(-1)\n-                        };\n-                        Some(transmute(self.end))\n+                            self.end = self.end.offset(-1);\n+\n+                            Some(transmute(self.end))\n+                        }\n                     }\n                 }\n             }\n@@ -956,7 +963,12 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     fn idx(&mut self, index: uint) -> Option<&'a T> {\n         unsafe {\n             if index < self.indexable() {\n-                transmute(self.ptr.offset(index as int))\n+                if mem::size_of::<T>() == 0 {\n+                    // Use a non-null pointer value\n+                    Some(transmute(1u))\n+                } else {\n+                    Some(transmute(self.ptr.offset(index as int)))\n+                }\n             } else {\n                 None\n             }"}]}