{"sha": "6690bcb10178b08c56ad56b111e4dcb7e0e06b36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2OTBiY2IxMDE3OGIwOGM1NmFkNTZiMTExZTRkY2I3ZTBlMDZiMzY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-04T22:03:32Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:10Z"}, "message": "Fixing rebase conflicts and such\n\nThis cleans up the merging of removing ~fn() and removing C++ wrappers to a\ncompile-able and progress-ready state", "tree": {"sha": "83add0283a6bf6b21125ad9f1399b6be44a21c26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83add0283a6bf6b21125ad9f1399b6be44a21c26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6690bcb10178b08c56ad56b111e4dcb7e0e06b36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6690bcb10178b08c56ad56b111e4dcb7e0e06b36", "html_url": "https://github.com/rust-lang/rust/commit/6690bcb10178b08c56ad56b111e4dcb7e0e06b36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18ce014e9d99a66690e9db02e799f57ab969f36d", "url": "https://api.github.com/repos/rust-lang/rust/commits/18ce014e9d99a66690e9db02e799f57ab969f36d", "html_url": "https://github.com/rust-lang/rust/commit/18ce014e9d99a66690e9db02e799f57ab969f36d"}], "stats": {"total": 235, "additions": 91, "deletions": 144}, "files": [{"sha": "0b93e8fa49fcba25c8c8aaee32f7dd6dbf680913", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=6690bcb10178b08c56ad56b111e4dcb7e0e06b36", "patch": "@@ -35,7 +35,7 @@ impl AsyncWatcher {\n     pub fn new(loop_: &mut Loop, cb: ~Callback) -> AsyncWatcher {\n         let handle = UvHandle::alloc(None::<AsyncWatcher>, uvll::UV_ASYNC);\n         assert_eq!(unsafe {\n-            uvll::async_init(loop_.native_handle(), handle, async_cb)\n+            uvll::uv_async_init(loop_.native_handle(), handle, async_cb)\n         }, 0);\n         let flag = Exclusive::new(false);\n         let payload = ~Payload { callback: cb, exit_flag: flag.clone() };\n@@ -49,7 +49,7 @@ impl AsyncWatcher {\n \n impl UvHandle<uvll::uv_async_t> for AsyncWatcher {\n     fn uv_handle(&self) -> *uvll::uv_async_t { self.handle }\n-    unsafe fn from_uv_handle<'a>(h: &'a *T) -> &'a mut AsyncWatcher {\n+    unsafe fn from_uv_handle<'a>(_: &'a *uvll::uv_async_t) -> &'a mut AsyncWatcher {\n         fail!(\"async watchers can't be built from their handles\");\n     }\n }\n@@ -89,7 +89,7 @@ extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n     payload.callback.call();\n \n     if should_exit {\n-        unsafe { uvll::close(handle, close_cb) }\n+        unsafe { uvll::uv_close(handle, close_cb) }\n     }\n }\n \n@@ -104,7 +104,7 @@ extern fn close_cb(handle: *uvll::uv_handle_t) {\n \n impl RemoteCallback for AsyncWatcher {\n     fn fire(&mut self) {\n-        unsafe { uvll::async_send(self.handle) }\n+        unsafe { uvll::uv_async_send(self.handle) }\n     }\n }\n \n@@ -117,7 +117,7 @@ impl Drop for AsyncWatcher {\n                 // signal and see the exit flag, destroying the handle\n                 // before the final send.\n                 *should_exit = true;\n-                uvll::async_send(self.handle)\n+                uvll::uv_async_send(self.handle)\n             }\n         }\n     }"}, {"sha": "0ff4543a116b008e4fc80b76a20d50c25871dcd0", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 15, "deletions": 66, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=6690bcb10178b08c56ad56b111e4dcb7e0e06b36", "patch": "@@ -13,7 +13,7 @@ use std::c_str;\n use std::c_str::CString;\n use std::cast::transmute;\n use std::libc;\n-use std::libc::{c_int, c_char, c_void};\n+use std::libc::{c_int, c_char, c_void, c_uint};\n \n use super::{Request, NativeHandle, Loop, FsCallback, Buf,\n             status_to_maybe_uv_error, UvError};\n@@ -147,25 +147,12 @@ impl FsRequest {\n         self.sync_cleanup(result)\n     }\n \n-<<<<<<< HEAD\n     pub fn close(mut self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n         let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         assert_eq!(unsafe {\n-            uvll::fs_close(loop_.native_handle(), self.native_handle(),\n-                           fd, complete_cb_ptr)\n-        }, 0);\n-=======\n-    pub fn close(self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = unsafe {\n             uvll::uv_fs_close(loop_.native_handle(), self.native_handle(),\n                               fd, complete_cb_ptr)\n-        };\n-        assert_eq!(ret, 0);\n->>>>>>> 1850d26... Remove lots of uv/C++ wrappers\n+        }, 0);\n     }\n     pub fn close_sync(mut self, loop_: &Loop,\n                       fd: c_int) -> Result<c_int, UvError> {\n@@ -177,77 +164,50 @@ impl FsRequest {\n         self.sync_cleanup(result)\n     }\n \n-<<<<<<< HEAD\n     pub fn mkdir(mut self, loop_: &Loop, path: &CString, mode: c_int,\n                  cb: FsCallback) {\n         let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         assert_eq!(path.with_ref(|p| unsafe {\n-            uvll::fs_mkdir(loop_.native_handle(),\n-                           self.native_handle(), p, mode, complete_cb_ptr)\n+            uvll::uv_fs_mkdir(loop_.native_handle(),\n+                              self.native_handle(), p, mode, complete_cb_ptr)\n         }), 0);\n     }\n \n     pub fn rmdir(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n         let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         assert_eq!(path.with_ref(|p| unsafe {\n-            uvll::fs_rmdir(loop_.native_handle(),\n-                           self.native_handle(), p, complete_cb_ptr)\n+            uvll::uv_fs_rmdir(loop_.native_handle(),\n+                              self.native_handle(), p, complete_cb_ptr)\n         }), 0);\n     }\n \n     pub fn rename(mut self, loop_: &Loop, path: &CString, to: &CString,\n                   cb: FsCallback) {\n         let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         assert_eq!(unsafe {\n-            uvll::fs_rename(loop_.native_handle(),\n-                            self.native_handle(),\n-                            path.with_ref(|p| p),\n-                            to.with_ref(|p| p),\n-                            complete_cb_ptr)\n+            uvll::uv_fs_rename(loop_.native_handle(),\n+                               self.native_handle(),\n+                               path.with_ref(|p| p),\n+                               to.with_ref(|p| p),\n+                               complete_cb_ptr)\n         }, 0);\n     }\n \n     pub fn chmod(mut self, loop_: &Loop, path: &CString, mode: c_int,\n                  cb: FsCallback) {\n         let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         assert_eq!(path.with_ref(|p| unsafe {\n-            uvll::fs_chmod(loop_.native_handle(), self.native_handle(), p, mode,\n-                           complete_cb_ptr)\n+            uvll::uv_fs_chmod(loop_.native_handle(), self.native_handle(), p,\n+                              mode, complete_cb_ptr)\n         }), 0);\n-=======\n-    pub fn mkdir(self, loop_: &Loop, path: &CString, mode: int, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n-            uvll::uv_fs_mkdir(loop_.native_handle(),\n-                              self.native_handle(), p,\n-                              mode as c_int, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n-    }\n-\n-    pub fn rmdir(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n-            uvll::uv_fs_rmdir(loop_.native_handle(),\n-                              self.native_handle(), p, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n->>>>>>> 1850d26... Remove lots of uv/C++ wrappers\n     }\n \n     pub fn readdir(mut self, loop_: &Loop, path: &CString,\n                    flags: c_int, cb: FsCallback) {\n-<<<<<<< HEAD\n         let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         assert_eq!(path.with_ref(|p| unsafe {\n-            uvll::fs_readdir(loop_.native_handle(),\n-                             self.native_handle(), p, flags, complete_cb_ptr)\n+            uvll::uv_fs_readdir(loop_.native_handle(),\n+                                self.native_handle(), p, flags, complete_cb_ptr)\n         }), 0);\n     }\n \n@@ -318,17 +278,6 @@ impl FsRequest {\n             uvll::uv_fs_fdatasync(loop_.native_handle(), self.native_handle(), fd,\n                                   complete_cb_ptr)\n         }, 0);\n-=======\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n-            uvll::uv_fs_readdir(loop_.native_handle(),\n-                                self.native_handle(), p, flags, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n->>>>>>> 1850d26... Remove lots of uv/C++ wrappers\n     }\n \n     // accessors/utility funcs"}, {"sha": "e3cc6ec90a1b120d83e8426e0f270baa03d0a11e", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=6690bcb10178b08c56ad56b111e4dcb7e0e06b36", "patch": "@@ -26,7 +26,7 @@ impl IdleWatcher {\n     pub fn new(loop_: &mut Loop) -> ~IdleWatcher {\n         let handle = UvHandle::alloc(None::<IdleWatcher>, uvll::UV_IDLE);\n         assert_eq!(unsafe {\n-            uvll::idle_init(loop_.native_handle(), handle)\n+            uvll::uv_idle_init(loop_.native_handle(), handle)\n         }, 0);\n         let me = ~IdleWatcher {\n             handle: handle,\n@@ -40,10 +40,10 @@ impl IdleWatcher {\n     pub fn onetime(loop_: &mut Loop, f: proc()) {\n         let handle = UvHandle::alloc(None::<IdleWatcher>, uvll::UV_IDLE);\n         unsafe {\n-            assert_eq!(uvll::idle_init(loop_.native_handle(), handle), 0);\n+            assert_eq!(uvll::uv_idle_init(loop_.native_handle(), handle), 0);\n             let data: *c_void = cast::transmute(~f);\n             uvll::set_data_for_uv_handle(handle, data);\n-            assert_eq!(uvll::idle_start(handle, onetime_cb), 0)\n+            assert_eq!(uvll::uv_idle_start(handle, onetime_cb), 0)\n         }\n \n         extern fn onetime_cb(handle: *uvll::uv_idle_t, status: c_int) {\n@@ -52,8 +52,8 @@ impl IdleWatcher {\n                 let data = uvll::get_data_for_uv_handle(handle);\n                 let f: ~proc() = cast::transmute(data);\n                 (*f)();\n-                uvll::idle_stop(handle);\n-                uvll::close(handle, close_cb);\n+                uvll::uv_idle_stop(handle);\n+                uvll::uv_close(handle, close_cb);\n             }\n         }\n \n@@ -67,18 +67,18 @@ impl PausibleIdleCallback for IdleWatcher {\n     fn start(&mut self, cb: ~Callback) {\n         assert!(self.callback.is_none());\n         self.callback = Some(cb);\n-        assert_eq!(unsafe { uvll::idle_start(self.handle, idle_cb) }, 0)\n+        assert_eq!(unsafe { uvll::uv_idle_start(self.handle, idle_cb) }, 0)\n         self.idle_flag = true;\n     }\n     fn pause(&mut self) {\n         if self.idle_flag == true {\n-            assert_eq!(unsafe {uvll::idle_stop(self.handle) }, 0);\n+            assert_eq!(unsafe {uvll::uv_idle_stop(self.handle) }, 0);\n             self.idle_flag = false;\n         }\n     }\n     fn resume(&mut self) {\n         if self.idle_flag == false {\n-            assert_eq!(unsafe { uvll::idle_start(self.handle, idle_cb) }, 0)\n+            assert_eq!(unsafe { uvll::uv_idle_start(self.handle, idle_cb) }, 0)\n             self.idle_flag = true;\n         }\n     }"}, {"sha": "de8bed948c4df9df7c72c36f392a0d879c61ec2a", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=6690bcb10178b08c56ad56b111e4dcb7e0e06b36", "patch": "@@ -50,7 +50,7 @@ use std::str::raw::from_c_str;\n use std::vec;\n use std::ptr;\n use std::str;\n-use std::libc::{c_void, c_int, size_t, malloc, free, c_char, c_uint};\n+use std::libc::{c_void, c_int, size_t, malloc, free};\n use std::cast::transmute;\n use std::ptr::null;\n use std::unstable::finally::Finally;\n@@ -153,7 +153,7 @@ pub trait UvHandle<T> {\n \n         unsafe {\n             uvll::set_data_for_uv_handle(self.uv_handle(), null::<()>());\n-            uvll::close(self.uv_handle(), close_cb)\n+            uvll::uv_close(self.uv_handle() as *uvll::uv_handle_t, close_cb)\n         }\n     }\n }"}, {"sha": "d143bc059e43729c23a9436d8b00d601e205c22e", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=6690bcb10178b08c56ad56b111e4dcb7e0e06b36", "patch": "@@ -201,32 +201,30 @@ impl RtioProcess for Process {\n     }\n \n     fn kill(&mut self, signal: int) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            match unsafe {\n-                uvll::process_kill(self_.handle, signal as libc::c_int)\n-            } {\n-                0 => Ok(()),\n-                err => Err(uv_error_to_io_error(UvError(err)))\n-            }\n+        let _m = self.fire_missiles();\n+        match unsafe {\n+            uvll::uv_process_kill(self.handle, signal as libc::c_int)\n+        } {\n+            0 => Ok(()),\n+            err => Err(uv_error_to_io_error(UvError(err)))\n         }\n     }\n \n     fn wait(&mut self) -> int {\n         // Make sure (on the home scheduler) that we have an exit status listed\n-        do self.home_for_io |self_| {\n-            match self_.exit_status {\n-                Some(*) => {}\n-                None => {\n-                    // If there's no exit code previously listed, then the\n-                    // process's exit callback has yet to be invoked. We just\n-                    // need to deschedule ourselves and wait to be reawoken.\n-                    let scheduler: ~Scheduler = Local::take();\n-                    do scheduler.deschedule_running_task_and_then |_, task| {\n-                        assert!(self_.to_wake.is_none());\n-                        self_.to_wake = Some(task);\n-                    }\n-                    assert!(self_.exit_status.is_some());\n+        let _m = self.fire_missiles();\n+        match self.exit_status {\n+            Some(*) => {}\n+            None => {\n+                // If there's no exit code previously listed, then the\n+                // process's exit callback has yet to be invoked. We just\n+                // need to deschedule ourselves and wait to be reawoken.\n+                let scheduler: ~Scheduler = Local::take();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    assert!(self.to_wake.is_none());\n+                    self.to_wake = Some(task);\n                 }\n+                assert!(self.exit_status.is_some());\n             }\n         }\n \n@@ -237,9 +235,8 @@ impl RtioProcess for Process {\n \n impl Drop for Process {\n     fn drop(&mut self) {\n-        do self.home_for_io |self_| {\n-            assert!(self_.to_wake.is_none());\n-            self_.close_async_();\n-        }\n+        let _m = self.fire_missiles();\n+        assert!(self.to_wake.is_none());\n+        self.close_async_();\n     }\n }"}, {"sha": "d8ecc25db6d1dca0a8d2efa82d265c3dcafc75f5", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=6690bcb10178b08c56ad56b111e4dcb7e0e06b36", "patch": "@@ -32,10 +32,10 @@ impl SignalWatcher {\n                channel: SharedChan<Signum>) -> Result<~SignalWatcher, UvError> {\n         let handle = UvHandle::alloc(None::<SignalWatcher>, uvll::UV_SIGNAL);\n         assert_eq!(unsafe {\n-            uvll::signal_init(loop_.native_handle(), handle)\n+            uvll::uv_signal_init(loop_.native_handle(), handle)\n         }, 0);\n \n-        match unsafe { uvll::signal_start(handle, signal_cb, signum as c_int) } {\n+        match unsafe { uvll::uv_signal_start(handle, signal_cb, signum as c_int) } {\n             0 => {\n                 let s = ~SignalWatcher {\n                     handle: handle,\n@@ -72,8 +72,7 @@ impl RtioSignal for SignalWatcher {}\n \n impl Drop for SignalWatcher {\n     fn drop(&mut self) {\n-        do self.home_for_io |self_| {\n-            self_.close_async_();\n-        }\n+        let _m = self.fire_missiles();\n+        self.close_async_();\n     }\n }"}, {"sha": "5bf3a82e972bb21fde078c5982a262d58c0938c3", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=6690bcb10178b08c56ad56b111e4dcb7e0e06b36", "patch": "@@ -36,7 +36,7 @@ impl TimerWatcher {\n     pub fn new(loop_: &mut Loop) -> ~TimerWatcher {\n         let handle = UvHandle::alloc(None::<TimerWatcher>, uvll::UV_TIMER);\n         assert_eq!(unsafe {\n-            uvll::timer_init(loop_.native_handle(), handle)\n+            uvll::uv_timer_init(loop_.native_handle(), handle)\n         }, 0);\n         let me = ~TimerWatcher {\n             handle: handle,\n@@ -48,12 +48,12 @@ impl TimerWatcher {\n \n     fn start(&mut self, msecs: u64, period: u64) {\n         assert_eq!(unsafe {\n-            uvll::timer_start(self.handle, timer_cb, msecs, period)\n+            uvll::uv_timer_start(self.handle, timer_cb, msecs, period)\n         }, 0)\n     }\n \n     fn stop(&mut self) {\n-        assert_eq!(unsafe { uvll::timer_stop(self.handle) }, 0)\n+        assert_eq!(unsafe { uvll::uv_timer_stop(self.handle) }, 0)\n     }\n }\n \n@@ -67,23 +67,21 @@ impl UvHandle<uvll::uv_timer_t> for TimerWatcher {\n \n impl RtioTimer for TimerWatcher {\n     fn sleep(&mut self, msecs: u64) {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            do scheduler.deschedule_running_task_and_then |_sched, task| {\n-                self_.action = Some(WakeTask(task));\n-                self_.start(msecs, 0);\n-            }\n-            self_.stop();\n+        let (_m, sched) = self.fire_missiles_sched();\n+        do sched.deschedule_running_task_and_then |_sched, task| {\n+            self.action = Some(WakeTask(task));\n+            self.start(msecs, 0);\n         }\n+        self.stop();\n     }\n \n     fn oneshot(&mut self, msecs: u64) -> PortOne<()> {\n         let (port, chan) = oneshot();\n         let chan = Cell::new(chan);\n \n-        do self.home_for_io |self_| {\n-            self_.action = Some(SendOnce(chan.take()));\n-            self_.start(msecs, 0);\n-        }\n+        let _m = self.fire_missiles();\n+        self.action = Some(SendOnce(chan.take()));\n+        self.start(msecs, 0);\n \n         return port;\n     }\n@@ -92,10 +90,9 @@ impl RtioTimer for TimerWatcher {\n         let (port, chan) = stream();\n         let chan = Cell::new(chan);\n \n-        do self.home_for_io |self_| {\n-            self_.action = Some(SendMany(chan.take()));\n-            self_.start(msecs, msecs);\n-        }\n+        let _m = self.fire_missiles();\n+        self.action = Some(SendMany(chan.take()));\n+        self.start(msecs, msecs);\n \n         return port;\n     }\n@@ -119,11 +116,10 @@ extern fn timer_cb(handle: *uvll::uv_timer_t, _status: c_int) {\n \n impl Drop for TimerWatcher {\n     fn drop(&mut self) {\n-        do self.home_for_io |self_| {\n-            self_.action = None;\n-            self_.stop();\n-            self_.close_async_();\n-        }\n+        let _m = self.fire_missiles();\n+        self.action = None;\n+        self.stop();\n+        self.close_async_();\n     }\n }\n "}, {"sha": "e0ceb954e58cbfa40642d0d3dcb68632b4603ecd", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=6690bcb10178b08c56ad56b111e4dcb7e0e06b36", "patch": "@@ -14,6 +14,7 @@ use std::cast;\n use std::cell::Cell;\n use std::clone::Clone;\n use std::comm::{SharedChan, GenericChan};\n+use std::libc;\n use std::libc::{c_int, c_uint, c_void};\n use std::ptr;\n use std::str;\n@@ -30,9 +31,9 @@ use std::rt::tube::Tube;\n use std::rt::task::Task;\n use std::path::{GenericPath, Path};\n use std::libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY,\n-                O_WRONLY, S_IRUSR, S_IWUSR, S_IRWXU};\n-use std::rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n-                  CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite,\n+                O_WRONLY, S_IRUSR, S_IWUSR};\n+use std::rt::io::{FileMode, FileAccess, Open,\n+                  Append, Truncate, Read, Write, ReadWrite,\n                   FileStat};\n use std::rt::io::signal::Signum;\n use std::task;\n@@ -1224,7 +1225,7 @@ impl UvFileStream {\n         do sched.deschedule_running_task_and_then |_, task| {\n             let task = Cell::new(task);\n             let req = file::FsRequest::new();\n-            do f(self_, req) |_, uverr| {\n+            do f(self, req) |_, uverr| {\n                 let res = match uverr  {\n                     None => Ok(()),\n                     Some(err) => Err(uv_error_to_io_error(err))"}, {"sha": "a32f03732d664ed91285e12ca072c4e52c5ecec3", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6690bcb10178b08c56ad56b111e4dcb7e0e06b36/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=6690bcb10178b08c56ad56b111e4dcb7e0e06b36", "patch": "@@ -724,6 +724,7 @@ extern {\n     fn rust_set_stdio_container_fd(c: *uv_stdio_container_t, fd: c_int);\n     fn rust_set_stdio_container_stream(c: *uv_stdio_container_t,\n                                        stream: *uv_stream_t);\n+    fn rust_uv_process_pid(p: *uv_process_t) -> c_int;\n }\n \n // generic uv functions\n@@ -809,21 +810,25 @@ externfn!(fn uv_fs_readdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n                            flags: c_int, cb: uv_fs_cb) -> c_int)\n externfn!(fn uv_fs_req_cleanup(req: *uv_fs_t))\n externfn!(fn uv_fs_fsync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n-                         cb: *u8) -> c_int)\n+                         cb: uv_fs_cb) -> c_int)\n externfn!(fn uv_fs_fdatasync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n-                             cb: *u8) -> c_int)\n+                             cb: uv_fs_cb) -> c_int)\n externfn!(fn uv_fs_ftruncate(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n-                             offset: i64, cb: *u8) -> c_int)\n+                             offset: i64, cb: uv_fs_cb) -> c_int)\n externfn!(fn uv_fs_readlink(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,\n-                            cb: *u8) -> c_int)\n+                            cb: uv_fs_cb) -> c_int)\n externfn!(fn uv_fs_symlink(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n-                           dst: *c_char, flags: c_int, cb: *u8) -> c_int)\n+                           dst: *c_char, flags: c_int, cb: uv_fs_cb) -> c_int)\n+externfn!(fn uv_fs_rename(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n+                          dst: *c_char, cb: uv_fs_cb) -> c_int)\n externfn!(fn uv_fs_link(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n-                        dst: *c_char, cb: *u8) -> c_int)\n+                        dst: *c_char, cb: uv_fs_cb) -> c_int)\n externfn!(fn uv_fs_chown(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n-                         uid: uv_uid_t, gid: uv_gid_t, cb: *u8) -> c_int)\n+                         uid: uv_uid_t, gid: uv_gid_t, cb: uv_fs_cb) -> c_int)\n+externfn!(fn uv_fs_chmod(handle: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                         mode: c_int, cb: uv_fs_cb) -> c_int)\n externfn!(fn uv_fs_lstat(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,\n-                         cb: *u8) -> c_int)\n+                         cb: uv_fs_cb) -> c_int)\n \n // getaddrinfo\n externfn!(fn uv_getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,"}]}