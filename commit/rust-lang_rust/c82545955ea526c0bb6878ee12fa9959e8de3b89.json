{"sha": "c82545955ea526c0bb6878ee12fa9959e8de3b89", "node_id": "C_kwDOAAsO6NoAKGM4MjU0NTk1NWVhNTI2YzBiYjY4NzhlZTEyZmE5OTU5ZThkZTNiODk", "commit": {"author": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2023-01-07T06:02:59Z"}, "committer": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2023-01-12T12:17:25Z"}, "message": "Provide help on closures capturing self causing borrow checker errors", "tree": {"sha": "1765deacfd8958b9e5f8dc039627318e0354f758", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1765deacfd8958b9e5f8dc039627318e0354f758"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c82545955ea526c0bb6878ee12fa9959e8de3b89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c82545955ea526c0bb6878ee12fa9959e8de3b89", "html_url": "https://github.com/rust-lang/rust/commit/c82545955ea526c0bb6878ee12fa9959e8de3b89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c82545955ea526c0bb6878ee12fa9959e8de3b89/comments", "author": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b8590ef3bd1221830ec8a4131ea9d02b1636746", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b8590ef3bd1221830ec8a4131ea9d02b1636746", "html_url": "https://github.com/rust-lang/rust/commit/2b8590ef3bd1221830ec8a4131ea9d02b1636746"}], "stats": {"total": 257, "additions": 252, "deletions": 5}, "files": [{"sha": "04bbceadd5a5feddad68867fa8252a131f20f562", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 146, "deletions": 4, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/c82545955ea526c0bb6878ee12fa9959e8de3b89/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c82545955ea526c0bb6878ee12fa9959e8de3b89/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=c82545955ea526c0bb6878ee12fa9959e8de3b89", "patch": "@@ -1,4 +1,6 @@\n+use crate::diagnostics::mutability_errors::mut_borrow_of_mutable_ref;\n use either::Either;\n+use hir::Closure;\n use rustc_const_eval::util::CallKind;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n@@ -20,7 +22,7 @@ use rustc_middle::ty::{self, suggest_constraining_type_params, PredicateKind, Ty\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{kw, sym};\n use rustc_span::{BytePos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n \n@@ -39,6 +41,8 @@ use super::{\n     DescribePlaceOpt, RegionName, RegionNameSource, UseSpans,\n };\n \n+use rustc_hir::def::Res;\n+\n #[derive(Debug)]\n struct MoveSite {\n     /// Index of the \"move out\" that we found. The `MoveData` can\n@@ -356,7 +360,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let Some(hir::Node::Item(hir::Item {\n             kind: hir::ItemKind::Fn(_, _, body_id),\n             ..\n-        })) = hir.find(hir.local_def_id_to_hir_id(self.mir_def_id()))\n+        })) = hir.find(self.mir_hir_id())\n             && let Some(hir::Node::Expr(expr)) = hir.find(body_id.hir_id)\n         {\n             let place = &self.move_data.move_paths[mpi].place;\n@@ -948,7 +952,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n             (BorrowKind::Mut { .. }, BorrowKind::Shared) => {\n                 first_borrow_desc = \"immutable \";\n-                self.cannot_reborrow_already_borrowed(\n+                let mut err = self.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     &msg_place,\n@@ -958,7 +962,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     \"immutable\",\n                     &msg_borrow,\n                     None,\n-                )\n+                );\n+                self.suggest_binding_for_closure_capture_self(\n+                    &mut err,\n+                    issued_borrow.borrowed_place,\n+                    &issued_spans,\n+                );\n+                err\n             }\n \n             (BorrowKind::Mut { .. }, BorrowKind::Mut { .. }) => {\n@@ -1240,6 +1250,138 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    fn suggest_binding_for_closure_capture_self(\n+        &self,\n+        err: &mut Diagnostic,\n+        borrowed_place: Place<'tcx>,\n+        issued_spans: &UseSpans<'tcx>,\n+    ) {\n+        let UseSpans::ClosureUse { capture_kind_span, .. } = issued_spans else { return };\n+        let hir = self.infcx.tcx.hir();\n+\n+        // check whether the borrowed place is capturing `self` by mut reference\n+        let local = borrowed_place.local;\n+        let Some(_) = self\n+            .body\n+            .local_decls\n+            .get(local)\n+            .map(|l| mut_borrow_of_mutable_ref(l, self.local_names[local])) else { return };\n+\n+        struct ExpressionFinder<'hir> {\n+            capture_span: Span,\n+            closure_change_spans: Vec<Span>,\n+            closure_arg_span: Option<Span>,\n+            in_closure: bool,\n+            suggest_arg: String,\n+            hir: rustc_middle::hir::map::Map<'hir>,\n+            closure_local_id: Option<hir::HirId>,\n+            closure_call_changes: Vec<(Span, String)>,\n+        }\n+        impl<'hir> Visitor<'hir> for ExpressionFinder<'hir> {\n+            fn visit_expr(&mut self, e: &'hir hir::Expr<'hir>) {\n+                if e.span.contains(self.capture_span) {\n+                    if let hir::ExprKind::Closure(&Closure {\n+                            movability: None,\n+                            body,\n+                            fn_arg_span,\n+                            fn_decl: hir::FnDecl{ inputs, .. },\n+                            ..\n+                        }) = e.kind &&\n+                        let Some(hir::Node::Expr(body )) = self.hir.find(body.hir_id) {\n+                            self.suggest_arg = \"this: &Self\".to_string();\n+                            if inputs.len() > 0 {\n+                                self.suggest_arg.push_str(\", \");\n+                            }\n+                            self.in_closure = true;\n+                            self.closure_arg_span = fn_arg_span;\n+                            self.visit_expr(body);\n+                            self.in_closure = false;\n+                    }\n+                }\n+                if let hir::Expr { kind: hir::ExprKind::Path(path), .. } = e {\n+                    if let hir::QPath::Resolved(_, hir::Path { segments: [seg], ..}) = path &&\n+                        seg.ident.name == kw::SelfLower && self.in_closure {\n+                            self.closure_change_spans.push(e.span);\n+                    }\n+                }\n+                hir::intravisit::walk_expr(self, e);\n+            }\n+\n+            fn visit_local(&mut self, local: &'hir hir::Local<'hir>) {\n+                if let hir::Pat { kind: hir::PatKind::Binding(_, hir_id, _ident, _), .. } = local.pat &&\n+                    let Some(init) = local.init\n+                {\n+                    if let hir::Expr { kind: hir::ExprKind::Closure(&Closure {\n+                            movability: None,\n+                            ..\n+                        }), .. } = init &&\n+                        init.span.contains(self.capture_span) {\n+                            self.closure_local_id = Some(*hir_id);\n+                    }\n+                }\n+                hir::intravisit::walk_local(self, local);\n+            }\n+\n+            fn visit_stmt(&mut self, s: &'hir hir::Stmt<'hir>) {\n+                if let hir::StmtKind::Semi(e) = s.kind &&\n+                    let hir::ExprKind::Call(hir::Expr { kind: hir::ExprKind::Path(path), ..}, args) = e.kind &&\n+                    let hir::QPath::Resolved(_, hir::Path { segments: [seg], ..}) = path &&\n+                    let Res::Local(hir_id) = seg.res &&\n+                        Some(hir_id) == self.closure_local_id {\n+                        let mut arg_str = \"self\".to_string();\n+                        if args.len() > 0 {\n+                            arg_str.push_str(\", \");\n+                        }\n+                        self.closure_call_changes.push((seg.ident.span, arg_str));\n+                }\n+                hir::intravisit::walk_stmt(self, s);\n+            }\n+        }\n+\n+        if let Some(hir::Node::ImplItem(\n+                    hir::ImplItem { kind: hir::ImplItemKind::Fn(_fn_sig, body_id), .. }\n+                )) = hir.find(self.mir_hir_id()) &&\n+            let Some(hir::Node::Expr(expr)) = hir.find(body_id.hir_id) {\n+            let mut finder = ExpressionFinder {\n+                capture_span: *capture_kind_span,\n+                closure_change_spans: vec![],\n+                closure_arg_span: None,\n+                in_closure: false,\n+                suggest_arg: String::new(),\n+                closure_local_id: None,\n+                closure_call_changes: vec![],\n+                hir,\n+            };\n+            finder.visit_expr(expr);\n+\n+            if finder.closure_change_spans.is_empty() || finder.closure_call_changes.is_empty() {\n+                return;\n+            }\n+\n+            let mut sugg = vec![];\n+            let sm = self.infcx.tcx.sess.source_map();\n+\n+            if let Some(span) = finder.closure_arg_span {\n+                sugg.push((sm.next_point(span.shrink_to_lo()).shrink_to_hi(), finder.suggest_arg));\n+            }\n+            for span in finder.closure_change_spans {\n+                sugg.push((span, \"this\".to_string()));\n+            }\n+\n+            for (span, suggest) in finder.closure_call_changes {\n+                if  let Ok(span) = sm.span_extend_while(span, |c| c != '(') {\n+                    sugg.push((sm.next_point(span).shrink_to_hi(), suggest));\n+                }\n+            }\n+\n+            err.multipart_suggestion_verbose(\n+                \"try explicitly pass `&Self` into the Closure as an argument\",\n+                sugg,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n     /// Returns the description of the root place for a conflicting borrow and the full\n     /// descriptions of the places that caused the conflict.\n     ///"}, {"sha": "45b15c2c5bd7062451a9b947584ecacb2f504d0f", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c82545955ea526c0bb6878ee12fa9959e8de3b89/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c82545955ea526c0bb6878ee12fa9959e8de3b89/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=c82545955ea526c0bb6878ee12fa9959e8de3b89", "patch": "@@ -1094,7 +1094,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symbol>) -> bool {\n+pub fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symbol>) -> bool {\n     debug!(\"local_info: {:?}, ty.kind(): {:?}\", local_decl.local_info, local_decl.ty.kind());\n \n     match local_decl.local_info.as_deref() {"}, {"sha": "78e48364bba001ec5bf7f1a4ba78dd9a444fa424", "filename": "tests/ui/suggestions/issue-105761-suggest-self-for-closure.fixed", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c82545955ea526c0bb6878ee12fa9959e8de3b89/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c82545955ea526c0bb6878ee12fa9959e8de3b89/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.fixed?ref=c82545955ea526c0bb6878ee12fa9959e8de3b89", "patch": "@@ -0,0 +1,28 @@\n+//run-rustfix\n+#![allow(unused)]\n+\n+struct S;\n+impl S {\n+    fn foo(&mut self) {\n+        let x = |this: &Self, v: i32| {\n+            this.bar();\n+            this.hel();\n+        };\n+        self.qux(); //~ ERROR cannot borrow `*self` as mutable because it is also borrowed as immutable\n+        x(self, 1);\n+        x(self, 3);\n+    }\n+    fn bar(&self) {}\n+    fn hel(&self) {}\n+    fn qux(&mut self) {}\n+\n+    fn hello(&mut self) {\n+        let y = |this: &Self| {\n+            this.bar();\n+        };\n+        self.qux(); //~ ERROR cannot borrow `*self` as mutable because it is also borrowed as immutable\n+        y(self);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6d8a9ffc12d3938e7a04772f9a8df1897137b5bb", "filename": "tests/ui/suggestions/issue-105761-suggest-self-for-closure.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c82545955ea526c0bb6878ee12fa9959e8de3b89/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c82545955ea526c0bb6878ee12fa9959e8de3b89/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.rs?ref=c82545955ea526c0bb6878ee12fa9959e8de3b89", "patch": "@@ -0,0 +1,28 @@\n+//run-rustfix\n+#![allow(unused)]\n+\n+struct S;\n+impl S {\n+    fn foo(&mut self) {\n+        let x = |v: i32| {\n+            self.bar();\n+            self.hel();\n+        };\n+        self.qux(); //~ ERROR cannot borrow `*self` as mutable because it is also borrowed as immutable\n+        x(1);\n+        x(3);\n+    }\n+    fn bar(&self) {}\n+    fn hel(&self) {}\n+    fn qux(&mut self) {}\n+\n+    fn hello(&mut self) {\n+        let y = || {\n+            self.bar();\n+        };\n+        self.qux(); //~ ERROR cannot borrow `*self` as mutable because it is also borrowed as immutable\n+        y();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "bc97d32ebb6e52e8a76347bc15a4cef75b17749a", "filename": "tests/ui/suggestions/issue-105761-suggest-self-for-closure.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c82545955ea526c0bb6878ee12fa9959e8de3b89/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c82545955ea526c0bb6878ee12fa9959e8de3b89/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.stderr?ref=c82545955ea526c0bb6878ee12fa9959e8de3b89", "patch": "@@ -0,0 +1,49 @@\n+error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable\n+  --> $DIR/issue-105761-suggest-self-for-closure.rs:11:9\n+   |\n+LL |         let x = |v: i32| {\n+   |                 -------- immutable borrow occurs here\n+LL |             self.bar();\n+   |             ---- first borrow occurs due to use of `self` in closure\n+...\n+LL |         self.qux();\n+   |         ^^^^^^^^^^ mutable borrow occurs here\n+LL |         x(1);\n+   |         - immutable borrow later used here\n+   |\n+help: try explicitly pass `&Self` into the Closure as an argument\n+   |\n+LL ~         let x = |this: &Self, v: i32| {\n+LL ~             this.bar();\n+LL ~             this.hel();\n+LL |         };\n+LL |         self.qux();\n+LL ~         x(self, 1);\n+LL ~         x(self, 3);\n+   |\n+\n+error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable\n+  --> $DIR/issue-105761-suggest-self-for-closure.rs:23:9\n+   |\n+LL |         let y = || {\n+   |                 -- immutable borrow occurs here\n+LL |             self.bar();\n+   |             ---- first borrow occurs due to use of `self` in closure\n+LL |         };\n+LL |         self.qux();\n+   |         ^^^^^^^^^^ mutable borrow occurs here\n+LL |         y();\n+   |         - immutable borrow later used here\n+   |\n+help: try explicitly pass `&Self` into the Closure as an argument\n+   |\n+LL ~         let y = |this: &Self| {\n+LL ~             this.bar();\n+LL |         };\n+LL |         self.qux();\n+LL ~         y(self);\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0502`."}]}