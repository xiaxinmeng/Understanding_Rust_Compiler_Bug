{"sha": "c09e14a4ff02f774460a70472e1aeb3c598e01dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwOWUxNGE0ZmYwMmY3NzQ0NjBhNzA0NzJlMWFlYjNjNTk4ZTAxZGM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-31T18:03:00Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-31T18:03:00Z"}, "message": "remove old completion", "tree": {"sha": "8100886e13a79b5c948a0273b761806d3ff57c3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8100886e13a79b5c948a0273b761806d3ff57c3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c09e14a4ff02f774460a70472e1aeb3c598e01dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c09e14a4ff02f774460a70472e1aeb3c598e01dc", "html_url": "https://github.com/rust-lang/rust/commit/c09e14a4ff02f774460a70472e1aeb3c598e01dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c09e14a4ff02f774460a70472e1aeb3c598e01dc/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "html_url": "https://github.com/rust-lang/rust/commit/f3fb59d7077801a3a68d2d03eef17d59c2925ae8"}], "stats": {"total": 1101, "additions": 1, "deletions": 1100}, "files": [{"sha": "20c8546a471b878ff6eee3f3d344cd2f9539b8da", "filename": "crates/ra_editor/src/completion.rs", "status": "removed", "additions": 0, "deletions": 602, "changes": 602, "blob_url": "https://github.com/rust-lang/rust/blob/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_editor%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_editor%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fcompletion.rs?ref=f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "patch": "@@ -1,602 +0,0 @@\n-/// FIXME: move completion from ra_editor to ra_analysis\n-\n-use rustc_hash::{FxHashMap, FxHashSet};\n-\n-use ra_syntax::{\n-    algo::visit::{visitor, visitor_ctx, Visitor, VisitorCtx},\n-    ast::{self, AstChildren, LoopBodyOwner, ModuleItemOwner},\n-    AstNode, File,\n-    SyntaxKind::*,\n-    SyntaxNodeRef, TextUnit,\n-};\n-\n-use crate::{\n-    find_node_at_offset,\n-    scope::{FnScopes, ModuleScope},\n-    AtomEdit,\n-};\n-\n-#[derive(Debug)]\n-pub struct CompletionItem {\n-    /// What user sees in pop-up\n-    pub label: String,\n-    /// What string is used for filtering, defaults to label\n-    pub lookup: Option<String>,\n-    /// What is inserted, defaults to label\n-    pub snippet: Option<String>,\n-}\n-\n-pub fn scope_completion(file: &File, offset: TextUnit) -> Option<Vec<CompletionItem>> {\n-    // Insert a fake ident to get a valid parse tree\n-    let file = {\n-        let edit = AtomEdit::insert(offset, \"intellijRulezz\".to_string());\n-        file.reparse(&edit)\n-    };\n-    let mut has_completions = false;\n-    let mut res = Vec::new();\n-    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), offset) {\n-        has_completions = true;\n-        complete_name_ref(&file, name_ref, &mut res);\n-        // special case, `trait T { fn foo(i_am_a_name_ref) {} }`\n-        if is_node::<ast::Param>(name_ref.syntax()) {\n-            param_completions(name_ref.syntax(), &mut res);\n-        }\n-        let name_range = name_ref.syntax().range();\n-        let top_node = name_ref\n-            .syntax()\n-            .ancestors()\n-            .take_while(|it| it.range() == name_range)\n-            .last()\n-            .unwrap();\n-        match top_node.parent().map(|it| it.kind()) {\n-            Some(ROOT) | Some(ITEM_LIST) => complete_mod_item_snippets(&mut res),\n-            _ => (),\n-        }\n-    }\n-    if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), offset) {\n-        if is_node::<ast::Param>(name.syntax()) {\n-            has_completions = true;\n-            param_completions(name.syntax(), &mut res);\n-        }\n-    }\n-    if has_completions {\n-        Some(res)\n-    } else {\n-        None\n-    }\n-}\n-\n-pub fn complete_module_items(items: AstChildren<ast::ModuleItem>, this_item: Option<ast::NameRef>, acc: &mut Vec<CompletionItem>) {\n-    let scope = ModuleScope::new(items);\n-    acc.extend(\n-        scope\n-            .entries()\n-            .iter()\n-            .filter(|entry| Some(entry.syntax()) != this_item.map(|it| it.syntax()))\n-            .map(|entry| CompletionItem {\n-                label: entry.name().to_string(),\n-                lookup: None,\n-                snippet: None,\n-            }),\n-    );\n-}\n-\n-fn complete_name_ref(file: &File, name_ref: ast::NameRef, acc: &mut Vec<CompletionItem>) {\n-    if !is_node::<ast::Path>(name_ref.syntax()) {\n-        return;\n-    }\n-    let mut visited_fn = false;\n-    for node in name_ref.syntax().ancestors() {\n-        if let Some(items) = visitor()\n-            .visit::<ast::Root, _>(|it| Some(it.items()))\n-            .visit::<ast::Module, _>(|it| Some(it.item_list()?.items()))\n-            .accept(node)\n-        {\n-            if let Some(items) = items {\n-                complete_module_items(items, Some(name_ref), acc);\n-            }\n-            break;\n-        } else if !visited_fn {\n-            if let Some(fn_def) = ast::FnDef::cast(node) {\n-                visited_fn = true;\n-                complete_expr_keywords(&file, fn_def, name_ref, acc);\n-                complete_expr_snippets(acc);\n-                let scopes = FnScopes::new(fn_def);\n-                complete_fn(name_ref, &scopes, acc);\n-            }\n-        }\n-    }\n-}\n-\n-fn param_completions(ctx: SyntaxNodeRef, acc: &mut Vec<CompletionItem>) {\n-    let mut params = FxHashMap::default();\n-    for node in ctx.ancestors() {\n-        let _ = visitor_ctx(&mut params)\n-            .visit::<ast::Root, _>(process)\n-            .visit::<ast::ItemList, _>(process)\n-            .accept(node);\n-    }\n-    params\n-        .into_iter()\n-        .filter_map(|(label, (count, param))| {\n-            let lookup = param.pat()?.syntax().text().to_string();\n-            if count < 2 {\n-                None\n-            } else {\n-                Some((label, lookup))\n-            }\n-        })\n-        .for_each(|(label, lookup)| {\n-            acc.push(CompletionItem {\n-                label,\n-                lookup: Some(lookup),\n-                snippet: None,\n-            })\n-        });\n-\n-    fn process<'a, N: ast::FnDefOwner<'a>>(\n-        node: N,\n-        params: &mut FxHashMap<String, (u32, ast::Param<'a>)>,\n-    ) {\n-        node.functions()\n-            .filter_map(|it| it.param_list())\n-            .flat_map(|it| it.params())\n-            .for_each(|param| {\n-                let text = param.syntax().text().to_string();\n-                params.entry(text).or_insert((0, param)).0 += 1;\n-            })\n-    }\n-}\n-\n-fn is_node<'a, N: AstNode<'a>>(node: SyntaxNodeRef<'a>) -> bool {\n-    match node.ancestors().filter_map(N::cast).next() {\n-        None => false,\n-        Some(n) => n.syntax().range() == node.range(),\n-    }\n-}\n-\n-fn complete_expr_keywords(\n-    file: &File,\n-    fn_def: ast::FnDef,\n-    name_ref: ast::NameRef,\n-    acc: &mut Vec<CompletionItem>,\n-) {\n-    acc.push(keyword(\"if\", \"if $0 {}\"));\n-    acc.push(keyword(\"match\", \"match $0 {}\"));\n-    acc.push(keyword(\"while\", \"while $0 {}\"));\n-    acc.push(keyword(\"loop\", \"loop {$0}\"));\n-\n-    if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n-        if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n-            if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n-                acc.push(keyword(\"else\", \"else {$0}\"));\n-                acc.push(keyword(\"else if\", \"else if $0 {}\"));\n-            }\n-        }\n-    }\n-    if is_in_loop_body(name_ref) {\n-        acc.push(keyword(\"continue\", \"continue\"));\n-        acc.push(keyword(\"break\", \"break\"));\n-    }\n-    acc.extend(complete_return(fn_def, name_ref));\n-}\n-\n-fn is_in_loop_body(name_ref: ast::NameRef) -> bool {\n-    for node in name_ref.syntax().ancestors() {\n-        if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n-            break;\n-        }\n-        let loop_body = visitor()\n-            .visit::<ast::ForExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::WhileExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::LoopExpr, _>(LoopBodyOwner::loop_body)\n-            .accept(node);\n-        if let Some(Some(body)) = loop_body {\n-            if name_ref.syntax().range().is_subrange(&body.syntax().range()) {\n-                return true;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-fn complete_return(fn_def: ast::FnDef, name_ref: ast::NameRef) -> Option<CompletionItem> {\n-    // let is_last_in_block = name_ref.syntax().ancestors().filter_map(ast::Expr::cast)\n-    //     .next()\n-    //     .and_then(|it| it.syntax().parent())\n-    //     .and_then(ast::Block::cast)\n-    //     .is_some();\n-\n-    // if is_last_in_block {\n-    //     return None;\n-    // }\n-\n-    let is_stmt = match name_ref\n-        .syntax()\n-        .ancestors()\n-        .filter_map(ast::ExprStmt::cast)\n-        .next()\n-    {\n-        None => false,\n-        Some(expr_stmt) => expr_stmt.syntax().range() == name_ref.syntax().range(),\n-    };\n-    let snip = match (is_stmt, fn_def.ret_type().is_some()) {\n-        (true, true) => \"return $0;\",\n-        (true, false) => \"return;\",\n-        (false, true) => \"return $0\",\n-        (false, false) => \"return\",\n-    };\n-    Some(keyword(\"return\", snip))\n-}\n-\n-fn keyword(kw: &str, snip: &str) -> CompletionItem {\n-    CompletionItem {\n-        label: kw.to_string(),\n-        lookup: None,\n-        snippet: Some(snip.to_string()),\n-    }\n-}\n-\n-fn complete_expr_snippets(acc: &mut Vec<CompletionItem>) {\n-    acc.push(CompletionItem {\n-        label: \"pd\".to_string(),\n-        lookup: None,\n-        snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\".to_string()),\n-    });\n-    acc.push(CompletionItem {\n-        label: \"ppd\".to_string(),\n-        lookup: None,\n-        snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\".to_string()),\n-    });\n-}\n-\n-fn complete_mod_item_snippets(acc: &mut Vec<CompletionItem>) {\n-    acc.push(CompletionItem {\n-        label: \"tfn\".to_string(),\n-        lookup: None,\n-        snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\".to_string()),\n-    });\n-    acc.push(CompletionItem {\n-        label: \"pub(crate)\".to_string(),\n-        lookup: None,\n-        snippet: Some(\"pub(crate) $0\".to_string()),\n-    })\n-}\n-\n-fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<CompletionItem>) {\n-    let mut shadowed = FxHashSet::default();\n-    acc.extend(\n-        scopes\n-            .scope_chain(name_ref.syntax())\n-            .flat_map(|scope| scopes.entries(scope).iter())\n-            .filter(|entry| shadowed.insert(entry.name()))\n-            .map(|entry| CompletionItem {\n-                label: entry.name().to_string(),\n-                lookup: None,\n-                snippet: None,\n-            }),\n-    );\n-    if scopes.self_param.is_some() {\n-        acc.push(CompletionItem {\n-            label: \"self\".to_string(),\n-            lookup: None,\n-            snippet: None,\n-        })\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use test_utils::{assert_eq_dbg, extract_offset};\n-\n-    fn check_scope_completion(code: &str, expected_completions: &str) {\n-        let (off, code) = extract_offset(&code);\n-        let file = File::parse(&code);\n-        let completions = scope_completion(&file, off)\n-            .unwrap()\n-            .into_iter()\n-            .filter(|c| c.snippet.is_none())\n-            .collect::<Vec<_>>();\n-        assert_eq_dbg(expected_completions, &completions);\n-    }\n-\n-    fn check_snippet_completion(code: &str, expected_completions: &str) {\n-        let (off, code) = extract_offset(&code);\n-        let file = File::parse(&code);\n-        let completions = scope_completion(&file, off)\n-            .unwrap()\n-            .into_iter()\n-            .filter(|c| c.snippet.is_some())\n-            .collect::<Vec<_>>();\n-        assert_eq_dbg(expected_completions, &completions);\n-    }\n-\n-    #[test]\n-    fn test_completion_let_scope() {\n-        check_scope_completion(\n-            r\"\n-            fn quux(x: i32) {\n-                let y = 92;\n-                1 + <|>;\n-                let z = ();\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"y\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"x\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_if_let_scope() {\n-        check_scope_completion(\n-            r\"\n-            fn quux() {\n-                if let Some(x) = foo() {\n-                    let y = 92;\n-                };\n-                if let Some(a) = bar() {\n-                    let b = 62;\n-                    1 + <|>\n-                }\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"b\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"a\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_for_scope() {\n-        check_scope_completion(\n-            r\"\n-            fn quux() {\n-                for x in &[1, 2, 3] {\n-                    <|>\n-                }\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"x\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope() {\n-        check_scope_completion(\n-            r\"\n-            struct Foo;\n-            enum Baz {}\n-            fn quux() {\n-                <|>\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"Baz\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope_no_self_use() {\n-        check_scope_completion(\n-            r\"\n-            use foo<|>;\n-            \",\n-            r#\"[]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope_nested() {\n-        check_scope_completion(\n-            r\"\n-            struct Foo;\n-            mod m {\n-                struct Bar;\n-                fn quux() { <|> }\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"Bar\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_complete_type() {\n-        check_scope_completion(\n-            r\"\n-            struct Foo;\n-            fn x() -> <|>\n-        \",\n-            r#\"[CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n-               CompletionItem { label: \"x\", lookup: None, snippet: None }]\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn test_complete_shadowing() {\n-        check_scope_completion(\n-            r\"\n-            fn foo() -> {\n-                let bar = 92;\n-                {\n-                    let bar = 62;\n-                    <|>\n-                }\n-            }\n-        \",\n-            r#\"[CompletionItem { label: \"bar\", lookup: None, snippet: None },\n-               CompletionItem { label: \"foo\", lookup: None, snippet: None }]\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn test_complete_self() {\n-        check_scope_completion(\n-            r\"\n-            impl S { fn foo(&self) { <|> } }\n-        \",\n-            r#\"[CompletionItem { label: \"self\", lookup: None, snippet: None }]\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn test_completion_kewords() {\n-        check_snippet_completion(r\"\n-            fn quux() {\n-                <|>\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_completion_else() {\n-        check_snippet_completion(r\"\n-            fn quux() {\n-                if true {\n-                    ()\n-                } <|>\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"else\", lookup: None, snippet: Some(\"else {$0}\") },\n-                   CompletionItem { label: \"else if\", lookup: None, snippet: Some(\"else if $0 {}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_completion_return_value() {\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                <|>\n-                92\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0;\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-        check_snippet_completion(r\"\n-            fn quux() {\n-                <|>\n-                92\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return;\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_completion_return_no_stmt() {\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                match () {\n-                    () => <|>\n-                }\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_continue_break_completion() {\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                loop { <|> }\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"continue\", lookup: None, snippet: Some(\"continue\") },\n-                   CompletionItem { label: \"break\", lookup: None, snippet: Some(\"break\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                loop { || { <|> } }\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_param_completion_last_param() {\n-        check_scope_completion(r\"\n-            fn foo(file_id: FileId) {}\n-            fn bar(file_id: FileId) {}\n-            fn baz(file<|>) {}\n-        \", r#\"[CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_param_completion_nth_param() {\n-        check_scope_completion(r\"\n-            fn foo(file_id: FileId) {}\n-            fn bar(file_id: FileId) {}\n-            fn baz(file<|>, x: i32) {}\n-        \", r#\"[CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_param_completion_trait_param() {\n-        check_scope_completion(r\"\n-            pub(crate) trait SourceRoot {\n-                pub fn contains(&self, file_id: FileId) -> bool;\n-                pub fn module_map(&self) -> &ModuleMap;\n-                pub fn lines(&self, file_id: FileId) -> &LineIndex;\n-                pub fn syntax(&self, file<|>)\n-            }\n-        \", r#\"[CompletionItem { label: \"self\", lookup: None, snippet: None },\n-               CompletionItem { label: \"SourceRoot\", lookup: None, snippet: None },\n-               CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_item_snippets() {\n-        // check_snippet_completion(r\"\n-        //     <|>\n-        //     \",\n-        //     r##\"[CompletionItem { label: \"tfn\", lookup: None, snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\") }]\"##,\n-        // );\n-        check_snippet_completion(r\"\n-            #[cfg(test)]\n-            mod tests {\n-                <|>\n-            }\n-            \",\n-            r##\"[CompletionItem { label: \"tfn\", lookup: None, snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\") },\n-                 CompletionItem { label: \"pub(crate)\", lookup: None, snippet: Some(\"pub(crate) $0\") }]\"##,\n-        );\n-    }\n-}"}, {"sha": "02a1b2d45c4c628a36be05217d9f1acb9a5cdc9f", "filename": "crates/ra_editor/src/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c09e14a4ff02f774460a70472e1aeb3c598e01dc/crates%2Fra_editor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09e14a4ff02f774460a70472e1aeb3c598e01dc/crates%2Fra_editor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Flib.rs?ref=c09e14a4ff02f774460a70472e1aeb3c598e01dc", "patch": "@@ -8,20 +8,17 @@ extern crate superslice;\n extern crate test_utils as _test_utils;\n \n mod code_actions;\n-mod completion;\n mod edit;\n mod extend_selection;\n mod folding_ranges;\n mod line_index;\n-mod scope;\n mod symbols;\n #[cfg(test)]\n mod test_utils;\n mod typing;\n \n pub use self::{\n     code_actions::{add_derive, add_impl, flip_comma, introduce_variable, LocalEdit},\n-    completion::{scope_completion, complete_module_items, CompletionItem},\n     edit::{Edit, EditBuilder},\n     extend_selection::extend_selection,\n     folding_ranges::{folding_ranges, Fold, FoldKind},\n@@ -33,7 +30,7 @@ pub use ra_syntax::AtomEdit;\n use ra_syntax::{\n     algo::find_leaf_at_offset,\n     ast::{self, AstNode, NameOwner},\n-    File, SmolStr,\n+    File,\n     SyntaxKind::{self, *},\n     SyntaxNodeRef, TextRange, TextUnit,\n };"}, {"sha": "4cb1f077cc573cb5ac16742fdf637f12a4a11bf4", "filename": "crates/ra_editor/src/scope/fn_scope.rs", "status": "removed", "additions": 0, "deletions": 363, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_editor%2Fsrc%2Fscope%2Ffn_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_editor%2Fsrc%2Fscope%2Ffn_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fscope%2Ffn_scope.rs?ref=f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "patch": "@@ -1,363 +0,0 @@\n-use std::fmt;\n-\n-use rustc_hash::FxHashMap;\n-\n-use ra_syntax::{\n-    algo::generate,\n-    ast::{self, ArgListOwner, LoopBodyOwner, NameOwner},\n-    AstNode, SmolStr, SyntaxNode, SyntaxNodeRef,\n-};\n-\n-type ScopeId = usize;\n-\n-#[derive(Debug)]\n-pub struct FnScopes {\n-    pub self_param: Option<SyntaxNode>,\n-    scopes: Vec<ScopeData>,\n-    scope_for: FxHashMap<SyntaxNode, ScopeId>,\n-}\n-\n-impl FnScopes {\n-    pub fn new(fn_def: ast::FnDef) -> FnScopes {\n-        let mut scopes = FnScopes {\n-            self_param: fn_def\n-                .param_list()\n-                .and_then(|it| it.self_param())\n-                .map(|it| it.syntax().owned()),\n-            scopes: Vec::new(),\n-            scope_for: FxHashMap::default(),\n-        };\n-        let root = scopes.root_scope();\n-        scopes.add_params_bindings(root, fn_def.param_list());\n-        if let Some(body) = fn_def.body() {\n-            compute_block_scopes(body, &mut scopes, root)\n-        }\n-        scopes\n-    }\n-    pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n-        &self.scopes[scope].entries\n-    }\n-    pub fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item = ScopeId> + 'a {\n-        generate(self.scope_for(node), move |&scope| {\n-            self.scopes[scope].parent\n-        })\n-    }\n-    fn root_scope(&mut self) -> ScopeId {\n-        let res = self.scopes.len();\n-        self.scopes.push(ScopeData {\n-            parent: None,\n-            entries: vec![],\n-        });\n-        res\n-    }\n-    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n-        let res = self.scopes.len();\n-        self.scopes.push(ScopeData {\n-            parent: Some(parent),\n-            entries: vec![],\n-        });\n-        res\n-    }\n-    fn add_bindings(&mut self, scope: ScopeId, pat: ast::Pat) {\n-        let entries = pat\n-            .syntax()\n-            .descendants()\n-            .filter_map(ast::BindPat::cast)\n-            .filter_map(ScopeEntry::new);\n-        self.scopes[scope].entries.extend(entries);\n-    }\n-    fn add_params_bindings(&mut self, scope: ScopeId, params: Option<ast::ParamList>) {\n-        params\n-            .into_iter()\n-            .flat_map(|it| it.params())\n-            .filter_map(|it| it.pat())\n-            .for_each(|it| self.add_bindings(scope, it));\n-    }\n-    fn set_scope(&mut self, node: SyntaxNodeRef, scope: ScopeId) {\n-        self.scope_for.insert(node.owned(), scope);\n-    }\n-    fn scope_for(&self, node: SyntaxNodeRef) -> Option<ScopeId> {\n-        node.ancestors()\n-            .filter_map(|it| self.scope_for.get(&it.owned()).map(|&scope| scope))\n-            .next()\n-    }\n-}\n-\n-#[derive(PartialEq, Eq)]\n-pub struct ScopeEntry {\n-    syntax: SyntaxNode,\n-}\n-\n-impl ScopeEntry {\n-    fn new(pat: ast::BindPat) -> Option<ScopeEntry> {\n-        if pat.name().is_some() {\n-            Some(ScopeEntry {\n-                syntax: pat.syntax().owned(),\n-            })\n-        } else {\n-            None\n-        }\n-    }\n-    pub fn name(&self) -> SmolStr {\n-        self.ast().name().unwrap().text()\n-    }\n-    pub fn ast(&self) -> ast::BindPat {\n-        ast::BindPat::cast(self.syntax.borrowed()).unwrap()\n-    }\n-}\n-\n-impl fmt::Debug for ScopeEntry {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"ScopeEntry\")\n-            .field(\"name\", &self.name())\n-            .field(\"syntax\", &self.syntax)\n-            .finish()\n-    }\n-}\n-\n-fn compute_block_scopes(block: ast::Block, scopes: &mut FnScopes, mut scope: ScopeId) {\n-    for stmt in block.statements() {\n-        match stmt {\n-            ast::Stmt::LetStmt(stmt) => {\n-                if let Some(expr) = stmt.initializer() {\n-                    scopes.set_scope(expr.syntax(), scope);\n-                    compute_expr_scopes(expr, scopes, scope);\n-                }\n-                scope = scopes.new_scope(scope);\n-                if let Some(pat) = stmt.pat() {\n-                    scopes.add_bindings(scope, pat);\n-                }\n-            }\n-            ast::Stmt::ExprStmt(expr_stmt) => {\n-                if let Some(expr) = expr_stmt.expr() {\n-                    scopes.set_scope(expr.syntax(), scope);\n-                    compute_expr_scopes(expr, scopes, scope);\n-                }\n-            }\n-        }\n-    }\n-    if let Some(expr) = block.expr() {\n-        scopes.set_scope(expr.syntax(), scope);\n-        compute_expr_scopes(expr, scopes, scope);\n-    }\n-}\n-\n-fn compute_expr_scopes(expr: ast::Expr, scopes: &mut FnScopes, scope: ScopeId) {\n-    match expr {\n-        ast::Expr::IfExpr(e) => {\n-            let cond_scope = e\n-                .condition()\n-                .and_then(|cond| compute_cond_scopes(cond, scopes, scope));\n-            if let Some(block) = e.then_branch() {\n-                compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n-            }\n-            if let Some(block) = e.else_branch() {\n-                compute_block_scopes(block, scopes, scope);\n-            }\n-        }\n-        ast::Expr::BlockExpr(e) => {\n-            if let Some(block) = e.block() {\n-                compute_block_scopes(block, scopes, scope);\n-            }\n-        }\n-        ast::Expr::LoopExpr(e) => {\n-            if let Some(block) = e.loop_body() {\n-                compute_block_scopes(block, scopes, scope);\n-            }\n-        }\n-        ast::Expr::WhileExpr(e) => {\n-            let cond_scope = e\n-                .condition()\n-                .and_then(|cond| compute_cond_scopes(cond, scopes, scope));\n-            if let Some(block) = e.loop_body() {\n-                compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n-            }\n-        }\n-        ast::Expr::ForExpr(e) => {\n-            if let Some(expr) = e.iterable() {\n-                compute_expr_scopes(expr, scopes, scope);\n-            }\n-            let mut scope = scope;\n-            if let Some(pat) = e.pat() {\n-                scope = scopes.new_scope(scope);\n-                scopes.add_bindings(scope, pat);\n-            }\n-            if let Some(block) = e.loop_body() {\n-                compute_block_scopes(block, scopes, scope);\n-            }\n-        }\n-        ast::Expr::LambdaExpr(e) => {\n-            let scope = scopes.new_scope(scope);\n-            scopes.add_params_bindings(scope, e.param_list());\n-            if let Some(body) = e.body() {\n-                scopes.set_scope(body.syntax(), scope);\n-                compute_expr_scopes(body, scopes, scope);\n-            }\n-        }\n-        ast::Expr::CallExpr(e) => {\n-            compute_call_scopes(e.expr(), e.arg_list(), scopes, scope);\n-        }\n-        ast::Expr::MethodCallExpr(e) => {\n-            compute_call_scopes(e.expr(), e.arg_list(), scopes, scope);\n-        }\n-        ast::Expr::MatchExpr(e) => {\n-            if let Some(expr) = e.expr() {\n-                compute_expr_scopes(expr, scopes, scope);\n-            }\n-            for arm in e.match_arm_list().into_iter().flat_map(|it| it.arms()) {\n-                let scope = scopes.new_scope(scope);\n-                for pat in arm.pats() {\n-                    scopes.add_bindings(scope, pat);\n-                }\n-                if let Some(expr) = arm.expr() {\n-                    compute_expr_scopes(expr, scopes, scope);\n-                }\n-            }\n-        }\n-        _ => expr\n-            .syntax()\n-            .children()\n-            .filter_map(ast::Expr::cast)\n-            .for_each(|expr| compute_expr_scopes(expr, scopes, scope)),\n-    };\n-\n-    fn compute_call_scopes(\n-        receiver: Option<ast::Expr>,\n-        arg_list: Option<ast::ArgList>,\n-        scopes: &mut FnScopes,\n-        scope: ScopeId,\n-    ) {\n-        arg_list\n-            .into_iter()\n-            .flat_map(|it| it.args())\n-            .chain(receiver)\n-            .for_each(|expr| compute_expr_scopes(expr, scopes, scope));\n-    }\n-\n-    fn compute_cond_scopes(\n-        cond: ast::Condition,\n-        scopes: &mut FnScopes,\n-        scope: ScopeId,\n-    ) -> Option<ScopeId> {\n-        if let Some(expr) = cond.expr() {\n-            compute_expr_scopes(expr, scopes, scope);\n-        }\n-        if let Some(pat) = cond.pat() {\n-            let s = scopes.new_scope(scope);\n-            scopes.add_bindings(s, pat);\n-            Some(s)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-struct ScopeData {\n-    parent: Option<ScopeId>,\n-    entries: Vec<ScopeEntry>,\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use crate::{find_node_at_offset, test_utils::extract_offset};\n-    use ra_syntax::File;\n-\n-    fn do_check(code: &str, expected: &[&str]) {\n-        let (off, code) = extract_offset(code);\n-        let code = {\n-            let mut buf = String::new();\n-            let off = u32::from(off) as usize;\n-            buf.push_str(&code[..off]);\n-            buf.push_str(\"marker\");\n-            buf.push_str(&code[off..]);\n-            buf\n-        };\n-        let file = File::parse(&code);\n-        let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n-        let fn_def: ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n-        let scopes = FnScopes::new(fn_def);\n-        let actual = scopes\n-            .scope_chain(marker.syntax())\n-            .flat_map(|scope| scopes.entries(scope))\n-            .map(|it| it.name())\n-            .collect::<Vec<_>>();\n-        assert_eq!(actual.as_slice(), expected);\n-    }\n-\n-    #[test]\n-    fn test_lambda_scope() {\n-        do_check(\n-            r\"\n-            fn quux(foo: i32) {\n-                let f = |bar, baz: i32| {\n-                    <|>\n-                };\n-            }\",\n-            &[\"bar\", \"baz\", \"foo\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_call_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                f(|x| <|> );\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_metod_call_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                z.f(|x| <|> );\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_loop_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                loop {\n-                    let x = ();\n-                    <|>\n-                };\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_match() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                match () {\n-                    Some(x) => {\n-                        <|>\n-                    }\n-                };\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_shadow_variable() {\n-        do_check(\n-            r\"\n-            fn foo(x: String) {\n-                let x : &str = &x<|>;\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-}"}, {"sha": "483f5e63cc64d7db10155640abcd01098849a5c7", "filename": "crates/ra_editor/src/scope/mod.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod.rs?ref=f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "patch": "@@ -1,7 +0,0 @@\n-mod fn_scope;\n-mod mod_scope;\n-\n-pub use self::{\n-    fn_scope::{FnScopes},\n-    mod_scope::ModuleScope,\n-};"}, {"sha": "818749a1258f17ce8dcbfd2a495ac410f21222f3", "filename": "crates/ra_editor/src/scope/mod_scope.rs", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod_scope.rs?ref=f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "patch": "@@ -1,124 +0,0 @@\n-/// FIXME: this is now moved to ra_analysis::descriptors::module::scope.\n-///\n-/// Current copy will be deleted as soon as we move the rest of the completion\n-/// to the analyezer.\n-\n-\n-use ra_syntax::{\n-    ast::{self, AstChildren},\n-    AstNode, SmolStr, SyntaxNode, SyntaxNodeRef,\n-};\n-\n-pub struct ModuleScope {\n-    entries: Vec<Entry>,\n-}\n-\n-pub struct Entry {\n-    node: SyntaxNode,\n-    kind: EntryKind,\n-}\n-\n-enum EntryKind {\n-    Item,\n-    Import,\n-}\n-\n-impl ModuleScope {\n-    pub fn new(items: AstChildren<ast::ModuleItem>) -> ModuleScope {\n-        let mut entries = Vec::new();\n-        for item in items {\n-            let entry = match item {\n-                ast::ModuleItem::StructDef(item) => Entry::new_item(item),\n-                ast::ModuleItem::EnumDef(item) => Entry::new_item(item),\n-                ast::ModuleItem::FnDef(item) => Entry::new_item(item),\n-                ast::ModuleItem::ConstDef(item) => Entry::new_item(item),\n-                ast::ModuleItem::StaticDef(item) => Entry::new_item(item),\n-                ast::ModuleItem::TraitDef(item) => Entry::new_item(item),\n-                ast::ModuleItem::TypeDef(item) => Entry::new_item(item),\n-                ast::ModuleItem::Module(item) => Entry::new_item(item),\n-                ast::ModuleItem::UseItem(item) => {\n-                    if let Some(tree) = item.use_tree() {\n-                        collect_imports(tree, &mut entries);\n-                    }\n-                    continue;\n-                }\n-                ast::ModuleItem::ExternCrateItem(_) | ast::ModuleItem::ImplItem(_) => continue,\n-            };\n-            entries.extend(entry)\n-        }\n-\n-        ModuleScope { entries }\n-    }\n-\n-    pub fn entries(&self) -> &[Entry] {\n-        self.entries.as_slice()\n-    }\n-}\n-\n-impl Entry {\n-    fn new_item<'a>(item: impl ast::NameOwner<'a>) -> Option<Entry> {\n-        let name = item.name()?;\n-        Some(Entry {\n-            node: name.syntax().owned(),\n-            kind: EntryKind::Item,\n-        })\n-    }\n-    fn new_import(path: ast::Path) -> Option<Entry> {\n-        let name_ref = path.segment()?.name_ref()?;\n-        Some(Entry {\n-            node: name_ref.syntax().owned(),\n-            kind: EntryKind::Import,\n-        })\n-    }\n-    pub fn name(&self) -> SmolStr {\n-        match self.kind {\n-            EntryKind::Item => ast::Name::cast(self.node.borrowed()).unwrap().text(),\n-            EntryKind::Import => ast::NameRef::cast(self.node.borrowed()).unwrap().text(),\n-        }\n-    }\n-    pub fn syntax(&self) -> SyntaxNodeRef {\n-        self.node.borrowed()\n-    }\n-}\n-\n-fn collect_imports(tree: ast::UseTree, acc: &mut Vec<Entry>) {\n-    if let Some(use_tree_list) = tree.use_tree_list() {\n-        return use_tree_list\n-            .use_trees()\n-            .for_each(|it| collect_imports(it, acc));\n-    }\n-    if let Some(path) = tree.path() {\n-        acc.extend(Entry::new_import(path));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use ra_syntax::{ast::ModuleItemOwner, File};\n-\n-    fn do_check(code: &str, expected: &[&str]) {\n-        let file = File::parse(&code);\n-        let scope = ModuleScope::new(file.ast().items());\n-        let actual = scope.entries.iter().map(|it| it.name()).collect::<Vec<_>>();\n-        assert_eq!(expected, actual.as_slice());\n-    }\n-\n-    #[test]\n-    fn test_module_scope() {\n-        do_check(\n-            \"\n-            struct Foo;\n-            enum Bar {}\n-            mod baz {}\n-            fn quux() {}\n-            use x::{\n-                y::z,\n-                t,\n-            };\n-            type T = ();\n-        \",\n-            &[\"Foo\", \"Bar\", \"baz\", \"quux\", \"z\", \"t\", \"T\"],\n-        )\n-    }\n-}"}]}