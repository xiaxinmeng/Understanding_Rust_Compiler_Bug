{"sha": "7f22b1c58a0b2d5051c45283a88ea101d66e75ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMjJiMWM1OGEwYjJkNTA1MWM0NTI4M2E4OGVhMTAxZDY2ZTc1ZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-04T00:43:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-04T00:43:00Z"}, "message": "Auto merge of #6394 - nico-abram:unsafe_sizeof_count_copies, r=ebroto\n\nAdd lint size_of_in_element_count\n\nFixes #6381\nchangelog: Add lint to check for using size_of::<T> or size_of_val::<T> in the count parameter to ptr::copy or ptr::copy_nonoverlapping, which take a count of Ts (And not a count of bytes)\n\n- \\[X] Followed [lint naming conventions][lint_naming]\n- \\[X] Added passing UI tests (including committed `.stderr` file)\n- \\[ ] `cargo test` passes locally\n- \\[X] Executed `cargo dev update_lints`\n- \\[X] Added lint documentation\n- \\[X] Run `cargo dev fmt`\n\n[lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n\nRunning `cargo test` locally fails with this error:\n\n```\nrunning 1 test\ntest fmt ... FAILED\n\nfailures:\n\n---- fmt stdout ----\nstatus: exit code: 1\nstdout:\nstderr: error: unable to unlink old fallback exe\nerror: caused by: Access is denied. (os error 5)\n\nthread 'fmt' panicked at 'Formatting check failed. Run `cargo dev fmt` to update formatting.', tests\\fmt.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\nfailures:\n    fmt\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n```\n\nBut I did run `cargo dev fmt`", "tree": {"sha": "e2728ea2ddb8c10755e8b868f9b4bc50a80bb25b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2728ea2ddb8c10755e8b868f9b4bc50a80bb25b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f22b1c58a0b2d5051c45283a88ea101d66e75ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f22b1c58a0b2d5051c45283a88ea101d66e75ef", "html_url": "https://github.com/rust-lang/rust/commit/7f22b1c58a0b2d5051c45283a88ea101d66e75ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f22b1c58a0b2d5051c45283a88ea101d66e75ef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "249b6fee9120efb6d6bb8f559524c478b2ab4b74", "url": "https://api.github.com/repos/rust-lang/rust/commits/249b6fee9120efb6d6bb8f559524c478b2ab4b74", "html_url": "https://github.com/rust-lang/rust/commit/249b6fee9120efb6d6bb8f559524c478b2ab4b74"}, {"sha": "c1a5329475d041dbeb077ecda6ae71f690b4bcc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1a5329475d041dbeb077ecda6ae71f690b4bcc1", "html_url": "https://github.com/rust-lang/rust/commit/c1a5329475d041dbeb077ecda6ae71f690b4bcc1"}], "stats": {"total": 418, "additions": 418, "deletions": 0}, "files": [{"sha": "c7e02aaf4e188762a3dd12f87409458bb2596ca2", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f22b1c58a0b2d5051c45283a88ea101d66e75ef/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/7f22b1c58a0b2d5051c45283a88ea101d66e75ef/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=7f22b1c58a0b2d5051c45283a88ea101d66e75ef", "patch": "@@ -2057,6 +2057,7 @@ Released 2018-09-13\n [`single_element_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_element_loop\n [`single_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match\n [`single_match_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match_else\n+[`size_of_in_element_count`]: https://rust-lang.github.io/rust-clippy/master/index.html#size_of_in_element_count\n [`skip_while_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#skip_while_next\n [`slow_vector_initialization`]: https://rust-lang.github.io/rust-clippy/master/index.html#slow_vector_initialization\n [`stable_sort_primitive`]: https://rust-lang.github.io/rust-clippy/master/index.html#stable_sort_primitive"}, {"sha": "4ef595bcffd9992f10ea5f38c3bd1c32b2cf6814", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f22b1c58a0b2d5051c45283a88ea101d66e75ef/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f22b1c58a0b2d5051c45283a88ea101d66e75ef/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=7f22b1c58a0b2d5051c45283a88ea101d66e75ef", "patch": "@@ -306,6 +306,7 @@ mod self_assignment;\n mod serde_api;\n mod shadow;\n mod single_component_path_imports;\n+mod size_of_in_element_count;\n mod slow_vector_initialization;\n mod stable_sort_primitive;\n mod strings;\n@@ -847,6 +848,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &shadow::SHADOW_SAME,\n         &shadow::SHADOW_UNRELATED,\n         &single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS,\n+        &size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT,\n         &slow_vector_initialization::SLOW_VECTOR_INITIALIZATION,\n         &stable_sort_primitive::STABLE_SORT_PRIMITIVE,\n         &strings::STRING_ADD,\n@@ -998,6 +1000,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box matches::Matches::new(msrv));\n     store.register_early_pass(move || box manual_non_exhaustive::ManualNonExhaustive::new(msrv));\n     store.register_late_pass(move || box manual_strip::ManualStrip::new(msrv));\n+    store.register_late_pass(|| box size_of_in_element_count::SizeOfInElementCount);\n     store.register_late_pass(|| box map_clone::MapClone);\n     store.register_late_pass(|| box map_err_ignore::MapErrIgnore);\n     store.register_late_pass(|| box shadow::Shadow);\n@@ -1559,6 +1562,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&self_assignment::SELF_ASSIGNMENT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n+        LintId::of(&size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n         LintId::of(&slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n         LintId::of(&stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n         LintId::of(&strings::STRING_FROM_UTF8_AS_BYTES),\n@@ -1868,6 +1872,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&regex::INVALID_REGEX),\n         LintId::of(&self_assignment::SELF_ASSIGNMENT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n+        LintId::of(&size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n         LintId::of(&swap::ALMOST_SWAPPED),"}, {"sha": "210cf5773e1cd43fb600a5f767f7fc50c389a637", "filename": "clippy_lints/src/size_of_in_element_count.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/7f22b1c58a0b2d5051c45283a88ea101d66e75ef/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f22b1c58a0b2d5051c45283a88ea101d66e75ef/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs?ref=7f22b1c58a0b2d5051c45283a88ea101d66e75ef", "patch": "@@ -0,0 +1,146 @@\n+//! Lint on use of `size_of` or `size_of_val` of T in an expression\n+//! expecting a count of T\n+\n+use crate::utils::{match_def_path, paths, span_lint_and_help};\n+use if_chain::if_chain;\n+use rustc_hir::BinOpKind;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, Ty, TyS, TypeAndMut};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Detects expressions where\n+    /// size_of::<T> or size_of_val::<T> is used as a\n+    /// count of elements of type T\n+    ///\n+    /// **Why is this bad?** These functions expect a count\n+    /// of T and not a number of bytes\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,no_run\n+    /// # use std::ptr::copy_nonoverlapping;\n+    /// # use std::mem::size_of;\n+    ///\n+    /// const SIZE: usize = 128;\n+    /// let x = [2u8; SIZE];\n+    /// let mut y = [2u8; SIZE];\n+    /// unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+    /// ```\n+    pub SIZE_OF_IN_ELEMENT_COUNT,\n+    correctness,\n+    \"using size_of::<T> or size_of_val::<T> where a count of elements of T is expected\"\n+}\n+\n+declare_lint_pass!(SizeOfInElementCount => [SIZE_OF_IN_ELEMENT_COUNT]);\n+\n+fn get_size_of_ty(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<Ty<'tcx>> {\n+    match expr.kind {\n+        ExprKind::Call(count_func, _func_args) => {\n+            if_chain! {\n+                if let ExprKind::Path(ref count_func_qpath) = count_func.kind;\n+                if let Some(def_id) = cx.qpath_res(count_func_qpath, count_func.hir_id).opt_def_id();\n+                if match_def_path(cx, def_id, &paths::MEM_SIZE_OF)\n+                    || match_def_path(cx, def_id, &paths::MEM_SIZE_OF_VAL);\n+                then {\n+                    cx.typeck_results().node_substs(count_func.hir_id).types().next()\n+                } else {\n+                    None\n+                }\n+            }\n+        },\n+        ExprKind::Binary(op, left, right) if BinOpKind::Mul == op.node || BinOpKind::Div == op.node => {\n+            get_size_of_ty(cx, left).or_else(|| get_size_of_ty(cx, right))\n+        },\n+        ExprKind::Cast(expr, _) => get_size_of_ty(cx, expr),\n+        _ => None,\n+    }\n+}\n+\n+fn get_pointee_ty_and_count_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<(Ty<'tcx>, &'tcx Expr<'tcx>)> {\n+    const FUNCTIONS: [&[&str]; 8] = [\n+        &paths::COPY_NONOVERLAPPING,\n+        &paths::COPY,\n+        &paths::WRITE_BYTES,\n+        &paths::PTR_SWAP_NONOVERLAPPING,\n+        &paths::PTR_SLICE_FROM_RAW_PARTS,\n+        &paths::PTR_SLICE_FROM_RAW_PARTS_MUT,\n+        &paths::SLICE_FROM_RAW_PARTS,\n+        &paths::SLICE_FROM_RAW_PARTS_MUT,\n+    ];\n+    const METHODS: [&str; 11] = [\n+        \"write_bytes\",\n+        \"copy_to\",\n+        \"copy_from\",\n+        \"copy_to_nonoverlapping\",\n+        \"copy_from_nonoverlapping\",\n+        \"add\",\n+        \"wrapping_add\",\n+        \"sub\",\n+        \"wrapping_sub\",\n+        \"offset\",\n+        \"wrapping_offset\",\n+    ];\n+\n+    if_chain! {\n+        // Find calls to ptr::{copy, copy_nonoverlapping}\n+        // and ptr::{swap_nonoverlapping, write_bytes},\n+        if let ExprKind::Call(func, [.., count]) = expr.kind;\n+        if let ExprKind::Path(ref func_qpath) = func.kind;\n+        if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n+        if FUNCTIONS.iter().any(|func_path| match_def_path(cx, def_id, func_path));\n+\n+        // Get the pointee type\n+        if let Some(pointee_ty) = cx.typeck_results().node_substs(func.hir_id).types().next();\n+        then {\n+            return Some((pointee_ty, count));\n+        }\n+    };\n+    if_chain! {\n+        // Find calls to copy_{from,to}{,_nonoverlapping} and write_bytes methods\n+        if let ExprKind::MethodCall(method_path, _, [ptr_self, .., count], _) = expr.kind;\n+        let method_ident = method_path.ident.as_str();\n+        if METHODS.iter().any(|m| *m == &*method_ident);\n+\n+        // Get the pointee type\n+        if let ty::RawPtr(TypeAndMut { ty: pointee_ty, .. }) =\n+            cx.typeck_results().expr_ty(ptr_self).kind();\n+        then {\n+            return Some((pointee_ty, count));\n+        }\n+    };\n+    None\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for SizeOfInElementCount {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        const HELP_MSG: &str = \"use a count of elements instead of a count of bytes\\\n+            , it already gets multiplied by the size of the type\";\n+\n+        const LINT_MSG: &str = \"found a count of bytes \\\n+             instead of a count of elements of T\";\n+\n+        if_chain! {\n+            // Find calls to functions with an element count parameter and get\n+            // the pointee type and count parameter expression\n+            if let Some((pointee_ty, count_expr)) = get_pointee_ty_and_count_expr(cx, expr);\n+\n+            // Find a size_of call in the count parameter expression and\n+            // check that it's the same type\n+            if let Some(ty_used_for_size_of) = get_size_of_ty(cx, count_expr);\n+            if TyS::same_type(pointee_ty, ty_used_for_size_of);\n+            then {\n+                span_lint_and_help(\n+                    cx,\n+                    SIZE_OF_IN_ELEMENT_COUNT,\n+                    count_expr.span,\n+                    LINT_MSG,\n+                    None,\n+                    HELP_MSG\n+                );\n+            }\n+        };\n+    }\n+}"}, {"sha": "6fdc7b4587f049c207f4fff45760fd5cd3e17419", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f22b1c58a0b2d5051c45283a88ea101d66e75ef/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f22b1c58a0b2d5051c45283a88ea101d66e75ef/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=7f22b1c58a0b2d5051c45283a88ea101d66e75ef", "patch": "@@ -20,6 +20,8 @@ pub const CLONE_TRAIT: [&str; 3] = [\"core\", \"clone\", \"Clone\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&str; 3] = [\"core\", \"cmp\", \"min\"];\n+pub const COPY: [&str; 3] = [\"core\", \"intrinsics\", \"copy_nonoverlapping\"];\n+pub const COPY_NONOVERLAPPING: [&str; 3] = [\"core\", \"intrinsics\", \"copy\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n pub const CSTRING_AS_C_STR: [&str; 5] = [\"std\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n pub const DEFAULT_TRAIT: [&str; 3] = [\"core\", \"default\", \"Default\"];\n@@ -73,6 +75,8 @@ pub const MEM_MANUALLY_DROP: [&str; 4] = [\"core\", \"mem\", \"manually_drop\", \"Manua\n pub const MEM_MAYBEUNINIT: [&str; 4] = [\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\"];\n pub const MEM_MAYBEUNINIT_UNINIT: [&str; 5] = [\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\", \"uninit\"];\n pub const MEM_REPLACE: [&str; 3] = [\"core\", \"mem\", \"replace\"];\n+pub const MEM_SIZE_OF: [&str; 3] = [\"core\", \"mem\", \"size_of\"];\n+pub const MEM_SIZE_OF_VAL: [&str; 3] = [\"core\", \"mem\", \"size_of_val\"];\n pub const MUTEX_GUARD: [&str; 4] = [\"std\", \"sync\", \"mutex\", \"MutexGuard\"];\n pub const OPEN_OPTIONS: [&str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n pub const OPS_MODULE: [&str; 2] = [\"core\", \"ops\"];\n@@ -100,6 +104,9 @@ pub const POLL_READY: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Ready\"];\n pub const PTR_EQ: [&str; 3] = [\"core\", \"ptr\", \"eq\"];\n pub const PTR_NULL: [&str; 3] = [\"core\", \"ptr\", \"null\"];\n pub const PTR_NULL_MUT: [&str; 3] = [\"core\", \"ptr\", \"null_mut\"];\n+pub const PTR_SLICE_FROM_RAW_PARTS: [&str; 3] = [\"core\", \"ptr\", \"slice_from_raw_parts\"];\n+pub const PTR_SLICE_FROM_RAW_PARTS_MUT: [&str; 3] = [\"core\", \"ptr\", \"slice_from_raw_parts_mut\"];\n+pub const PTR_SWAP_NONOVERLAPPING: [&str; 3] = [\"core\", \"ptr\", \"swap_nonoverlapping\"];\n pub const PUSH_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"push_str\"];\n pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n@@ -121,6 +128,8 @@ pub const RWLOCK_READ_GUARD: [&str; 4] = [\"std\", \"sync\", \"rwlock\", \"RwLockReadGu\n pub const RWLOCK_WRITE_GUARD: [&str; 4] = [\"std\", \"sync\", \"rwlock\", \"RwLockWriteGuard\"];\n pub const SERDE_DESERIALIZE: [&str; 3] = [\"serde\", \"de\", \"Deserialize\"];\n pub const SERDE_DE_VISITOR: [&str; 3] = [\"serde\", \"de\", \"Visitor\"];\n+pub const SLICE_FROM_RAW_PARTS: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_parts\"];\n+pub const SLICE_FROM_RAW_PARTS_MUT: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_parts_mut\"];\n pub const SLICE_INTO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"into_vec\"];\n pub const SLICE_ITER: [&str; 4] = [\"core\", \"slice\", \"iter\", \"Iter\"];\n pub const STDERR: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stderr\"];\n@@ -154,3 +163,4 @@ pub const VEC_NEW: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"new\"];\n pub const VEC_RESIZE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"resize\"];\n pub const WEAK_ARC: [&str; 3] = [\"alloc\", \"sync\", \"Weak\"];\n pub const WEAK_RC: [&str; 3] = [\"alloc\", \"rc\", \"Weak\"];\n+pub const WRITE_BYTES: [&str; 3] = [\"core\", \"intrinsics\", \"write_bytes\"];"}, {"sha": "b13e390705ab79e96317b57375dff763f9725039", "filename": "tests/ui/size_of_in_element_count.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7f22b1c58a0b2d5051c45283a88ea101d66e75ef/tests%2Fui%2Fsize_of_in_element_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f22b1c58a0b2d5051c45283a88ea101d66e75ef/tests%2Fui%2Fsize_of_in_element_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsize_of_in_element_count.rs?ref=7f22b1c58a0b2d5051c45283a88ea101d66e75ef", "patch": "@@ -0,0 +1,61 @@\n+#![warn(clippy::size_of_in_element_count)]\n+#![allow(clippy::ptr_offset_with_cast)]\n+\n+use std::mem::{size_of, size_of_val};\n+use std::ptr::{\n+    copy, copy_nonoverlapping, slice_from_raw_parts, slice_from_raw_parts_mut, swap_nonoverlapping, write_bytes,\n+};\n+use std::slice::{from_raw_parts, from_raw_parts_mut};\n+\n+fn main() {\n+    const SIZE: usize = 128;\n+    const HALF_SIZE: usize = SIZE / 2;\n+    const DOUBLE_SIZE: usize = SIZE * 2;\n+    let mut x = [2u8; SIZE];\n+    let mut y = [2u8; SIZE];\n+\n+    // Count is size_of (Should trigger the lint)\n+    unsafe { copy_nonoverlapping::<u8>(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };\n+    unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };\n+\n+    unsafe { x.as_ptr().copy_to(y.as_mut_ptr(), size_of::<u8>()) };\n+    unsafe { x.as_ptr().copy_to_nonoverlapping(y.as_mut_ptr(), size_of::<u8>()) };\n+    unsafe { y.as_mut_ptr().copy_from(x.as_ptr(), size_of::<u8>()) };\n+    unsafe { y.as_mut_ptr().copy_from_nonoverlapping(x.as_ptr(), size_of::<u8>()) };\n+\n+    unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };\n+    unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };\n+\n+    unsafe { y.as_mut_ptr().write_bytes(0u8, size_of::<u8>() * SIZE) };\n+    unsafe { write_bytes(y.as_mut_ptr(), 0u8, size_of::<u8>() * SIZE) };\n+\n+    unsafe { swap_nonoverlapping(y.as_mut_ptr(), x.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+\n+    slice_from_raw_parts_mut(y.as_mut_ptr(), size_of::<u8>() * SIZE);\n+    slice_from_raw_parts(y.as_ptr(), size_of::<u8>() * SIZE);\n+\n+    unsafe { from_raw_parts_mut(y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+    unsafe { from_raw_parts(y.as_ptr(), size_of::<u8>() * SIZE) };\n+\n+    unsafe { y.as_mut_ptr().sub(size_of::<u8>()) };\n+    y.as_ptr().wrapping_sub(size_of::<u8>());\n+    unsafe { y.as_ptr().add(size_of::<u8>()) };\n+    y.as_mut_ptr().wrapping_add(size_of::<u8>());\n+    unsafe { y.as_ptr().offset(size_of::<u8>() as isize) };\n+    y.as_mut_ptr().wrapping_offset(size_of::<u8>() as isize);\n+\n+    // Count expression involving multiplication of size_of (Should trigger the lint)\n+    unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+\n+    // Count expression involving nested multiplications of size_of (Should trigger the lint)\n+    unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), HALF_SIZE * size_of_val(&x[0]) * 2) };\n+\n+    // Count expression involving divisions of size_of (Should trigger the lint)\n+    unsafe { copy(x.as_ptr(), y.as_mut_ptr(), DOUBLE_SIZE * size_of::<u8>() / 2) };\n+\n+    // No size_of calls (Should not trigger the lint)\n+    unsafe { copy(x.as_ptr(), y.as_mut_ptr(), SIZE) };\n+\n+    // Different types for pointee and size_of (Should not trigger the lint)\n+    unsafe { y.as_mut_ptr().write_bytes(0u8, size_of::<u16>() / 2 * SIZE) };\n+}"}, {"sha": "b7f421ec99741abc64bc3e1d11a87c208e024f27", "filename": "tests/ui/size_of_in_element_count.stderr", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/7f22b1c58a0b2d5051c45283a88ea101d66e75ef/tests%2Fui%2Fsize_of_in_element_count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f22b1c58a0b2d5051c45283a88ea101d66e75ef/tests%2Fui%2Fsize_of_in_element_count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsize_of_in_element_count.stderr?ref=7f22b1c58a0b2d5051c45283a88ea101d66e75ef", "patch": "@@ -0,0 +1,195 @@\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:18:68\n+   |\n+LL |     unsafe { copy_nonoverlapping::<u8>(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };\n+   |                                                                    ^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::size-of-in-element-count` implied by `-D warnings`\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:19:62\n+   |\n+LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };\n+   |                                                              ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:21:49\n+   |\n+LL |     unsafe { x.as_ptr().copy_to(y.as_mut_ptr(), size_of::<u8>()) };\n+   |                                                 ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:22:64\n+   |\n+LL |     unsafe { x.as_ptr().copy_to_nonoverlapping(y.as_mut_ptr(), size_of::<u8>()) };\n+   |                                                                ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:23:51\n+   |\n+LL |     unsafe { y.as_mut_ptr().copy_from(x.as_ptr(), size_of::<u8>()) };\n+   |                                                   ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:24:66\n+   |\n+LL |     unsafe { y.as_mut_ptr().copy_from_nonoverlapping(x.as_ptr(), size_of::<u8>()) };\n+   |                                                                  ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:26:47\n+   |\n+LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };\n+   |                                               ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:27:47\n+   |\n+LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };\n+   |                                               ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:29:46\n+   |\n+LL |     unsafe { y.as_mut_ptr().write_bytes(0u8, size_of::<u8>() * SIZE) };\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:30:47\n+   |\n+LL |     unsafe { write_bytes(y.as_mut_ptr(), 0u8, size_of::<u8>() * SIZE) };\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:32:66\n+   |\n+LL |     unsafe { swap_nonoverlapping(y.as_mut_ptr(), x.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+   |                                                                  ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:34:46\n+   |\n+LL |     slice_from_raw_parts_mut(y.as_mut_ptr(), size_of::<u8>() * SIZE);\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:35:38\n+   |\n+LL |     slice_from_raw_parts(y.as_ptr(), size_of::<u8>() * SIZE);\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:37:49\n+   |\n+LL |     unsafe { from_raw_parts_mut(y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+   |                                                 ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:38:41\n+   |\n+LL |     unsafe { from_raw_parts(y.as_ptr(), size_of::<u8>() * SIZE) };\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:40:33\n+   |\n+LL |     unsafe { y.as_mut_ptr().sub(size_of::<u8>()) };\n+   |                                 ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:41:29\n+   |\n+LL |     y.as_ptr().wrapping_sub(size_of::<u8>());\n+   |                             ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:42:29\n+   |\n+LL |     unsafe { y.as_ptr().add(size_of::<u8>()) };\n+   |                             ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:43:33\n+   |\n+LL |     y.as_mut_ptr().wrapping_add(size_of::<u8>());\n+   |                                 ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:44:32\n+   |\n+LL |     unsafe { y.as_ptr().offset(size_of::<u8>() as isize) };\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:45:36\n+   |\n+LL |     y.as_mut_ptr().wrapping_offset(size_of::<u8>() as isize);\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:48:62\n+   |\n+LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+   |                                                              ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:51:62\n+   |\n+LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), HALF_SIZE * size_of_val(&x[0]) * 2) };\n+   |                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of T\n+  --> $DIR/size_of_in_element_count.rs:54:47\n+   |\n+LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), DOUBLE_SIZE * size_of::<u8>() / 2) };\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: aborting due to 24 previous errors\n+"}]}