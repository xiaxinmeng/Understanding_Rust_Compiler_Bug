{"sha": "42727658304b04babff6dd384637398c17331bbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNzI3NjU4MzA0YjA0YmFiZmY2ZGQzODQ2MzczOThjMTczMzFiYmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-07T21:58:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-07T21:58:32Z"}, "message": "auto merge of #4791 : jbclements/rust/demodeing-and-deGCing, r=jbclements,brson\n\nr?\r\n\r\nIt looks to me like the string_reader and tt_reader structs are\r\nGC pointers only because they predate the modern borrow system.\r\nThis commit leaves the type names string_reader and tt_reader alone\r\n(they still refer to GC-ed pointers), but internally the functions\r\nnow use borrowed pointers to refer to these structures. My guess\r\nwould be that it's possible to move this change outward and not\r\nuse the GCed pointers at all, but that change looks like it could be\r\na larger one. Actually, I'm delighted at how quick this change was.", "tree": {"sha": "bd3c411fa83ce77c56f4b5d6176d26b73da5b1a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd3c411fa83ce77c56f4b5d6176d26b73da5b1a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42727658304b04babff6dd384637398c17331bbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42727658304b04babff6dd384637398c17331bbe", "html_url": "https://github.com/rust-lang/rust/commit/42727658304b04babff6dd384637398c17331bbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42727658304b04babff6dd384637398c17331bbe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e9298ab888b425e9a395e87aa750feeaadb2e83", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e9298ab888b425e9a395e87aa750feeaadb2e83", "html_url": "https://github.com/rust-lang/rust/commit/6e9298ab888b425e9a395e87aa750feeaadb2e83"}, {"sha": "61827a70205c0be48badf09eced0e0d5dc6a4e02", "url": "https://api.github.com/repos/rust-lang/rust/commits/61827a70205c0be48badf09eced0e0d5dc6a4e02", "html_url": "https://github.com/rust-lang/rust/commit/61827a70205c0be48badf09eced0e0d5dc6a4e02"}], "stats": {"total": 137, "additions": 70, "deletions": 67}, "files": [{"sha": "ba42c3744e59bc1856e9905bfbfeba07ad250413", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/42727658304b04babff6dd384637398c17331bbe/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42727658304b04babff6dd384637398c17331bbe/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=42727658304b04babff6dd384637398c17331bbe", "patch": "@@ -39,7 +39,8 @@ type tt_frame = @{\n     up: tt_frame_up,\n };\n \n-pub type tt_reader = @{\n+pub type tt_reader = @tt_reader_;\n+pub type tt_reader_ = {\n     sp_diag: span_handler,\n     interner: @ident_interner,\n     mut cur: tt_frame,\n@@ -87,7 +88,7 @@ pure fn dup_tt_frame(&&f: tt_frame) -> tt_frame {\n      }\n }\n \n-pub pure fn dup_tt_reader(&&r: tt_reader) -> tt_reader {\n+pub pure fn dup_tt_reader(r: &tt_reader_) -> tt_reader {\n     @{sp_diag: r.sp_diag, interner: r.interner,\n       mut cur: dup_tt_frame(r.cur),\n       interpolations: r.interpolations,\n@@ -96,7 +97,7 @@ pub pure fn dup_tt_reader(&&r: tt_reader) -> tt_reader {\n }\n \n \n-pure fn lookup_cur_matched_by_matched(r: tt_reader,\n+pure fn lookup_cur_matched_by_matched(r: &tt_reader_,\n                                       start: @named_match) -> @named_match {\n     pure fn red(+ad: @named_match, idx: &uint) -> @named_match {\n         match *ad {\n@@ -110,15 +111,15 @@ pure fn lookup_cur_matched_by_matched(r: tt_reader,\n     vec::foldl(start, r.repeat_idx, red)\n }\n \n-fn lookup_cur_matched(r: tt_reader, name: ident) -> @named_match {\n+fn lookup_cur_matched(r: &tt_reader_, name: ident) -> @named_match {\n     lookup_cur_matched_by_matched(r, r.interpolations.get(&name))\n }\n enum lis {\n     lis_unconstrained, lis_constraint(uint, ident), lis_contradiction(~str)\n }\n \n-fn lockstep_iter_size(t: token_tree, r: tt_reader) -> lis {\n-    fn lis_merge(lhs: lis, rhs: lis, r: tt_reader) -> lis {\n+fn lockstep_iter_size(t: token_tree, r: &tt_reader_) -> lis {\n+    fn lis_merge(lhs: lis, rhs: lis, r: &tt_reader_) -> lis {\n         match lhs {\n           lis_unconstrained => rhs,\n           lis_contradiction(_) => lhs,\n@@ -150,7 +151,7 @@ fn lockstep_iter_size(t: token_tree, r: tt_reader) -> lis {\n }\n \n \n-pub fn tt_next_token(&&r: tt_reader) -> TokenAndSpan {\n+pub fn tt_next_token(r: &tt_reader_) -> TokenAndSpan {\n     let ret_val = TokenAndSpan { tok: r.cur_tok, sp: r.cur_span };\n     while r.cur.idx >= r.cur.readme.len() {\n         /* done with this set; pop or repeat? */\n@@ -199,25 +200,26 @@ pub fn tt_next_token(&&r: tt_reader) -> TokenAndSpan {\n             return ret_val;\n           }\n           tt_seq(sp, ref tts, ref sep, zerok) => {\n-            match lockstep_iter_size(tt_seq(sp, (*tts), (*sep), zerok), r) {\n-              lis_unconstrained => {\n-                r.sp_diag.span_fatal(\n+              match lockstep_iter_size(tt_seq(sp, (*tts), (*sep), zerok), r) {\n+                lis_unconstrained => {\n+                  r.sp_diag.span_fatal(\n                     sp, /* blame macro writer */\n-                    ~\"attempted to repeat an expression containing no syntax \\\n-                     variables matched as repeating at this depth\");\n-              }\n-              lis_contradiction(ref msg) => {\n-                /* FIXME #2887 blame macro invoker instead*/\n-                r.sp_diag.span_fatal(sp, (*msg));\n-              }\n-              lis_constraint(len, _) => {\n-                if len == 0 {\n-                    if !zerok {\n+                      ~\"attempted to repeat an expression \\\n+                        containing no syntax \\\n+                        variables matched as repeating at this depth\");\n+                  }\n+                  lis_contradiction(ref msg) => {\n+                      /* FIXME #2887 blame macro invoker instead*/\n+                      r.sp_diag.span_fatal(sp, (*msg));\n+                  }\n+                  lis_constraint(len, _) => {\n+                    if len == 0 {\n+                      if !zerok {\n                         r.sp_diag.span_fatal(sp, /* FIXME #2887 blame invoker\n-                                                  */\n+                        */\n                                              ~\"this must repeat at least \\\n-                                              once\");\n-                    }\n+                                               once\");\n+                          }\n \n                     r.cur.idx += 1u;\n                     return tt_next_token(r);"}, {"sha": "07c2a9f5e7e30650ddd080269c82148c438d36b5", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/42727658304b04babff6dd384637398c17331bbe/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42727658304b04babff6dd384637398c17331bbe/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=42727658304b04babff6dd384637398c17331bbe", "patch": "@@ -24,24 +24,25 @@ use core::either;\n use core::str;\n use core::u64;\n \n-pub use ext::tt::transcribe::{tt_reader, new_tt_reader};\n+pub use ext::tt::transcribe::{tt_reader, tt_reader_, new_tt_reader};\n \n-use std;\n+//use std;\n \n pub trait reader {\n-    fn is_eof() -> bool;\n-    fn next_token() -> TokenAndSpan;\n-    fn fatal(~str) -> !;\n-    fn span_diag() -> span_handler;\n-    pure fn interner() -> @token::ident_interner;\n-    fn peek() -> TokenAndSpan;\n-    fn dup() -> reader;\n+    fn is_eof(&self) -> bool;\n+    fn next_token(&self) -> TokenAndSpan;\n+    fn fatal(&self,~str) -> !;\n+    fn span_diag(&self) -> span_handler;\n+    pure fn interner(&self) -> @token::ident_interner;\n+    fn peek(&self) -> TokenAndSpan;\n+    fn dup(&self) -> reader;\n }\n \n #[deriving_eq]\n pub struct TokenAndSpan {tok: token::Token, sp: span}\n \n-pub type string_reader = @{\n+pub type string_reader = @string_reader_;\n+pub type string_reader_ = {\n     span_diagnostic: span_handler,\n     src: @~str,\n     // The absolute offset within the codemap of the next character to read\n@@ -90,7 +91,7 @@ pub fn new_low_level_string_reader(span_diagnostic: span_handler,\n // duplicating the string reader is probably a bad idea, in\n // that using them will cause interleaved pushes of line\n // offsets to the underlying filemap...\n-fn dup_string_reader(&&r: string_reader) -> string_reader {\n+fn dup_string_reader(r: &string_reader_) -> string_reader {\n     @{span_diagnostic: r.span_diagnostic, src: r.src,\n       mut pos: r.pos,\n       mut last_pos: r.last_pos,\n@@ -99,28 +100,28 @@ fn dup_string_reader(&&r: string_reader) -> string_reader {\n       mut peek_tok: r.peek_tok, mut peek_span: r.peek_span}\n }\n \n-impl string_reader: reader {\n-    fn is_eof() -> bool { is_eof(self) }\n+impl string_reader_: reader {\n+    fn is_eof(&self) -> bool { is_eof(self) }\n     // return the next token. EFFECT: advances the string_reader.\n-    fn next_token() -> TokenAndSpan {\n+    fn next_token(&self) -> TokenAndSpan {\n         let ret_val = TokenAndSpan {tok: self.peek_tok, sp: self.peek_span};\n         string_advance_token(self);\n         return ret_val;\n     }\n-    fn fatal(m: ~str) -> ! {\n+    fn fatal(&self, m: ~str) -> ! {\n         self.span_diagnostic.span_fatal(copy self.peek_span, m)\n     }\n-    fn span_diag() -> span_handler { self.span_diagnostic }\n-    pure fn interner() -> @token::ident_interner { self.interner }\n-    fn peek() -> TokenAndSpan {\n+    fn span_diag(&self) -> span_handler { self.span_diagnostic }\n+    pure fn interner(&self) -> @token::ident_interner { self.interner }\n+    fn peek(&self) -> TokenAndSpan {\n         TokenAndSpan {tok: self.peek_tok, sp: self.peek_span}\n     }\n-    fn dup() -> reader { dup_string_reader(self) as reader }\n+    fn dup(&self) -> reader { dup_string_reader(self) as reader }\n }\n \n-pub impl tt_reader: reader {\n-    fn is_eof() -> bool { self.cur_tok == token::EOF }\n-    fn next_token() -> TokenAndSpan {\n+pub impl tt_reader_: reader {\n+    fn is_eof(&self) -> bool { self.cur_tok == token::EOF }\n+    fn next_token(&self) -> TokenAndSpan {\n         /* weird resolve bug: if the following `if`, or any of its\n         statements are removed, we get resolution errors */\n         if false {\n@@ -129,19 +130,19 @@ pub impl tt_reader: reader {\n         }\n         tt_next_token(self)\n     }\n-    fn fatal(m: ~str) -> ! {\n+    fn fatal(&self, m: ~str) -> ! {\n         self.sp_diag.span_fatal(copy self.cur_span, m);\n     }\n-    fn span_diag() -> span_handler { self.sp_diag }\n-    pure fn interner() -> @token::ident_interner { self.interner }\n-    fn peek() -> TokenAndSpan {\n+    fn span_diag(&self) -> span_handler { self.sp_diag }\n+    pure fn interner(&self) -> @token::ident_interner { self.interner }\n+    fn peek(&self) -> TokenAndSpan {\n         TokenAndSpan { tok: self.cur_tok, sp: self.cur_span }\n     }\n-    fn dup() -> reader { dup_tt_reader(self) as reader }\n+    fn dup(&self) -> reader { dup_tt_reader(self) as reader }\n }\n \n // EFFECT: advance peek_tok and peek_span to refer to the next token.\n-fn string_advance_token(&&r: string_reader) {\n+fn string_advance_token(r: &string_reader_) {\n     match (consume_whitespace_and_comments(r)) {\n         Some(comment) => {\n             r.peek_tok = comment.tok;\n@@ -159,11 +160,11 @@ fn string_advance_token(&&r: string_reader) {\n     }\n }\n \n-fn byte_offset(rdr: string_reader) -> BytePos {\n+fn byte_offset(rdr: &string_reader_) -> BytePos {\n     (rdr.pos - rdr.filemap.start_pos)\n }\n \n-pub fn get_str_from(rdr: string_reader, start: BytePos) -> ~str {\n+pub fn get_str_from(rdr: &string_reader_, start: BytePos) -> ~str {\n     unsafe {\n         // I'm pretty skeptical about this subtraction. What if there's a\n         // multi-byte character before the mark?\n@@ -174,7 +175,7 @@ pub fn get_str_from(rdr: string_reader, start: BytePos) -> ~str {\n \n // EFFECT: advance the StringReader by one character. If a newline is\n // discovered, add it to the FileMap's list of line start offsets.\n-pub fn bump(rdr: string_reader) {\n+pub fn bump(rdr: &string_reader_) {\n     rdr.last_pos = rdr.pos;\n     let current_byte_offset = byte_offset(rdr).to_uint();;\n     if current_byte_offset < (*rdr.src).len() {\n@@ -198,10 +199,10 @@ pub fn bump(rdr: string_reader) {\n         rdr.curr = -1 as char;\n     }\n }\n-pub fn is_eof(rdr: string_reader) -> bool {\n+pub fn is_eof(rdr: &string_reader_) -> bool {\n     rdr.curr == -1 as char\n }\n-pub fn nextch(rdr: string_reader) -> char {\n+pub fn nextch(rdr: &string_reader_) -> char {\n     let offset = byte_offset(rdr).to_uint();\n     if offset < (*rdr.src).len() {\n         return str::char_at(*rdr.src, offset);\n@@ -246,7 +247,7 @@ fn is_bin_digit(c: char) -> bool { return c == '0' || c == '1'; }\n \n // EFFECT: eats whitespace and comments.\n // returns a Some(sugared-doc-attr) if one exists, None otherwise.\n-fn consume_whitespace_and_comments(rdr: string_reader)\n+fn consume_whitespace_and_comments(rdr: &string_reader_)\n     -> Option<TokenAndSpan> {\n     while is_whitespace(rdr.curr) { bump(rdr); }\n     return consume_any_line_comment(rdr);\n@@ -255,7 +256,7 @@ fn consume_whitespace_and_comments(rdr: string_reader)\n // PRECONDITION: rdr.curr is not whitespace\n // EFFECT: eats any kind of comment.\n // returns a Some(sugared-doc-attr) if one exists, None otherwise\n-fn consume_any_line_comment(rdr: string_reader)\n+fn consume_any_line_comment(rdr: &string_reader_)\n                                 -> Option<TokenAndSpan> {\n     if rdr.curr == '/' {\n         match nextch(rdr) {\n@@ -298,7 +299,7 @@ fn consume_any_line_comment(rdr: string_reader)\n }\n \n // might return a sugared-doc-attr\n-fn consume_block_comment(rdr: string_reader)\n+fn consume_block_comment(rdr: &string_reader_)\n                                 -> Option<TokenAndSpan> {\n \n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n@@ -337,7 +338,7 @@ fn consume_block_comment(rdr: string_reader)\n     return consume_whitespace_and_comments(rdr);\n }\n \n-fn scan_exponent(rdr: string_reader) -> Option<~str> {\n+fn scan_exponent(rdr: &string_reader_) -> Option<~str> {\n     let mut c = rdr.curr;\n     let mut rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n@@ -355,7 +356,7 @@ fn scan_exponent(rdr: string_reader) -> Option<~str> {\n     } else { return None::<~str>; }\n }\n \n-fn scan_digits(rdr: string_reader, radix: uint) -> ~str {\n+fn scan_digits(rdr: &string_reader_, radix: uint) -> ~str {\n     let mut rslt = ~\"\";\n     loop {\n         let c = rdr.curr;\n@@ -370,7 +371,7 @@ fn scan_digits(rdr: string_reader, radix: uint) -> ~str {\n     };\n }\n \n-fn scan_number(c: char, rdr: string_reader) -> token::Token {\n+fn scan_number(c: char, rdr: &string_reader_) -> token::Token {\n     let mut num_str, base = 10u, c = c, n = nextch(rdr);\n     if c == '0' && n == 'x' {\n         bump(rdr);\n@@ -486,7 +487,7 @@ fn scan_number(c: char, rdr: string_reader) -> token::Token {\n     }\n }\n \n-fn scan_numeric_escape(rdr: string_reader, n_hex_digits: uint) -> char {\n+fn scan_numeric_escape(rdr: &string_reader_, n_hex_digits: uint) -> char {\n     let mut accum_int = 0, i = n_hex_digits;\n     while i != 0u {\n         let n = rdr.curr;\n@@ -501,7 +502,7 @@ fn scan_numeric_escape(rdr: string_reader, n_hex_digits: uint) -> char {\n     return accum_int as char;\n }\n \n-fn next_token_inner(rdr: string_reader) -> token::Token {\n+fn next_token_inner(rdr: &string_reader_) -> token::Token {\n     let mut accum_str = ~\"\";\n     let mut c = rdr.curr;\n     if (c >= 'a' && c <= 'z')\n@@ -526,7 +527,7 @@ fn next_token_inner(rdr: string_reader) -> token::Token {\n     if is_dec_digit(c) {\n         return scan_number(c, rdr);\n     }\n-    fn binop(rdr: string_reader, op: token::binop) -> token::Token {\n+    fn binop(rdr: &string_reader_, op: token::binop) -> token::Token {\n         bump(rdr);\n         if rdr.curr == '=' {\n             bump(rdr);\n@@ -719,7 +720,7 @@ fn next_token_inner(rdr: string_reader) -> token::Token {\n     }\n }\n \n-fn consume_whitespace(rdr: string_reader) {\n+fn consume_whitespace(rdr: &string_reader_) {\n     while is_whitespace(rdr.curr) && !is_eof(rdr) { bump(rdr); }\n }\n \n@@ -730,7 +731,7 @@ pub mod test {\n     use util::interner;\n     use diagnostic;\n     use util::testing::{check_equal, check_equal_ptr};\n-    #[test] fn t1 () {\n+    #[tetst] fn t1 () {\n         let teststr =\n             @~\"/* my source file */\n fn main() { io::println(~\\\"zebra\\\"); }\\n\";"}]}