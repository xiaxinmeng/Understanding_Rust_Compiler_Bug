{"sha": "03119fe269de56e737562a9ee8d1bc47a9013eb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMTE5ZmUyNjlkZTU2ZTczNzU2MmE5ZWU4ZDFiYzQ3YTkwMTNlYjQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-26T00:00:12Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:54:44Z"}, "message": "Convert ast::ident to istr. Issue #855", "tree": {"sha": "043711359bd61d152c33a01a720b1982d5ccb69e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/043711359bd61d152c33a01a720b1982d5ccb69e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03119fe269de56e737562a9ee8d1bc47a9013eb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03119fe269de56e737562a9ee8d1bc47a9013eb4", "html_url": "https://github.com/rust-lang/rust/commit/03119fe269de56e737562a9ee8d1bc47a9013eb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03119fe269de56e737562a9ee8d1bc47a9013eb4/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "652332f9d44d0c3eb36c220a88ef37f7f875206f", "url": "https://api.github.com/repos/rust-lang/rust/commits/652332f9d44d0c3eb36c220a88ef37f7f875206f", "html_url": "https://github.com/rust-lang/rust/commit/652332f9d44d0c3eb36c220a88ef37f7f875206f"}], "stats": {"total": 719, "additions": 403, "deletions": 316}, "files": [{"sha": "3f09374309cbd0118500999dc487322111c5bfd2", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -299,12 +299,12 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess, linkage_metas);\n         for meta: @ast::meta_item in linkage_metas {\n-            if attr::get_meta_item_name(meta) == \"name\" {\n+            if attr::get_meta_item_name(meta) == ~\"name\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { name = some(v); }\n                   none. { cmh_items += [meta]; }\n                 }\n-            } else if attr::get_meta_item_name(meta) == \"vers\" {\n+            } else if attr::get_meta_item_name(meta) == ~\"vers\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { vers = some(v); }\n                   none. { cmh_items += [meta]; }\n@@ -334,11 +334,11 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n             let m = m_;\n             alt m.node {\n               ast::meta_name_value(key, value) {\n-                sha.input_str(len_and_str(istr::from_estr(key)));\n+                sha.input_str(len_and_str(key));\n                 sha.input_str(len_and_str_lit(value));\n               }\n               ast::meta_word(name) {\n-                sha.input_str(len_and_str(istr::from_estr(name)));\n+                sha.input_str(len_and_str(name));\n               }\n               ast::meta_list(_, _) {\n                 // FIXME (#607): Implement this"}, {"sha": "18ff05596240aad1a6f2e3ba6d070421ae8e81e5", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -55,11 +55,11 @@ fn default_configuration(sess: session::session, argv0: str, input: str) ->\n     let mk = attr::mk_name_value_item_str;\n \n     ret [ // Target bindings.\n-         mk(\"target_os\", istr::to_estr(std::os::target_os())),\n-        mk(\"target_arch\", \"x86\"),\n-         mk(\"target_libc\", libc),\n+         mk(~\"target_os\", istr::to_estr(std::os::target_os())),\n+        mk(~\"target_arch\", \"x86\"),\n+         mk(~\"target_libc\", libc),\n          // Build bindings.\n-         mk(\"build_compiler\", argv0), mk(\"build_input\", input)];\n+         mk(~\"build_compiler\", argv0), mk(~\"build_input\", input)];\n }\n \n fn build_configuration(sess: session::session, argv0: str, input: str) ->\n@@ -71,9 +71,9 @@ fn build_configuration(sess: session::session, argv0: str, input: str) ->\n     // If the user wants a test runner, then add the test cfg\n     let gen_cfg =\n         {\n-            if sess.get_opts().test && !attr::contains_name(user_cfg, \"test\")\n-               {\n-                [attr::mk_word_item(\"test\")]\n+            if sess.get_opts().test\n+                && !attr::contains_name(user_cfg, ~\"test\") {\n+                [attr::mk_word_item(~\"test\")]\n             } else { [] }\n         };\n     ret user_cfg + gen_cfg + default_cfg;\n@@ -84,7 +84,9 @@ fn parse_cfgspecs(cfgspecs: &[str]) -> ast::crate_cfg {\n     // FIXME: It would be nice to use the parser to parse all varieties of\n     // meta_item here. At the moment we just support the meta_word variant.\n     let words = [];\n-    for s: str in cfgspecs { words += [attr::mk_word_item(s)]; }\n+    for s: str in cfgspecs {\n+        words += [attr::mk_word_item(istr::from_estr(s))];\n+    }\n     ret words;\n }\n \n@@ -655,7 +657,7 @@ mod test {\n         let sessopts = build_session_options(\"whatever\", match, \"whatever\");\n         let sess = build_session(sessopts);\n         let cfg = build_configuration(sess, \"whatever\", \"whatever\");\n-        assert (attr::contains_name(cfg, \"test\"));\n+        assert (attr::contains_name(cfg, ~\"test\"));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n@@ -669,7 +671,7 @@ mod test {\n         let sessopts = build_session_options(\"whatever\", match, \"whatever\");\n         let sess = build_session(sessopts);\n         let cfg = build_configuration(sess, \"whatever\", \"whatever\");\n-        let test_items = attr::find_meta_items_by_name(cfg, \"test\");\n+        let test_items = attr::find_meta_items_by_name(cfg, ~\"test\");\n         assert (vec::len(test_items) == 1u);\n     }\n }"}, {"sha": "711f9f670395c1090bb4251633a8d02d6e16f145", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -2,6 +2,7 @@\n \n import std::vec;\n import std::str;\n+import std::istr;\n import std::map;\n import std::option;\n import syntax::ast;\n@@ -32,7 +33,7 @@ export mk_attr;\n // linkage\n fn find_linkage_metas(attrs: &[ast::attribute]) -> [@ast::meta_item] {\n     let metas: [@ast::meta_item] = [];\n-    for attr: ast::attribute in find_attrs_by_name(attrs, \"link\") {\n+    for attr: ast::attribute in find_attrs_by_name(attrs, ~\"link\") {\n         alt attr.node.value.node {\n           ast::meta_list(_, items) { metas += items; }\n           _ { log \"ignoring link attribute that has incorrect type\"; }\n@@ -163,11 +164,11 @@ fn sort_meta_items(items: &[@ast::meta_item]) -> [@ast::meta_item] {\n     ret v2;\n }\n \n-fn remove_meta_items_by_name(items: &[@ast::meta_item], name: str) ->\n+fn remove_meta_items_by_name(items: &[@ast::meta_item], name: &istr) ->\n    [@ast::meta_item] {\n \n     let filter =\n-        bind fn (item: &@ast::meta_item, name: str) ->\n+        bind fn (item: &@ast::meta_item, name: &istr) ->\n                 option::t<@ast::meta_item> {\n                  if get_meta_item_name(item) != name {\n                      option::some(item)\n@@ -178,12 +179,13 @@ fn remove_meta_items_by_name(items: &[@ast::meta_item], name: str) ->\n }\n \n fn require_unique_names(sess: &session::session, metas: &[@ast::meta_item]) {\n-    let map = map::mk_hashmap::<str, ()>(str::hash, str::eq);\n+    let map = map::new_str_hash();\n     for meta: @ast::meta_item in metas {\n         let name = get_meta_item_name(meta);\n         if map.contains_key(name) {\n             sess.span_fatal(meta.span,\n-                            #fmt[\"duplicate meta item `%s`\", name]);\n+                            #fmt[\"duplicate meta item `%s`\",\n+                                 istr::to_estr(name)]);\n         }\n         map.insert(name, ());\n     }"}, {"sha": "be02086cc012bf54f678ec771e265fa08fbed0bc", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -94,7 +94,7 @@ fn native_item_in_cfg(cfg: &ast::crate_cfg, item: &@ast::native_item) ->\n fn in_cfg(cfg: &ast::crate_cfg, attrs: &[ast::attribute]) -> bool {\n \n     // The \"cfg\" attributes on the item\n-    let item_cfg_attrs = attr::find_attrs_by_name(attrs, \"cfg\");\n+    let item_cfg_attrs = attr::find_attrs_by_name(attrs, ~\"cfg\");\n     let item_has_cfg_attrs = vec::len(item_cfg_attrs) > 0u;\n     if !item_has_cfg_attrs { ret true; }\n \n@@ -108,7 +108,7 @@ fn in_cfg(cfg: &ast::crate_cfg, attrs: &[ast::attribute]) -> bool {\n                [@ast::meta_item] {\n                 alt cfg_item.node {\n                   ast::meta_list(name, items) {\n-                    assert (name == \"cfg\");\n+                    assert (name == ~\"cfg\");\n                     inner_items + items\n                   }\n                   _ { inner_items }"}, {"sha": "425736c2d5c40ff350908a39d0acc1d628c9cbd2", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -64,7 +64,7 @@ fn fold_mod(_cx: &test_ctxt, m: &ast::_mod, fld: fold::ast_fold) ->\n     fn nomain(item: &@ast::item) -> option::t<@ast::item> {\n         alt item.node {\n           ast::item_fn(f, _) {\n-            if item.ident == \"main\" {\n+            if item.ident == ~\"main\" {\n                 option::none\n             } else { option::some(item) }\n           }\n@@ -107,7 +107,7 @@ fn fold_item(cx: &test_ctxt, i: &@ast::item, fld: fold::ast_fold) ->\n \n fn is_test_fn(i: &@ast::item) -> bool {\n     let has_test_attr =\n-        vec::len(attr::find_attrs_by_name(i.attrs, \"test\")) > 0u;\n+        vec::len(attr::find_attrs_by_name(i.attrs, ~\"test\")) > 0u;\n \n     fn has_test_signature(i: &@ast::item) -> bool {\n         alt i.node {\n@@ -125,7 +125,7 @@ fn is_test_fn(i: &@ast::item) -> bool {\n }\n \n fn is_ignored(i: &@ast::item) -> bool {\n-    attr::contains_name(attr::attr_metas(i.attrs), \"ignore\")\n+    attr::contains_name(attr::attr_metas(i.attrs), ~\"ignore\")\n }\n \n fn add_test_module(cx: &test_ctxt, m: &ast::_mod) -> ast::_mod {\n@@ -160,7 +160,7 @@ fn mk_test_module(cx: &test_ctxt) -> @ast::item {\n     let testmod: ast::_mod = {view_items: [], items: [mainfn, testsfn]};\n     let item_ = ast::item_mod(testmod);\n     let item: ast::item =\n-        {ident: \"__test\",\n+        {ident: ~\"__test\",\n          attrs: [],\n          id: cx.next_node_id(),\n          node: item_,\n@@ -198,7 +198,7 @@ fn mk_tests(cx: &test_ctxt) -> @ast::item {\n \n     let item_ = ast::item_fn(fn_, []);\n     let item: ast::item =\n-        {ident: \"tests\",\n+        {ident: ~\"tests\",\n          attrs: [],\n          id: cx.next_node_id(),\n          node: item_,\n@@ -219,7 +219,7 @@ fn empty_fn_ty() -> ast::ty {\n fn mk_test_desc_vec_ty(cx: &test_ctxt) -> @ast::ty {\n     let test_desc_ty_path: ast::path =\n         nospan({global: false,\n-                idents: [\"std\", \"test\", \"test_desc\"],\n+                idents: [~\"std\", ~\"test\", ~\"test_desc\"],\n                 types: []});\n \n     let test_desc_ty: ast::ty =\n@@ -256,7 +256,7 @@ fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n          span: dummy_sp()};\n \n     let name_field: ast::field =\n-        nospan({mut: ast::imm, ident: \"name\", expr: @name_expr});\n+        nospan({mut: ast::imm, ident: ~\"name\", expr: @name_expr});\n \n     let fn_path: ast::path = nospan({global: false, idents: path, types: []});\n \n@@ -266,7 +266,7 @@ fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n          span: dummy_sp()};\n \n     let fn_field: ast::field =\n-        nospan({mut: ast::imm, ident: \"fn\", expr: @fn_expr});\n+        nospan({mut: ast::imm, ident: ~\"fn\", expr: @fn_expr});\n \n     let ignore_lit: ast::lit = nospan(ast::lit_bool(test.ignore));\n \n@@ -276,7 +276,7 @@ fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n          span: dummy_sp()};\n \n     let ignore_field: ast::field =\n-        nospan({mut: ast::imm, ident: \"ignore\", expr: @ignore_expr});\n+        nospan({mut: ast::imm, ident: ~\"ignore\", expr: @ignore_expr});\n \n     let desc_rec_: ast::expr_ =\n         ast::expr_rec([name_field, fn_field, ignore_field], option::none);\n@@ -291,7 +291,7 @@ fn mk_main(cx: &test_ctxt) -> @ast::item {\n     let args_ty: ast::ty = nospan(ast::ty_vec(args_mt));\n \n     let args_arg: ast::arg =\n-        {mode: ast::val, ty: @args_ty, ident: \"args\", id: cx.next_node_id()};\n+        {mode: ast::val, ty: @args_ty, ident: ~\"args\", id: cx.next_node_id()};\n \n     let ret_ty = nospan(ast::ty_nil);\n \n@@ -314,7 +314,7 @@ fn mk_main(cx: &test_ctxt) -> @ast::item {\n \n     let item_ = ast::item_fn(fn_, []);\n     let item: ast::item =\n-        {ident: \"main\",\n+        {ident: ~\"main\",\n          attrs: [],\n          id: cx.next_node_id(),\n          node: item_,\n@@ -326,7 +326,7 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n \n     // Get the args passed to main so we can pass the to test_main\n     let args_path: ast::path =\n-        nospan({global: false, idents: [\"args\"], types: []});\n+        nospan({global: false, idents: [~\"args\"], types: []});\n \n     let args_path_expr_: ast::expr_ = ast::expr_path(args_path);\n \n@@ -335,7 +335,7 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n \n     // Call __test::test to generate the vector of test_descs\n     let test_path: ast::path =\n-        nospan({global: false, idents: [\"tests\"], types: []});\n+        nospan({global: false, idents: [~\"tests\"], types: []});\n \n     let test_path_expr_: ast::expr_ = ast::expr_path(test_path);\n \n@@ -350,7 +350,7 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n     // Call std::test::test_main\n     let test_main_path: ast::path =\n         nospan({global: false,\n-                idents: [\"std\", \"test\", \"test_main\"],\n+                idents: [~\"std\", ~\"test\", ~\"test_main\"],\n                 types: []});\n \n     let test_main_path_expr_: ast::expr_ = ast::expr_path(test_main_path);"}, {"sha": "1400fe9839520c0f3694da703bba15ee2f8fd3e9", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -70,7 +70,7 @@ fn visit_item(e: env, i: &@ast::item) {\n         let cstore = e.sess.get_cstore();\n         if !cstore::add_used_library(cstore, m.native_name) { ret; }\n         for a: ast::attribute in\n-            attr::find_attrs_by_name(i.attrs, \"link_args\") {\n+            attr::find_attrs_by_name(i.attrs, ~\"link_args\") {\n             alt attr::get_meta_item_value_str(attr::attr_meta(a)) {\n               some(linkarg) { cstore::add_used_link_args(cstore, linkarg); }\n               none. {/* fallthrough */ }\n@@ -128,15 +128,15 @@ fn find_library_crate(sess: &session::session, ident: &ast::ident,\n     // is using the wrong type of meta item\n     let crate_name =\n         {\n-            let name_items = attr::find_meta_items_by_name(metas, \"name\");\n+            let name_items = attr::find_meta_items_by_name(metas, ~\"name\");\n             alt vec::last(name_items) {\n               some(i) {\n                 alt attr::get_meta_item_value_str(i) {\n                   some(n) { n }\n-                  _ { ident }\n+                  _ { istr::to_estr(ident) }\n                 }\n               }\n-              none. { ident }\n+              none. { istr::to_estr(ident) }\n             }\n         };\n \n@@ -219,14 +219,15 @@ fn load_library_crate(sess: &session::session, span: span, ident: &ast::ident,\n     alt find_library_crate(sess, ident, metas, library_search_paths) {\n       some(t) { ret t; }\n       none. {\n-        sess.span_fatal(span, #fmt[\"can't find crate for '%s'\", ident]);\n+        sess.span_fatal(span, #fmt[\"can't find crate for '%s'\",\n+                                   istr::to_estr(ident)]);\n       }\n     }\n }\n \n-fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n+fn resolve_crate(e: env, ident: &ast::ident, metas: [@ast::meta_item],\n                  span: span) -> ast::crate_num {\n-    if !e.crate_cache.contains_key(istr::from_estr(ident)) {\n+    if !e.crate_cache.contains_key(ident) {\n         let cinfo =\n             load_library_crate(e.sess, span, ident, metas,\n                                e.library_search_paths);\n@@ -236,19 +237,20 @@ fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n \n         // Claim this crate number and cache it\n         let cnum = e.next_crate_num;\n-        e.crate_cache.insert(istr::from_estr(ident), cnum);\n+        e.crate_cache.insert(ident, cnum);\n         e.next_crate_num += 1;\n \n         // Now resolve the crates referenced by this crate\n         let cnum_map = resolve_crate_deps(e, cdata);\n \n-        let cmeta = {name: ident, data: cdata, cnum_map: cnum_map};\n+        let cmeta = {name: istr::to_estr(ident),\n+                     data: cdata, cnum_map: cnum_map};\n \n         let cstore = e.sess.get_cstore();\n         cstore::set_crate_data(cstore, cnum, cmeta);\n         cstore::add_used_crate_file(cstore, cfilename);\n         ret cnum;\n-    } else { ret e.crate_cache.get(istr::from_estr(ident)); }\n+    } else { ret e.crate_cache.get(ident); }\n }\n \n // Go through the crate metadata and load any crates that it references\n@@ -271,7 +273,9 @@ fn resolve_crate_deps(e: env, cdata: &@[u8]) -> cstore::cnum_map {\n             // This is a new one so we've got to load it\n             // FIXME: Need better error reporting than just a bogus span\n             let fake_span = ast_util::dummy_sp();\n-            let local_cnum = resolve_crate(e, cname, [], fake_span);\n+            let local_cnum = resolve_crate(e,\n+                                           istr::from_estr(cname),\n+                                           [], fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n         }\n     }"}, {"sha": "b91906063fce644484aef2922f5735c124f693f3", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -153,7 +153,7 @@ fn resolve_path(path: &[ast::ident], data: @[u8]) -> [ast::def_id] {\n     fn eq_item(data: &[u8], s: str) -> bool {\n         ret str::eq(str::unsafe_from_bytes(data), s);\n     }\n-    let s = str::connect(path, \"::\");\n+    let s = istr::to_estr(istr::connect(path, ~\"::\"));\n     let md = ebml::new_doc(data);\n     let paths = ebml::get_doc(md, tag_paths);\n     let eqer = bind eq_item(_, s);\n@@ -302,14 +302,14 @@ fn get_meta_items(md: &ebml::doc) -> [@ast::meta_item] {\n     for each meta_item_doc: ebml::doc in\n              ebml::tagged_docs(md, tag_meta_item_word) {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n+        let n = istr::unsafe_from_bytes(ebml::doc_data(nd));\n         items += [attr::mk_word_item(n)];\n     }\n     for each meta_item_doc: ebml::doc in\n              ebml::tagged_docs(md, tag_meta_item_name_value) {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = ebml::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n+        let n = istr::unsafe_from_bytes(ebml::doc_data(nd));\n         let v = str::unsafe_from_bytes(ebml::doc_data(vd));\n         // FIXME (#611): Should be able to decode meta_name_value variants,\n         // but currently they can't be encoded\n@@ -318,7 +318,7 @@ fn get_meta_items(md: &ebml::doc) -> [@ast::meta_item] {\n     for each meta_item_doc: ebml::doc in\n              ebml::tagged_docs(md, tag_meta_item_list) {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n+        let n = istr::unsafe_from_bytes(ebml::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n         items += [attr::mk_list_item(n, subitems)];\n     }"}, {"sha": "f803292d9ad437afc3f38b0fc22decdadf2e7a7e", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -44,9 +44,9 @@ type entry<T> = {val: T, pos: uint};\n fn encode_tag_variant_paths(ebml_w: &ebml::writer, variants: &[variant],\n                             path: &[istr], index: &mutable [entry<istr>]) {\n     for variant: variant in variants {\n-        add_to_index(ebml_w, path, index, istr::from_estr(variant.node.name));\n+        add_to_index(ebml_w, path, index, variant.node.name);\n         ebml::start_tag(ebml_w, tag_paths_data_item);\n-        encode_name(ebml_w, istr::from_estr(variant.node.name));\n+        encode_name(ebml_w, variant.node.name);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         ebml::end_tag(ebml_w);\n     }\n@@ -63,9 +63,9 @@ fn encode_native_module_item_paths(ebml_w: &ebml::writer, nmod: &native_mod,\n                                    path: &[istr],\n                                    index: &mutable [entry<istr>]) {\n     for nitem: @native_item in nmod.items {\n-        add_to_index(ebml_w, path, index, istr::from_estr(nitem.ident));\n+        add_to_index(ebml_w, path, index, nitem.ident);\n         ebml::start_tag(ebml_w, tag_paths_data_item);\n-        encode_name(ebml_w, istr::from_estr(nitem.ident));\n+        encode_name(ebml_w, nitem.ident);\n         encode_def_id(ebml_w, local_def(nitem.id));\n         ebml::end_tag(ebml_w);\n     }\n@@ -77,76 +77,76 @@ fn encode_module_item_paths(ebml_w: &ebml::writer, module: &_mod,\n         if !ast_util::is_exported(it.ident, module) { cont; }\n         alt it.node {\n           item_const(_, _) {\n-            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n+            add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, istr::from_estr(it.ident));\n+            encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n           }\n           item_fn(_, tps) {\n-            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n+            add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, istr::from_estr(it.ident));\n+            encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n           }\n           item_mod(_mod) {\n-            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n+            add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_mod);\n-            encode_name(ebml_w, istr::from_estr(it.ident));\n+            encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n             encode_module_item_paths(ebml_w, _mod,\n-                                     path + [istr::from_estr(it.ident)],\n+                                     path + [it.ident],\n                                      index);\n             ebml::end_tag(ebml_w);\n           }\n           item_native_mod(nmod) {\n-            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n+            add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_mod);\n-            encode_name(ebml_w, istr::from_estr(it.ident));\n+            encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n             encode_native_module_item_paths(\n                 ebml_w, nmod,\n-                path + [istr::from_estr(it.ident)],\n+                path + [it.ident],\n                 index);\n             ebml::end_tag(ebml_w);\n           }\n           item_ty(_, tps) {\n-            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n+            add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, istr::from_estr(it.ident));\n+            encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n           }\n           item_res(_, _, tps, ctor_id) {\n-            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n+            add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, istr::from_estr(it.ident));\n+            encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(ctor_id));\n             ebml::end_tag(ebml_w);\n-            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n+            add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, istr::from_estr(it.ident));\n+            encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n           }\n           item_tag(variants, tps) {\n-            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n+            add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, istr::from_estr(it.ident));\n+            encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n             encode_tag_variant_paths(ebml_w, variants, path, index);\n           }\n           item_obj(_, tps, ctor_id) {\n-            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n+            add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, istr::from_estr(it.ident));\n+            encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(ctor_id));\n             ebml::end_tag(ebml_w);\n-            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n+            add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, istr::from_estr(it.ident));\n+            encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n           }\n@@ -453,7 +453,7 @@ fn encode_meta_item(ebml_w: &ebml::writer, mi: &meta_item) {\n       meta_word(name) {\n         ebml::start_tag(ebml_w, tag_meta_item_word);\n         ebml::start_tag(ebml_w, tag_meta_item_name);\n-        ebml_w.writer.write(str::bytes(name));\n+        ebml_w.writer.write(istr::bytes(name));\n         ebml::end_tag(ebml_w);\n         ebml::end_tag(ebml_w);\n       }\n@@ -462,7 +462,7 @@ fn encode_meta_item(ebml_w: &ebml::writer, mi: &meta_item) {\n           lit_str(value, _) {\n             ebml::start_tag(ebml_w, tag_meta_item_name_value);\n             ebml::start_tag(ebml_w, tag_meta_item_name);\n-            ebml_w.writer.write(str::bytes(name));\n+            ebml_w.writer.write(istr::bytes(name));\n             ebml::end_tag(ebml_w);\n             ebml::start_tag(ebml_w, tag_meta_item_value);\n             ebml_w.writer.write(str::bytes(value));\n@@ -475,7 +475,7 @@ fn encode_meta_item(ebml_w: &ebml::writer, mi: &meta_item) {\n       meta_list(name, items) {\n         ebml::start_tag(ebml_w, tag_meta_item_list);\n         ebml::start_tag(ebml_w, tag_meta_item_name);\n-        ebml_w.writer.write(str::bytes(name));\n+        ebml_w.writer.write(istr::bytes(name));\n         ebml::end_tag(ebml_w);\n         for inner_item: @meta_item in items {\n             encode_meta_item(ebml_w, *inner_item);\n@@ -508,18 +508,18 @@ fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> [attribute] {\n         assert (ecx.ccx.link_meta.vers != \"\");\n \n         let name_item =\n-            attr::mk_name_value_item_str(\"name\", ecx.ccx.link_meta.name);\n+            attr::mk_name_value_item_str(~\"name\", ecx.ccx.link_meta.name);\n         let vers_item =\n-            attr::mk_name_value_item_str(\"vers\", ecx.ccx.link_meta.vers);\n+            attr::mk_name_value_item_str(~\"vers\", ecx.ccx.link_meta.vers);\n \n         let other_items =\n             {\n-                let tmp = attr::remove_meta_items_by_name(items, \"name\");\n-                attr::remove_meta_items_by_name(tmp, \"vers\")\n+                let tmp = attr::remove_meta_items_by_name(items, ~\"name\");\n+                attr::remove_meta_items_by_name(tmp, ~\"vers\")\n             };\n \n         let meta_items = [name_item, vers_item] + other_items;\n-        let link_item = attr::mk_list_item(\"link\", meta_items);\n+        let link_item = attr::mk_list_item(~\"link\", meta_items);\n \n         ret attr::mk_attr(link_item);\n     }\n@@ -528,7 +528,7 @@ fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> [attribute] {\n     let found_link_attr = false;\n     for attr: attribute in crate.node.attrs {\n         attrs +=\n-            if attr::get_attr_name(attr) != \"link\" {\n+            if attr::get_attr_name(attr) != ~\"link\" {\n                 [attr]\n             } else {\n                 alt attr.node.value.node {"}, {"sha": "1ab9ed931260ad1c64a2c80fe1fbd2ed3d14332a", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -2,6 +2,7 @@\n \n import std::vec;\n import std::str;\n+import std::istr;\n import std::uint;\n import std::option;\n import std::option::none;\n@@ -42,9 +43,9 @@ fn parse_ident(st: @pstate, sd: str_def, last: char) -> ast::ident {\n \n fn parse_ident_(st: @pstate, _sd: str_def, is_last: fn(char) -> bool) ->\n    ast::ident {\n-    let rslt = \"\";\n+    let rslt = ~\"\";\n     while !is_last(peek(st) as char) {\n-        rslt += str::unsafe_from_byte(next(st));\n+        rslt += istr::unsafe_from_byte(next(st));\n     }\n     ret rslt;\n }\n@@ -225,9 +226,9 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n         assert (next(st) as char == '[');\n         let fields: [ty::field] = [];\n         while peek(st) as char != ']' {\n-            let name = \"\";\n+            let name = ~\"\";\n             while peek(st) as char != '=' {\n-                name += str::unsafe_from_byte(next(st));\n+                name += istr::unsafe_from_byte(next(st));\n             }\n             st.pos = st.pos + 1u;\n             fields += [{ident: name, mt: parse_mt(st, sd)}];\n@@ -278,9 +279,9 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n               'W' { proto = ast::proto_iter; }\n               'F' { proto = ast::proto_fn; }\n             }\n-            let name = \"\";\n+            let name = ~\"\";\n             while peek(st) as char != '[' {\n-                name += str::unsafe_from_byte(next(st));\n+                name += istr::unsafe_from_byte(next(st));\n             }\n             let func = parse_ty_fn(st, sd);\n             methods +="}, {"sha": "df2c83593d13223ed9dae05bf2af0f737d4c6fd2", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -134,7 +134,7 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n       ty::ty_rec(fields) {\n         w.write_str(~\"R[\");\n         for field: ty::field in fields {\n-            w.write_str(istr::from_estr(field.ident));\n+            w.write_str(field.ident);\n             w.write_char('=');\n             enc_mt(w, cx, field.mt);\n         }\n@@ -159,7 +159,7 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n         w.write_str(~\"O[\");\n         for m: ty::method in methods {\n             enc_proto(w, m.proto);\n-            w.write_str(istr::from_estr(m.ident));\n+            w.write_str(m.ident);\n             enc_ty_fn(w, cx, m.inputs, m.output, m.cf, m.constrs);\n         }\n         w.write_char(']');"}, {"sha": "177f5f752a9779fee7c82859db54cd787c9c7446", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -10,6 +10,7 @@ import syntax::visit;\n import visit::vt;\n import std::vec;\n import std::str;\n+import std::istr;\n import std::option;\n import std::option::some;\n import std::option::none;\n@@ -593,7 +594,7 @@ fn expr_root(cx: &ctx, ex: @ast::expr, autoderef: bool) ->\n             alt ty::struct(cx.tcx, auto_unbox.t) {\n               ty::ty_rec(fields) {\n                 for fld: ty::field in fields {\n-                    if str::eq(ident, fld.ident) {\n+                    if istr::eq(ident, fld.ident) {\n                         mut = fld.mt.mut != ast::imm;\n                         break;\n                     }"}, {"sha": "a0b1a96e3d6685a0fd7df1bb7f439c62ed018b38", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -131,7 +131,7 @@ mod test {\n     fn test_node_span_item() {\n         let expected: codemap::span = ast_util::mk_sp(20u, 30u);\n         let node =\n-            node_item(@{ident: \"test\",\n+            node_item(@{ident: ~\"test\",\n                         attrs: [],\n                         id: 0,\n                         node: item_mod({view_items: [], items: []}),\n@@ -143,7 +143,7 @@ mod test {\n     fn test_node_span_obj_ctor() {\n         let expected: codemap::span = ast_util::mk_sp(20u, 30u);\n         let node =\n-            node_obj_ctor(@{ident: \"test\",\n+            node_obj_ctor(@{ident: ~\"test\",\n                             attrs: [],\n                             id: 0,\n                             node: item_mod({view_items: [], items: []}),\n@@ -155,7 +155,7 @@ mod test {\n     fn test_node_span_native_item() {\n         let expected: codemap::span = ast_util::mk_sp(20u, 30u);\n         let node =\n-            node_native_item(@{ident: \"test\",\n+            node_native_item(@{ident: ~\"test\",\n                                attrs: [],\n                                node: native_item_ty,\n                                id: 0,"}, {"sha": "f65449e7099a6f206f334d0cab25a9afafe29bb8", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -432,7 +432,7 @@ fn follow_import(e: &env, sc: &scopes, path: &[ident], sp: &span) ->\n           ast::def_mod(_) | ast::def_native_mod(_) { ret dcur; }\n           _ {\n             e.sess.span_err(sp,\n-                            str::connect(path, \"::\") +\n+                            istr::to_estr(istr::connect(path, ~\"::\")) +\n                                 \" does not name a module.\");\n             ret none;\n           }\n@@ -465,7 +465,7 @@ fn resolve_import(e: &env, defid: ast::def_id, name: &ast::ident,\n     let end_id = ids[n_idents - 1u];\n     // Ignore the current scope if this import would shadow itself.\n     let sc =\n-        if str::eq(name, ids[0]) { std::list::cdr(sc_in) } else { sc_in };\n+        if istr::eq(name, ids[0]) { std::list::cdr(sc_in) } else { sc_in };\n     if n_idents == 1u {\n         register(e, defid, sp, end_id, sc_in,\n                  lookup_in_scope(e, sc, sp, end_id, ns_value),\n@@ -559,9 +559,10 @@ fn unresolved_err(e: &env, sc: &scopes, sp: &span, name: &ident, kind: &str) {\n     }\n     let err_scope = find_fn_or_mod_scope(sc);\n     for rs: {ident: str, sc: scope} in e.reported {\n-        if str::eq(rs.ident, name) && err_scope == rs.sc { ret; }\n+        if str::eq(rs.ident, istr::to_estr(name))\n+            && err_scope == rs.sc { ret; }\n     }\n-    e.reported += [{ident: name, sc: err_scope}];\n+    e.reported += [{ident: istr::to_estr(name), sc: err_scope}];\n     e.sess.span_err(sp, mk_unresolved_msg(name, kind));\n }\n \n@@ -570,7 +571,7 @@ fn unresolved_fatal(e: &env, sp: &span, id: &ident, kind: &str) -> ! {\n }\n \n fn mk_unresolved_msg(id: &ident, kind: &str) -> str {\n-    ret #fmt[\"unresolved %s: %s\", kind, id];\n+    ret #fmt[\"unresolved %s: %s\", kind, istr::to_estr(id)];\n }\n \n // Lookup helpers\n@@ -734,7 +735,7 @@ fn lookup_in_ty_params(name: &ident, ty_params: &[ast::ty_param]) ->\n    option::t<def> {\n     let i = 0u;\n     for tp: ast::ty_param in ty_params {\n-        if str::eq(tp.ident, name) { ret some(ast::def_ty_arg(i, tp.kind)); }\n+        if istr::eq(tp.ident, name) { ret some(ast::def_ty_arg(i, tp.kind)); }\n         i += 1u;\n     }\n     ret none::<def>;\n@@ -744,7 +745,7 @@ fn lookup_in_pat(name: &ident, pat: &@ast::pat) -> option::t<def_id> {\n     let found = none;\n     for each bound in ast_util::pat_bindings(pat) {\n         let p_name = alt bound.node { ast::pat_bind(n) { n } };\n-        if str::eq(p_name, name) { found = some(local_def(bound.id)); }\n+        if istr::eq(p_name, name) { found = some(local_def(bound.id)); }\n     }\n     ret found;\n }\n@@ -755,7 +756,7 @@ fn lookup_in_fn(name: &ident, decl: &ast::fn_decl,\n     alt ns {\n       ns_value. {\n         for a: ast::arg in decl.inputs {\n-            if str::eq(a.ident, name) {\n+            if istr::eq(a.ident, name) {\n                 ret some(ast::def_arg(local_def(a.id)));\n             }\n         }\n@@ -771,7 +772,7 @@ fn lookup_in_obj(name: &ident, ob: &ast::_obj, ty_params: &[ast::ty_param],\n     alt ns {\n       ns_value. {\n         for f: ast::obj_field in ob.fields {\n-            if str::eq(f.ident, name) {\n+            if istr::eq(f.ident, name) {\n                 ret some(ast::def_obj_field(local_def(f.id)));\n             }\n         }\n@@ -810,12 +811,12 @@ fn lookup_in_block(name: &ident, b: &ast::blk_, pos: uint, loc_pos: uint,\n                 alt it.node {\n                   ast::item_tag(variants, _) {\n                     if ns == ns_type {\n-                        if str::eq(it.ident, name) {\n+                        if istr::eq(it.ident, name) {\n                             ret some(ast::def_ty(local_def(it.id)));\n                         }\n                     } else if ns == ns_value {\n                         for v: ast::variant in variants {\n-                            if str::eq(v.node.name, name) {\n+                            if istr::eq(v.node.name, name) {\n                                 let i = v.node.id;\n                                 ret some(ast::def_variant(local_def(it.id),\n                                                           local_def(i)));\n@@ -824,7 +825,7 @@ fn lookup_in_block(name: &ident, b: &ast::blk_, pos: uint, loc_pos: uint,\n                     }\n                   }\n                   _ {\n-                    if str::eq(it.ident, name) {\n+                    if istr::eq(it.ident, name) {\n                         let found = found_def_item(it, ns);\n                         if !is_none(found) { ret found; }\n                     }\n@@ -898,13 +899,15 @@ fn lookup_in_mod(e: &env, m: &def, sp: &span, name: &ident, ns: namespace,\n     if defid.crate != ast::local_crate {\n         // examining a module in an external crate\n \n-        let cached = e.ext_cache.find({did: defid, ident: name, ns: ns});\n+        let cached = e.ext_cache.find({did: defid,\n+                                       ident: istr::to_estr(name), ns: ns});\n         if !is_none(cached) { ret cached; }\n         let path = [name];\n         if defid.node != -1 { path = e.ext_map.get(defid) + path; }\n         let fnd = lookup_external(e, defid.crate, path, ns);\n         if !is_none(fnd) {\n-            e.ext_cache.insert({did: defid, ident: name, ns: ns},\n+            e.ext_cache.insert({did: defid,\n+                                ident: istr::to_estr(name), ns: ns},\n                                option::get(fnd));\n         }\n         ret fnd;\n@@ -955,7 +958,7 @@ fn lookup_in_local_mod(e: &env, node_id: node_id, sp: &span, id: &ident,\n         ret none::<def>; // name is not visible\n \n     }\n-    alt info.index.find(istr::from_estr(id)) {\n+    alt info.index.find(id) {\n       none. { }\n       some(lst_) {\n         let lst = lst_;\n@@ -1000,25 +1003,27 @@ fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n         } else {\n             for match: glob_imp_def in matches {\n                 let sp = match.item.span;\n-                e.sess.span_note(sp, #fmt[\"'%s' is imported here\", id]);\n+                e.sess.span_note(sp, #fmt[\"'%s' is imported here\",\n+                                          istr::to_estr(id)]);\n             }\n             e.sess.span_fatal(sp,\n-                              \"'\" + id + \"' is glob-imported from\" +\n+                              \"'\" + istr::to_estr(id)\n+                              + \"' is glob-imported from\" +\n                                   \" multiple different modules.\");\n         }\n     }\n     // since we don't know what names we have in advance,\n     // absence takes the place of todo()\n \n-    if !info.glob_imported_names.contains_key(istr::from_estr(id)) {\n-        info.glob_imported_names.insert(istr::from_estr(id), resolving(sp));\n+    if !info.glob_imported_names.contains_key(id) {\n+        info.glob_imported_names.insert(id, resolving(sp));\n         let val = per_ns(e, info, sp, id, ns_value, dr);\n         let typ = per_ns(e, info, sp, id, ns_type, dr);\n         let md = per_ns(e, info, sp, id, ns_module, dr);\n-        info.glob_imported_names.insert(istr::from_estr(id),\n+        info.glob_imported_names.insert(id,\n                                         resolved(val, typ, md));\n     }\n-    alt info.glob_imported_names.get(istr::from_estr(id)) {\n+    alt info.glob_imported_names.get(id) {\n       todo(_, _, _, _, _) { e.sess.bug(\"Shouldn't've put a todo in.\"); }\n       resolving(sp) {\n         ret none::<def>; //circularity is okay in import globs\n@@ -1075,7 +1080,6 @@ fn lookup_in_mie(e: &env, mie: &mod_index_entry, ns: namespace) ->\n // Module indexing\n fn add_to_index(index: &hashmap<identistr, list<mod_index_entry>>,\n                 id: &ident, ent: &mod_index_entry) {\n-    let id = istr::from_estr(id);\n     alt index.find(id) {\n       none. { index.insert(id,\n                            cons(ent, @nil::<mod_index_entry>)); }\n@@ -1193,7 +1197,7 @@ fn check_for_collisions(e: &@env, c: &ast::crate) {\n     for each m: @{key: ast::node_id, val: @indexed_mod} in e.mod_map.items() {\n         for each name: @{key: identistr, val: list<mod_index_entry>} in\n                  m.val.index.items() {\n-            check_mod_name(*e, istr::to_estr(name.key), name.val);\n+            check_mod_name(*e, name.key, name.val);\n         }\n     }\n     // Other scopes have to be checked the hard way.\n@@ -1211,7 +1215,8 @@ fn check_mod_name(e: &env, name: &ident, entries: list<mod_index_entry>) {\n     let saw_type = false;\n     let saw_value = false;\n     fn dup(e: &env, sp: &span, word: &str, name: &ident) {\n-        e.sess.span_fatal(sp, \"duplicate definition of \" + word + name);\n+        e.sess.span_fatal(sp, \"duplicate definition of \" + word\n+                          + istr::to_estr(name));\n     }\n     while true {\n         alt entries {\n@@ -1303,11 +1308,11 @@ fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt<()>) {\n                             \"inconsistent number of bindings\");\n         } else {\n             for name: ident in ch.seen {\n-                if is_none(vec::find(bind str::eq(name, _), seen0)) {\n+                if is_none(vec::find(bind istr::eq(name, _), seen0)) {\n                     // Fight the alias checker\n                     let name_ = name;\n                     e.sess.span_err(a.pats[i].span,\n-                                    \"binding \" + name_ +\n+                                    \"binding \" + istr::to_estr(name_) +\n                                         \" does not occur in first pattern\");\n                 }\n             }\n@@ -1399,8 +1404,9 @@ fn checker(e: &env, kind: str) -> checker {\n \n fn check_name(ch: &checker, sp: &span, name: &ident) {\n     for s: ident in ch.seen {\n-        if str::eq(s, name) {\n-            ch.sess.span_fatal(sp, \"duplicate \" + ch.kind + \" name: \" + name);\n+        if istr::eq(s, name) {\n+            ch.sess.span_fatal(sp, \"duplicate \" + ch.kind\n+                               + \" name: \" + istr::to_estr(name));\n         }\n     }\n }"}, {"sha": "c2391563b787fd618ed51dec618061df5563670e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -4240,7 +4240,7 @@ fn trans_rec(cx: &@block_ctxt, fields: &[ast::field],\n         bcx = dst_res.bcx;\n         let expr_provided = false;\n         for f: ast::field in fields {\n-            if str::eq(f.node.ident, tf.ident) {\n+            if istr::eq(f.node.ident, tf.ident) {\n                 expr_provided = true;\n                 let lv = trans_lval(bcx, f.node.expr);\n                 bcx = move_val_if_temp(lv.res.bcx, INIT, dst_res.val,\n@@ -5060,6 +5060,7 @@ fn alloc_local(cx: &@block_ctxt, local: &@ast::local) -> result {\n     alt local.node.pat.node {\n       ast::pat_bind(ident) {\n         if bcx_ccx(cx).sess.get_opts().debuginfo {\n+            let ident = istr::to_estr(ident);\n             llvm::LLVMSetValueName(r.val, str::buf(ident));\n         }\n       }\n@@ -5523,7 +5524,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n         fn_args +=\n             [{mode: ast::alias(false),\n               ty: varg.ty,\n-              ident: istr::to_estr(~\"arg\" + uint::to_str(i, 10u)),\n+              ident: ~\"arg\" + uint::to_str(i, 10u),\n               id: varg.id}];\n     }\n     assert (cx.ccx.item_ids.contains_key(variant.node.id));\n@@ -5625,7 +5626,7 @@ fn trans_const(cx: &@crate_ctxt, e: @ast::expr, id: ast::node_id) {\n fn trans_item(cx: @local_ctxt, item: &ast::item) {\n     alt item.node {\n       ast::item_fn(f, tps) {\n-        let sub_cx = extend_path(cx, item.ident);\n+        let sub_cx = extend_path(cx, istr::to_estr(item.ident));\n         alt cx.ccx.item_ids.find(item.id) {\n           some(llfndecl) {\n             trans_fn(sub_cx, item.span, f, llfndecl, none, tps, item.id);\n@@ -5639,7 +5640,7 @@ fn trans_item(cx: @local_ctxt, item: &ast::item) {\n       ast::item_obj(ob, tps, ctor_id) {\n         let sub_cx =\n             @{obj_typarams: tps, obj_fields: ob.fields\n-                 with *extend_path(cx, item.ident)};\n+                 with *extend_path(cx, istr::to_estr(item.ident))};\n         trans_obj(sub_cx, item.span, ob, ctor_id, tps);\n       }\n       ast::item_res(dtor, dtor_id, tps, ctor_id) {\n@@ -5657,12 +5658,13 @@ fn trans_item(cx: @local_ctxt, item: &ast::item) {\n       }\n       ast::item_mod(m) {\n         let sub_cx =\n-            @{path: cx.path + [item.ident],\n-              module_path: cx.module_path + [item.ident] with *cx};\n+            @{path: cx.path + [istr::to_estr(item.ident)],\n+              module_path: cx.module_path\n+                  + [istr::to_estr(item.ident)] with *cx};\n         trans_mod(sub_cx, m);\n       }\n       ast::item_tag(variants, tps) {\n-        let sub_cx = extend_path(cx, item.ident);\n+        let sub_cx = extend_path(cx, istr::to_estr(item.ident));\n         let degen = std::vec::len(variants) == 1u;\n         let i = 0;\n         for variant: ast::variant in variants {\n@@ -5717,6 +5719,7 @@ fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &[str],\n     let ps: str = mangle_exported_name(ccx, path, node_type);\n     register_fn_pair(ccx, ps, llfty, llfn, node_id);\n \n+    let path = istr::from_estrs(path);\n     let is_main: bool = is_main_name(path) && !ccx.sess.get_opts().library;\n     if is_main { create_main_wrapper(ccx, sp, llfn, node_type); }\n }\n@@ -6029,14 +6032,15 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n     finish_fn(fcx, lltop);\n }\n \n-fn item_path(item: &@ast::item) -> [str] { ret [item.ident]; }\n+fn item_path(item: &@ast::item) -> [str] { ret [istr::to_estr(item.ident)]; }\n \n fn collect_native_item(ccx: @crate_ctxt, i: &@ast::native_item, pt: &[str],\n                        _v: &vt<[str]>) {\n     alt i.node {\n       ast::native_item_fn(_, _, _) {\n         if !ccx.obj_methods.contains_key(i.id) {\n-            decl_native_fn_and_pair(ccx, i.span, pt, i.ident, i.id);\n+            decl_native_fn_and_pair(ccx, i.span, pt,\n+                                    istr::to_estr(i.ident), i.id);\n         }\n       }\n       _ { }\n@@ -6050,7 +6054,7 @@ fn collect_item_1(ccx: @crate_ctxt, i: &@ast::item, pt: &[str],\n       ast::item_const(_, _) {\n         let typ = node_id_type(ccx, i.id);\n         let s =\n-            mangle_exported_name(ccx, pt + [i.ident],\n+            mangle_exported_name(ccx, pt + [istr::to_estr(i.ident)],\n                                  node_id_type(ccx, i.id));\n         let g =\n             llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, i.span, typ),\n@@ -6110,7 +6114,8 @@ fn collect_tag_ctor(ccx: @crate_ctxt, i: &@ast::item, pt: &[str],\n       ast::item_tag(variants, tps) {\n         for variant: ast::variant in variants {\n             if std::vec::len(variant.node.args) != 0u {\n-                decl_fn_and_pair(ccx, i.span, new_pt + [variant.node.name],\n+                decl_fn_and_pair(ccx, i.span,\n+                                 new_pt + [istr::to_estr(variant.node.name)],\n                                  \"tag\", tps, variant.node.id);\n             }\n         }\n@@ -6138,7 +6143,8 @@ fn trans_constant(ccx: @crate_ctxt, it: &@ast::item, pt: &[str],\n         let n_variants = std::vec::len::<ast::variant>(variants);\n         while i < n_variants {\n             let variant = variants[i];\n-            let p = new_pt + [it.ident, variant.node.name, \"discrim\"];\n+            let p = new_pt + istr::to_estrs([it.ident,\n+                                             variant.node.name, ~\"discrim\"]);\n             let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n             let discrim_gvar =\n                 llvm::LLVMAddGlobal(ccx.llmod, T_int(), str::buf(s));"}, {"sha": "fdd2446cb1bfecf740c00ca09efb46d330e84990", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -60,7 +60,7 @@ fn variant_opt(ccx: &@crate_ctxt, pat_id: ast::node_id) -> opt {\n type bind_map = [{ident: ast::ident, val: ValueRef}];\n fn assoc(key: str, list: &bind_map) -> option::t<ValueRef> {\n     for elt: {ident: ast::ident, val: ValueRef} in list {\n-        if str::eq(elt.ident, key) { ret some(elt.val); }\n+        if istr::eq(elt.ident, istr::from_estr(key)) { ret some(elt.val); }\n     }\n     ret none;\n }\n@@ -146,7 +146,7 @@ fn enter_rec(m: &match, col: uint, fields: &[ast::ident], val: ValueRef) ->\n             for fname: ast::ident in fields {\n                 let pat = dummy;\n                 for fpat: ast::field_pat in fpats {\n-                    if str::eq(fpat.ident, fname) { pat = fpat.pat; break; }\n+                    if istr::eq(fpat.ident, fname) { pat = fpat.pat; break; }\n                 }\n                 pats += [pat];\n             }\n@@ -234,7 +234,7 @@ fn collect_record_fields(m: &match, col: uint) -> [ast::ident] {\n         alt br.pats[col].node {\n           ast::pat_rec(fs, _) {\n             for f: ast::field_pat in fs {\n-                if !vec::any(bind str::eq(f.ident, _), fields) {\n+                if !vec::any(bind istr::eq(f.ident, _), fields) {\n                     fields += [f.ident];\n                 }\n             }"}, {"sha": "c55d32593d8d71f7f4c662bad14e05eec9d4eb2f", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -1,6 +1,7 @@\n // Translation of object-related things to LLVM IR.\n \n import std::str;\n+import std::istr;\n import std::option;\n import std::vec;\n import option::none;\n@@ -396,22 +397,22 @@ tag vtbl_mthd {\n \n // Alphabetize ast::methods by ident.  A helper for create_vtbl.\n fn ast_mthd_lteq(a: &@ast::method, b: &@ast::method) -> bool {\n-    ret str::lteq(a.node.ident, b.node.ident);\n+    ret istr::lteq(a.node.ident, b.node.ident);\n }\n \n // Alphabetize vtbl_mthds by ident.  A helper for create_vtbl.\n fn vtbl_mthd_lteq(a: &vtbl_mthd, b: &vtbl_mthd) -> bool {\n     alt a {\n       normal_mthd(ma) {\n         alt b {\n-          normal_mthd(mb) { ret str::lteq(ma.node.ident, mb.node.ident); }\n-          fwding_mthd(mb) { ret str::lteq(ma.node.ident, mb.ident); }\n+          normal_mthd(mb) { ret istr::lteq(ma.node.ident, mb.node.ident); }\n+          fwding_mthd(mb) { ret istr::lteq(ma.node.ident, mb.ident); }\n         }\n       }\n       fwding_mthd(ma) {\n         alt b {\n-          normal_mthd(mb) { ret str::lteq(ma.ident, mb.node.ident); }\n-          fwding_mthd(mb) { ret str::lteq(ma.ident, mb.ident); }\n+          normal_mthd(mb) { ret istr::lteq(ma.ident, mb.node.ident); }\n+          fwding_mthd(mb) { ret istr::lteq(ma.ident, mb.ident); }\n         }\n       }\n     }\n@@ -430,7 +431,7 @@ fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd, addtl_meths: [@ast::method])\n     alt m {\n       fwding_mthd(fm) {\n         for am: @ast::method in addtl_meths {\n-            if str::eq(am.node.ident, fm.ident) { ret none; }\n+            if istr::eq(am.node.ident, fm.ident) { ret none; }\n         }\n         ret some(fwding_mthd(fm));\n       }\n@@ -598,7 +599,8 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Create a local context that's aware of the name of the method we're\n     // creating.\n-    let mcx: @local_ctxt = @{path: cx.path + [\"method\", m.ident] with *cx};\n+    let mcx: @local_ctxt = @{path: cx.path\n+        + [\"method\", istr::to_estr(m.ident)] with *cx};\n \n     // Make up a name for the backwarding function.\n     let fn_name: str = \"backwarding_fn\";\n@@ -726,7 +728,8 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Create a local context that's aware of the name of the method we're\n     // creating.\n-    let mcx: @local_ctxt = @{path: cx.path + [\"method\", m.ident] with *cx};\n+    let mcx: @local_ctxt = @{path: cx.path\n+        + [\"method\", istr::to_estr(m.ident)] with *cx};\n \n     // Make up a name for the forwarding function.\n     let fn_name: str = \"forwarding_fn\";\n@@ -917,7 +920,7 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n       }\n     }\n     let mcx: @local_ctxt =\n-        @{path: cx.path + [\"method\", m.node.ident] with *cx};\n+        @{path: cx.path + [\"method\", istr::to_estr(m.node.ident)] with *cx};\n     let s: str = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n     let llfn: ValueRef = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n "}, {"sha": "640619301c1c0a49bbd5c275f5af0f88352b15d6", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -67,7 +67,7 @@ fn comma_str(args: &[@constr_arg_use]) -> str {\n         if comma { rslt += \", \"; } else { comma = true; }\n         alt a.node {\n           carg_base. { rslt += \"*\"; }\n-          carg_ident(i) { rslt += i.ident; }\n+          carg_ident(i) { rslt += istr::to_estr(i.ident); }\n           carg_lit(l) { rslt += lit_to_str(l); }\n         }\n     }\n@@ -77,7 +77,8 @@ fn comma_str(args: &[@constr_arg_use]) -> str {\n fn constraint_to_str(tcx: &ty::ctxt, c: &sp_constr) -> str {\n     alt c.node {\n       ninit(_, i) {\n-        ret \"init(\" + i + \" [\" + tcx.sess.span_str(c.span) + \"])\";\n+        ret \"init(\" +\n+            istr::to_estr(i) + \" [\" + tcx.sess.span_str(c.span) + \"])\";\n       }\n       npred(p, _, args) {\n         ret path_to_str(p) + \"(\" + comma_str(args) + \")\" + \"[\" +\n@@ -169,11 +170,11 @@ fn log_states_err(pp: &pre_and_post_state) {\n     log_cond_err(p2);\n }\n \n-fn print_ident(i: &ident) { log \" \" + i + \" \"; }\n+fn print_ident(i: &ident) { log ~\" \" + i + ~\" \"; }\n \n fn print_idents(idents: &mutable [ident]) {\n     if vec::len::<ident>(idents) == 0u { ret; }\n-    log \"an ident: \" + vec::pop::<ident>(idents);\n+    log ~\"an ident: \" + vec::pop::<ident>(idents);\n     print_idents(idents);\n }\n \n@@ -592,7 +593,9 @@ fn constraints(fcx: &fn_ctxt) -> [norm_constraint] {\n fn match_args(fcx: &fn_ctxt, occs: &@mutable [pred_args],\n               occ: &[@constr_arg_use]) -> uint {\n     log \"match_args: looking at \" +\n-            constr_args_to_str(fn (i: &inst) -> str { ret i.ident; }, occ);\n+            constr_args_to_str(fn (i: &inst) -> str {\n+                ret istr::to_estr(i.ident);\n+            }, occ);\n     for pd: pred_args in *occs {\n         log \"match_args: candidate \" + pred_args_to_str(pd);\n         fn eq(p: &inst, q: &inst) -> bool { ret p.node == q.node; }\n@@ -684,7 +687,9 @@ fn expr_to_constr(tcx: ty::ctxt, e: &@expr) -> sp_constr {\n \n fn pred_args_to_str(p: &pred_args) -> str {\n     \"<\" + istr::to_estr(uint::str(p.node.bit_num)) + \", \" +\n-        constr_args_to_str(fn (i: &inst) -> str { ret i.ident; }, p.node.args)\n+        constr_args_to_str(fn (i: &inst) -> str {\n+            ret istr::to_estr(i.ident);\n+        }, p.node.args)\n         + \">\"\n }\n \n@@ -790,7 +795,7 @@ fn insts_to_str(stuff: &[constr_arg_general_<inst>]) -> str {\n         rslt +=\n             \" \" +\n                 alt i {\n-                  carg_ident(p) { p.ident }\n+                  carg_ident(p) { istr::to_estr(p.ident) }\n                   carg_base. { \"*\" }\n                   carg_lit(_) { \"[lit]\" }\n                 } + \" \";"}, {"sha": "8d42e761571fb63ab31234d589e55457f1f64cd6", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -37,6 +37,7 @@ import std::option;\n import std::option::t;\n import std::option::some;\n import std::option::none;\n+import std::istr;\n import aux::*;\n import syntax::print::pprust::ty_to_str;\n import util::common::log_stmt_err;\n@@ -54,7 +55,9 @@ fn check_unused_vars(fcx: &fn_ctxt) {\n           ninit(id, v) {\n             if !vec_contains(fcx.enclosing.used_vars, id) && v[0] != '_' as u8\n                {\n-                fcx.ccx.tcx.sess.span_warn(c.c.span, \"unused variable \" + v);\n+                fcx.ccx.tcx.sess.span_warn(c.c.span,\n+                                           \"unused variable \"\n+                                           + istr::to_estr(v));\n             }\n           }\n           _ {/* ignore pred constraints */ }\n@@ -147,7 +150,8 @@ fn check_states_against_conditions(fcx: &fn_ctxt, f: &_fn,\n            !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n            f.decl.cf == return {\n         fcx.ccx.tcx.sess.span_err(f.body.span,\n-                                  \"In function \" + fcx.name +\n+                                  \"In function \" +\n+                                  istr::to_estr(fcx.name) +\n                                       \", not all control paths \\\n                                         return a value\");\n         fcx.ccx.tcx.sess.span_fatal(f.decl.output.span,\n@@ -162,7 +166,7 @@ fn check_states_against_conditions(fcx: &fn_ctxt, f: &_fn,\n         if !promises(fcx, post, fcx.enclosing.i_diverge) {\n             fcx.ccx.tcx.sess.span_fatal(f.body.span,\n                                         \"In non-returning function \" +\n-                                            fcx.name +\n+                                            istr::to_estr(fcx.name) +\n                                             \", some control paths may \\\n                                            return to the caller\");\n         }\n@@ -192,8 +196,11 @@ fn fn_states(f: &_fn, tps: &[ast::ty_param], sp: &span, i: &fn_ident,\n \n     assert (ccx.fm.contains_key(id));\n     let f_info = ccx.fm.get(id);\n-    let name = option::from_maybe(\"anon\", i);\n-    let fcx = {enclosing: f_info, id: id, name: name, ccx: ccx};\n+    let name = option::from_maybe(~\"anon\", i);\n+    let fcx = {enclosing: f_info,\n+               id: id,\n+               name: name,\n+               ccx: ccx};\n     check_fn_states(fcx, f, tps, id, sp, i);\n }\n "}, {"sha": "ef7b38d452c9280c85823433d2e1df63177331b6", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -18,7 +18,7 @@ type ctxt = {cs: @mutable [sp_constr], tcx: ty::ctxt};\n fn collect_local(loc: &@local, cx: &ctxt, v: &visit::vt<ctxt>) {\n     for each p: @pat in pat_bindings(loc.node.pat) {\n         let ident = alt p.node { pat_bind(id) { id } };\n-        log \"collect_local: pushing \" + ident;;\n+        log ~\"collect_local: pushing \" + ident;;\n         *cx.cs += [respan(loc.span, ninit(p.id, ident))];\n     }\n     visit::visit_local(loc, cx, v);\n@@ -94,7 +94,7 @@ fn add_constraint(tcx: &ty::ctxt, c: sp_constr, next: uint, tbl: constr_map)\n    to a bit number in the precondition/postcondition vectors */\n fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &[ty_param], f_sp: &span,\n               f_name: &fn_ident, id: node_id) {\n-    let name = fn_ident_to_string(id, f_name);\n+    let name = istr::from_estr(fn_ident_to_string(id, f_name));\n     let res_map = @new_def_hash::<constraint>();\n     let next: uint = 0u;\n \n@@ -130,7 +130,7 @@ fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &[ty_param], f_sp: &span,\n     // and the name of the function, with a '!' appended to it, for the\n     // \"diverges\" constraint\n     let diverges_id = ccx.tcx.sess.next_node_id();\n-    let diverges_name = name + \"!\";\n+    let diverges_name = name + ~\"!\";\n     add_constraint(cx.tcx, respan(f_sp, ninit(diverges_id, diverges_name)),\n                    next, res_map);\n \n@@ -147,9 +147,9 @@ fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &[ty_param], f_sp: &span,\n          i_diverge: ninit(diverges_id, diverges_name),\n          used_vars: v};\n     ccx.fm.insert(id, rslt);\n-    log name + istr::to_estr(~\" has \"\n-                             + std::uint::str(num_constraints(rslt))\n-                             + ~\" constraints\");\n+    log istr::to_estr(name + ~\" has \"\n+                      + std::uint::str(num_constraints(rslt))\n+                      + ~\" constraints\");\n }\n \n "}, {"sha": "d9d88b04533f32f2896d397daca87119d8b59639", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -1,5 +1,6 @@\n \n import std::vec;\n+import std::istr;\n import std::option;\n import std::option::none;\n import std::option::some;\n@@ -68,11 +69,11 @@ fn find_pre_post_item(ccx: &crate_ctxt, i: &item) {\n                  {constrs: @new_def_hash::<constraint>(),\n                   num_constraints: 0u,\n                   cf: return,\n-                  i_return: ninit(0, \"\"),\n-                  i_diverge: ninit(0, \"\"),\n+                  i_return: ninit(0, ~\"\"),\n+                  i_diverge: ninit(0, ~\"\"),\n                   used_vars: v},\n              id: 0,\n-             name: \"\",\n+             name: ~\"\",\n              ccx: ccx};\n         find_pre_post_expr(fake_fcx, e);\n       }\n@@ -369,7 +370,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n         let rslt = expr_pp(fcx.ccx, e);\n         clear_pp(rslt);\n         let upvars = freevars::get_freevars(fcx.ccx.tcx, e.id);\n-        for id: node_id in *upvars { handle_var(fcx, rslt, id, \"upvar\"); }\n+        for id: node_id in *upvars { handle_var(fcx, rslt, id, ~\"upvar\"); }\n       }\n       expr_block(b) {\n         find_pre_post_block(fcx, b);\n@@ -750,7 +751,7 @@ fn fn_pre_post(f: &_fn, tps: &[ty_param], sp: &span, i: &fn_ident,\n     let fcx =\n         {enclosing: ccx.fm.get(id),\n          id: id,\n-         name: fn_ident_to_string(id, i),\n+         name: istr::from_estr(fn_ident_to_string(id, i)),\n          ccx: ccx};\n     find_pre_post_fn(fcx, f);\n }"}, {"sha": "02ec45739017a5a6946a7d29c1d7fd261157846d", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -1513,7 +1513,7 @@ fn hash_type_structure(st: &sty) -> uint {\n       ty_native_fn(_, args, rty) { ret hash_fn(28u, args, rty); }\n       ty_obj(methods) {\n         let h = 29u;\n-        for m: method in methods { h += h << 5u + str::hash(m.ident); }\n+        for m: method in methods { h += h << 5u + istr::hash(m.ident); }\n         ret h;\n       }\n       ty_var(v) { ret hash_uint(30u, v as uint); }\n@@ -1801,20 +1801,21 @@ fn stmt_node_id(s: &@ast::stmt) -> ast::node_id {\n fn field_idx(sess: &session::session, sp: &span, id: &ast::ident,\n              fields: &[field]) -> uint {\n     let i: uint = 0u;\n-    for f: field in fields { if str::eq(f.ident, id) { ret i; } i += 1u; }\n-    sess.span_fatal(sp, \"unknown field '\" + id + \"' of record\");\n+    for f: field in fields { if istr::eq(f.ident, id) { ret i; } i += 1u; }\n+    sess.span_fatal(sp, \"unknown field '\" +\n+                    istr::to_estr(id) + \"' of record\");\n }\n \n fn method_idx(sess: &session::session, sp: &span, id: &ast::ident,\n               meths: &[method]) -> uint {\n     let i: uint = 0u;\n-    for m: method in meths { if str::eq(m.ident, id) { ret i; } i += 1u; }\n-    sess.span_fatal(sp, \"unknown method '\" + id + \"' of obj\");\n+    for m: method in meths { if istr::eq(m.ident, id) { ret i; } i += 1u; }\n+    sess.span_fatal(sp, \"unknown method '\" + istr::to_estr(id) + \"' of obj\");\n }\n \n fn sort_methods(meths: &[method]) -> [method] {\n     fn method_lteq(a: &method, b: &method) -> bool {\n-        ret str::lteq(a.ident, b.ident);\n+        ret istr::lteq(a.ident, b.ident);\n     }\n     ret std::sort::merge_sort::<method>(bind method_lteq(_, _), meths);\n }\n@@ -2135,7 +2136,7 @@ mod unify {\n         while i < expected_len {\n             let e_meth = expected_meths[i];\n             let a_meth = actual_meths[i];\n-            if !str::eq(e_meth.ident, a_meth.ident) {\n+            if !istr::eq(e_meth.ident, a_meth.ident) {\n                 ret ures_err(terr_obj_meths(e_meth.ident, a_meth.ident));\n             }\n             let r =\n@@ -2412,7 +2413,7 @@ mod unify {\n                       none. { ret ures_err(terr_record_mutability); }\n                       some(m) { mut = m; }\n                     }\n-                    if !str::eq(expected_field.ident, actual_field.ident) {\n+                    if !istr::eq(expected_field.ident, actual_field.ident) {\n                         let err =\n                             terr_record_fields(expected_field.ident,\n                                                actual_field.ident);\n@@ -2622,14 +2623,14 @@ fn type_err_to_str(err: &ty::type_err) -> str {\n       }\n       terr_record_mutability. { ret \"record elements differ in mutability\"; }\n       terr_record_fields(e_fld, a_fld) {\n-        ret \"expected a record with field '\" + e_fld +\n-                \"' but found one with field '\" + a_fld + \"'\";\n+        ret \"expected a record with field '\" + istr::to_estr(e_fld) +\n+                \"' but found one with field '\" + istr::to_estr(a_fld) + \"'\";\n       }\n       terr_arg_count. { ret \"incorrect number of function parameters\"; }\n       terr_meth_count. { ret \"incorrect number of object methods\"; }\n       terr_obj_meths(e_meth, a_meth) {\n-        ret \"expected an obj with method '\" + e_meth +\n-                \"' but found one with method '\" + a_meth + \"'\";\n+        ret \"expected an obj with method '\" + istr::to_estr(e_meth) +\n+                \"' but found one with method '\" + istr::to_estr(a_meth) + \"'\";\n       }\n       terr_mode_mismatch(e_mode, a_mode) {\n         ret \"expected argument mode \" + mode_str_1(e_mode) + \" but found \" +"}, {"sha": "4ae6ecd003ff1f899e71f2940628ca6371b007f8", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -107,7 +107,7 @@ fn lookup_def(fcx: &@fn_ctxt, sp: &span, id: ast::node_id) -> ast::def {\n fn ident_for_local(loc: &@ast::local) -> ast::ident {\n     ret alt loc.node.pat.node {\n           ast::pat_bind(name) { name }\n-          _ { \"local\" }\n+          _ { ~\"local\" }\n         }; // FIXME DESTR\n }\n \n@@ -626,7 +626,7 @@ mod collect {\n                  ty_params: &[ast::ty_param]) -> ty::ty_param_kinds_and_ty {\n         let methods = get_obj_method_types(cx, ob);\n         let t_obj = ty::mk_obj(cx.tcx, ty::sort_methods(methods));\n-        t_obj = ty::rename(cx.tcx, t_obj, id);\n+        t_obj = ty::rename(cx.tcx, t_obj, istr::to_estr(id));\n         ret {kinds: ty_param_kinds(ty_params), ty: t_obj};\n     }\n     fn ty_of_obj_ctor(cx: @ctxt, id: &ast::ident, ob: &ast::_obj,\n@@ -1322,7 +1322,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n         let vid = lookup_local(fcx, pat.span, pat.id);\n         let typ = ty::mk_var(fcx.ccx.tcx, vid);\n         typ = demand::simple(fcx, pat.span, expected, typ);\n-        let canon_id = map.get(istr::from_estr(name));\n+        let canon_id = map.get(name);\n         if canon_id != pat.id {\n             let ct =\n                 ty::mk_var(fcx.ccx.tcx,\n@@ -1429,8 +1429,8 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n                       fields\",\n                      ex_f_count, f_count]);\n         }\n-        fn matches(name: &str, f: &ty::field) -> bool {\n-            ret str::eq(name, f.ident);\n+        fn matches(name: &istr, f: &ty::field) -> bool {\n+            ret istr::eq(name, f.ident);\n         }\n         for f: ast::field_pat in fields {\n             alt vec::find(bind matches(f.ident, _), ex_fields) {\n@@ -1439,7 +1439,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n                 fcx.ccx.tcx.sess.span_fatal(pat.span,\n                                             #fmt[\"mismatched types: did not \\\n                                              expect a record with a field %s\",\n-                                                 f.ident]);\n+                                                 istr::to_estr(f.ident)]);\n               }\n             }\n         }\n@@ -2255,15 +2255,15 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             for f: spanned<ty::field> in fields_t {\n                 let found = false;\n                 for bf: ty::field in base_fields {\n-                    if str::eq(f.node.ident, bf.ident) {\n+                    if istr::eq(f.node.ident, bf.ident) {\n                         demand::simple(fcx, f.span, bf.mt.ty, f.node.mt.ty);\n                         found = true;\n                     }\n                 }\n                 if !found {\n                     tcx.sess.span_fatal(f.span,\n                                         \"unknown field in record update: \" +\n-                                            f.node.ident);\n+                                        istr::to_estr(f.node.ident));\n                 }\n             }\n           }\n@@ -2419,15 +2419,15 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                option::t<ty::method> {\n \n                 for om: @ast::method in outer_obj_methods {\n-                    if str::eq(om.node.ident, m.ident) {\n+                    if istr::eq(om.node.ident, m.ident) {\n                         // We'd better be overriding with one of the same\n                         // type.  Check to make sure.\n                         let new_type = ty_of_method(ccx, om);\n                         if new_type != m {\n                             ccx.tcx.sess.span_fatal(\n                                 om.span,\n                                 \"Attempted to override method \"\n-                                + m.ident +\n+                                + istr::to_estr(m.ident) +\n                                 \" with one of a different type\");\n                         }\n                         ret none;\n@@ -2504,7 +2504,7 @@ fn check_decl_local(fcx: &@fn_ctxt, local: &@ast::local) -> bool {\n     alt fcx.locals.find(local.node.id) {\n       none. {\n         fcx.ccx.tcx.sess.bug(\"check_decl_local: local id not found \" +\n-                                 ident_for_local(local));\n+                             istr::to_estr(ident_for_local(local)));\n       }\n       some(i) {\n         let t = ty::mk_var(fcx.ccx.tcx, i);"}, {"sha": "4009ff2bd4edcbb1f6f084db697f6197c3789a48", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -7,7 +7,7 @@ import codemap::filename;\n \n type spanned<T> = {node: T, span: span};\n \n-type ident = str;\n+type ident = istr;\n type identistr = istr;\n \n // Functions may or may not have names.\n@@ -429,7 +429,7 @@ type native_mod =\n \n type variant_arg = {ty: @ty, id: node_id};\n \n-type variant_ = {name: str, args: [variant_arg], id: node_id};\n+type variant_ = {name: ident, args: [variant_arg], id: node_id};\n \n type variant = spanned<variant_>;\n "}, {"sha": "72a633da9282ead4a8f8dbf707de0e6913d2704d", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -16,7 +16,9 @@ fn dummy_sp() -> span { ret mk_sp(0u, 0u); }\n \n fn path_name(p: &path) -> str { path_name_i(p.node.idents) }\n \n-fn path_name_i(idents: &[ident]) -> str { str::connect(idents, \"::\") }\n+fn path_name_i(idents: &[ident]) -> str {\n+    istr::to_estr(istr::connect(idents, ~\"::\"))\n+}\n \n fn local_def(id: node_id) -> def_id { ret {crate: local_crate, node: id}; }\n \n@@ -52,7 +54,7 @@ fn pat_id_map(pat: &@pat) -> pat_id_map {\n     let map = std::map::new_str_hash::<node_id>();\n     for each bound in pat_bindings(pat) {\n         let name = alt bound.node { pat_bind(n) { n } };\n-        map.insert(istr::from_estr(name), bound.id);\n+        map.insert(name, bound.id);\n     }\n     ret map;\n }\n@@ -156,7 +158,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n     for vi: @ast::view_item in m.view_items {\n         alt vi.node {\n           ast::view_item_export(ids, _) {\n-            for id in ids { if str::eq(i, id) { ret true; } }\n+            for id in ids { if istr::eq(i, id) { ret true; } }\n             count += 1u;\n           }\n           _ {/* fall through */ }"}, {"sha": "0b88d09ec4d872d5b0b73cc5f5e5e184b55bcbc7", "filename": "src/comp/syntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -11,7 +11,7 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n             cx.span_fatal(sp, \"#concat_idents requires a vector argument .\")\n           }\n         };\n-    let res: ast::ident = \"\";\n+    let res: ast::ident = ~\"\";\n     for e: @ast::expr in args {\n         res += expr_to_ident(cx, e, \"expected an ident\");\n     }"}, {"sha": "6a80b0b6cb298a1090e8828264f56c036de982af", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -24,10 +24,11 @@ fn expand_expr(exts: &hashmap<istr, syntax_extension>, cx: &ext_ctxt,\n               mac_invoc(pth, args, body) {\n                 assert (vec::len(pth.node.idents) > 0u);\n                 let extname = pth.node.idents[0];\n-                alt exts.find(istr::from_estr(extname)) {\n+                alt exts.find(extname) {\n                   none. {\n                     cx.span_fatal(pth.span,\n-                                  #fmt[\"macro undefined: '%s'\", extname])\n+                                  #fmt[\"macro undefined: '%s'\",\n+                                       istr::to_estr(extname)])\n                   }\n                   some(normal(ext)) {\n                     let expanded = ext(cx, pth.span, args, body);"}, {"sha": "093799714a79cdc5fa6990b76dc1a3ec8abdda36", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -100,16 +100,16 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n         let recexpr = ast::expr_rec(astfields, option::none::<@ast::expr>);\n         ret @{id: cx.next_id(), node: recexpr, span: sp};\n     }\n-    fn make_path_vec(cx: &ext_ctxt, ident: str) -> [str] {\n+    fn make_path_vec(cx: &ext_ctxt, ident: &ast::ident) -> [ast::ident] {\n         fn compiling_std(cx: &ext_ctxt) -> bool {\n             ret str::find(cx.crate_file_name(), \"std.rc\") >= 0;\n         }\n         if compiling_std(cx) {\n-            ret [\"extfmt\", \"rt\", ident];\n-        } else { ret [\"std\", \"extfmt\", \"rt\", ident]; }\n+            ret [~\"extfmt\", ~\"rt\", ident];\n+        } else { ret [~\"std\", ~\"extfmt\", ~\"rt\", ident]; }\n     }\n     fn make_rt_path_expr(cx: &ext_ctxt, sp: span, ident: str) -> @ast::expr {\n-        let path = make_path_vec(cx, ident);\n+        let path = make_path_vec(cx, istr::from_estr(ident));\n         ret make_path_expr(cx, sp, path);\n     }\n     // Produces an AST expression that represents a RT::conv record,\n@@ -145,7 +145,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n               }\n               count_is(c) {\n                 let count_lit = make_new_int(cx, sp, c);\n-                let count_is_path = make_path_vec(cx, \"count_is\");\n+                let count_is_path = make_path_vec(cx, ~\"count_is\");\n                 let count_is_args = [count_lit];\n                 ret make_call(cx, sp, count_is_path, count_is_args);\n               }\n@@ -171,10 +171,10 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n             ret make_rec_expr(cx, sp,\n-                              [{ident: \"flags\", ex: flags_expr},\n-                               {ident: \"width\", ex: width_expr},\n-                               {ident: \"precision\", ex: precision_expr},\n-                               {ident: \"ty\", ex: ty_expr}]);\n+                              [{ident: ~\"flags\", ex: flags_expr},\n+                               {ident: ~\"width\", ex: width_expr},\n+                               {ident: ~\"precision\", ex: precision_expr},\n+                               {ident: ~\"ty\", ex: ty_expr}]);\n         }\n         let rt_conv_flags = make_flags(cx, sp, cnv.flags);\n         let rt_conv_width = make_count(cx, sp, cnv.width);\n@@ -185,7 +185,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     }\n     fn make_conv_call(cx: &ext_ctxt, sp: span, conv_type: str, cnv: &conv,\n                       arg: @ast::expr) -> @ast::expr {\n-        let fname = \"conv_\" + conv_type;\n+        let fname = ~\"conv_\" + istr::from_estr(conv_type);\n         let path = make_path_vec(cx, fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         let args = [cnv_expr, arg];"}, {"sha": "0664987e5309a7e0de1a15536a32ce42644a3e04", "filename": "src/comp/syntax/ext/ident_to_str.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -1,4 +1,5 @@\n import std::vec;\n+import std::istr;\n import std::option;\n import base::*;\n import syntax::ast;\n@@ -17,8 +18,8 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n     }\n \n     ret make_new_lit(cx, sp,\n-                     ast::lit_str(expr_to_ident(cx, args[0u],\n-                                                \"expected an ident\"),\n+                     ast::lit_str(istr::to_estr(expr_to_ident(cx, args[0u],\n+                                                \"expected an ident\")),\n                                   ast::sk_rc));\n \n }"}, {"sha": "94d814ae9c8473557b31f4403ed7e0672c59a198", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -268,8 +268,8 @@ iter free_vars(b: &bindings, e: @expr) -> ident {\n     let idents: hashmap<identistr, ()> = new_str_hash::<()>();\n     fn mark_ident(i: &ident, _fld: ast_fold, b: &bindings,\n                   idents: &hashmap<identistr, ()>) -> ident {\n-        if b.contains_key(istr::from_estr(i)) {\n-            idents.insert(istr::from_estr(i), ());\n+        if b.contains_key(i) {\n+            idents.insert(i, ());\n         }\n         ret i;\n     }\n@@ -281,7 +281,7 @@ iter free_vars(b: &bindings, e: @expr) -> ident {\n     let f = make_fold(f_pre);\n     f.fold_expr(e); // ignore result\n     dummy_out(f);\n-    for each id: identistr in idents.keys() { put istr::to_estr(id); }\n+    for each id: identistr in idents.keys() { put id; }\n }\n \n \n@@ -298,7 +298,7 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n             /* we need to walk over all the free vars in lockstep, except for\n             the leaves, which are just duplicated */\n             for each fv: ident in free_vars(b, repeat_me) {\n-                let cur_pos = follow(b.get(istr::from_estr(fv)), idx_path);\n+                let cur_pos = follow(b.get(fv), idx_path);\n                 alt cur_pos {\n                   leaf(_) { }\n                   seq(ms, _) {\n@@ -310,8 +310,10 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                         let len = vec::len(*ms);\n                         if old_len != len {\n                             let msg =\n-                                #fmt[\"'%s' occurs %u times, but \", fv, len] +\n-                                    #fmt[\"'%s' occurs %u times\", old_name,\n+                                #fmt[\"'%s' occurs %u times, but \",\n+                                     istr::to_estr(fv), len] +\n+                                    #fmt[\"'%s' occurs %u times\",\n+                                         istr::to_estr(old_name),\n                                          old_len];\n                             cx.span_fatal(repeat_me.span, msg);\n                         }\n@@ -350,7 +352,7 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n // substitute, in a position that's required to be an ident\n fn transcribe_ident(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                     i: &ident, _fld: ast_fold) -> ident {\n-    ret alt follow_for_trans(cx, b.find(istr::from_estr(i)), idx_path) {\n+    ret alt follow_for_trans(cx, b.find(i), idx_path) {\n           some(match_ident(a_id)) { a_id.node }\n           some(m) { match_error(cx, m, \"an identifier\") }\n           none. { i }\n@@ -362,8 +364,7 @@ fn transcribe_path(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                    p: &path_, _fld: ast_fold) -> path_ {\n     // Don't substitute into qualified names.\n     if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { ret p; }\n-    ret alt follow_for_trans(cx, b.find(\n-        istr::from_estr(p.idents[0])), idx_path) {\n+    ret alt follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n           some(match_ident(id)) {\n             {global: false, idents: [id.node], types: []}\n           }\n@@ -384,8 +385,7 @@ fn transcribe_expr(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n             if vec::len(p.node.types) > 0u || vec::len(p.node.idents) != 1u {\n                 e\n             }\n-            alt follow_for_trans(cx, b.find(\n-                istr::from_estr(p.node.idents[0])), idx_path) {\n+            alt follow_for_trans(cx, b.find(p.node.idents[0]), idx_path) {\n               some(match_ident(id)) {\n                 expr_path(respan(id.span,\n                                  {global: false,\n@@ -409,8 +409,7 @@ fn transcribe_type(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n           ast::ty_path(pth, _) {\n             alt path_to_ident(pth) {\n               some(id) {\n-                alt follow_for_trans(cx, b.find(\n-                    istr::from_estr(id)), idx_path) {\n+                alt follow_for_trans(cx, b.find(id), idx_path) {\n                   some(match_ty(ty)) { ty.node }\n                   some(m) { match_error(cx, m, \"a type\") }\n                   none. { orig(t, fld) }\n@@ -433,7 +432,7 @@ fn transcribe_block(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n     ret alt block_to_ident(blk) {\n           some(id) {\n             alt follow_for_trans(cx, b.find(\n-                istr::from_estr(id)), idx_path) {\n+                id), idx_path) {\n               some(match_block(new_blk)) { new_blk.node }\n \n \n@@ -534,10 +533,10 @@ fn p_t_s_r_path(cx: &ext_ctxt, p: &path, s: &selector, b: &binders) {\n                   _ { cx.bug(\"broken traversal in p_t_s_r\") }\n                 }\n         }\n-        if b.real_binders.contains_key(istr::from_estr(p_id)) {\n+        if b.real_binders.contains_key(p_id) {\n             cx.span_fatal(p.span, \"duplicate binding identifier\");\n         }\n-        b.real_binders.insert(istr::from_estr(p_id),\n+        b.real_binders.insert(p_id,\n                               compose_sels(s, bind select(cx, _)));\n       }\n       none. { }\n@@ -584,7 +583,7 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n                 }\n                 let final_step = bind select_pt_1(cx, _, select_pt_2);\n                 b.real_binders.insert(\n-                    istr::from_estr(id), compose_sels(s, final_step));\n+                    id, compose_sels(s, final_step));\n               }\n               none. { no_des(cx, pth.span, \"under `#<>`\"); }\n             }\n@@ -604,7 +603,7 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n                     }\n             }\n             let final_step = bind select_pt_1(cx, _, select_pt_2);\n-            b.real_binders.insert(istr::from_estr(id),\n+            b.real_binders.insert(id,\n                                   compose_sels(s, final_step));\n           }\n           none. { no_des(cx, blk.span, \"under `#{}`\"); }\n@@ -700,7 +699,7 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n           }\n         };\n \n-    let macro_name: option::t<str> = none;\n+    let macro_name: option::t<istr> = none;\n     let clauses: [@clause] = [];\n     for arg: @expr in args {\n         alt arg.node {\n@@ -760,7 +759,7 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n \n     ret {ident:\n              alt macro_name {\n-               some(id) { id }\n+               some(id) { istr::to_estr(id) }\n                none. {\n                  cx.span_fatal(sp,\n                                \"macro definition must have \" +"}, {"sha": "ccb7f0cfde2f9b421b8e14de2eaadacf12765aa4", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -47,13 +47,18 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n                         items: &mutable [@ast::item]) {\n     alt cdir.node {\n       ast::cdir_src_mod(id, file_opt, attrs) {\n-        let file_path = id + \".rs\";\n-        alt file_opt { some(f) { file_path = f; } none. { } }\n+        let file_path = id + ~\".rs\";\n+        alt file_opt {\n+          some(f) {\n+            file_path = istr::from_estr(f);\n+          }\n+          none. { }\n+        }\n         let full_path = if std::fs::path_is_absolute(\n-            istr::from_estr(file_path)) {\n-            file_path\n+            file_path) {\n+            istr::to_estr(file_path)\n         } else {\n-            prefix + istr::to_estr(std::fs::path_sep()) + file_path\n+            prefix + istr::to_estr(std::fs::path_sep() + file_path)\n         };\n         if cx.mode == mode_depend { cx.deps += [full_path]; ret; }\n         let p0 =\n@@ -74,11 +79,18 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n       }\n       ast::cdir_dir_mod(id, dir_opt, cdirs, attrs) {\n         let path = id;\n-        alt dir_opt { some(d) { path = d; } none. { } }\n+        alt dir_opt {\n+          some(d) {\n+            path = istr::from_estr(d);\n+          }\n+          none. { }\n+        }\n         let full_path =\n-            if std::fs::path_is_absolute(istr::from_estr(path)) {\n-                path\n-            } else { prefix + istr::to_estr(std::fs::path_sep()) + path };\n+            if std::fs::path_is_absolute(path) {\n+                istr::to_estr(path)\n+            } else {\n+            prefix + istr::to_estr(std::fs::path_sep() + path)\n+        };\n         let m0 = eval_crate_directives_to_mod(cx, cdirs, full_path);\n         let i =\n             @{ident: id,"}, {"sha": "85f809ef9653b9937f090d584dcbe7853fcd352a", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -229,7 +229,10 @@ fn spanned<@T>(lo: uint, hi: uint, node: &T) -> spanned<T> {\n \n fn parse_ident(p: &parser) -> ast::ident {\n     alt p.peek() {\n-      token::IDENT(i, _) { p.bump(); ret p.get_str(i); }\n+      token::IDENT(i, _) {\n+        p.bump();\n+        ret istr::from_estr(p.get_str(i));\n+      }\n       _ { p.fatal(\"expecting ident\"); }\n     }\n }\n@@ -375,7 +378,8 @@ fn parse_ty_field(p: &parser) -> ast::ty_field {\n fn ident_index(p: &parser, args: &[ast::arg], i: &ast::ident) -> uint {\n     let j = 0u;\n     for a: ast::arg in args { if a.ident == i { ret j; } j += 1u; }\n-    p.fatal(\"Unbound variable \" + i + \" in constraint arg\");\n+    p.fatal(\"Unbound variable \" +\n+            istr::to_estr(i) + \" in constraint arg\");\n }\n \n fn parse_type_constr_arg(p: &parser) -> @ast::ty_constr_arg {\n@@ -742,7 +746,7 @@ fn parse_path(p: &parser) -> ast::path {\n         alt p.peek() {\n           token::IDENT(i, _) {\n             hi = p.get_hi_pos();\n-            ids += [p.get_str(i)];\n+            ids += [istr::from_estr(p.get_str(i))];\n             hi = p.get_hi_pos();\n             p.bump();\n             if p.peek() == token::MOD_SEP && p.look_ahead(1u) != token::LT {\n@@ -1102,7 +1106,9 @@ fn parse_dot_or_call_expr_with(p: &parser, e: @ast::expr) -> @ast::expr {\n               token::IDENT(i, _) {\n                 hi = p.get_hi_pos();\n                 p.bump();\n-                e = mk_expr(p, lo, hi, ast::expr_field(e, p.get_str(i)));\n+                e = mk_expr(p, lo, hi,\n+                            ast::expr_field(\n+                                e, istr::from_estr(p.get_str(i))));\n               }\n               t { unexpected(p, t); }\n             }\n@@ -1455,9 +1461,9 @@ fn parse_pat(p: &parser) -> @ast::pat {\n                 p.bump();\n                 subpat = parse_pat(p);\n             } else {\n-                if p.get_bad_expr_words()\n-                    .contains_key(istr::from_estr(fieldname)) {\n-                    p.fatal(\"found \" + fieldname + \" in binding position\");\n+                if p.get_bad_expr_words().contains_key(fieldname) {\n+                    p.fatal(\"found \" + istr::to_estr(fieldname)\n+                            + \" in binding position\");\n                 }\n                 subpat =\n                     @{id: p.get_id(),\n@@ -1984,7 +1990,8 @@ fn parse_native_item(p: &parser, attrs: &[ast::attribute]) ->\n     } else { unexpected(p, p.peek()); }\n }\n \n-fn parse_native_mod_items(p: &parser, native_name: &str, abi: ast::native_abi,\n+fn parse_native_mod_items(p: &parser, native_name: &str,\n+                          abi: ast::native_abi,\n                           first_item_attrs: &[ast::attribute]) ->\n    ast::native_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n@@ -2027,7 +2034,7 @@ fn parse_item_native_mod(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     if p.peek() == token::EQ {\n         expect(p, token::EQ);\n         native_name = parse_str(p);\n-    } else { native_name = id; }\n+    } else { native_name = istr::to_estr(id); }\n     expect(p, token::LBRACE);\n     let more_attrs = parse_inner_attrs_and_next(p);\n     let inner_attrs = more_attrs.inner;\n@@ -2062,8 +2069,9 @@ fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let variants: [ast::variant] = [];\n     // Newtype syntax\n     if p.peek() == token::EQ {\n-        if p.get_bad_expr_words().contains_key(istr::from_estr(id)) {\n-            p.fatal(\"found \" + id + \" in tag constructor position\");\n+        if p.get_bad_expr_words().contains_key(id) {\n+            p.fatal(\"found \" + istr::to_estr(id)\n+                    + \" in tag constructor position\");\n         }\n         p.bump();\n         let ty = parse_ty(p, false);\n@@ -2100,7 +2108,8 @@ fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n             }\n             expect(p, token::SEMI);\n             p.get_id();\n-            let vr = {name: p.get_str(name), args: args, id: p.get_id()};\n+            let vr = {name: istr::from_estr(p.get_str(name)),\n+                      args: args, id: p.get_id()};\n             variants += [spanned(vlo, vhi, vr)];\n           }\n           token::RBRACE. {/* empty */ }\n@@ -2261,7 +2270,7 @@ fn parse_use(p: &parser) -> ast::view_item_ {\n     ret ast::view_item_use(ident, metadata, p.get_id());\n }\n \n-fn parse_rest_import_name(p: &parser, first: ast::ident,\n+fn parse_rest_import_name(p: &parser, first: &ast::ident,\n                           def_ident: option::t<ast::ident>) ->\n    ast::view_item_ {\n     let identifiers: [ast::ident] = [first];\n@@ -2336,12 +2345,13 @@ fn parse_rest_import_name(p: &parser, first: ast::ident,\n     }\n }\n \n-fn parse_full_import_name(p: &parser, def_ident: ast::ident) ->\n+fn parse_full_import_name(p: &parser, def_ident: &ast::ident) ->\n    ast::view_item_ {\n     alt p.peek() {\n       token::IDENT(i, _) {\n         p.bump();\n-        ret parse_rest_import_name(p, p.get_str(i), some(def_ident));\n+        ret parse_rest_import_name(\n+            p, istr::from_estr(p.get_str(i)), some(def_ident));\n       }\n       _ { p.fatal(\"expecting an identifier\"); }\n     }\n@@ -2354,9 +2364,12 @@ fn parse_import(p: &parser) -> ast::view_item_ {\n         alt p.peek() {\n           token::EQ. {\n             p.bump();\n-            ret parse_full_import_name(p, p.get_str(i));\n+            ret parse_full_import_name(p, istr::from_estr(p.get_str(i)));\n+          }\n+          _ {\n+            ret parse_rest_import_name(\n+                p, istr::from_estr(p.get_str(i)), none);\n           }\n-          _ { ret parse_rest_import_name(p, p.get_str(i), none); }\n         }\n       }\n       _ { p.fatal(\"expecting an identifier\"); }\n@@ -2436,7 +2449,7 @@ fn parse_crate_mod(p: &parser, _cfg: &ast::crate_cfg) -> @ast::crate {\n                   config: p.get_cfg()});\n }\n \n-fn parse_str(p: &parser) -> ast::ident {\n+fn parse_str(p: &parser) -> str {\n     alt p.peek() {\n       token::LIT_STR(s) { p.bump(); ret p.get_str(s); }\n       _ { fail; }"}, {"sha": "530b16a20377423a9e9ed4c1a40e27d5c9e71ac3", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 59, "deletions": 45, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -107,7 +107,8 @@ fn path_to_str(p: &ast::path) -> str {\n     be to_str(p, bind print_path(_, _, false));\n }\n \n-fn fun_to_str(f: &ast::_fn, name: str, params: &[ast::ty_param]) -> str {\n+fn fun_to_str(f: &ast::_fn, name: &ast::ident,\n+              params: &[ast::ty_param]) -> str {\n     let writer = io::string_writer();\n     let s = rust_printer(writer.get_writer());\n     print_fn(s, f.decl, f.proto, name, params, f.decl.constraints);\n@@ -305,7 +306,7 @@ fn print_type(s: &ps, ty: &@ast::ty) {\n         fn print_field(s: &ps, f: &ast::ty_field) {\n             cbox(s, indent_unit);\n             print_mutability(s, f.node.mt.mut);\n-            word(s.s, f.node.ident);\n+            word(s.s, istr::to_estr(f.node.ident));\n             word_space(s, \":\");\n             print_type(s, f.node.mt.ty);\n             end(s);\n@@ -320,7 +321,7 @@ fn print_type(s: &ps, ty: &@ast::ty) {\n         pclose(s);\n       }\n       ast::ty_fn(proto, inputs, output, cf, constrs) {\n-        print_ty_fn(s, proto, none::<str>, inputs, output, cf, constrs);\n+        print_ty_fn(s, proto, none::<istr>, inputs, output, cf, constrs);\n       }\n       ast::ty_obj(methods) {\n         head(s, \"obj\");\n@@ -356,7 +357,7 @@ fn print_native_item(s: &ps, item: &@ast::native_item) {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n         word_nbsp(s, \"type\");\n-        word(s.s, item.ident);\n+        word(s.s, istr::to_estr(item.ident));\n         end(s); // end the inner ibox\n         word(s.s, \";\");\n         end(s); // end the outer ibox\n@@ -388,7 +389,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n     alt item.node {\n       ast::item_const(ty, expr) {\n         head(s, \"const\");\n-        word_space(s, item.ident + \":\");\n+        word_space(s, istr::to_estr(item.ident) + \":\");\n         print_type(s, ty);\n         space(s.s);\n         end(s); // end the head-ibox\n@@ -407,7 +408,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n       }\n       ast::item_mod(_mod) {\n         head(s, \"mod\");\n-        word_nbsp(s, item.ident);\n+        word_nbsp(s, istr::to_estr(item.ident));\n         bopen(s);\n         print_mod(s, _mod, item.attrs);\n         bclose(s, item.span);\n@@ -424,8 +425,8 @@ fn print_item(s: &ps, item: &@ast::item) {\n           ast::native_abi_x86stdcall. { word_nbsp(s, \"\\\"x86stdcall\\\"\"); }\n         }\n         word_nbsp(s, \"mod\");\n-        word_nbsp(s, item.ident);\n-        if !str::eq(nmod.native_name, item.ident) {\n+        word_nbsp(s, istr::to_estr(item.ident));\n+        if !str::eq(nmod.native_name, istr::to_estr(item.ident)) {\n             word_space(s, \"=\");\n             print_string(s, nmod.native_name);\n             nbsp(s);\n@@ -438,7 +439,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n         word_nbsp(s, \"type\");\n-        word(s.s, item.ident);\n+        word(s.s, istr::to_estr(item.ident));\n         print_type_params(s, params);\n         end(s); // end the inner ibox\n \n@@ -451,13 +452,13 @@ fn print_item(s: &ps, item: &@ast::item) {\n       ast::item_tag(variants, params) {\n         let newtype =\n             vec::len(variants) == 1u &&\n-                str::eq(item.ident, variants[0].node.name) &&\n+                istr::eq(item.ident, variants[0].node.name) &&\n                 vec::len(variants[0].node.args) == 1u;\n         if newtype {\n             ibox(s, indent_unit);\n             word_space(s, \"tag\");\n         } else { head(s, \"tag\"); }\n-        word(s.s, item.ident);\n+        word(s.s, istr::to_estr(item.ident));\n         print_type_params(s, params);\n         space(s.s);\n         if newtype {\n@@ -470,7 +471,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n             for v: ast::variant in variants {\n                 space_if_not_bol(s);\n                 maybe_print_comment(s, v.span.lo);\n-                word(s.s, v.node.name);\n+                word(s.s, istr::to_estr(v.node.name));\n                 if vec::len(v.node.args) > 0u {\n                     popen(s);\n                     fn print_variant_arg(s: &ps, arg: &ast::variant_arg) {\n@@ -487,13 +488,13 @@ fn print_item(s: &ps, item: &@ast::item) {\n       }\n       ast::item_obj(_obj, params, _) {\n         head(s, \"obj\");\n-        word(s.s, item.ident);\n+        word(s.s, istr::to_estr(item.ident));\n         print_type_params(s, params);\n         popen(s);\n         fn print_field(s: &ps, field: &ast::obj_field) {\n             ibox(s, indent_unit);\n             print_mutability(s, field.mut);\n-            word_space(s, field.ident + \":\");\n+            word_space(s, istr::to_estr(field.ident) + \":\");\n             print_type(s, field.ty);\n             end(s);\n         }\n@@ -515,10 +516,10 @@ fn print_item(s: &ps, item: &@ast::item) {\n       }\n       ast::item_res(dt, dt_id, tps, ct_id) {\n         head(s, \"resource\");\n-        word(s.s, item.ident);\n+        word(s.s, istr::to_estr(item.ident));\n         print_type_params(s, tps);\n         popen(s);\n-        word_space(s, dt.decl.inputs[0].ident + \":\");\n+        word_space(s, istr::to_estr(dt.decl.inputs[0].ident) + \":\");\n         print_type(s, dt.decl.inputs[0].ty);\n         pclose(s);\n         space(s.s);\n@@ -786,7 +787,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         fn print_field(s: &ps, field: &ast::field) {\n             ibox(s, indent_unit);\n             if field.node.mut == ast::mut { word_nbsp(s, \"mutable\"); }\n-            word(s.s, field.node.ident);\n+            word(s.s, istr::to_estr(field.node.ident));\n             word_space(s, \":\");\n             print_expr(s, field.node.expr);\n             end(s);\n@@ -981,7 +982,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n       ast::expr_field(expr, id) {\n         print_expr_parens_if_unary(s, expr);\n         word(s.s, \".\");\n-        word(s.s, id);\n+        word(s.s, istr::to_estr(id));\n       }\n       ast::expr_index(expr, index) {\n         print_expr_parens_if_unary(s, expr);\n@@ -1042,7 +1043,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         fn print_field(s: &ps, field: &ast::anon_obj_field) {\n             ibox(s, indent_unit);\n             print_mutability(s, field.mut);\n-            word_space(s, field.ident + \":\");\n+            word_space(s, istr::to_estr(field.ident) + \":\");\n             print_type(s, field.ty);\n             space(s.s);\n             word_space(s, \"=\");\n@@ -1131,7 +1132,9 @@ fn print_decl(s: &ps, decl: &@ast::decl) {\n     }\n }\n \n-fn print_ident(s: &ps, ident: &ast::ident) { word(s.s, ident); }\n+fn print_ident(s: &ps, ident: &ast::ident) {\n+    word(s.s, istr::to_estr(ident));\n+}\n \n fn print_for_decl(s: &ps, loc: &@ast::local, coll: &@ast::expr) {\n     print_local_decl(s, loc);\n@@ -1144,9 +1147,9 @@ fn print_path(s: &ps, path: &ast::path, colons_before_params: bool) {\n     maybe_print_comment(s, path.span.lo);\n     if path.node.global { word(s.s, \"::\"); }\n     let first = true;\n-    for id: str in path.node.idents {\n+    for id: ast::ident in path.node.idents {\n         if first { first = false; } else { word(s.s, \"::\"); }\n-        word(s.s, id);\n+        word(s.s, istr::to_estr(id));\n     }\n     if vec::len(path.node.types) > 0u {\n         if colons_before_params { word(s.s, \"::\"); }\n@@ -1162,7 +1165,7 @@ fn print_pat(s: &ps, pat: &@ast::pat) {\n     s.ann.pre(ann_node);\n     alt pat.node {\n       ast::pat_wild. { word(s.s, \"_\"); }\n-      ast::pat_bind(id) { word(s.s, id); }\n+      ast::pat_bind(id) { word(s.s, istr::to_estr(id)); }\n       ast::pat_lit(lit) { print_literal(s, lit); }\n       ast::pat_tag(path, args) {\n         print_path(s, path, true);\n@@ -1176,7 +1179,7 @@ fn print_pat(s: &ps, pat: &@ast::pat) {\n         word(s.s, \"{\");\n         fn print_field(s: &ps, f: &ast::field_pat) {\n             cbox(s, indent_unit);\n-            word(s.s, f.ident);\n+            word(s.s, istr::to_estr(f.ident));\n             word_space(s, \":\");\n             print_pat(s, f.pat);\n             end(s);\n@@ -1199,13 +1202,13 @@ fn print_pat(s: &ps, pat: &@ast::pat) {\n     s.ann.post(ann_node);\n }\n \n-fn print_fn(s: &ps, decl: ast::fn_decl, proto: ast::proto, name: str,\n+fn print_fn(s: &ps, decl: ast::fn_decl, proto: ast::proto, name: &ast::ident,\n             typarams: &[ast::ty_param], constrs: [@ast::constr]) {\n     alt decl.purity {\n       ast::impure_fn. { head(s, proto_to_str(proto)); }\n       _ { head(s, \"pure fn\"); }\n     }\n-    word(s.s, name);\n+    word(s.s, istr::to_estr(name));\n     print_type_params(s, typarams);\n     print_fn_args_and_ret(s, decl, constrs);\n }\n@@ -1215,7 +1218,7 @@ fn print_fn_args_and_ret(s: &ps, decl: &ast::fn_decl,\n     popen(s);\n     fn print_arg(s: &ps, x: &ast::arg) {\n         ibox(s, indent_unit);\n-        word_space(s, x.ident + \":\");\n+        word_space(s, istr::to_estr(x.ident) + \":\");\n         print_alias(s, x.mode);\n         print_type(s, x.ty);\n         end(s);\n@@ -1236,7 +1239,7 @@ fn print_fn_block_args(s: &ps, decl: &ast::fn_decl) {\n     fn print_arg(s: &ps, x: &ast::arg) {\n         ibox(s, indent_unit);\n         print_alias(s, x.mode);\n-        word(s.s, x.ident);\n+        word(s.s, istr::to_estr(x.ident));\n         end(s);\n     }\n     commasep(s, inconsistent, decl.inputs, print_arg);\n@@ -1266,7 +1269,7 @@ fn print_type_params(s: &ps, params: &[ast::ty_param]) {\n         word(s.s, \"<\");\n         fn printParam(s: &ps, param: &ast::ty_param) {\n             print_kind(s, param.kind);\n-            word(s.s, param.ident);\n+            word(s.s, istr::to_estr(param.ident));\n         }\n         commasep(s, inconsistent, params, printParam);\n         word(s.s, \">\");\n@@ -1276,14 +1279,14 @@ fn print_type_params(s: &ps, params: &[ast::ty_param]) {\n fn print_meta_item(s: &ps, item: &@ast::meta_item) {\n     ibox(s, indent_unit);\n     alt item.node {\n-      ast::meta_word(name) { word(s.s, name); }\n+      ast::meta_word(name) { word(s.s, istr::to_estr(name)); }\n       ast::meta_name_value(name, value) {\n-        word_space(s, name);\n+        word_space(s, istr::to_estr(name));\n         word_space(s, \"=\");\n         print_literal(s, @value);\n       }\n       ast::meta_list(name, items) {\n-        word(s.s, name);\n+        word(s.s, istr::to_estr(name));\n         popen(s);\n         commasep(s, consistent, items, print_meta_item);\n         pclose(s);\n@@ -1298,7 +1301,7 @@ fn print_view_item(s: &ps, item: &@ast::view_item) {\n     alt item.node {\n       ast::view_item_use(id, mta, _) {\n         head(s, \"use\");\n-        word(s.s, id);\n+        word(s.s, istr::to_estr(id));\n         if vec::len(mta) > 0u {\n             popen(s);\n             commasep(s, consistent, mta, print_meta_item);\n@@ -1307,38 +1310,43 @@ fn print_view_item(s: &ps, item: &@ast::view_item) {\n       }\n       ast::view_item_import(id, ids, _) {\n         head(s, \"import\");\n-        if !str::eq(id, ids[vec::len(ids) - 1u]) {\n-            word_space(s, id);\n+        if !istr::eq(id, ids[vec::len(ids) - 1u]) {\n+            word_space(s, istr::to_estr(id));\n             word_space(s, \"=\");\n         }\n         let first = true;\n-        for elt: str in ids {\n+        for elt: ast::ident in ids {\n             if first { first = false; } else { word(s.s, \"::\"); }\n-            word(s.s, elt);\n+            word(s.s, istr::to_estr(elt));\n         }\n       }\n       ast::view_item_import_from(mod_path, idents, _) {\n         head(s, \"import\");\n-        for elt: str in mod_path { word(s.s, elt); word(s.s, \"::\"); }\n+        for elt: ast::ident in mod_path {\n+            word(s.s, istr::to_estr(elt)); word(s.s, \"::\");\n+        }\n         word(s.s, \"{\");\n         commasep(s, inconsistent, idents,\n                  fn (s: &ps, w: &ast::import_ident) {\n-                     word(s.s, w.node.name)\n+                     word(s.s, istr::to_estr(w.node.name))\n                  });\n         word(s.s, \"}\");\n       }\n       ast::view_item_import_glob(ids, _) {\n         head(s, \"import\");\n         let first = true;\n-        for elt: str in ids {\n+        for elt: ast::ident in ids {\n             if first { first = false; } else { word(s.s, \"::\"); }\n-            word(s.s, elt);\n+            word(s.s, istr::to_estr(elt));\n         }\n         word(s.s, \"::*\");\n       }\n       ast::view_item_export(ids, _) {\n         head(s, \"export\");\n-        commasep(s, inconsistent, ids, fn (s: &ps, w: &str) { word(s.s, w) });\n+        commasep(s, inconsistent, ids,\n+                 fn (s: &ps, w: &ast::ident) {\n+                     word(s.s, istr::to_estr(w))\n+                 });\n       }\n     }\n     word(s.s, \";\");\n@@ -1402,12 +1410,18 @@ fn print_mt(s: &ps, mt: &ast::mt) {\n     print_type(s, mt.ty);\n }\n \n-fn print_ty_fn(s: &ps, proto: &ast::proto, id: &option::t<str>,\n+fn print_ty_fn(s: &ps, proto: &ast::proto, id: &option::t<ast::ident>,\n                inputs: &[ast::ty_arg], output: &@ast::ty,\n                cf: &ast::controlflow, constrs: &[@ast::constr]) {\n     ibox(s, indent_unit);\n     word(s.s, proto_to_str(proto));\n-    alt id { some(id) { word(s.s, \" \"); word(s.s, id); } _ { } }\n+    alt id {\n+      some(id) {\n+        word(s.s, \" \");\n+        word(s.s, istr::to_estr(id));\n+      }\n+      _ { }\n+    }\n     zerobreak(s.s);\n     popen(s);\n     fn print_arg(s: &ps, input: &ast::ty_arg) {\n@@ -1680,7 +1694,7 @@ fn ast_ty_fn_constrs_str(constrs: &[@ast::constr]) -> str {\n }\n \n fn fn_arg_idx_to_str(decl: &ast::fn_decl, idx: &uint) -> str {\n-    decl.inputs[idx].ident\n+    istr::to_estr(decl.inputs[idx].ident)\n }\n \n fn ast_fn_constr_to_str(decl: &ast::fn_decl, c: &@ast::constr) -> str {"}, {"sha": "7afad61064dacc492d78f5aedd8d3fad50761f35", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -70,11 +70,11 @@ fn log_block_err(b: &ast::blk) { log_err print::pprust::block_to_str(b); }\n \n fn log_item_err(i: &@ast::item) { log_err print::pprust::item_to_str(i); }\n \n-fn log_fn(f: &ast::_fn, name: str, params: &[ast::ty_param]) {\n+fn log_fn(f: &ast::_fn, name: &ast::ident, params: &[ast::ty_param]) {\n     log print::pprust::fun_to_str(f, name, params);\n }\n \n-fn log_fn_err(f: &ast::_fn, name: str, params: &[ast::ty_param]) {\n+fn log_fn_err(f: &ast::_fn, name: &ast::ident, params: &[ast::ty_param]) {\n     log_err print::pprust::fun_to_str(f, name, params);\n }\n \n@@ -154,8 +154,8 @@ fn call_kind_str(c: call_kind) -> str {\n     }\n }\n \n-fn is_main_name(path: &[str]) -> bool {\n-    str::eq(option::get(std::vec::last(path)), \"main\")\n+fn is_main_name(path: &[ast::ident]) -> bool {\n+    istr::eq(option::get(std::vec::last(path)), ~\"main\")\n }\n \n // FIXME mode this to std::float when editing the stdlib no longer"}, {"sha": "88d419ae0cea1c72355d90ae464189b79da0c913", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03119fe269de56e737562a9ee8d1bc47a9013eb4/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=03119fe269de56e737562a9ee8d1bc47a9013eb4", "patch": "@@ -38,16 +38,16 @@ fn mode_str_1(m: &ty::mode) -> str {\n fn fn_ident_to_string(id: ast::node_id, i: &ast::fn_ident) -> str {\n     ret alt i {\n       none. { istr::to_estr(~\"anon\" + int::str(id)) }\n-      some(s) { s }\n+      some(s) { istr::to_estr(s) }\n     };\n }\n \n fn get_id_ident(cx: &ctxt, id: ast::def_id) -> str {\n     if id.crate != ast::local_crate {\n-        str::connect(cx.ext_map.get(id), \"::\")\n+        str::connect(istr::to_estrs(cx.ext_map.get(id)), \"::\")\n     } else {\n         alt cx.items.find(id.node) {\n-          some(ast_map::node_item(it)) { it.ident }\n+          some(ast_map::node_item(it)) { istr::to_estr(it.ident) }\n           _ { fail \"get_id_ident: can't find item in ast_map\" }\n         }\n     }\n@@ -63,7 +63,13 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n                  inputs: &[arg], output: t, cf: ast::controlflow,\n                  constrs: &[@constr]) -> str {\n         let s = proto_to_str(proto);\n-        alt ident { some(i) { s += \" \"; s += i; } _ { } }\n+        alt ident {\n+          some(i) {\n+            s += \" \";\n+            s += istr::to_estr(i);\n+          }\n+          _ { }\n+        }\n         s += \"(\";\n         let strs = [];\n         for a: arg in inputs { strs += [fn_input_to_str(cx, a)]; }\n@@ -83,7 +89,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n                       m.output, m.cf, m.constrs) + \";\";\n     }\n     fn field_to_str(cx: &ctxt, f: &field) -> str {\n-        ret f.ident + \": \" + mt_to_str(cx, f.mt);\n+        ret istr::to_estr(f.ident) + \": \" + mt_to_str(cx, f.mt);\n     }\n     fn mt_to_str(cx: &ctxt, m: &mt) -> str {\n         let mstr;"}]}