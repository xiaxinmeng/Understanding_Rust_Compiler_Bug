{"sha": "9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "node_id": "C_kwDOAAsO6NoAKDliZTJmMzVhNGMxZWQxYjA0YWE0YTY5NDViNjQ3NjNmNTk5MjU5ZmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-23T11:33:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-23T11:33:18Z"}, "message": "Auto merge of #103431 - Dylan-DPC:rollup-oozfo89, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #101293 (Recover when unclosed char literal is parsed as a lifetime in some positions)\n - #101908 (Suggest let for assignment, and some code refactor)\n - #103192 (rustdoc: Eliminate uses of `EarlyDocLinkResolver::all_traits`)\n - #103226 (Check `needs_infer` before `needs_drop` during HIR generator analysis)\n - #103249 (resolve: Revert \"Set effective visibilities for imports more precisely\")\n - #103305 (Move some tests to more reasonable places)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0fcc4f7182b13a4711e19ecf0262767633c6b862", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fcc4f7182b13a4711e19ecf0262767633c6b862"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "html_url": "https://github.com/rust-lang/rust/commit/9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e64f1110c062f61746f222059439529a43ccf6dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e64f1110c062f61746f222059439529a43ccf6dc", "html_url": "https://github.com/rust-lang/rust/commit/e64f1110c062f61746f222059439529a43ccf6dc"}, {"sha": "d35a24a0c203e7230d128230d28d8fbababebe8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d35a24a0c203e7230d128230d28d8fbababebe8d", "html_url": "https://github.com/rust-lang/rust/commit/d35a24a0c203e7230d128230d28d8fbababebe8d"}], "stats": {"total": 805, "additions": 541, "deletions": 264}, "files": [{"sha": "0963ea71f80236ac51c1e7bc70781f069ea8a2ec", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -463,6 +463,9 @@ pub enum StashKey {\n     UnderscoreForArrayLengths,\n     EarlySyntaxWarning,\n     CallIntoMethod,\n+    /// When an invalid lifetime e.g. `'2` should be reinterpreted\n+    /// as a char literal in the parser\n+    LifetimeIsChar,\n }\n \n fn default_track_diagnostic(_: &Diagnostic) {}"}, {"sha": "bfe95852aa7b408cd22fc5f6912064fe2eebd67b", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -6,8 +6,11 @@ use crate::{\n use hir::{def_id::DefId, Body, HirId, HirIdMap};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_middle::hir::place::{PlaceBase, Projection, ProjectionKind};\n use rustc_middle::ty::{ParamEnv, TyCtxt};\n+use rustc_middle::{\n+    hir::place::{PlaceBase, Projection, ProjectionKind},\n+    ty::TypeVisitable,\n+};\n \n pub(super) fn find_consumed_and_borrowed<'a, 'tcx>(\n     fcx: &'a FnCtxt<'a, 'tcx>,\n@@ -198,11 +201,13 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n \n         // If the type being assigned needs dropped, then the mutation counts as a borrow\n         // since it is essentially doing `Drop::drop(&mut x); x = new_value;`.\n-        //\n-        // FIXME(drop-tracking): We need to be more responsible about inference\n-        // variables here, since `needs_drop` is a \"raw\" type query, i.e. it\n-        // basically requires types to have been fully resolved.\n-        if assignee_place.place.base_ty.needs_drop(self.tcx, self.param_env) {\n+        let ty = self.tcx.erase_regions(assignee_place.place.base_ty);\n+        if ty.needs_infer() {\n+            self.tcx.sess.delay_span_bug(\n+                self.tcx.hir().span(assignee_place.hir_id),\n+                &format!(\"inference variables in {ty}\"),\n+            );\n+        } else if ty.needs_drop(self.tcx, self.param_env) {\n             self.places\n                 .borrowed\n                 .insert(TrackedValue::from_place_with_projections_allowed(assignee_place));"}, {"sha": "b7dd599cd432183b00f9a1233afd83a6bdd03783", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -377,15 +377,6 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         debug!(\"is_borrowed_temporary: {:?}\", self.drop_ranges.is_borrowed_temporary(expr));\n \n         let ty = self.fcx.typeck_results.borrow().expr_ty_adjusted_opt(expr);\n-        let may_need_drop = |ty: Ty<'tcx>| {\n-            // Avoid ICEs in needs_drop.\n-            let ty = self.fcx.resolve_vars_if_possible(ty);\n-            let ty = self.fcx.tcx.erase_regions(ty);\n-            if ty.needs_infer() {\n-                return true;\n-            }\n-            ty.needs_drop(self.fcx.tcx, self.fcx.param_env)\n-        };\n \n         // Typically, the value produced by an expression is consumed by its parent in some way,\n         // so we only have to check if the parent contains a yield (note that the parent may, for\n@@ -403,9 +394,18 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         // src/test/ui/generator/drop-tracking-parent-expression.rs.\n         let scope = if self.drop_ranges.is_borrowed_temporary(expr)\n             || ty.map_or(true, |ty| {\n-                let needs_drop = may_need_drop(ty);\n-                debug!(?needs_drop, ?ty);\n-                needs_drop\n+                // Avoid ICEs in needs_drop.\n+                let ty = self.fcx.resolve_vars_if_possible(ty);\n+                let ty = self.fcx.tcx.erase_regions(ty);\n+                if ty.needs_infer() {\n+                    self.fcx\n+                        .tcx\n+                        .sess\n+                        .delay_span_bug(expr.span, &format!(\"inference variables in {ty}\"));\n+                    true\n+                } else {\n+                    ty.needs_drop(self.fcx.tcx, self.fcx.param_env)\n+                }\n             }) {\n             self.rvalue_scopes.temporary_scope(self.region_scope_tree, expr.hir_id.local_id)\n         } else {"}, {"sha": "a0a0855251b8dc241837ce3e1488a9b8445b1184", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -587,11 +587,6 @@ impl CStore {\n         self.get_crate_data(cnum).get_proc_macro_quoted_span(id, sess)\n     }\n \n-    /// Decodes all traits in the crate (for rustdoc).\n-    pub fn traits_in_crate_untracked(&self, cnum: CrateNum) -> impl Iterator<Item = DefId> + '_ {\n-        self.get_crate_data(cnum).get_traits()\n-    }\n-\n     /// Decodes all trait impls in the crate (for rustdoc).\n     pub fn trait_impls_in_crate_untracked(\n         &self,"}, {"sha": "462bce16ad717d424c9a16185f9405d41f19646b", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -3,7 +3,9 @@ use rustc_ast::ast::{self, AttrStyle};\n use rustc_ast::token::{self, CommentKind, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::util::unicode::contains_text_flow_control_chars;\n-use rustc_errors::{error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n+use rustc_errors::{\n+    error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult, StashKey,\n+};\n use rustc_lexer::unescape::{self, Mode};\n use rustc_lexer::Cursor;\n use rustc_lexer::{Base, DocStyle, RawStrError};\n@@ -203,7 +205,10 @@ impl<'a> StringReader<'a> {\n                     // this is necessary.\n                     let lifetime_name = self.str_from(start);\n                     if starts_with_number {\n-                        self.err_span_(start, self.pos, \"lifetimes cannot start with a number\");\n+                        let span = self.mk_sp(start, self.pos);\n+                        let mut diag = self.sess.struct_err(\"lifetimes cannot start with a number\");\n+                        diag.set_span(span);\n+                        diag.stash(span, StashKey::LifetimeIsChar);\n                     }\n                     let ident = Symbol::intern(lifetime_name);\n                     token::Lifetime(ident)"}, {"sha": "98520a446a62f995de95dc087b56a3ad8b7e9951", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 67, "deletions": 9, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -42,8 +42,10 @@ use rustc_ast::{AnonConst, BinOp, BinOpKind, FnDecl, FnRetTy, MacCall, Param, Ty\n use rustc_ast::{Arm, Async, BlockCheckMode, Expr, ExprKind, Label, Movability, RangeLimits};\n use rustc_ast::{ClosureBinder, StmtKind};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::IntoDiagnostic;\n-use rustc_errors::{Applicability, Diagnostic, PResult};\n+use rustc_errors::{\n+    Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, PResult,\n+    StashKey,\n+};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_session::lint::builtin::BREAK_WITH_LABEL_AND_LOOP;\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -1513,11 +1515,11 @@ impl<'a> Parser<'a> {\n     /// Parse `'label: $expr`. The label is already parsed.\n     fn parse_labeled_expr(\n         &mut self,\n-        label: Label,\n+        label_: Label,\n         mut consume_colon: bool,\n     ) -> PResult<'a, P<Expr>> {\n-        let lo = label.ident.span;\n-        let label = Some(label);\n+        let lo = label_.ident.span;\n+        let label = Some(label_);\n         let ate_colon = self.eat(&token::Colon);\n         let expr = if self.eat_keyword(kw::While) {\n             self.parse_while_expr(label, lo)\n@@ -1529,6 +1531,19 @@ impl<'a> Parser<'a> {\n             || self.token.is_whole_block()\n         {\n             self.parse_block_expr(label, lo, BlockCheckMode::Default)\n+        } else if !ate_colon\n+            && (matches!(self.token.kind, token::CloseDelim(_) | token::Comma)\n+                || self.token.is_op())\n+        {\n+            let lit = self.recover_unclosed_char(label_.ident, |self_| {\n+                self_.sess.create_err(UnexpectedTokenAfterLabel {\n+                    span: self_.token.span,\n+                    remove_label: None,\n+                    enclose_in_block: None,\n+                })\n+            });\n+            consume_colon = false;\n+            Ok(self.mk_expr(lo, ExprKind::Lit(lit)))\n         } else if !ate_colon\n             && (self.check_noexpect(&TokenKind::Comma) || self.check_noexpect(&TokenKind::Gt))\n         {\n@@ -1603,6 +1618,39 @@ impl<'a> Parser<'a> {\n         Ok(expr)\n     }\n \n+    /// Emit an error when a char is parsed as a lifetime because of a missing quote\n+    pub(super) fn recover_unclosed_char(\n+        &mut self,\n+        lifetime: Ident,\n+        err: impl FnOnce(&mut Self) -> DiagnosticBuilder<'a, ErrorGuaranteed>,\n+    ) -> ast::Lit {\n+        if let Some(mut diag) =\n+            self.sess.span_diagnostic.steal_diagnostic(lifetime.span, StashKey::LifetimeIsChar)\n+        {\n+            diag.span_suggestion_verbose(\n+                lifetime.span.shrink_to_hi(),\n+                \"add `'` to close the char literal\",\n+                \"'\",\n+                Applicability::MaybeIncorrect,\n+            )\n+            .emit();\n+        } else {\n+            err(self)\n+                .span_suggestion_verbose(\n+                    lifetime.span.shrink_to_hi(),\n+                    \"add `'` to close the char literal\",\n+                    \"'\",\n+                    Applicability::MaybeIncorrect,\n+                )\n+                .emit();\n+        }\n+        ast::Lit {\n+            token_lit: token::Lit::new(token::LitKind::Char, lifetime.name, None),\n+            kind: ast::LitKind::Char(lifetime.name.as_str().chars().next().unwrap_or('_')),\n+            span: lifetime.span,\n+        }\n+    }\n+\n     /// Recover on the syntax `do catch { ... }` suggesting `try { ... }` instead.\n     fn recover_do_catch(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n@@ -1728,7 +1776,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn parse_lit(&mut self) -> PResult<'a, Lit> {\n-        self.parse_opt_lit().ok_or_else(|| {\n+        self.parse_opt_lit().ok_or(()).or_else(|()| {\n             if let token::Interpolated(inner) = &self.token.kind {\n                 let expr = match inner.as_ref() {\n                     token::NtExpr(expr) => Some(expr),\n@@ -1740,12 +1788,22 @@ impl<'a> Parser<'a> {\n                         let mut err = InvalidInterpolatedExpression { span: self.token.span }\n                             .into_diagnostic(&self.sess.span_diagnostic);\n                         err.downgrade_to_delayed_bug();\n-                        return err;\n+                        return Err(err);\n                     }\n                 }\n             }\n-            let msg = format!(\"unexpected token: {}\", super::token_descr(&self.token));\n-            self.struct_span_err(self.token.span, &msg)\n+            let token = self.token.clone();\n+            let err = |self_: &mut Self| {\n+                let msg = format!(\"unexpected token: {}\", super::token_descr(&token));\n+                self_.struct_span_err(token.span, &msg)\n+            };\n+            // On an error path, eagerly consider a lifetime to be an unclosed character lit\n+            if self.token.is_lifetime() {\n+                let lt = self.expect_lifetime();\n+                Ok(self.recover_unclosed_char(lt.ident, err))\n+            } else {\n+                Err(err(self))\n+            }\n         })\n     }\n "}, {"sha": "52c11b4e35f34372b59e21ac27037cc38e9a7269", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -402,6 +402,25 @@ impl<'a> Parser<'a> {\n             } else {\n                 PatKind::Path(qself, path)\n             }\n+        } else if matches!(self.token.kind, token::Lifetime(_))\n+            // In pattern position, we're totally fine with using \"next token isn't colon\"\n+            // as a heuristic. We could probably just always try to recover if it's a lifetime,\n+            // because we never have `'a: label {}` in a pattern position anyways, but it does\n+            // keep us from suggesting something like `let 'a: Ty = ..` => `let 'a': Ty = ..`\n+            && !self.look_ahead(1, |token| matches!(token.kind, token::Colon))\n+        {\n+            // Recover a `'a` as a `'a'` literal\n+            let lt = self.expect_lifetime();\n+            let lit = self.recover_unclosed_char(lt.ident, |self_| {\n+                let expected = expected.unwrap_or(\"pattern\");\n+                let msg =\n+                    format!(\"expected {}, found {}\", expected, super::token_descr(&self_.token));\n+\n+                let mut err = self_.struct_span_err(self_.token.span, &msg);\n+                err.span_label(self_.token.span, format!(\"expected {}\", expected));\n+                err\n+            });\n+            PatKind::Lit(self.mk_expr(lo, ExprKind::Lit(lit)))\n         } else {\n             // Try to parse everything else as literal with optional minus\n             match self.parse_literal_maybe_minus() {\n@@ -799,6 +818,7 @@ impl<'a> Parser<'a> {\n                 || t.kind == token::Dot // e.g. `.5` for recovery;\n                 || t.can_begin_literal_maybe_minus() // e.g. `42`.\n                 || t.is_whole_expr()\n+                || t.is_lifetime() // recover `'a` instead of `'a'`\n             })\n     }\n "}, {"sha": "257784341e3f8de3ed6d6064d81d2f18168fa437", "filename": "compiler/rustc_resolve/src/access_levels.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -1,5 +1,4 @@\n-use crate::NameBindingKind;\n-use crate::Resolver;\n+use crate::{ImportKind, NameBindingKind, Resolver};\n use rustc_ast::ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n@@ -45,31 +44,40 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n         let module = self.r.get_module(module_id.to_def_id()).unwrap();\n         let resolutions = self.r.resolutions(module);\n \n-        for (key, name_resolution) in resolutions.borrow().iter() {\n+        for (_, name_resolution) in resolutions.borrow().iter() {\n             if let Some(mut binding) = name_resolution.borrow().binding() && !binding.is_ambiguity() {\n                 // Set the given binding access level to `AccessLevel::Public` and\n                 // sets the rest of the `use` chain to `AccessLevel::Exported` until\n                 // we hit the actual exported item.\n \n-                // FIXME: tag and is_public() condition must be deleted,\n-                // but assertion fail occurs in import_id_for_ns\n+                // FIXME: tag and is_public() condition should be removed, but assertions occur.\n                 let tag = if binding.is_import() { AccessLevel::Exported } else { AccessLevel::Public };\n                 if binding.vis.is_public() {\n                     let mut prev_parent_id = module_id;\n                     let mut level = AccessLevel::Public;\n                     while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n                         binding.kind\n                     {\n-                        let id = self.r.local_def_id(self.r.import_id_for_ns(import, key.ns));\n-                        self.update(\n-                            id,\n+                        let mut update = |node_id| self.update(\n+                            self.r.local_def_id(node_id),\n                             binding.vis.expect_local(),\n                             prev_parent_id,\n                             level,\n                         );\n+                        // In theory all the import IDs have individual visibilities and effective\n+                        // visibilities, but in practice these IDs go straigth to HIR where all\n+                        // their few uses assume that their (effective) visibility applies to the\n+                        // whole syntactic `use` item. So we update them all to the maximum value\n+                        // among the potential individual effective visibilities. Maybe HIR for\n+                        // imports shouldn't use three IDs at all.\n+                        update(import.id);\n+                        if let ImportKind::Single { additional_ids, .. } = import.kind {\n+                            update(additional_ids.0);\n+                            update(additional_ids.1);\n+                        }\n \n                         level = AccessLevel::Exported;\n-                        prev_parent_id = id;\n+                        prev_parent_id = self.r.local_def_id(import.id);\n                         binding = nested_binding;\n                     }\n                 }"}, {"sha": "f2cc50c199fc8119dda242d66136d406d4e77adf", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -2,7 +2,7 @@\n \n use crate::diagnostics::{import_candidates, Suggestion};\n use crate::Determinacy::{self, *};\n-use crate::Namespace::{self, *};\n+use crate::Namespace::*;\n use crate::{module_to_string, names_to_string, ImportSuggestion};\n use crate::{AmbiguityKind, BindingKey, ModuleKind, ResolutionError, Resolver, Segment};\n use crate::{Finalize, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet};\n@@ -371,31 +371,6 @@ impl<'a> Resolver<'a> {\n             self.used_imports.insert(import.id);\n         }\n     }\n-\n-    /// Take primary and additional node IDs from an import and select one that corresponds to the\n-    /// given namespace. The logic must match the corresponding logic from `fn lower_use_tree` that\n-    /// assigns resolutons to IDs.\n-    pub(crate) fn import_id_for_ns(&self, import: &Import<'_>, ns: Namespace) -> NodeId {\n-        if let ImportKind::Single { additional_ids: (id1, id2), .. } = import.kind {\n-            if let Some(resolutions) = self.import_res_map.get(&import.id) {\n-                assert!(resolutions[ns].is_some(), \"incorrectly finalized import\");\n-                return match ns {\n-                    TypeNS => import.id,\n-                    ValueNS => match resolutions.type_ns {\n-                        Some(_) => id1,\n-                        None => import.id,\n-                    },\n-                    MacroNS => match (resolutions.type_ns, resolutions.value_ns) {\n-                        (Some(_), Some(_)) => id2,\n-                        (Some(_), None) | (None, Some(_)) => id1,\n-                        (None, None) => import.id,\n-                    },\n-                };\n-            }\n-        }\n-\n-        import.id\n-    }\n }\n \n /// An error that may be transformed into a diagnostic later. Used to combine multiple unresolved"}, {"sha": "58853346a92889e8cdca7d8ddaaf34ef3640e9eb", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -524,6 +524,9 @@ struct DiagnosticMetadata<'ast> {\n     /// Used to detect possible `if let` written without `let` and to provide structured suggestion.\n     in_if_condition: Option<&'ast Expr>,\n \n+    /// Used to detect possible new binding written without `let` and to provide structured suggestion.\n+    in_assignment: Option<&'ast Expr>,\n+\n     /// If we are currently in a trait object definition. Used to point at the bounds when\n     /// encountering a struct or enum.\n     current_trait_object: Option<&'ast [ast::GenericBound]>,\n@@ -3905,6 +3908,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.resolve_expr(elem, Some(expr));\n                 self.visit_expr(idx);\n             }\n+            ExprKind::Assign(..) => {\n+                let old = self.diagnostic_metadata.in_assignment.replace(expr);\n+                visit::walk_expr(self, expr);\n+                self.diagnostic_metadata.in_assignment = old;\n+            }\n             _ => {\n                 visit::walk_expr(self, expr);\n             }"}, {"sha": "23c5fac8b71c1a54f623a0f8d308d36911e7103e", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 43, "deletions": 53, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -708,7 +708,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n             // If the trait has a single item (which wasn't matched by Levenshtein), suggest it\n             let suggestion = self.get_single_associated_item(&path, &source, is_expected);\n-            self.r.add_typo_suggestion(err, suggestion, ident_span);\n+            if !self.r.add_typo_suggestion(err, suggestion, ident_span) {\n+                fallback = !self.let_binding_suggestion(err, ident_span);\n+            }\n         }\n         fallback\n     }\n@@ -1105,41 +1107,14 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         // where a brace being opened means a block is being started. Look\n         // ahead for the next text to see if `span` is followed by a `{`.\n         let sm = self.r.session.source_map();\n-        let mut sp = span;\n-        loop {\n-            sp = sm.next_point(sp);\n-            match sm.span_to_snippet(sp) {\n-                Ok(ref snippet) => {\n-                    if snippet.chars().any(|c| !c.is_whitespace()) {\n-                        break;\n-                    }\n-                }\n-                _ => break,\n-            }\n-        }\n+        let sp = sm.span_look_ahead(span, None, Some(50));\n         let followed_by_brace = matches!(sm.span_to_snippet(sp), Ok(ref snippet) if snippet == \"{\");\n         // In case this could be a struct literal that needs to be surrounded\n         // by parentheses, find the appropriate span.\n-        let mut i = 0;\n-        let mut closing_brace = None;\n-        loop {\n-            sp = sm.next_point(sp);\n-            match sm.span_to_snippet(sp) {\n-                Ok(ref snippet) => {\n-                    if snippet == \"}\" {\n-                        closing_brace = Some(span.to(sp));\n-                        break;\n-                    }\n-                }\n-                _ => break,\n-            }\n-            i += 1;\n-            // The bigger the span, the more likely we're incorrect --\n-            // bound it to 100 chars long.\n-            if i > 100 {\n-                break;\n-            }\n-        }\n+        let closing_span = sm.span_look_ahead(span, Some(\"}\"), Some(50));\n+        let closing_brace: Option<Span> = sm\n+            .span_to_snippet(closing_span)\n+            .map_or(None, |s| if s == \"}\" { Some(span.to(closing_span)) } else { None });\n         (followed_by_brace, closing_brace)\n     }\n \n@@ -1779,26 +1754,16 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                             }\n                         }\n                         if let Ok(base_snippet) = base_snippet {\n-                            let mut sp = after_colon_sp;\n-                            for _ in 0..100 {\n-                                // Try to find an assignment\n-                                sp = sm.next_point(sp);\n-                                let snippet = sm.span_to_snippet(sp);\n-                                match snippet {\n-                                    Ok(ref x) if x.as_str() == \"=\" => {\n-                                        err.span_suggestion(\n-                                            base_span,\n-                                            \"maybe you meant to write an assignment here\",\n-                                            format!(\"let {}\", base_snippet),\n-                                            Applicability::MaybeIncorrect,\n-                                        );\n-                                        show_label = false;\n-                                        break;\n-                                    }\n-                                    Ok(ref x) if x.as_str() == \"\\n\" => break,\n-                                    Err(_) => break,\n-                                    Ok(_) => {}\n-                                }\n+                            // Try to find an assignment\n+                            let eq_span = sm.span_look_ahead(after_colon_sp, Some(\"=\"), Some(50));\n+                            if let Ok(ref snippet) = sm.span_to_snippet(eq_span) && snippet == \"=\" {\n+                                err.span_suggestion(\n+                                    base_span,\n+                                    \"maybe you meant to write an assignment here\",\n+                                    format!(\"let {}\", base_snippet),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                show_label = false;\n                             }\n                         }\n                     }\n@@ -1815,6 +1780,31 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         false\n     }\n \n+    fn let_binding_suggestion(&self, err: &mut Diagnostic, ident_span: Span) -> bool {\n+        // try to give a suggestion for this pattern: `name = 1`, which is common in other languages\n+        let mut added_suggestion = false;\n+        if let Some(Expr { kind: ExprKind::Assign(lhs, _rhs, _), .. }) = self.diagnostic_metadata.in_assignment &&\n+            let ast::ExprKind::Path(None, _) = lhs.kind {\n+                let sm = self.r.session.source_map();\n+                let line_span = sm.span_extend_to_line(ident_span);\n+                let ident_name = sm.span_to_snippet(ident_span).unwrap();\n+                // HACK(chenyukang): make sure ident_name is at the starting of the line to protect against macros\n+                if sm\n+                    .span_to_snippet(line_span)\n+                    .map_or(false, |s| s.trim().starts_with(&ident_name))\n+                {\n+                    err.span_suggestion_verbose(\n+                        ident_span.shrink_to_lo(),\n+                        \"you might have meant to introduce a new binding\",\n+                        \"let \".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    added_suggestion = true;\n+                }\n+            }\n+        added_suggestion\n+    }\n+\n     fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {\n         let mut result = None;\n         let mut seen_modules = FxHashSet::default();"}, {"sha": "f9566eeee9465949b17e4c133a7b7f3d5d31e1ff", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -877,6 +877,26 @@ impl SourceMap {\n         Span::new(BytePos(start_of_next_point), end_of_next_point, sp.ctxt(), None)\n     }\n \n+    /// Returns a new span to check next none-whitespace character or some specified expected character\n+    /// If `expect` is none, the first span of non-whitespace character is returned.\n+    /// If `expect` presented, the first span of the character `expect` is returned\n+    /// Otherwise, the span reached to limit is returned.\n+    pub fn span_look_ahead(&self, span: Span, expect: Option<&str>, limit: Option<usize>) -> Span {\n+        let mut sp = span;\n+        for _ in 0..limit.unwrap_or(100 as usize) {\n+            sp = self.next_point(sp);\n+            if let Ok(ref snippet) = self.span_to_snippet(sp) {\n+                if expect.map_or(false, |es| snippet == es) {\n+                    break;\n+                }\n+                if expect.is_none() && snippet.chars().any(|c| !c.is_whitespace()) {\n+                    break;\n+                }\n+            }\n+        }\n+        sp\n+    }\n+\n     /// Finds the width of the character, either before or after the end of provided span,\n     /// depending on the `forwards` parameter.\n     fn find_width_of_character_at_span(&self, sp: Span, forwards: bool) -> u32 {"}, {"sha": "7c59e785752dcc9cfccc65169b425455f2f1dcf1", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 102, "deletions": 94, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -13,116 +13,124 @@ pub(crate) struct BlanketImplFinder<'a, 'tcx> {\n \n impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n     pub(crate) fn get_blanket_impls(&mut self, item_def_id: DefId) -> Vec<Item> {\n-        let param_env = self.cx.tcx.param_env(item_def_id);\n-        let ty = self.cx.tcx.bound_type_of(item_def_id);\n+        let cx = &mut self.cx;\n+        let param_env = cx.tcx.param_env(item_def_id);\n+        let ty = cx.tcx.bound_type_of(item_def_id);\n \n         trace!(\"get_blanket_impls({:?})\", ty);\n         let mut impls = Vec::new();\n-        self.cx.with_all_traits(|cx, all_traits| {\n-            for &trait_def_id in all_traits {\n-                if !cx.cache.access_levels.is_public(trait_def_id)\n-                    || cx.generated_synthetics.get(&(ty.0, trait_def_id)).is_some()\n-                {\n+        for trait_def_id in cx.tcx.all_traits() {\n+            if !cx.cache.access_levels.is_public(trait_def_id)\n+                || cx.generated_synthetics.get(&(ty.0, trait_def_id)).is_some()\n+            {\n+                continue;\n+            }\n+            // NOTE: doesn't use `for_each_relevant_impl` to avoid looking at anything besides blanket impls\n+            let trait_impls = cx.tcx.trait_impls_of(trait_def_id);\n+            'blanket_impls: for &impl_def_id in trait_impls.blanket_impls() {\n+                trace!(\n+                    \"get_blanket_impls: Considering impl for trait '{:?}' {:?}\",\n+                    trait_def_id,\n+                    impl_def_id\n+                );\n+                let trait_ref = cx.tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n+                if !matches!(trait_ref.0.self_ty().kind(), ty::Param(_)) {\n                     continue;\n                 }\n-                // NOTE: doesn't use `for_each_relevant_impl` to avoid looking at anything besides blanket impls\n-                let trait_impls = cx.tcx.trait_impls_of(trait_def_id);\n-                'blanket_impls: for &impl_def_id in trait_impls.blanket_impls() {\n-                    trace!(\n-                        \"get_blanket_impls: Considering impl for trait '{:?}' {:?}\",\n-                        trait_def_id,\n-                        impl_def_id\n-                    );\n-                    let trait_ref = cx.tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n-                    if !matches!(trait_ref.0.self_ty().kind(), ty::Param(_)) {\n-                        continue;\n-                    }\n-                    let infcx = cx.tcx.infer_ctxt().build();\n-                    let substs = infcx.fresh_substs_for_item(DUMMY_SP, item_def_id);\n-                    let impl_ty = ty.subst(infcx.tcx, substs);\n-                    let param_env = EarlyBinder(param_env).subst(infcx.tcx, substs);\n+                let infcx = cx.tcx.infer_ctxt().build();\n+                let substs = infcx.fresh_substs_for_item(DUMMY_SP, item_def_id);\n+                let impl_ty = ty.subst(infcx.tcx, substs);\n+                let param_env = EarlyBinder(param_env).subst(infcx.tcx, substs);\n \n-                    let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n-                    let impl_trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n+                let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+                let impl_trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n \n-                    // Require the type the impl is implemented on to match\n-                    // our type, and ignore the impl if there was a mismatch.\n-                    let cause = traits::ObligationCause::dummy();\n-                    let Ok(eq_result) = infcx.at(&cause, param_env).eq(impl_trait_ref.self_ty(), impl_ty) else {\n+                // Require the type the impl is implemented on to match\n+                // our type, and ignore the impl if there was a mismatch.\n+                let cause = traits::ObligationCause::dummy();\n+                let Ok(eq_result) = infcx.at(&cause, param_env).eq(impl_trait_ref.self_ty(), impl_ty) else {\n                         continue\n                     };\n-                    let InferOk { value: (), obligations } = eq_result;\n-                    // FIXME(eddyb) ignoring `obligations` might cause false positives.\n-                    drop(obligations);\n+                let InferOk { value: (), obligations } = eq_result;\n+                // FIXME(eddyb) ignoring `obligations` might cause false positives.\n+                drop(obligations);\n \n-                    trace!(\n-                        \"invoking predicate_may_hold: param_env={:?}, impl_trait_ref={:?}, impl_ty={:?}\",\n+                trace!(\n+                    \"invoking predicate_may_hold: param_env={:?}, impl_trait_ref={:?}, impl_ty={:?}\",\n+                    param_env,\n+                    impl_trait_ref,\n+                    impl_ty\n+                );\n+                let predicates = cx\n+                    .tcx\n+                    .predicates_of(impl_def_id)\n+                    .instantiate(cx.tcx, impl_substs)\n+                    .predicates\n+                    .into_iter()\n+                    .chain(Some(\n+                        ty::Binder::dummy(impl_trait_ref)\n+                            .to_poly_trait_predicate()\n+                            .map_bound(ty::PredicateKind::Trait)\n+                            .to_predicate(infcx.tcx),\n+                    ));\n+                for predicate in predicates {\n+                    debug!(\"testing predicate {:?}\", predicate);\n+                    let obligation = traits::Obligation::new(\n+                        traits::ObligationCause::dummy(),\n                         param_env,\n-                        impl_trait_ref,\n-                        impl_ty\n+                        predicate,\n                     );\n-                    let predicates = cx\n-                        .tcx\n-                        .predicates_of(impl_def_id)\n-                        .instantiate(cx.tcx, impl_substs)\n-                        .predicates\n-                        .into_iter()\n-                        .chain(Some(\n-                            ty::Binder::dummy(impl_trait_ref)\n-                                .to_poly_trait_predicate()\n-                                .map_bound(ty::PredicateKind::Trait)\n-                                .to_predicate(infcx.tcx),\n-                        ));\n-                    for predicate in predicates {\n-                        debug!(\"testing predicate {:?}\", predicate);\n-                        let obligation = traits::Obligation::new(\n-                            traits::ObligationCause::dummy(),\n-                            param_env,\n-                            predicate,\n-                        );\n-                        match infcx.evaluate_obligation(&obligation) {\n-                            Ok(eval_result) if eval_result.may_apply() => {}\n-                            Err(traits::OverflowError::Canonical) => {}\n-                            Err(traits::OverflowError::ErrorReporting) => {}\n-                            _ => continue 'blanket_impls,\n-                        }\n+                    match infcx.evaluate_obligation(&obligation) {\n+                        Ok(eval_result) if eval_result.may_apply() => {}\n+                        Err(traits::OverflowError::Canonical) => {}\n+                        Err(traits::OverflowError::ErrorReporting) => {}\n+                        _ => continue 'blanket_impls,\n                     }\n-                    debug!(\n-                        \"get_blanket_impls: found applicable impl for trait_ref={:?}, ty={:?}\",\n-                        trait_ref, ty\n-                    );\n+                }\n+                debug!(\n+                    \"get_blanket_impls: found applicable impl for trait_ref={:?}, ty={:?}\",\n+                    trait_ref, ty\n+                );\n \n-                    cx.generated_synthetics.insert((ty.0, trait_def_id));\n+                cx.generated_synthetics.insert((ty.0, trait_def_id));\n \n-                    impls.push(Item {\n-                        name: None,\n-                        attrs: Default::default(),\n-                        visibility: Inherited,\n-                        item_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n-                        kind: Box::new(ImplItem(Box::new(Impl {\n-                            unsafety: hir::Unsafety::Normal,\n-                            generics: clean_ty_generics(\n-                                cx,\n-                                cx.tcx.generics_of(impl_def_id),\n-                                cx.tcx.explicit_predicates_of(impl_def_id),\n-                            ),\n-                            // FIXME(eddyb) compute both `trait_` and `for_` from\n-                            // the post-inference `trait_ref`, as it's more accurate.\n-                            trait_: Some(clean_trait_ref_with_bindings(cx, trait_ref.0, ThinVec::new())),\n-                            for_: clean_middle_ty(ty.0, cx, None),\n-                            items: cx.tcx\n-                                .associated_items(impl_def_id)\n-                                .in_definition_order()\n-                                .map(|x| clean_middle_assoc_item(x, cx))\n-                                .collect::<Vec<_>>(),\n-                            polarity: ty::ImplPolarity::Positive,\n-                            kind: ImplKind::Blanket(Box::new(clean_middle_ty(trait_ref.0.self_ty(), cx, None))),\n-                        }))),\n-                        cfg: None,\n-                    });\n-                }\n+                impls.push(Item {\n+                    name: None,\n+                    attrs: Default::default(),\n+                    visibility: Inherited,\n+                    item_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n+                    kind: Box::new(ImplItem(Box::new(Impl {\n+                        unsafety: hir::Unsafety::Normal,\n+                        generics: clean_ty_generics(\n+                            cx,\n+                            cx.tcx.generics_of(impl_def_id),\n+                            cx.tcx.explicit_predicates_of(impl_def_id),\n+                        ),\n+                        // FIXME(eddyb) compute both `trait_` and `for_` from\n+                        // the post-inference `trait_ref`, as it's more accurate.\n+                        trait_: Some(clean_trait_ref_with_bindings(\n+                            cx,\n+                            trait_ref.0,\n+                            ThinVec::new(),\n+                        )),\n+                        for_: clean_middle_ty(ty.0, cx, None),\n+                        items: cx\n+                            .tcx\n+                            .associated_items(impl_def_id)\n+                            .in_definition_order()\n+                            .map(|x| clean_middle_assoc_item(x, cx))\n+                            .collect::<Vec<_>>(),\n+                        polarity: ty::ImplPolarity::Positive,\n+                        kind: ImplKind::Blanket(Box::new(clean_middle_ty(\n+                            trait_ref.0.self_ty(),\n+                            cx,\n+                            None,\n+                        ))),\n+                    }))),\n+                    cfg: None,\n+                });\n             }\n-        });\n+        }\n \n         impls\n     }"}, {"sha": "8232353f915b948419eaedeb56a9591ca3575856", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -38,7 +38,6 @@ pub(crate) struct ResolverCaches {\n     /// Traits in scope for a given module.\n     /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n     pub(crate) traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n-    pub(crate) all_traits: Option<Vec<DefId>>,\n     pub(crate) all_trait_impls: Option<Vec<DefId>>,\n     pub(crate) all_macro_rules: FxHashMap<Symbol, Res<NodeId>>,\n }\n@@ -134,12 +133,6 @@ impl<'tcx> DocContext<'tcx> {\n         }\n     }\n \n-    pub(crate) fn with_all_traits(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n-        let all_traits = self.resolver_caches.all_traits.take();\n-        f(self, all_traits.as_ref().expect(\"`all_traits` are already borrowed\"));\n-        self.resolver_caches.all_traits = all_traits;\n-    }\n-\n     pub(crate) fn with_all_trait_impls(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n         let all_trait_impls = self.resolver_caches.all_trait_impls.take();\n         f(self, all_trait_impls.as_ref().expect(\"`all_trait_impls` are already borrowed\"));\n@@ -353,14 +346,8 @@ pub(crate) fn run_global_ctxt(\n     });\n     rustc_passes::stability::check_unused_or_stable_features(tcx);\n \n-    let auto_traits = resolver_caches\n-        .all_traits\n-        .as_ref()\n-        .expect(\"`all_traits` are already borrowed\")\n-        .iter()\n-        .copied()\n-        .filter(|&trait_def_id| tcx.trait_is_auto(trait_def_id))\n-        .collect();\n+    let auto_traits =\n+        tcx.all_traits().filter(|&trait_def_id| tcx.trait_is_auto(trait_def_id)).collect();\n     let access_levels = tcx.privacy_access_levels(()).map_id(Into::into);\n \n     let mut ctxt = DocContext {"}, {"sha": "d121a3e2aa4a9f750d60f78a3db0329b6782df0a", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -37,7 +37,6 @@ pub(crate) fn early_resolve_intra_doc_links(\n         markdown_links: Default::default(),\n         doc_link_resolutions: Default::default(),\n         traits_in_scope: Default::default(),\n-        all_traits: Default::default(),\n         all_trait_impls: Default::default(),\n         all_macro_rules: Default::default(),\n         document_private_items,\n@@ -63,7 +62,6 @@ pub(crate) fn early_resolve_intra_doc_links(\n         markdown_links: Some(link_resolver.markdown_links),\n         doc_link_resolutions: link_resolver.doc_link_resolutions,\n         traits_in_scope: link_resolver.traits_in_scope,\n-        all_traits: Some(link_resolver.all_traits),\n         all_trait_impls: Some(link_resolver.all_trait_impls),\n         all_macro_rules: link_resolver.all_macro_rules,\n     }\n@@ -81,7 +79,6 @@ struct EarlyDocLinkResolver<'r, 'ra> {\n     markdown_links: FxHashMap<String, Vec<PreprocessedMarkdownLink>>,\n     doc_link_resolutions: FxHashMap<(Symbol, Namespace, DefId), Option<Res<ast::NodeId>>>,\n     traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n-    all_traits: Vec<DefId>,\n     all_trait_impls: Vec<DefId>,\n     all_macro_rules: FxHashMap<Symbol, Res<ast::NodeId>>,\n     document_private_items: bool,\n@@ -122,8 +119,6 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n         loop {\n             let crates = Vec::from_iter(self.resolver.cstore().crates_untracked());\n             for &cnum in &crates[start_cnum..] {\n-                let all_traits =\n-                    Vec::from_iter(self.resolver.cstore().traits_in_crate_untracked(cnum));\n                 let all_trait_impls =\n                     Vec::from_iter(self.resolver.cstore().trait_impls_in_crate_untracked(cnum));\n                 let all_inherent_impls =\n@@ -132,20 +127,18 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n                     self.resolver.cstore().incoherent_impls_in_crate_untracked(cnum),\n                 );\n \n-                // Querying traits in scope is expensive so we try to prune the impl and traits lists\n-                // using privacy, private traits and impls from other crates are never documented in\n+                // Querying traits in scope is expensive so we try to prune the impl lists using\n+                // privacy, private traits and impls from other crates are never documented in\n                 // the current crate, and links in their doc comments are not resolved.\n-                for &def_id in &all_traits {\n-                    if self.resolver.cstore().visibility_untracked(def_id).is_public() {\n-                        self.resolve_doc_links_extern_impl(def_id, false);\n-                    }\n-                }\n                 for &(trait_def_id, impl_def_id, simplified_self_ty) in &all_trait_impls {\n                     if self.resolver.cstore().visibility_untracked(trait_def_id).is_public()\n                         && simplified_self_ty.and_then(|ty| ty.def()).map_or(true, |ty_def_id| {\n                             self.resolver.cstore().visibility_untracked(ty_def_id).is_public()\n                         })\n                     {\n+                        if self.visited_mods.insert(trait_def_id) {\n+                            self.resolve_doc_links_extern_impl(trait_def_id, false);\n+                        }\n                         self.resolve_doc_links_extern_impl(impl_def_id, false);\n                     }\n                 }\n@@ -158,7 +151,6 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n                     self.resolve_doc_links_extern_impl(impl_def_id, true);\n                 }\n \n-                self.all_traits.extend(all_traits);\n                 self.all_trait_impls\n                     .extend(all_trait_impls.into_iter().map(|(_, def_id, _)| def_id));\n             }\n@@ -307,15 +299,20 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n             {\n                 if let Some(def_id) = child.res.opt_def_id() && !def_id.is_local() {\n                     let scope_id = match child.res {\n-                        Res::Def(DefKind::Variant, ..) => self.resolver.parent(def_id),\n+                        Res::Def(\n+                            DefKind::Variant\n+                            | DefKind::AssocTy\n+                            | DefKind::AssocFn\n+                            | DefKind::AssocConst,\n+                            ..,\n+                        ) => self.resolver.parent(def_id),\n                         _ => def_id,\n                     };\n                     self.resolve_doc_links_extern_outer(def_id, scope_id); // Outer attribute scope\n                     if let Res::Def(DefKind::Mod, ..) = child.res {\n                         self.resolve_doc_links_extern_inner(def_id); // Inner attribute scope\n                     }\n-                    // `DefKind::Trait`s are processed in `process_extern_impls`.\n-                    if let Res::Def(DefKind::Mod | DefKind::Enum, ..) = child.res {\n+                    if let Res::Def(DefKind::Mod | DefKind::Enum | DefKind::Trait, ..) = child.res {\n                         self.process_module_children_or_reexports(def_id);\n                     }\n                     if let Res::Def(DefKind::Struct | DefKind::Union | DefKind::Variant, _) =\n@@ -357,9 +354,6 @@ impl Visitor<'_> for EarlyDocLinkResolver<'_, '_> {\n             self.parent_scope.module = old_module;\n         } else {\n             match &item.kind {\n-                ItemKind::Trait(..) => {\n-                    self.all_traits.push(self.resolver.local_def_id(item.id).to_def_id());\n-                }\n                 ItemKind::Impl(box ast::Impl { of_trait: Some(..), .. }) => {\n                     self.all_trait_impls.push(self.resolver.local_def_id(item.id).to_def_id());\n                 }"}, {"sha": "d45aaa843fb6e4eb6c20c533c7b9c870a73834f1", "filename": "src/test/ui/borrowck/issue-23338-params-outlive-temps-of-body.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fborrowck%2Fissue-23338-params-outlive-temps-of-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fborrowck%2Fissue-23338-params-outlive-temps-of-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-23338-params-outlive-temps-of-body.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "previous_filename": "src/test/ui/issues/issue-23338-params-outlive-temps-of-body.rs"}, {"sha": "a99f260dde3b260f871dcc2a1ee92c4ee5ce315d", "filename": "src/test/ui/drop/issue-23338-ensure-param-drop-order.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fdrop%2Fissue-23338-ensure-param-drop-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fdrop%2Fissue-23338-ensure-param-drop-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fissue-23338-ensure-param-drop-order.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "previous_filename": "src/test/ui/issues/issue-23338-ensure-param-drop-order.rs"}, {"sha": "45761b61c3e95097b5108020b3188d8473998c1a", "filename": "src/test/ui/dropck/issue-24805-dropck-itemless.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fdropck%2Fissue-24805-dropck-itemless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fdropck%2Fissue-24805-dropck-itemless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fissue-24805-dropck-itemless.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "previous_filename": "src/test/ui/issues/issue-24805-dropck-itemless.rs"}, {"sha": "5c6d078041600b7d92b7a1f083e52826d8a0675e", "filename": "src/test/ui/inference/issue-36053.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Finference%2Fissue-36053.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Finference%2Fissue-36053.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-36053.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "previous_filename": "src/test/ui/issues/issue-36053.rs"}, {"sha": "274245f1a465f33d807d57590a08396cf3ee9fcf", "filename": "src/test/ui/parser/issues/issue-93282.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-93282.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-93282.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-93282.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -12,4 +12,5 @@ fn foo() {\n     let x = 1;\n     bar('y, x);\n     //~^ ERROR expected\n+    //~| ERROR mismatched types\n }"}, {"sha": "c6140bb821e48b985390c2ececf2adeeb7f9b152", "filename": "src/test/ui/parser/issues/issue-93282.stderr", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-93282.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-93282.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-93282.stderr?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -3,6 +3,11 @@ error: expected `while`, `for`, `loop` or `{` after a label\n    |\n LL |     f<'a,>\n    |         ^ expected `while`, `for`, `loop` or `{` after a label\n+   |\n+help: add `'` to close the char literal\n+   |\n+LL |     f<'a',>\n+   |         +\n \n error: expected one of `.`, `:`, `;`, `?`, `for`, `loop`, `while`, `}`, or an operator, found `,`\n   --> $DIR/issue-93282.rs:2:9\n@@ -20,6 +25,26 @@ error: expected `while`, `for`, `loop` or `{` after a label\n    |\n LL |     bar('y, x);\n    |           ^ expected `while`, `for`, `loop` or `{` after a label\n+   |\n+help: add `'` to close the char literal\n+   |\n+LL |     bar('y', x);\n+   |           +\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-93282.rs:13:9\n+   |\n+LL |     bar('y, x);\n+   |     --- ^^ expected `usize`, found `char`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+note: function defined here\n+  --> $DIR/issue-93282.rs:7:4\n+   |\n+LL | fn bar(a: usize, b: usize) -> usize {\n+   |    ^^^ --------\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "183da603da43480a47051d4839e21cc282a09e64", "filename": "src/test/ui/parser/label-is-actually-char.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fparser%2Flabel-is-actually-char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fparser%2Flabel-is-actually-char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flabel-is-actually-char.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -0,0 +1,16 @@\n+fn main() {\n+    let c = 'a;\n+    //~^ ERROR expected `while`, `for`, `loop` or `{` after a label\n+    //~| HELP add `'` to close the char literal\n+    match c {\n+        'a'..='b => {}\n+        //~^ ERROR unexpected token: `'b`\n+        //~| HELP add `'` to close the char literal\n+        _ => {}\n+    }\n+    let x = ['a, 'b];\n+    //~^ ERROR expected `while`, `for`, `loop` or `{` after a label\n+    //~| ERROR expected `while`, `for`, `loop` or `{` after a label\n+    //~| HELP add `'` to close the char literal\n+    //~| HELP add `'` to close the char literal\n+}"}, {"sha": "28c8d2ada3adbb56dd1fc12ca34941ad0379c1c0", "filename": "src/test/ui/parser/label-is-actually-char.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fparser%2Flabel-is-actually-char.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fparser%2Flabel-is-actually-char.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flabel-is-actually-char.stderr?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -0,0 +1,46 @@\n+error: expected `while`, `for`, `loop` or `{` after a label\n+  --> $DIR/label-is-actually-char.rs:2:15\n+   |\n+LL |     let c = 'a;\n+   |               ^ expected `while`, `for`, `loop` or `{` after a label\n+   |\n+help: add `'` to close the char literal\n+   |\n+LL |     let c = 'a';\n+   |               +\n+\n+error: unexpected token: `'b`\n+  --> $DIR/label-is-actually-char.rs:6:15\n+   |\n+LL |         'a'..='b => {}\n+   |               ^^\n+   |\n+help: add `'` to close the char literal\n+   |\n+LL |         'a'..='b' => {}\n+   |                 +\n+\n+error: expected `while`, `for`, `loop` or `{` after a label\n+  --> $DIR/label-is-actually-char.rs:11:16\n+   |\n+LL |     let x = ['a, 'b];\n+   |                ^ expected `while`, `for`, `loop` or `{` after a label\n+   |\n+help: add `'` to close the char literal\n+   |\n+LL |     let x = ['a', 'b];\n+   |                +\n+\n+error: expected `while`, `for`, `loop` or `{` after a label\n+  --> $DIR/label-is-actually-char.rs:11:20\n+   |\n+LL |     let x = ['a, 'b];\n+   |                    ^ expected `while`, `for`, `loop` or `{` after a label\n+   |\n+help: add `'` to close the char literal\n+   |\n+LL |     let x = ['a, 'b'];\n+   |                    +\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "7c1bcb7263171d9b0d06d98feef52bae6501593f", "filename": "src/test/ui/parser/numeric-lifetime.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fparser%2Fnumeric-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fparser%2Fnumeric-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fnumeric-lifetime.stderr?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -1,3 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-lifetime.rs:6:20\n+   |\n+LL |     let x: usize = \"\";\n+   |            -----   ^^ expected `usize`, found `&str`\n+   |            |\n+   |            expected due to this\n+\n error: lifetimes cannot start with a number\n   --> $DIR/numeric-lifetime.rs:1:10\n    |\n@@ -10,14 +18,6 @@ error: lifetimes cannot start with a number\n LL | struct S<'1> { s: &'1 usize }\n    |                    ^^\n \n-error[E0308]: mismatched types\n-  --> $DIR/numeric-lifetime.rs:6:20\n-   |\n-LL |     let x: usize = \"\";\n-   |            -----   ^^ expected `usize`, found `&str`\n-   |            |\n-   |            expected due to this\n-\n error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "5b90e905a64a2b55e29659bf54c4666edecd8c3c", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -23,11 +23,13 @@ fn main() {\n     //~^ ERROR expected one of\n     //~| HELP use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n     //~| ERROR expected\n+    //~| HELP add `'` to close the char literal\n \n     f<'_>();\n     //~^ comparison operators cannot be chained\n     //~| HELP use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n     //~| ERROR expected\n+    //~| HELP add `'` to close the char literal\n \n     let _ = f<u8>;\n     //~^ ERROR comparison operators cannot be chained"}, {"sha": "52e201c435c16d5f37ce44d08b761996e3acca38", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.stderr", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -58,6 +58,11 @@ error: expected `while`, `for`, `loop` or `{` after a label\n    |\n LL |     let _ = f<'_, i8>();\n    |                 ^ expected `while`, `for`, `loop` or `{` after a label\n+   |\n+help: add `'` to close the char literal\n+   |\n+LL |     let _ = f<'_', i8>();\n+   |                 +\n \n error: expected one of `.`, `:`, `;`, `?`, `else`, `for`, `loop`, `while`, or an operator, found `,`\n   --> $DIR/require-parens-for-chained-comparison.rs:22:17\n@@ -71,13 +76,18 @@ LL |     let _ = f::<'_, i8>();\n    |              ++\n \n error: expected `while`, `for`, `loop` or `{` after a label\n-  --> $DIR/require-parens-for-chained-comparison.rs:27:9\n+  --> $DIR/require-parens-for-chained-comparison.rs:28:9\n    |\n LL |     f<'_>();\n    |         ^ expected `while`, `for`, `loop` or `{` after a label\n+   |\n+help: add `'` to close the char literal\n+   |\n+LL |     f<'_'>();\n+   |         +\n \n error: comparison operators cannot be chained\n-  --> $DIR/require-parens-for-chained-comparison.rs:27:6\n+  --> $DIR/require-parens-for-chained-comparison.rs:28:6\n    |\n LL |     f<'_>();\n    |      ^  ^\n@@ -88,7 +98,7 @@ LL |     f::<'_>();\n    |      ++\n \n error: comparison operators cannot be chained\n-  --> $DIR/require-parens-for-chained-comparison.rs:32:14\n+  --> $DIR/require-parens-for-chained-comparison.rs:34:14\n    |\n LL |     let _ = f<u8>;\n    |              ^  ^"}, {"sha": "42c9975bedb70995a8d4efde11ec499d2954b130", "filename": "src/test/ui/privacy/access_levels.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -70,5 +70,6 @@ mod half_public_import {\n \n #[rustc_effective_visibility]\n pub use half_public_import::HalfPublicImport; //~ ERROR Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+                                              //~^ ERROR Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n \n fn main() {}"}, {"sha": "111e02bc329ccc483246525ebc6e3b4c703f99c0", "filename": "src/test/ui/privacy/access_levels.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.stderr?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -112,6 +112,12 @@ error: Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n LL | pub use half_public_import::HalfPublicImport;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+  --> $DIR/access_levels.rs:72:9\n+   |\n+LL | pub use half_public_import::HalfPublicImport;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n   --> $DIR/access_levels.rs:14:13\n    |\n@@ -124,5 +130,5 @@ error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait\n LL |             type B;\n    |             ^^^^^^\n \n-error: aborting due to 21 previous errors\n+error: aborting due to 22 previous errors\n "}, {"sha": "a62e5bf8d3c622fe19d3f31b05b994aa9bcbd6d6", "filename": "src/test/ui/return/issue-64620.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Freturn%2Fissue-64620.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Freturn%2Fissue-64620.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn%2Fissue-64620.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "previous_filename": "src/test/ui/issues/issue-64620.rs"}, {"sha": "f40ac4de32d5981426db6c54f4f285715aed09c3", "filename": "src/test/ui/return/issue-64620.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Freturn%2Fissue-64620.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Freturn%2Fissue-64620.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn%2Fissue-64620.stderr?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "previous_filename": "src/test/ui/issues/issue-64620.stderr"}, {"sha": "6c491584540586c9b8e419d70f8075278526a6fb", "filename": "src/test/ui/structs-enums/issue-2718-a.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fstructs-enums%2Fissue-2718-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fstructs-enums%2Fissue-2718-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fissue-2718-a.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "previous_filename": "src/test/ui/issues/issue-2718-a.rs"}, {"sha": "7ea620f386a205fcb3dffc3081028c8dc3a996f8", "filename": "src/test/ui/structs-enums/issue-2718-a.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fstructs-enums%2Fissue-2718-a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fstructs-enums%2Fissue-2718-a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fissue-2718-a.stderr?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "previous_filename": "src/test/ui/issues/issue-2718-a.stderr"}, {"sha": "3a25e25eede62b42ffd190101ee4577543389e8a", "filename": "src/test/ui/suggestions/suggest-let-for-assignment.fixed", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-let-for-assignment.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-let-for-assignment.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-let-for-assignment.fixed?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -0,0 +1,17 @@\n+// run-rustfix\n+\n+fn main() {\n+    let demo = 1; //~ ERROR cannot find value `demo` in this scope\n+    dbg!(demo); //~ ERROR cannot find value `demo` in this scope\n+\n+    let x = \"x\"; //~ ERROR cannot find value `x` in this scope\n+    println!(\"x: {}\", x); //~ ERROR cannot find value `x` in this scope\n+\n+    if x == \"x\" {\n+        //~^ ERROR cannot find value `x` in this scope\n+        println!(\"x is 1\");\n+    }\n+\n+    let y = 1 + 2; //~ ERROR cannot find value `y` in this scope\n+    println!(\"y: {}\", y); //~ ERROR cannot find value `y` in this scope\n+}"}, {"sha": "67705fe063a79e5e0474fb941cc9a3b155984f6c", "filename": "src/test/ui/suggestions/suggest-let-for-assignment.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-let-for-assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-let-for-assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-let-for-assignment.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -0,0 +1,17 @@\n+// run-rustfix\n+\n+fn main() {\n+    demo = 1; //~ ERROR cannot find value `demo` in this scope\n+    dbg!(demo); //~ ERROR cannot find value `demo` in this scope\n+\n+    x = \"x\"; //~ ERROR cannot find value `x` in this scope\n+    println!(\"x: {}\", x); //~ ERROR cannot find value `x` in this scope\n+\n+    if x == \"x\" {\n+        //~^ ERROR cannot find value `x` in this scope\n+        println!(\"x is 1\");\n+    }\n+\n+    y = 1 + 2; //~ ERROR cannot find value `y` in this scope\n+    println!(\"y: {}\", y); //~ ERROR cannot find value `y` in this scope\n+}"}, {"sha": "3f6a3da4be2b35810e007e266d4e0a801b5d1fd6", "filename": "src/test/ui/suggestions/suggest-let-for-assignment.stderr", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-let-for-assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-let-for-assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-let-for-assignment.stderr?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -0,0 +1,60 @@\n+error[E0425]: cannot find value `demo` in this scope\n+  --> $DIR/suggest-let-for-assignment.rs:4:5\n+   |\n+LL |     demo = 1;\n+   |     ^^^^\n+   |\n+help: you might have meant to introduce a new binding\n+   |\n+LL |     let demo = 1;\n+   |     +++\n+\n+error[E0425]: cannot find value `demo` in this scope\n+  --> $DIR/suggest-let-for-assignment.rs:5:10\n+   |\n+LL |     dbg!(demo);\n+   |          ^^^^ not found in this scope\n+\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/suggest-let-for-assignment.rs:7:5\n+   |\n+LL |     x = \"x\";\n+   |     ^\n+   |\n+help: you might have meant to introduce a new binding\n+   |\n+LL |     let x = \"x\";\n+   |     +++\n+\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/suggest-let-for-assignment.rs:8:23\n+   |\n+LL |     println!(\"x: {}\", x);\n+   |                       ^ not found in this scope\n+\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/suggest-let-for-assignment.rs:10:8\n+   |\n+LL |     if x == \"x\" {\n+   |        ^ not found in this scope\n+\n+error[E0425]: cannot find value `y` in this scope\n+  --> $DIR/suggest-let-for-assignment.rs:15:5\n+   |\n+LL |     y = 1 + 2;\n+   |     ^\n+   |\n+help: you might have meant to introduce a new binding\n+   |\n+LL |     let y = 1 + 2;\n+   |     +++\n+\n+error[E0425]: cannot find value `y` in this scope\n+  --> $DIR/suggest-let-for-assignment.rs:16:23\n+   |\n+LL |     println!(\"y: {}\", y);\n+   |                       ^ not found in this scope\n+\n+error: aborting due to 7 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "c600f99c2c4bf79ef53824c505cb584ecc615279", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -8,7 +8,7 @@ use std::path::Path;\n const ENTRY_LIMIT: usize = 1000;\n // FIXME: The following limits should be reduced eventually.\n const ROOT_ENTRY_LIMIT: usize = 948;\n-const ISSUES_ENTRY_LIMIT: usize = 2126;\n+const ISSUES_ENTRY_LIMIT: usize = 2117;\n \n fn check_entries(path: &Path, bad: &mut bool) {\n     let dirs = walkdir::WalkDir::new(&path.join(\"test/ui\"))"}]}