{"sha": "baecad9c392ec74fe0cccee2dc5876cf157e4966", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhZWNhZDljMzkyZWM3NGZlMGNjY2VlMmRjNTg3NmNmMTU3ZTQ5NjY=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-04T13:07:03Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-19T14:54:20Z"}, "message": "Move NonZero* to its file", "tree": {"sha": "e723fe9811d97eddd517f3bee4d4a19e5b51863f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e723fe9811d97eddd517f3bee4d4a19e5b51863f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/baecad9c392ec74fe0cccee2dc5876cf157e4966", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/baecad9c392ec74fe0cccee2dc5876cf157e4966", "html_url": "https://github.com/rust-lang/rust/commit/baecad9c392ec74fe0cccee2dc5876cf157e4966", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/baecad9c392ec74fe0cccee2dc5876cf157e4966/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e9d5db8392c44a2e94008168fa3506ecddaa357", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9d5db8392c44a2e94008168fa3506ecddaa357", "html_url": "https://github.com/rust-lang/rust/commit/8e9d5db8392c44a2e94008168fa3506ecddaa357"}], "stats": {"total": 373, "additions": 197, "deletions": 176}, "files": [{"sha": "fdf7695fbc8a5d35f2c67a7908c5084d4c429983", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 7, "deletions": 176, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/baecad9c392ec74fe0cccee2dc5876cf157e4966/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baecad9c392ec74fe0cccee2dc5876cf157e4966/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=baecad9c392ec74fe0cccee2dc5876cf157e4966", "patch": "@@ -8,7 +8,6 @@ use crate::convert::Infallible;\n use crate::fmt;\n use crate::intrinsics;\n use crate::mem;\n-use crate::ops::{BitOr, BitOrAssign};\n use crate::str::FromStr;\n \n // Used because the `?` operator is not allowed in a const context.\n@@ -28,188 +27,13 @@ macro_rules! unlikely {\n     };\n }\n \n-macro_rules! impl_nonzero_fmt {\n-    ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n-        $(\n-            #[$stability]\n-            impl fmt::$Trait for $Ty {\n-                #[inline]\n-                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                    self.get().fmt(f)\n-                }\n-            }\n-        )+\n-    }\n-}\n-\n macro_rules! doc_comment {\n     ($x:expr, $($tt:tt)*) => {\n         #[doc = $x]\n         $($tt)*\n     };\n }\n \n-macro_rules! nonzero_integers {\n-    ( $( #[$stability: meta] $Ty: ident($Int: ty); )+ ) => {\n-        $(\n-            doc_comment! {\n-                concat!(\"An integer that is known not to equal zero.\n-\n-This enables some memory layout optimization.\n-For example, `Option<\", stringify!($Ty), \">` is the same size as `\", stringify!($Int), \"`:\n-\n-```rust\n-use std::mem::size_of;\n-assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", stringify!($Int),\n-\">());\n-```\"),\n-                #[$stability]\n-                #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n-                #[repr(transparent)]\n-                #[rustc_layout_scalar_valid_range_start(1)]\n-                #[rustc_nonnull_optimization_guaranteed]\n-                pub struct $Ty($Int);\n-            }\n-\n-            impl $Ty {\n-                /// Creates a non-zero without checking the value.\n-                ///\n-                /// # Safety\n-                ///\n-                /// The value must not be zero.\n-                #[$stability]\n-                #[rustc_const_stable(feature = \"nonzero\", since = \"1.34.0\")]\n-                #[inline]\n-                pub const unsafe fn new_unchecked(n: $Int) -> Self {\n-                    // SAFETY: this is guaranteed to be safe by the caller.\n-                    unsafe { Self(n) }\n-                }\n-\n-                /// Creates a non-zero if the given value is not zero.\n-                #[$stability]\n-                #[rustc_const_stable(feature = \"const_nonzero_int_methods\", since = \"1.47.0\")]\n-                #[inline]\n-                pub const fn new(n: $Int) -> Option<Self> {\n-                    if n != 0 {\n-                        // SAFETY: we just checked that there's no `0`\n-                        Some(unsafe { Self(n) })\n-                    } else {\n-                        None\n-                    }\n-                }\n-\n-                /// Returns the value as a primitive type.\n-                #[$stability]\n-                #[inline]\n-                #[rustc_const_stable(feature = \"nonzero\", since = \"1.34.0\")]\n-                pub const fn get(self) -> $Int {\n-                    self.0\n-                }\n-\n-            }\n-\n-            #[stable(feature = \"from_nonzero\", since = \"1.31.0\")]\n-            impl From<$Ty> for $Int {\n-                doc_comment! {\n-                    concat!(\n-\"Converts a `\", stringify!($Ty), \"` into an `\", stringify!($Int), \"`\"),\n-                    fn from(nonzero: $Ty) -> Self {\n-                        nonzero.0\n-                    }\n-                }\n-            }\n-\n-            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n-            impl BitOr for $Ty {\n-                type Output = Self;\n-                #[inline]\n-                fn bitor(self, rhs: Self) -> Self::Output {\n-                    // SAFETY: since `self` and `rhs` are both nonzero, the\n-                    // result of the bitwise-or will be nonzero.\n-                    unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }\n-                }\n-            }\n-\n-            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n-            impl BitOr<$Int> for $Ty {\n-                type Output = Self;\n-                #[inline]\n-                fn bitor(self, rhs: $Int) -> Self::Output {\n-                    // SAFETY: since `self` is nonzero, the result of the\n-                    // bitwise-or will be nonzero regardless of the value of\n-                    // `rhs`.\n-                    unsafe { $Ty::new_unchecked(self.get() | rhs) }\n-                }\n-            }\n-\n-            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n-            impl BitOr<$Ty> for $Int {\n-                type Output = $Ty;\n-                #[inline]\n-                fn bitor(self, rhs: $Ty) -> Self::Output {\n-                    // SAFETY: since `rhs` is nonzero, the result of the\n-                    // bitwise-or will be nonzero regardless of the value of\n-                    // `self`.\n-                    unsafe { $Ty::new_unchecked(self | rhs.get()) }\n-                }\n-            }\n-\n-            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n-            impl BitOrAssign for $Ty {\n-                #[inline]\n-                fn bitor_assign(&mut self, rhs: Self) {\n-                    *self = *self | rhs;\n-                }\n-            }\n-\n-            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n-            impl BitOrAssign<$Int> for $Ty {\n-                #[inline]\n-                fn bitor_assign(&mut self, rhs: $Int) {\n-                    *self = *self | rhs;\n-                }\n-            }\n-\n-            impl_nonzero_fmt! {\n-                #[$stability] (Debug, Display, Binary, Octal, LowerHex, UpperHex) for $Ty\n-            }\n-        )+\n-    }\n-}\n-\n-nonzero_integers! {\n-    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU8(u8);\n-    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU16(u16);\n-    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU32(u32);\n-    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU64(u64);\n-    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU128(u128);\n-    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroUsize(usize);\n-    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI8(i8);\n-    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI16(i16);\n-    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI32(i32);\n-    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI64(i64);\n-    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI128(i128);\n-    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroIsize(isize);\n-}\n-\n-macro_rules! from_str_radix_nzint_impl {\n-    ($($t:ty)*) => {$(\n-        #[stable(feature = \"nonzero_parse\", since = \"1.35.0\")]\n-        impl FromStr for $t {\n-            type Err = ParseIntError;\n-            fn from_str(src: &str) -> Result<Self, Self::Err> {\n-                Self::new(from_str_radix(src, 10)?)\n-                    .ok_or(ParseIntError {\n-                        kind: IntErrorKind::Zero\n-                    })\n-            }\n-        }\n-    )*}\n-}\n-\n-from_str_radix_nzint_impl! { NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU128 NonZeroUsize\n-NonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize }\n-\n /// Provides intentionally-wrapped arithmetic on `T`.\n ///\n /// Operations like `+` on `u32` values are intended to never overflow,\n@@ -289,8 +113,15 @@ pub mod dec2flt;\n pub mod diy_float;\n pub mod flt2dec;\n \n+mod nonzero;\n mod wrapping;\n \n+#[stable(feature = \"nonzero\", since = \"1.28.0\")]\n+pub use nonzero::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize};\n+\n+#[stable(feature = \"signed_nonzero\", since = \"1.34.0\")]\n+pub use nonzero::{NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize};\n+\n macro_rules! usize_isize_to_xe_bytes_doc {\n     () => {\n         \""}, {"sha": "382f799bfe5f9fc9459662b17e2b4228803f34be", "filename": "library/core/src/num/nonzero.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/baecad9c392ec74fe0cccee2dc5876cf157e4966/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baecad9c392ec74fe0cccee2dc5876cf157e4966/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=baecad9c392ec74fe0cccee2dc5876cf157e4966", "patch": "@@ -0,0 +1,190 @@\n+//! Definitions of integer that is known not to equal zero.\n+\n+use crate::fmt;\n+use crate::ops::{BitOr, BitOrAssign};\n+use crate::str::FromStr;\n+\n+use super::from_str_radix;\n+use super::{IntErrorKind, ParseIntError};\n+\n+macro_rules! doc_comment {\n+    ($x:expr, $($tt:tt)*) => {\n+        #[doc = $x]\n+        $($tt)*\n+    };\n+}\n+\n+macro_rules! impl_nonzero_fmt {\n+    ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n+        $(\n+            #[$stability]\n+            impl fmt::$Trait for $Ty {\n+                #[inline]\n+                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                    self.get().fmt(f)\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+macro_rules! nonzero_integers {\n+    ( $( #[$stability: meta] $Ty: ident($Int: ty); )+ ) => {\n+        $(\n+            doc_comment! {\n+                concat!(\"An integer that is known not to equal zero.\n+\n+This enables some memory layout optimization.\n+For example, `Option<\", stringify!($Ty), \">` is the same size as `\", stringify!($Int), \"`:\n+\n+```rust\n+use std::mem::size_of;\n+assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", stringify!($Int),\n+\">());\n+```\"),\n+                #[$stability]\n+                #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+                #[repr(transparent)]\n+                #[rustc_layout_scalar_valid_range_start(1)]\n+                #[rustc_nonnull_optimization_guaranteed]\n+                pub struct $Ty($Int);\n+            }\n+\n+            impl $Ty {\n+                /// Creates a non-zero without checking the value.\n+                ///\n+                /// # Safety\n+                ///\n+                /// The value must not be zero.\n+                #[$stability]\n+                #[rustc_const_stable(feature = \"nonzero\", since = \"1.34.0\")]\n+                #[inline]\n+                pub const unsafe fn new_unchecked(n: $Int) -> Self {\n+                    // SAFETY: this is guaranteed to be safe by the caller.\n+                    unsafe { Self(n) }\n+                }\n+\n+                /// Creates a non-zero if the given value is not zero.\n+                #[$stability]\n+                #[rustc_const_stable(feature = \"const_nonzero_int_methods\", since = \"1.47.0\")]\n+                #[inline]\n+                pub const fn new(n: $Int) -> Option<Self> {\n+                    if n != 0 {\n+                        // SAFETY: we just checked that there's no `0`\n+                        Some(unsafe { Self(n) })\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                /// Returns the value as a primitive type.\n+                #[$stability]\n+                #[inline]\n+                #[rustc_const_stable(feature = \"nonzero\", since = \"1.34.0\")]\n+                pub const fn get(self) -> $Int {\n+                    self.0\n+                }\n+\n+            }\n+\n+            #[stable(feature = \"from_nonzero\", since = \"1.31.0\")]\n+            impl From<$Ty> for $Int {\n+                doc_comment! {\n+                    concat!(\n+\"Converts a `\", stringify!($Ty), \"` into an `\", stringify!($Int), \"`\"),\n+                    fn from(nonzero: $Ty) -> Self {\n+                        nonzero.0\n+                    }\n+                }\n+            }\n+\n+            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n+            impl BitOr for $Ty {\n+                type Output = Self;\n+                #[inline]\n+                fn bitor(self, rhs: Self) -> Self::Output {\n+                    // SAFETY: since `self` and `rhs` are both nonzero, the\n+                    // result of the bitwise-or will be nonzero.\n+                    unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }\n+                }\n+            }\n+\n+            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n+            impl BitOr<$Int> for $Ty {\n+                type Output = Self;\n+                #[inline]\n+                fn bitor(self, rhs: $Int) -> Self::Output {\n+                    // SAFETY: since `self` is nonzero, the result of the\n+                    // bitwise-or will be nonzero regardless of the value of\n+                    // `rhs`.\n+                    unsafe { $Ty::new_unchecked(self.get() | rhs) }\n+                }\n+            }\n+\n+            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n+            impl BitOr<$Ty> for $Int {\n+                type Output = $Ty;\n+                #[inline]\n+                fn bitor(self, rhs: $Ty) -> Self::Output {\n+                    // SAFETY: since `rhs` is nonzero, the result of the\n+                    // bitwise-or will be nonzero regardless of the value of\n+                    // `self`.\n+                    unsafe { $Ty::new_unchecked(self | rhs.get()) }\n+                }\n+            }\n+\n+            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n+            impl BitOrAssign for $Ty {\n+                #[inline]\n+                fn bitor_assign(&mut self, rhs: Self) {\n+                    *self = *self | rhs;\n+                }\n+            }\n+\n+            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n+            impl BitOrAssign<$Int> for $Ty {\n+                #[inline]\n+                fn bitor_assign(&mut self, rhs: $Int) {\n+                    *self = *self | rhs;\n+                }\n+            }\n+\n+            impl_nonzero_fmt! {\n+                #[$stability] (Debug, Display, Binary, Octal, LowerHex, UpperHex) for $Ty\n+            }\n+        )+\n+    }\n+}\n+\n+nonzero_integers! {\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU8(u8);\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU16(u16);\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU32(u32);\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU64(u64);\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU128(u128);\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroUsize(usize);\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI8(i8);\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI16(i16);\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI32(i32);\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI64(i64);\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI128(i128);\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroIsize(isize);\n+}\n+\n+macro_rules! from_str_radix_nzint_impl {\n+    ($($t:ty)*) => {$(\n+        #[stable(feature = \"nonzero_parse\", since = \"1.35.0\")]\n+        impl FromStr for $t {\n+            type Err = ParseIntError;\n+            fn from_str(src: &str) -> Result<Self, Self::Err> {\n+                Self::new(from_str_radix(src, 10)?)\n+                    .ok_or(ParseIntError {\n+                        kind: IntErrorKind::Zero\n+                    })\n+            }\n+        }\n+    )*}\n+}\n+\n+from_str_radix_nzint_impl! { NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU128 NonZeroUsize\n+NonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize }"}]}