{"sha": "019614f03d106324ab50a37746b556c41e66c099", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxOTYxNGYwM2QxMDYzMjRhYjUwYTM3NzQ2YjU1NmM0MWU2NmMwOTk=", "commit": {"author": {"name": "Oliver 'ker' Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-02-09T10:36:51Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-02-11T11:34:48Z"}, "message": "[breaking-change] don't glob export ast::Item_ variants", "tree": {"sha": "e95206fa5d2ee8c83a9915f03bcefc32081fc7bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e95206fa5d2ee8c83a9915f03bcefc32081fc7bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/019614f03d106324ab50a37746b556c41e66c099", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/019614f03d106324ab50a37746b556c41e66c099", "html_url": "https://github.com/rust-lang/rust/commit/019614f03d106324ab50a37746b556c41e66c099", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/019614f03d106324ab50a37746b556c41e66c099/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d6ddd190355650a6d851c3aae12cf79339665af", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d6ddd190355650a6d851c3aae12cf79339665af", "html_url": "https://github.com/rust-lang/rust/commit/0d6ddd190355650a6d851c3aae12cf79339665af"}], "stats": {"total": 463, "additions": 230, "deletions": 233}, "files": [{"sha": "cfd9d5bdaa75d11be74b88e9e209a9aab7b7a4b3", "filename": "src/librustc/front/check_attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc%2Ffront%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc%2Ffront%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcheck_attr.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -26,9 +26,9 @@ enum Target {\n impl Target {\n     fn from_item(item: &ast::Item) -> Target {\n         match item.node {\n-            ast::ItemFn(..) => Target::Fn,\n-            ast::ItemStruct(..) => Target::Struct,\n-            ast::ItemEnum(..) => Target::Enum,\n+            ast::ItemKind::Fn(..) => Target::Fn,\n+            ast::ItemKind::Struct(..) => Target::Struct,\n+            ast::ItemKind::Enum(..) => Target::Enum,\n             _ => Target::Other,\n         }\n     }"}, {"sha": "e0a948f766141ac5c799bfae0f969e0c27e987c4", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -600,16 +600,16 @@ impl ReplaceBodyWithLoop {\n }\n \n impl fold::Folder for ReplaceBodyWithLoop {\n-    fn fold_item_underscore(&mut self, i: ast::Item_) -> ast::Item_ {\n+    fn fold_item_kind(&mut self, i: ast::ItemKind) -> ast::ItemKind {\n         match i {\n-            ast::ItemStatic(..) | ast::ItemConst(..) => {\n+            ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => {\n                 self.within_static_or_const = true;\n-                let ret = fold::noop_fold_item_underscore(i, self);\n+                let ret = fold::noop_fold_item_kind(i, self);\n                 self.within_static_or_const = false;\n                 return ret;\n             }\n             _ => {\n-                fold::noop_fold_item_underscore(i, self)\n+                fold::noop_fold_item_kind(i, self)\n             }\n         }\n     }"}, {"sha": "d04f4c96504ec928ece7163a275557044ef2e70e", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -654,34 +654,34 @@ pub fn lower_block(lctx: &LoweringContext, b: &Block) -> P<hir::Block> {\n     })\n }\n \n-pub fn lower_item_underscore(lctx: &LoweringContext, i: &Item_) -> hir::Item_ {\n+pub fn lower_item_kind(lctx: &LoweringContext, i: &ItemKind) -> hir::Item_ {\n     match *i {\n-        ItemExternCrate(string) => hir::ItemExternCrate(string),\n-        ItemUse(ref view_path) => {\n+        ItemKind::ExternCrate(string) => hir::ItemExternCrate(string),\n+        ItemKind::Use(ref view_path) => {\n             hir::ItemUse(lower_view_path(lctx, view_path))\n         }\n-        ItemStatic(ref t, m, ref e) => {\n+        ItemKind::Static(ref t, m, ref e) => {\n             hir::ItemStatic(lower_ty(lctx, t),\n                             lower_mutability(lctx, m),\n                             lower_expr(lctx, e))\n         }\n-        ItemConst(ref t, ref e) => {\n+        ItemKind::Const(ref t, ref e) => {\n             hir::ItemConst(lower_ty(lctx, t), lower_expr(lctx, e))\n         }\n-        ItemFn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n+        ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n             hir::ItemFn(lower_fn_decl(lctx, decl),\n                         lower_unsafety(lctx, unsafety),\n                         lower_constness(lctx, constness),\n                         abi,\n                         lower_generics(lctx, generics),\n                         lower_block(lctx, body))\n         }\n-        ItemMod(ref m) => hir::ItemMod(lower_mod(lctx, m)),\n-        ItemForeignMod(ref nm) => hir::ItemForeignMod(lower_foreign_mod(lctx, nm)),\n-        ItemTy(ref t, ref generics) => {\n+        ItemKind::Mod(ref m) => hir::ItemMod(lower_mod(lctx, m)),\n+        ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(lower_foreign_mod(lctx, nm)),\n+        ItemKind::Ty(ref t, ref generics) => {\n             hir::ItemTy(lower_ty(lctx, t), lower_generics(lctx, generics))\n         }\n-        ItemEnum(ref enum_definition, ref generics) => {\n+        ItemKind::Enum(ref enum_definition, ref generics) => {\n             hir::ItemEnum(hir::EnumDef {\n                               variants: enum_definition.variants\n                                                        .iter()\n@@ -690,15 +690,15 @@ pub fn lower_item_underscore(lctx: &LoweringContext, i: &Item_) -> hir::Item_ {\n                           },\n                           lower_generics(lctx, generics))\n         }\n-        ItemStruct(ref struct_def, ref generics) => {\n+        ItemKind::Struct(ref struct_def, ref generics) => {\n             let struct_def = lower_variant_data(lctx, struct_def);\n             hir::ItemStruct(struct_def, lower_generics(lctx, generics))\n         }\n-        ItemDefaultImpl(unsafety, ref trait_ref) => {\n+        ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n             hir::ItemDefaultImpl(lower_unsafety(lctx, unsafety),\n                                  lower_trait_ref(lctx, trait_ref))\n         }\n-        ItemImpl(unsafety, polarity, ref generics, ref ifce, ref ty, ref impl_items) => {\n+        ItemKind::Impl(unsafety, polarity, ref generics, ref ifce, ref ty, ref impl_items) => {\n             let new_impl_items = impl_items.iter()\n                                            .map(|item| lower_impl_item(lctx, item))\n                                            .collect();\n@@ -710,15 +710,15 @@ pub fn lower_item_underscore(lctx: &LoweringContext, i: &Item_) -> hir::Item_ {\n                           lower_ty(lctx, ty),\n                           new_impl_items)\n         }\n-        ItemTrait(unsafety, ref generics, ref bounds, ref items) => {\n+        ItemKind::Trait(unsafety, ref generics, ref bounds, ref items) => {\n             let bounds = lower_bounds(lctx, bounds);\n             let items = items.iter().map(|item| lower_trait_item(lctx, item)).collect();\n             hir::ItemTrait(lower_unsafety(lctx, unsafety),\n                            lower_generics(lctx, generics),\n                            bounds,\n                            items)\n         }\n-        ItemMac(_) => panic!(\"Shouldn't still be around\"),\n+        ItemKind::Mac(_) => panic!(\"Shouldn't still be around\"),\n     }\n }\n \n@@ -820,7 +820,7 @@ pub fn lower_item_id(_lctx: &LoweringContext, i: &Item) -> hir::ItemId {\n }\n \n pub fn lower_item(lctx: &LoweringContext, i: &Item) -> hir::Item {\n-    let node = lower_item_underscore(lctx, &i.node);\n+    let node = lower_item_kind(lctx, &i.node);\n \n     hir::Item {\n         id: i.id,"}, {"sha": "52456251f962b18404d441c596589d1d31ae0a04", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -157,7 +157,7 @@ impl<'a> CrateReader<'a> {\n \n     fn extract_crate_info(&self, i: &ast::Item) -> Option<CrateInfo> {\n         match i.node {\n-            ast::ItemExternCrate(ref path_opt) => {\n+            ast::ItemKind::ExternCrate(ref path_opt) => {\n                 debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n                        i.ident, path_opt);\n                 let name = match *path_opt {"}, {"sha": "b2395ac355f62800188343bc536e83c14074defc", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -56,7 +56,7 @@ pub fn read_macro_defs(sess: &Session, cstore: &CStore, krate: &ast::Crate)\n     // crate root, because `$crate` won't work properly. Identify these by\n     // spans, because the crate map isn't set up yet.\n     for item in &krate.module.items {\n-        if let ast::ItemExternCrate(_) = item.node {\n+        if let ast::ItemKind::ExternCrate(_) = item.node {\n             loader.span_whitelist.insert(item.span);\n         }\n     }\n@@ -73,7 +73,7 @@ impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         // We're only interested in `extern crate`.\n         match item.node {\n-            ast::ItemExternCrate(_) => {}\n+            ast::ItemKind::ExternCrate(_) => {}\n             _ => {\n                 visit::walk_item(self, item);\n                 return;"}, {"sha": "98346f538b0bc257d9538844a6de0007a98587c8", "filename": "src/librustc_passes/const_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc_passes%2Fconst_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc_passes%2Fconst_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconst_fn.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -78,10 +78,10 @@ impl<'a, 'v> Visitor<'v> for CheckConstFn<'a> {\n     fn visit_item(&mut self, i: &'v ast::Item) {\n         visit::walk_item(self, i);\n         match i.node {\n-            ast::ItemConst(_, ref e) => {\n+            ast::ItemKind::Const(_, ref e) => {\n                 CheckBlock{ sess: self.sess, kind: \"constant\"}.visit_expr(e)\n             },\n-            ast::ItemStatic(_, _, ref e) => {\n+            ast::ItemKind::Static(_, _, ref e) => {\n                 CheckBlock{ sess: self.sess, kind: \"static\"}.visit_expr(e)\n             },\n             _ => {},"}, {"sha": "d8f21fd4dd6bf20e9a0c17cf22cbcc7cd1be1169", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -864,9 +864,10 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n+        use syntax::ast::ItemKind::*;\n         self.process_macro_use(item.span, item.id);\n         match item.node {\n-            ast::ItemUse(ref use_item) => {\n+            Use(ref use_item) => {\n                 match use_item.node {\n                     ast::ViewPathSimple(ident, ref path) => {\n                         let sub_span = self.span.span_for_last_ident(path.span);\n@@ -950,7 +951,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                     }\n                 }\n             }\n-            ast::ItemExternCrate(ref s) => {\n+            ExternCrate(ref s) => {\n                 let location = match *s {\n                     Some(s) => s.to_string(),\n                     None => item.ident.to_string(),\n@@ -968,28 +969,28 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                           &location,\n                                           self.cur_scope);\n             }\n-            ast::ItemFn(ref decl, _, _, _, ref ty_params, ref body) =>\n+            Fn(ref decl, _, _, _, ref ty_params, ref body) =>\n                 self.process_fn(item, &**decl, ty_params, &**body),\n-            ast::ItemStatic(ref typ, _, ref expr) =>\n+            Static(ref typ, _, ref expr) =>\n                 self.process_static_or_const_item(item, typ, expr),\n-            ast::ItemConst(ref typ, ref expr) =>\n+            Const(ref typ, ref expr) =>\n                 self.process_static_or_const_item(item, &typ, &expr),\n-            ast::ItemStruct(ref def, ref ty_params) => self.process_struct(item, def, ty_params),\n-            ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n-            ast::ItemImpl(_, _,\n+            Struct(ref def, ref ty_params) => self.process_struct(item, def, ty_params),\n+            Enum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n+            Impl(_, _,\n                           ref ty_params,\n                           ref trait_ref,\n                           ref typ,\n                           ref impl_items) => {\n                 self.process_impl(item, ty_params, trait_ref, &typ, impl_items)\n             }\n-            ast::ItemTrait(_, ref generics, ref trait_refs, ref methods) =>\n+            Trait(_, ref generics, ref trait_refs, ref methods) =>\n                 self.process_trait(item, generics, trait_refs, methods),\n-            ast::ItemMod(ref m) => {\n+            Mod(ref m) => {\n                 self.process_mod(item);\n                 self.nest(item.id, |v| visit::walk_mod(v, m));\n             }\n-            ast::ItemTy(ref ty, ref ty_params) => {\n+            Ty(ref ty, ref ty_params) => {\n                 let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let value = ty_to_string(&**ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n@@ -998,7 +999,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 self.visit_ty(&**ty);\n                 self.process_generic_params(ty_params, item.span, &qualname, item.id);\n             }\n-            ast::ItemMac(_) => (),\n+            Mac(_) => (),\n             _ => visit::walk_item(self, item),\n         }\n     }"}, {"sha": "1790da39ad0869b1802a33bf204ec5232fd2ef2e", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -229,7 +229,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_item_data(&self, item: &ast::Item) -> Option<Data> {\n         match item.node {\n-            ast::ItemFn(..) => {\n+            ast::ItemKind::Fn(..) => {\n                 let name = self.tcx.map.path_to_string(item.id);\n                 let qualname = format!(\"::{}\", name);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n@@ -243,7 +243,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     scope: self.enclosing_scope(item.id),\n                 }))\n             }\n-            ast::ItemStatic(ref typ, mt, ref expr) => {\n+            ast::ItemKind::Static(ref typ, mt, ref expr) => {\n                 let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n \n                 // If the variable is immutable, save the initialising expression.\n@@ -264,7 +264,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     type_value: ty_to_string(&typ),\n                 }))\n             }\n-            ast::ItemConst(ref typ, ref expr) => {\n+            ast::ItemKind::Const(ref typ, ref expr) => {\n                 let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Const);\n                 filter!(self.span_utils, sub_span, item.span, None);\n@@ -278,7 +278,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     type_value: ty_to_string(&typ),\n                 }))\n             }\n-            ast::ItemMod(ref m) => {\n+            ast::ItemKind::Mod(ref m) => {\n                 let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n \n                 let cm = self.tcx.sess.codemap();\n@@ -295,7 +295,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     filename: filename,\n                 }))\n             }\n-            ast::ItemEnum(..) => {\n+            ast::ItemKind::Enum(..) => {\n                 let enum_name = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let val = self.span_utils.snippet(item.span);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Enum);\n@@ -308,7 +308,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     scope: self.enclosing_scope(item.id),\n                 }))\n             }\n-            ast::ItemImpl(_, _, _, ref trait_ref, ref typ, _) => {\n+            ast::ItemKind::Impl(_, _, _, ref trait_ref, ref typ, _) => {\n                 let mut type_data = None;\n                 let sub_span;\n "}, {"sha": "7519def15032feddf6cc5d70c6fe349ff5d21a51", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -10,7 +10,6 @@\n \n // The Rust abstract syntax tree.\n \n-pub use self::Item_::*;\n pub use self::KleeneOp::*;\n pub use self::MacStmtStyle::*;\n pub use self::MetaItem_::*;\n@@ -1828,7 +1827,7 @@ pub struct Attribute_ {\n ///\n /// resolve maps each TraitRef's ref_id to its defining trait; that's all\n /// that the ref_id is for. The impl_id maps to the \"self type\" of this impl.\n-/// If this impl is an ItemImpl, the impl_id is redundant (it could be the\n+/// If this impl is an ItemKind::Impl, the impl_id is redundant (it could be the\n /// same as the impl's node id).\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitRef {\n@@ -1956,7 +1955,7 @@ pub struct Item {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n-    pub node: Item_,\n+    pub node: ItemKind,\n     pub vis: Visibility,\n     pub span: Span,\n }\n@@ -1968,68 +1967,68 @@ impl Item {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Item_ {\n+pub enum ItemKind {\n     /// An`extern crate` item, with optional original crate name,\n     ///\n     /// e.g. `extern crate foo` or `extern crate foo_bar as foo`\n-    ItemExternCrate(Option<Name>),\n+    ExternCrate(Option<Name>),\n     /// A `use` or `pub use` item\n-    ItemUse(P<ViewPath>),\n+    Use(P<ViewPath>),\n \n     /// A `static` item\n-    ItemStatic(P<Ty>, Mutability, P<Expr>),\n+    Static(P<Ty>, Mutability, P<Expr>),\n     /// A `const` item\n-    ItemConst(P<Ty>, P<Expr>),\n+    Const(P<Ty>, P<Expr>),\n     /// A function declaration\n-    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Block>),\n+    Fn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Block>),\n     /// A module\n-    ItemMod(Mod),\n+    Mod(Mod),\n     /// An external module\n-    ItemForeignMod(ForeignMod),\n+    ForeignMod(ForeignMod),\n     /// A type alias, e.g. `type Foo = Bar<u8>`\n-    ItemTy(P<Ty>, Generics),\n+    Ty(P<Ty>, Generics),\n     /// An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n-    ItemEnum(EnumDef, Generics),\n+    Enum(EnumDef, Generics),\n     /// A struct definition, e.g. `struct Foo<A> {x: A}`\n-    ItemStruct(VariantData, Generics),\n+    Struct(VariantData, Generics),\n     /// Represents a Trait Declaration\n-    ItemTrait(Unsafety,\n+    Trait(Unsafety,\n               Generics,\n               TyParamBounds,\n               Vec<P<TraitItem>>),\n \n     // Default trait implementations\n     ///\n     // `impl Trait for .. {}`\n-    ItemDefaultImpl(Unsafety, TraitRef),\n+    DefaultImpl(Unsafety, TraitRef),\n     /// An implementation, eg `impl<A> Trait for Foo { .. }`\n-    ItemImpl(Unsafety,\n+    Impl(Unsafety,\n              ImplPolarity,\n              Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n              Vec<P<ImplItem>>),\n     /// A macro invocation (which includes macro definition)\n-    ItemMac(Mac),\n+    Mac(Mac),\n }\n \n-impl Item_ {\n+impl ItemKind {\n     pub fn descriptive_variant(&self) -> &str {\n         match *self {\n-            ItemExternCrate(..) => \"extern crate\",\n-            ItemUse(..) => \"use\",\n-            ItemStatic(..) => \"static item\",\n-            ItemConst(..) => \"constant item\",\n-            ItemFn(..) => \"function\",\n-            ItemMod(..) => \"module\",\n-            ItemForeignMod(..) => \"foreign module\",\n-            ItemTy(..) => \"type alias\",\n-            ItemEnum(..) => \"enum\",\n-            ItemStruct(..) => \"struct\",\n-            ItemTrait(..) => \"trait\",\n-            ItemMac(..) |\n-            ItemImpl(..) |\n-            ItemDefaultImpl(..) => \"item\"\n+            ItemKind::ExternCrate(..) => \"extern crate\",\n+            ItemKind::Use(..) => \"use\",\n+            ItemKind::Static(..) => \"static item\",\n+            ItemKind::Const(..) => \"constant item\",\n+            ItemKind::Fn(..) => \"function\",\n+            ItemKind::Mod(..) => \"module\",\n+            ItemKind::ForeignMod(..) => \"foreign module\",\n+            ItemKind::Ty(..) => \"type alias\",\n+            ItemKind::Enum(..) => \"enum\",\n+            ItemKind::Struct(..) => \"struct\",\n+            ItemKind::Trait(..) => \"trait\",\n+            ItemKind::Mac(..) |\n+            ItemKind::Impl(..) |\n+            ItemKind::DefaultImpl(..) => \"item\"\n         }\n     }\n }"}, {"sha": "270133ad59995fb196fe0c1b4859ecf0630203cd", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -173,7 +173,7 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n \n         self.operation.visit_id(item.id);\n         match item.node {\n-            ItemUse(ref view_path) => {\n+            ItemKind::Use(ref view_path) => {\n                 match view_path.node {\n                     ViewPathSimple(_, _) |\n                     ViewPathGlob(_) => {}"}, {"sha": "57416bce3cbe7585b60bab42b43b173a319573c6", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -52,8 +52,8 @@ impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) ->\n     fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n         fold_foreign_mod(self, foreign_mod)\n     }\n-    fn fold_item_underscore(&mut self, item: ast::Item_) -> ast::Item_ {\n-        fold_item_underscore(self, item)\n+    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n+        fold_item_kind(self, item)\n     }\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         // If an expr is valid to cfg away it will have been removed by the\n@@ -129,26 +129,26 @@ fn fold_item<F>(cx: &mut Context<F>, item: P<ast::Item>) -> SmallVector<P<ast::I\n     }\n }\n \n-fn fold_item_underscore<F>(cx: &mut Context<F>, item: ast::Item_) -> ast::Item_ where\n+fn fold_item_kind<F>(cx: &mut Context<F>, item: ast::ItemKind) -> ast::ItemKind where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n     let item = match item {\n-        ast::ItemImpl(u, o, a, b, c, impl_items) => {\n+        ast::ItemKind::Impl(u, o, a, b, c, impl_items) => {\n             let impl_items = impl_items.into_iter()\n                                        .filter(|ii| (cx.in_cfg)(&ii.attrs))\n                                        .collect();\n-            ast::ItemImpl(u, o, a, b, c, impl_items)\n+            ast::ItemKind::Impl(u, o, a, b, c, impl_items)\n         }\n-        ast::ItemTrait(u, a, b, methods) => {\n+        ast::ItemKind::Trait(u, a, b, methods) => {\n             let methods = methods.into_iter()\n                                  .filter(|ti| (cx.in_cfg)(&ti.attrs))\n                                  .collect();\n-            ast::ItemTrait(u, a, b, methods)\n+            ast::ItemKind::Trait(u, a, b, methods)\n         }\n-        ast::ItemStruct(def, generics) => {\n-            ast::ItemStruct(fold_struct(cx, def), generics)\n+        ast::ItemKind::Struct(def, generics) => {\n+            ast::ItemKind::Struct(fold_struct(cx, def), generics)\n         }\n-        ast::ItemEnum(def, generics) => {\n+        ast::ItemKind::Enum(def, generics) => {\n             let variants = def.variants.into_iter().filter_map(|v| {\n                 if !(cx.in_cfg)(&v.node.attrs) {\n                     None\n@@ -167,14 +167,14 @@ fn fold_item_underscore<F>(cx: &mut Context<F>, item: ast::Item_) -> ast::Item_\n                     }))\n                 }\n             });\n-            ast::ItemEnum(ast::EnumDef {\n+            ast::ItemKind::Enum(ast::EnumDef {\n                 variants: variants.collect(),\n             }, generics)\n         }\n         item => item,\n     };\n \n-    fold::noop_fold_item_underscore(item, cx)\n+    fold::noop_fold_item_kind(item, cx)\n }\n \n fn fold_struct<F>(cx: &mut Context<F>, vdata: ast::VariantData) -> ast::VariantData where"}, {"sha": "e8a4bb59bdc3c503f69aed31bea52ed14f5c83d8", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -226,7 +226,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n             ident: name.clone(),\n             attrs: Vec::new(),\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::ItemConst(\n+            node: ast::ItemKind::Const(\n                 ty,\n                 expr,\n             ),"}, {"sha": "7014e576e2b8a36e2390e3da39262d03bf8c30a1", "filename": "src/libsyntax/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fentry.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use attr;\n-use ast::{Item, ItemFn};\n+use ast::{Item, ItemKind};\n \n pub enum EntryPointType {\n     None,\n@@ -23,7 +23,7 @@ pub enum EntryPointType {\n // them in sync.\n pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n     match item.node {\n-        ItemFn(..) => {\n+        ItemKind::Fn(..) => {\n             if attr::contains_name(&item.attrs, \"start\") {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {"}, {"sha": "381d952ea887499824193c4938ed8426400abed1", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -120,7 +120,7 @@ impl<F> MultiItemDecorator for F\n     }\n }\n \n-// A more flexible ItemModifier (ItemModifier should go away, eventually, FIXME).\n+// A more flexible ItemKind::Modifier (ItemKind::Modifier should go away, eventually, FIXME).\n // meta_item is the annotation, item is the item being modified, parent_item\n // is the impl or trait item is declared in if item is part of such a thing.\n // FIXME Decorators should follow the same pattern too."}, {"sha": "256825eacf28969e391a0b32068b5d5a114c63aa", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -213,7 +213,7 @@ pub trait AstBuilder {\n \n     // items\n     fn item(&self, span: Span,\n-            name: Ident, attrs: Vec<ast::Attribute> , node: ast::Item_) -> P<ast::Item>;\n+            name: Ident, attrs: Vec<ast::Attribute> , node: ast::ItemKind) -> P<ast::Item>;\n \n     fn arg(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::Arg;\n     // FIXME unused self\n@@ -951,7 +951,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item(&self, span: Span, name: Ident,\n-            attrs: Vec<ast::Attribute>, node: ast::Item_) -> P<ast::Item> {\n+            attrs: Vec<ast::Attribute>, node: ast::ItemKind) -> P<ast::Item> {\n         // FIXME: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n         P(ast::Item {\n@@ -974,7 +974,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.item(span,\n                   name,\n                   Vec::new(),\n-                  ast::ItemFn(self.fn_decl(inputs, output),\n+                  ast::ItemKind::Fn(self.fn_decl(inputs, output),\n                               ast::Unsafety::Normal,\n                               ast::Constness::NotConst,\n                               Abi::Rust,\n@@ -1026,7 +1026,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn item_enum_poly(&self, span: Span, name: Ident,\n                       enum_definition: ast::EnumDef,\n                       generics: Generics) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemEnum(enum_definition, generics))\n+        self.item(span, name, Vec::new(), ast::ItemKind::Enum(enum_definition, generics))\n     }\n \n     fn item_enum(&self, span: Span, name: Ident,\n@@ -1047,7 +1047,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn item_struct_poly(&self, span: Span, name: Ident,\n         struct_def: ast::VariantData, generics: Generics) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemStruct(struct_def, generics))\n+        self.item(span, name, Vec::new(), ast::ItemKind::Struct(struct_def, generics))\n     }\n \n     fn item_mod(&self, span: Span, inner_span: Span, name: Ident,\n@@ -1057,7 +1057,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             span,\n             name,\n             attrs,\n-            ast::ItemMod(ast::Mod {\n+            ast::ItemKind::Mod(ast::Mod {\n                 inner: inner_span,\n                 items: items,\n             })\n@@ -1071,7 +1071,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                    mutbl: ast::Mutability,\n                    expr: P<ast::Expr>)\n                    -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemStatic(ty, mutbl, expr))\n+        self.item(span, name, Vec::new(), ast::ItemKind::Static(ty, mutbl, expr))\n     }\n \n     fn item_const(&self,\n@@ -1080,12 +1080,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                   ty: P<ast::Ty>,\n                   expr: P<ast::Expr>)\n                   -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemConst(ty, expr))\n+        self.item(span, name, Vec::new(), ast::ItemKind::Const(ty, expr))\n     }\n \n     fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n                     generics: Generics) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemTy(ty, generics))\n+        self.item(span, name, Vec::new(), ast::ItemKind::Ty(ty, generics))\n     }\n \n     fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item> {\n@@ -1125,7 +1125,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             ident: special_idents::invalid,\n             attrs: vec![],\n-            node: ast::ItemUse(vp),\n+            node: ast::ItemKind::Use(vp),\n             vis: vis,\n             span: sp\n         })"}, {"sha": "bcd02fb8cb3cd345dbcb4facdb438e72c0b47a04", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -10,7 +10,7 @@\n \n use ast::{Block, Crate, DeclKind, PatMac};\n use ast::{Local, Ident, Mac_, Name};\n-use ast::{ItemMac, MacStmtWithSemicolon, Mrk, Stmt, StmtKind};\n+use ast::{MacStmtStyle, Mrk, Stmt, StmtKind, ItemKind};\n use ast::TokenTree;\n use ast;\n use ext::mtwt;\n@@ -315,17 +315,17 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n         .into_iter().map(|i| i.expect_item()).collect()\n }\n \n-/// Expand item_underscore\n-fn expand_item_underscore(item: ast::Item_, fld: &mut MacroExpander) -> ast::Item_ {\n+/// Expand item_kind\n+fn expand_item_kind(item: ast::ItemKind, fld: &mut MacroExpander) -> ast::ItemKind {\n     match item {\n-        ast::ItemFn(decl, unsafety, constness, abi, generics, body) => {\n+        ast::ItemKind::Fn(decl, unsafety, constness, abi, generics, body) => {\n             let (rewritten_fn_decl, rewritten_body)\n                 = expand_and_rename_fn_decl_and_block(decl, body, fld);\n             let expanded_generics = fold::noop_fold_generics(generics,fld);\n-            ast::ItemFn(rewritten_fn_decl, unsafety, constness, abi,\n+            ast::ItemKind::Fn(rewritten_fn_decl, unsafety, constness, abi,\n                         expanded_generics, rewritten_body)\n         }\n-        _ => noop_fold_item_underscore(item, fld)\n+        _ => noop_fold_item_kind(item, fld)\n     }\n }\n \n@@ -362,7 +362,7 @@ fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool\n pub fn expand_item_mac(it: P<ast::Item>,\n                        fld: &mut MacroExpander) -> SmallVector<P<ast::Item>> {\n     let (extname, path_span, tts, span, attrs, ident) = it.and_then(|it| match it.node {\n-        ItemMac(codemap::Spanned { node: Mac_ { path, tts, .. }, .. }) =>\n+        ItemKind::Mac(codemap::Spanned { node: Mac_ { path, tts, .. }, .. }) =>\n             (path.segments[0].identifier.name, path.span, tts, it.span, it.attrs, it.ident),\n         _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n     });\n@@ -890,10 +890,10 @@ fn expand_annotatable(a: Annotatable,\n \n     let mut new_items: SmallVector<Annotatable> = match a {\n         Annotatable::Item(it) => match it.node {\n-            ast::ItemMac(..) => {\n+            ast::ItemKind::Mac(..) => {\n                 expand_item_mac(it, fld).into_iter().map(|i| Annotatable::Item(i)).collect()\n             }\n-            ast::ItemMod(_) | ast::ItemForeignMod(_) => {\n+            ast::ItemKind::Mod(_) | ast::ItemKind::ForeignMod(_) => {\n                 let valid_ident =\n                     it.ident.name != parse::token::special_idents::invalid.name;\n \n@@ -1048,7 +1048,7 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n         }\n     }\n \n-    // Expansion may have added new ItemModifiers.\n+    // Expansion may have added new ItemKind::Modifiers.\n     expand_item_multi_modifier(it, fld)\n }\n \n@@ -1194,8 +1194,8 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_item(item, self)\n     }\n \n-    fn fold_item_underscore(&mut self, item: ast::Item_) -> ast::Item_ {\n-        expand_item_underscore(item, self)\n+    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n+        expand_item_kind(item, self)\n     }\n \n     fn fold_stmt(&mut self, stmt: P<ast::Stmt>) -> SmallVector<P<ast::Stmt>> {"}, {"sha": "6dc0da1eb09d78ce73a2f861e1970d0a7f2a0803", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -855,15 +855,15 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n     fn visit_item(&mut self, i: &ast::Item) {\n         match i.node {\n-            ast::ItemExternCrate(_) => {\n+            ast::ItemKind::ExternCrate(_) => {\n                 if attr::contains_name(&i.attrs[..], \"macro_reexport\") {\n                     self.gate_feature(\"macro_reexport\", i.span,\n                                       \"macros reexports are experimental \\\n                                        and possibly buggy\");\n                 }\n             }\n \n-            ast::ItemForeignMod(ref foreign_module) => {\n+            ast::ItemKind::ForeignMod(ref foreign_module) => {\n                 if attr::contains_name(&i.attrs[..], \"link_args\") {\n                     self.gate_feature(\"link_args\", i.span,\n                                       \"the `link_args` attribute is not portable \\\n@@ -888,7 +888,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemFn(..) => {\n+            ast::ItemKind::Fn(..) => {\n                 if attr::contains_name(&i.attrs[..], \"plugin_registrar\") {\n                     self.gate_feature(\"plugin_registrar\", i.span,\n                                       \"compiler plugins are experimental and possibly buggy\");\n@@ -907,7 +907,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemStruct(..) => {\n+            ast::ItemKind::Struct(..) => {\n                 if attr::contains_name(&i.attrs[..], \"simd\") {\n                     self.gate_feature(\"simd\", i.span,\n                                       \"SIMD types are experimental and possibly buggy\");\n@@ -928,14 +928,14 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemDefaultImpl(..) => {\n+            ast::ItemKind::DefaultImpl(..) => {\n                 self.gate_feature(\"optin_builtin_traits\",\n                                   i.span,\n                                   \"default trait implementations are experimental \\\n                                    and possibly buggy\");\n             }\n \n-            ast::ItemImpl(_, polarity, _, _, _, _) => {\n+            ast::ItemKind::Impl(_, polarity, _, _, _, _) => {\n                 match polarity {\n                     ast::ImplPolarity::Negative => {\n                         self.gate_feature(\"optin_builtin_traits\","}, {"sha": "8bb915362e80d3966d1fb0f2ebccac813663d13e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -71,8 +71,8 @@ pub trait Folder : Sized {\n         noop_fold_struct_field(sf, self)\n     }\n \n-    fn fold_item_underscore(&mut self, i: Item_) -> Item_ {\n-        noop_fold_item_underscore(i, self)\n+    fn fold_item_kind(&mut self, i: ItemKind) -> ItemKind {\n+        noop_fold_item_kind(i, self)\n     }\n \n     fn fold_trait_item(&mut self, i: P<TraitItem>) -> SmallVector<P<TraitItem>> {\n@@ -890,20 +890,20 @@ pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     })\n }\n \n-pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n+pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n     match i {\n-        ItemExternCrate(string) => ItemExternCrate(string),\n-        ItemUse(view_path) => {\n-            ItemUse(folder.fold_view_path(view_path))\n+        ItemKind::ExternCrate(string) => ItemKind::ExternCrate(string),\n+        ItemKind::Use(view_path) => {\n+            ItemKind::Use(folder.fold_view_path(view_path))\n         }\n-        ItemStatic(t, m, e) => {\n-            ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n+        ItemKind::Static(t, m, e) => {\n+            ItemKind::Static(folder.fold_ty(t), m, folder.fold_expr(e))\n         }\n-        ItemConst(t, e) => {\n-            ItemConst(folder.fold_ty(t), folder.fold_expr(e))\n+        ItemKind::Const(t, e) => {\n+            ItemKind::Const(folder.fold_ty(t), folder.fold_expr(e))\n         }\n-        ItemFn(decl, unsafety, constness, abi, generics, body) => {\n-            ItemFn(\n+        ItemKind::Fn(decl, unsafety, constness, abi, generics, body) => {\n+            ItemKind::Fn(\n                 folder.fold_fn_decl(decl),\n                 unsafety,\n                 constness,\n@@ -912,26 +912,26 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n                 folder.fold_block(body)\n             )\n         }\n-        ItemMod(m) => ItemMod(folder.fold_mod(m)),\n-        ItemForeignMod(nm) => ItemForeignMod(folder.fold_foreign_mod(nm)),\n-        ItemTy(t, generics) => {\n-            ItemTy(folder.fold_ty(t), folder.fold_generics(generics))\n+        ItemKind::Mod(m) => ItemKind::Mod(folder.fold_mod(m)),\n+        ItemKind::ForeignMod(nm) => ItemKind::ForeignMod(folder.fold_foreign_mod(nm)),\n+        ItemKind::Ty(t, generics) => {\n+            ItemKind::Ty(folder.fold_ty(t), folder.fold_generics(generics))\n         }\n-        ItemEnum(enum_definition, generics) => {\n-            ItemEnum(\n+        ItemKind::Enum(enum_definition, generics) => {\n+            ItemKind::Enum(\n                 ast::EnumDef {\n                     variants: enum_definition.variants.move_map(|x| folder.fold_variant(x)),\n                 },\n                 folder.fold_generics(generics))\n         }\n-        ItemStruct(struct_def, generics) => {\n+        ItemKind::Struct(struct_def, generics) => {\n             let struct_def = folder.fold_variant_data(struct_def);\n-            ItemStruct(struct_def, folder.fold_generics(generics))\n+            ItemKind::Struct(struct_def, folder.fold_generics(generics))\n         }\n-        ItemDefaultImpl(unsafety, ref trait_ref) => {\n-            ItemDefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n+        ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n+            ItemKind::DefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n         }\n-        ItemImpl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n+        ItemKind::Impl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n             let new_impl_items = impl_items.move_flat_map(|item| {\n                 folder.fold_impl_item(item)\n             });\n@@ -941,24 +941,24 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n                     Some(folder.fold_trait_ref((*trait_ref).clone()))\n                 }\n             };\n-            ItemImpl(unsafety,\n+            ItemKind::Impl(unsafety,\n                      polarity,\n                      folder.fold_generics(generics),\n                      ifce,\n                      folder.fold_ty(ty),\n                      new_impl_items)\n         }\n-        ItemTrait(unsafety, generics, bounds, items) => {\n+        ItemKind::Trait(unsafety, generics, bounds, items) => {\n             let bounds = folder.fold_bounds(bounds);\n             let items = items.move_flat_map(|item| {\n                 folder.fold_trait_item(item)\n             });\n-            ItemTrait(unsafety,\n+            ItemKind::Trait(unsafety,\n                       folder.fold_generics(generics),\n                       bounds,\n                       items)\n         }\n-        ItemMac(m) => ItemMac(folder.fold_mac(m)),\n+        ItemKind::Mac(m) => ItemKind::Mac(folder.fold_mac(m)),\n     }\n }\n \n@@ -1025,7 +1025,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_mac\n         id: ast::DUMMY_NODE_ID,\n         vis: ast::Public,\n         span: span,\n-        node: ast::ItemMod(module),\n+        node: ast::ItemKind::Mod(module),\n     })).into_iter();\n \n     let (module, attrs, span) = match items.next() {\n@@ -1034,7 +1034,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_mac\n                     \"a crate cannot expand to more than one item\");\n             item.and_then(|ast::Item { attrs, span, node, .. }| {\n                 match node {\n-                    ast::ItemMod(m) => (m, attrs, span),\n+                    ast::ItemKind::Mod(m) => (m, attrs, span),\n                     _ => panic!(\"fold converted a module to not a module\"),\n                 }\n             })\n@@ -1067,10 +1067,10 @@ pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVector<P<It\n pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}: Item,\n                                         folder: &mut T) -> Item {\n     let id = folder.new_id(id);\n-    let node = folder.fold_item_underscore(node);\n+    let node = folder.fold_item_kind(node);\n     let ident = match node {\n         // The node may have changed, recompute the \"pretty\" impl name.\n-        ItemImpl(_, _, _, ref maybe_trait, ref ty, _) => {\n+        ItemKind::Impl(_, _, _, ref maybe_trait, ref ty, _) => {\n             ast_util::impl_pretty_name(maybe_trait, Some(&**ty))\n         }\n         _ => ident"}, {"sha": "a505b27e9db09500b2a39bc1880b9f33dbf647ef", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -913,7 +913,7 @@ mod tests {\n                       P(ast::Item{ident:str_to_ident(\"a\"),\n                             attrs:Vec::new(),\n                             id: ast::DUMMY_NODE_ID,\n-                            node: ast::ItemFn(P(ast::FnDecl {\n+                            node: ast::ItemKind::Fn(P(ast::FnDecl {\n                                 inputs: vec!(ast::Arg{\n                                     ty: P(ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                   node: ast::TyKind::Path(None, ast::Path{"}, {"sha": "4133c024f85668411f2a1a093abf9582ed5c532d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -23,10 +23,7 @@ use ast::{EMPTY_CTXT, EnumDef, ExplicitSelf};\n use ast::{Expr, ExprKind};\n use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n-use ast::{Ident, Inherited, ImplItem, Item, Item_, ItemStatic};\n-use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl, ItemConst};\n-use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy, ItemDefaultImpl};\n-use ast::{ItemExternCrate, ItemUse};\n+use ast::{Ident, Inherited, ImplItem, Item, ItemKind};\n use ast::{Lit, LitKind, UintTy};\n use ast::Local;\n use ast::{MacStmtWithBraces, MacStmtWithSemicolon, MacStmtWithoutBraces};\n@@ -80,7 +77,7 @@ bitflags! {\n     }\n }\n \n-type ItemInfo = (Ident, Item_, Option<Vec<Attribute> >);\n+type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute> >);\n \n /// How to parse a path. There are four different kinds of paths, all of which\n /// are parsed somewhat differently.\n@@ -3750,7 +3747,7 @@ impl<'a> Parser<'a> {\n                     P(spanned(lo, hi, DeclKind::Item(\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n-                            ItemMac(spanned(lo, hi,\n+                            ItemKind::Mac(spanned(lo, hi,\n                                             Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT })),\n                             Inherited, attrs)))),\n                     ast::DUMMY_NODE_ID))\n@@ -4590,7 +4587,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn mk_item(&mut self, lo: BytePos, hi: BytePos, ident: Ident,\n-               node: Item_, vis: Visibility,\n+               node: ItemKind, vis: Visibility,\n                attrs: Vec<Attribute>) -> P<Item> {\n         P(Item {\n             ident: ident,\n@@ -4612,7 +4609,7 @@ impl<'a> Parser<'a> {\n         let decl = try!(self.parse_fn_decl(false));\n         generics.where_clause = try!(self.parse_where_clause());\n         let (inner_attrs, body) = try!(self.parse_inner_attrs_and_block());\n-        Ok((ident, ItemFn(decl, unsafety, constness, abi, generics, body), Some(inner_attrs)))\n+        Ok((ident, ItemKind::Fn(decl, unsafety, constness, abi, generics, body), Some(inner_attrs)))\n     }\n \n     /// true if we are looking at `const ID`, false for things like `const fn` etc\n@@ -4772,7 +4769,7 @@ impl<'a> Parser<'a> {\n         tps.where_clause = try!(self.parse_where_clause());\n \n         let meths = try!(self.parse_trait_items());\n-        Ok((ident, ItemTrait(unsafety, tps, bounds, meths), None))\n+        Ok((ident, ItemKind::Trait(unsafety, tps, bounds, meths), None))\n     }\n \n     /// Parses items implementations variants\n@@ -4835,7 +4832,7 @@ impl<'a> Parser<'a> {\n             try!(self.expect(&token::OpenDelim(token::Brace)));\n             try!(self.expect(&token::CloseDelim(token::Brace)));\n             Ok((ast_util::impl_pretty_name(&opt_trait, None),\n-             ItemDefaultImpl(unsafety, opt_trait.unwrap()), None))\n+             ItemKind::DefaultImpl(unsafety, opt_trait.unwrap()), None))\n         } else {\n             if opt_trait.is_some() {\n                 ty = try!(self.parse_ty_sum());\n@@ -4851,7 +4848,7 @@ impl<'a> Parser<'a> {\n             }\n \n             Ok((ast_util::impl_pretty_name(&opt_trait, Some(&*ty)),\n-             ItemImpl(unsafety, polarity, generics, opt_trait, ty, impl_items),\n+             ItemKind::Impl(unsafety, polarity, generics, opt_trait, ty, impl_items),\n              Some(attrs)))\n         }\n     }\n@@ -4936,7 +4933,7 @@ impl<'a> Parser<'a> {\n                                             name, found `{}`\", token_str)))\n         };\n \n-        Ok((class_name, ItemStruct(vdata, generics), None))\n+        Ok((class_name, ItemKind::Struct(vdata, generics), None))\n     }\n \n     pub fn parse_record_struct_body(&mut self,\n@@ -5066,8 +5063,8 @@ impl<'a> Parser<'a> {\n         let e = try!(self.parse_expr());\n         try!(self.commit_expr_expecting(&*e, token::Semi));\n         let item = match m {\n-            Some(m) => ItemStatic(ty, m, e),\n-            None => ItemConst(ty, e),\n+            Some(m) => ItemKind::Static(ty, m, e),\n+            None => ItemKind::Const(ty, e),\n         };\n         Ok((id, item, None))\n     }\n@@ -5091,7 +5088,7 @@ impl<'a> Parser<'a> {\n             let m = try!(self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo));\n             self.owns_directory = old_owns_directory;\n             self.pop_mod_path();\n-            Ok((id, ItemMod(m), Some(attrs)))\n+            Ok((id, ItemKind::Mod(m), Some(attrs)))\n         }\n     }\n \n@@ -5197,7 +5194,7 @@ impl<'a> Parser<'a> {\n                     id: ast::Ident,\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n-                    -> PResult<'a, (ast::Item_, Vec<ast::Attribute> )> {\n+                    -> PResult<'a, (ast::ItemKind, Vec<ast::Attribute> )> {\n         let ModulePathSuccess { path, owns_directory } = try!(self.submod_path(id,\n                                                                                outer_attrs,\n                                                                                id_sp));\n@@ -5212,7 +5209,7 @@ impl<'a> Parser<'a> {\n                               path: PathBuf,\n                               owns_directory: bool,\n                               name: String,\n-                              id_sp: Span) -> PResult<'a, (ast::Item_, Vec<ast::Attribute> )> {\n+                              id_sp: Span) -> PResult<'a, (ast::ItemKind, Vec<ast::Attribute> )> {\n         let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n         match included_mod_stack.iter().position(|p| *p == path) {\n             Some(i) => {\n@@ -5240,7 +5237,7 @@ impl<'a> Parser<'a> {\n         let mod_attrs = try!(p0.parse_inner_attributes());\n         let m0 = try!(p0.parse_mod_items(&token::Eof, mod_inner_lo));\n         self.sess.included_mod_stack.borrow_mut().pop();\n-        Ok((ast::ItemMod(m0), mod_attrs))\n+        Ok((ast::ItemKind::Mod(m0), mod_attrs))\n     }\n \n     /// Parse a function declaration from a foreign module\n@@ -5315,7 +5312,7 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_item(lo,\n                         last_span.hi,\n                         ident,\n-                        ItemExternCrate(maybe_path),\n+                        ItemKind::ExternCrate(maybe_path),\n                         visibility,\n                         attrs))\n     }\n@@ -5356,7 +5353,7 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_item(lo,\n                      last_span.hi,\n                      special_idents::invalid,\n-                     ItemForeignMod(m),\n+                     ItemKind::ForeignMod(m),\n                      visibility,\n                      attrs))\n     }\n@@ -5369,7 +5366,7 @@ impl<'a> Parser<'a> {\n         try!(self.expect(&token::Eq));\n         let ty = try!(self.parse_ty_sum());\n         try!(self.expect(&token::Semi));\n-        Ok((ident, ItemTy(ty, tps), None))\n+        Ok((ident, ItemKind::Ty(ty, tps), None))\n     }\n \n     /// Parse the part of an \"enum\" decl following the '{'\n@@ -5430,7 +5427,7 @@ impl<'a> Parser<'a> {\n         try!(self.expect(&token::OpenDelim(token::Brace)));\n \n         let enum_definition = try!(self.parse_enum_def(&generics));\n-        Ok((id, ItemEnum(enum_definition, generics), None))\n+        Ok((id, ItemKind::Enum(enum_definition, generics), None))\n     }\n \n     /// Parses a string as an ABI spec on an extern type or module. Consumes\n@@ -5488,7 +5485,7 @@ impl<'a> Parser<'a> {\n \n         if self.eat_keyword(keywords::Use) {\n             // USE ITEM\n-            let item_ = ItemUse(try!(self.parse_view_path()));\n+            let item_ = ItemKind::Use(try!(self.parse_view_path()));\n             try!(self.expect(&token::Semi));\n \n             let last_span = self.last_span;\n@@ -5804,7 +5801,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n \n-            let item_ = ItemMac(m);\n+            let item_ = ItemKind::Mac(m);\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,"}, {"sha": "167df26f433fbb91b8e7f50349a4c2399aa659b2", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -1117,7 +1117,7 @@ impl<'a> State<'a> {\n         try!(self.print_outer_attributes(&item.attrs));\n         try!(self.ann.pre(self, NodeItem(item)));\n         match item.node {\n-            ast::ItemExternCrate(ref optional_path) => {\n+            ast::ItemKind::ExternCrate(ref optional_path) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                      \"extern crate\")));\n                 if let Some(p) = *optional_path {\n@@ -1136,15 +1136,15 @@ impl<'a> State<'a> {\n                 try!(self.end()); // end inner head-block\n                 try!(self.end()); // end outer head-block\n             }\n-            ast::ItemUse(ref vp) => {\n+            ast::ItemKind::Use(ref vp) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                      \"use\")));\n                 try!(self.print_view_path(&**vp));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end inner head-block\n                 try!(self.end()); // end outer head-block\n             }\n-            ast::ItemStatic(ref ty, m, ref expr) => {\n+            ast::ItemKind::Static(ref ty, m, ref expr) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                     \"static\")));\n                 if m == ast::MutMutable {\n@@ -1161,7 +1161,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n-            ast::ItemConst(ref ty, ref expr) => {\n+            ast::ItemKind::Const(ref ty, ref expr) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                     \"const\")));\n                 try!(self.print_ident(item.ident));\n@@ -1175,7 +1175,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n-            ast::ItemFn(ref decl, unsafety, constness, abi, ref typarams, ref body) => {\n+            ast::ItemKind::Fn(ref decl, unsafety, constness, abi, ref typarams, ref body) => {\n                 try!(self.head(\"\"));\n                 try!(self.print_fn(\n                     decl,\n@@ -1190,7 +1190,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.print_block_with_attrs(&**body, &item.attrs));\n             }\n-            ast::ItemMod(ref _mod) => {\n+            ast::ItemKind::Mod(ref _mod) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                     \"mod\")));\n                 try!(self.print_ident(item.ident));\n@@ -1199,14 +1199,14 @@ impl<'a> State<'a> {\n                 try!(self.print_mod(_mod, &item.attrs));\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemForeignMod(ref nmod) => {\n+            ast::ItemKind::ForeignMod(ref nmod) => {\n                 try!(self.head(\"extern\"));\n                 try!(self.word_nbsp(&nmod.abi.to_string()));\n                 try!(self.bopen());\n                 try!(self.print_foreign_mod(nmod, &item.attrs));\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemTy(ref ty, ref params) => {\n+            ast::ItemKind::Ty(ref ty, ref params) => {\n                 try!(self.ibox(INDENT_UNIT));\n                 try!(self.ibox(0));\n                 try!(self.word_nbsp(&visibility_qualified(item.vis, \"type\")));\n@@ -1221,7 +1221,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer ibox\n             }\n-            ast::ItemEnum(ref enum_definition, ref params) => {\n+            ast::ItemKind::Enum(ref enum_definition, ref params) => {\n                 try!(self.print_enum_def(\n                     enum_definition,\n                     params,\n@@ -1230,12 +1230,12 @@ impl<'a> State<'a> {\n                     item.vis\n                 ));\n             }\n-            ast::ItemStruct(ref struct_def, ref generics) => {\n+            ast::ItemKind::Struct(ref struct_def, ref generics) => {\n                 try!(self.head(&visibility_qualified(item.vis,\"struct\")));\n                 try!(self.print_struct(&struct_def, generics, item.ident, item.span, true));\n             }\n \n-            ast::ItemDefaultImpl(unsafety, ref trait_ref) => {\n+            ast::ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n                 try!(self.head(\"\"));\n                 try!(self.print_visibility(item.vis));\n                 try!(self.print_unsafety(unsafety));\n@@ -1247,7 +1247,7 @@ impl<'a> State<'a> {\n                 try!(self.bopen());\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemImpl(unsafety,\n+            ast::ItemKind::Impl(unsafety,\n                           polarity,\n                           ref generics,\n                           ref opt_trait,\n@@ -1290,7 +1290,7 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemTrait(unsafety, ref generics, ref bounds, ref trait_items) => {\n+            ast::ItemKind::Trait(unsafety, ref generics, ref bounds, ref trait_items) => {\n                 try!(self.head(\"\"));\n                 try!(self.print_visibility(item.vis));\n                 try!(self.print_unsafety(unsafety));\n@@ -1316,7 +1316,7 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemMac(codemap::Spanned { ref node, .. }) => {\n+            ast::ItemKind::Mac(codemap::Spanned { ref node, .. }) => {\n                 try!(self.print_visibility(item.vis));\n                 try!(self.print_path(&node.path, false, 0));\n                 try!(word(&mut self.s, \"! \"));\n@@ -1596,7 +1596,7 @@ impl<'a> State<'a> {\n                 try!(self.print_associated_type(ii.ident, None, Some(ty)));\n             }\n             ast::ImplItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n-                // code copied from ItemMac:\n+                // code copied from ItemKind::Mac:\n                 try!(self.print_path(&node.path, false, 0));\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.cbox(INDENT_UNIT));"}, {"sha": "828896d422cc1d683c80be45f61142d7bc84fe2f", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -89,7 +89,7 @@ impl fold::Folder for CrateInjector {\n             attrs: vec!(\n                 attr::mk_attr_outer(attr::mk_attr_id(), attr::mk_word_item(\n                         InternedString::new(\"macro_use\")))),\n-            node: ast::ItemExternCrate(Some(self.crate_name)),\n+            node: ast::ItemKind::ExternCrate(Some(self.crate_name)),\n             vis: ast::Inherited,\n             span: DUMMY_SP\n         }));\n@@ -149,7 +149,7 @@ impl fold::Folder for PreludeInjector {\n         mod_.items.insert(0, P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n             ident: special_idents::invalid,\n-            node: ast::ItemUse(vp),\n+            node: ast::ItemKind::Use(vp),\n             attrs: vec![ast::Attribute {\n                 span: self.span,\n                 node: ast::Attribute_ {"}, {"sha": "a817eb62af8f7f7914f3cc16660958c43dd88098", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -125,7 +125,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n \n         let i = if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n             match i.node {\n-                ast::ItemFn(_, ast::Unsafety::Unsafe, _, _, _, _) => {\n+                ast::ItemKind::Fn(_, ast::Unsafety::Unsafe, _, _, _, _) => {\n                     let diag = self.cx.span_diagnostic;\n                     panic!(diag.span_fatal(i.span, \"unsafe functions cannot be used for tests\"));\n                 }\n@@ -159,7 +159,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n         let res = match i.node {\n-            ast::ItemMod(..) => fold::noop_fold_item(i, self),\n+            ast::ItemKind::Mod(..) => fold::noop_fold_item(i, self),\n             _ => SmallVector::one(i),\n         };\n         if ident.name != token::special_idents::invalid.name {\n@@ -262,7 +262,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n         ident: sym.clone(),\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ItemMod(reexport_mod),\n+        node: ast::ItemKind::Mod(reexport_mod),\n         vis: ast::Public,\n         span: DUMMY_SP,\n     });\n@@ -355,7 +355,7 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n \n     fn has_test_signature(i: &ast::Item) -> HasTestSignature {\n         match i.node {\n-          ast::ItemFn(ref decl, _, _, _, ref generics, _) => {\n+          ast::ItemKind::Fn(ref decl, _, _, _, ref generics, _) => {\n             let no_output = match decl.output {\n                 ast::FunctionRetTy::Default(..) => true,\n                 ast::FunctionRetTy::Ty(ref t) if t.node == ast::TyKind::Tup(vec![]) => true,\n@@ -391,7 +391,7 @@ fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n \n     fn has_test_signature(i: &ast::Item) -> bool {\n         match i.node {\n-            ast::ItemFn(ref decl, _, _, _, ref generics, _) => {\n+            ast::ItemKind::Fn(ref decl, _, _, _, ref generics, _) => {\n                 let input_cnt = decl.inputs.len();\n                 let no_output = match decl.output {\n                     ast::FunctionRetTy::Default(..) => true,\n@@ -453,12 +453,12 @@ mod __test {\n fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n     let id_test = token::str_to_ident(\"test\");\n     let (vi, vis, ident) = if cx.is_test_crate {\n-        (ast::ItemUse(\n+        (ast::ItemKind::Use(\n             P(nospan(ast::ViewPathSimple(id_test,\n                                          path_node(vec!(id_test)))))),\n          ast::Public, token::special_idents::invalid)\n     } else {\n-        (ast::ItemExternCrate(None), ast::Inherited, id_test)\n+        (ast::ItemKind::ExternCrate(None), ast::Inherited, id_test)\n     };\n     P(ast::Item {\n         id: ast::DUMMY_NODE_ID,\n@@ -496,7 +496,7 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n     let main_body = ecx.block_all(sp, vec![call_test_main], None);\n-    let main = ast::ItemFn(ecx.fn_decl(vec![], main_ret_ty),\n+    let main = ast::ItemKind::Fn(ecx.fn_decl(vec![], main_ret_ty),\n                            ast::Unsafety::Normal,\n                            ast::Constness::NotConst,\n                            ::abi::Abi::Rust, ast::Generics::default(), main_body);\n@@ -527,7 +527,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         inner: DUMMY_SP,\n         items: vec![import, mainfn, tests],\n     };\n-    let item_ = ast::ItemMod(testmod);\n+    let item_ = ast::ItemKind::Mod(testmod);\n \n     let mod_ident = token::gensym_ident(\"__test\");\n     let item = P(ast::Item {\n@@ -550,7 +550,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n             id: ast::DUMMY_NODE_ID,\n             ident: token::special_idents::invalid,\n             attrs: vec![],\n-            node: ast::ItemUse(P(use_path)),\n+            node: ast::ItemKind::Use(P(use_path)),\n             vis: ast::Inherited,\n             span: DUMMY_SP\n         })"}, {"sha": "4082bcbe38e76a3f94d6f66741606b9611680a0e", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -230,10 +230,10 @@ pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_ident(item.span, item.ident);\n     match item.node {\n-        ItemExternCrate(opt_name) => {\n+        ItemKind::ExternCrate(opt_name) => {\n             walk_opt_name(visitor, item.span, opt_name)\n         }\n-        ItemUse(ref vp) => {\n+        ItemKind::Use(ref vp) => {\n             match vp.node {\n                 ViewPathSimple(ident, ref path) => {\n                     visitor.visit_ident(vp.span, ident);\n@@ -253,37 +253,37 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                 }\n             }\n         }\n-        ItemStatic(ref typ, _, ref expr) |\n-        ItemConst(ref typ, ref expr) => {\n+        ItemKind::Static(ref typ, _, ref expr) |\n+        ItemKind::Const(ref typ, ref expr) => {\n             visitor.visit_ty(typ);\n             visitor.visit_expr(expr);\n         }\n-        ItemFn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n+        ItemKind::Fn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n             visitor.visit_fn(FnKind::ItemFn(item.ident, generics, unsafety,\n                                             constness, abi, item.vis),\n                              declaration,\n                              body,\n                              item.span,\n                              item.id)\n         }\n-        ItemMod(ref module) => {\n+        ItemKind::Mod(ref module) => {\n             visitor.visit_mod(module, item.span, item.id)\n         }\n-        ItemForeignMod(ref foreign_module) => {\n+        ItemKind::ForeignMod(ref foreign_module) => {\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n-        ItemTy(ref typ, ref type_parameters) => {\n+        ItemKind::Ty(ref typ, ref type_parameters) => {\n             visitor.visit_ty(typ);\n             visitor.visit_generics(type_parameters)\n         }\n-        ItemEnum(ref enum_definition, ref type_parameters) => {\n+        ItemKind::Enum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters);\n             visitor.visit_enum_def(enum_definition, type_parameters, item.id, item.span)\n         }\n-        ItemDefaultImpl(_, ref trait_ref) => {\n+        ItemKind::DefaultImpl(_, ref trait_ref) => {\n             visitor.visit_trait_ref(trait_ref)\n         }\n-        ItemImpl(_, _,\n+        ItemKind::Impl(_, _,\n                  ref type_parameters,\n                  ref opt_trait_reference,\n                  ref typ,\n@@ -293,17 +293,17 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_ty(typ);\n             walk_list!(visitor, visit_impl_item, impl_items);\n         }\n-        ItemStruct(ref struct_definition, ref generics) => {\n+        ItemKind::Struct(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_variant_data(struct_definition, item.ident,\n                                      generics, item.id, item.span);\n         }\n-        ItemTrait(_, ref generics, ref bounds, ref methods) => {\n+        ItemKind::Trait(_, ref generics, ref bounds, ref methods) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n             walk_list!(visitor, visit_trait_item, methods);\n         }\n-        ItemMac(ref mac) => visitor.visit_mac(mac),\n+        ItemKind::Mac(ref mac) => visitor.visit_mac(mac),\n     }\n     walk_list!(visitor, visit_attribute, &item.attrs);\n }"}, {"sha": "51091b84672704b02ec6f9aca147ddfc1a2a7b89", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -391,13 +391,13 @@ impl<'a> TraitDef<'a> {\n         match *item {\n             Annotatable::Item(ref item) => {\n                 let newitem = match item.node {\n-                    ast::ItemStruct(ref struct_def, ref generics) => {\n+                    ast::ItemKind::Struct(ref struct_def, ref generics) => {\n                         self.expand_struct_def(cx,\n                                                &struct_def,\n                                                item.ident,\n                                                generics)\n                     }\n-                    ast::ItemEnum(ref enum_def, ref generics) => {\n+                    ast::ItemKind::Enum(ref enum_def, ref generics) => {\n                         self.expand_enum_def(cx,\n                                              enum_def,\n                                              &item.attrs,\n@@ -637,12 +637,12 @@ impl<'a> TraitDef<'a> {\n             self.span,\n             ident,\n             a,\n-            ast::ItemImpl(unsafety,\n-                          ast::ImplPolarity::Positive,\n-                          trait_generics,\n-                          opt_trait_ref,\n-                          self_type,\n-                          methods.into_iter().chain(associated_types).collect()))\n+            ast::ItemKind::Impl(unsafety,\n+                                ast::ImplPolarity::Positive,\n+                                trait_generics,\n+                                opt_trait_ref,\n+                                self_type,\n+                                methods.into_iter().chain(associated_types).collect()))\n     }\n \n     fn expand_struct_def(&self,"}, {"sha": "a5ad143f15b56dd0e4bfc21d9533bdecefbf5366", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -453,7 +453,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             ast::MutImmutable);\n         let slice = ecx.expr_vec_slice(sp, pieces);\n         // static instead of const to speed up codegen by not requiring this to be inlined\n-        let st = ast::ItemStatic(ty, ast::MutImmutable, slice);\n+        let st = ast::ItemKind::Static(ty, ast::MutImmutable, slice);\n \n         let name = ecx.ident_of(name);\n         let item = ecx.item(sp, name, vec![], st);"}, {"sha": "2c68296b634d2da94360c7bbe4b36610d1c1d09c", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/019614f03d106324ab50a37746b556c41e66c099/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019614f03d106324ab50a37746b556c41e66c099/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=019614f03d106324ab50a37746b556c41e66c099", "patch": "@@ -16,7 +16,7 @@ extern crate syntax;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use syntax::ast::{self, TokenTree, Item, MetaItem, ImplItem, TraitItem};\n+use syntax::ast::{self, TokenTree, Item, MetaItem, ImplItem, TraitItem, ItemKind};\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::parse::{self, token};\n@@ -73,7 +73,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n         Annotatable::ImplItem(it) => {\n             quote_item!(cx, impl X { fn foo(&self) -> i32 { 42 } }).unwrap().and_then(|i| {\n                 match i.node {\n-                    ast::ItemImpl(_, _, _, _, _, mut items) => {\n+                    ItemKind::Impl(_, _, _, _, _, mut items) => {\n                         Annotatable::ImplItem(items.pop().expect(\"impl method not found\"))\n                     }\n                     _ => unreachable!(\"impl parsed to something other than impl\")\n@@ -83,7 +83,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n         Annotatable::TraitItem(it) => {\n             quote_item!(cx, trait X { fn foo(&self) -> i32 { 0 } }).unwrap().and_then(|i| {\n                 match i.node {\n-                    ast::ItemTrait(_, _, _, mut items) => {\n+                    ItemKind::Trait(_, _, _, mut items) => {\n                         Annotatable::TraitItem(items.pop().expect(\"trait method not found\"))\n                     }\n                     _ => unreachable!(\"trait parsed to something other than trait\")"}]}