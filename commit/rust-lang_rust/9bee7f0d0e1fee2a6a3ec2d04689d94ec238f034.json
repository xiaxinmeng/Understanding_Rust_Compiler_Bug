{"sha": "9bee7f0d0e1fee2a6a3ec2d04689d94ec238f034", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliZWU3ZjBkMGUxZmVlMmE2YTNlYzJkMDQ2ODlkOTRlYzIzOGYwMzQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-06-18T17:19:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-06-18T17:19:08Z"}, "message": "WIP: identify the case where we need to serialize path", "tree": {"sha": "46c6cdb4b7be1b6d24e00220ac88c170970b568c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46c6cdb4b7be1b6d24e00220ac88c170970b568c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bee7f0d0e1fee2a6a3ec2d04689d94ec238f034", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bee7f0d0e1fee2a6a3ec2d04689d94ec238f034", "html_url": "https://github.com/rust-lang/rust/commit/9bee7f0d0e1fee2a6a3ec2d04689d94ec238f034", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bee7f0d0e1fee2a6a3ec2d04689d94ec238f034/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbc9da7962b7282c5752a7bc2c9907694b7c158c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc9da7962b7282c5752a7bc2c9907694b7c158c", "html_url": "https://github.com/rust-lang/rust/commit/dbc9da7962b7282c5752a7bc2c9907694b7c158c"}], "stats": {"total": 50, "additions": 40, "deletions": 10}, "files": [{"sha": "5f6731b6c5219c6c68586c26aa54deb679e2ce9d", "filename": "compiler/rustc_typeck/src/check/method/prelude2021.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9bee7f0d0e1fee2a6a3ec2d04689d94ec238f034/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bee7f0d0e1fee2a6a3ec2d04689d94ec238f034/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs?ref=9bee7f0d0e1fee2a6a3ec2d04689d94ec238f034", "patch": "@@ -1,10 +1,12 @@\n use hir::def_id::DefId;\n use hir::HirId;\n+use hir::ItemKind;\n use rustc_ast::Mutability;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_middle::ty::Ty;\n use rustc_session::lint::builtin::FUTURE_PRELUDE_COLLISION;\n+use rustc_span::symbol::kw::Underscore;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n \n@@ -51,7 +53,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             |lint| {\n                 let sp = call_expr.span;\n                 let trait_name =\n-                    self.trait_path_or_bare_name(call_expr.hir_id, pick.item.container.id());\n+                    self.trait_path_or_bare_name(span, call_expr.hir_id, pick.item.container.id());\n \n                 let mut lint = lint.build(&format!(\n                     \"trait method `{}` will become ambiguous in Rust 2021\",\n@@ -147,7 +149,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx.struct_span_lint_hir(FUTURE_PRELUDE_COLLISION, expr_id, span, |lint| {\n             // \"type\" refers to either a type or, more likely, a trait from which\n             // the associated function or method is from.\n-            let trait_path = self.trait_path_or_bare_name(expr_id, pick.item.container.id());\n+            let trait_path = self.trait_path_or_bare_name(span, expr_id, pick.item.container.id());\n             let trait_generics = self.tcx.generics_of(pick.item.container.id());\n \n             let parameter_count = trait_generics.count() - (trait_generics.has_self as usize);\n@@ -183,27 +185,55 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         });\n     }\n \n-    fn trait_path_or_bare_name(&self, expr_hir_id: HirId, trait_def_id: DefId) -> String {\n-        self.trait_path(expr_hir_id, trait_def_id).unwrap_or_else(|| {\n+    fn trait_path_or_bare_name(\n+        &self,\n+        span: Span,\n+        expr_hir_id: HirId,\n+        trait_def_id: DefId,\n+    ) -> String {\n+        self.trait_path(span, expr_hir_id, trait_def_id).unwrap_or_else(|| {\n             let key = self.tcx.def_key(trait_def_id);\n             format!(\"{}\", key.disambiguated_data.data)\n         })\n     }\n \n-    fn trait_path(&self, expr_hir_id: HirId, trait_def_id: DefId) -> Option<String> {\n+    fn trait_path(&self, span: Span, expr_hir_id: HirId, trait_def_id: DefId) -> Option<String> {\n         let applicable_traits = self.tcx.in_scope_traits(expr_hir_id)?;\n         let applicable_trait = applicable_traits.iter().find(|t| t.def_id == trait_def_id)?;\n         if applicable_trait.import_ids.is_empty() {\n             // The trait was declared within the module, we only need to use its name.\n             return None;\n         }\n \n-        for &import_id in &applicable_trait.import_ids {\n-            let hir_id = self.tcx.hir().local_def_id_to_hir_id(import_id);\n-            let item = self.tcx.hir().expect_item(hir_id);\n-            debug!(?item, ?import_id, \"import_id\");\n+        let import_items: Vec<_> = applicable_trait\n+            .import_ids\n+            .iter()\n+            .map(|&import_id| {\n+                let hir_id = self.tcx.hir().local_def_id_to_hir_id(import_id);\n+                self.tcx.hir().expect_item(hir_id)\n+            })\n+            .collect();\n+\n+        // Find an identifier with which this trait was imported (note that `_` doesn't count).\n+        let any_id = import_items\n+            .iter()\n+            .filter_map(|item| if item.ident.name != Underscore { Some(item.ident) } else { None })\n+            .next();\n+        if let Some(any_id) = any_id {\n+            return Some(format!(\"{}\", any_id));\n         }\n \n-        return None;\n+        // All that is left is `_`! We need to use the full path. It doesn't matter which one we pick,\n+        // so just take the first one.\n+        match import_items[0].kind {\n+            ItemKind::Use(path, _) => {\n+                // FIXME: serialize path into something readable like a::b, there must be a fn for this\n+                debug!(\"no name for trait, found import of path: {:?}\", path);\n+                return None;\n+            }\n+            _ => {\n+                span_bug!(span, \"unexpected item kind, expected a use: {:?}\", import_items[0].kind);\n+            }\n+        }\n     }\n }"}]}