{"sha": "ee76be54861189275be483c3f4a72531dc7f7698", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNzZiZTU0ODYxMTg5Mjc1YmU0ODNjM2Y0YTcyNTMxZGM3Zjc2OTg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-03-28T13:07:25Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-03-30T09:19:11Z"}, "message": "Remove unnecessary `as usize`", "tree": {"sha": "888c45bb127498a176405320895899bbcd3179fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/888c45bb127498a176405320895899bbcd3179fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee76be54861189275be483c3f4a72531dc7f7698", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee76be54861189275be483c3f4a72531dc7f7698", "html_url": "https://github.com/rust-lang/rust/commit/ee76be54861189275be483c3f4a72531dc7f7698", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee76be54861189275be483c3f4a72531dc7f7698/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5825c72e730a12efdc0e2d60fb9d40f6f5ea771c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5825c72e730a12efdc0e2d60fb9d40f6f5ea771c", "html_url": "https://github.com/rust-lang/rust/commit/5825c72e730a12efdc0e2d60fb9d40f6f5ea771c"}], "stats": {"total": 152, "additions": 76, "deletions": 76}, "files": [{"sha": "99577b0d7e77569f2515d0b10bba365a090893e9", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=ee76be54861189275be483c3f4a72531dc7f7698", "patch": "@@ -191,17 +191,17 @@ fn blocks_for_bits(bits: usize) -> usize {\n     //\n     // Note that we can technically avoid this branch with the expression\n     // `(nbits + u32::BITS - 1) / 32::BITS`, but if nbits is almost usize::MAX this will overflow.\n-    if bits % u32::BITS as usize == 0 {\n-        bits / u32::BITS as usize\n+    if bits % u32::BITS == 0 {\n+        bits / u32::BITS\n     } else {\n-        bits / u32::BITS as usize + 1\n+        bits / u32::BITS + 1\n     }\n }\n \n /// Computes the bitmask for the final word of the vector\n fn mask_for_bits(bits: usize) -> u32 {\n     // Note especially that a perfect multiple of u32::BITS should mask all 1s.\n-    !0 >> (u32::BITS as usize - bits % u32::BITS as usize) % u32::BITS as usize\n+    !0 >> (u32::BITS - bits % u32::BITS) % u32::BITS\n }\n \n impl BitVec {\n@@ -239,7 +239,7 @@ impl BitVec {\n     /// An operation might screw up the unused bits in the last block of the\n     /// `BitVec`. As per (3), it's assumed to be all 0s. This method fixes it up.\n     fn fix_last_block(&mut self) {\n-        let extra_bits = self.len() % u32::BITS as usize;\n+        let extra_bits = self.len() % u32::BITS;\n         if extra_bits > 0 {\n             let mask = (1 << extra_bits) - 1;\n             let storage_len = self.storage.len();\n@@ -318,7 +318,7 @@ impl BitVec {\n     ///                     false, false, true, false]));\n     /// ```\n     pub fn from_bytes(bytes: &[u8]) -> BitVec {\n-        let len = bytes.len().checked_mul(u8::BITS as usize).expect(\"capacity overflow\");\n+        let len = bytes.len().checked_mul(u8::BITS).expect(\"capacity overflow\");\n         let mut bit_vec = BitVec::with_capacity(len);\n         let complete_words = bytes.len() / 4;\n         let extra_bytes = bytes.len() % 4;\n@@ -387,8 +387,8 @@ impl BitVec {\n         if i >= self.nbits {\n             return None;\n         }\n-        let w = i / u32::BITS as usize;\n-        let b = i % u32::BITS as usize;\n+        let w = i / u32::BITS;\n+        let b = i % u32::BITS;\n         self.storage.get(w).map(|&block|\n             (block & (1 << b)) != 0\n         )\n@@ -415,8 +415,8 @@ impl BitVec {\n                reason = \"panic semantics are likely to change in the future\")]\n     pub fn set(&mut self, i: usize, x: bool) {\n         assert!(i < self.nbits);\n-        let w = i / u32::BITS as usize;\n-        let b = i % u32::BITS as usize;\n+        let w = i / u32::BITS;\n+        let b = i % u32::BITS;\n         let flag = 1 << b;\n         let val = if x { self.storage[w] | flag }\n                   else { self.storage[w] & !flag };\n@@ -812,7 +812,7 @@ impl BitVec {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.storage.capacity().checked_mul(u32::BITS as usize).unwrap_or(usize::MAX)\n+        self.storage.capacity().checked_mul(u32::BITS).unwrap_or(usize::MAX)\n     }\n \n     /// Grows the `BitVec` in-place, adding `n` copies of `value` to the `BitVec`.\n@@ -843,7 +843,7 @@ impl BitVec {\n \n         // Correct the old tail word, setting or clearing formerly unused bits\n         let num_cur_blocks = blocks_for_bits(self.nbits);\n-        if self.nbits % u32::BITS as usize > 0 {\n+        if self.nbits % u32::BITS > 0 {\n             let mask = mask_for_bits(self.nbits);\n             if value {\n                 self.storage[num_cur_blocks - 1] |= !mask;\n@@ -893,7 +893,7 @@ impl BitVec {\n             // (3)\n             self.set(i, false);\n             self.nbits = i;\n-            if self.nbits % u32::BITS as usize == 0 {\n+            if self.nbits % u32::BITS == 0 {\n                 // (2)\n                 self.storage.pop();\n             }\n@@ -916,7 +916,7 @@ impl BitVec {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, elem: bool) {\n-        if self.nbits % u32::BITS as usize == 0 {\n+        if self.nbits % u32::BITS == 0 {\n             self.storage.push(0);\n         }\n         let insert_pos = self.nbits;\n@@ -1442,7 +1442,7 @@ impl BitSet {\n         // Truncate\n         let trunc_len = cmp::max(old_len - n, 1);\n         bit_vec.storage.truncate(trunc_len);\n-        bit_vec.nbits = trunc_len * u32::BITS as usize;\n+        bit_vec.nbits = trunc_len * u32::BITS;\n     }\n \n     /// Iterator over each u32 stored in the `BitSet`.\n@@ -1880,13 +1880,13 @@ impl<'a> Iterator for TwoBitPositions<'a> {\n     fn next(&mut self) -> Option<usize> {\n         while self.next_idx < self.set.bit_vec.len() ||\n               self.next_idx < self.other.bit_vec.len() {\n-            let bit_idx = self.next_idx % u32::BITS as usize;\n+            let bit_idx = self.next_idx % u32::BITS;\n             if bit_idx == 0 {\n                 let s_bit_vec = &self.set.bit_vec;\n                 let o_bit_vec = &self.other.bit_vec;\n                 // Merging the two words is a bit of an awkward dance since\n                 // one BitVec might be longer than the other\n-                let word_idx = self.next_idx / u32::BITS as usize;\n+                let word_idx = self.next_idx / u32::BITS;\n                 let w1 = if word_idx < s_bit_vec.storage.len() {\n                              s_bit_vec.storage[word_idx]\n                          } else { 0 };"}, {"sha": "ecf341a5ea6b8be4893de1912f38621f67885d9a", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=ee76be54861189275be483c3f4a72531dc7f7698", "patch": "@@ -83,7 +83,7 @@ pub trait CLike {\n fn bit<E:CLike>(e: &E) -> usize {\n     use core::usize;\n     let value = e.to_usize();\n-    assert!(value < usize::BITS as usize,\n+    assert!(value < usize::BITS,\n             \"EnumSet only supports up to {} variants.\", usize::BITS - 1);\n     1 << value\n }"}, {"sha": "ef2f4969d0cd6f55ee6257abe2a6ed4387307382", "filename": "src/libcollectionstest/bit/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibcollectionstest%2Fbit%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibcollectionstest%2Fbit%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fset.rs?ref=ee76be54861189275be483c3f4a72531dc7f7698", "patch": "@@ -408,7 +408,7 @@ mod bench {\n         let mut bit_vec = BitSet::new();\n         b.iter(|| {\n             for _ in 0..100 {\n-                bit_vec.insert((r.next_u32() as usize) % u32::BITS as usize);\n+                bit_vec.insert((r.next_u32() as usize) % u32::BITS);\n             }\n             black_box(&bit_vec);\n         });"}, {"sha": "de3c0586ab728f3ccd8e8215e06633f78683c663", "filename": "src/libcollectionstest/bit/vec.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fvec.rs?ref=ee76be54861189275be483c3f4a72531dc7f7698", "patch": "@@ -541,70 +541,70 @@ fn test_big_bit_vec_tests() {\n \n #[test]\n fn test_bit_vec_push_pop() {\n-    let mut s = BitVec::from_elem(5 * u32::BITS as usize - 2, false);\n-    assert_eq!(s.len(), 5 * u32::BITS as usize - 2);\n-    assert_eq!(s[5 * u32::BITS as usize - 3], false);\n+    let mut s = BitVec::from_elem(5 * u32::BITS - 2, false);\n+    assert_eq!(s.len(), 5 * u32::BITS - 2);\n+    assert_eq!(s[5 * u32::BITS - 3], false);\n     s.push(true);\n     s.push(true);\n-    assert_eq!(s[5 * u32::BITS as usize - 2], true);\n-    assert_eq!(s[5 * u32::BITS as usize - 1], true);\n+    assert_eq!(s[5 * u32::BITS - 2], true);\n+    assert_eq!(s[5 * u32::BITS - 1], true);\n     // Here the internal vector will need to be extended\n     s.push(false);\n-    assert_eq!(s[5 * u32::BITS as usize], false);\n+    assert_eq!(s[5 * u32::BITS], false);\n     s.push(false);\n-    assert_eq!(s[5 * u32::BITS as usize + 1], false);\n-    assert_eq!(s.len(), 5 * u32::BITS as usize + 2);\n+    assert_eq!(s[5 * u32::BITS + 1], false);\n+    assert_eq!(s.len(), 5 * u32::BITS + 2);\n     // Pop it all off\n     assert_eq!(s.pop(), Some(false));\n     assert_eq!(s.pop(), Some(false));\n     assert_eq!(s.pop(), Some(true));\n     assert_eq!(s.pop(), Some(true));\n-    assert_eq!(s.len(), 5 * u32::BITS as usize - 2);\n+    assert_eq!(s.len(), 5 * u32::BITS - 2);\n }\n \n #[test]\n fn test_bit_vec_truncate() {\n-    let mut s = BitVec::from_elem(5 * u32::BITS as usize, true);\n+    let mut s = BitVec::from_elem(5 * u32::BITS, true);\n \n-    assert_eq!(s, BitVec::from_elem(5 * u32::BITS as usize, true));\n-    assert_eq!(s.len(), 5 * u32::BITS as usize);\n-    s.truncate(4 * u32::BITS as usize);\n-    assert_eq!(s, BitVec::from_elem(4 * u32::BITS as usize, true));\n-    assert_eq!(s.len(), 4 * u32::BITS as usize);\n+    assert_eq!(s, BitVec::from_elem(5 * u32::BITS, true));\n+    assert_eq!(s.len(), 5 * u32::BITS);\n+    s.truncate(4 * u32::BITS);\n+    assert_eq!(s, BitVec::from_elem(4 * u32::BITS, true));\n+    assert_eq!(s.len(), 4 * u32::BITS);\n     // Truncating to a size > s.len() should be a noop\n-    s.truncate(5 * u32::BITS as usize);\n-    assert_eq!(s, BitVec::from_elem(4 * u32::BITS as usize, true));\n-    assert_eq!(s.len(), 4 * u32::BITS as usize);\n-    s.truncate(3 * u32::BITS as usize - 10);\n-    assert_eq!(s, BitVec::from_elem(3 * u32::BITS as usize - 10, true));\n-    assert_eq!(s.len(), 3 * u32::BITS as usize - 10);\n+    s.truncate(5 * u32::BITS);\n+    assert_eq!(s, BitVec::from_elem(4 * u32::BITS, true));\n+    assert_eq!(s.len(), 4 * u32::BITS);\n+    s.truncate(3 * u32::BITS - 10);\n+    assert_eq!(s, BitVec::from_elem(3 * u32::BITS - 10, true));\n+    assert_eq!(s.len(), 3 * u32::BITS - 10);\n     s.truncate(0);\n     assert_eq!(s, BitVec::from_elem(0, true));\n     assert_eq!(s.len(), 0);\n }\n \n #[test]\n fn test_bit_vec_reserve() {\n-    let mut s = BitVec::from_elem(5 * u32::BITS as usize, true);\n+    let mut s = BitVec::from_elem(5 * u32::BITS, true);\n     // Check capacity\n-    assert!(s.capacity() >= 5 * u32::BITS as usize);\n-    s.reserve(2 * u32::BITS as usize);\n-    assert!(s.capacity() >= 7 * u32::BITS as usize);\n-    s.reserve(7 * u32::BITS as usize);\n-    assert!(s.capacity() >= 12 * u32::BITS as usize);\n-    s.reserve_exact(7 * u32::BITS as usize);\n-    assert!(s.capacity() >= 12 * u32::BITS as usize);\n-    s.reserve(7 * u32::BITS as usize + 1);\n-    assert!(s.capacity() >= 12 * u32::BITS as usize + 1);\n+    assert!(s.capacity() >= 5 * u32::BITS);\n+    s.reserve(2 * u32::BITS);\n+    assert!(s.capacity() >= 7 * u32::BITS);\n+    s.reserve(7 * u32::BITS);\n+    assert!(s.capacity() >= 12 * u32::BITS);\n+    s.reserve_exact(7 * u32::BITS);\n+    assert!(s.capacity() >= 12 * u32::BITS);\n+    s.reserve(7 * u32::BITS + 1);\n+    assert!(s.capacity() >= 12 * u32::BITS + 1);\n     // Check that length hasn't changed\n-    assert_eq!(s.len(), 5 * u32::BITS as usize);\n+    assert_eq!(s.len(), 5 * u32::BITS);\n     s.push(true);\n     s.push(false);\n     s.push(true);\n-    assert_eq!(s[5 * u32::BITS as usize - 1], true);\n-    assert_eq!(s[5 * u32::BITS as usize - 0], true);\n-    assert_eq!(s[5 * u32::BITS as usize + 1], false);\n-    assert_eq!(s[5 * u32::BITS as usize + 2], true);\n+    assert_eq!(s[5 * u32::BITS - 1], true);\n+    assert_eq!(s[5 * u32::BITS - 0], true);\n+    assert_eq!(s[5 * u32::BITS + 1], false);\n+    assert_eq!(s[5 * u32::BITS + 2], true);\n }\n \n #[test]\n@@ -650,7 +650,7 @@ mod bench {\n         let mut bit_vec = 0 as usize;\n         b.iter(|| {\n             for _ in 0..100 {\n-                bit_vec |= 1 << ((r.next_u32() as usize) % u32::BITS as usize);\n+                bit_vec |= 1 << ((r.next_u32() as usize) % u32::BITS);\n             }\n             black_box(&bit_vec);\n         });\n@@ -683,10 +683,10 @@ mod bench {\n     #[bench]\n     fn bench_bit_set_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bit_vec = BitVec::from_elem(u32::BITS as usize, false);\n+        let mut bit_vec = BitVec::from_elem(u32::BITS, false);\n         b.iter(|| {\n             for _ in 0..100 {\n-                bit_vec.set((r.next_u32() as usize) % u32::BITS as usize, true);\n+                bit_vec.set((r.next_u32() as usize) % u32::BITS, true);\n             }\n             black_box(&bit_vec);\n         });\n@@ -703,7 +703,7 @@ mod bench {\n \n     #[bench]\n     fn bench_bit_vec_small_iter(b: &mut Bencher) {\n-        let bit_vec = BitVec::from_elem(u32::BITS as usize, false);\n+        let bit_vec = BitVec::from_elem(u32::BITS, false);\n         b.iter(|| {\n             let mut sum = 0;\n             for _ in 0..10 {"}, {"sha": "553e0c0dfe6e45c3cf792d70cd0768a80c0a8990", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=ee76be54861189275be483c3f4a72531dc7f7698", "patch": "@@ -194,7 +194,7 @@ mod impls {\n                 fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {\n                     // FIXME(#23542) Replace with type ascription.\n                     #![allow(trivial_casts)]\n-                    let newlen = data.len() * ::$ty::BYTES as usize;\n+                    let newlen = data.len() * ::$ty::BYTES;\n                     let ptr = data.as_ptr() as *const u8;\n                     state.write(unsafe { slice::from_raw_parts(ptr, newlen) })\n                 }"}, {"sha": "4cd56999cb3d54242a83418f4d28bbde34873bce", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=ee76be54861189275be483c3f4a72531dc7f7698", "patch": "@@ -195,7 +195,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                oper: O,\n                id_range: IdRange,\n                bits_per_id: usize) -> DataFlowContext<'a, 'tcx, O> {\n-        let words_per_id = (bits_per_id + usize::BITS as usize - 1) / usize::BITS as usize;\n+        let words_per_id = (bits_per_id + usize::BITS - 1) / usize::BITS;\n         let num_nodes = cfg.graph.all_nodes().len();\n \n         debug!(\"DataFlowContext::new(analysis_name: {}, id_range={:?}, \\\n@@ -367,7 +367,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         for (word_index, &word) in words.iter().enumerate() {\n             if word != 0 {\n-                let base_index = word_index * usize::BITS as usize;\n+                let base_index = word_index * usize::BITS;\n                 for offset in 0..usize::BITS {\n                     let bit = 1 << offset;\n                     if (word & bit) != 0 {\n@@ -601,8 +601,8 @@ fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n fn set_bit(words: &mut [usize], bit: usize) -> bool {\n     debug!(\"set_bit: words={} bit={}\",\n            mut_bits_to_string(words), bit_str(bit));\n-    let word = bit / usize::BITS as usize;\n-    let bit_in_word = bit % usize::BITS as usize;\n+    let word = bit / usize::BITS;\n+    let bit_in_word = bit % usize::BITS;\n     let bit_mask = 1 << bit_in_word;\n     debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, word);\n     let oldv = words[word];"}, {"sha": "e14a934d8dd1ddb73e197b5a9dc0460fd629741e", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=ee76be54861189275be483c3f4a72531dc7f7698", "patch": "@@ -726,28 +726,28 @@ pub trait Reader {\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_le_uint(&mut self) -> IoResult<usize> {\n-        self.read_le_uint_n(usize::BYTES as usize).map(|i| i as usize)\n+        self.read_le_uint_n(usize::BYTES).map(|i| i as usize)\n     }\n \n     /// Reads a little-endian integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_le_int(&mut self) -> IoResult<isize> {\n-        self.read_le_int_n(isize::BYTES as usize).map(|i| i as isize)\n+        self.read_le_int_n(isize::BYTES).map(|i| i as isize)\n     }\n \n     /// Reads a big-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_be_uint(&mut self) -> IoResult<usize> {\n-        self.read_be_uint_n(usize::BYTES as usize).map(|i| i as usize)\n+        self.read_be_uint_n(usize::BYTES).map(|i| i as usize)\n     }\n \n     /// Reads a big-endian integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_be_int(&mut self) -> IoResult<isize> {\n-        self.read_be_int_n(isize::BYTES as usize).map(|i| i as isize)\n+        self.read_be_int_n(isize::BYTES).map(|i| i as isize)\n     }\n \n     /// Reads a big-endian `u64`.\n@@ -1110,25 +1110,25 @@ pub trait Writer {\n     /// Write a little-endian usize (number of bytes depends on system).\n     #[inline]\n     fn write_le_uint(&mut self, n: usize) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, usize::BYTES as usize, |v| self.write_all(v))\n+        extensions::u64_to_le_bytes(n as u64, usize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian isize (number of bytes depends on system).\n     #[inline]\n     fn write_le_int(&mut self, n: isize) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, isize::BYTES as usize, |v| self.write_all(v))\n+        extensions::u64_to_le_bytes(n as u64, isize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian usize (number of bytes depends on system).\n     #[inline]\n     fn write_be_uint(&mut self, n: usize) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, usize::BYTES as usize, |v| self.write_all(v))\n+        extensions::u64_to_be_bytes(n as u64, usize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian isize (number of bytes depends on system).\n     #[inline]\n     fn write_be_int(&mut self, n: isize) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, isize::BYTES as usize, |v| self.write_all(v))\n+        extensions::u64_to_be_bytes(n as u64, isize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian u64 (8 bytes)."}, {"sha": "5ae508e46106a7f35fcbc431d90db5aba18a1e4b", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee76be54861189275be483c3f4a72531dc7f7698/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=ee76be54861189275be483c3f4a72531dc7f7698", "patch": "@@ -194,12 +194,12 @@ mod select {\n     #[repr(C)]\n     pub struct fd_set {\n         // FIXME: shouldn't this be a c_ulong?\n-        fds_bits: [libc::uintptr_t; (FD_SETSIZE / usize::BITS as usize)]\n+        fds_bits: [libc::uintptr_t; (FD_SETSIZE / usize::BITS)]\n     }\n \n     pub fn fd_set(set: &mut fd_set, fd: i32) {\n         let fd = fd as usize;\n-        set.fds_bits[fd / usize::BITS as usize] |= 1 << (fd % usize::BITS as usize);\n+        set.fds_bits[fd / usize::BITS] |= 1 << (fd % usize::BITS);\n     }\n }\n "}, {"sha": "e11270c94ca546dc980578b8c2eff4e987d92bc9", "filename": "src/test/run-pass/issue-13763.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee76be54861189275be483c3f4a72531dc7f7698/src%2Ftest%2Frun-pass%2Fissue-13763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee76be54861189275be483c3f4a72531dc7f7698/src%2Ftest%2Frun-pass%2Fissue-13763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13763.rs?ref=ee76be54861189275be483c3f4a72531dc7f7698", "patch": "@@ -14,7 +14,7 @@\n \n use std::u8;\n \n-const NUM: usize = u8::BITS as usize;\n+const NUM: usize = u8::BITS;\n \n struct MyStruct { nums: [usize; 8] }\n "}, {"sha": "eca7e62d67cbf4937f01045d56f6c05a097fb5af", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee76be54861189275be483c3f4a72531dc7f7698/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee76be54861189275be483c3f4a72531dc7f7698/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=ee76be54861189275be483c3f4a72531dc7f7698", "patch": "@@ -57,7 +57,7 @@ impl Drop for DropCounter {\n }\n \n pub fn main() {\n-    assert!(MAX_LEN <= std::usize::BITS as usize);\n+    assert!(MAX_LEN <= std::usize::BITS);\n     // len can't go above 64.\n     for len in 2..MAX_LEN {\n         for _ in 0..REPEATS {"}]}