{"sha": "1946265e1a1a32eb922846f314657a4aa7eb1d23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NDYyNjVlMWExYTMyZWI5MjI4NDZmMzE0NjU3YTRhYTdlYjFkMjM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-19T05:15:42Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-19T20:40:19Z"}, "message": "libstd: Change all uses of `&fn(A)->B` over to `|A|->B` in libstd", "tree": {"sha": "4b83f81bf1b265933a13605d9d35eab67a34ea8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b83f81bf1b265933a13605d9d35eab67a34ea8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1946265e1a1a32eb922846f314657a4aa7eb1d23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1946265e1a1a32eb922846f314657a4aa7eb1d23", "html_url": "https://github.com/rust-lang/rust/commit/1946265e1a1a32eb922846f314657a4aa7eb1d23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1946265e1a1a32eb922846f314657a4aa7eb1d23/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eef913b290f668b4f131ead5be65a1615616426b", "url": "https://api.github.com/repos/rust-lang/rust/commits/eef913b290f668b4f131ead5be65a1615616426b", "html_url": "https://github.com/rust-lang/rust/commit/eef913b290f668b4f131ead5be65a1615616426b"}], "stats": {"total": 506, "additions": 270, "deletions": 236}, "files": [{"sha": "c4641eff572699627fd7e850d5bcc032016c7a82", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -235,7 +235,7 @@ impl ToStrConsume for ~[Ascii] {\n \n impl IterBytes for Ascii {\n     #[inline]\n-    fn iter_bytes(&self, _lsb0: bool, f: &fn(buf: &[u8]) -> bool) -> bool {\n+    fn iter_bytes(&self, _lsb0: bool, f: |buf: &[u8]| -> bool) -> bool {\n         f([self.to_byte()])\n     }\n }"}, {"sha": "a052ae87a41c590e5527a26963f0db9d8829a0c1", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -43,7 +43,7 @@ pub fn capacity<T>(v: @[T]) -> uint {\n  *             onto the vector being constructed.\n  */\n #[inline]\n-pub fn build<A>(size: Option<uint>, builder: &fn(push: &fn(v: A))) -> @[A] {\n+pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> @[A] {\n     let mut vec = @[];\n     unsafe { raw::reserve(&mut vec, size.unwrap_or(4)); }\n     builder(|x| unsafe { raw::push(&mut vec, x) });\n@@ -68,7 +68,7 @@ pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n \n \n /// Apply a function to each element of a vector and return the results\n-pub fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n+pub fn map<T, U>(v: &[T], f: |x: &T| -> U) -> @[U] {\n     do build(Some(v.len())) |push| {\n         for elem in v.iter() {\n             push(f(elem));\n@@ -82,7 +82,7 @@ pub fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pub fn from_fn<T>(n_elts: uint, op: &fn(uint) -> T) -> @[T] {\n+pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> @[T] {\n     do build(Some(n_elts)) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }"}, {"sha": "ce0a66965962369c14a2c143e14da5eb4e7a95d0", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -58,7 +58,7 @@ use num::FromPrimitive;\n /// }\n /// ```\n #[inline]\n-pub fn all_values(blk: &fn(v: bool)) {\n+pub fn all_values(blk: |v: bool|) {\n     blk(true);\n     blk(false);\n }"}, {"sha": "a9c4d2cacde2ccb0af467f5dc57519bb17593858", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -117,7 +117,7 @@ impl CString {\n     /// # Failure\n     ///\n     /// Fails if the CString is null.\n-    pub fn with_ref<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+    pub fn with_ref<T>(&self, f: |*libc::c_char| -> T) -> T {\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(self.buf)\n     }\n@@ -127,7 +127,7 @@ impl CString {\n     /// # Failure\n     ///\n     /// Fails if the CString is null.\n-    pub fn with_mut_ref<T>(&mut self, f: &fn(*mut libc::c_char) -> T) -> T {\n+    pub fn with_mut_ref<T>(&mut self, f: |*mut libc::c_char| -> T) -> T {\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(unsafe { cast::transmute_mut_unsafe(self.buf) })\n     }\n@@ -223,13 +223,13 @@ pub trait ToCStr {\n     ///\n     /// Raises the `null_byte` condition if the receiver has an interior null.\n     #[inline]\n-    fn with_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n         self.to_c_str().with_ref(f)\n     }\n \n     /// Unsafe variant of `with_c_str()` that doesn't check for nulls.\n     #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n         self.to_c_str_unchecked().with_ref(f)\n     }\n }\n@@ -246,12 +246,12 @@ impl<'self> ToCStr for &'self str {\n     }\n \n     #[inline]\n-    fn with_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n         self.as_bytes().with_c_str(f)\n     }\n \n     #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n         self.as_bytes().with_c_str_unchecked(f)\n     }\n }\n@@ -282,17 +282,17 @@ impl<'self> ToCStr for &'self [u8] {\n         }\n     }\n \n-    fn with_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n         unsafe { with_c_str(*self, true, f) }\n     }\n \n-    unsafe fn with_c_str_unchecked<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n         with_c_str(*self, false, f)\n     }\n }\n \n // Unsafe function that handles possibly copying the &[u8] into a stack array.\n-unsafe fn with_c_str<T>(v: &[u8], checked: bool, f: &fn(*libc::c_char) -> T) -> T {\n+unsafe fn with_c_str<T>(v: &[u8], checked: bool, f: |*libc::c_char| -> T) -> T {\n     if v.len() < BUF_LEN {\n         let mut buf: [u8, .. BUF_LEN] = intrinsics::uninit();\n         vec::bytes::copy_memory(buf, v, v.len());\n@@ -357,7 +357,7 @@ impl<'self> Iterator<libc::c_char> for CStringIterator<'self> {\n /// is found, and the number of strings found is returned.\n pub unsafe fn from_c_multistring(buf: *libc::c_char,\n                                  count: Option<uint>,\n-                                 f: &fn(&CString)) -> uint {\n+                                 f: |&CString|) -> uint {\n \n     let mut curr_ptr: uint = buf as uint;\n     let mut ctr = 0;"}, {"sha": "54849a44f6d3b96cdbb3249e8bd47a5b4f7e0570", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -71,12 +71,12 @@ impl<T> Cell<T> {\n     }\n \n     /// Calls a closure with a reference to the value.\n-    pub fn with_ref<R>(&self, op: &fn(v: &T) -> R) -> R {\n+    pub fn with_ref<R>(&self, op: |v: &T| -> R) -> R {\n         do self.with_mut_ref |ptr| { op(ptr) }\n     }\n \n     /// Calls a closure with a mutable reference to the value.\n-    pub fn with_mut_ref<R>(&self, op: &fn(v: &mut T) -> R) -> R {\n+    pub fn with_mut_ref<R>(&self, op: |v: &mut T| -> R) -> R {\n         let mut v = Some(self.take());\n         do (|| {\n             op(v.get_mut_ref())"}, {"sha": "c5a4dd1631df99b6b40dc7868992634c0cb2d260", "filename": "src/libstd/char.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -241,7 +241,7 @@ static N_COUNT: uint = (V_COUNT * T_COUNT);\n static S_COUNT: uint = (L_COUNT * N_COUNT);\n \n // Decompose a precomposed Hangul syllable\n-fn decompose_hangul(s: char, f: &fn(char)) {\n+fn decompose_hangul(s: char, f: |char|) {\n     let si = s as uint - S_BASE;\n \n     let li = si / N_COUNT;\n@@ -259,7 +259,7 @@ fn decompose_hangul(s: char, f: &fn(char)) {\n }\n \n /// Returns the canonical decompostion of a character\n-pub fn decompose_canonical(c: char, f: &fn(char)) {\n+pub fn decompose_canonical(c: char, f: |char|) {\n     if (c as uint) < S_BASE || (c as uint) >= (S_BASE + S_COUNT) {\n         decompose::canonical(c, f);\n     } else {\n@@ -268,7 +268,7 @@ pub fn decompose_canonical(c: char, f: &fn(char)) {\n }\n \n /// Returns the compatibility decompostion of a character\n-pub fn decompose_compatible(c: char, f: &fn(char)) {\n+pub fn decompose_compatible(c: char, f: |char|) {\n     if (c as uint) < S_BASE || (c as uint) >= (S_BASE + S_COUNT) {\n         decompose::compatibility(c, f);\n     } else {\n@@ -285,7 +285,7 @@ pub fn decompose_compatible(c: char, f: &fn(char)) {\n /// - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n /// - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n ///\n-pub fn escape_unicode(c: char, f: &fn(char)) {\n+pub fn escape_unicode(c: char, f: |char|) {\n     // avoid calling str::to_str_radix because we don't really need to allocate\n     // here.\n     f('\\\\');\n@@ -316,7 +316,7 @@ pub fn escape_unicode(c: char, f: &fn(char)) {\n /// - Any other chars in the range [0x20,0x7e] are not escaped.\n /// - Any other chars are given hex unicode escapes; see `escape_unicode`.\n ///\n-pub fn escape_default(c: char, f: &fn(char)) {\n+pub fn escape_default(c: char, f: |char|) {\n     match c {\n         '\\t' => { f('\\\\'); f('t'); }\n         '\\r' => { f('\\\\'); f('r'); }\n@@ -367,8 +367,8 @@ pub trait Char {\n     fn is_digit_radix(&self, radix: uint) -> bool;\n     fn to_digit(&self, radix: uint) -> Option<uint>;\n     fn from_digit(num: uint, radix: uint) -> Option<char>;\n-    fn escape_unicode(&self, f: &fn(char));\n-    fn escape_default(&self, f: &fn(char));\n+    fn escape_unicode(&self, f: |char|);\n+    fn escape_default(&self, f: |char|);\n     fn len_utf8_bytes(&self) -> uint;\n \n     /// Encodes this character as utf-8 into the provided byte-buffer. The\n@@ -403,9 +403,9 @@ impl Char for char {\n \n     fn from_digit(num: uint, radix: uint) -> Option<char> { from_digit(num, radix) }\n \n-    fn escape_unicode(&self, f: &fn(char)) { escape_unicode(*self, f) }\n+    fn escape_unicode(&self, f: |char|) { escape_unicode(*self, f) }\n \n-    fn escape_default(&self, f: &fn(char)) { escape_default(*self, f) }\n+    fn escape_default(&self, f: |char|) { escape_default(*self, f) }\n \n     fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }\n "}, {"sha": "a1f850978656260a481c16423a3130981f433dc2", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -30,7 +30,8 @@ struct AnnihilateStats {\n }\n \n unsafe fn each_live_alloc(read_next_before: bool,\n-                          f: &fn(box: *mut raw::Box<()>, uniq: bool) -> bool) -> bool {\n+                          f: |box: *mut raw::Box<()>, uniq: bool| -> bool)\n+                          -> bool {\n     //! Walks the internal list of allocations\n \n     use managed;"}, {"sha": "56d5a8594012fd1b118a5cabe45f6b16fec2a51c", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -133,7 +133,7 @@ impl<T, U> Condition<T, U> {\n \n     /// Performs the same functionality as `raise`, except that when no handler\n     /// is found the `default` argument is called instead of failing the task.\n-    pub fn raise_default(&self, t: T, default: &fn() -> U) -> U {\n+    pub fn raise_default(&self, t: T, default: || -> U) -> U {\n         match local_data::pop(self.key) {\n             None => {\n                 debug!(\"Condition.raise: found no handler\");\n@@ -145,7 +145,7 @@ impl<T, U> Condition<T, U> {\n                     None => {}\n                     Some(hp) => local_data::set(self.key, hp)\n                 }\n-                let handle : &fn(T) -> U = unsafe {\n+                let handle : |T| -> U = unsafe {\n                     ::cast::transmute(handler.handle)\n                 };\n                 let u = handle(t);"}, {"sha": "d2874a6f7f578ea0fd06eeed5b4eaa083a7e0d7c", "filename": "src/libstd/either.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -38,7 +38,7 @@ impl<L, R> Either<L, R> {\n     /// `value` is `Right(R)` then `f_right` is applied to its contents, and the\n     /// result is returned.\n     #[inline]\n-    pub fn either<T>(&self, f_left: &fn(&L) -> T, f_right: &fn(&R) -> T) -> T {\n+    pub fn either<T>(&self, f_left: |&L| -> T, f_right: |&R| -> T) -> T {\n         match *self {\n             Left(ref l) => f_left(l),\n             Right(ref r) => f_right(r)"}, {"sha": "427690a4aa5899de8aeab2cae5288556334e37ea", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -931,8 +931,10 @@ impl<'self> Formatter<'self> {\n         }\n     }\n \n-    fn with_padding(&mut self, padding: uint,\n-                    default: parse::Alignment, f: &fn(&mut Formatter)) {\n+    fn with_padding(&mut self,\n+                    padding: uint,\n+                    default: parse::Alignment,\n+                    f: |&mut Formatter|) {\n         let align = match self.align {\n             parse::AlignUnknown => default,\n             parse::AlignLeft | parse::AlignRight => self.align"}, {"sha": "f15abff8316903c71ef86b071df199abae77cd0e", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -408,7 +408,7 @@ mod tests {\n     // Hash just the bytes of the slice, without length prefix\n     struct Bytes<'self>(&'self [u8]);\n     impl<'self> IterBytes for Bytes<'self> {\n-        fn iter_bytes(&self, _lsb0: bool, f: &fn(&[u8]) -> bool) -> bool {\n+        fn iter_bytes(&self, _lsb0: bool, f: |&[u8]| -> bool) -> bool {\n             f(**self)\n         }\n     }"}, {"sha": "2d3e6431b0cd7761ad5a5194059bf1655be40ae0", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -80,8 +80,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n     }\n \n     #[inline]\n-    fn bucket_sequence(&self, hash: uint,\n-                       op: &fn(uint) -> bool) -> bool {\n+    fn bucket_sequence(&self, hash: uint, op: |uint| -> bool) -> bool {\n         let start_idx = self.to_bucket(hash);\n         let len_buckets = self.buckets.len();\n         let mut idx = start_idx;\n@@ -360,8 +359,14 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Modify and return the value corresponding to the key in the map, or\n     /// insert and return a new value if it doesn't exist.\n-    pub fn mangle<'a,A>(&'a mut self, k: K, a: A, not_found: &fn(&K, A) -> V,\n-                        found: &fn(&K, &mut V, A)) -> &'a mut V {\n+    pub fn mangle<'a,\n+                  A>(\n+                  &'a mut self,\n+                  k: K,\n+                  a: A,\n+                  not_found: |&K, A| -> V,\n+                  found: |&K, &mut V, A|)\n+                  -> &'a mut V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n             // that we do not resize if this call to insert is\n@@ -395,16 +400,20 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n-    pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V)\n+    pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)\n                                -> &'a mut V {\n         self.mangle(k, (), |k,_a| f(k), |_k,_v,_a| ())\n     }\n \n     /// Insert a key-value pair into the map if the key is not already present.\n     /// Otherwise, modify the existing value for the key.\n     /// Returns the new or modified value for the key.\n-    pub fn insert_or_update_with<'a>(&'a mut self, k: K, v: V,\n-                                     f: &fn(&K, &mut V)) -> &'a mut V {\n+    pub fn insert_or_update_with<'a>(\n+                                 &'a mut self,\n+                                 k: K,\n+                                 v: V,\n+                                 f: |&K, &mut V|)\n+                                 -> &'a mut V {\n         self.mangle(k, v, |_k,a| a, |k,v,_a| f(k,v))\n     }\n \n@@ -446,12 +455,12 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     }\n \n     /// Visit all keys\n-    pub fn each_key(&self, blk: &fn(k: &K) -> bool) -> bool {\n+    pub fn each_key(&self, blk: |k: &K| -> bool) -> bool {\n         self.iter().advance(|(k, _)| blk(k))\n     }\n \n     /// Visit all values\n-    pub fn each_value<'a>(&'a self, blk: &fn(v: &'a V) -> bool) -> bool {\n+    pub fn each_value<'a>(&'a self, blk: |v: &'a V| -> bool) -> bool {\n         self.iter().advance(|(_, v)| blk(v))\n     }\n "}, {"sha": "5eb2e72e96b21efc03965f7191fae965a13f31e3", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -54,8 +54,7 @@ impl<'self, R: Reader> Iterator<u8> for ByteIterator<R> {\n     }\n }\n \n-pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n-                          f: &fn(v: &[u8]) -> T) -> T {\n+pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n     assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n@@ -88,8 +87,7 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n     }\n }\n \n-pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n-                           f: &fn(v: &[u8]) -> T) -> T {\n+pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n     assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),"}, {"sha": "930f58ef33f2759b7c0636ea5319630e3141aafc", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -75,7 +75,7 @@ pub struct File {\n     priv last_nread: int,\n }\n \n-fn io_raise<T>(f: &fn(io: &mut IoFactory) -> Result<T, IoError>) -> Option<T> {\n+fn io_raise<T>(f: |io: &mut IoFactory| -> Result<T, IoError>) -> Option<T> {\n     do with_local_io |io| {\n         match f(io) {\n             Ok(t) => Some(t),\n@@ -499,7 +499,7 @@ pub fn rmdir(path: &Path) {\n ///     use std::io::fs;\n ///\n ///     // one possible implementation of fs::walk_dir only visiting files\n-///     fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n+///     fn visit_dirs(dir: &Path, cb: |&Path|) {\n ///         if dir.is_dir() {\n ///             let contents = fs::readdir(dir).unwrap();\n ///             for entry in contents.iter() {"}, {"sha": "decdfb60bfbe51f40883bdfefda279d0694ea0e8", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -240,7 +240,7 @@ impl<'self> Buffer for BufReader<'self> {\n \n ///Calls a function with a MemWriter and returns\n ///the writer's stored vector.\n-pub fn with_mem_writer(writeFn:&fn(&mut MemWriter)) -> ~[u8] {\n+pub fn with_mem_writer(writeFn: |&mut MemWriter|) -> ~[u8] {\n     let mut writer = MemWriter::new();\n     writeFn(&mut writer);\n     writer.inner()"}, {"sha": "1d0fef48890714b178ff82f1669df95dad4624a6", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -394,7 +394,7 @@ condition! {\n \n /// Helper for wrapper calls where you want to\n /// ignore any io_errors that might be raised\n-pub fn ignore_io_error<T>(cb: &fn() -> T) -> T {\n+pub fn ignore_io_error<T>(cb: || -> T) -> T {\n     do io_error::cond.trap(|_| {\n         // just swallow the error.. downstream users\n         // who can make a decision based on a None result\n@@ -407,7 +407,7 @@ pub fn ignore_io_error<T>(cb: &fn() -> T) -> T {\n /// Helper for catching an I/O error and wrapping it in a Result object. The\n /// return result will be the last I/O error that happened or the result of the\n /// closure if no error occurred.\n-pub fn result<T>(cb: &fn() -> T) -> Result<T, IoError> {\n+pub fn result<T>(cb: || -> T) -> Result<T, IoError> {\n     let mut err = None;\n     let ret = io_error::cond.trap(|e| {\n         if err.is_none() {"}, {"sha": "abaeab609aaa02dc989eb9ad741d116e20b53e50", "filename": "src/libstd/io/native/file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Ffile.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -33,7 +33,7 @@ use vec;\n #[cfg(windows)] use ptr;\n #[cfg(windows)] use str;\n \n-fn keep_going(data: &[u8], f: &fn(*u8, uint) -> i64) -> i64 {\n+fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n     #[cfg(windows)] static eintr: int = 0; // doesn't matter\n     #[cfg(not(windows))] static eintr: int = libc::EINTR as int;\n "}, {"sha": "6aa3ae65fc9852a6dfc20fa8c4ad2619d7695e0f", "filename": "src/libstd/io/native/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -432,7 +432,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n }\n \n #[cfg(unix)]\n-fn with_argv<T>(prog: &str, args: &[~str], cb: &fn(**libc::c_char) -> T) -> T {\n+fn with_argv<T>(prog: &str, args: &[~str], cb: |**libc::c_char| -> T) -> T {\n     use vec;\n \n     // We can't directly convert `str`s into `*char`s, as someone needs to hold\n@@ -460,7 +460,7 @@ fn with_argv<T>(prog: &str, args: &[~str], cb: &fn(**libc::c_char) -> T) -> T {\n }\n \n #[cfg(unix)]\n-fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n+fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*c_void| -> T) -> T {\n     use vec;\n \n     // On posixy systems we can pass a char** for envp, which is a\n@@ -490,7 +490,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n }\n \n #[cfg(windows)]\n-fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n+fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*mut c_void| -> T) -> T {\n     // On win32 we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n@@ -514,7 +514,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n     }\n }\n \n-fn with_dirp<T>(d: Option<&Path>, cb: &fn(*libc::c_char) -> T) -> T {\n+fn with_dirp<T>(d: Option<&Path>, cb: |*libc::c_char| -> T) -> T {\n     match d {\n       Some(dir) => dir.with_c_str(|buf| cb(buf)),\n       None => cb(ptr::null())"}, {"sha": "9c63108beef3e5fec3da42865b83c6e8f2de82ef", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -81,7 +81,8 @@ impl<'self> Parser<'self> {\n     }\n \n     // Commit only if parser returns Some\n-    fn read_atomically<T>(&mut self, cb: &fn(&mut Parser) -> Option<T>) -> Option<T> {\n+    fn read_atomically<T>(&mut self, cb: |&mut Parser| -> Option<T>)\n+                       -> Option<T> {\n         let pos = self.pos;\n         let r = cb(self);\n         if r.is_none() {\n@@ -91,14 +92,16 @@ impl<'self> Parser<'self> {\n     }\n \n     // Commit only if parser read till EOF\n-    fn read_till_eof<T>(&mut self, cb: &fn(&mut Parser) -> Option<T>) -> Option<T> {\n+    fn read_till_eof<T>(&mut self, cb: |&mut Parser| -> Option<T>)\n+                     -> Option<T> {\n         do self.read_atomically |p| {\n             cb(p).filtered(|_| p.is_eof())\n         }\n     }\n \n     // Return result of first successful parser\n-    fn read_or<T>(&mut self, parsers: &[&fn(&mut Parser) -> Option<T>]) -> Option<T> {\n+    fn read_or<T>(&mut self, parsers: &[|&mut Parser| -> Option<T>])\n+               -> Option<T> {\n         for pf in parsers.iter() {\n             match self.read_atomically(|p: &mut Parser| (*pf)(p)) {\n                 Some(r) => return Some(r),\n@@ -109,12 +112,14 @@ impl<'self> Parser<'self> {\n     }\n \n     // Apply 3 parsers sequentially\n-    fn read_seq_3<A, B, C>(&mut self,\n-            pa: &fn(&mut Parser) -> Option<A>,\n-            pb: &fn(&mut Parser) -> Option<B>,\n-            pc: &fn(&mut Parser) -> Option<C>\n-        ) -> Option<(A, B, C)>\n-    {\n+    fn read_seq_3<A,\n+                  B,\n+                  C>(\n+                  &mut self,\n+                  pa: |&mut Parser| -> Option<A>,\n+                  pb: |&mut Parser| -> Option<B>,\n+                  pc: |&mut Parser| -> Option<C>)\n+                  -> Option<(A, B, C)> {\n         do self.read_atomically |p| {\n             let a = pa(p);\n             let b = if a.is_some() { pb(p) } else { None };"}, {"sha": "b8cdbfc25cb4cfb21f01107bb533e2ee92a4749a", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -74,7 +74,9 @@ pub struct UdpStream {\n }\n \n impl UdpStream {\n-    pub fn as_socket<T>(&mut self, f: &fn(&mut UdpSocket) -> T) -> T { f(&mut self.socket) }\n+    pub fn as_socket<T>(&mut self, f: |&mut UdpSocket| -> T) -> T {\n+        f(&mut self.socket)\n+    }\n \n     pub fn disconnect(self) -> UdpSocket { self.socket }\n }"}, {"sha": "1362d702f1c3a9c53454deae7214f34dd6229dfc", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -69,7 +69,7 @@ enum StdSource {\n     File(~RtioFileStream),\n }\n \n-fn src<T>(fd: libc::c_int, readable: bool, f: &fn(StdSource) -> T) -> T {\n+fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n     do with_local_io |io| {\n         let fd = unsafe { libc::dup(fd) };\n         match io.tty_open(fd, readable) {\n@@ -121,7 +121,7 @@ pub fn stderr() -> StdWriter {\n //          // io1 aliases io2\n //      }\n //  }\n-fn with_task_stdout(f: &fn(&mut Writer)) {\n+fn with_task_stdout(f: |&mut Writer|) {\n     use rt::local::Local;\n     use rt::task::Task;\n "}, {"sha": "f736b10cc4fc58d493c5d9b730444a50db731805", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -433,7 +433,7 @@ pub trait Iterator<A> {\n     /// range(0, 5).advance(|x| {print!(\"{} \", x); true});\n     /// ```\n     #[inline]\n-    fn advance(&mut self, f: &fn(A) -> bool) -> bool {\n+    fn advance(&mut self, f: |A| -> bool) -> bool {\n         loop {\n             match self.next() {\n                 Some(x) => {\n@@ -522,7 +522,7 @@ pub trait Iterator<A> {\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ```\n     #[inline]\n-    fn fold<B>(&mut self, init: B, f: &fn(B, A) -> B) -> B {\n+    fn fold<B>(&mut self, init: B, f: |B, A| -> B) -> B {\n         let mut accum = init;\n         loop {\n             match self.next() {\n@@ -558,7 +558,7 @@ pub trait Iterator<A> {\n     /// assert!(!a.iter().all(|&x| *x > 2));\n     /// ```\n     #[inline]\n-    fn all(&mut self, f: &fn(A) -> bool) -> bool {\n+    fn all(&mut self, f: |A| -> bool) -> bool {\n         for x in *self { if !f(x) { return false; } }\n         true\n     }\n@@ -575,14 +575,14 @@ pub trait Iterator<A> {\n     /// assert!(!it.any(|&x| *x == 3));\n     /// ```\n     #[inline]\n-    fn any(&mut self, f: &fn(A) -> bool) -> bool {\n+    fn any(&mut self, f: |A| -> bool) -> bool {\n         for x in *self { if f(x) { return true; } }\n         false\n     }\n \n     /// Return the first element satisfying the specified predicate\n     #[inline]\n-    fn find(&mut self, predicate: &fn(&A) -> bool) -> Option<A> {\n+    fn find(&mut self, predicate: |&A| -> bool) -> Option<A> {\n         for x in *self {\n             if predicate(&x) { return Some(x) }\n         }\n@@ -591,7 +591,7 @@ pub trait Iterator<A> {\n \n     /// Return the index of the first element satisfying the specified predicate\n     #[inline]\n-    fn position(&mut self, predicate: &fn(A) -> bool) -> Option<uint> {\n+    fn position(&mut self, predicate: |A| -> bool) -> Option<uint> {\n         let mut i = 0;\n         for x in *self {\n             if predicate(x) {\n@@ -604,7 +604,7 @@ pub trait Iterator<A> {\n \n     /// Count the number of elements satisfying the specified predicate\n     #[inline]\n-    fn count(&mut self, predicate: &fn(A) -> bool) -> uint {\n+    fn count(&mut self, predicate: |A| -> bool) -> uint {\n         let mut i = 0;\n         for x in *self {\n             if predicate(x) { i += 1 }\n@@ -622,7 +622,7 @@ pub trait Iterator<A> {\n     /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n-    fn max_by<B: Ord>(&mut self, f: &fn(&A) -> B) -> Option<A> {\n+    fn max_by<B: Ord>(&mut self, f: |&A| -> B) -> Option<A> {\n         self.fold(None, |max: Option<(A, B)>, x| {\n             let x_val = f(&x);\n             match max {\n@@ -646,7 +646,7 @@ pub trait Iterator<A> {\n     /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n-    fn min_by<B: Ord>(&mut self, f: &fn(&A) -> B) -> Option<A> {\n+    fn min_by<B: Ord>(&mut self, f: |&A| -> B) -> Option<A> {\n         self.fold(None, |min: Option<(A, B)>, x| {\n             let x_val = f(&x);\n             match min {\n@@ -729,7 +729,7 @@ pub trait ExactSize<A> : DoubleEndedIterator<A> {\n     ///\n     /// If no element matches, None is returned.\n     #[inline]\n-    fn rposition(&mut self, predicate: &fn(A) -> bool) -> Option<uint> {\n+    fn rposition(&mut self, predicate: |A| -> bool) -> Option<uint> {\n         let (lower, upper) = self.size_hint();\n         assert!(upper == Some(lower));\n         let mut i = lower;"}, {"sha": "083de15008a27f23c0d995f9680b4698567d43cd", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -177,7 +177,7 @@ pub fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n ///\n /// It is considered a runtime error to attempt to get a value which is already\n /// on loan via the `get_mut` method provided.\n-pub fn get<T: 'static, U>(key: Key<T>, f: &fn(Option<&T>) -> U) -> U {\n+pub fn get<T: 'static, U>(key: Key<T>, f: |Option<&T>| -> U) -> U {\n     get_with(key, ImmLoan, f)\n }\n \n@@ -188,7 +188,7 @@ pub fn get<T: 'static, U>(key: Key<T>, f: &fn(Option<&T>) -> U) -> U {\n /// It is considered a runtime error to attempt to get a value which is already\n /// on loan via this or the `get` methods. This is similar to how it's a runtime\n /// error to take two mutable loans on an `@mut` box.\n-pub fn get_mut<T: 'static, U>(key: Key<T>, f: &fn(Option<&mut T>) -> U) -> U {\n+pub fn get_mut<T: 'static, U>(key: Key<T>, f: |Option<&mut T>| -> U) -> U {\n     do get_with(key, MutLoan) |x| {\n         match x {\n             None => f(None),\n@@ -202,9 +202,12 @@ pub fn get_mut<T: 'static, U>(key: Key<T>, f: &fn(Option<&mut T>) -> U) -> U {\n     }\n }\n \n-fn get_with<T: 'static, U>(key: Key<T>,\n-                           state: LoanState,\n-                           f: &fn(Option<&T>) -> U) -> U {\n+fn get_with<T:'static,\n+            U>(\n+            key: Key<T>,\n+            state: LoanState,\n+            f: |Option<&T>| -> U)\n+            -> U {\n     // This function must be extremely careful. Because TLS can store owned\n     // values, and we must have some form of `get` function other than `pop`,\n     // this function has to give a `&` reference back to the caller.\n@@ -335,7 +338,7 @@ pub fn set<T: 'static>(key: Key<T>, data: T) {\n ///\n /// This function will have the same runtime errors as generated from `pop` and\n /// `set` (the key must not currently be on loan\n-pub fn modify<T: 'static>(key: Key<T>, f: &fn(Option<T>) -> Option<T>) {\n+pub fn modify<T: 'static>(key: Key<T>, f: |Option<T>| -> Option<T>) {\n     match f(pop(key)) {\n         Some(next) => { set(key, next); }\n         None => {}"}, {"sha": "9141e87bd722d20bac35218bae14fba6aa0e735c", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -415,7 +415,7 @@ impl FromStrRadix for $T {\n \n /// Convert to a string as a byte slice in a given base.\n #[inline]\n-pub fn to_str_bytes<U>(n: $T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n+pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n     // The radix can be as low as 2, so we need at least 64 characters for a\n     // base 2 number, and then we need another for a possible '-' character.\n     let mut buf = [0u8, ..65];"}, {"sha": "aeda3fa1cd193f71d62c6662c1a64a6be5443edc", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -108,7 +108,7 @@ pub trait Unsigned: Num {}\n /// ```\n ///\n pub trait Times {\n-    fn times(&self, it: &fn());\n+    fn times(&self, it: ||);\n }\n \n pub trait Integer: Num"}, {"sha": "5d713f1a622cc7e51179e7266f3ba14637ef5b9d", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -132,9 +132,19 @@ static NAN_BUF:          [u8, ..3] = ['N' as u8, 'a' as u8, 'N' as u8];\n  * # Failure\n  * - Fails if `radix` < 2 or `radix` > 36.\n  */\n-pub fn int_to_str_bytes_common<T:NumCast+Zero+Eq+Ord+Integer+\n-                                 Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n-        num: T, radix: uint, sign: SignFormat, f: &fn(u8)) {\n+pub fn int_to_str_bytes_common<T:NumCast\n+                                +Zero\n+                                +Eq\n+                                +Ord\n+                                +Integer\n+                                +Div<T,T>\n+                                +Neg<T>\n+                                +Rem<T,T>\n+                                +Mul<T,T>>(\n+                                num: T,\n+                                radix: uint,\n+                                sign: SignFormat,\n+                                f: |u8|) {\n     assert!(2 <= radix && radix <= 36);\n \n     let _0: T = Zero::zero();"}, {"sha": "1cc0c19150137caf7f6b48fee8dcbe6f2b5e23ca", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -85,7 +85,7 @@ impl num::Times for uint {\n     /// use with integer literals of inferred integer-type as\n     /// the self-value (eg. `do 100.times { ... }`).\n     ///\n-    fn times(&self, it: &fn()) {\n+    fn times(&self, it: ||) {\n         let mut i = *self;\n         while i > 0 {\n             it();"}, {"sha": "49f270369f72cbdff0a550ac59b4a57f09d32b9e", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -266,7 +266,7 @@ impl FromStrRadix for $T {\n \n /// Convert to a string as a byte slice in a given base.\n #[inline]\n-pub fn to_str_bytes<U>(n: $T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n+pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n     // The radix can be as low as 2, so we need at least 64 characters for a\n     // base 2 number.\n     let mut buf = [0u8, ..64];"}, {"sha": "c5a10c75640ec364f327b0367db471d50f87987d", "filename": "src/libstd/option.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -147,7 +147,7 @@ impl<T> Option<T> {\n \n     /// Returns the contained value or computes it from a closure\n     #[inline]\n-    pub fn unwrap_or_else(self, f: &fn() -> T) -> T {\n+    pub fn unwrap_or_else(self, f: || -> T) -> T {\n         match self {\n             Some(x) => x,\n             None => f()\n@@ -160,19 +160,19 @@ impl<T> Option<T> {\n \n     /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n     #[inline]\n-    pub fn map<U>(self, f: &fn(T) -> U) -> Option<U> {\n+    pub fn map<U>(self, f: |T| -> U) -> Option<U> {\n         match self { Some(x) => Some(f(x)), None => None }\n     }\n \n     /// Applies a function to the contained value or returns a default.\n     #[inline]\n-    pub fn map_default<U>(self, def: U, f: &fn(T) -> U) -> U {\n+    pub fn map_default<U>(self, def: U, f: |T| -> U) -> U {\n         match self { None => def, Some(t) => f(t) }\n     }\n \n     /// Apply a function to the contained value or do nothing.\n     /// Returns true if the contained value was mutated.\n-    pub fn mutate(&mut self, f: &fn(T) -> T) -> bool {\n+    pub fn mutate(&mut self, f: |T| -> T) -> bool {\n         if self.is_some() {\n             *self = Some(f(self.take_unwrap()));\n             true\n@@ -181,7 +181,7 @@ impl<T> Option<T> {\n \n     /// Apply a function to the contained value or set it to a default.\n     /// Returns true if the contained value was mutated, or false if set to the default.\n-    pub fn mutate_default(&mut self, def: T, f: &fn(T) -> T) -> bool {\n+    pub fn mutate_default(&mut self, def: T, f: |T| -> T) -> bool {\n         if self.is_some() {\n             *self = Some(f(self.take_unwrap()));\n             true\n@@ -235,7 +235,7 @@ impl<T> Option<T> {\n     /// Returns `None` if the option is `None`, otherwise calls `f` with the\n     /// wrapped value and returns the result.\n     #[inline]\n-    pub fn and_then<U>(self, f: &fn(T) -> Option<U>) -> Option<U> {\n+    pub fn and_then<U>(self, f: |T| -> Option<U>) -> Option<U> {\n         match self {\n             Some(x) => f(x),\n             None => None,\n@@ -254,7 +254,7 @@ impl<T> Option<T> {\n     /// Returns the option if it contains a value, otherwise calls `f` and\n     /// returns the result.\n     #[inline]\n-    pub fn or_else(self, f: &fn() -> Option<T>) -> Option<T> {\n+    pub fn or_else(self, f: || -> Option<T>) -> Option<T> {\n         match self {\n             Some(_) => self,\n             None => f(),\n@@ -273,7 +273,7 @@ impl<T> Option<T> {\n \n     /// Filters an optional value using a given function.\n     #[inline(always)]\n-    pub fn filtered(self, f: &fn(t: &T) -> bool) -> Option<T> {\n+    pub fn filtered(self, f: |t: &T| -> bool) -> Option<T> {\n         match self {\n             Some(x) => if(f(&x)) {Some(x)} else {None},\n             None => None\n@@ -282,7 +282,7 @@ impl<T> Option<T> {\n \n     /// Applies a function zero or more times until the result is `None`.\n     #[inline]\n-    pub fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n+    pub fn while_some(self, blk: |v: T| -> Option<T>) {\n         let mut opt = self;\n         while opt.is_some() {\n             opt = blk(opt.unwrap());"}, {"sha": "3692bc303fb616bd747ddcaafaaddf2c506c6b72", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -94,7 +94,7 @@ pub mod win32 {\n     use os::TMPBUF_SZ;\n     use libc::types::os::arch::extra::DWORD;\n \n-    pub fn fill_utf16_buf_and_decode(f: &fn(*mut u16, DWORD) -> DWORD)\n+    pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD)\n         -> Option<~str> {\n \n         unsafe {\n@@ -125,7 +125,7 @@ pub mod win32 {\n         }\n     }\n \n-    pub fn as_utf16_p<T>(s: &str, f: &fn(*u16) -> T) -> T {\n+    pub fn as_utf16_p<T>(s: &str, f: |*u16| -> T) -> T {\n         let mut t = s.to_utf16();\n         // Null terminate before passing on.\n         t.push(0u16);\n@@ -137,7 +137,7 @@ pub mod win32 {\n Accessing environment variables is not generally threadsafe.\n Serialize access through a global lock.\n */\n-fn with_env_lock<T>(f: &fn() -> T) -> T {\n+fn with_env_lock<T>(f: || -> T) -> T {\n     use unstable::mutex::{Mutex, MUTEX_INIT};\n     use unstable::finally::Finally;\n "}, {"sha": "6f152fa2a411559ed0464b6052095dc5dc108d44", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -559,7 +559,7 @@ impl<'self, P: GenericPath> Display<'self, P> {\n     /// If the path is not UTF-8, invalid sequences will be replaced with the\n     /// unicode replacement char. This involves allocation.\n     #[inline]\n-    pub fn with_str<T>(&self, f: &fn(&str) -> T) -> T {\n+    pub fn with_str<T>(&self, f: |&str| -> T) -> T {\n         let opt = if self.filename { self.path.filename_str() }\n                   else { self.path.as_str() };\n         match opt {"}, {"sha": "86f1e7f6e86ae42547da9f579b1262802c2c99f6", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -87,7 +87,7 @@ impl ToCStr for Path {\n \n impl IterBytes for Path {\n     #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: &fn(buf: &[u8]) -> bool) -> bool {\n+    fn iter_bytes(&self, lsb0: bool, f: |buf: &[u8]| -> bool) -> bool {\n         self.repr.iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "d5bc6b85424f0893bf583b4975790664d018d45e", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -112,7 +112,7 @@ impl ToCStr for Path {\n \n impl IterBytes for Path {\n     #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: &fn(&[u8]) -> bool) -> bool {\n+    fn iter_bytes(&self, lsb0: bool, f: |&[u8]| -> bool) -> bool {\n         self.repr.iter_bytes(lsb0, f)\n     }\n }\n@@ -970,7 +970,8 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n     }\n     return None;\n \n-    fn parse_two_comps<'a>(mut path: &'a str, f: &fn(char)->bool) -> Option<(uint, uint)> {\n+    fn parse_two_comps<'a>(mut path: &'a str, f: |char| -> bool)\n+                       -> Option<(uint, uint)> {\n         let idx_a = match path.find(|x| f(x)) {\n             None => return None,\n             Some(x) => x"}, {"sha": "887f7f2e9a6310ea4743c691235c11478d0df664", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -56,7 +56,7 @@ impl<T> Clone for *mut T {\n \n /// Return the first offset `i` such that `f(buf[i]) == true`.\n #[inline]\n-pub unsafe fn position<T>(buf: *T, f: &fn(&T) -> bool) -> uint {\n+pub unsafe fn position<T>(buf: *T, f: |&T| -> bool) -> uint {\n     let mut i = 0;\n     loop {\n         if f(&(*offset(buf, i as int))) { return i; }\n@@ -195,7 +195,7 @@ pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n \n   SAFETY NOTE: Pointer-arithmetic. Dragons be here.\n */\n-pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: &fn(*T)) {\n+pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n     debug!(\"array_each_with_len: before iterate\");\n     if (arr as uint == 0) {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n@@ -217,7 +217,7 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: &fn(*T)) {\n   pointer array. Barely less-dodgy Pointer Arithmetic.\n   Dragons be here.\n */\n-pub unsafe fn array_each<T>(arr: **T, cb: &fn(*T)) {\n+pub unsafe fn array_each<T>(arr: **T, cb: |*T|) {\n     if (arr as uint == 0) {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n     }"}, {"sha": "9e83afa819c18571a3fbdbd8a63fc1d54c6930fc", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -203,7 +203,7 @@ impl<T> RcMut<T> {\n impl<T> RcMut<T> {\n     /// Fails if there is already a mutable borrow of the box\n     #[inline]\n-    pub fn with_borrow<U>(&self, f: &fn(&T) -> U) -> U {\n+    pub fn with_borrow<U>(&self, f: |&T| -> U) -> U {\n         unsafe {\n             assert!((*self.ptr).borrow != Mutable);\n             let previous = (*self.ptr).borrow;\n@@ -216,7 +216,7 @@ impl<T> RcMut<T> {\n \n     /// Fails if there is already a mutable or immutable borrow of the box\n     #[inline]\n-    pub fn with_mut_borrow<U>(&self, f: &fn(&mut T) -> U) -> U {\n+    pub fn with_mut_borrow<U>(&self, f: |&mut T| -> U) -> U {\n         unsafe {\n             assert_eq!((*self.ptr).borrow, Nothing);\n             (*self.ptr).borrow = Mutable;"}, {"sha": "d0a696491761460fdd35399c7aa248f000f5d825", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -28,7 +28,7 @@ use unstable::raw;\n  * then build a MovePtrAdaptor wrapped around your struct.\n  */\n pub trait MovePtr {\n-    fn move_ptr(&mut self, adjustment: &fn(*c_void) -> *c_void);\n+    fn move_ptr(&mut self, adjustment: |*c_void| -> *c_void);\n     fn push_ptr(&mut self);\n     fn pop_ptr(&mut self);\n }"}, {"sha": "33e80d7fcaeec4d843999731bad20b6a30cb78a5", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -116,7 +116,7 @@ pub fn ReprVisitor<'a>(ptr: *c_void,\n \n impl<'self> MovePtr for ReprVisitor<'self> {\n     #[inline]\n-    fn move_ptr(&mut self, adjustment: &fn(*c_void) -> *c_void) {\n+    fn move_ptr(&mut self, adjustment: |*c_void| -> *c_void) {\n         self.ptr = adjustment(self.ptr);\n     }\n     fn push_ptr(&mut self) {\n@@ -131,7 +131,7 @@ impl<'self> ReprVisitor<'self> {\n     // Various helpers for the TyVisitor impl\n \n     #[inline]\n-    pub fn get<T>(&mut self, f: &fn(&mut ReprVisitor, &T)) -> bool {\n+    pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T|) -> bool {\n         unsafe {\n             f(self, transmute::<*c_void,&T>(self.ptr));\n         }"}, {"sha": "97daf8d7e60df5dca24ad7cdd1f9df56bbaaa1db", "filename": "src/libstd/result.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -143,7 +143,7 @@ impl<T, E: ToStr> Result<T, E> {\n     ///         parse_bytes(buf)\n     ///     }\n     #[inline]\n-    pub fn map<U>(self, op: &fn(T) -> U) -> Result<U,E> {\n+    pub fn map<U>(self, op: |T| -> U) -> Result<U,E> {\n         match self {\n           Ok(t) => Ok(op(t)),\n           Err(e) => Err(e)\n@@ -156,7 +156,7 @@ impl<T, E: ToStr> Result<T, E> {\n     /// This function can be used to pass through a successful result while handling\n     /// an error.\n     #[inline]\n-    pub fn map_err<F>(self, op: &fn(E) -> F) -> Result<T,F> {\n+    pub fn map_err<F>(self, op: |E| -> F) -> Result<T,F> {\n         match self {\n           Ok(t) => Ok(t),\n           Err(e) => Err(op(e))\n@@ -208,7 +208,7 @@ impl<T, E: ToStr> Result<T, E> {\n     ///\n     /// This function can be used for control flow based on result values\n     #[inline]\n-    pub fn and_then<U>(self, op: &fn(T) -> Result<U, E>) -> Result<U, E> {\n+    pub fn and_then<U>(self, op: |T| -> Result<U, E>) -> Result<U, E> {\n         match self {\n             Ok(t) => op(t),\n             Err(e) => Err(e),\n@@ -228,7 +228,7 @@ impl<T, E: ToStr> Result<T, E> {\n     ///\n     /// This function can be used for control flow based on result values\n     #[inline]\n-    pub fn or_else<F>(self, op: &fn(E) -> Result<T, F>) -> Result<T, F> {\n+    pub fn or_else<F>(self, op: |E| -> Result<T, F>) -> Result<T, F> {\n         match self {\n             Ok(t) => Ok(t),\n             Err(e) => op(e),\n@@ -378,12 +378,14 @@ pub fn collect<T, E, Iter: Iterator<Result<T, E>>>(mut iterator: Iter)\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, the folded value is returned.\n #[inline]\n-pub fn fold<T, V, E,\n+pub fn fold<T,\n+            V,\n+            E,\n             Iter: Iterator<Result<T, E>>>(\n             mut iterator: Iter,\n             mut init: V,\n-            f: &fn(V, T) -> V)\n-         -> Result<V, E> {\n+            f: |V, T| -> V)\n+            -> Result<V, E> {\n     for t in iterator {\n         match t {\n             Ok(v) => init = f(init, v),\n@@ -399,9 +401,7 @@ pub fn fold<T, V, E,\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, a simple `Ok(())` is returned.\n #[inline]\n-pub fn fold_<T, E, Iter: Iterator<Result<T, E>>>(\n-             iterator: Iter)\n-          -> Result<(), E> {\n+pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n     fold(iterator, (), |_, _| ())\n }\n "}, {"sha": "a173be64356702b00290d14392a6bb4d740805c4", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -107,9 +107,8 @@ mod imp {\n         })\n     }\n \n-    fn with_lock<T>(f: &fn() -> T) -> T {\n+    fn with_lock<T>(f: || -> T) -> T {\n         static mut lock: Mutex = MUTEX_INIT;\n-\n         do (|| {\n             unsafe {\n                 lock.lock();"}, {"sha": "2c1c5d84be15469d7d2ee4ea5bfe253bb10d8291", "filename": "src/libstd/rt/basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbasic.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -170,7 +170,7 @@ impl EventLoop for BasicLoop {\n         ~BasicRemote::new(self.messages.clone(), id) as ~RemoteCallback\n     }\n \n-    fn io<'a>(&'a mut self, f: &fn(&'a mut IoFactory)) {\n+    fn io<'a>(&'a mut self, f: |&'a mut IoFactory|) {\n         f(self.io)\n     }\n }"}, {"sha": "d1f69ada301cb9255a56586dba2a326bdc38b911", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -40,7 +40,7 @@ fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {\n     }\n }\n \n-fn swap_task_borrow_list(f: &fn(~[BorrowRecord]) -> ~[BorrowRecord]) {\n+fn swap_task_borrow_list(f: |~[BorrowRecord]| -> ~[BorrowRecord]) {\n     let borrows = match try_take_task_borrow_list() {\n         Some(l) => l,\n         None => ~[]"}, {"sha": "987b32c084674653cfff00c8403d576c982c398e", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -79,8 +79,10 @@ fn version(crate_map: &CrateMap) -> i32 {\n     }\n }\n \n-fn do_iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry),\n-                            visited: &mut HashSet<*CrateMap<'a>>) {\n+fn do_iter_crate_map<'a>(\n+                     crate_map: &'a CrateMap<'a>,\n+                     f: |&ModEntry|,\n+                     visited: &mut HashSet<*CrateMap<'a>>) {\n     if visited.insert(crate_map as *CrateMap) {\n         match version(crate_map) {\n             2 => {\n@@ -98,7 +100,7 @@ fn do_iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry),\n }\n \n /// Iterates recursively over `crate_map` and all child crate maps\n-pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry)) {\n+pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: |&ModEntry|) {\n     // XXX: use random numbers as keys from the OS-level RNG when there is a nice\n     //        way to do this\n     let mut v: HashSet<*CrateMap<'a>> = HashSet::with_capacity_and_keys(0, 0, 32);"}, {"sha": "fa4746a6bb77f6088e5afc6c00758c796ffe5d0e", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -369,7 +369,7 @@ impl BlockedTask {\n \n // So that KillHandle can be hashed in the taskgroup bookkeeping code.\n impl IterBytes for KillHandle {\n-    fn iter_bytes(&self, lsb0: bool, f: &fn(buf: &[u8]) -> bool) -> bool {\n+    fn iter_bytes(&self, lsb0: bool, f: |buf: &[u8]| -> bool) -> bool {\n         self.data.iter_bytes(lsb0, f)\n     }\n }\n@@ -525,9 +525,8 @@ impl KillHandle {\n         // NB: Takes a pthread mutex -- 'blk' not allowed to reschedule.\n         #[inline]\n         fn add_lazy_tombstone(parent: &mut KillHandle,\n-                              blk: &fn(Option<proc() -> bool>)\n-                              -> proc() -> bool) {\n-\n+                              blk: |Option<proc() -> bool>| -> proc() -> bool)\n+                              {\n             let inner: &mut KillHandleInner = unsafe { &mut *parent.get() };\n             unsafe {\n                 do inner.graveyard_lock.lock {"}, {"sha": "d47dae96283a6fbfa1ea52a378713371bce69dc7", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -18,7 +18,7 @@ pub trait Local {\n     fn put(value: ~Self);\n     fn take() -> ~Self;\n     fn exists(unused_value: Option<Self>) -> bool;\n-    fn borrow<T>(f: &fn(&mut Self) -> T) -> T;\n+    fn borrow<T>(f: |&mut Self| -> T) -> T;\n     unsafe fn unsafe_take() -> ~Self;\n     unsafe fn unsafe_borrow() -> *mut Self;\n     unsafe fn try_unsafe_borrow() -> Option<*mut Self>;\n@@ -30,7 +30,7 @@ impl Local for Task {\n     #[inline]\n     fn take() -> ~Task { unsafe { local_ptr::take() } }\n     fn exists(_: Option<Task>) -> bool { local_ptr::exists() }\n-    fn borrow<T>(f: &fn(&mut Task) -> T) -> T {\n+    fn borrow<T>(f: |&mut Task| -> T) -> T {\n         let mut res: Option<T> = None;\n         let res_ptr: *mut Option<T> = &mut res;\n         unsafe {\n@@ -78,7 +78,7 @@ impl Local for Scheduler {\n             }\n         }\n     }\n-    fn borrow<T>(f: &fn(&mut Scheduler) -> T) -> T {\n+    fn borrow<T>(f: |&mut Scheduler| -> T) -> T {\n         do Local::borrow |task: &mut Task| {\n             match task.sched {\n                 Some(~ref mut task) => {"}, {"sha": "862ecd6499a5011bcc7546905b6b480d5352cbd1", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -103,7 +103,7 @@ pub fn exists() -> bool {\n /// # Safety note\n ///\n /// Does not validate the pointer type.\n-pub unsafe fn borrow<T>(f: &fn(&mut T)) {\n+pub unsafe fn borrow<T>(f: |&mut T|) {\n     let mut value = take();\n \n     // XXX: Need a different abstraction from 'finally' here to avoid unsafety"}, {"sha": "f83932f9ffa28ed571108a347e0bb74c5d3fd50c", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -36,7 +36,7 @@ pub trait EventLoop {\n \n     /// The asynchronous I/O services. Not all event loops may provide one\n     // FIXME(#9382) this is an awful interface\n-    fn io<'a>(&'a mut self, f: &fn(&'a mut IoFactory));\n+    fn io<'a>(&'a mut self, f: |&'a mut IoFactory|);\n }\n \n pub trait RemoteCallback {\n@@ -75,7 +75,7 @@ pub enum CloseBehavior {\n     CloseAsynchronously,\n }\n \n-pub fn with_local_io<T>(f: &fn(&mut IoFactory) -> Option<T>) -> Option<T> {\n+pub fn with_local_io<T>(f: |&mut IoFactory| -> Option<T>) -> Option<T> {\n     use rt::sched::Scheduler;\n     use rt::local::Local;\n     use io::native;"}, {"sha": "e317b76b24d0e2d9bf96aebd649695aee35abc2b", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -556,7 +556,7 @@ impl Scheduler {\n \n     pub fn change_task_context(mut ~self,\n                                next_task: ~Task,\n-                               f: &fn(&mut Scheduler, ~Task)) {\n+                               f: |&mut Scheduler, ~Task|) {\n         // The current task is grabbed from TLS, not taken as an input.\n         // Doing an unsafe_take to avoid writing back a null pointer -\n         // We're going to call `put` later to do that.\n@@ -568,8 +568,8 @@ impl Scheduler {\n \n         // These transmutes do something fishy with a closure.\n         let f_fake_region = unsafe {\n-            transmute::<&fn(&mut Scheduler, ~Task),\n-                        &fn(&mut Scheduler, ~Task)>(f)\n+            transmute::<|&mut Scheduler, ~Task|,\n+                        |&mut Scheduler, ~Task|>(f)\n         };\n         let f_opaque = ClosureConverter::from_fn(f_fake_region);\n \n@@ -678,7 +678,7 @@ impl Scheduler {\n     /// in order to prevent that fn from performing further scheduling operations.\n     /// Doing further scheduling could easily result in infinite recursion.\n     pub fn deschedule_running_task_and_then(mut ~self,\n-                                            f: &fn(&mut Scheduler, BlockedTask)) {\n+                                            f: |&mut Scheduler, BlockedTask|) {\n         // Trickier - we need to get the scheduler task out of self\n         // and use it as the destination.\n         let stask = self.sched_task.take_unwrap();\n@@ -687,7 +687,7 @@ impl Scheduler {\n     }\n \n     pub fn switch_running_tasks_and_then(~self, next_task: ~Task,\n-                                         f: &fn(&mut Scheduler, BlockedTask)) {\n+                                         f: |&mut Scheduler, BlockedTask|) {\n         // This is where we convert the BlockedTask-taking closure into one\n         // that takes just a Task, and is aware of the block-or-killed protocol.\n         do self.change_task_context(next_task) |sched, task| {\n@@ -829,18 +829,18 @@ impl CleanupJob {\n     }\n }\n \n-// XXX: Some hacks to put a &fn in Scheduler without borrowck\n+// XXX: Some hacks to put a || closure in Scheduler without borrowck\n // complaining\n type UnsafeTaskReceiver = raw::Closure;\n trait ClosureConverter {\n-    fn from_fn(&fn(&mut Scheduler, ~Task)) -> Self;\n-    fn to_fn(self) -> &fn(&mut Scheduler, ~Task);\n+    fn from_fn(|&mut Scheduler, ~Task|) -> Self;\n+    fn to_fn(self) -> |&mut Scheduler, ~Task|;\n }\n impl ClosureConverter for UnsafeTaskReceiver {\n-    fn from_fn(f: &fn(&mut Scheduler, ~Task)) -> UnsafeTaskReceiver {\n+    fn from_fn(f: |&mut Scheduler, ~Task|) -> UnsafeTaskReceiver {\n         unsafe { transmute(f) }\n     }\n-    fn to_fn(self) -> &fn(&mut Scheduler, ~Task) { unsafe { transmute(self) } }\n+    fn to_fn(self) -> |&mut Scheduler, ~Task| { unsafe { transmute(self) } }\n }\n \n // On unix, we read randomness straight from /dev/urandom, but the"}, {"sha": "3fe555de56c9e2c8c750182f04a279274ed24ac0", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -282,7 +282,7 @@ impl Task {\n         }\n     }\n \n-    pub fn run(&mut self, f: &fn()) {\n+    pub fn run(&mut self, f: ||) {\n         rtdebug!(\"run called on task: {}\", borrow::to_uint(self));\n \n         // The only try/catch block in the world. Attempt to run the task's\n@@ -494,7 +494,7 @@ impl Coroutine {\n static UNWIND_TOKEN: uintptr_t = 839147;\n \n impl Unwinder {\n-    pub fn try(&mut self, f: &fn()) {\n+    pub fn try(&mut self, f: ||) {\n         use unstable::raw::Closure;\n \n         unsafe {\n@@ -512,7 +512,7 @@ impl Unwinder {\n                     code: transmute(code),\n                     env: transmute(env),\n                 };\n-                let closure: &fn() = transmute(closure);\n+                let closure: || = transmute(closure);\n                 closure();\n             }\n         }"}, {"sha": "c567fd0a8b312307af65cb07be6c3e3a6864a445", "filename": "src/libstd/str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -925,7 +925,7 @@ pub fn is_utf16(v: &[u16]) -> bool {\n /// # Failures\n ///\n /// * Fails on invalid utf-16 data\n-pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n+pub fn utf16_chars(v: &[u16], f: |char|) {\n     let len = v.len();\n     let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n@@ -1762,7 +1762,7 @@ pub trait StrSlice<'self> {\n     /// Work with the byte buffer and length of a slice.\n     ///\n     /// The buffer does not have a null terminator.\n-    fn as_imm_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T;\n+    fn as_imm_buf<T>(&self, f: |*u8, uint| -> T) -> T;\n }\n \n impl<'self> StrSlice<'self> for &'self str {\n@@ -2268,7 +2268,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     #[inline]\n-    fn as_imm_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T {\n+    fn as_imm_buf<T>(&self, f: |*u8, uint| -> T) -> T {\n         let v: &[u8] = unsafe { cast::transmute(*self) };\n         v.as_imm_buf(f)\n     }\n@@ -2355,7 +2355,7 @@ pub trait OwnedStr {\n     ///\n     /// The caller must make sure any mutations to this buffer keep the string\n     /// valid UTF-8!\n-    fn as_mut_buf<T>(&mut self, f: &fn(*mut u8, uint) -> T) -> T;\n+    fn as_mut_buf<T>(&mut self, f: |*mut u8, uint| -> T) -> T;\n }\n \n impl OwnedStr for ~str {\n@@ -2456,7 +2456,7 @@ impl OwnedStr for ~str {\n     }\n \n     #[inline]\n-    fn as_mut_buf<T>(&mut self, f: &fn(*mut u8, uint) -> T) -> T {\n+    fn as_mut_buf<T>(&mut self, f: |*mut u8, uint| -> T) -> T {\n         unsafe {\n             raw::as_owned_vec(self).as_mut_buf(f)\n         }"}, {"sha": "f9b918d6d1215544df7dec43e9eeaea7abfb9b9b", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -554,7 +554,7 @@ pub fn try<T:Send>(f: proc() -> T) -> Result<T, ~Any> {\n /* Lifecycle functions */\n \n /// Read the name of the current task.\n-pub fn with_task_name<U>(blk: &fn(Option<&str>) -> U) -> U {\n+pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n     use rt::task::Task;\n \n     if in_green_task_context() {\n@@ -605,7 +605,7 @@ pub fn failing() -> bool {\n  * }\n  * ```\n  */\n-pub fn unkillable<U>(f: &fn() -> U) -> U {\n+pub fn unkillable<U>(f: || -> U) -> U {\n     use rt::task::Task;\n \n     unsafe {\n@@ -640,7 +640,7 @@ pub fn unkillable<U>(f: &fn() -> U) -> U {\n  *    // Task is unkillable again\n  * }\n  */\n-pub fn rekillable<U>(f: &fn() -> U) -> U {\n+pub fn rekillable<U>(f: || -> U) -> U {\n     use rt::task::Task;\n \n     unsafe {\n@@ -1201,7 +1201,7 @@ fn test_spawn_sched_blocking() {\n }\n \n #[cfg(test)]\n-fn avoid_copying_the_body(spawnfn: &fn(v: proc())) {\n+fn avoid_copying_the_body(spawnfn: |v: proc()|) {\n     let (p, ch) = stream::<uint>();\n \n     let x = ~1;"}, {"sha": "66a2e8cc5e0d449265bd46dfc93fc3784086d428", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -164,15 +164,17 @@ struct AncestorList(Option<Exclusive<AncestorNode>>);\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline]\n-fn access_group<U>(x: &TaskGroupArc, blk: &fn(TaskGroupInner) -> U) -> U {\n+fn access_group<U>(x: &TaskGroupArc, blk: |TaskGroupInner| -> U) -> U {\n     unsafe {\n         x.with(blk)\n     }\n }\n \n #[inline]\n-fn access_ancestors<U>(x: &Exclusive<AncestorNode>,\n-                       blk: &fn(x: &mut AncestorNode) -> U) -> U {\n+fn access_ancestors<U>(\n+                    x: &Exclusive<AncestorNode>,\n+                    blk: |x: &mut AncestorNode| -> U)\n+                    -> U {\n     unsafe {\n         x.with(blk)\n     }\n@@ -197,17 +199,17 @@ fn incr_generation(_ancestors: &AncestorList) -> uint { 0 }\n //     is NOT called on the block that forward_blk broke on!).\n // (3) As a bonus, coalesces away all 'dead' taskgroup nodes in the list.\n fn each_ancestor(list:        &mut AncestorList,\n-                 bail_blk:    &fn(TaskGroupInner),\n-                 forward_blk: &fn(TaskGroupInner) -> bool)\n-              -> bool {\n+                 bail_blk:    |TaskGroupInner|,\n+                 forward_blk: |TaskGroupInner| -> bool)\n+                 -> bool {\n     // \"Kickoff\" call - there was no last generation.\n     return !coalesce(list, bail_blk, forward_blk, uint::max_value);\n \n     // Recursively iterates, and coalesces afterwards if needed. Returns\n     // whether or not unwinding is needed (i.e., !successful iteration).\n     fn coalesce(list:            &mut AncestorList,\n-                bail_blk:        &fn(TaskGroupInner),\n-                forward_blk:     &fn(TaskGroupInner) -> bool,\n+                bail_blk:        |TaskGroupInner|,\n+                forward_blk:     |TaskGroupInner| -> bool,\n                 last_generation: uint) -> bool {\n         let (coalesce_this, early_break) =\n             iterate(list, bail_blk, forward_blk, last_generation);\n@@ -229,8 +231,8 @@ fn each_ancestor(list:        &mut AncestorList,\n     //     True if the supplied block did 'break', here or in any recursive\n     //     calls. If so, must call the unwinder on all previous nodes.\n     fn iterate(ancestors:       &mut AncestorList,\n-               bail_blk:        &fn(TaskGroupInner),\n-               forward_blk:     &fn(TaskGroupInner) -> bool,\n+               bail_blk:        |TaskGroupInner|,\n+               forward_blk:     |TaskGroupInner| -> bool,\n                last_generation: uint)\n             -> (Option<AncestorList>, bool) {\n         // At each step of iteration, three booleans are at play which govern\n@@ -457,7 +459,7 @@ impl RuntimeGlue {\n         };\n     }\n \n-    fn with_task_handle_and_failing(blk: &fn(&KillHandle, bool)) {\n+    fn with_task_handle_and_failing(blk: |&KillHandle, bool|) {\n         assert!(in_green_task_context());\n         unsafe {\n             // Can't use safe borrow, because the taskgroup destructor needs to\n@@ -467,7 +469,7 @@ impl RuntimeGlue {\n         }\n     }\n \n-    fn with_my_taskgroup<U>(blk: &fn(&Taskgroup) -> U) -> U {\n+    fn with_my_taskgroup<U>(blk: |&Taskgroup| -> U) -> U {\n         assert!(in_green_task_context());\n         unsafe {\n             // Can't use safe borrow, because creating new hashmaps for the\n@@ -545,7 +547,7 @@ fn enlist_many(child: &KillHandle, child_arc: &TaskGroupArc,\n     };\n     if result {\n         // Unwinding function in case any ancestral enlisting fails\n-        let bail: &fn(TaskGroupInner) = |tg| { leave_taskgroup(tg, child, false) };\n+        let bail: |TaskGroupInner| = |tg| { leave_taskgroup(tg, child, false) };\n         // Attempt to join every ancestor group.\n         result = do each_ancestor(ancestors, bail) |ancestor_tg| {\n             // Enlist as a descendant, not as an actual member."}, {"sha": "f60d8641aca12716c2d60e22bfd6f664396a6052", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -107,43 +107,43 @@ impl<T> TrieMap<T> {\n \n     /// Visit all key-value pairs in reverse order\n     #[inline]\n-    pub fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+    pub fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n         self.root.each_reverse(f)\n     }\n \n     /// Visit all key-value pairs in order\n     #[inline]\n-    pub fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+    pub fn each<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n         self.root.each(f)\n     }\n \n     /// Visit all keys in order\n     #[inline]\n-    pub fn each_key(&self, f: &fn(&uint) -> bool) -> bool {\n+    pub fn each_key(&self, f: |&uint| -> bool) -> bool {\n         self.each(|k, _| f(k))\n     }\n \n     /// Visit all values in order\n     #[inline]\n-    pub fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) -> bool {\n+    pub fn each_value<'a>(&'a self, f: |&'a T| -> bool) -> bool {\n         self.each(|_, v| f(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n     #[inline]\n-    pub fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n+    pub fn mutate_values(&mut self, f: |&uint, &mut T| -> bool) -> bool {\n         self.root.mutate_values(f)\n     }\n \n     /// Visit all keys in reverse order\n     #[inline]\n-    pub fn each_key_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n+    pub fn each_key_reverse(&self, f: |&uint| -> bool) -> bool {\n         self.each_reverse(|k, _| f(k))\n     }\n \n     /// Visit all values in reverse order\n     #[inline]\n-    pub fn each_value_reverse(&self, f: &fn(&T) -> bool) -> bool {\n+    pub fn each_value_reverse(&self, f: |&T| -> bool) -> bool {\n         self.each_reverse(|_, v| f(v))\n     }\n \n@@ -266,11 +266,11 @@ impl TrieSet {\n \n     /// Visit all values in order\n     #[inline]\n-    pub fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n+    pub fn each(&self, f: |&uint| -> bool) -> bool { self.map.each_key(f) }\n \n     /// Visit all values in reverse order\n     #[inline]\n-    pub fn each_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n+    pub fn each_reverse(&self, f: |&uint| -> bool) -> bool {\n         self.map.each_key_reverse(f)\n     }\n \n@@ -328,7 +328,7 @@ impl<T> TrieNode<T> {\n }\n \n impl<T> TrieNode<T> {\n-    fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+    fn each<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n         for elt in self.children.iter() {\n             match *elt {\n                 Internal(ref x) => if !x.each(|i,t| f(i,t)) { return false },\n@@ -339,7 +339,7 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n-    fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+    fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n         for elt in self.children.rev_iter() {\n             match *elt {\n                 Internal(ref x) => if !x.each_reverse(|i,t| f(i,t)) { return false },\n@@ -350,7 +350,7 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n-    fn mutate_values<'a>(&'a mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n+    fn mutate_values<'a>(&'a mut self, f: |&uint, &mut T| -> bool) -> bool {\n         for child in self.children.mut_iter() {\n             match *child {\n                 Internal(ref mut x) => if !x.mutate_values(|i,t| f(i,t)) {"}, {"sha": "a8f56228dcb69060212980df284f54e7aa180313", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -3619,15 +3619,15 @@ pub mod decompose {\n         ('\\U0001d185', '\\U0001d189', 230), ('\\U0001d18a', '\\U0001d18b', 220),\n         ('\\U0001d1aa', '\\U0001d1ad', 230), ('\\U0001d242', '\\U0001d244', 230)\n     ];\n-    pub fn canonical(c: char, i: &fn(char)) { d(c, i, false); }\n+    pub fn canonical(c: char, i: |char|) { d(c, i, false); }\n \n-    pub fn compatibility(c: char, i: &fn(char)) { d(c, i, true); }\n+    pub fn compatibility(c: char, i: |char|) { d(c, i, true); }\n \n     pub fn canonical_combining_class(c: char) -> u8 {\n         bsearch_range_value_table(c, combining_class_table)\n     }\n \n-    fn d(c: char, i: &fn(char), k: bool) {\n+    fn d(c: char, i: |char|, k: bool) {\n         use iter::Iterator;\n         if c <= '\\x7f' { i(c); return; }\n "}, {"sha": "cdfbf8c0049911cc2d6d2ff9f0f66ee71c620821", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -153,10 +153,9 @@ pub mod dl {\n         dlopen(ptr::null(), Lazy as libc::c_int)\n     }\n \n-    pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n+    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {\n         use unstable::mutex::{Mutex, MUTEX_INIT};\n         static mut lock: Mutex = MUTEX_INIT;\n-\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n             // sequence. `atomically` asserts that we don't do anything that\n@@ -225,7 +224,7 @@ pub mod dl {\n         handle\n     }\n \n-    pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n+    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {\n         unsafe {\n             do atomically {\n                 SetLastError(0);"}, {"sha": "78f1c3655ad6e779bd5889ed160ae6885896c5dc", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -28,13 +28,13 @@ use ops::Drop;\n #[cfg(test)] use task::{failing, spawn};\n \n pub trait Finally<T> {\n-    fn finally(&self, dtor: &fn()) -> T;\n+    fn finally(&self, dtor: ||) -> T;\n }\n \n macro_rules! finally_fn {\n     ($fnty:ty) => {\n         impl<T> Finally<T> for $fnty {\n-            fn finally(&self, dtor: &fn()) -> T {\n+            fn finally(&self, dtor: ||) -> T {\n                 let _d = Finallyalizer {\n                     dtor: dtor\n                 };\n@@ -45,7 +45,7 @@ macro_rules! finally_fn {\n }\n \n impl<'self,T> Finally<T> for &'self fn() -> T {\n-    fn finally(&self, dtor: &fn()) -> T {\n+    fn finally(&self, dtor: ||) -> T {\n         let _d = Finallyalizer {\n             dtor: dtor\n         };\n@@ -95,7 +95,7 @@ fn test_fail() {\n \n #[test]\n fn test_retval() {\n-    let closure: &fn() -> int = || 10;\n+    let closure: || -> int = || 10;\n     let i = do closure.finally { };\n     assert_eq!(i, 10);\n }"}, {"sha": "4ad4656af7bf2a418d9ffbd12f803abe95678cf8", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -73,7 +73,7 @@ mod tests {\n     fn synthesize_closure() {\n         unsafe {\n             let x = 10;\n-            let f: &fn(int) -> int = |y| x + y;\n+            let f: |int| -> int = |y| x + y;\n \n             assert_eq!(f(20), 30);\n \n@@ -87,7 +87,7 @@ mod tests {\n                 env: environment\n             };\n \n-            let new_f: &fn(int) -> int = cast::transmute(new_closure);\n+            let new_f: |int| -> int = cast::transmute(new_closure);\n             assert_eq!(new_f(20), 30);\n         }\n     }"}, {"sha": "ae4b5d4c6aa37d433705b81a183c44832e90f555", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -296,7 +296,7 @@ impl<T> Drop for UnsafeArc<T>{\n  * synchronization whatsoever. It only makes sense to use for CPU-local issues.\n  */\n // FIXME(#8140) should not be pub\n-pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n+pub unsafe fn atomically<U>(f: || -> U) -> U {\n     use rt::task::{Task, GreenTask, SchedTask};\n     use rt::local::Local;\n \n@@ -340,7 +340,7 @@ impl LittleLock {\n         }\n     }\n \n-    pub unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n+    pub unsafe fn lock<T>(&self, f: || -> T) -> T {\n         let this = cast::transmute_mut(self);\n         do atomically {\n             this.l.lock();\n@@ -352,7 +352,7 @@ impl LittleLock {\n         }\n     }\n \n-    pub unsafe fn try_lock<T>(&self, f: &fn() -> T) -> Option<T> {\n+    pub unsafe fn try_lock<T>(&self, f: || -> T) -> Option<T> {\n         let this = cast::transmute_mut(self);\n         do atomically {\n             if this.l.trylock() {\n@@ -372,7 +372,7 @@ impl LittleLock {\n         this.l.signal();\n     }\n \n-    pub unsafe fn lock_and_wait(&self, f: &fn() -> bool) {\n+    pub unsafe fn lock_and_wait(&self, f: || -> bool) {\n         let this = cast::transmute_mut(self);\n         do atomically {\n             this.l.lock();\n@@ -433,7 +433,7 @@ impl<T:Send> Exclusive<T> {\n     // accessing the provided condition variable) are prohibited while inside\n     // the Exclusive. Supporting that is a work in progress.\n     #[inline]\n-    pub unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n+    pub unsafe fn with<U>(&self, f: |x: &mut T| -> U) -> U {\n         let rec = self.x.get();\n         do (*rec).lock.lock {\n             if (*rec).failed {\n@@ -447,14 +447,14 @@ impl<T:Send> Exclusive<T> {\n     }\n \n     #[inline]\n-    pub unsafe fn with_imm<U>(&self, f: &fn(x: &T) -> U) -> U {\n+    pub unsafe fn with_imm<U>(&self, f: |x: &T| -> U) -> U {\n         do self.with |x| {\n             f(cast::transmute_immut(x))\n         }\n     }\n \n     #[inline]\n-    pub unsafe fn hold_and_signal(&self, f: &fn(x: &mut T)) {\n+    pub unsafe fn hold_and_signal(&self, f: |x: &mut T|) {\n         let rec = self.x.get();\n         do (*rec).lock.lock {\n             if (*rec).failed {\n@@ -468,7 +468,7 @@ impl<T:Send> Exclusive<T> {\n     }\n \n     #[inline]\n-    pub unsafe fn hold_and_wait(&self, f: &fn(x: &T) -> bool) {\n+    pub unsafe fn hold_and_wait(&self, f: |x: &T| -> bool) {\n         let rec = self.x.get();\n         do (*rec).lock.lock_and_wait {\n             if (*rec).failed {"}, {"sha": "2bd6a00ed4a0e3e7c9aa9013173a4d110d2017a6", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1946265e1a1a32eb922846f314657a4aa7eb1d23/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=1946265e1a1a32eb922846f314657a4aa7eb1d23", "patch": "@@ -132,7 +132,7 @@ use util;\n  * Creates an owned vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pub fn from_fn<T>(n_elts: uint, op: &fn(uint) -> T) -> ~[T] {\n+pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n         let p = raw::to_mut_ptr(v);\n@@ -211,7 +211,7 @@ pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n  *             onto the vector being constructed.\n  */\n #[inline]\n-pub fn build<A>(size: Option<uint>, builder: &fn(push: &fn(v: A))) -> ~[A] {\n+pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> ~[A] {\n     let mut vec = with_capacity(size.unwrap_or(4));\n     builder(|x| vec.push(x));\n     vec\n@@ -338,7 +338,7 @@ pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n  * Apply a function to each element of a vector and return a concatenation\n  * of each result vector\n  */\n-pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n+pub fn flat_map<T, U>(v: &[T], f: |t: &T| -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n     for elem in v.iter() { result.push_all_move(f(elem)); }\n     result\n@@ -946,7 +946,7 @@ pub trait ImmutableVector<'self, T> {\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector\n      */\n-    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n+    fn flat_map<U>(&self, f: |t: &T| -> ~[U]) -> ~[U];\n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     unsafe fn unsafe_ref(&self, index: uint) -> *T;\n@@ -961,20 +961,20 @@ pub trait ImmutableVector<'self, T> {\n      * Returns the index where the comparator returned `Equal`, or `None` if\n      * not found.\n      */\n-    fn bsearch(&self, f: &fn(&T) -> Ordering) -> Option<uint>;\n+    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n \n     /// Deprecated, use iterators where possible\n     /// (`self.iter().map(f)`). Apply a function to each element\n     /// of a vector and return the results.\n-    fn map<U>(&self, &fn(t: &T) -> U) -> ~[U];\n+    fn map<U>(&self, |t: &T| -> U) -> ~[U];\n \n     /**\n      * Work with the buffer of a vector.\n      *\n      * Allows for unsafe manipulation of vector contents, which is useful for\n      * foreign interop.\n      */\n-    fn as_imm_buf<U>(&self, f: &fn(*T, uint) -> U) -> U;\n+    fn as_imm_buf<U>(&self, f: |*T, uint| -> U) -> U;\n }\n \n impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n@@ -1104,7 +1104,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     }\n \n     #[inline]\n-    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n+    fn flat_map<U>(&self, f: |t: &T| -> ~[U]) -> ~[U] {\n         flat_map(*self, f)\n     }\n \n@@ -1113,7 +1113,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         self.repr().data.offset(index as int)\n     }\n \n-    fn bsearch(&self, f: &fn(&T) -> Ordering) -> Option<uint> {\n+    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n         let mut base : uint = 0;\n         let mut lim : uint = self.len();\n \n@@ -1132,12 +1132,12 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         return None;\n     }\n \n-    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] {\n+    fn map<U>(&self, f: |t: &T| -> U) -> ~[U] {\n         self.iter().map(f).collect()\n     }\n \n     #[inline]\n-    fn as_imm_buf<U>(&self, f: &fn(*T, uint) -> U) -> U {\n+    fn as_imm_buf<U>(&self, f: |*T, uint| -> U) -> U {\n         let s = self.repr();\n         f(s.data, s.len)\n     }\n@@ -1212,7 +1212,7 @@ pub trait ImmutableCopyableVector<T> {\n      * Partitions the vector into those that satisfies the predicate, and\n      * those that do not.\n      */\n-    fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n+    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]);\n     /// Returns the element at the given index, without doing bounds checking.\n     unsafe fn unsafe_get(&self, elem: uint) -> T;\n \n@@ -1223,7 +1223,7 @@ pub trait ImmutableCopyableVector<T> {\n \n impl<'self,T:Clone> ImmutableCopyableVector<T> for &'self [T] {\n     #[inline]\n-    fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n+    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]) {\n         let mut lefts  = ~[];\n         let mut rights = ~[];\n \n@@ -1370,12 +1370,12 @@ pub trait OwnedVector<T> {\n     /**\n      * Like `filter()`, but in place.  Preserves order of `v`.  Linear time.\n      */\n-    fn retain(&mut self, f: &fn(t: &T) -> bool);\n+    fn retain(&mut self, f: |t: &T| -> bool);\n     /**\n      * Partitions the vector into those that satisfies the predicate, and\n      * those that do not.\n      */\n-    fn partition(self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n+    fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]);\n \n     /**\n      * Expands a vector in place, initializing the new elements to the result of\n@@ -1389,7 +1389,7 @@ pub trait OwnedVector<T> {\n      * * init_op - A function to call to retreive each appended element's\n      *             value\n      */\n-    fn grow_fn(&mut self, n: uint, op: &fn(uint) -> T);\n+    fn grow_fn(&mut self, n: uint, op: |uint| -> T);\n }\n \n impl<T> OwnedVector<T> for ~[T] {\n@@ -1646,7 +1646,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         unsafe { raw::set_len(self, newlen); }\n     }\n \n-    fn retain(&mut self, f: &fn(t: &T) -> bool) {\n+    fn retain(&mut self, f: |t: &T| -> bool) {\n         let len = self.len();\n         let mut deleted: uint = 0;\n \n@@ -1664,7 +1664,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    fn partition(self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n+    fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]) {\n         let mut lefts  = ~[];\n         let mut rights = ~[];\n \n@@ -1678,7 +1678,7 @@ impl<T> OwnedVector<T> for ~[T] {\n \n         (lefts, rights)\n     }\n-    fn grow_fn(&mut self, n: uint, op: &fn(uint) -> T) {\n+    fn grow_fn(&mut self, n: uint, op: |uint| -> T) {\n         let new_len = self.len() + n;\n         self.reserve_at_least(new_len);\n         let mut i: uint = 0u;\n@@ -1919,7 +1919,7 @@ pub trait MutableVector<'self, T> {\n     unsafe fn unsafe_set(self, index: uint, val: T);\n \n     /// Similar to `as_imm_buf` but passing a `*mut T`\n-    fn as_mut_buf<U>(self, f: &fn(*mut T, uint) -> U) -> U;\n+    fn as_mut_buf<U>(self, f: |*mut T, uint| -> U) -> U;\n }\n \n impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n@@ -2016,7 +2016,7 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     }\n \n     #[inline]\n-    fn as_mut_buf<U>(self, f: &fn(*mut T, uint) -> U) -> U {\n+    fn as_mut_buf<U>(self, f: |*mut T, uint| -> U) -> U {\n         let Slice{ data, len } = self.repr();\n         f(data as *mut T, len)\n     }\n@@ -2107,9 +2107,8 @@ pub mod raw {\n      * not bytes).\n      */\n     #[inline]\n-    pub unsafe fn buf_as_slice<T,U>(p: *T,\n-                                    len: uint,\n-                                    f: &fn(v: &[T]) -> U) -> U {\n+    pub unsafe fn buf_as_slice<T,U>(p: *T, len: uint, f: |v: &[T]| -> U)\n+                               -> U {\n         f(cast::transmute(Slice {\n             data: p,\n             len: len\n@@ -2121,9 +2120,12 @@ pub mod raw {\n      * not bytes).\n      */\n     #[inline]\n-    pub unsafe fn mut_buf_as_slice<T,U>(p: *mut T,\n-                                        len: uint,\n-                                        f: &fn(v: &mut [T]) -> U) -> U {\n+    pub unsafe fn mut_buf_as_slice<T,\n+                                   U>(\n+                                   p: *mut T,\n+                                   len: uint,\n+                                   f: |v: &mut [T]| -> U)\n+                                   -> U {\n         f(cast::transmute(Slice {\n             data: p as *T,\n             len: len"}]}