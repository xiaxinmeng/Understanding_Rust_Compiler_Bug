{"sha": "9ed0bf9f2bd63933785fb8a380c177d2d70e88ec", "node_id": "C_kwDOAAsO6NoAKDllZDBiZjlmMmJkNjM5MzM3ODVmYjhhMzgwYzE3N2QyZDcwZTg4ZWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-18T10:16:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-18T10:16:58Z"}, "message": "Auto merge of #99223 - saethlin:panicless-split-mut, r=Mark-Simulacrum\n\nRearrange slice::split_mut to remove bounds check\n\nCloses https://github.com/rust-lang/rust/issues/86313\n\nTurns out that all we need to do here is reorder the bounds checks to convince LLVM that all the bounds checks can be removed. It seems like LLVM just fails to propagate the original length information past the first bounds check and into the second one. With this implementation it doesn't need to, each check can be proven inbounds based on the one immediately previous.\n\nI've gradually convinced myself that this implementation is unambiguously better based on the above logic, but maybe this is still deserving of a codegen test?\n\nAlso the mentioned borrowck limitation no longer seems to exist.", "tree": {"sha": "bfb57073698c842ec8dcf94a021e2b3c77f59afd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfb57073698c842ec8dcf94a021e2b3c77f59afd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ed0bf9f2bd63933785fb8a380c177d2d70e88ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ed0bf9f2bd63933785fb8a380c177d2d70e88ec", "html_url": "https://github.com/rust-lang/rust/commit/9ed0bf9f2bd63933785fb8a380c177d2d70e88ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ed0bf9f2bd63933785fb8a380c177d2d70e88ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "880416180b0a9ee1141c07d4d17667edb77daebd", "url": "https://api.github.com/repos/rust-lang/rust/commits/880416180b0a9ee1141c07d4d17667edb77daebd", "html_url": "https://github.com/rust-lang/rust/commit/880416180b0a9ee1141c07d4d17667edb77daebd"}, {"sha": "c9373903e759c96f2ab8ba2a78c6799b5d92b105", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9373903e759c96f2ab8ba2a78c6799b5d92b105", "html_url": "https://github.com/rust-lang/rust/commit/c9373903e759c96f2ab8ba2a78c6799b5d92b105"}], "stats": {"total": 19, "additions": 9, "deletions": 10}, "files": [{"sha": "a1889e3d21cb88481f3a6231149a8d52bf6296eb", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9ed0bf9f2bd63933785fb8a380c177d2d70e88ec/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed0bf9f2bd63933785fb8a380c177d2d70e88ec/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=9ed0bf9f2bd63933785fb8a380c177d2d70e88ec", "patch": "@@ -710,18 +710,17 @@ where\n             return None;\n         }\n \n-        let idx_opt = {\n-            // work around borrowck limitations\n-            let pred = &mut self.pred;\n-            self.v.iter().position(|x| (*pred)(x))\n-        };\n-        match idx_opt {\n+        match self.v.iter().position(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let (head, tail) = tmp.split_at_mut(idx);\n-                self.v = &mut tail[1..];\n-                Some(head)\n+                let tmp = mem::take(&mut self.v);\n+                // idx is the index of the element we are splitting on. We want to set self to the\n+                // region after idx, and return the subslice before and not including idx.\n+                // So first we split after idx\n+                let (head, tail) = tmp.split_at_mut(idx + 1);\n+                self.v = tail;\n+                // Then return the subslice up to but not including the found element\n+                Some(&mut head[..idx])\n             }\n         }\n     }"}]}