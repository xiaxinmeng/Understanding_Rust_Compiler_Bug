{"sha": "5f32e180118b8163821e3276d4234f4d7e2f1eeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMzJlMTgwMTE4YjgxNjM4MjFlMzI3NmQ0MjM0ZjRkN2UyZjFlZWI=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-21T22:32:30Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-22T00:03:00Z"}, "message": "Make std::arena run destructors. Closes #2831.", "tree": {"sha": "91b697ad59c5b710b622eeb7136c4feb5f2e14eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91b697ad59c5b710b622eeb7136c4feb5f2e14eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f32e180118b8163821e3276d4234f4d7e2f1eeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f32e180118b8163821e3276d4234f4d7e2f1eeb", "html_url": "https://github.com/rust-lang/rust/commit/5f32e180118b8163821e3276d4234f4d7e2f1eeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f32e180118b8163821e3276d4234f4d7e2f1eeb/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98d0aae9a1a427e299f281917ad3f387dbd675f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/98d0aae9a1a427e299f281917ad3f387dbd675f2", "html_url": "https://github.com/rust-lang/rust/commit/98d0aae9a1a427e299f281917ad3f387dbd675f2"}], "stats": {"total": 196, "additions": 174, "deletions": 22}, "files": [{"sha": "ef8ddc9addcbea3e279e828117736fd4c52e3da2", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f32e180118b8163821e3276d4234f4d7e2f1eeb/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f32e180118b8163821e3276d4234f4d7e2f1eeb/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=5f32e180118b8163821e3276d4234f4d7e2f1eeb", "patch": "@@ -65,11 +65,13 @@ pure fn size_of<T>() -> uint {\n  * This is the alignment used for struct fields. It may be smaller\n  * than the preferred alignment.\n  */\n+#[inline(always)]\n pure fn min_align_of<T>() -> uint {\n     unchecked { rusti::min_align_of::<T>() }\n }\n \n /// Returns the preferred alignment of a type\n+#[inline(always)]\n pure fn pref_align_of<T>() -> uint {\n     unchecked { rusti::pref_align_of::<T>() }\n }"}, {"sha": "d824507ea1fc55df9b2f77dd967b53660b1ca422", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 162, "deletions": 22, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/5f32e180118b8163821e3276d4234f4d7e2f1eeb/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f32e180118b8163821e3276d4234f4d7e2f1eeb/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=5f32e180118b8163821e3276d4234f4d7e2f1eeb", "patch": "@@ -1,17 +1,63 @@\n // Dynamic arenas.\n \n+// Arenas are used to quickly allocate objects that share a\n+// lifetime. The arena uses ~[u8] vectors as a backing store to\n+// allocate objects from. For each allocated object, the arena stores\n+// a pointer to the type descriptor followed by the\n+// object. (Potentially with alignment padding after each of them.)\n+// When the arena is destroyed, it iterates through all of its chunks,\n+// and uses the tydesc information to trace through the objects,\n+// calling the destructors on them.\n+// One subtle point that needs to be addressed is how to handle\n+// failures while running the user provided initializer function. It\n+// is important to not run the destructor on uninitalized objects, but\n+// how to detect them is somewhat subtle. Since alloc() can be invoked\n+// recursively, it is not sufficient to simply exclude the most recent\n+// object. To solve this without requiring extra space, we use the low\n+// order bit of the tydesc pointer to encode whether the object it\n+// describes has been fully initialized.\n+\n+// A good extension of this scheme would be to segregate data with and\n+// without destructors in order to avoid the overhead in the\n+// plain-old-data case.\n+\n export arena, arena_with_size;\n \n import list;\n import list::{list, cons, nil};\n import unsafe::reinterpret_cast;\n+import sys::TypeDesc;\n+import libc::size_t;\n \n-type chunk = {data: ~[u8], mut fill: uint};\n+#[abi = \"rust-intrinsic\"]\n+extern mod rusti {\n+    fn move_val_init<T>(&dst: T, -src: T);\n+}\n+extern mod rustrt {\n+    #[rust_stack]\n+    fn rust_call_tydesc_glue(root: *u8, tydesc: *TypeDesc, field: size_t);\n+}\n+// This probably belongs somewhere else. Needs to be kept in sync with\n+// changes to glue...\n+const tydesc_drop_glue_index: size_t = 3 as size_t;\n \n-type arena_ = {mut chunks: @list<@chunk>};\n+// The way arena uses arrays is really deeply awful. The arrays are\n+// allocated, and have capacities reserved, but the fill for the array\n+// will always stay at 0.\n+type chunk = {data: ~[u8], mut fill: uint};\n \n-enum arena {\n-    arena_(arena_)\n+struct arena {\n+    // The head is seperated out from the list as a unbenchmarked\n+    // microoptimization, to avoid needing to case on the list to\n+    // access the head.\n+    priv mut head: @chunk;\n+    priv mut chunks: @list<@chunk>;\n+    drop {\n+        unsafe {\n+            destroy_chunk(self.head);\n+            for list::each(self.chunks) |chunk| { destroy_chunk(chunk); }\n+        }\n+    }\n }\n \n fn chunk(size: uint) -> @chunk {\n@@ -21,58 +67,152 @@ fn chunk(size: uint) -> @chunk {\n }\n \n fn arena_with_size(initial_size: uint) -> arena {\n-    return arena_({mut chunks: @cons(chunk(initial_size), @nil)});\n+    return arena {mut head: chunk(initial_size),\n+                  mut chunks: @nil};\n }\n \n fn arena() -> arena {\n     arena_with_size(32u)\n }\n \n-#[abi = \"rust-intrinsic\"]\n-extern mod rusti {\n-    fn move_val_init<T>(&dst: T, -src: T);\n+#[inline(always)]\n+fn round_up_to(base: uint, align: uint) -> uint {\n+    (base + (align - 1)) & !(align - 1)\n+}\n+\n+// Walk down a chunk, running the destructors for any objects stored\n+// in it.\n+unsafe fn destroy_chunk(chunk: @chunk) {\n+    let mut idx = 0;\n+    let buf = vec::unsafe::to_ptr(chunk.data);\n+    let fill = chunk.fill;\n+\n+    while idx < fill {\n+        let tydesc_data: *uint = reinterpret_cast(ptr::offset(buf, idx));\n+        let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n+        let size = (*tydesc).size, align = (*tydesc).align;\n+\n+        let after_tydesc = idx + sys::size_of::<*TypeDesc>();\n+\n+        let start = round_up_to(after_tydesc, align);\n+\n+        //debug!(\"freeing object: idx = %u, size = %u, align = %u, done = %b\",\n+        //       start, size, align, is_done);\n+        if is_done {\n+            rustrt::rust_call_tydesc_glue(\n+                ptr::offset(buf, start), tydesc, tydesc_drop_glue_index);\n+        }\n+\n+        // Find where the next tydesc lives\n+        idx = round_up_to(start + size, sys::pref_align_of::<*TypeDesc>());\n+    }\n }\n \n+// We encode whether the object a tydesc describes has been\n+// initialized in the arena in the low bit of the tydesc pointer. This\n+// is necessary in order to properly do cleanup if a failure occurs\n+// during an initializer.\n+#[inline(always)]\n+unsafe fn bitpack_tydesc_ptr(p: *TypeDesc, is_done: bool) -> uint {\n+    let p_bits: uint = reinterpret_cast(p);\n+    p_bits | (is_done as uint)\n+}\n+#[inline(always)]\n+unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n+    (reinterpret_cast(p & !1), p & 1 == 1)\n+}\n+\n+\n impl &arena {\n-    fn alloc_grow(n_bytes: uint, align: uint) -> *() {\n+    fn alloc_grow(n_bytes: uint, align: uint) -> (*u8, *u8) {\n         // Allocate a new chunk.\n-        let mut head = list::head(self.chunks);\n-        let chunk_size = vec::capacity(head.data);\n+        let chunk_size = vec::capacity(self.head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n-        head = chunk(uint::next_power_of_two(new_min_chunk_size + 1u));\n-        self.chunks = @cons(head, self.chunks);\n+        self.chunks = @cons(self.head, self.chunks);\n+        self.head = chunk(uint::next_power_of_two(new_min_chunk_size + 1u));\n \n         return self.alloc_inner(n_bytes, align);\n     }\n \n     #[inline(always)]\n-    fn alloc_inner(n_bytes: uint, align: uint) -> *() {\n-        let alignm1 = align - 1u;\n-        let mut head = list::head(self.chunks);\n+    fn alloc_inner(n_bytes: uint, align: uint) -> (*u8, *u8) {\n+        let head = self.head;\n \n-        let mut start = head.fill;\n-        start = (start + alignm1) & !alignm1;\n+        let after_tydesc = head.fill + sys::size_of::<*TypeDesc>();\n+\n+        let start = round_up_to(after_tydesc, align);\n         let end = start + n_bytes;\n         if end > vec::capacity(head.data) {\n             return self.alloc_grow(n_bytes, align);\n         }\n \n+        //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n+        //       start, n_bytes, align, head.fill);\n+\n         unsafe {\n-            let p = ptr::offset(vec::unsafe::to_ptr(head.data), start);\n-            head.fill = end;\n-            return unsafe::reinterpret_cast(p);\n+            let buf = vec::unsafe::to_ptr(head.data);\n+            let tydesc_p = ptr::offset(buf, head.fill);\n+            let p = ptr::offset(buf, start);\n+            head.fill = round_up_to(end, sys::pref_align_of::<*TypeDesc>());\n+\n+            return (tydesc_p, p);\n         }\n     }\n \n     #[inline(always)]\n     fn alloc<T>(op: fn() -> T) -> &self/T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n-            let ptr = self.alloc_inner((*tydesc).size, (*tydesc).align);\n+            let (ty_ptr, ptr) =\n+                self.alloc_inner((*tydesc).size, (*tydesc).align);\n+            let ty_ptr: *mut uint = reinterpret_cast(ty_ptr);\n             let ptr: *mut T = reinterpret_cast(ptr);\n+            // Write in our tydesc along with a bit indicating that it\n+            // has *not* been initialized yet.\n+            *ty_ptr = reinterpret_cast(tydesc);\n+            // Actually initialize it\n             rusti::move_val_init(*ptr, op());\n+            // Now that we are done, update the tydesc to indicate that\n+            // the object is there.\n+            *ty_ptr = bitpack_tydesc_ptr(tydesc, true);\n+\n             return reinterpret_cast(ptr);\n         }\n     }\n }\n \n+#[test]\n+fn test_arena_destructors() {\n+    let arena = arena::arena();\n+    for uint::range(0, 10) |i| {\n+        // Arena allocate something with drop glue to make sure it\n+        // doesn't leak.\n+        do arena.alloc { @i };\n+        // Allocate something with funny size and alignment, to keep\n+        // things interesting.\n+        do arena.alloc { [0u8, 1u8, 2u8]/3 };\n+    }\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_arena_destructors_fail() {\n+    let arena = arena::arena();\n+    // Put some stuff in the arena.\n+    for uint::range(0, 10) |i| {\n+        // Arena allocate something with drop glue to make sure it\n+        // doesn't leak.\n+        do arena.alloc { @i };\n+        // Allocate something with funny size and alignment, to keep\n+        // things interesting.\n+        do arena.alloc { [0u8, 1u8, 2u8]/3 };\n+    }\n+    // Now, fail while allocating\n+    do arena.alloc::<@int> {\n+        // First, recursively allocate something else; that needs to\n+        // get freed too.\n+        do arena.alloc { @20 };\n+        // Now fail.\n+        fail;\n+    };\n+}"}, {"sha": "cabc086b64ff06f34ab81630081c8f137b7e6427", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f32e180118b8163821e3276d4234f4d7e2f1eeb/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5f32e180118b8163821e3276d4234f4d7e2f1eeb/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=5f32e180118b8163821e3276d4234f4d7e2f1eeb", "patch": "@@ -949,6 +949,15 @@ rust_task_deref(rust_task *task) {\n     task->deref();\n }\n \n+// Must call on rust stack.\n+extern \"C\" CDECL void\n+rust_call_tydesc_glue(void *root, size_t *tydesc, size_t glue_index) {\n+    void (*glue_fn)(void *, void *, void *, void *) =\n+        (void (*)(void *, void *, void *, void *))tydesc[glue_index];\n+    if (glue_fn)\n+        glue_fn(0, 0, 0, root);\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "db7182a5064206a4bc7334c7b5ca65c2a3f4c7aa", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f32e180118b8163821e3276d4234f4d7e2f1eeb/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/5f32e180118b8163821e3276d4234f4d7e2f1eeb/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=5f32e180118b8163821e3276d4234f4d7e2f1eeb", "patch": "@@ -195,3 +195,4 @@ rust_set_task_local_data\n rust_task_local_data_atexit\n rust_task_ref\n rust_task_deref\n+rust_call_tydesc_glue"}]}