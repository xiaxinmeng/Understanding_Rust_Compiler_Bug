{"sha": "9be155d88e44c1e4cdacfc640448fc9305151ab2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliZTE1NWQ4OGU0NGMxZTRjZGFjZmM2NDA0NDhmYzkzMDUxNTFhYjI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-15T10:41:54Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-29T11:34:43Z"}, "message": "remove the hacky selection impl in `method::probe`", "tree": {"sha": "3033245d1b0cc6a67dbaf17afb57986dad6be931", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3033245d1b0cc6a67dbaf17afb57986dad6be931"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9be155d88e44c1e4cdacfc640448fc9305151ab2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9be155d88e44c1e4cdacfc640448fc9305151ab2", "html_url": "https://github.com/rust-lang/rust/commit/9be155d88e44c1e4cdacfc640448fc9305151ab2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9be155d88e44c1e4cdacfc640448fc9305151ab2/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fceab9fb348becb62f404d0d9381a49446beac7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fceab9fb348becb62f404d0d9381a49446beac7a", "html_url": "https://github.com/rust-lang/rust/commit/fceab9fb348becb62f404d0d9381a49446beac7a"}], "stats": {"total": 558, "additions": 120, "deletions": 438}, "files": [{"sha": "08ec3bf74a71daf355cd41ff0cac98f22b32ec59", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9be155d88e44c1e4cdacfc640448fc9305151ab2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be155d88e44c1e4cdacfc640448fc9305151ab2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=9be155d88e44c1e4cdacfc640448fc9305151ab2", "patch": "@@ -232,24 +232,6 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 })\n             }\n \n-            probe::ExtensionImplPick(impl_def_id) => {\n-                // The method being invoked is the method as defined on the trait,\n-                // so return the substitutions from the trait. Consider:\n-                //\n-                //     impl<A,B,C> Trait<A,B> for Foo<C> { ... }\n-                //\n-                // If we instantiate A, B, and C with $A, $B, and $C\n-                // respectively, then we want to return the type\n-                // parameters from the trait ([$A,$B]), not those from\n-                // the impl ([$A,$B,$C]) not the receiver type ([$C]).\n-                let impl_polytype = self.impl_self_ty(self.span, impl_def_id);\n-                let impl_trait_ref =\n-                    self.instantiate_type_scheme(self.span,\n-                                                 impl_polytype.substs,\n-                                                 &self.tcx.impl_trait_ref(impl_def_id).unwrap());\n-                impl_trait_ref.substs\n-            }\n-\n             probe::TraitPick => {\n                 let trait_def_id = pick.item.container.id();\n "}, {"sha": "caf1ab7cf831d821369fd4068ce7d85b2b94f329", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9be155d88e44c1e4cdacfc640448fc9305151ab2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be155d88e44c1e4cdacfc640448fc9305151ab2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=9be155d88e44c1e4cdacfc640448fc9305151ab2", "patch": "@@ -52,10 +52,6 @@ pub enum MethodError<'tcx> {\n     // Multiple methods might apply.\n     Ambiguity(Vec<CandidateSource>),\n \n-    // Using a `Fn`/`FnMut`/etc method on a raw closure type before we have inferred its kind.\n-    ClosureAmbiguity(// DefId of fn trait\n-                     DefId),\n-\n     // Found an applicable method, but it is not visible. The second argument contains a list of\n     // not-in-scope traits which may work.\n     PrivateMatch(Def, Vec<DefId>),\n@@ -113,7 +109,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Ok(..) => true,\n             Err(NoMatch(..)) => false,\n             Err(Ambiguity(..)) => true,\n-            Err(ClosureAmbiguity(..)) => true,\n             Err(PrivateMatch(..)) => allow_private,\n             Err(IllegalSizedBound(..)) => true,\n         }"}, {"sha": "f63db891bfb06a9a6a6c73e39f0a9c5673e2f368", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 110, "deletions": 395, "changes": 505, "blob_url": "https://github.com/rust-lang/rust/blob/9be155d88e44c1e4cdacfc640448fc9305151ab2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be155d88e44c1e4cdacfc640448fc9305151ab2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9be155d88e44c1e4cdacfc640448fc9305151ab2", "patch": "@@ -18,7 +18,7 @@ use hir::def_id::DefId;\n use hir::def::Def;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, ObligationCause};\n-use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n+use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TraitRef, TypeFoldable};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::util::nodemap::FxHashSet;\n use rustc::infer::{self, InferOk};\n@@ -51,7 +51,6 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     mode: Mode,\n     looking_for: LookingFor<'tcx>,\n     steps: Rc<Vec<CandidateStep<'tcx>>>,\n-    opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: FxHashSet<DefId>,\n@@ -95,13 +94,8 @@ enum CandidateKind<'tcx> {\n     InherentImplCandidate(&'tcx Substs<'tcx>,\n                           // Normalize obligations\n                           Vec<traits::PredicateObligation<'tcx>>),\n-    ExtensionImplCandidate(// Impl\n-                           DefId,\n-                           &'tcx Substs<'tcx>,\n-                           // Normalize obligations\n-                           Vec<traits::PredicateObligation<'tcx>>),\n     ObjectCandidate,\n-    TraitCandidate,\n+    TraitCandidate(ty::TraitRef<'tcx>),\n     WhereClauseCandidate(// Trait\n                          ty::PolyTraitRef<'tcx>),\n }\n@@ -133,8 +127,6 @@ pub struct Pick<'tcx> {\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum PickKind<'tcx> {\n     InherentImplPick,\n-    ExtensionImplPick(// Impl\n-                      DefId),\n     ObjectPick,\n     TraitPick,\n     WhereClausePick(// Trait\n@@ -259,24 +251,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                  }]\n         };\n \n-        // Create a list of simplified self types, if we can.\n-        let mut simplified_steps = Vec::new();\n-        for step in &steps {\n-            match ty::fast_reject::simplify_type(self.tcx, step.self_ty, true) {\n-                None => {\n-                    break;\n-                }\n-                Some(simplified_type) => {\n-                    simplified_steps.push(simplified_type);\n-                }\n-            }\n-        }\n-        let opt_simplified_steps = if simplified_steps.len() < steps.len() {\n-            None // failed to convert at least one of the steps\n-        } else {\n-            Some(simplified_steps)\n-        };\n-\n         debug!(\"ProbeContext: steps for self_ty={:?} are {:?}\",\n                self_ty,\n                steps);\n@@ -285,8 +259,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // that we create during the probe process are removed later\n         self.probe(|_| {\n             let mut probe_cx =\n-                ProbeContext::new(self, span, mode, looking_for,\n-                                  steps, opt_simplified_steps);\n+                ProbeContext::new(self, span, mode, looking_for, steps);\n \n             probe_cx.assemble_inherent_candidates();\n             match scope {\n@@ -357,8 +330,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n            span: Span,\n            mode: Mode,\n            looking_for: LookingFor<'tcx>,\n-           steps: Vec<CandidateStep<'tcx>>,\n-           opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>)\n+           steps: Vec<CandidateStep<'tcx>>)\n            -> ProbeContext<'a, 'gcx, 'tcx> {\n         ProbeContext {\n             fcx,\n@@ -369,7 +341,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             extension_candidates: Vec::new(),\n             impl_dups: FxHashSet(),\n             steps: Rc::new(steps),\n-            opt_simplified_steps,\n             static_candidates: Vec::new(),\n             private_candidate: None,\n             unsatisfied_predicates: Vec::new(),\n@@ -710,6 +681,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                                -> Result<(), MethodError<'tcx>> {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\",\n                trait_def_id);\n+        let trait_substs = self.fresh_item_substs(trait_def_id);\n+        let trait_ref = ty::TraitRef::new(trait_def_id, trait_substs);\n \n         for item in self.impl_or_trait_item(trait_def_id) {\n             // Check whether `trait_def_id` defines a method with suitable name:\n@@ -719,317 +692,14 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 continue;\n             }\n \n-            self.assemble_builtin_candidates(import_id, trait_def_id, item.clone());\n-\n-            self.assemble_extension_candidates_for_trait_impls(import_id, trait_def_id,\n-                                                               item.clone());\n-\n-            self.assemble_closure_candidates(import_id, trait_def_id, item.clone())?;\n-\n-            self.assemble_generator_candidates(import_id, trait_def_id, item.clone())?;\n-\n-            self.assemble_projection_candidates(import_id, trait_def_id, item.clone());\n-\n-            self.assemble_where_clause_candidates(import_id, trait_def_id, item.clone());\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn assemble_builtin_candidates(&mut self,\n-                                   import_id: Option<ast::NodeId>,\n-                                   trait_def_id: DefId,\n-                                   item: ty::AssociatedItem) {\n-        if Some(trait_def_id) == self.tcx.lang_items.clone_trait() {\n-            self.assemble_builtin_clone_candidates(import_id, trait_def_id, item);\n-        }\n-    }\n-\n-    fn assemble_builtin_clone_candidates(&mut self,\n-                                         import_id: Option<ast::NodeId>,\n-                                         trait_def_id: DefId,\n-                                         item: ty::AssociatedItem) {\n-        for step in Rc::clone(&self.steps).iter() {\n-            match step.self_ty.sty {\n-                ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n-                ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n-                ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n-                ty::TyRawPtr(..) | ty::TyError | ty::TyNever |\n-                ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) |\n-                ty::TyArray(..) | ty::TyTuple(..) => {\n-                    ()\n-                }\n-\n-                _ => continue,\n-            };\n-\n-            let substs = Substs::for_item(self.tcx,\n-                                          trait_def_id,\n-                                          |def, _| self.region_var_for_def(self.span, def),\n-                                          |def, substs| {\n-                if def.index == 0 {\n-                    step.self_ty\n-                } else {\n-                    self.type_var_for_def(self.span, def, substs)\n-                }\n-            });\n-\n-            let xform_self_ty = self.xform_self_ty(&item, step.self_ty, substs);\n-            self.push_inherent_candidate(xform_self_ty, item, TraitCandidate, import_id);\n-        }\n-    }\n-\n-    fn assemble_extension_candidates_for_trait_impls(&mut self,\n-                                                     import_id: Option<ast::NodeId>,\n-                                                     trait_def_id: DefId,\n-                                                     item: ty::AssociatedItem) {\n-        // FIXME(arielb1): can we use for_each_relevant_impl here?\n-        self.tcx.for_each_impl(trait_def_id, |impl_def_id| {\n-            debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={:?} \\\n-                                                                  impl_def_id={:?}\",\n-                   trait_def_id,\n-                   impl_def_id);\n-\n-            if !self.impl_can_possibly_match(impl_def_id) {\n-                return;\n-            }\n-\n-            let (_, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n-\n-            debug!(\"impl_substs={:?}\", impl_substs);\n-\n-            let impl_trait_ref = self.tcx.impl_trait_ref(impl_def_id)\n-                .unwrap() // we know this is a trait impl\n-                .subst(self.tcx, impl_substs);\n-\n-            debug!(\"impl_trait_ref={:?}\", impl_trait_ref);\n-\n-            // Determine the receiver type that the method itself expects.\n-            let xform_self_ty =\n-                self.xform_self_ty(&item, impl_trait_ref.self_ty(), impl_trait_ref.substs);\n-\n-            // Normalize the receiver. We can't use normalize_associated_types_in\n-            // as it will pollute the fcx's fulfillment context after this probe\n-            // is over.\n-            let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-            let selcx = &mut traits::SelectionContext::new(self.fcx);\n-            let traits::Normalized { value: xform_self_ty, obligations } =\n-                traits::normalize(selcx, self.param_env, cause, &xform_self_ty);\n-\n-            debug!(\"xform_self_ty={:?}\", xform_self_ty);\n-\n+            let xform_self_ty = self.xform_self_ty(&item, trait_ref.self_ty(), trait_substs);\n             self.push_extension_candidate(xform_self_ty, item,\n-                        ExtensionImplCandidate(impl_def_id, impl_substs, obligations), import_id);\n-        });\n-    }\n-\n-    fn impl_can_possibly_match(&self, impl_def_id: DefId) -> bool {\n-        let simplified_steps = match self.opt_simplified_steps {\n-            Some(ref simplified_steps) => simplified_steps,\n-            None => {\n-                return true;\n-            }\n-        };\n-\n-        let impl_type = self.tcx.type_of(impl_def_id);\n-        let impl_simplified_type =\n-            match ty::fast_reject::simplify_type(self.tcx, impl_type, false) {\n-                Some(simplified_type) => simplified_type,\n-                None => {\n-                    return true;\n-                }\n-            };\n-\n-        simplified_steps.contains(&impl_simplified_type)\n-    }\n-\n-    fn assemble_closure_candidates(&mut self,\n-                                   import_id: Option<ast::NodeId>,\n-                                   trait_def_id: DefId,\n-                                   item: ty::AssociatedItem)\n-                                   -> Result<(), MethodError<'tcx>> {\n-        // Check if this is one of the Fn,FnMut,FnOnce traits.\n-        let tcx = self.tcx;\n-        let kind = if Some(trait_def_id) == tcx.lang_items.fn_trait() {\n-            ty::ClosureKind::Fn\n-        } else if Some(trait_def_id) == tcx.lang_items.fn_mut_trait() {\n-            ty::ClosureKind::FnMut\n-        } else if Some(trait_def_id) == tcx.lang_items.fn_once_trait() {\n-            ty::ClosureKind::FnOnce\n-        } else {\n-            return Ok(());\n-        };\n-\n-        // Check if there is an unboxed-closure self-type in the list of receivers.\n-        // If so, add \"synthetic impls\".\n-        let steps = self.steps.clone();\n-        for step in steps.iter() {\n-            let closure_id = match step.self_ty.sty {\n-                ty::TyClosure(def_id, _) => {\n-                    if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                        self.tcx.hir.node_to_hir_id(id)\n-                    } else {\n-                        continue;\n-                    }\n-                }\n-                _ => continue,\n-            };\n-\n-            let closure_kind = {\n-                match self.tables.borrow().closure_kinds().get(closure_id) {\n-                    Some(&(k, _)) => k,\n-                    None => {\n-                        return Err(MethodError::ClosureAmbiguity(trait_def_id));\n-                    }\n-                }\n-            };\n-\n-            // this closure doesn't implement the right kind of `Fn` trait\n-            if !closure_kind.extends(kind) {\n-                continue;\n-            }\n-\n-            // create some substitutions for the argument/return type;\n-            // for the purposes of our method lookup, we only take\n-            // receiver type into account, so we can just substitute\n-            // fresh types here to use during substitution and subtyping.\n-            let substs = Substs::for_item(self.tcx,\n-                                          trait_def_id,\n-                                          |def, _| self.region_var_for_def(self.span, def),\n-                                          |def, substs| {\n-                if def.index == 0 {\n-                    step.self_ty\n-                } else {\n-                    self.type_var_for_def(self.span, def, substs)\n-                }\n-            });\n-\n-            let xform_self_ty = self.xform_self_ty(&item, step.self_ty, substs);\n-            self.push_inherent_candidate(xform_self_ty, item, TraitCandidate, import_id);\n+                                          TraitCandidate(trait_ref),\n+                                          import_id);\n         }\n-\n         Ok(())\n     }\n \n-    fn assemble_generator_candidates(&mut self,\n-                                   import_id: Option<ast::NodeId>,\n-                                   trait_def_id: DefId,\n-                                   item: ty::AssociatedItem)\n-                                   -> Result<(), MethodError<'tcx>> {\n-        // Check if this is the Generator trait.\n-        let tcx = self.tcx;\n-        if Some(trait_def_id) != tcx.lang_items.gen_trait() {\n-            return Ok(());\n-        }\n-\n-        // Check if there is an generator self-type in the list of receivers.\n-        // If so, add \"synthetic impls\".\n-        let steps = self.steps.clone();\n-        for step in steps.iter() {\n-            match step.self_ty.sty {\n-                ty::TyGenerator(..) => (),\n-                _ => continue,\n-            };\n-\n-            // create some substitutions for the argument/return type;\n-            // for the purposes of our method lookup, we only take\n-            // receiver type into account, so we can just substitute\n-            // fresh types here to use during substitution and subtyping.\n-            let substs = Substs::for_item(self.tcx,\n-                                          trait_def_id,\n-                                          |def, _| self.region_var_for_def(self.span, def),\n-                                          |def, substs| {\n-                if def.index == 0 {\n-                    step.self_ty\n-                } else {\n-                    self.type_var_for_def(self.span, def, substs)\n-                }\n-            });\n-\n-            let xform_self_ty = self.xform_self_ty(&item, step.self_ty, substs);\n-            self.push_inherent_candidate(xform_self_ty, item, TraitCandidate, import_id);\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn assemble_projection_candidates(&mut self,\n-                                      import_id: Option<ast::NodeId>,\n-                                      trait_def_id: DefId,\n-                                      item: ty::AssociatedItem) {\n-        debug!(\"assemble_projection_candidates(\\\n-               trait_def_id={:?}, \\\n-               item={:?})\",\n-               trait_def_id,\n-               item);\n-\n-        for step in Rc::clone(&self.steps).iter() {\n-            debug!(\"assemble_projection_candidates: step={:?}\", step);\n-\n-            let (def_id, substs) = match step.self_ty.sty {\n-                ty::TyProjection(ref data) => {\n-                    let trait_ref = data.trait_ref(self.tcx);\n-                    (trait_ref.def_id, trait_ref.substs)\n-                },\n-                ty::TyAnon(def_id, substs) => (def_id, substs),\n-                _ => continue,\n-            };\n-\n-            debug!(\"assemble_projection_candidates: def_id={:?} substs={:?}\",\n-                   def_id,\n-                   substs);\n-\n-            let trait_predicates = self.tcx.predicates_of(def_id);\n-            let bounds = trait_predicates.instantiate(self.tcx, substs);\n-            let predicates = bounds.predicates;\n-            debug!(\"assemble_projection_candidates: predicates={:?}\",\n-                   predicates);\n-            for poly_bound in traits::elaborate_predicates(self.tcx, predicates)\n-                .filter_map(|p| p.to_opt_poly_trait_ref())\n-                .filter(|b| b.def_id() == trait_def_id) {\n-                let bound = self.erase_late_bound_regions(&poly_bound);\n-\n-                debug!(\"assemble_projection_candidates: def_id={:?} substs={:?} bound={:?}\",\n-                       def_id,\n-                       substs,\n-                       bound);\n-\n-                if self.can_eq(self.param_env, step.self_ty, bound.self_ty()).is_ok() {\n-                    let xform_self_ty = self.xform_self_ty(&item, bound.self_ty(), bound.substs);\n-\n-                    debug!(\"assemble_projection_candidates: bound={:?} xform_self_ty={:?}\",\n-                           bound,\n-                           xform_self_ty);\n-\n-                    self.push_extension_candidate(xform_self_ty, item, TraitCandidate, import_id);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn assemble_where_clause_candidates(&mut self,\n-                                        import_id: Option<ast::NodeId>,\n-                                        trait_def_id: DefId,\n-                                        item: ty::AssociatedItem) {\n-        debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n-               trait_def_id);\n-\n-        let caller_predicates = self.param_env.caller_bounds.to_vec();\n-        for poly_bound in traits::elaborate_predicates(self.tcx, caller_predicates)\n-            .filter_map(|p| p.to_opt_poly_trait_ref())\n-            .filter(|b| b.def_id() == trait_def_id) {\n-            let bound = self.erase_late_bound_regions(&poly_bound);\n-            let xform_self_ty = self.xform_self_ty(&item, bound.self_ty(), bound.substs);\n-\n-            debug!(\"assemble_where_clause_candidates: bound={:?} xform_self_ty={:?}\",\n-                   bound,\n-                   xform_self_ty);\n-\n-            self.push_extension_candidate(xform_self_ty, item,\n-                                          WhereClauseCandidate(poly_bound), import_id);\n-        }\n-    }\n-\n     fn candidate_method_names(&self) -> Vec<ast::Name> {\n         let mut set = FxHashSet();\n         let mut names: Vec<_> =\n@@ -1095,10 +765,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 assert!(others.is_empty());\n                 vec![]\n             }\n-            Some(Err(MethodError::ClosureAmbiguity(..))) => {\n-                // this error only occurs when assembling candidates\n-                span_bug!(span, \"encountered ClosureAmbiguity from pick_core\");\n-            }\n             _ => vec![],\n         };\n \n@@ -1226,13 +892,49 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         }\n \n         if applicable_candidates.len() > 1 {\n-            let sources = probes.iter().map(|p| p.to_source()).collect();\n+            let sources = probes.iter()\n+                .map(|p| self.candidate_source(p, self_ty))\n+                .collect();\n             return Some(Err(MethodError::Ambiguity(sources)));\n         }\n \n         applicable_candidates.pop().map(|probe| Ok(probe.to_unadjusted_pick()))\n     }\n \n+    fn select_trait_candidate(&self, trait_ref: ty::TraitRef<'tcx>)\n+                              -> traits::SelectionResult<'tcx, traits::Selection<'tcx>>\n+    {\n+        let cause = traits::ObligationCause::misc(self.span, self.body_id);\n+        let predicate =\n+            trait_ref.to_poly_trait_ref().to_poly_trait_predicate();\n+        let obligation = traits::Obligation::new(cause, self.param_env, predicate);\n+        traits::SelectionContext::new(self).select(&obligation)\n+    }\n+\n+    fn candidate_source(&self, candidate: &Candidate<'tcx>, self_ty: Ty<'tcx>)\n+                        -> CandidateSource\n+    {\n+        match candidate.kind {\n+            InherentImplCandidate(..) => ImplSource(candidate.item.container.id()),\n+            ObjectCandidate |\n+            WhereClauseCandidate(_) => TraitSource(candidate.item.container.id()),\n+            TraitCandidate(trait_ref) => self.probe(|_| {\n+                let _ = self.at(&ObligationCause::dummy(), self.param_env)\n+                    .sup(candidate.xform_self_ty, self_ty);\n+                match self.select_trait_candidate(trait_ref) {\n+                    Ok(Some(traits::Vtable::VtableImpl(ref impl_data))) => {\n+                        // If only a single impl matches, make the error message point\n+                        // to that impl.\n+                        ImplSource(impl_data.impl_def_id)\n+                    }\n+                    _ => {\n+                        TraitSource(candidate.item.container.id())\n+                    }\n+                }\n+            })\n+        }\n+    }\n+\n     fn consider_probe(&self,\n                       self_ty: Ty<'tcx>,\n                       probe: &Candidate<'tcx>,\n@@ -1251,56 +953,80 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 }\n             };\n \n+            let mut successful = true;\n+            let selcx = &mut traits::SelectionContext::new(self);\n+            let cause = traits::ObligationCause::misc(self.span, self.body_id);\n+\n             // If so, impls may carry other conditions (e.g., where\n             // clauses) that must be considered. Make sure that those\n             // match as well (or at least may match, sometimes we\n             // don't have enough information to fully evaluate).\n-            let (impl_def_id, substs, ref_obligations) = match probe.kind {\n+            let candidate_obligations : Vec<_> = match probe.kind {\n                 InherentImplCandidate(ref substs, ref ref_obligations) => {\n-                    (probe.item.container.id(), substs, ref_obligations)\n-                }\n-\n-                ExtensionImplCandidate(impl_def_id, ref substs, ref ref_obligations) => {\n-                    (impl_def_id, substs, ref_obligations)\n+                    // Check whether the impl imposes obligations we have to worry about.\n+                    let impl_def_id = probe.item.container.id();\n+                    let impl_bounds = self.tcx.predicates_of(impl_def_id);\n+                    let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n+                    let traits::Normalized { value: impl_bounds, obligations: norm_obligations } =\n+                        traits::normalize(selcx, self.param_env, cause.clone(), &impl_bounds);\n+\n+                    // Convert the bounds into obligations.\n+                    let impl_obligations = traits::predicates_for_generics(\n+                        cause.clone(), self.param_env, &impl_bounds);\n+\n+                    debug!(\"impl_obligations={:?}\", impl_obligations);\n+                    impl_obligations.into_iter()\n+                        .chain(norm_obligations.into_iter())\n+                        .chain(ref_obligations.iter().cloned())\n+                        .collect()\n                 }\n \n                 ObjectCandidate |\n-                TraitCandidate |\n                 WhereClauseCandidate(..) => {\n                     // These have no additional conditions to check.\n-                    return true;\n+                    vec![]\n                 }\n-            };\n \n-            let selcx = &mut traits::SelectionContext::new(self);\n-            let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-\n-            // Check whether the impl imposes obligations we have to worry about.\n-            let impl_bounds = self.tcx.predicates_of(impl_def_id);\n-            let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n-            let traits::Normalized { value: impl_bounds, obligations: norm_obligations } =\n-                traits::normalize(selcx, self.param_env, cause.clone(), &impl_bounds);\n+                TraitCandidate(trait_ref) => {\n+                    let predicate = trait_ref.to_predicate();\n+                    let obligation =\n+                        traits::Obligation::new(cause.clone(), self.param_env, predicate);\n+                    if !selcx.evaluate_obligation(&obligation) {\n+                        if self.probe(|_| self.select_trait_candidate(trait_ref).is_err()) {\n+                            // This candidate's primary obligation doesn't even\n+                            // select - don't bother registering anything in\n+                            // `potentially_unsatisfied_predicates`.\n+                            return false\n+                        } else {\n+                            // Some nested subobligation of this predicate\n+                            // failed.\n+                            //\n+                            // FIXME: try to find the exact nested subobligation\n+                            // and point at it rather than reporting the entire\n+                            // trait-ref?\n+                            successful = false;\n+                            let trait_ref = self.resolve_type_vars_if_possible(&trait_ref);\n+                            possibly_unsatisfied_predicates.push(trait_ref);\n+                        }\n+                    }\n+                    vec![]\n+                }\n+            };\n \n-            // Convert the bounds into obligations.\n-            let obligations = traits::predicates_for_generics(cause.clone(),\n-                                                              self.param_env,\n-                                                              &impl_bounds);\n-            debug!(\"impl_obligations={:?}\", obligations);\n+            debug!(\"consider_probe - candidate_obligations={:?} sub_obligations={:?}\",\n+                   candidate_obligations, sub_obligations);\n \n             // Evaluate those obligations to see if they might possibly hold.\n-            let mut all_true = true;\n-            for o in obligations.iter()\n-                .chain(sub_obligations.iter())\n-                .chain(norm_obligations.iter())\n-                .chain(ref_obligations.iter()) {\n-                if !selcx.evaluate_obligation(o) {\n-                    all_true = false;\n+            for o in candidate_obligations.into_iter().chain(sub_obligations) {\n+                let o = self.resolve_type_vars_if_possible(&o);\n+                if !selcx.evaluate_obligation(&o) {\n+                    successful = false;\n                     if let &ty::Predicate::Trait(ref pred) = &o.predicate {\n                         possibly_unsatisfied_predicates.push(pred.0.trait_ref);\n                     }\n                 }\n             }\n-            all_true\n+            successful\n         })\n     }\n \n@@ -1434,16 +1160,16 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     /// Get the type of an impl and generate substitutions with placeholders.\n     fn impl_ty_and_substs(&self, impl_def_id: DefId) -> (Ty<'tcx>, &'tcx Substs<'tcx>) {\n-        let impl_ty = self.tcx.type_of(impl_def_id);\n-\n-        let substs = Substs::for_item(self.tcx,\n-                                      impl_def_id,\n-                                      |_, _| self.tcx.types.re_erased,\n-                                      |_, _| self.next_ty_var(\n-                                        TypeVariableOrigin::SubstitutionPlaceholder(\n-                                            self.tcx.def_span(impl_def_id))));\n+        (self.tcx.type_of(impl_def_id), self.fresh_item_substs(impl_def_id))\n+    }\n \n-        (impl_ty, substs)\n+    fn fresh_item_substs(&self, def_id: DefId) -> &'tcx Substs<'tcx> {\n+        Substs::for_item(self.tcx,\n+                         def_id,\n+                         |_, _| self.tcx.types.re_erased,\n+                         |_, _| self.next_ty_var(\n+                             TypeVariableOrigin::SubstitutionPlaceholder(\n+                                 self.tcx.def_span(def_id))))\n     }\n \n     /// Replace late-bound-regions bound by `value` with `'static` using\n@@ -1493,9 +1219,8 @@ impl<'tcx> Candidate<'tcx> {\n             item: self.item.clone(),\n             kind: match self.kind {\n                 InherentImplCandidate(..) => InherentImplPick,\n-                ExtensionImplCandidate(def_id, ..) => ExtensionImplPick(def_id),\n                 ObjectCandidate => ObjectPick,\n-                TraitCandidate => TraitPick,\n+                TraitCandidate(_) => TraitPick,\n                 WhereClauseCandidate(ref trait_ref) => {\n                     // Only trait derived from where-clauses should\n                     // appear here, so they should not contain any\n@@ -1513,14 +1238,4 @@ impl<'tcx> Candidate<'tcx> {\n             unsize: None,\n         }\n     }\n-\n-    fn to_source(&self) -> CandidateSource {\n-        match self.kind {\n-            InherentImplCandidate(..) => ImplSource(self.item.container.id()),\n-            ExtensionImplCandidate(def_id, ..) => ImplSource(def_id),\n-            ObjectCandidate |\n-            TraitCandidate |\n-            WhereClauseCandidate(_) => TraitSource(self.item.container.id()),\n-        }\n-    }\n }"}, {"sha": "9079ba4a89382be01eab18ddd6e9a03e73012010", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9be155d88e44c1e4cdacfc640448fc9305151ab2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be155d88e44c1e4cdacfc640448fc9305151ab2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=9be155d88e44c1e4cdacfc640448fc9305151ab2", "patch": "@@ -296,22 +296,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 err.emit();\n             }\n \n-            MethodError::ClosureAmbiguity(trait_def_id) => {\n-                let msg = format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n-                                   invoked on this closure as we have not yet inferred what \\\n-                                   kind of closure it is\",\n-                                  item_name,\n-                                  self.tcx.item_path_str(trait_def_id));\n-                let msg = if let Some(callee) = rcvr_expr {\n-                    format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n-                            msg,\n-                            self.tcx.hir.node_to_pretty_string(callee.id))\n-                } else {\n-                    msg\n-                };\n-                self.sess().span_err(span, &msg);\n-            }\n-\n             MethodError::PrivateMatch(def, out_of_scope_traits) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0624,\n                                                \"{} `{}` is private\", def.kind_name(), item_name);"}, {"sha": "028f2e9375b3cf8caad48aeb44d67d4ca1408946", "filename": "src/test/run-pass/unboxed-closures-infer-explicit-call-early.rs", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9be155d88e44c1e4cdacfc640448fc9305151ab2/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-explicit-call-early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be155d88e44c1e4cdacfc640448fc9305151ab2/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-explicit-call-early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-explicit-call-early.rs?ref=9be155d88e44c1e4cdacfc640448fc9305151ab2", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(fn_traits)]\n+\n fn main() {\n-    let mut zero = || {};\n-    let () = zero.call_mut(());\n-    //~^ ERROR we have not yet inferred what kind of closure it is\n+    let mut zero = || 0;\n+    let x = zero.call_mut(());\n+    assert_eq!(x, 0);\n }", "previous_filename": "src/test/compile-fail/unboxed-closures-infer-explicit-call-too-early.rs"}, {"sha": "23f115858cd5e6b53c66cb24ddf3d9b7e4d58668", "filename": "src/test/ui/impl-trait/no-method-suggested-traits.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9be155d88e44c1e4cdacfc640448fc9305151ab2/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be155d88e44c1e4cdacfc640448fc9305151ab2/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr?ref=9be155d88e44c1e4cdacfc640448fc9305151ab2", "patch": "@@ -8,6 +8,8 @@ error[E0599]: no method named `method` found for type `u32` in the current scope\n    = note: the following traits are implemented but not in scope, perhaps add a `use` for one of them:\n            candidate #1: `use foo::Bar;`\n            candidate #2: `use no_method_suggested_traits::foo::PubPub;`\n+           candidate #3: `use no_method_suggested_traits::qux::PrivPub;`\n+           candidate #4: `use no_method_suggested_traits::Reexported;`\n \n error[E0599]: no method named `method` found for type `std::rc::Rc<&mut std::boxed::Box<&u32>>` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:38:44\n@@ -19,6 +21,8 @@ error[E0599]: no method named `method` found for type `std::rc::Rc<&mut std::box\n    = note: the following traits are implemented but not in scope, perhaps add a `use` for one of them:\n            candidate #1: `use foo::Bar;`\n            candidate #2: `use no_method_suggested_traits::foo::PubPub;`\n+           candidate #3: `use no_method_suggested_traits::qux::PrivPub;`\n+           candidate #4: `use no_method_suggested_traits::Reexported;`\n \n error[E0599]: no method named `method` found for type `char` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:44:9"}, {"sha": "e2e2019307f34f53160b3148a781273cf12ccae2", "filename": "src/test/ui/mismatched_types/issue-36053-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be155d88e44c1e4cdacfc640448fc9305151ab2/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be155d88e44c1e4cdacfc640448fc9305151ab2/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr?ref=9be155d88e44c1e4cdacfc640448fc9305151ab2", "patch": "@@ -5,8 +5,8 @@ error[E0599]: no method named `count` found for type `std::iter::Filter<std::ite\n    |                                                       ^^^^^\n    |\n    = note: the method `count` exists but the following trait bounds were not satisfied:\n-           `[closure@$DIR/issue-36053-2.rs:17:39: 17:53] : std::ops::FnMut<(&_,)>`\n            `std::iter::Filter<std::iter::Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:17:39: 17:53]> : std::iter::Iterator`\n+           `&mut std::iter::Filter<std::iter::Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:17:39: 17:53]> : std::iter::Iterator`\n \n error[E0281]: type mismatch: `[closure@$DIR/issue-36053-2.rs:17:39: 17:53]` implements the trait `for<'r> std::ops::FnMut<(&'r str,)>`, but the trait `for<'r> std::ops::FnMut<(&'r &str,)>` is required\n   --> $DIR/issue-36053-2.rs:17:32"}]}