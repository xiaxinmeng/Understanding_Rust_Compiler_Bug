{"sha": "75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZmYzMTEwYWM2ZDhhMDI1OTAyM2I4M2ZkMjBkN2FiMjk1ZjhkZDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-31T14:00:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-31T14:00:55Z"}, "message": "Auto merge of #70617 - Centril:rollup-063ycso, r=Centril\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #69784 (Optimize strip_prefix and strip_suffix with str patterns)\n - #70548 (Add long error code for error E0226)\n - #70555 (resolve, `try_resolve_as_non_binding`: use `delay_span_bug` due to parser recovery)\n - #70561 (remove obsolete comment)\n - #70562 (infer array len from pattern)\n - #70585 (std: Fix over-aligned allocations on wasm32-wasi)\n - #70587 (Add `Rust` to the code snippet)\n - #70588 (Fix incorrect documentation for `str::{split_at, split_at_mut}`)\n - #70613 (more clippy fixes)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "16273bf92f9580d0c1a3fbb99b10d32c234902b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16273bf92f9580d0c1a3fbb99b10d32c234902b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "html_url": "https://github.com/rust-lang/rust/commit/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2113659479a82ea69633b23ef710b58ab127755e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2113659479a82ea69633b23ef710b58ab127755e", "html_url": "https://github.com/rust-lang/rust/commit/2113659479a82ea69633b23ef710b58ab127755e"}, {"sha": "976f8d59dddac2ccddbe940953ee6247454e6736", "url": "https://api.github.com/repos/rust-lang/rust/commits/976f8d59dddac2ccddbe940953ee6247454e6736", "html_url": "https://github.com/rust-lang/rust/commit/976f8d59dddac2ccddbe940953ee6247454e6736"}], "stats": {"total": 666, "additions": 470, "deletions": 196}, "files": [{"sha": "03bc4bab45137c76d85bdd644f76d8640a614ab3", "filename": ".github/ISSUE_TEMPLATE/ice.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/.github%2FISSUE_TEMPLATE%2Fice.md", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/.github%2FISSUE_TEMPLATE%2Fice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.md?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -14,7 +14,7 @@ http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\n \n ### Code\n \n-```\n+```Rust\n <code>\n ```\n "}, {"sha": "1e5fe125c550d3c5724471b229ae5697163fc705", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -1849,6 +1849,21 @@ impl<'a, 'b> Pattern<'a> for &'b String {\n     fn is_prefix_of(self, haystack: &'a str) -> bool {\n         self[..].is_prefix_of(haystack)\n     }\n+\n+    #[inline]\n+    fn strip_prefix_of(self, haystack: &'a str) -> Option<&'a str> {\n+        self[..].strip_prefix_of(haystack)\n+    }\n+\n+    #[inline]\n+    fn is_suffix_of(self, haystack: &'a str) -> bool {\n+        self[..].is_suffix_of(haystack)\n+    }\n+\n+    #[inline]\n+    fn strip_suffix_of(self, haystack: &'a str) -> Option<&'a str> {\n+        self[..].strip_suffix_of(haystack)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "dc7637cfdb934121c6f8cd80e948aeae8ce4097f", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 9, "deletions": 32, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -9,7 +9,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::pattern::Pattern;\n-use self::pattern::{DoubleEndedSearcher, ReverseSearcher, SearchStep, Searcher};\n+use self::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};\n \n use crate::char;\n use crate::fmt::{self, Write};\n@@ -2642,7 +2642,7 @@ impl str {\n     /// # Panics\n     ///\n     /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n-    /// beyond the last code point of the string slice.\n+    /// past the end of the last code point of the string slice.\n     ///\n     /// # Examples\n     ///\n@@ -2683,7 +2683,7 @@ impl str {\n     /// # Panics\n     ///\n     /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n-    /// beyond the last code point of the string slice.\n+    /// past the end of the last code point of the string slice.\n     ///\n     /// # Examples\n     ///\n@@ -3986,26 +3986,15 @@ impl str {\n     /// ```\n     /// #![feature(str_strip)]\n     ///\n-    /// assert_eq!(\"foobar\".strip_prefix(\"foo\"), Some(\"bar\"));\n-    /// assert_eq!(\"foobar\".strip_prefix(\"bar\"), None);\n+    /// assert_eq!(\"foo:bar\".strip_prefix(\"foo:\"), Some(\"bar\"));\n+    /// assert_eq!(\"foo:bar\".strip_prefix(\"bar\"), None);\n     /// assert_eq!(\"foofoo\".strip_prefix(\"foo\"), Some(\"foo\"));\n     /// ```\n     #[must_use = \"this returns the remaining substring as a new slice, \\\n                   without modifying the original\"]\n     #[unstable(feature = \"str_strip\", reason = \"newly added\", issue = \"67302\")]\n     pub fn strip_prefix<'a, P: Pattern<'a>>(&'a self, prefix: P) -> Option<&'a str> {\n-        let mut matcher = prefix.into_searcher(self);\n-        if let SearchStep::Match(start, len) = matcher.next() {\n-            debug_assert_eq!(\n-                start, 0,\n-                \"The first search step from Searcher \\\n-                 must include the first character\"\n-            );\n-            // SAFETY: `Searcher` is known to return valid indices.\n-            unsafe { Some(self.get_unchecked(len..)) }\n-        } else {\n-            None\n-        }\n+        prefix.strip_prefix_of(self)\n     }\n \n     /// Returns a string slice with the suffix removed.\n@@ -4020,8 +4009,8 @@ impl str {\n     ///\n     /// ```\n     /// #![feature(str_strip)]\n-    /// assert_eq!(\"barfoo\".strip_suffix(\"foo\"), Some(\"bar\"));\n-    /// assert_eq!(\"barfoo\".strip_suffix(\"bar\"), None);\n+    /// assert_eq!(\"bar:foo\".strip_suffix(\":foo\"), Some(\"bar\"));\n+    /// assert_eq!(\"bar:foo\".strip_suffix(\"bar\"), None);\n     /// assert_eq!(\"foofoo\".strip_suffix(\"foo\"), Some(\"foo\"));\n     /// ```\n     #[must_use = \"this returns the remaining substring as a new slice, \\\n@@ -4032,19 +4021,7 @@ impl str {\n         P: Pattern<'a>,\n         <P as Pattern<'a>>::Searcher: ReverseSearcher<'a>,\n     {\n-        let mut matcher = suffix.into_searcher(self);\n-        if let SearchStep::Match(start, end) = matcher.next_back() {\n-            debug_assert_eq!(\n-                end,\n-                self.len(),\n-                \"The first search step from ReverseSearcher \\\n-                 must include the last character\"\n-            );\n-            // SAFETY: `Searcher` is known to return valid indices.\n-            unsafe { Some(self.get_unchecked(..start)) }\n-        } else {\n-            None\n-        }\n+        suffix.strip_suffix_of(self)\n     }\n \n     /// Returns a string slice with all suffixes that match a pattern"}, {"sha": "30fd55f7b7f646f35fcb31aba5d0e4f5035f7f80", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -47,6 +47,22 @@ pub trait Pattern<'a>: Sized {\n         matches!(self.into_searcher(haystack).next(), SearchStep::Match(0, _))\n     }\n \n+    /// Removes the pattern from the front of haystack, if it matches.\n+    #[inline]\n+    fn strip_prefix_of(self, haystack: &'a str) -> Option<&'a str> {\n+        if let SearchStep::Match(start, len) = self.into_searcher(haystack).next() {\n+            debug_assert_eq!(\n+                start, 0,\n+                \"The first search step from Searcher \\\n+                 must include the first character\"\n+            );\n+            // SAFETY: `Searcher` is known to return valid indices.\n+            unsafe { Some(haystack.get_unchecked(len..)) }\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Checks whether the pattern matches at the back of the haystack\n     #[inline]\n     fn is_suffix_of(self, haystack: &'a str) -> bool\n@@ -55,6 +71,26 @@ pub trait Pattern<'a>: Sized {\n     {\n         matches!(self.into_searcher(haystack).next_back(), SearchStep::Match(_, j) if haystack.len() == j)\n     }\n+\n+    /// Removes the pattern from the back of haystack, if it matches.\n+    #[inline]\n+    fn strip_suffix_of(self, haystack: &'a str) -> Option<&'a str>\n+    where\n+        Self::Searcher: ReverseSearcher<'a>,\n+    {\n+        if let SearchStep::Match(start, end) = self.into_searcher(haystack).next_back() {\n+            debug_assert_eq!(\n+                end,\n+                haystack.len(),\n+                \"The first search step from ReverseSearcher \\\n+                 must include the last character\"\n+            );\n+            // SAFETY: `Searcher` is known to return valid indices.\n+            unsafe { Some(haystack.get_unchecked(..start)) }\n+        } else {\n+            None\n+        }\n+    }\n }\n \n // Searcher\n@@ -448,13 +484,26 @@ impl<'a> Pattern<'a> for char {\n         self.encode_utf8(&mut [0u8; 4]).is_prefix_of(haystack)\n     }\n \n+    #[inline]\n+    fn strip_prefix_of(self, haystack: &'a str) -> Option<&'a str> {\n+        self.encode_utf8(&mut [0u8; 4]).strip_prefix_of(haystack)\n+    }\n+\n     #[inline]\n     fn is_suffix_of(self, haystack: &'a str) -> bool\n     where\n         Self::Searcher: ReverseSearcher<'a>,\n     {\n         self.encode_utf8(&mut [0u8; 4]).is_suffix_of(haystack)\n     }\n+\n+    #[inline]\n+    fn strip_suffix_of(self, haystack: &'a str) -> Option<&'a str>\n+    where\n+        Self::Searcher: ReverseSearcher<'a>,\n+    {\n+        self.encode_utf8(&mut [0u8; 4]).strip_suffix_of(haystack)\n+    }\n }\n \n /////////////////////////////////////////////////////////////////////////////\n@@ -569,13 +618,26 @@ macro_rules! pattern_methods {\n             ($pmap)(self).is_prefix_of(haystack)\n         }\n \n+        #[inline]\n+        fn strip_prefix_of(self, haystack: &'a str) -> Option<&'a str> {\n+            ($pmap)(self).strip_prefix_of(haystack)\n+        }\n+\n         #[inline]\n         fn is_suffix_of(self, haystack: &'a str) -> bool\n         where\n             $t: ReverseSearcher<'a>,\n         {\n             ($pmap)(self).is_suffix_of(haystack)\n         }\n+\n+        #[inline]\n+        fn strip_suffix_of(self, haystack: &'a str) -> Option<&'a str>\n+        where\n+            $t: ReverseSearcher<'a>,\n+        {\n+            ($pmap)(self).strip_suffix_of(haystack)\n+        }\n     };\n }\n \n@@ -715,11 +777,34 @@ impl<'a, 'b> Pattern<'a> for &'b str {\n         haystack.as_bytes().starts_with(self.as_bytes())\n     }\n \n+    /// Removes the pattern from the front of haystack, if it matches.\n+    #[inline]\n+    fn strip_prefix_of(self, haystack: &'a str) -> Option<&'a str> {\n+        if self.is_prefix_of(haystack) {\n+            // SAFETY: prefix was just verified to exist.\n+            unsafe { Some(haystack.get_unchecked(self.as_bytes().len()..)) }\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Checks whether the pattern matches at the back of the haystack\n     #[inline]\n     fn is_suffix_of(self, haystack: &'a str) -> bool {\n         haystack.as_bytes().ends_with(self.as_bytes())\n     }\n+\n+    /// Removes the pattern from the back of haystack, if it matches.\n+    #[inline]\n+    fn strip_suffix_of(self, haystack: &'a str) -> Option<&'a str> {\n+        if self.is_suffix_of(haystack) {\n+            let i = haystack.len() - self.as_bytes().len();\n+            // SAFETY: suffix was just verified to exist.\n+            unsafe { Some(haystack.get_unchecked(..i)) }\n+        } else {\n+            None\n+        }\n+    }\n }\n \n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "6e690655f60c57409196d623a9df612a6c511dbf", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -119,6 +119,7 @@ E0222: include_str!(\"./error_codes/E0222.md\"),\n E0223: include_str!(\"./error_codes/E0223.md\"),\n E0224: include_str!(\"./error_codes/E0224.md\"),\n E0225: include_str!(\"./error_codes/E0225.md\"),\n+E0226: include_str!(\"./error_codes/E0226.md\"),\n E0229: include_str!(\"./error_codes/E0229.md\"),\n E0230: include_str!(\"./error_codes/E0230.md\"),\n E0231: include_str!(\"./error_codes/E0231.md\"),\n@@ -475,7 +476,6 @@ E0751: include_str!(\"./error_codes/E0751.md\"),\n //  E0217, // ambiguous associated type, defined in multiple supertraits\n //  E0218, // no associated type defined\n //  E0219, // associated type defined in higher-ranked supertrait\n-    E0226, // only a single explicit lifetime bound is permitted\n     E0227, // ambiguous lifetime bound, explicit lifetime bound required\n     E0228, // explicit lifetime bound required\n //  E0233,"}, {"sha": "4e65132ff0d69742126a1a74c708163925067d00", "filename": "src/librustc_error_codes/error_codes/E0226.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_error_codes%2Ferror_codes%2FE0226.md", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_error_codes%2Ferror_codes%2FE0226.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0226.md?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -0,0 +1,21 @@\n+More than one explicit lifetime bound was used on a trait object.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0226\n+trait Foo {}\n+\n+type T<'a, 'b> = dyn Foo + 'a + 'b; // error: Trait object `arg` has two\n+                                    //        lifetime bound, 'a and 'b.\n+```\n+\n+Here `T` is a trait object with two explicit lifetime bounds, 'a and 'b.\n+\n+Only a single explicit lifetime bound is permitted on trait objects.\n+To fix this error, consider removing one of the lifetime bounds:\n+\n+```\n+trait Foo {}\n+\n+type T<'a> = dyn Foo + 'a;\n+```"}, {"sha": "c2a71ca5669a130b62c96eb4dd17e59d8e06acf3", "filename": "src/librustc_error_codes/error_codes/E0730.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_error_codes%2Ferror_codes%2FE0730.md", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_error_codes%2Ferror_codes%2FE0730.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0730.md?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -7,8 +7,8 @@ Example of erroneous code:\n \n fn is_123<const N: usize>(x: [u32; N]) -> bool {\n     match x {\n-        [1, 2, 3] => true, // error: cannot pattern-match on an\n-                           //        array without a fixed length\n+        [1, 2, ..] => true, // error: cannot pattern-match on an\n+                            //        array without a fixed length\n         _ => false\n     }\n }"}, {"sha": "e3fc4fa52fb61225b8718cbb20a60e0977f64866", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -711,7 +711,7 @@ impl<'tcx> QueryContext<'tcx> {\n     }\n \n     pub fn print_stats(&mut self) {\n-        self.enter(|tcx| ty::query::print_stats(tcx))\n+        self.enter(ty::query::print_stats)\n     }\n }\n "}, {"sha": "8e7abcd09c2330602c8e0e1df5ec7697d604804b", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -30,7 +30,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 trace!(\"SwitchInt({:?})\", *discr);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n-                assert!(targets.len() > 0);\n+                assert!(!targets.is_empty());\n                 let mut target_block = targets[targets.len() - 1];\n \n                 for (index, &const_int) in values.iter().enumerate() {"}, {"sha": "c7ea10ec812581bb258c386142663cd89fc48956", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -93,9 +93,6 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Returns the next token, including trivia like whitespace or comments.\n-    ///\n-    /// `Err(())` means that some errors were encountered, which can be\n-    /// retrieved using `buffer_fatal_errors`.\n     pub fn next_token(&mut self) -> Token {\n         let start_src_index = self.src_index(self.pos);\n         let text: &str = &self.src[start_src_index..self.end_src_index];"}, {"sha": "2b90527a825377bada77264b3f5e918aaa83aca0", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -1536,20 +1536,18 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Not);\n \n         match res {\n-            Res::Def(DefKind::Ctor(_, CtorKind::Const), _)\n-            | Res::Def(DefKind::Const, _)\n-            | Res::Def(DefKind::ConstParam, _)\n-                if is_syntactic_ambiguity =>\n-            {\n+            Res::SelfCtor(_) // See #70549.\n+            | Res::Def(\n+                DefKind::Ctor(_, CtorKind::Const) | DefKind::Const | DefKind::ConstParam,\n+                _,\n+            ) if is_syntactic_ambiguity => {\n                 // Disambiguate in favor of a unit struct/variant or constant pattern.\n                 if let Some(binding) = binding {\n                     self.r.record_use(ident, ValueNS, binding, false);\n                 }\n                 Some(res)\n             }\n-            Res::Def(DefKind::Ctor(..), _)\n-            | Res::Def(DefKind::Const, _)\n-            | Res::Def(DefKind::Static, _) => {\n+            Res::Def(DefKind::Ctor(..) | DefKind::Const | DefKind::Static, _) => {\n                 // This is unambiguously a fresh binding, either syntactically\n                 // (e.g., `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n                 // to something unusable as a pattern (e.g., constructor function),\n@@ -1572,7 +1570,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             _ => span_bug!(\n                 ident.span,\n                 \"unexpected resolution for an identifier in pattern: {:?}\",\n-                res\n+                res,\n             ),\n         }\n     }"}, {"sha": "75c5dfb8d18b0c04afa6313e92c507f9e7766784", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -10,6 +10,7 @@\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(nll)]\n+#![feature(or_patterns)]\n #![recursion_limit = \"256\"]\n \n pub use rustc_hir::def::{Namespace, PerNS};"}, {"sha": "24b7be0c9b306de9f8b4fd05fff44a1ca4bd36e5", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -591,7 +591,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 Some(Data::RefData(Ref {\n                     kind: RefKind::Function,\n                     span,\n-                    ref_id: def_id.or(decl_id).map(id_from_def_id).unwrap_or_else(|| null_id()),\n+                    ref_id: def_id.or(decl_id).map(id_from_def_id).unwrap_or_else(null_id),\n                 }))\n             }\n             ast::ExprKind::Path(_, ref path) => {"}, {"sha": "54481bd124df5fc7ba43f165629e5c2f0e982f25", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -1650,7 +1650,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     check_thread_count(&debugging_opts, error_format);\n \n-    let incremental = cg.incremental.as_ref().map(|m| PathBuf::from(m));\n+    let incremental = cg.incremental.as_ref().map(PathBuf::from);\n \n     if debugging_opts.profile && incremental.is_some() {\n         early_error("}, {"sha": "b7a34f9740ac41248e044f49fcc1f0c075b61fcd", "filename": "src/librustc_target/spec/i686_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_target%2Fspec%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_target%2Fspec%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fi686_apple_darwin.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> TargetResult {\n     let llvm_target = super::apple_base::macos_llvm_target(&arch);\n \n     Ok(Target {\n-        llvm_target: llvm_target,\n+        llvm_target,\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n         target_c_int_width: \"32\".to_string(),"}, {"sha": "31011e847495838d3a1083b6449c88942052b0f9", "filename": "src/librustc_target/spec/x86_64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_target%2Fspec%2Fx86_64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_target%2Fspec%2Fx86_64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_apple_darwin.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> TargetResult {\n     let llvm_target = super::apple_base::macos_llvm_target(&arch);\n \n     Ok(Target {\n-        llvm_target: llvm_target,\n+        llvm_target,\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n         target_c_int_width: \"32\".to_string(),"}, {"sha": "b3cace8298a923852fc9198b3285cbecd3e175a1", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -1355,16 +1355,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let err = self.tcx.types.err;\n         let expected = self.structurally_resolved_type(span, expected);\n-        let (inner_ty, slice_ty, expected) = match expected.kind {\n+        let (element_ty, slice_ty, inferred) = match expected.kind {\n             // An array, so we might have something like `let [a, b, c] = [0, 1, 2];`.\n-            ty::Array(inner_ty, len) => {\n+            ty::Array(element_ty, len) => {\n                 let min = before.len() as u64 + after.len() as u64;\n-                let slice_ty = self\n-                    .check_array_pat_len(span, slice, len, min)\n-                    .map_or(err, |len| self.tcx.mk_array(inner_ty, len));\n-                (inner_ty, slice_ty, expected)\n+                let (slice_ty, expected) =\n+                    self.check_array_pat_len(span, element_ty, expected, slice, len, min);\n+                (element_ty, slice_ty, expected)\n             }\n-            ty::Slice(inner_ty) => (inner_ty, expected, expected),\n+            ty::Slice(element_ty) => (element_ty, expected, expected),\n             // The expected type must be an array or slice, but was neither, so error.\n             _ => {\n                 if !expected.references_error() {\n@@ -1376,30 +1375,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Type check all the patterns before `slice`.\n         for elt in before {\n-            self.check_pat(&elt, inner_ty, def_bm, ti);\n+            self.check_pat(&elt, element_ty, def_bm, ti);\n         }\n         // Type check the `slice`, if present, against its expected type.\n         if let Some(slice) = slice {\n             self.check_pat(&slice, slice_ty, def_bm, ti);\n         }\n         // Type check the elements after `slice`, if present.\n         for elt in after {\n-            self.check_pat(&elt, inner_ty, def_bm, ti);\n+            self.check_pat(&elt, element_ty, def_bm, ti);\n         }\n-        expected\n+        inferred\n     }\n \n     /// Type check the length of an array pattern.\n     ///\n-    /// Return the length of the variable length pattern,\n-    /// if it exists and there are no errors.\n+    /// Returns both the type of the variable length pattern\n+    /// (or `tcx.err` in case there is none),\n+    /// and the potentially inferred array type.\n     fn check_array_pat_len(\n         &self,\n         span: Span,\n+        element_ty: Ty<'tcx>,\n+        arr_ty: Ty<'tcx>,\n         slice: Option<&'tcx Pat<'tcx>>,\n         len: &ty::Const<'tcx>,\n         min_len: u64,\n-    ) -> Option<u64> {\n+    ) -> (Ty<'tcx>, Ty<'tcx>) {\n         if let Some(len) = len.try_eval_usize(self.tcx, self.param_env) {\n             // Now we know the length...\n             if slice.is_none() {\n@@ -1409,21 +1411,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if min_len != len {\n                     self.error_scrutinee_inconsistent_length(span, min_len, len);\n                 }\n-            } else if let r @ Some(_) = len.checked_sub(min_len) {\n+            } else if let Some(pat_len) = len.checked_sub(min_len) {\n                 // The variable-length pattern was there,\n                 // so it has an array type with the remaining elements left as its size...\n-                return r;\n+                return (self.tcx.mk_array(element_ty, pat_len), arr_ty);\n             } else {\n                 // ...however, in this case, there were no remaining elements.\n                 // That is, the slice pattern requires more than the array type offers.\n                 self.error_scrutinee_with_rest_inconsistent_length(span, min_len, len);\n             }\n+        } else if slice.is_none() {\n+            // We have a pattern with a fixed length,\n+            // which we can use to infer the length of the array.\n+            let updated_arr_ty = self.tcx.mk_array(element_ty, min_len);\n+            self.demand_eqtype(span, updated_arr_ty, arr_ty);\n+            return (self.tcx.types.err, updated_arr_ty);\n         } else {\n-            // No idea what the length is, which happens if we have e.g.,\n-            // `let [a, b] = arr` where `arr: [T; N]` where `const N: usize`.\n+            // We have a variable-length pattern and don't know the array length.\n+            // This happens if we have e.g.,\n+            // `let [a, b, ..] = arr` where `arr: [T; N]` where `const N: usize`.\n             self.error_scrutinee_unfixed_length(span);\n         }\n-        None\n+        (self.tcx.types.err, arr_ty)\n     }\n \n     fn error_scrutinee_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {"}, {"sha": "9f327b0b743d8f78c277613c8d8e241fc69e0c7e", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -497,11 +497,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     // of the type.\n                     // Therefore, we make sure that we never add a ?Sized\n                     // bound for projections\n-                    match &ty {\n-                        &Type::QPath { .. } => {\n-                            has_sized.insert(ty.clone());\n-                        }\n-                        _ => {}\n+                    if let Type::QPath { .. } = ty {\n+                        has_sized.insert(ty.clone());\n                     }\n \n                     if bounds.is_empty() {"}, {"sha": "f8e44bc5a1ab7421bfeed0bf48f7fea37c898863", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -521,11 +521,8 @@ impl<'tcx> Clean<Option<WherePredicate>>\n     fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n \n-        match (a, b) {\n-            (ty::ReEmpty(_), ty::ReEmpty(_)) => {\n-                return None;\n-            }\n-            _ => {}\n+        if let (ty::ReEmpty(_), ty::ReEmpty(_)) = (a, b) {\n+            return None;\n         }\n \n         Some(WherePredicate::RegionPredicate {\n@@ -539,9 +536,8 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n     fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(ref ty, ref lt) = *self;\n \n-        match lt {\n-            ty::ReEmpty(_) => return None,\n-            _ => {}\n+        if let ty::ReEmpty(_) = lt {\n+            return None;\n         }\n \n         Some(WherePredicate::BoundPredicate {\n@@ -2239,15 +2235,12 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n         } else {\n             let name = self.name;\n             if !please_inline {\n-                match path.res {\n-                    Res::Def(DefKind::Mod, did) => {\n-                        if !did.is_local() && did.index == CRATE_DEF_INDEX {\n-                            // if we're `pub use`ing an extern crate root, don't inline it unless we\n-                            // were specifically asked for it\n-                            denied = true;\n-                        }\n+                if let Res::Def(DefKind::Mod, did) = path.res {\n+                    if !did.is_local() && did.index == CRATE_DEF_INDEX {\n+                        // if we're `pub use`ing an extern crate root, don't inline it unless we\n+                        // were specifically asked for it\n+                        denied = true;\n                     }\n-                    _ => {}\n                 }\n             }\n             if !denied {\n@@ -2426,10 +2419,9 @@ impl From<GenericBound> for SimpleBound {\n             GenericBound::TraitBound(t, mod_) => match t.trait_ {\n                 Type::ResolvedPath { path, param_names, .. } => SimpleBound::TraitBound(\n                     path.segments,\n-                    param_names.map_or_else(\n-                        || Vec::new(),\n-                        |v| v.iter().map(|p| SimpleBound::from(p.clone())).collect(),\n-                    ),\n+                    param_names.map_or_else(Vec::new, |v| {\n+                        v.iter().map(|p| SimpleBound::from(p.clone())).collect()\n+                    }),\n                     t.generic_params,\n                     mod_,\n                 ),"}, {"sha": "9e96015d306e4e747cedfef8aecc4de4b880738d", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -121,7 +121,7 @@ pub fn external_generic_args(\n     let args: Vec<_> = substs\n         .iter()\n         .filter_map(|kind| match kind.unpack() {\n-            GenericArgKind::Lifetime(lt) => lt.clean(cx).map(|lt| GenericArg::Lifetime(lt)),\n+            GenericArgKind::Lifetime(lt) => lt.clean(cx).map(GenericArg::Lifetime),\n             GenericArgKind::Type(_) if skip_self => {\n                 skip_self = false;\n                 None\n@@ -198,27 +198,24 @@ pub fn get_real_types(\n         }) {\n             let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n             for bound in bounds.iter() {\n-                match *bound {\n-                    GenericBound::TraitBound(ref poly_trait, _) => {\n-                        for x in poly_trait.generic_params.iter() {\n-                            if !x.is_type() {\n-                                continue;\n-                            }\n-                            if let Some(ty) = x.get_type() {\n-                                let adds = get_real_types(generics, &ty, cx, recurse + 1);\n-                                if !adds.is_empty() {\n-                                    res.extend(adds);\n-                                } else if !ty.is_full_generic() {\n-                                    if let Some(did) = ty.def_id() {\n-                                        if let Some(kind) = cx.tcx.def_kind(did).clean(cx) {\n-                                            res.insert((ty, kind));\n-                                        }\n+                if let GenericBound::TraitBound(ref poly_trait, _) = *bound {\n+                    for x in poly_trait.generic_params.iter() {\n+                        if !x.is_type() {\n+                            continue;\n+                        }\n+                        if let Some(ty) = x.get_type() {\n+                            let adds = get_real_types(generics, &ty, cx, recurse + 1);\n+                            if !adds.is_empty() {\n+                                res.extend(adds);\n+                            } else if !ty.is_full_generic() {\n+                                if let Some(did) = ty.def_id() {\n+                                    if let Some(kind) = cx.tcx.def_kind(did).clean(cx) {\n+                                        res.insert((ty, kind));\n                                     }\n                                 }\n                             }\n                         }\n                     }\n-                    _ => {}\n                 }\n             }\n         }"}, {"sha": "9fe3e35d197fa132a49210c8153ef15072b093bf", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 59, "deletions": 64, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -448,7 +448,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for SummaryLine<'a, I> {\n         if !self.started {\n             self.started = true;\n         }\n-        while let Some(event) = self.inner.next() {\n+        if let Some(event) = self.inner.next() {\n             let mut is_start = true;\n             let is_allowed_tag = match event {\n                 Event::Start(Tag::CodeBlock(_)) | Event::End(Tag::CodeBlock(_)) => {\n@@ -944,75 +944,70 @@ crate fn rust_code_blocks(md: &str) -> Vec<RustCodeBlock> {\n     let mut p = Parser::new_ext(md, opts()).into_offset_iter();\n \n     while let Some((event, offset)) = p.next() {\n-        match event {\n-            Event::Start(Tag::CodeBlock(syntax)) => {\n-                let (syntax, code_start, code_end, range, is_fenced) = match syntax {\n-                    CodeBlockKind::Fenced(syntax) => {\n-                        let syntax = syntax.as_ref();\n-                        let lang_string = if syntax.is_empty() {\n-                            LangString::all_false()\n-                        } else {\n-                            LangString::parse(&*syntax, ErrorCodes::Yes, false)\n-                        };\n-                        if !lang_string.rust {\n+        if let Event::Start(Tag::CodeBlock(syntax)) = event {\n+            let (syntax, code_start, code_end, range, is_fenced) = match syntax {\n+                CodeBlockKind::Fenced(syntax) => {\n+                    let syntax = syntax.as_ref();\n+                    let lang_string = if syntax.is_empty() {\n+                        LangString::all_false()\n+                    } else {\n+                        LangString::parse(&*syntax, ErrorCodes::Yes, false)\n+                    };\n+                    if !lang_string.rust {\n+                        continue;\n+                    }\n+                    let syntax = if syntax.is_empty() { None } else { Some(syntax.to_owned()) };\n+                    let (code_start, mut code_end) = match p.next() {\n+                        Some((Event::Text(_), offset)) => (offset.start, offset.end),\n+                        Some((_, sub_offset)) => {\n+                            let code = Range { start: sub_offset.start, end: sub_offset.start };\n+                            code_blocks.push(RustCodeBlock {\n+                                is_fenced: true,\n+                                range: offset,\n+                                code,\n+                                syntax,\n+                            });\n                             continue;\n                         }\n-                        let syntax = if syntax.is_empty() { None } else { Some(syntax.to_owned()) };\n-                        let (code_start, mut code_end) = match p.next() {\n-                            Some((Event::Text(_), offset)) => (offset.start, offset.end),\n-                            Some((_, sub_offset)) => {\n-                                let code = Range { start: sub_offset.start, end: sub_offset.start };\n-                                code_blocks.push(RustCodeBlock {\n-                                    is_fenced: true,\n-                                    range: offset,\n-                                    code,\n-                                    syntax,\n-                                });\n-                                continue;\n-                            }\n-                            None => {\n-                                let code = Range { start: offset.end, end: offset.end };\n-                                code_blocks.push(RustCodeBlock {\n-                                    is_fenced: true,\n-                                    range: offset,\n-                                    code,\n-                                    syntax,\n-                                });\n-                                continue;\n-                            }\n-                        };\n-                        while let Some((Event::Text(_), offset)) = p.next() {\n-                            code_end = offset.end;\n+                        None => {\n+                            let code = Range { start: offset.end, end: offset.end };\n+                            code_blocks.push(RustCodeBlock {\n+                                is_fenced: true,\n+                                range: offset,\n+                                code,\n+                                syntax,\n+                            });\n+                            continue;\n                         }\n-                        (syntax, code_start, code_end, offset, true)\n+                    };\n+                    while let Some((Event::Text(_), offset)) = p.next() {\n+                        code_end = offset.end;\n                     }\n-                    CodeBlockKind::Indented => {\n-                        // The ending of the offset goes too far sometime so we reduce it by one in\n-                        // these cases.\n-                        if offset.end > offset.start\n-                            && md.get(offset.end..=offset.end) == Some(&\"\\n\")\n-                        {\n-                            (\n-                                None,\n-                                offset.start,\n-                                offset.end,\n-                                Range { start: offset.start, end: offset.end - 1 },\n-                                false,\n-                            )\n-                        } else {\n-                            (None, offset.start, offset.end, offset, false)\n-                        }\n+                    (syntax, code_start, code_end, offset, true)\n+                }\n+                CodeBlockKind::Indented => {\n+                    // The ending of the offset goes too far sometime so we reduce it by one in\n+                    // these cases.\n+                    if offset.end > offset.start && md.get(offset.end..=offset.end) == Some(&\"\\n\") {\n+                        (\n+                            None,\n+                            offset.start,\n+                            offset.end,\n+                            Range { start: offset.start, end: offset.end - 1 },\n+                            false,\n+                        )\n+                    } else {\n+                        (None, offset.start, offset.end, offset, false)\n                     }\n-                };\n+                }\n+            };\n \n-                code_blocks.push(RustCodeBlock {\n-                    is_fenced,\n-                    range,\n-                    code: Range { start: code_start, end: code_end },\n-                    syntax,\n-                });\n-            }\n-            _ => (),\n+            code_blocks.push(RustCodeBlock {\n+                is_fenced,\n+                range,\n+                code: Range { start: code_start, end: code_end },\n+                syntax,\n+            });\n         }\n     }\n "}, {"sha": "f51f47a8d3387702a9b1292edab2a687663e027e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -782,7 +782,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n                         .split('\"')\n                         .next()\n                         .map(|s| s.to_owned())\n-                        .unwrap_or_else(|| String::new()),\n+                        .unwrap_or_else(String::new),\n                 );\n             }\n         }\n@@ -2158,7 +2158,7 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n                     docs = MarkdownSummaryLine(doc_value, &myitem.links()).to_string(),\n                     class = myitem.type_(),\n                     add = add,\n-                    stab = stab.unwrap_or_else(|| String::new()),\n+                    stab = stab.unwrap_or_else(String::new),\n                     unsafety_flag = unsafety_flag,\n                     href = item_path(myitem.type_(), myitem.name.as_ref().unwrap()),\n                     title = [full_path(cx, myitem), myitem.type_().to_string()]\n@@ -4593,12 +4593,9 @@ fn collect_paths_for_type(first_ty: clean::Type) -> Vec<String> {\n                 let get_extern = || cache.external_paths.get(&did).map(|s| s.0.clone());\n                 let fqp = cache.exact_paths.get(&did).cloned().or_else(get_extern);\n \n-                match fqp {\n-                    Some(path) => {\n-                        out.push(path.join(\"::\"));\n-                    }\n-                    _ => {}\n-                };\n+                if let Some(path) = fqp {\n+                    out.push(path.join(\"::\"));\n+                }\n             }\n             clean::Type::Tuple(tys) => {\n                 work.extend(tys.into_iter());"}, {"sha": "d9f6f7b466a1f4e36f7ad96e816b33e0b12f3718", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -590,7 +590,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     for item in search_index {\n         item.parent_idx = item.parent.and_then(|defid| {\n             if defid_to_pathid.contains_key(&defid) {\n-                defid_to_pathid.get(&defid).map(|x| *x)\n+                defid_to_pathid.get(&defid).copied()\n             } else {\n                 let pathid = lastpathid;\n                 defid_to_pathid.insert(defid, pathid);"}, {"sha": "a064c552c84f5e6a6203ecf9f29cca38c5fbd814", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -496,7 +496,7 @@ pub fn stdout() -> Stdout {\n         unsafe {\n             let ret = Arc::new(ReentrantMutex::new(RefCell::new(LineWriter::new(stdout))));\n             ret.init();\n-            return ret;\n+            ret\n         }\n     }\n }\n@@ -664,7 +664,7 @@ pub fn stderr() -> Stderr {\n             *INSTANCE.lock().borrow_mut() = Maybe::Real(stderr);\n         }\n     });\n-    return Stderr { inner: &INSTANCE };\n+    Stderr { inner: &INSTANCE }\n }\n \n impl Stderr {"}, {"sha": "f389c60615f244e28fa34a3694e6f567adae9433", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -72,7 +72,7 @@ impl Command {\n             }\n         };\n \n-        let mut p = Process { pid: pid, status: None };\n+        let mut p = Process { pid, status: None };\n         drop(output);\n         let mut bytes = [0; 8];\n "}, {"sha": "bc614162784010e98e580f2257afbd18bf5b05fe", "filename": "src/libstd/sys/wasi/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibstd%2Fsys%2Fwasi%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Flibstd%2Fsys%2Fwasi%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Falloc.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -10,7 +10,7 @@ unsafe impl GlobalAlloc for System {\n         if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n             libc::malloc(layout.size()) as *mut u8\n         } else {\n-            libc::aligned_alloc(layout.size(), layout.align()) as *mut u8\n+            libc::aligned_alloc(layout.align(), layout.size()) as *mut u8\n         }\n     }\n "}, {"sha": "22fe7cb88388895fecbc675daf8641ff4c4891ac", "filename": "src/test/ui/array-slice-vec/infer_array_len.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Farray-slice-vec%2Finfer_array_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Farray-slice-vec%2Finfer_array_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Finfer_array_len.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -0,0 +1,21 @@\n+// see issue #70529\n+struct A;\n+\n+impl From<A> for [u8; 2] {\n+    fn from(a: A) -> Self {\n+        [0; 2]\n+    }\n+}\n+\n+impl From<A> for [u8; 3] {\n+    fn from(a: A) -> Self {\n+        [0; 3]\n+    }\n+}\n+\n+\n+fn main() {\n+    let a = A;\n+    let [_, _] = a.into();\n+    //~^ ERROR type annotations needed\n+}"}, {"sha": "6eed4ce4f0c01ecd1cf8509e2682d2f8e24182c7", "filename": "src/test/ui/array-slice-vec/infer_array_len.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Farray-slice-vec%2Finfer_array_len.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Farray-slice-vec%2Finfer_array_len.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Finfer_array_len.stderr?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -0,0 +1,11 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/infer_array_len.rs:19:9\n+   |\n+LL |     let [_, _] = a.into();\n+   |         ^^^^^^ consider giving this pattern a type\n+   |\n+   = note: type must be known at this point\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "7f3da75ddcbe8525b7cc439b30bc0d329c3098b0", "filename": "src/test/ui/array-slice-vec/match_arr_unknown_len.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Farray-slice-vec%2Fmatch_arr_unknown_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Farray-slice-vec%2Fmatch_arr_unknown_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fmatch_arr_unknown_len.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -0,0 +1,11 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn is_123<const N: usize>(x: [u32; N]) -> bool {\n+    match x {\n+        [1, 2] => true, //~ ERROR mismatched types\n+        _ => false\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9edb139028b7250e32679423d9c4571f1a040f27", "filename": "src/test/ui/array-slice-vec/match_arr_unknown_len.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Farray-slice-vec%2Fmatch_arr_unknown_len.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Farray-slice-vec%2Fmatch_arr_unknown_len.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fmatch_arr_unknown_len.stderr?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -0,0 +1,20 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/match_arr_unknown_len.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0308]: mismatched types\n+  --> $DIR/match_arr_unknown_len.rs:6:9\n+   |\n+LL |         [1, 2] => true,\n+   |         ^^^^^^ expected `2usize`, found `N`\n+   |\n+   = note: expected array `[u32; 2]`\n+              found array `[u32; _]`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "a4e3d3dee4a824c2de8e72349332219e4f2ff9bd", "filename": "src/test/ui/const-generics/infer_arg_from_pat.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Fconst-generics%2Finfer_arg_from_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Fconst-generics%2Finfer_arg_from_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer_arg_from_pat.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -0,0 +1,27 @@\n+// run-pass\n+//\n+// see issue #70529\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+struct A<const N: usize> {\n+    arr: [u8; N],\n+}\n+\n+impl<const N: usize> A<N> {\n+    fn new() -> Self {\n+        A {\n+            arr: [0; N],\n+        }\n+    }\n+\n+    fn value(&self) -> usize {\n+        N\n+    }\n+}\n+\n+fn main() {\n+    let a = A::new();\n+    let [_, _] = a.arr;\n+    assert_eq!(a.value(), 2);\n+}"}, {"sha": "ad6bf3e235aebc48fc4605fd14914340fb2bad98", "filename": "src/test/ui/const-generics/infer_arg_from_pat.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Fconst-generics%2Finfer_arg_from_pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Fconst-generics%2Finfer_arg_from_pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer_arg_from_pat.stderr?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/infer_arg_from_pat.rs:4:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "70633bbb141d49aabf25717d9a08f4edb5366614", "filename": "src/test/ui/const-generics/infer_arr_len_from_pat.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Fconst-generics%2Finfer_arr_len_from_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Fconst-generics%2Finfer_arr_len_from_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer_arr_len_from_pat.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+//\n+// see issue #70529\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn as_chunks<const N: usize>() -> [u8; N] {\n+    loop {}\n+}\n+\n+fn main() {\n+    let [_, _] = as_chunks();\n+}"}, {"sha": "6f5b601e14ca113903eab03bafd16e9aba06b2d0", "filename": "src/test/ui/const-generics/infer_arr_len_from_pat.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Fconst-generics%2Finfer_arr_len_from_pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Fconst-generics%2Finfer_arr_len_from_pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer_arr_len_from_pat.stderr?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/infer_arr_len_from_pat.rs:4:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "66a6e1c817a37afe2a5108e4866f40dc9cf59a85", "filename": "src/test/ui/error-codes/E0730.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Ferror-codes%2FE0730.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Ferror-codes%2FE0730.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0730.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -3,7 +3,7 @@\n \n fn is_123<const N: usize>(x: [u32; N]) -> bool {\n     match x {\n-        [1, 2, 3] => true, //~ ERROR cannot pattern-match on an array without a fixed length\n+        [1, 2, ..] => true, //~ ERROR cannot pattern-match on an array without a fixed length\n         _ => false\n     }\n }"}, {"sha": "fb53ae31c0b428a0bf9b9335db2ab84266937afd", "filename": "src/test/ui/error-codes/E0730.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Ferror-codes%2FE0730.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Ferror-codes%2FE0730.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0730.stderr?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -9,8 +9,8 @@ LL | #![feature(const_generics)]\n error[E0730]: cannot pattern-match on an array without a fixed length\n   --> $DIR/E0730.rs:6:9\n    |\n-LL |         [1, 2, 3] => true,\n-   |         ^^^^^^^^^\n+LL |         [1, 2, ..] => true,\n+   |         ^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "aeccd0d9f76cafa177f4bf316a55e4fc095fc9a4", "filename": "src/test/ui/parser/issue-70549-resolve-after-recovered-self-ctor.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Fparser%2Fissue-70549-resolve-after-recovered-self-ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Fparser%2Fissue-70549-resolve-after-recovered-self-ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-70549-resolve-after-recovered-self-ctor.rs?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -0,0 +1,18 @@\n+struct S {}\n+\n+impl S {\n+    fn foo(&mur Self) {}\n+    //~^ ERROR expected identifier, found keyword `Self`\n+    //~| ERROR expected one of `:`, `@`\n+    //~| ERROR the `Self` constructor can only be used with\n+    fn bar(&'static mur Self) {}\n+    //~^ ERROR unexpected lifetime\n+    //~| ERROR expected identifier, found keyword `Self`\n+    //~| ERROR expected one of `:`, `@`\n+    //~| ERROR the `Self` constructor can only be used with\n+\n+    fn baz(&mur Self @ _) {}\n+    //~^ ERROR expected one of `:`, `@`\n+}\n+\n+fn main() {}"}, {"sha": "421f145403623b70367271b1f10e92524bd48d35", "filename": "src/test/ui/parser/issue-70549-resolve-after-recovered-self-ctor.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Fparser%2Fissue-70549-resolve-after-recovered-self-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Fparser%2Fissue-70549-resolve-after-recovered-self-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-70549-resolve-after-recovered-self-ctor.stderr?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -0,0 +1,56 @@\n+error: expected identifier, found keyword `Self`\n+  --> $DIR/issue-70549-resolve-after-recovered-self-ctor.rs:4:17\n+   |\n+LL |     fn foo(&mur Self) {}\n+   |                 ^^^^ expected identifier, found keyword\n+\n+error: expected one of `:`, `@`, or `|`, found keyword `Self`\n+  --> $DIR/issue-70549-resolve-after-recovered-self-ctor.rs:4:17\n+   |\n+LL |     fn foo(&mur Self) {}\n+   |            -----^^^^\n+   |            |    |\n+   |            |    expected one of `:`, `@`, or `|`\n+   |            help: declare the type after the parameter binding: `<identifier>: <type>`\n+\n+error: unexpected lifetime `'static` in pattern\n+  --> $DIR/issue-70549-resolve-after-recovered-self-ctor.rs:8:13\n+   |\n+LL |     fn bar(&'static mur Self) {}\n+   |             ^^^^^^^ help: remove the lifetime\n+\n+error: expected identifier, found keyword `Self`\n+  --> $DIR/issue-70549-resolve-after-recovered-self-ctor.rs:8:25\n+   |\n+LL |     fn bar(&'static mur Self) {}\n+   |                         ^^^^ expected identifier, found keyword\n+\n+error: expected one of `:`, `@`, or `|`, found keyword `Self`\n+  --> $DIR/issue-70549-resolve-after-recovered-self-ctor.rs:8:25\n+   |\n+LL |     fn bar(&'static mur Self) {}\n+   |            -------------^^^^\n+   |            |            |\n+   |            |            expected one of `:`, `@`, or `|`\n+   |            help: declare the type after the parameter binding: `<identifier>: <type>`\n+\n+error: expected one of `:`, `@`, or `|`, found keyword `Self`\n+  --> $DIR/issue-70549-resolve-after-recovered-self-ctor.rs:14:17\n+   |\n+LL |     fn baz(&mur Self @ _) {}\n+   |                 ^^^^ expected one of `:`, `@`, or `|`\n+\n+error: the `Self` constructor can only be used with tuple or unit structs\n+  --> $DIR/issue-70549-resolve-after-recovered-self-ctor.rs:4:17\n+   |\n+LL |     fn foo(&mur Self) {}\n+   |                 ^^^^ help: use curly brackets: `Self { /* fields */ }`\n+\n+error: the `Self` constructor can only be used with tuple or unit structs\n+  --> $DIR/issue-70549-resolve-after-recovered-self-ctor.rs:8:25\n+   |\n+LL |     fn bar(&'static mur Self) {}\n+   |                         ^^^^ help: use curly brackets: `Self { /* fields */ }`\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "ea9be77a3e8b5bb85a54ad9b715d467c0d5e261f", "filename": "src/test/ui/regions/region-bounds-on-objects-and-type-parameters.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Fregions%2Fregion-bounds-on-objects-and-type-parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src%2Ftest%2Fui%2Fregions%2Fregion-bounds-on-objects-and-type-parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-bounds-on-objects-and-type-parameters.stderr?ref=75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "patch": "@@ -31,5 +31,5 @@ LL | struct Foo<'a,'b,'c> {\n \n error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0392, E0478.\n-For more information about an error, try `rustc --explain E0392`.\n+Some errors have detailed explanations: E0226, E0392, E0478.\n+For more information about an error, try `rustc --explain E0226`."}]}