{"sha": "4c30cb25642d2cd4b228554e768068ba07504797", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMzBjYjI1NjQyZDJjZDRiMjI4NTU0ZTc2ODA2OGJhMDc1MDQ3OTc=", "commit": {"author": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-16T09:21:42Z"}, "committer": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-16T09:21:42Z"}, "message": "rollup merge of #18976: bjz/rfc369-numerics", "tree": {"sha": "ea124407c05314a1862322b1fccc28ac21a3ba09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea124407c05314a1862322b1fccc28ac21a3ba09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c30cb25642d2cd4b228554e768068ba07504797", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c30cb25642d2cd4b228554e768068ba07504797", "html_url": "https://github.com/rust-lang/rust/commit/4c30cb25642d2cd4b228554e768068ba07504797", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c30cb25642d2cd4b228554e768068ba07504797/comments", "author": null, "committer": null, "parents": [{"sha": "42c77f4958fcd6c2238d883c49f52341e0631999", "url": "https://api.github.com/repos/rust-lang/rust/commits/42c77f4958fcd6c2238d883c49f52341e0631999", "html_url": "https://github.com/rust-lang/rust/commit/42c77f4958fcd6c2238d883c49f52341e0631999"}, {"sha": "d82a7ea57a69954dcc9b58869907a0a070ef432d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d82a7ea57a69954dcc9b58869907a0a070ef432d", "html_url": "https://github.com/rust-lang/rust/commit/d82a7ea57a69954dcc9b58869907a0a070ef432d"}], "stats": {"total": 1337, "additions": 580, "deletions": 757}, "files": [{"sha": "b7d4596b0febf528302f049be36cc40cc49a1888", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::from_str::FromStr;\n use std::fmt;\n+use std::str::FromStr;\n use regex::Regex;\n \n #[deriving(Clone, PartialEq)]"}, {"sha": "d49ff0258ab02917a6599986adbd28448bb4bd9e", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -22,7 +22,7 @@ extern crate regex;\n use std::os;\n use std::io;\n use std::io::fs;\n-use std::from_str::FromStr;\n+use std::str::FromStr;\n use getopts::{optopt, optflag, reqopt};\n use common::Config;\n use common::{Pretty, DebugInfoGdb, DebugInfoLldb, Codegen};"}, {"sha": "60ef76528e849cee43367fd53a7211d200c4ad00", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -12,8 +12,6 @@ use common::Config;\n use common;\n use util;\n \n-use std::from_str::FromStr;\n-\n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n     pub error_patterns: Vec<String> ,\n@@ -353,8 +351,8 @@ pub fn gdb_version_to_int(version_string: &str) -> int {\n         panic!(\"{}\", error_string);\n     }\n \n-    let major: int = FromStr::from_str(components[0]).expect(error_string);\n-    let minor: int = FromStr::from_str(components[1]).expect(error_string);\n+    let major: int = from_str(components[0]).expect(error_string);\n+    let minor: int = from_str(components[1]).expect(error_string);\n \n     return major * 1000 + minor;\n }\n@@ -364,6 +362,6 @@ pub fn lldb_version_to_int(version_string: &str) -> int {\n         \"Encountered LLDB version string with unexpected format: {}\",\n         version_string);\n     let error_string = error_string.as_slice();\n-    let major: int = FromStr::from_str(version_string).expect(error_string);\n+    let major: int = from_str(version_string).expect(error_string);\n     return major;\n }"}, {"sha": "b3bf554f30c0f1f299099b502a7414f8c9e0f401", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -3108,11 +3108,10 @@ then the expression completes.\n Some examples of call expressions:\n \n ```\n-# use std::from_str::FromStr;\n # fn add(x: int, y: int) -> int { 0 }\n \n let x: int = add(1, 2);\n-let pi: Option<f32> = FromStr::from_str(\"3.14\");\n+let pi: Option<f32> = from_str(\"3.14\");\n ```\n \n ### Lambda expressions"}, {"sha": "1b1b65bd560e16fb93b1fd73d6ece63a918f32b7", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -105,7 +105,7 @@ syn keyword rustTrait RawPtr\n syn keyword rustTrait Buffer Writer Reader Seek\n syn keyword rustTrait Str StrVector StrSlice\n syn keyword rustTrait IntoMaybeOwned StrAllocating UnicodeStrSlice\n-syn keyword rustTrait ToString IntoStr\n+syn keyword rustTrait ToString IntoString\n syn keyword rustTrait Tuple1 Tuple2 Tuple3 Tuple4\n syn keyword rustTrait Tuple5 Tuple6 Tuple7 Tuple8\n syn keyword rustTrait Tuple9 Tuple10 Tuple11 Tuple12"}, {"sha": "a2f89dfecbc1370bd6239e6770466a98fb554af9", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -73,6 +73,7 @@ pub use core::str::{CharSplitsN, AnyLines, MatchIndices, StrSplits};\n pub use core::str::{Utf16CodeUnits, eq_slice, is_utf8, is_utf16, Utf16Items};\n pub use core::str::{Utf16Item, ScalarValue, LoneSurrogate, utf16_items};\n pub use core::str::{truncate_utf16_at_nul, utf8_char_width, CharRange};\n+pub use core::str::{FromStr, from_str};\n pub use core::str::{Str, StrPrelude};\n pub use unicode::str::{UnicodeStrPrelude, Words, Graphemes, GraphemeIndices};\n "}, {"sha": "3c75198a368bffa4a72c02b9d19d3219d12785b4", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -25,7 +25,7 @@ use core::raw::Slice as RawSlice;\n use hash;\n use slice::CloneSliceAllocPrelude;\n use str;\n-use str::{CharRange, StrAllocating, MaybeOwned, Owned};\n+use str::{CharRange, FromStr, StrAllocating, MaybeOwned, Owned};\n use str::Slice as MaybeOwnedSlice; // So many `Slice`s...\n use vec::{DerefVec, Vec, as_vec};\n \n@@ -795,6 +795,33 @@ pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {\n     DerefString { x: as_vec(x.as_bytes()) }\n }\n \n+impl FromStr for String {\n+    #[inline]\n+    fn from_str(s: &str) -> Option<String> {\n+        Some(String::from_str(s))\n+    }\n+}\n+\n+/// Trait for converting a type to a string, consuming it in the process.\n+pub trait IntoString {\n+    /// Consume and convert to a string.\n+    fn into_string(self) -> String;\n+}\n+\n+/// A generic trait for converting a value to a string\n+pub trait ToString {\n+    /// Converts the value of `self` to an owned string\n+    fn to_string(&self) -> String;\n+}\n+\n+impl<T: fmt::Show> ToString for T {\n+    fn to_string(&self) -> String {\n+        let mut buf = Vec::<u8>::new();\n+        let _ = format_args!(|args| fmt::write(&mut buf, args), \"{}\", self);\n+        String::from_utf8(buf).unwrap()\n+    }\n+}\n+\n /// Unsafe operations\n #[unstable = \"waiting on raw module conventions\"]\n pub mod raw {\n@@ -860,7 +887,7 @@ mod tests {\n \n     use str;\n     use str::{Str, StrPrelude, Owned};\n-    use super::{as_string, String};\n+    use super::{as_string, String, ToString};\n     use vec::Vec;\n     use slice::CloneSliceAllocPrelude;\n \n@@ -1164,6 +1191,28 @@ mod tests {\n         assert_eq!(\"oob\", s[1..4]);\n     }\n \n+    #[test]\n+    fn test_simple_types() {\n+        assert_eq!(1i.to_string(), \"1\".to_string());\n+        assert_eq!((-1i).to_string(), \"-1\".to_string());\n+        assert_eq!(200u.to_string(), \"200\".to_string());\n+        assert_eq!(2u8.to_string(), \"2\".to_string());\n+        assert_eq!(true.to_string(), \"true\".to_string());\n+        assert_eq!(false.to_string(), \"false\".to_string());\n+        assert_eq!(().to_string(), \"()\".to_string());\n+        assert_eq!((\"hi\".to_string()).to_string(), \"hi\".to_string());\n+    }\n+\n+    #[test]\n+    fn test_vectors() {\n+        let x: Vec<int> = vec![];\n+        assert_eq!(x.to_string(), \"[]\".to_string());\n+        assert_eq!((vec![1i]).to_string(), \"[1]\".to_string());\n+        assert_eq!((vec![1i, 2, 3]).to_string(), \"[1, 2, 3]\".to_string());\n+        assert!((vec![vec![], vec![1i], vec![1i, 1]]).to_string() ==\n+               \"[[], [1], [1, 1]]\".to_string());\n+    }\n+\n     #[bench]\n     fn bench_with_capacity(b: &mut Bencher) {\n         b.iter(|| {"}, {"sha": "fdee089380bbb6b340cd262439e6de03a7ef7c69", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -1652,6 +1652,13 @@ impl<T> Vec<T> {\n     }\n }\n \n+impl<'a> fmt::FormatWriter for Vec<u8> {\n+    fn write(&mut self, buf: &[u8]) -> fmt::Result {\n+        self.push_all(buf);\n+        Ok(())\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     extern crate test;"}, {"sha": "e7b0f626bf8725d26118e84c2a0d6695911e222f", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -16,8 +16,8 @@\n \n use intrinsics;\n use mem;\n-use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n-use num::Float;\n+use num::{Float, FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n+use num::from_str_radix;\n use option::Option;\n \n pub const RADIX: uint = 2u;\n@@ -424,3 +424,10 @@ impl Float for f32 {\n         self * (value / 180.0f32)\n     }\n }\n+\n+#[inline]\n+#[allow(missing_docs)]\n+#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n+pub fn from_str_hex(src: &str) -> Option<f32> {\n+    from_str_radix(src, 16)\n+}"}, {"sha": "e82be19011073950dbde530693578feb588c2b6d", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -16,8 +16,8 @@\n \n use intrinsics;\n use mem;\n-use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n-use num::Float;\n+use num::{Float, FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n+use num::from_str_radix;\n use option::Option;\n \n // FIXME(#5527): These constants should be deprecated once associated\n@@ -430,3 +430,10 @@ impl Float for f64 {\n         self * (value / 180.0)\n     }\n }\n+\n+#[inline]\n+#[allow(missing_docs)]\n+#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n+pub fn from_str_hex(src: &str) -> Option<f64> {\n+    from_str_radix(src, 16)\n+}"}, {"sha": "f5505ff8e762519a448ded962091fcf0ebca08d6", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 288, "deletions": 1, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -14,18 +14,21 @@\n \n #![allow(missing_docs)]\n \n-use intrinsics;\n use {int, i8, i16, i32, i64};\n use {uint, u8, u16, u32, u64};\n use {f32, f64};\n+use char::Char;\n use clone::Clone;\n use cmp::{PartialEq, Eq};\n use cmp::{PartialOrd, Ord};\n+use intrinsics;\n+use iter::Iterator;\n use kinds::Copy;\n use mem::size_of;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::{Option, Some, None};\n+use str::{FromStr, from_str, StrPrelude};\n \n /// Simultaneous division and remainder\n #[inline]\n@@ -1372,6 +1375,290 @@ pub trait Float\n     fn to_radians(self) -> Self;\n }\n \n+/// A generic trait for converting a string with a radix (base) to a value\n+#[experimental = \"might need to return Result\"]\n+pub trait FromStrRadix {\n+    fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n+}\n+\n+/// A utility function that just calls FromStrRadix::from_str_radix.\n+#[experimental = \"might need to return Result\"]\n+pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n+    FromStrRadix::from_str_radix(str, radix)\n+}\n+\n+macro_rules! from_str_radix_float_impl {\n+    ($T:ty) => {\n+        #[experimental = \"might need to return Result\"]\n+        impl FromStr for $T {\n+            /// Convert a string in base 10 to a float.\n+            /// Accepts an optional decimal exponent.\n+            ///\n+            /// This function accepts strings such as\n+            ///\n+            /// * '3.14'\n+            /// * '+3.14', equivalent to '3.14'\n+            /// * '-3.14'\n+            /// * '2.5E10', or equivalently, '2.5e10'\n+            /// * '2.5E-10'\n+            /// * '.' (understood as 0)\n+            /// * '5.'\n+            /// * '.5', or, equivalently,  '0.5'\n+            /// * '+inf', 'inf', '-inf', 'NaN'\n+            ///\n+            /// Leading and trailing whitespace represent an error.\n+            ///\n+            /// # Arguments\n+            ///\n+            /// * src - A string\n+            ///\n+            /// # Return value\n+            ///\n+            /// `None` if the string did not represent a valid number.  Otherwise,\n+            /// `Some(n)` where `n` is the floating-point number represented by `src`.\n+            #[inline]\n+            fn from_str(src: &str) -> Option<$T> {\n+                from_str_radix(src, 10)\n+            }\n+        }\n+\n+        #[experimental = \"might need to return Result\"]\n+        impl FromStrRadix for $T {\n+            /// Convert a string in a given base to a float.\n+            ///\n+            /// Due to possible conflicts, this function does **not** accept\n+            /// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+            /// does it recognize exponents of any kind.\n+            ///\n+            /// Leading and trailing whitespace represent an error.\n+            ///\n+            /// # Arguments\n+            ///\n+            /// * src - A string\n+            /// * radix - The base to use. Must lie in the range [2 .. 36]\n+            ///\n+            /// # Return value\n+            ///\n+            /// `None` if the string did not represent a valid number. Otherwise,\n+            /// `Some(n)` where `n` is the floating-point number represented by `src`.\n+            fn from_str_radix(src: &str, radix: uint) -> Option<$T> {\n+               assert!(radix >= 2 && radix <= 36,\n+                       \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n+                       radix);\n+\n+                // Special values\n+                match src {\n+                    \"inf\"   => return Some(Float::infinity()),\n+                    \"-inf\"  => return Some(Float::neg_infinity()),\n+                    \"NaN\"   => return Some(Float::nan()),\n+                    _       => {},\n+                }\n+\n+                let (is_positive, src) =  match src.slice_shift_char() {\n+                    (None, _)        => return None,\n+                    (Some('-'), \"\")  => return None,\n+                    (Some('-'), src) => (false, src),\n+                    (Some(_), _)     => (true,  src),\n+                };\n+\n+                // The significand to accumulate\n+                let mut sig = if is_positive { 0.0 } else { -0.0 };\n+                // Necessary to detect overflow\n+                let mut prev_sig = sig;\n+                let mut cs = src.chars().enumerate();\n+                // Exponent prefix and exponent index offset\n+                let mut exp_info = None::<(char, uint)>;\n+\n+                // Parse the integer part of the significand\n+                for (i, c) in cs {\n+                    match c.to_digit(radix) {\n+                        Some(digit) => {\n+                            // shift significand one digit left\n+                            sig = sig * (radix as $T);\n+\n+                            // add/subtract current digit depending on sign\n+                            if is_positive {\n+                                sig = sig + ((digit as int) as $T);\n+                            } else {\n+                                sig = sig - ((digit as int) as $T);\n+                            }\n+\n+                            // Detect overflow by comparing to last value, except\n+                            // if we've not seen any non-zero digits.\n+                            if prev_sig != 0.0 {\n+                                if is_positive && sig <= prev_sig\n+                                    { return Some(Float::infinity()); }\n+                                if !is_positive && sig >= prev_sig\n+                                    { return Some(Float::neg_infinity()); }\n+\n+                                // Detect overflow by reversing the shift-and-add process\n+                                if is_positive && (prev_sig != (sig - digit as $T) / radix as $T)\n+                                    { return Some(Float::infinity()); }\n+                                if !is_positive && (prev_sig != (sig + digit as $T) / radix as $T)\n+                                    { return Some(Float::neg_infinity()); }\n+                            }\n+                            prev_sig = sig;\n+                        },\n+                        None => match c {\n+                            'e' | 'E' | 'p' | 'P' => {\n+                                exp_info = Some((c, i + 1));\n+                                break;  // start of exponent\n+                            },\n+                            '.' => {\n+                                break;  // start of fractional part\n+                            },\n+                            _ => {\n+                                return None;\n+                            },\n+                        },\n+                    }\n+                }\n+\n+                // If we are not yet at the exponent parse the fractional\n+                // part of the significand\n+                if exp_info.is_none() {\n+                    let mut power = 1.0;\n+                    for (i, c) in cs {\n+                        match c.to_digit(radix) {\n+                            Some(digit) => {\n+                                // Decrease power one order of magnitude\n+                                power = power / (radix as $T);\n+                                // add/subtract current digit depending on sign\n+                                sig = if is_positive {\n+                                    sig + (digit as $T) * power\n+                                } else {\n+                                    sig - (digit as $T) * power\n+                                };\n+                                // Detect overflow by comparing to last value\n+                                if is_positive && sig < prev_sig\n+                                    { return Some(Float::infinity()); }\n+                                if !is_positive && sig > prev_sig\n+                                    { return Some(Float::neg_infinity()); }\n+                                prev_sig = sig;\n+                            },\n+                            None => match c {\n+                                'e' | 'E' | 'p' | 'P' => {\n+                                    exp_info = Some((c, i + 1));\n+                                    break; // start of exponent\n+                                },\n+                                _ => {\n+                                    return None; // invalid number\n+                                },\n+                            },\n+                        }\n+                    }\n+                }\n+\n+                // Parse and calculate the exponent\n+                let exp = match exp_info {\n+                    Some((c, offset)) => {\n+                        let base = match c {\n+                            'E' | 'e' if radix == 10 => 10u as $T,\n+                            'P' | 'p' if radix == 16 => 2u as $T,\n+                            _ => return None,\n+                        };\n+\n+                        // Parse the exponent as decimal integer\n+                        let src = src[offset..];\n+                        let (is_positive, exp) = match src.slice_shift_char() {\n+                            (Some('-'), src) => (false, from_str::<uint>(src)),\n+                            (Some('+'), src) => (true,  from_str::<uint>(src)),\n+                            (Some(_), _)     => (true,  from_str::<uint>(src)),\n+                            (None, _)        => return None,\n+                        };\n+\n+                        match (is_positive, exp) {\n+                            (true,  Some(exp)) => base.powi(exp as i32),\n+                            (false, Some(exp)) => 1.0 / base.powi(exp as i32),\n+                            (_, None)          => return None,\n+                        }\n+                    },\n+                    None => 1.0, // no exponent\n+                };\n+\n+                Some(sig * exp)\n+            }\n+        }\n+    }\n+}\n+from_str_radix_float_impl!(f32)\n+from_str_radix_float_impl!(f64)\n+\n+macro_rules! from_str_radix_int_impl {\n+    ($T:ty) => {\n+        #[experimental = \"might need to return Result\"]\n+        impl FromStr for $T {\n+            #[inline]\n+            fn from_str(src: &str) -> Option<$T> {\n+                from_str_radix(src, 10)\n+            }\n+        }\n+\n+        #[experimental = \"might need to return Result\"]\n+        impl FromStrRadix for $T {\n+            fn from_str_radix(src: &str, radix: uint) -> Option<$T> {\n+                assert!(radix >= 2 && radix <= 36,\n+                       \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n+                       radix);\n+\n+                let is_signed_ty = (0 as $T) > Int::min_value();\n+\n+                match src.slice_shift_char() {\n+                    (Some('-'), src) if is_signed_ty => {\n+                        // The number is negative\n+                        let mut result = 0;\n+                        for c in src.chars() {\n+                            let x = match c.to_digit(radix) {\n+                                Some(x) => x,\n+                                None => return None,\n+                            };\n+                            result = match result.checked_mul(radix as $T) {\n+                                Some(result) => result,\n+                                None => return None,\n+                            };\n+                            result = match result.checked_sub(x as $T) {\n+                                Some(result) => result,\n+                                None => return None,\n+                            };\n+                        }\n+                        Some(result)\n+                    },\n+                    (Some(_), _) => {\n+                        // The number is signed\n+                        let mut result = 0;\n+                        for c in src.chars() {\n+                            let x = match c.to_digit(radix) {\n+                                Some(x) => x,\n+                                None => return None,\n+                            };\n+                            result = match result.checked_mul(radix as $T) {\n+                                Some(result) => result,\n+                                None => return None,\n+                            };\n+                            result = match result.checked_add(x as $T) {\n+                                Some(result) => result,\n+                                None => return None,\n+                            };\n+                        }\n+                        Some(result)\n+                    },\n+                    (None, _) => None,\n+                }\n+            }\n+        }\n+    }\n+}\n+from_str_radix_int_impl!(int)\n+from_str_radix_int_impl!(i8)\n+from_str_radix_int_impl!(i16)\n+from_str_radix_int_impl!(i32)\n+from_str_radix_int_impl!(i64)\n+from_str_radix_int_impl!(uint)\n+from_str_radix_int_impl!(u8)\n+from_str_radix_int_impl!(u16)\n+from_str_radix_int_impl!(u32)\n+from_str_radix_int_impl!(u64)\n+\n // DEPRECATED\n \n macro_rules! trait_impl {"}, {"sha": "101eb7ac74cdbdf4208742bacd194c87c95ea1c6", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -41,6 +41,7 @@ pub use ops::{Fn, FnMut, FnOnce};\n // Reexported functions\n pub use iter::{range, repeat};\n pub use mem::drop;\n+pub use str::from_str;\n \n // Reexported types and traits\n "}, {"sha": "ab4e50c58d9a45a87ad462a9c287178052c02a49", "filename": "src/libcore/str.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -31,6 +31,42 @@ use raw::Repr;\n use slice::{mod, SlicePrelude};\n use uint;\n \n+/// A trait to abstract the idea of creating a new instance of a type from a\n+/// string.\n+#[experimental = \"might need to return Result\"]\n+pub trait FromStr {\n+    /// Parses a string `s` to return an optional value of this type. If the\n+    /// string is ill-formatted, the None is returned.\n+    fn from_str(s: &str) -> Option<Self>;\n+}\n+\n+/// A utility function that just calls FromStr::from_str\n+pub fn from_str<A: FromStr>(s: &str) -> Option<A> {\n+    FromStr::from_str(s)\n+}\n+\n+impl FromStr for bool {\n+    /// Parse a `bool` from a string.\n+    ///\n+    /// Yields an `Option<bool>`, because `s` may or may not actually be parseable.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert_eq!(from_str::<bool>(\"true\"), Some(true));\n+    /// assert_eq!(from_str::<bool>(\"false\"), Some(false));\n+    /// assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n+    /// ```\n+    #[inline]\n+    fn from_str(s: &str) -> Option<bool> {\n+        match s {\n+            \"true\"  => Some(true),\n+            \"false\" => Some(false),\n+            _       => None,\n+        }\n+    }\n+}\n+\n /*\n Section: Creating a string\n */"}, {"sha": "e25f10bd0dad531b0df7590bca75ff5ed9788776", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -15,7 +15,8 @@ macro_rules! int_module (($T:ty, $T_i:ident) => (\n mod tests {\n     use core::$T_i::*;\n     use core::int;\n-    use core::num::{Int, SignedInt};\n+    use core::num::{FromStrRadix, Int, SignedInt};\n+    use core::str::from_str;\n     use num;\n \n     #[test]\n@@ -156,6 +157,49 @@ mod tests {\n         assert!(5i.checked_div(0) == None);\n         assert!(int::MIN.checked_div(-1) == None);\n     }\n+\n+    #[test]\n+    fn test_from_str() {\n+        assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n+        assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n+        assert_eq!(from_str::<$T>(\"10\"), Some(10 as $T));\n+        assert_eq!(from_str::<i32>(\"123456789\"), Some(123456789 as i32));\n+        assert_eq!(from_str::<$T>(\"00100\"), Some(100 as $T));\n+\n+        assert_eq!(from_str::<$T>(\"-1\"), Some(-1 as $T));\n+        assert_eq!(from_str::<$T>(\"-3\"), Some(-3 as $T));\n+        assert_eq!(from_str::<$T>(\"-10\"), Some(-10 as $T));\n+        assert_eq!(from_str::<i32>(\"-123456789\"), Some(-123456789 as i32));\n+        assert_eq!(from_str::<$T>(\"-00100\"), Some(-100 as $T));\n+\n+        assert_eq!(from_str::<$T>(\"\"), None);\n+        assert_eq!(from_str::<$T>(\" \"), None);\n+        assert_eq!(from_str::<$T>(\"x\"), None);\n+    }\n+\n+    #[test]\n+    fn test_from_str_radix() {\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Some(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Some(35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Some(-123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Some(-9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Some(-83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Some(-291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Some(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Some(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Some(-35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Some(-35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2), None::<$T>);\n+    }\n }\n \n ))"}, {"sha": "0cd1ded21d6c6cdd269a12e5b3c6209ff0bae9a4", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -45,3 +45,73 @@ pub fn test_num<T>(ten: T, two: T) where\n     assert_eq!(ten.div(&two),  ten / two);\n     assert_eq!(ten.rem(&two),  ten % two);\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use core::option::{Option, Some, None};\n+    use core::num::Float;\n+    use core::num::from_str_radix;\n+\n+    #[test]\n+    fn from_str_issue7588() {\n+        let u : Option<u8> = from_str_radix(\"1000\", 10);\n+        assert_eq!(u, None);\n+        let s : Option<i16> = from_str_radix(\"80000\", 10);\n+        assert_eq!(s, None);\n+        let f : Option<f32> = from_str_radix(\"10000000000000000000000000000000000000000\", 10);\n+        assert_eq!(f, Some(Float::infinity()))\n+        let fe : Option<f32> = from_str_radix(\"1e40\", 10);\n+        assert_eq!(fe, Some(Float::infinity()))\n+    }\n+\n+    #[test]\n+    fn test_from_str_radix_float() {\n+        let x1 : Option<f64> = from_str_radix(\"-123.456\", 10);\n+        assert_eq!(x1, Some(-123.456));\n+        let x2 : Option<f32> = from_str_radix(\"123.456\", 10);\n+        assert_eq!(x2, Some(123.456));\n+        let x3 : Option<f32> = from_str_radix(\"-0.0\", 10);\n+        assert_eq!(x3, Some(-0.0));\n+        let x4 : Option<f32> = from_str_radix(\"0.0\", 10);\n+        assert_eq!(x4, Some(0.0));\n+        let x4 : Option<f32> = from_str_radix(\"1.0\", 10);\n+        assert_eq!(x4, Some(1.0));\n+        let x5 : Option<f32> = from_str_radix(\"-1.0\", 10);\n+        assert_eq!(x5, Some(-1.0));\n+    }\n+\n+    #[test]\n+    fn test_int_from_str_overflow() {\n+        let mut i8_val: i8 = 127_i8;\n+        assert_eq!(from_str::<i8>(\"127\"), Some(i8_val));\n+        assert_eq!(from_str::<i8>(\"128\"), None);\n+\n+        i8_val += 1 as i8;\n+        assert_eq!(from_str::<i8>(\"-128\"), Some(i8_val));\n+        assert_eq!(from_str::<i8>(\"-129\"), None);\n+\n+        let mut i16_val: i16 = 32_767_i16;\n+        assert_eq!(from_str::<i16>(\"32767\"), Some(i16_val));\n+        assert_eq!(from_str::<i16>(\"32768\"), None);\n+\n+        i16_val += 1 as i16;\n+        assert_eq!(from_str::<i16>(\"-32768\"), Some(i16_val));\n+        assert_eq!(from_str::<i16>(\"-32769\"), None);\n+\n+        let mut i32_val: i32 = 2_147_483_647_i32;\n+        assert_eq!(from_str::<i32>(\"2147483647\"), Some(i32_val));\n+        assert_eq!(from_str::<i32>(\"2147483648\"), None);\n+\n+        i32_val += 1 as i32;\n+        assert_eq!(from_str::<i32>(\"-2147483648\"), Some(i32_val));\n+        assert_eq!(from_str::<i32>(\"-2147483649\"), None);\n+\n+        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n+        assert_eq!(from_str::<i64>(\"9223372036854775807\"), Some(i64_val));\n+        assert_eq!(from_str::<i64>(\"9223372036854775808\"), None);\n+\n+        i64_val += 1 as i64;\n+        assert_eq!(from_str::<i64>(\"-9223372036854775808\"), Some(i64_val));\n+        assert_eq!(from_str::<i64>(\"-9223372036854775809\"), None);\n+    }\n+}"}, {"sha": "5f44fd807ccae726d3ecf852129b9f777565dbc6", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -8,6 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[test]\n+fn test_bool_from_str() {\n+    assert_eq!(from_str::<bool>(\"true\"), Some(true));\n+    assert_eq!(from_str::<bool>(\"false\"), Some(false));\n+    assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n+}\n+\n fn check_contains_all_substrings(s: &str) {\n     assert!(s.contains(\"\"));\n     for i in range(0, s.len()) {"}, {"sha": "c7540852970d8ca9a2ea42636fa1e2a324ddb9df", "filename": "src/libregex/re.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -10,7 +10,6 @@\n \n use std::collections::HashMap;\n use std::fmt;\n-use std::from_str::from_str;\n use std::str::{MaybeOwned, Owned, Slice};\n \n use compile::Program;"}, {"sha": "10cf92e32c3aa07516f05788033b313635f3f542", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -334,8 +334,7 @@ macro_rules! cgoptions(\n         }\n \n         fn parse_uint(slot: &mut uint, v: Option<&str>) -> bool {\n-            use std::from_str::FromStr;\n-            match v.and_then(FromStr::from_str) {\n+            match v.and_then(from_str) {\n                 Some(i) => { *slot = i; true },\n                 None => false\n             }"}, {"sha": "7b6de088319f4fcc3bab7fcc7241e66b4ea30276", "filename": "src/librustc/driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibrustc%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibrustc%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fpretty.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -31,8 +31,8 @@ use syntax::print::{pp, pprust};\n use graphviz as dot;\n \n use std::io::{mod, MemReader};\n-use std::from_str::FromStr;\n use std::option;\n+use std::str::FromStr;\n use arena::TypedArena;\n \n #[deriving(PartialEq, Show)]"}, {"sha": "a074d6f43b97baf8444b3e346329b79cb7bf0e0d", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -200,7 +200,7 @@ use std::{char, f64, fmt, io, num, str};\n use std::io::MemWriter;\n use std::mem::{swap, transmute};\n use std::num::{Float, FPNaN, FPInfinite, Int};\n-use std::str::ScalarValue;\n+use std::str::{FromStr, ScalarValue};\n use std::string;\n use std::vec::Vec;\n use std::ops;\n@@ -1988,7 +1988,7 @@ macro_rules! read_primitive {\n                 String(s) => {\n                     // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                     // is going to have a string here, as per JSON spec.\n-                    match std::from_str::from_str(s.as_slice()) {\n+                    match std::str::from_str(s.as_slice()) {\n                         Some(f) => Ok(f),\n                         None => Err(ExpectedError(\"Number\".to_string(), s)),\n                     }\n@@ -2027,7 +2027,7 @@ impl ::Decoder<DecoderError> for Decoder {\n             String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n-                match std::from_str::from_str(s.as_slice()) {\n+                match std::str::from_str(s.as_slice()) {\n                     Some(f) => Ok(f),\n                     None => Err(ExpectedError(\"Number\".to_string(), s)),\n                 }\n@@ -2399,7 +2399,7 @@ impl fmt::Show for Json {\n     }\n }\n \n-impl std::from_str::FromStr for Json {\n+impl FromStr for Json {\n     fn from_str(s: &str) -> Option<Json> {\n         from_str(s).ok()\n     }\n@@ -2484,7 +2484,7 @@ mod tests {\n     #[test]\n     fn test_from_str_trait() {\n         let s = \"null\";\n-        assert!(::std::from_str::from_str::<Json>(s).unwrap() == from_str(s).unwrap());\n+        assert!(::std::str::from_str::<Json>(s).unwrap() == from_str(s).unwrap());\n     }\n \n     #[test]"}, {"sha": "923349b1bf74089ba378064d222e9e8e56cf0b02", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -21,8 +21,7 @@ use mem;\n use option::{Option, Some, None};\n use slice::{SlicePrelude, AsSlice};\n use str::{Str, StrPrelude};\n-use string::{mod, String};\n-use to_string::IntoStr;\n+use string::{mod, String, IntoString};\n use vec::Vec;\n \n /// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n@@ -326,7 +325,7 @@ impl AsciiStr for [Ascii] {\n     }\n }\n \n-impl IntoStr for Vec<Ascii> {\n+impl IntoString for Vec<Ascii> {\n     #[inline]\n     fn into_string(self) -> String {\n         unsafe {"}, {"sha": "21b1e0560a5dba49ff6d0b715196d0f4d91ba957", "filename": "src/libstd/from_str.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibstd%2Ffrom_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibstd%2Ffrom_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffrom_str.rs?ref=42c77f4958fcd6c2238d883c49f52341e0631999", "patch": "@@ -1,71 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The `FromStr` trait for types that can be created from strings\n-\n-#![experimental]\n-\n-use option::{Option, Some, None};\n-use string::String;\n-\n-/// A trait to abstract the idea of creating a new instance of a type from a\n-/// string.\n-#[experimental = \"might need to return Result\"]\n-pub trait FromStr {\n-    /// Parses a string `s` to return an optional value of this type. If the\n-    /// string is ill-formatted, the None is returned.\n-    fn from_str(s: &str) -> Option<Self>;\n-}\n-\n-/// A utility function that just calls FromStr::from_str\n-pub fn from_str<A: FromStr>(s: &str) -> Option<A> {\n-    FromStr::from_str(s)\n-}\n-\n-impl FromStr for bool {\n-    /// Parse a `bool` from a string.\n-    ///\n-    /// Yields an `Option<bool>`, because `s` may or may not actually be parseable.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(from_str::<bool>(\"true\"), Some(true));\n-    /// assert_eq!(from_str::<bool>(\"false\"), Some(false));\n-    /// assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n-    /// ```\n-    #[inline]\n-    fn from_str(s: &str) -> Option<bool> {\n-        match s {\n-            \"true\"  => Some(true),\n-            \"false\" => Some(false),\n-            _       => None,\n-        }\n-    }\n-}\n-\n-impl FromStr for String {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<String> {\n-        Some(String::from_str(s))\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::*;\n-\n-    #[test]\n-    fn test_bool_from_str() {\n-        assert_eq!(from_str::<bool>(\"true\"), Some(true));\n-        assert_eq!(from_str::<bool>(\"false\"), Some(false));\n-        assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n-    }\n-}"}, {"sha": "7ba5e173182e165c8061357365200849c66183df", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -16,13 +16,12 @@\n #![allow(missing_docs)]\n \n use fmt;\n-use from_str::FromStr;\n use io::{mod, IoResult, IoError};\n use io::net;\n use iter::Iterator;\n use option::{Option, None, Some};\n use result::{Ok, Err};\n-use str::StrPrelude;\n+use str::{FromStr, StrPrelude};\n use slice::{CloneSlicePrelude, SlicePrelude};\n use vec::Vec;\n \n@@ -540,7 +539,7 @@ impl<'a> ToSocketAddr for &'a str {\n mod test {\n     use prelude::*;\n     use super::*;\n-    use from_str::FromStr;\n+    use str::FromStr;\n \n     #[test]\n     fn test_from_str_ipv4() {"}, {"sha": "612613134d448e95d3517ea40f21be39351a1e2c", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -54,7 +54,7 @@\n //!\n //! For converting to strings use the [`format!`](fmt/index.html)\n //! macro, and for converting from strings use the\n-//! [`FromStr`](from_str/index.html) trait.\n+//! [`FromStr`](str/trait.FromStr.html) trait.\n //!\n //! ## Platform abstractions\n //!\n@@ -219,9 +219,7 @@ pub mod time;\n /* Common traits */\n \n pub mod error;\n-pub mod from_str;\n pub mod num;\n-pub mod to_string;\n \n /* Common data structures */\n "}, {"sha": "207fa6499309c43ceac08ae53569aa1e7df7e9e4", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -17,12 +17,10 @@\n \n use prelude::*;\n \n-use from_str::FromStr;\n use intrinsics;\n use libc::c_int;\n use num::{Float, FloatMath};\n use num::strconv;\n-use num;\n \n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f32::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -339,68 +337,6 @@ pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     r\n }\n \n-#[inline]\n-#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n-pub fn from_str_hex(src: &str) -> Option<f32> {\n-    strconv::from_str_radix_float(src, 16)\n-}\n-\n-impl FromStr for f32 {\n-    /// Convert a string in base 10 to a float.\n-    /// Accepts an optional decimal exponent.\n-    ///\n-    /// This function accepts strings such as\n-    ///\n-    /// * '3.14'\n-    /// * '+3.14', equivalent to '3.14'\n-    /// * '-3.14'\n-    /// * '2.5E10', or equivalently, '2.5e10'\n-    /// * '2.5E-10'\n-    /// * '.' (understood as 0)\n-    /// * '5.'\n-    /// * '.5', or, equivalently,  '0.5'\n-    /// * '+inf', 'inf', '-inf', 'NaN'\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    ///\n-    /// # Return value\n-    ///\n-    /// `None` if the string did not represent a valid number.  Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str(src: &str) -> Option<f32> {\n-        strconv::from_str_radix_float(src, 10u)\n-    }\n-}\n-\n-impl num::FromStrRadix for f32 {\n-    /// Convert a string in a given base to a float.\n-    ///\n-    /// Due to possible conflicts, this function does **not** accept\n-    /// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n-    /// does it recognize exponents of any kind.\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    /// * radix - The base to use. Must lie in the range [2 .. 36]\n-    ///\n-    /// # Return value\n-    ///\n-    /// `None` if the string did not represent a valid number. Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str_radix(src: &str, radix: uint) -> Option<f32> {\n-        strconv::from_str_radix_float(src, radix)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use f32::*;"}, {"sha": "543d50596e8ce00402a5d287ecf2e062ad273c42", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -16,12 +16,10 @@\n \n use prelude::*;\n \n-use from_str::FromStr;\n use intrinsics;\n use libc::c_int;\n use num::{Float, FloatMath};\n use num::strconv;\n-use num;\n \n pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f64::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -347,63 +345,6 @@ pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n     r\n }\n \n-#[inline]\n-#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n-pub fn from_str_hex(src: &str) -> Option<f64> {\n-    strconv::from_str_radix_float(src, 16)\n-}\n-\n-impl FromStr for f64 {\n-    /// Convert a string in base 10 to a float.\n-    /// Accepts an optional decimal exponent.\n-    ///\n-    /// This function accepts strings such as:\n-    ///\n-    /// * '3.14'\n-    /// * '-3.14'\n-    /// * '2.5E10', or equivalently, '2.5e10'\n-    /// * '2.5E-10'\n-    /// * '.' (understood as 0)\n-    /// * '5.'\n-    /// * '.5', or, equivalently,  '0.5'\n-    /// * inf', '-inf', 'NaN'\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    ///\n-    /// # Return value\n-    ///\n-    /// `none` if the string did not represent a valid number.  Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str(src: &str) -> Option<f64> {\n-        strconv::from_str_radix_float(src, 10u)\n-    }\n-}\n-\n-impl num::FromStrRadix for f64 {\n-    /// Convert a string in a given base to a float.\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    /// * radix - The base to use. Must lie in the range [2 .. 36]\n-    ///\n-    /// # Return value\n-    ///\n-    /// `None` if the string did not represent a valid number. Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str_radix(src: &str, radix: uint) -> Option<f64> {\n-        strconv::from_str_radix_float(src, radix)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use f64::*;"}, {"sha": "6455c10736a3fe8dc1beda48341339d60041d7aa", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"i16\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::i16::{BITS, BYTES, MIN, MAX};\n \n int_module!(i16)"}, {"sha": "39b179c8274eb01c07efc2c8e47cfaececfc636f", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"i32\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::i32::{BITS, BYTES, MIN, MAX};\n \n int_module!(i32)"}, {"sha": "a0c474c479ae409e6d1abf0d36bd9e2524e4e887", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"i64\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::i64::{BITS, BYTES, MIN, MAX};\n \n int_module!(i64)"}, {"sha": "e911ed1de9ac4e29a8eb2319bdb862375048461b", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"i8\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::i8::{BITS, BYTES, MIN, MAX};\n \n int_module!(i8)"}, {"sha": "36c021efe0a3978f29389520c2c2d29b3763b220", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"int\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::int::{BITS, BYTES, MIN, MAX};\n \n int_module!(int)"}, {"sha": "2f1162d28e558797a0c4be6239f39a808263e7c6", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -14,131 +14,4 @@\n \n macro_rules! int_module (($T:ty) => (\n \n-#[experimental = \"might need to return Result\"]\n-impl FromStr for $T {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<$T> {\n-        strconv::from_str_radix_int(s, 10)\n-    }\n-}\n-\n-#[experimental = \"might need to return Result\"]\n-impl FromStrRadix for $T {\n-    #[inline]\n-    fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-        strconv::from_str_radix_int(s, radix)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use num::FromStrRadix;\n-\n-    #[test]\n-    fn test_from_str() {\n-        assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n-        assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n-        assert_eq!(from_str::<$T>(\"10\"), Some(10 as $T));\n-        assert_eq!(from_str::<i32>(\"123456789\"), Some(123456789 as i32));\n-        assert_eq!(from_str::<$T>(\"00100\"), Some(100 as $T));\n-\n-        assert_eq!(from_str::<$T>(\"-1\"), Some(-1 as $T));\n-        assert_eq!(from_str::<$T>(\"-3\"), Some(-3 as $T));\n-        assert_eq!(from_str::<$T>(\"-10\"), Some(-10 as $T));\n-        assert_eq!(from_str::<i32>(\"-123456789\"), Some(-123456789 as i32));\n-        assert_eq!(from_str::<$T>(\"-00100\"), Some(-100 as $T));\n-\n-        assert_eq!(from_str::<$T>(\"\"), None);\n-        assert_eq!(from_str::<$T>(\" \"), None);\n-        assert_eq!(from_str::<$T>(\"x\"), None);\n-    }\n-\n-    #[test]\n-    fn test_from_str_radix() {\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Some(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Some(35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Some(-123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Some(-9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Some(-83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Some(-291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Some(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Some(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Some(-35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Some(-35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35), None::<$T>);\n-        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2), None::<$T>);\n-    }\n-\n-    #[test]\n-    fn test_int_to_str_overflow() {\n-        let mut i8_val: i8 = 127_i8;\n-        assert_eq!(i8_val.to_string(), \"127\".to_string());\n-\n-        i8_val += 1 as i8;\n-        assert_eq!(i8_val.to_string(), \"-128\".to_string());\n-\n-        let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(i16_val.to_string(), \"32767\".to_string());\n-\n-        i16_val += 1 as i16;\n-        assert_eq!(i16_val.to_string(), \"-32768\".to_string());\n-\n-        let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(i32_val.to_string(), \"2147483647\".to_string());\n-\n-        i32_val += 1 as i32;\n-        assert_eq!(i32_val.to_string(), \"-2147483648\".to_string());\n-\n-        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(i64_val.to_string(), \"9223372036854775807\".to_string());\n-\n-        i64_val += 1 as i64;\n-        assert_eq!(i64_val.to_string(), \"-9223372036854775808\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_int_from_str_overflow() {\n-        let mut i8_val: i8 = 127_i8;\n-        assert_eq!(from_str::<i8>(\"127\"), Some(i8_val));\n-        assert_eq!(from_str::<i8>(\"128\"), None);\n-\n-        i8_val += 1 as i8;\n-        assert_eq!(from_str::<i8>(\"-128\"), Some(i8_val));\n-        assert_eq!(from_str::<i8>(\"-129\"), None);\n-\n-        let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(from_str::<i16>(\"32767\"), Some(i16_val));\n-        assert_eq!(from_str::<i16>(\"32768\"), None);\n-\n-        i16_val += 1 as i16;\n-        assert_eq!(from_str::<i16>(\"-32768\"), Some(i16_val));\n-        assert_eq!(from_str::<i16>(\"-32769\"), None);\n-\n-        let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(from_str::<i32>(\"2147483647\"), Some(i32_val));\n-        assert_eq!(from_str::<i32>(\"2147483648\"), None);\n-\n-        i32_val += 1 as i32;\n-        assert_eq!(from_str::<i32>(\"-2147483648\"), Some(i32_val));\n-        assert_eq!(from_str::<i32>(\"-2147483649\"), None);\n-\n-        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(from_str::<i64>(\"9223372036854775807\"), Some(i64_val));\n-        assert_eq!(from_str::<i64>(\"9223372036854775808\"), None);\n-\n-        i64_val += 1 as i64;\n-        assert_eq!(from_str::<i64>(\"-9223372036854775808\"), Some(i64_val));\n-        assert_eq!(from_str::<i64>(\"-9223372036854775809\"), None);\n-    }\n-}\n-\n ))"}, {"sha": "2ce6c0e6e71cd7647c6b1463d268d5e426757819", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -16,8 +16,6 @@\n #![experimental]\n #![allow(missing_docs)]\n \n-use option::Option;\n-\n #[cfg(test)] use cmp::PartialEq;\n #[cfg(test)] use fmt::Show;\n #[cfg(test)] use ops::{Add, Sub, Mul, Div, Rem};\n@@ -31,6 +29,7 @@ pub use core::num::{checked_next_power_of_two};\n pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n pub use core::num::{from_f32, from_f64};\n+pub use core::num::{FromStrRadix, from_str_radix};\n pub use core::num::{FPCategory, FPNaN, FPInfinite, FPZero, FPSubnormal};\n pub use core::num::{FPNormal, Float};\n \n@@ -115,18 +114,6 @@ pub trait FloatMath: Float {\n     fn atanh(self) -> Self;\n }\n \n-/// A generic trait for converting a string with a radix (base) to a value\n-#[experimental = \"might need to return Result\"]\n-pub trait FromStrRadix {\n-    fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n-}\n-\n-/// A utility function that just calls FromStrRadix::from_str_radix.\n-#[experimental = \"might need to return Result\"]\n-pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n-    FromStrRadix::from_str_radix(str, radix)\n-}\n-\n // DEPRECATED\n \n #[deprecated = \"Use `FloatMath::abs_sub`\"]\n@@ -764,8 +751,9 @@ mod tests {\n \n     #[test]\n     fn test_pow() {\n-        fn naive_pow<T: One + Mul<T, T>>(base: T, exp: uint) -> T {\n-            range(0, exp).fold(one::<T>(), |acc, _| acc * base)\n+        fn naive_pow<T: Int>(base: T, exp: uint) -> T {\n+            let one: T = Int::one();\n+            range(0, exp).fold(one, |acc, _| acc * base)\n         }\n         macro_rules! assert_pow(\n             (($num:expr, $exp:expr) => $expected:expr) => {{"}, {"sha": "d1a89d72621a7a9f8ba27729a35d35260d7e271c", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 21, "deletions": 232, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -13,12 +13,8 @@\n #![allow(missing_docs)]\n \n use char;\n-use char::Char;\n-use from_str::from_str;\n-use iter::Iterator;\n use num;\n use num::{Int, Float, FPNaN, FPInfinite, ToPrimitive};\n-use option::{None, Option, Some};\n use slice::{SlicePrelude, CloneSliceAllocPrelude};\n use str::StrPrelude;\n use string::String;\n@@ -425,242 +421,35 @@ pub fn float_to_str_common<T: Float>(\n static DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n \n-pub fn from_str_radix_float<T: Float>(src: &str, radix: uint) -> Option<T> {\n-   assert!(radix >= 2 && radix <= 36,\n-           \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n-           radix);\n-\n-    let _0: T = Float::zero();\n-    let _1: T = Float::one();\n-    let radix_t: T = num::cast(radix as int).unwrap();\n-\n-    // Special values\n-    match src {\n-        \"inf\"   => return Some(Float::infinity()),\n-        \"-inf\"  => return Some(Float::neg_infinity()),\n-        \"NaN\"   => return Some(Float::nan()),\n-        _       => {},\n-    }\n-\n-    let (is_positive, src) =  match src.slice_shift_char() {\n-        (None, _)        => return None,\n-        (Some('-'), \"\")  => return None,\n-        (Some('-'), src) => (false, src),\n-        (Some(_), _)     => (true,  src),\n-    };\n-\n-    // The significand to accumulate\n-    let mut sig = if is_positive { _0 } else { -_0 };\n-    // Necessary to detect overflow\n-    let mut prev_sig = sig;\n-    let mut cs = src.chars().enumerate();\n-    // Exponent prefix and exponent index offset\n-    let mut exp_info = None::<(char, uint)>;\n-\n-    // Parse the integer part of the significand\n-    for (i, c) in cs {\n-        match c.to_digit(radix) {\n-            Some(digit) => {\n-                // shift significand one digit left\n-                sig = sig * radix_t;\n-\n-                // add/subtract current digit depending on sign\n-                if is_positive {\n-                    sig = sig + num::cast(digit as int).unwrap();\n-                } else {\n-                    sig = sig - num::cast(digit as int).unwrap();\n-                }\n-\n-                // Detect overflow by comparing to last value, except\n-                // if we've not seen any non-zero digits.\n-                if prev_sig != _0 {\n-                    if is_positive && sig <= prev_sig\n-                        { return Some(Float::infinity()); }\n-                    if !is_positive && sig >= prev_sig\n-                        { return Some(Float::neg_infinity()); }\n-\n-                    // Detect overflow by reversing the shift-and-add process\n-                    let digit: T = num::cast(digit as int).unwrap();\n-                    if is_positive && (prev_sig != ((sig - digit) / radix_t))\n-                        { return Some(Float::infinity()); }\n-                    if !is_positive && (prev_sig != ((sig + digit) / radix_t))\n-                        { return Some(Float::neg_infinity()); }\n-                }\n-                prev_sig = sig;\n-            },\n-            None => match c {\n-                'e' | 'E' | 'p' | 'P' => {\n-                    exp_info = Some((c, i + 1));\n-                    break;  // start of exponent\n-                },\n-                '.' => {\n-                    break;  // start of fractional part\n-                },\n-                _ => {\n-                    return None;\n-                },\n-            },\n-        }\n-    }\n-\n-    // If we are not yet at the exponent parse the fractional\n-    // part of the significand\n-    if exp_info.is_none() {\n-        let mut power = _1;\n-        for (i, c) in cs {\n-            match c.to_digit(radix) {\n-                Some(digit) => {\n-                    let digit: T = num::cast(digit).unwrap();\n-                    // Decrease power one order of magnitude\n-                    power = power / radix_t;\n-                    // add/subtract current digit depending on sign\n-                    sig = if is_positive {\n-                        sig + digit * power\n-                    } else {\n-                        sig - digit * power\n-                    };\n-                    // Detect overflow by comparing to last value\n-                    if is_positive && sig < prev_sig\n-                        { return Some(Float::infinity()); }\n-                    if !is_positive && sig > prev_sig\n-                        { return Some(Float::neg_infinity()); }\n-                    prev_sig = sig;\n-                },\n-                None => match c {\n-                    'e' | 'E' | 'p' | 'P' => {\n-                        exp_info = Some((c, i + 1));\n-                        break; // start of exponent\n-                    },\n-                    _ => {\n-                        return None; // invalid number\n-                    },\n-                },\n-            }\n-        }\n-    }\n-\n-    // Parse and calculate the exponent\n-    let exp = match exp_info {\n-        Some((c, offset)) => {\n-            let base: T = match c {\n-                'E' | 'e' if radix == 10 => num::cast(10u).unwrap(),\n-                'P' | 'p' if radix == 16 => num::cast(2u).unwrap(),\n-                _ => return None,\n-            };\n-\n-            // Parse the exponent as decimal integer\n-            let src = src[offset..];\n-            let (is_positive, exp) = match src.slice_shift_char() {\n-                (Some('-'), src) => (false, from_str::<uint>(src)),\n-                (Some('+'), src) => (true,  from_str::<uint>(src)),\n-                (Some(_), _)     => (true,  from_str::<uint>(src)),\n-                (None, _)        => return None,\n-            };\n-\n-            match (is_positive, exp) {\n-                (true,  Some(exp)) => base.powi(exp as i32),\n-                (false, Some(exp)) => _1 / base.powi(exp as i32),\n-                (_, None)          => return None,\n-            }\n-        },\n-        None => _1, // no exponent\n-    };\n+#[cfg(test)]\n+mod tests {\n+    use string::ToString;\n \n-    Some(sig * exp)\n-}\n+    #[test]\n+    fn test_int_to_str_overflow() {\n+        let mut i8_val: i8 = 127_i8;\n+        assert_eq!(i8_val.to_string(), \"127\".to_string());\n \n-pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n-   assert!(radix >= 2 && radix <= 36,\n-           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n-           radix);\n+        i8_val += 1 as i8;\n+        assert_eq!(i8_val.to_string(), \"-128\".to_string());\n \n-    fn cast<T: Int>(x: uint) -> T {\n-        num::cast(x).unwrap()\n-    }\n+        let mut i16_val: i16 = 32_767_i16;\n+        assert_eq!(i16_val.to_string(), \"32767\".to_string());\n \n-    let _0: T = Int::zero();\n-    let _1: T = Int::one();\n-    let is_signed = _0 > Int::min_value();\n+        i16_val += 1 as i16;\n+        assert_eq!(i16_val.to_string(), \"-32768\".to_string());\n \n-    let (is_positive, src) =  match src.slice_shift_char() {\n-        (Some('-'), src) if is_signed => (false, src),\n-        (Some(_), _) => (true, src),\n-        (None, _) => return None,\n-    };\n+        let mut i32_val: i32 = 2_147_483_647_i32;\n+        assert_eq!(i32_val.to_string(), \"2147483647\".to_string());\n \n-    let mut xs = src.chars().map(|c| {\n-        c.to_digit(radix).map(cast)\n-    });\n-    let radix = cast(radix);\n-    let mut result = _0;\n-\n-    if is_positive {\n-        for x in xs {\n-            let x = match x {\n-                Some(x) => x,\n-                None => return None,\n-            };\n-            result = match result.checked_mul(radix) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-            result = match result.checked_add(x) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-        }\n-    } else {\n-        for x in xs {\n-            let x = match x {\n-                Some(x) => x,\n-                None => return None,\n-            };\n-            result = match result.checked_mul(radix) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-            result = match result.checked_sub(x) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-        }\n-    }\n+        i32_val += 1 as i32;\n+        assert_eq!(i32_val.to_string(), \"-2147483648\".to_string());\n \n-    Some(result)\n-}\n+        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n+        assert_eq!(i64_val.to_string(), \"9223372036854775807\".to_string());\n \n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use option::*;\n-    use num::Float;\n-\n-    #[test]\n-    fn from_str_issue7588() {\n-        let u : Option<u8> = from_str_radix_int(\"1000\", 10);\n-        assert_eq!(u, None);\n-        let s : Option<i16> = from_str_radix_int(\"80000\", 10);\n-        assert_eq!(s, None);\n-        let f : Option<f32> = from_str_radix_float(\"10000000000000000000000000000000000000000\", 10);\n-        assert_eq!(f, Some(Float::infinity()))\n-        let fe : Option<f32> = from_str_radix_float(\"1e40\", 10);\n-        assert_eq!(fe, Some(Float::infinity()))\n-    }\n-\n-    #[test]\n-    fn test_from_str_radix_float() {\n-        let x1 : Option<f64> = from_str_radix_float(\"-123.456\", 10);\n-        assert_eq!(x1, Some(-123.456));\n-        let x2 : Option<f32> = from_str_radix_float(\"123.456\", 10);\n-        assert_eq!(x2, Some(123.456));\n-        let x3 : Option<f32> = from_str_radix_float(\"-0.0\", 10);\n-        assert_eq!(x3, Some(-0.0));\n-        let x4 : Option<f32> = from_str_radix_float(\"0.0\", 10);\n-        assert_eq!(x4, Some(0.0));\n-        let x4 : Option<f32> = from_str_radix_float(\"1.0\", 10);\n-        assert_eq!(x4, Some(1.0));\n-        let x5 : Option<f32> = from_str_radix_float(\"-1.0\", 10);\n-        assert_eq!(x5, Some(-1.0));\n+        i64_val += 1 as i64;\n+        assert_eq!(i64_val.to_string(), \"-9223372036854775808\".to_string());\n     }\n }\n "}, {"sha": "246224ddb2b4eff7c3b98987f10d8dc57485bca9", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"u16\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::u16::{BITS, BYTES, MIN, MAX};\n \n uint_module!(u16)"}, {"sha": "143b45010c2548f3552e51acc91f4c398b3498b4", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"u32\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::u32::{BITS, BYTES, MIN, MAX};\n \n uint_module!(u32)"}, {"sha": "92c5380f980ea0d991a37150c801ec05a9dd6f8e", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"u64\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::u64::{BITS, BYTES, MIN, MAX};\n \n uint_module!(u64)"}, {"sha": "faa6d167065ce26a1de0bcf7e25b441293ba0906", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"u8\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::u8::{BITS, BYTES, MIN, MAX};\n \n uint_module!(u8)"}, {"sha": "a425aab3aa10c5529380d530eab152cebc010fcb", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"uint\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::uint::{BITS, BYTES, MIN, MAX};\n \n uint_module!(uint)"}, {"sha": "ef9e809ed2bcc3fbff2eee6c104ce5833ac0b2fb", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -15,22 +15,6 @@\n \n macro_rules! uint_module (($T:ty) => (\n \n-#[experimental = \"might need to return Result\"]\n-impl FromStr for $T {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<$T> {\n-        strconv::from_str_radix_int(s, 10)\n-    }\n-}\n-\n-#[experimental = \"might need to return Result\"]\n-impl FromStrRadix for $T {\n-    #[inline]\n-    fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-        strconv::from_str_radix_int(s, radix)\n-    }\n-}\n-\n // String conversion functions and impl num -> str\n \n /// Convert to a string as a byte slice in a given base."}, {"sha": "23e57a028de27efee45620e6b4a3ab6cda699a85", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -51,8 +51,7 @@ use result::{Err, Ok, Result};\n use slice::{AsSlice, SlicePrelude, PartialEqSlicePrelude};\n use slice::CloneSliceAllocPrelude;\n use str::{Str, StrPrelude, StrAllocating};\n-use string::String;\n-use to_string::ToString;\n+use string::{String, ToString};\n use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use vec::Vec;\n "}, {"sha": "e2ff824a7c98fb5010d585f58b264711d572060b", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -13,12 +13,11 @@\n use c_str::{CString, ToCStr};\n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n-use from_str::FromStr;\n use hash;\n use io::Writer;\n use iter::{DoubleEndedIterator, AdditiveIterator, Extend, Iterator, Map};\n use option::{Option, None, Some};\n-use str::Str;\n+use str::{FromStr, Str};\n use str;\n use slice::{CloneSliceAllocPrelude, Splits, AsSlice, VectorVector,\n             PartialEqSlicePrelude, SlicePrelude};"}, {"sha": "b8016e3e8f453b2fbcf41024e2b451fcfe54f74c", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -16,14 +16,13 @@ use ascii::AsciiCast;\n use c_str::{CString, ToCStr};\n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n-use from_str::FromStr;\n use hash;\n use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIterator, Extend, Iterator, Map};\n use mem;\n use option::{Option, Some, None};\n use slice::{AsSlice, SlicePrelude};\n-use str::{CharSplits, Str, StrAllocating, StrVector, StrPrelude};\n+use str::{CharSplits, FromStr, Str, StrAllocating, StrVector, StrPrelude};\n use string::String;\n use unicode::char::UnicodeChar;\n use vec::Vec;"}, {"sha": "a9e99940c4689d2e2944859d1ca37ebc8d722ddc", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -50,9 +50,9 @@\n #[doc(no_inline)] pub use ops::{Fn, FnMut, FnOnce};\n \n // Reexported functions\n-#[doc(no_inline)] pub use from_str::from_str;\n #[doc(no_inline)] pub use iter::{range, repeat};\n #[doc(no_inline)] pub use mem::drop;\n+#[doc(no_inline)] pub use str::from_str;\n \n // Reexported types and traits\n \n@@ -76,14 +76,13 @@\n #[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek, BufferPrelude};\n #[doc(no_inline)] pub use str::{Str, StrVector, StrPrelude};\n #[doc(no_inline)] pub use str::{IntoMaybeOwned, StrAllocating, UnicodeStrPrelude};\n-#[doc(no_inline)] pub use to_string::{ToString, IntoStr};\n #[doc(no_inline)] pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n #[doc(no_inline)] pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n #[doc(no_inline)] pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n #[doc(no_inline)] pub use slice::{SlicePrelude, AsSlice, CloneSlicePrelude};\n #[doc(no_inline)] pub use slice::{VectorVector, PartialEqSlicePrelude, OrdSlicePrelude};\n #[doc(no_inline)] pub use slice::{CloneSliceAllocPrelude, OrdSliceAllocPrelude, SliceAllocPrelude};\n-#[doc(no_inline)] pub use string::String;\n+#[doc(no_inline)] pub use string::{IntoString, String, ToString};\n #[doc(no_inline)] pub use vec::Vec;\n \n // Reexported runtime types"}, {"sha": "8b457d1639dc43857199b21f9c90fa413e3a6a6a", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -12,13 +12,12 @@\n \n #![allow(non_camel_case_types)]\n \n-use from_str::from_str;\n use io::{IoResult, Writer};\n use iter::Iterator;\n use option::{Some, None};\n use os;\n use result::{Ok, Err};\n-use str::StrPrelude;\n+use str::{StrPrelude, from_str};\n use sync::atomic;\n use unicode::char::UnicodeChar;\n "}, {"sha": "92657d1b59bee8723bcdbb57fdc363d08912ec0d", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use from_str::FromStr;\n-use from_str::from_str;\n use libc::uintptr_t;\n use option::{Some, None, Option};\n use os;\n-use str::Str;\n+use str::{FromStr, from_str, Str};\n use sync::atomic;\n \n /// Dynamically inquire about whether we're running under V."}, {"sha": "c7e31dae3d459c5d0dab78399d6fba4c29bac674", "filename": "src/libstd/task.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -105,9 +105,8 @@ use rt::local::Local;\n use rt::task;\n use rt::task::Task;\n use str::{Str, SendStr, IntoMaybeOwned};\n-use string::String;\n+use string::{String, ToString};\n use sync::Future;\n-use to_string::ToString;\n \n /// A means of spawning a task\n pub trait Spawner {"}, {"sha": "83340c9faac22d5b9d18bf5eff5291e32815a54a", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -388,7 +388,7 @@ mod tests {\n     use super::{Duration, MIN, MAX};\n     use {i32, i64};\n     use option::{Some, None};\n-    use to_string::ToString;\n+    use string::ToString;\n \n     #[test]\n     fn test_duration() {"}, {"sha": "c19fd81b5705667185f8a8a9391fca11a9114dba", "filename": "src/libstd/to_string.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibstd%2Fto_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c77f4958fcd6c2238d883c49f52341e0631999/src%2Flibstd%2Fto_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_string.rs?ref=42c77f4958fcd6c2238d883c49f52341e0631999", "patch": "@@ -1,66 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-The `ToString` trait for converting to strings\n-\n-*/\n-\n-#![experimental]\n-\n-use fmt;\n-use string::String;\n-\n-/// A generic trait for converting a value to a string\n-pub trait ToString {\n-    /// Converts the value of `self` to an owned string\n-    fn to_string(&self) -> String;\n-}\n-\n-/// Trait for converting a type to a string, consuming it in the process.\n-pub trait IntoStr {\n-    /// Consume and convert to a string.\n-    fn into_string(self) -> String;\n-}\n-\n-impl<T: fmt::Show> ToString for T {\n-    fn to_string(&self) -> String {\n-        format!(\"{}\", *self)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use super::*;\n-\n-    #[test]\n-    fn test_simple_types() {\n-        assert_eq!(1i.to_string(), \"1\".to_string());\n-        assert_eq!((-1i).to_string(), \"-1\".to_string());\n-        assert_eq!(200u.to_string(), \"200\".to_string());\n-        assert_eq!(2u8.to_string(), \"2\".to_string());\n-        assert_eq!(true.to_string(), \"true\".to_string());\n-        assert_eq!(false.to_string(), \"false\".to_string());\n-        assert_eq!(().to_string(), \"()\".to_string());\n-        assert_eq!((\"hi\".to_string()).to_string(), \"hi\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_vectors() {\n-        let x: Vec<int> = vec![];\n-        assert_eq!(x.to_string(), \"[]\".to_string());\n-        assert_eq!((vec![1i]).to_string(), \"[1]\".to_string());\n-        assert_eq!((vec![1i, 2, 3]).to_string(), \"[1, 2, 3]\".to_string());\n-        assert!((vec![vec![], vec![1i], vec![1i, 1]]).to_string() ==\n-               \"[[], [1], [1, 1]]\".to_string());\n-    }\n-}"}, {"sha": "ff96f806faccb336cb8a16f86247c3f6c50d4a4e", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -53,13 +53,13 @@ use std::cmp;\n use std::f64;\n use std::fmt::Show;\n use std::fmt;\n-use std::from_str::FromStr;\n use std::io::fs::PathExtensions;\n use std::io::stdio::StdWriter;\n use std::io::{File, ChanReader, ChanWriter};\n use std::io;\n use std::num::{Float, FloatMath, Int};\n use std::os;\n+use std::str::FromStr;\n use std::string::String;\n use std::task::TaskBuilder;\n use std::time::Duration;"}, {"sha": "a041bbfe8ad92ed706707edbba9d3e746750f01c", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -11,7 +11,7 @@\n // aux-build:cci_class_cast.rs\n extern crate cci_class_cast;\n \n-use std::to_string::ToString;\n+use std::string::ToString;\n use cci_class_cast::kitty::cat;\n \n fn print_out(thing: Box<ToString>, expected: String) {"}, {"sha": "0d88141984750fb8e5362a9e725c503e16670075", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c30cb25642d2cd4b228554e768068ba07504797/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30cb25642d2cd4b228554e768068ba07504797/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=4c30cb25642d2cd4b228554e768068ba07504797", "patch": "@@ -11,7 +11,7 @@\n extern crate collections;\n \n use std::str::{SendStr, Owned, Slice};\n-use std::to_string::ToString;\n+use std::string::ToString;\n use self::collections::TreeMap;\n use std::option::Some;\n "}]}