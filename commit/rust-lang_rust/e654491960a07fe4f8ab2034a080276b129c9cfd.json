{"sha": "e654491960a07fe4f8ab2034a080276b129c9cfd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NTQ0OTE5NjBhMDdmZTRmOGFiMjAzNGEwODAyNzZiMTI5YzljZmQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T08:04:00Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T17:26:42Z"}, "message": "rollup merge of #19926: eddyb/less-sty\n\nr? @nikomatsakis", "tree": {"sha": "4813ec872896a8e5ff54951d943f065758fc9301", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4813ec872896a8e5ff54951d943f065758fc9301"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e654491960a07fe4f8ab2034a080276b129c9cfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e654491960a07fe4f8ab2034a080276b129c9cfd", "html_url": "https://github.com/rust-lang/rust/commit/e654491960a07fe4f8ab2034a080276b129c9cfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e654491960a07fe4f8ab2034a080276b129c9cfd/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2af8155bee8614a4e3bd1831f8927652c7475cc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2af8155bee8614a4e3bd1831f8927652c7475cc5", "html_url": "https://github.com/rust-lang/rust/commit/2af8155bee8614a4e3bd1831f8927652c7475cc5"}, {"sha": "e0d44386d334e13677e2d43ad9365d6b24350780", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0d44386d334e13677e2d43ad9365d6b24350780", "html_url": "https://github.com/rust-lang/rust/commit/e0d44386d334e13677e2d43ad9365d6b24350780"}], "stats": {"total": 551, "additions": 259, "deletions": 292}, "files": [{"sha": "ce63c467822db76b070ba7b18f2691e668ab4006", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 97, "deletions": 100, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/e654491960a07fe4f8ab2034a080276b129c9cfd/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e654491960a07fe4f8ab2034a080276b129c9cfd/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=e654491960a07fe4f8ab2034a080276b129c9cfd", "patch": "@@ -55,7 +55,103 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         None => {}\n     }\n     let pos = w.tell().unwrap();\n-    enc_sty(w, cx, &t.sty);\n+\n+    match t.sty {\n+        ty::ty_bool => mywrite!(w, \"b\"),\n+        ty::ty_char => mywrite!(w, \"c\"),\n+        ty::ty_int(t) => {\n+            match t {\n+                ast::TyI => mywrite!(w, \"i\"),\n+                ast::TyI8 => mywrite!(w, \"MB\"),\n+                ast::TyI16 => mywrite!(w, \"MW\"),\n+                ast::TyI32 => mywrite!(w, \"ML\"),\n+                ast::TyI64 => mywrite!(w, \"MD\")\n+            }\n+        }\n+        ty::ty_uint(t) => {\n+            match t {\n+                ast::TyU => mywrite!(w, \"u\"),\n+                ast::TyU8 => mywrite!(w, \"Mb\"),\n+                ast::TyU16 => mywrite!(w, \"Mw\"),\n+                ast::TyU32 => mywrite!(w, \"Ml\"),\n+                ast::TyU64 => mywrite!(w, \"Md\")\n+            }\n+        }\n+        ty::ty_float(t) => {\n+            match t {\n+                ast::TyF32 => mywrite!(w, \"Mf\"),\n+                ast::TyF64 => mywrite!(w, \"MF\"),\n+            }\n+        }\n+        ty::ty_enum(def, ref substs) => {\n+            mywrite!(w, \"t[{}|\", (cx.ds)(def));\n+            enc_substs(w, cx, substs);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_trait(box ty::TyTrait { ref principal,\n+                                       ref bounds }) => {\n+            mywrite!(w, \"x[\");\n+            enc_trait_ref(w, cx, &principal.0);\n+            enc_existential_bounds(w, cx, bounds);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_tup(ref ts) => {\n+            mywrite!(w, \"T[\");\n+            for t in ts.iter() { enc_ty(w, cx, *t); }\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_uniq(typ) => { mywrite!(w, \"~\"); enc_ty(w, cx, typ); }\n+        ty::ty_ptr(mt) => { mywrite!(w, \"*\"); enc_mt(w, cx, mt); }\n+        ty::ty_rptr(r, mt) => {\n+            mywrite!(w, \"&\");\n+            enc_region(w, cx, r);\n+            enc_mt(w, cx, mt);\n+        }\n+        ty::ty_vec(t, sz) => {\n+            mywrite!(w, \"V\");\n+            enc_ty(w, cx, t);\n+            mywrite!(w, \"/\");\n+            match sz {\n+                Some(n) => mywrite!(w, \"{}|\", n),\n+                None => mywrite!(w, \"|\"),\n+            }\n+        }\n+        ty::ty_str => {\n+            mywrite!(w, \"v\");\n+        }\n+        ty::ty_closure(ref f) => {\n+            mywrite!(w, \"f\");\n+            enc_closure_ty(w, cx, &**f);\n+        }\n+        ty::ty_bare_fn(ref f) => {\n+            mywrite!(w, \"F\");\n+            enc_bare_fn_ty(w, cx, f);\n+        }\n+        ty::ty_infer(_) => {\n+            cx.diag.handler().bug(\"cannot encode inference variable types\");\n+        }\n+        ty::ty_param(ParamTy {space, idx: id, def_id: did}) => {\n+            mywrite!(w, \"p{}|{}|{}|\", (cx.ds)(did), id, space.to_uint())\n+        }\n+        ty::ty_struct(def, ref substs) => {\n+            mywrite!(w, \"a[{}|\", (cx.ds)(def));\n+            enc_substs(w, cx, substs);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_unboxed_closure(def, region, ref substs) => {\n+            mywrite!(w, \"k[{}|\", (cx.ds)(def));\n+            enc_region(w, cx, region);\n+            enc_substs(w, cx, substs);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_err => {\n+            mywrite!(w, \"e\");\n+        }\n+        ty::ty_open(_) => {\n+            cx.diag.handler().bug(\"unexpected type in enc_sty (ty_open)\");\n+        }\n+    }\n+\n     let end = w.tell().unwrap();\n     let len = end - pos;\n     fn estimate_sz(u: u64) -> u64 {\n@@ -214,105 +310,6 @@ pub fn enc_trait_store(w: &mut SeekableMemWriter, cx: &ctxt, s: ty::TraitStore)\n     }\n }\n \n-fn enc_sty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n-                     st: &ty::sty<'tcx>) {\n-    match *st {\n-        ty::ty_bool => mywrite!(w, \"b\"),\n-        ty::ty_char => mywrite!(w, \"c\"),\n-        ty::ty_int(t) => {\n-            match t {\n-                ast::TyI => mywrite!(w, \"i\"),\n-                ast::TyI8 => mywrite!(w, \"MB\"),\n-                ast::TyI16 => mywrite!(w, \"MW\"),\n-                ast::TyI32 => mywrite!(w, \"ML\"),\n-                ast::TyI64 => mywrite!(w, \"MD\")\n-            }\n-        }\n-        ty::ty_uint(t) => {\n-            match t {\n-                ast::TyU => mywrite!(w, \"u\"),\n-                ast::TyU8 => mywrite!(w, \"Mb\"),\n-                ast::TyU16 => mywrite!(w, \"Mw\"),\n-                ast::TyU32 => mywrite!(w, \"Ml\"),\n-                ast::TyU64 => mywrite!(w, \"Md\")\n-            }\n-        }\n-        ty::ty_float(t) => {\n-            match t {\n-                ast::TyF32 => mywrite!(w, \"Mf\"),\n-                ast::TyF64 => mywrite!(w, \"MF\"),\n-            }\n-        }\n-        ty::ty_enum(def, ref substs) => {\n-            mywrite!(w, \"t[{}|\", (cx.ds)(def));\n-            enc_substs(w, cx, substs);\n-            mywrite!(w, \"]\");\n-        }\n-        ty::ty_trait(box ty::TyTrait { ref principal,\n-                                       ref bounds }) => {\n-            mywrite!(w, \"x[\");\n-            enc_trait_ref(w, cx, &principal.0);\n-            enc_existential_bounds(w, cx, bounds);\n-            mywrite!(w, \"]\");\n-        }\n-        ty::ty_tup(ref ts) => {\n-            mywrite!(w, \"T[\");\n-            for t in ts.iter() { enc_ty(w, cx, *t); }\n-            mywrite!(w, \"]\");\n-        }\n-        ty::ty_uniq(typ) => { mywrite!(w, \"~\"); enc_ty(w, cx, typ); }\n-        ty::ty_ptr(mt) => { mywrite!(w, \"*\"); enc_mt(w, cx, mt); }\n-        ty::ty_rptr(r, mt) => {\n-            mywrite!(w, \"&\");\n-            enc_region(w, cx, r);\n-            enc_mt(w, cx, mt);\n-        }\n-        ty::ty_vec(t, sz) => {\n-            mywrite!(w, \"V\");\n-            enc_ty(w, cx, t);\n-            mywrite!(w, \"/\");\n-            match sz {\n-                Some(n) => mywrite!(w, \"{}|\", n),\n-                None => mywrite!(w, \"|\"),\n-            }\n-        }\n-        ty::ty_str => {\n-            mywrite!(w, \"v\");\n-        }\n-        ty::ty_closure(ref f) => {\n-            mywrite!(w, \"f\");\n-            enc_closure_ty(w, cx, &**f);\n-        }\n-        ty::ty_bare_fn(ref f) => {\n-            mywrite!(w, \"F\");\n-            enc_bare_fn_ty(w, cx, f);\n-        }\n-        ty::ty_infer(_) => {\n-            cx.diag.handler().bug(\"cannot encode inference variable types\");\n-        }\n-        ty::ty_param(ParamTy {space, idx: id, def_id: did}) => {\n-            mywrite!(w, \"p{}|{}|{}|\", (cx.ds)(did), id, space.to_uint())\n-        }\n-        ty::ty_struct(def, ref substs) => {\n-            mywrite!(w, \"a[{}|\", (cx.ds)(def));\n-            enc_substs(w, cx, substs);\n-            mywrite!(w, \"]\");\n-        }\n-        ty::ty_unboxed_closure(def, region, ref substs) => {\n-            mywrite!(w, \"k[{}|\", (cx.ds)(def));\n-            enc_region(w, cx, region);\n-            enc_substs(w, cx, substs);\n-            mywrite!(w, \"]\");\n-        }\n-        ty::ty_err => {\n-            mywrite!(w, \"e\");\n-        }\n-        ty::ty_open(_) => {\n-            cx.diag.handler().bug(\"unexpected type in enc_sty (ty_open)\");\n-        }\n-    }\n-}\n-\n fn enc_unsafety(w: &mut SeekableMemWriter, p: ast::Unsafety) {\n     match p {\n         ast::Unsafety::Normal => mywrite!(w, \"n\"),"}, {"sha": "64bfd1388026d38345c61f386070b11cf62358d4", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 51, "deletions": 59, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/e654491960a07fe4f8ab2034a080276b129c9cfd/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e654491960a07fe4f8ab2034a080276b129c9cfd/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=e654491960a07fe4f8ab2034a080276b129c9cfd", "patch": "@@ -90,8 +90,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                b.repr(self.get_ref().infcx.tcx));\n \n         // Consider coercing the subtype to a DST\n-        let unsize = self.unpack_actual_value(a, |sty_a| {\n-            self.coerce_unsized(a, sty_a, b)\n+        let unsize = self.unpack_actual_value(a, |a| {\n+            self.coerce_unsized(a, b)\n         });\n         if unsize.is_ok() {\n             return unsize;\n@@ -105,14 +105,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             ty::ty_ptr(mt_b) => {\n                 match mt_b.ty.sty {\n                     ty::ty_str => {\n-                        return self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_unsafe_ptr(a, sty_a, b, ast::MutImmutable)\n+                        return self.unpack_actual_value(a, |a| {\n+                            self.coerce_unsafe_ptr(a, b, ast::MutImmutable)\n                         });\n                     }\n \n                     ty::ty_trait(..) => {\n-                        let result = self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_unsafe_object(a, sty_a, b, mt_b.mutbl)\n+                        let result = self.unpack_actual_value(a, |a| {\n+                            self.coerce_unsafe_object(a, b, mt_b.mutbl)\n                         });\n \n                         match result {\n@@ -122,8 +122,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     }\n \n                     _ => {\n-                        return self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_unsafe_ptr(a, sty_a, b, mt_b.mutbl)\n+                        return self.unpack_actual_value(a, |a| {\n+                            self.coerce_unsafe_ptr(a, b, mt_b.mutbl)\n                         });\n                     }\n                 };\n@@ -132,14 +132,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             ty::ty_rptr(_, mt_b) => {\n                 match mt_b.ty.sty {\n                     ty::ty_str => {\n-                        return self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_borrowed_pointer(a, sty_a, b, ast::MutImmutable)\n+                        return self.unpack_actual_value(a, |a| {\n+                            self.coerce_borrowed_pointer(a, b, ast::MutImmutable)\n                         });\n                     }\n \n                     ty::ty_trait(..) => {\n-                        let result = self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_borrowed_object(a, sty_a, b, mt_b.mutbl)\n+                        let result = self.unpack_actual_value(a, |a| {\n+                            self.coerce_borrowed_object(a, b, mt_b.mutbl)\n                         });\n \n                         match result {\n@@ -149,8 +149,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     }\n \n                     _ => {\n-                        return self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_borrowed_pointer(a, sty_a, b, mt_b.mutbl)\n+                        return self.unpack_actual_value(a, |a| {\n+                            self.coerce_borrowed_pointer(a, b, mt_b.mutbl)\n                         });\n                     }\n                 };\n@@ -160,16 +160,16 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     store: ty::RegionTraitStore(..),\n                     ..\n                 }) => {\n-                return self.unpack_actual_value(a, |sty_a| {\n-                    self.coerce_borrowed_fn(a, sty_a, b)\n+                return self.unpack_actual_value(a, |a| {\n+                    self.coerce_borrowed_fn(a, b)\n                 });\n             }\n \n             _ => {}\n         }\n \n-        self.unpack_actual_value(a, |sty_a| {\n-            match *sty_a {\n+        self.unpack_actual_value(a, |a| {\n+            match a.sty {\n                 ty::ty_bare_fn(ref a_f) => {\n                     // Bare functions are coercible to any closure type.\n                     //\n@@ -194,20 +194,19 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     pub fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where\n-        F: FnOnce(&ty::sty<'tcx>) -> T,\n+        F: FnOnce(Ty<'tcx>) -> T,\n     {\n-        f(&self.get_ref().infcx.shallow_resolve(a).sty)\n+        f(self.get_ref().infcx.shallow_resolve(a))\n     }\n \n     // ~T -> &T or &mut T -> &T (including where T = [U] or str)\n     pub fn coerce_borrowed_pointer(&self,\n                                    a: Ty<'tcx>,\n-                                   sty_a: &ty::sty<'tcx>,\n                                    b: Ty<'tcx>,\n                                    mutbl_b: ast::Mutability)\n                                    -> CoerceResult<'tcx> {\n-        debug!(\"coerce_borrowed_pointer(a={}, sty_a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx), sty_a,\n+        debug!(\"coerce_borrowed_pointer(a={}, b={})\",\n+               a.repr(self.get_ref().infcx.tcx),\n                b.repr(self.get_ref().infcx.tcx));\n \n         // If we have a parameter of type `&M T_a` and the value\n@@ -220,7 +219,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let coercion = Coercion(self.get_ref().trace.clone());\n         let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n \n-        let inner_ty = match *sty_a {\n+        let inner_ty = match a.sty {\n             ty::ty_uniq(_) => return Err(ty::terr_mismatch),\n             ty::ty_rptr(_, mt_a) => mt_a.ty,\n             _ => {\n@@ -245,11 +244,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // or &Concrete -> &Trait, etc.\n     fn coerce_unsized(&self,\n                       a: Ty<'tcx>,\n-                      sty_a: &ty::sty<'tcx>,\n                       b: Ty<'tcx>)\n                       -> CoerceResult<'tcx> {\n-        debug!(\"coerce_unsized(a={}, sty_a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx), sty_a,\n+        debug!(\"coerce_unsized(a={}, b={})\",\n+               a.repr(self.get_ref().infcx.tcx),\n                b.repr(self.get_ref().infcx.tcx));\n \n         // Note, we want to avoid unnecessary unsizing. We don't want to coerce to\n@@ -259,11 +257,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         let sub = Sub(self.get_ref().clone());\n \n-        let sty_b = &b.sty;\n-        match (sty_a, sty_b) {\n+        match (&a.sty, &b.sty) {\n             (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_rptr(_, mt_b)) => {\n-                self.unpack_actual_value(t_a, |sty_a| {\n-                    match self.unsize_ty(t_a, sty_a, mt_b.ty) {\n+                self.unpack_actual_value(t_a, |a| {\n+                    match self.unsize_ty(t_a, a, mt_b.ty) {\n                         Some((ty, kind)) => {\n                             if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n                                 return Err(ty::terr_mutability);\n@@ -288,8 +285,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 })\n             }\n             (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_ptr(mt_b)) => {\n-                self.unpack_actual_value(t_a, |sty_a| {\n-                    match self.unsize_ty(t_a, sty_a, mt_b.ty) {\n+                self.unpack_actual_value(t_a, |a| {\n+                    match self.unsize_ty(t_a, a, mt_b.ty) {\n                         Some((ty, kind)) => {\n                             if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n                                 return Err(ty::terr_mutability);\n@@ -311,8 +308,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 })\n             }\n             (&ty::ty_uniq(t_a), &ty::ty_uniq(t_b)) => {\n-                self.unpack_actual_value(t_a, |sty_a| {\n-                    match self.unsize_ty(t_a, sty_a, t_b) {\n+                self.unpack_actual_value(t_a, |a| {\n+                    match self.unsize_ty(t_a, a, t_b) {\n                         Some((ty, kind)) => {\n                             let ty = ty::mk_uniq(self.get_ref().infcx.tcx, ty);\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n@@ -336,15 +333,15 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // E.g., `[T, ..n]` -> `([T], UnsizeLength(n))`\n     fn unsize_ty(&self,\n                  ty_a: Ty<'tcx>,\n-                 sty_a: &ty::sty<'tcx>,\n+                 a: Ty<'tcx>,\n                  ty_b: Ty<'tcx>)\n                  -> Option<(Ty<'tcx>, ty::UnsizeKind<'tcx>)> {\n-        debug!(\"unsize_ty(sty_a={}, ty_b={})\", sty_a, ty_b.repr(self.get_ref().infcx.tcx));\n+        debug!(\"unsize_ty(a={}, ty_b={})\", a, ty_b.repr(self.get_ref().infcx.tcx));\n \n         let tcx = self.get_ref().infcx.tcx;\n \n-        self.unpack_actual_value(ty_b, |sty_b|\n-            match (sty_a, sty_b) {\n+        self.unpack_actual_value(ty_b, |b|\n+            match (&a.sty, &b.sty) {\n                 (&ty::ty_vec(t_a, Some(len)), &ty::ty_vec(_, None)) => {\n                     let ty = ty::mk_vec(tcx, t_a, None);\n                     Some((ty, ty::UnsizeLength(len)))\n@@ -412,44 +409,41 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n     fn coerce_borrowed_object(&self,\n                               a: Ty<'tcx>,\n-                              sty_a: &ty::sty<'tcx>,\n                               b: Ty<'tcx>,\n                               b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n-        debug!(\"coerce_borrowed_object(a={}, sty_a={}, b={}, b_mutbl={})\",\n-               a.repr(tcx), sty_a,\n+        debug!(\"coerce_borrowed_object(a={}, b={}, b_mutbl={})\",\n+               a.repr(tcx),\n                b.repr(tcx), b_mutbl);\n \n         let coercion = Coercion(self.get_ref().trace.clone());\n         let r_a = self.get_ref().infcx.next_region_var(coercion);\n \n-        self.coerce_object(a, sty_a, b, b_mutbl,\n+        self.coerce_object(a, b, b_mutbl,\n                            |tr| ty::mk_rptr(tcx, r_a, ty::mt{ mutbl: b_mutbl, ty: tr }),\n                            || AutoPtr(r_a, b_mutbl, None))\n     }\n \n     fn coerce_unsafe_object(&self,\n                             a: Ty<'tcx>,\n-                            sty_a: &ty::sty<'tcx>,\n                             b: Ty<'tcx>,\n                             b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n-        debug!(\"coerce_unsafe_object(a={}, sty_a={}, b={}, b_mutbl={})\",\n-               a.repr(tcx), sty_a,\n+        debug!(\"coerce_unsafe_object(a={}, b={}, b_mutbl={})\",\n+               a.repr(tcx),\n                b.repr(tcx), b_mutbl);\n \n-        self.coerce_object(a, sty_a, b, b_mutbl,\n+        self.coerce_object(a, b, b_mutbl,\n                            |tr| ty::mk_ptr(tcx, ty::mt{ mutbl: b_mutbl, ty: tr }),\n                            || AutoUnsafe(b_mutbl, None))\n     }\n \n     fn coerce_object<F, G>(&self,\n                            a: Ty<'tcx>,\n-                           sty_a: &ty::sty<'tcx>,\n                            b: Ty<'tcx>,\n                            b_mutbl: ast::Mutability,\n                            mk_ty: F,\n@@ -459,7 +453,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n-        match *sty_a {\n+        match a.sty {\n             ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty.sty {\n                 ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n                     debug!(\"mutbl={} b_mutbl={}\", mutbl, b_mutbl);\n@@ -483,14 +477,13 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n     pub fn coerce_borrowed_fn(&self,\n                               a: Ty<'tcx>,\n-                              sty_a: &ty::sty<'tcx>,\n                               b: Ty<'tcx>)\n                               -> CoerceResult<'tcx> {\n-        debug!(\"coerce_borrowed_fn(a={}, sty_a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx), sty_a,\n+        debug!(\"coerce_borrowed_fn(a={}, b={})\",\n+               a.repr(self.get_ref().infcx.tcx),\n                b.repr(self.get_ref().infcx.tcx));\n \n-        match *sty_a {\n+        match a.sty {\n             ty::ty_bare_fn(ref f) => {\n                 self.coerce_from_bare_fn(a, f, b)\n             }\n@@ -504,7 +497,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     ///  `proc`.\n     fn coerce_from_bare_fn(&self, a: Ty<'tcx>, fn_ty_a: &ty::BareFnTy<'tcx>, b: Ty<'tcx>)\n                            -> CoerceResult<'tcx> {\n-        self.unpack_actual_value(b, |sty_b| {\n+        self.unpack_actual_value(b, |b| {\n \n             debug!(\"coerce_from_bare_fn(a={}, b={})\",\n                    a.repr(self.get_ref().infcx.tcx), b.repr(self.get_ref().infcx.tcx));\n@@ -513,7 +506,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 return self.subtype(a, b);\n             }\n \n-            let fn_ty_b = match *sty_b {\n+            let fn_ty_b = match b.sty {\n                 ty::ty_closure(ref f) => (*f).clone(),\n                 _ => return self.subtype(a, b)\n             };\n@@ -531,15 +524,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n     pub fn coerce_unsafe_ptr(&self,\n                              a: Ty<'tcx>,\n-                             sty_a: &ty::sty<'tcx>,\n                              b: Ty<'tcx>,\n                              mutbl_b: ast::Mutability)\n                              -> CoerceResult<'tcx> {\n-        debug!(\"coerce_unsafe_ptr(a={}, sty_a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx), sty_a,\n+        debug!(\"coerce_unsafe_ptr(a={}, b={})\",\n+               a.repr(self.get_ref().infcx.tcx),\n                b.repr(self.get_ref().infcx.tcx));\n \n-        let mt_a = match *sty_a {\n+        let mt_a = match a.sty {\n             ty::ty_rptr(_, mt) | ty::ty_ptr(mt) => mt,\n             _ => {\n                 return self.subtype(a, b);"}, {"sha": "d69ae96d07eca21907c1b617bb05132d84af33e7", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 48, "deletions": 64, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e654491960a07fe4f8ab2034a080276b129c9cfd/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e654491960a07fe4f8ab2034a080276b129c9cfd/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=e654491960a07fe4f8ab2034a080276b129c9cfd", "patch": "@@ -82,10 +82,6 @@ pub trait TypeFolder<'tcx> {\n         super_fold_trait_ref(self, t)\n     }\n \n-    fn fold_sty(&mut self, sty: &ty::sty<'tcx>) -> ty::sty<'tcx> {\n-        super_fold_sty(self, sty)\n-    }\n-\n     fn fold_substs(&mut self,\n                    substs: &subst::Substs<'tcx>)\n                    -> subst::Substs<'tcx> {\n@@ -260,12 +256,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::sty<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::sty<'tcx> {\n-        folder.fold_sty(self)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef<'tcx> {\n         folder.fold_trait_ref(self)\n@@ -521,9 +511,55 @@ impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n // They should invoke `foo.fold_with()` to do recursive folding.\n \n pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                t: Ty<'tcx>)\n+                                                ty: Ty<'tcx>)\n                                                 -> Ty<'tcx> {\n-    let sty = t.sty.fold_with(this);\n+    let sty = match ty.sty {\n+        ty::ty_uniq(typ) => {\n+            ty::ty_uniq(typ.fold_with(this))\n+        }\n+        ty::ty_ptr(ref tm) => {\n+            ty::ty_ptr(tm.fold_with(this))\n+        }\n+        ty::ty_vec(typ, sz) => {\n+            ty::ty_vec(typ.fold_with(this), sz)\n+        }\n+        ty::ty_open(typ) => {\n+            ty::ty_open(typ.fold_with(this))\n+        }\n+        ty::ty_enum(tid, ref substs) => {\n+            ty::ty_enum(tid, substs.fold_with(this))\n+        }\n+        ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n+            ty::ty_trait(box ty::TyTrait {\n+                principal: (*principal).fold_with(this),\n+                bounds: bounds.fold_with(this),\n+            })\n+        }\n+        ty::ty_tup(ref ts) => {\n+            ty::ty_tup(ts.fold_with(this))\n+        }\n+        ty::ty_bare_fn(ref f) => {\n+            ty::ty_bare_fn(f.fold_with(this))\n+        }\n+        ty::ty_closure(ref f) => {\n+            ty::ty_closure(box f.fold_with(this))\n+        }\n+        ty::ty_rptr(r, ref tm) => {\n+            ty::ty_rptr(r.fold_with(this), tm.fold_with(this))\n+        }\n+        ty::ty_struct(did, ref substs) => {\n+            ty::ty_struct(did, substs.fold_with(this))\n+        }\n+        ty::ty_unboxed_closure(did, ref region, ref substs) => {\n+            ty::ty_unboxed_closure(did, region.fold_with(this), substs.fold_with(this))\n+        }\n+        ty::ty_bool | ty::ty_char | ty::ty_str |\n+        ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n+        ty::ty_err | ty::ty_infer(_) |\n+        ty::ty_param(..) => {\n+            ty.sty.clone()\n+        }\n+    };\n     ty::mk_t(this.tcx(), sty)\n }\n \n@@ -601,58 +637,6 @@ pub fn super_fold_mt<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             mutbl: mt.mutbl}\n }\n \n-pub fn super_fold_sty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                 sty: &ty::sty<'tcx>)\n-                                                 -> ty::sty<'tcx> {\n-    match *sty {\n-        ty::ty_uniq(typ) => {\n-            ty::ty_uniq(typ.fold_with(this))\n-        }\n-        ty::ty_ptr(ref tm) => {\n-            ty::ty_ptr(tm.fold_with(this))\n-        }\n-        ty::ty_vec(typ, sz) => {\n-            ty::ty_vec(typ.fold_with(this), sz)\n-        }\n-        ty::ty_open(typ) => {\n-            ty::ty_open(typ.fold_with(this))\n-        }\n-        ty::ty_enum(tid, ref substs) => {\n-            ty::ty_enum(tid, substs.fold_with(this))\n-        }\n-        ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n-            ty::ty_trait(box ty::TyTrait {\n-                principal: (*principal).fold_with(this),\n-                bounds: bounds.fold_with(this),\n-            })\n-        }\n-        ty::ty_tup(ref ts) => {\n-            ty::ty_tup(ts.fold_with(this))\n-        }\n-        ty::ty_bare_fn(ref f) => {\n-            ty::ty_bare_fn(f.fold_with(this))\n-        }\n-        ty::ty_closure(ref f) => {\n-            ty::ty_closure(box f.fold_with(this))\n-        }\n-        ty::ty_rptr(r, ref tm) => {\n-            ty::ty_rptr(r.fold_with(this), tm.fold_with(this))\n-        }\n-        ty::ty_struct(did, ref substs) => {\n-            ty::ty_struct(did, substs.fold_with(this))\n-        }\n-        ty::ty_unboxed_closure(did, ref region, ref substs) => {\n-            ty::ty_unboxed_closure(did, region.fold_with(this), substs.fold_with(this))\n-        }\n-        ty::ty_bool | ty::ty_char | ty::ty_str |\n-        ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n-        ty::ty_err | ty::ty_infer(_) |\n-        ty::ty_param(..) => {\n-            (*sty).clone()\n-        }\n-    }\n-}\n-\n pub fn super_fold_trait_store<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                          trait_store: ty::TraitStore)\n                                                          -> ty::TraitStore {"}, {"sha": "092260523670745db03f5c5442c27371a7ab82f8", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e654491960a07fe4f8ab2034a080276b129c9cfd/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e654491960a07fe4f8ab2034a080276b129c9cfd/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e654491960a07fe4f8ab2034a080276b129c9cfd", "patch": "@@ -261,44 +261,43 @@ fn check_boxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     // Find the expected input/output types (if any). Substitute\n     // fresh bound regions for any bound regions we find in the\n     // expected types so as to avoid capture.\n-    let expected_sty = expected.map_to_option(fcx, |x| Some((*x).clone()));\n-    let (expected_sig,\n-         expected_onceness,\n-         expected_bounds) = {\n-        match expected_sty {\n-            Some(ty::ty_closure(ref cenv)) => {\n-                let (sig, _) =\n-                    ty::replace_late_bound_regions(\n-                        tcx,\n-                        &cenv.sig,\n-                        |_, debruijn| fcx.inh.infcx.fresh_bound_region(debruijn));\n-                let onceness = match (&store, &cenv.store) {\n-                    // As the closure type and onceness go, only three\n-                    // combinations are legit:\n-                    //      once closure\n-                    //      many closure\n-                    //      once proc\n-                    // If the actual and expected closure type disagree with\n-                    // each other, set expected onceness to be always Once or\n-                    // Many according to the actual type. Otherwise, it will\n-                    // yield either an illegal \"many proc\" or a less known\n-                    // \"once closure\" in the error message.\n-                    (&ty::UniqTraitStore, &ty::UniqTraitStore) |\n-                    (&ty::RegionTraitStore(..), &ty::RegionTraitStore(..)) =>\n-                        cenv.onceness,\n-                    (&ty::UniqTraitStore, _) => ast::Once,\n-                    (&ty::RegionTraitStore(..), _) => ast::Many,\n-                };\n-                (Some(sig), onceness, cenv.bounds)\n-            }\n-            _ => {\n-                // Not an error! Means we're inferring the closure type\n-                let region = fcx.infcx().next_region_var(\n-                    infer::AddrOfRegion(expr.span));\n-                let bounds = ty::region_existential_bound(region);\n-                let onceness = ast::Many;\n-                (None, onceness, bounds)\n-            }\n+    let expected_cenv = expected.map_to_option(fcx, |ty| match ty.sty {\n+        ty::ty_closure(ref cenv) => Some(cenv),\n+        _ => None\n+    });\n+    let (expected_sig, expected_onceness, expected_bounds) = match expected_cenv {\n+        Some(cenv) => {\n+            let (sig, _) =\n+                ty::replace_late_bound_regions(\n+                    tcx,\n+                    &cenv.sig,\n+                    |_, debruijn| fcx.inh.infcx.fresh_bound_region(debruijn));\n+            let onceness = match (&store, &cenv.store) {\n+                // As the closure type and onceness go, only three\n+                // combinations are legit:\n+                //      once closure\n+                //      many closure\n+                //      once proc\n+                // If the actual and expected closure type disagree with\n+                // each other, set expected onceness to be always Once or\n+                // Many according to the actual type. Otherwise, it will\n+                // yield either an illegal \"many proc\" or a less known\n+                // \"once closure\" in the error message.\n+                (&ty::UniqTraitStore, &ty::UniqTraitStore) |\n+                (&ty::RegionTraitStore(..), &ty::RegionTraitStore(..)) =>\n+                    cenv.onceness,\n+                (&ty::UniqTraitStore, _) => ast::Once,\n+                (&ty::RegionTraitStore(..), _) => ast::Many,\n+            };\n+            (Some(sig), onceness, cenv.bounds)\n+        }\n+        _ => {\n+            // Not an error! Means we're inferring the closure type\n+            let region = fcx.infcx().next_region_var(\n+                infer::AddrOfRegion(expr.span));\n+            let bounds = ty::region_existential_bound(region);\n+            let onceness = ast::Many;\n+            (None, onceness, bounds)\n         }\n     };\n "}, {"sha": "1e624dfaaa47fd4a916c9c4f316ed588aeab983e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e654491960a07fe4f8ab2034a080276b129c9cfd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e654491960a07fe4f8ab2034a080276b129c9cfd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e654491960a07fe4f8ab2034a080276b129c9cfd", "patch": "@@ -2042,7 +2042,7 @@ fn try_overloaded_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                  -> bool {\n     // Bail out if the callee is a bare function or a closure. We check those\n     // manually.\n-    match *structure_of(fcx, callee.span, callee_type) {\n+    match structurally_resolved_type(fcx, callee.span, callee_type).sty {\n         ty::ty_bare_fn(_) | ty::ty_closure(_) => return false,\n         _ => {}\n     }\n@@ -2717,10 +2717,9 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         ast::LitInt(_, ast::SignedIntLit(t, _)) => ty::mk_mach_int(t),\n         ast::LitInt(_, ast::UnsignedIntLit(t)) => ty::mk_mach_uint(t),\n         ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n-            let opt_ty = expected.map_to_option(fcx, |sty| {\n-                match *sty {\n-                    ty::ty_int(i) => Some(ty::mk_mach_int(i)),\n-                    ty::ty_uint(i) => Some(ty::mk_mach_uint(i)),\n+            let opt_ty = expected.map_to_option(fcx, |ty| {\n+                match ty.sty {\n+                    ty::ty_int(_) | ty::ty_uint(_) => Some(ty),\n                     ty::ty_char => Some(ty::mk_mach_uint(ast::TyU8)),\n                     ty::ty_ptr(..) => Some(ty::mk_mach_uint(ast::TyU)),\n                     ty::ty_bare_fn(..) => Some(ty::mk_mach_uint(ast::TyU)),\n@@ -2732,9 +2731,9 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n         ast::LitFloat(_, t) => ty::mk_mach_float(t),\n         ast::LitFloatUnsuffixed(_) => {\n-            let opt_ty = expected.map_to_option(fcx, |sty| {\n-                match *sty {\n-                    ty::ty_float(i) => Some(ty::mk_mach_float(i)),\n+            let opt_ty = expected.map_to_option(fcx, |ty| {\n+                match ty.sty {\n+                    ty::ty_float(_) => Some(ty),\n                     _ => None\n                 }\n             });\n@@ -2910,7 +2909,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let fn_ty = fcx.expr_ty(f);\n \n         // Extract the function signature from `in_fty`.\n-        let fn_sty = structure_of(fcx, f.span, fn_ty);\n+        let fn_ty = structurally_resolved_type(fcx, f.span, fn_ty);\n \n         // This is the \"default\" function signature, used in case of error.\n         // In that case, we check each argument against \"error\" in order to\n@@ -2921,7 +2920,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             variadic: false\n         });\n \n-        let fn_sig = match *fn_sty {\n+        let fn_sig = match fn_ty.sty {\n             ty::ty_bare_fn(ty::BareFnTy {ref sig, ..}) |\n             ty::ty_closure(box ty::ClosureTy {ref sig, ..}) => sig,\n             _ => {\n@@ -3655,9 +3654,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       ast::ExprUnary(unop, ref oprnd) => {\n-        let expected_inner = expected.map(fcx, |sty| {\n+        let expected_inner = expected.map(fcx, |ty| {\n             match unop {\n-                ast::UnUniq => match *sty {\n+                ast::UnUniq => match ty.sty {\n                     ty::ty_uniq(ty) => {\n                         ExpectHasType(ty)\n                     }\n@@ -3746,9 +3745,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprAddrOf(mutbl, ref oprnd) => {\n         let expected = expected.only_has_type();\n-        let hint = expected.map(fcx, |sty| {\n-            match *sty { ty::ty_rptr(_, ref mt) | ty::ty_ptr(ref mt) => ExpectHasType(mt.ty),\n-                         _ => NoExpectation }\n+        let hint = expected.map(fcx, |ty| {\n+            match ty.sty {\n+                ty::ty_rptr(_, ref mt) | ty::ty_ptr(ref mt) => ExpectHasType(mt.ty),\n+                _ => NoExpectation\n+            }\n         });\n         let lvalue_pref = match mutbl {\n             ast::MutMutable => PreferMutLvalue,\n@@ -4037,9 +4038,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprTup(ref elts) => {\n         let expected = expected.only_has_type();\n-        let flds = expected.map_to_option(fcx, |sty| {\n-            match *sty {\n-                ty::ty_tup(ref flds) => Some((*flds).clone()),\n+        let flds = expected.map_to_option(fcx, |ty| {\n+            match ty.sty {\n+                ty::ty_tup(ref flds) => Some(flds[]),\n                 _ => None\n             }\n         });\n@@ -4304,20 +4305,20 @@ impl<'tcx> Expectation<'tcx> {\n     }\n \n     fn map<'a, F>(self, fcx: &FnCtxt<'a, 'tcx>, unpack: F) -> Expectation<'tcx> where\n-        F: FnOnce(&ty::sty<'tcx>) -> Expectation<'tcx>\n+        F: FnOnce(Ty<'tcx>) -> Expectation<'tcx>\n     {\n         match self.resolve(fcx) {\n             NoExpectation => NoExpectation,\n-            ExpectCastableToType(t) | ExpectHasType(t) => unpack(&t.sty),\n+            ExpectCastableToType(ty) | ExpectHasType(ty) => unpack(ty),\n         }\n     }\n \n     fn map_to_option<'a, O, F>(self, fcx: &FnCtxt<'a, 'tcx>, unpack: F) -> Option<O> where\n-        F: FnOnce(&ty::sty<'tcx>) -> Option<O>,\n+        F: FnOnce(Ty<'tcx>) -> Option<O>,\n     {\n         match self.resolve(fcx) {\n             NoExpectation => None,\n-            ExpectCastableToType(t) | ExpectHasType(t) => unpack(&t.sty),\n+            ExpectCastableToType(ty) | ExpectHasType(ty) => unpack(ty),\n         }\n     }\n }\n@@ -5320,12 +5321,6 @@ pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n     ty\n }\n \n-// Returns the one-level-deep structure of the given type.\n-pub fn structure_of<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span, typ: Ty<'tcx>)\n-                        -> &'tcx ty::sty<'tcx> {\n-    &structurally_resolved_type(fcx, sp, typ).sty\n-}\n-\n // Returns true if b contains a break that can exit from b\n pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n     // First: is there an unlabeled break immediately"}, {"sha": "24d7bf5031e46c8a6687c86dbf82cd6ac70ad446", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e654491960a07fe4f8ab2034a080276b129c9cfd/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e654491960a07fe4f8ab2034a080276b129c9cfd/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=e654491960a07fe4f8ab2034a080276b129c9cfd", "patch": "@@ -17,7 +17,7 @@ use middle::subst::{Subst};\n use middle::traits;\n use middle::ty::{mod, Ty};\n use middle::ty::liberate_late_bound_regions;\n-use middle::ty_fold::{TypeFolder, TypeFoldable};\n+use middle::ty_fold::{TypeFolder, TypeFoldable, super_fold_ty};\n use util::ppaux::Repr;\n \n use std::collections::HashSet;\n@@ -368,8 +368,8 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n \n                 self.binding_count -= 1;\n             }\n-            ref sty => {\n-                self.fold_sty(sty);\n+            _ => {\n+                super_fold_ty(self, t);\n             }\n         }\n "}]}