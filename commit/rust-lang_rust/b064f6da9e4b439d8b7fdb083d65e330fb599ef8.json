{"sha": "b064f6da9e4b439d8b7fdb083d65e330fb599ef8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNjRmNmRhOWU0YjQzOWQ4YjdmZGIwODNkNjVlMzMwZmI1OTllZjg=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-12-07T19:38:28Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-12-07T19:38:28Z"}, "message": "Keep doc attribute order", "tree": {"sha": "a91c3ab6637b610e5a70a987a3279c621e2c3377", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a91c3ab6637b610e5a70a987a3279c621e2c3377"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b064f6da9e4b439d8b7fdb083d65e330fb599ef8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b064f6da9e4b439d8b7fdb083d65e330fb599ef8", "html_url": "https://github.com/rust-lang/rust/commit/b064f6da9e4b439d8b7fdb083d65e330fb599ef8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b064f6da9e4b439d8b7fdb083d65e330fb599ef8/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efe86a42dc922ca2cb38227f3b0bf6a420d3cfca", "url": "https://api.github.com/repos/rust-lang/rust/commits/efe86a42dc922ca2cb38227f3b0bf6a420d3cfca", "html_url": "https://github.com/rust-lang/rust/commit/efe86a42dc922ca2cb38227f3b0bf6a420d3cfca"}], "stats": {"total": 116, "additions": 61, "deletions": 55}, "files": [{"sha": "43f0355e5fa1b744dbe1a0f67229ea0dc93abba9", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b064f6da9e4b439d8b7fdb083d65e330fb599ef8/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b064f6da9e4b439d8b7fdb083d65e330fb599ef8/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=b064f6da9e4b439d8b7fdb083d65e330fb599ef8", "patch": "@@ -9,7 +9,7 @@ use itertools::Itertools;\n use mbe::ast_to_token_tree;\n use syntax::{\n     ast::{self, AstNode, AttrsOwner},\n-    SmolStr,\n+    AstToken, SmolStr,\n };\n use tt::Subtree;\n \n@@ -110,18 +110,25 @@ impl Attrs {\n     }\n \n     pub(crate) fn new(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Attrs {\n-        let docs = ast::CommentIter::from_syntax_node(owner.syntax()).doc_comment_text().map(\n-            |docs_text| Attr {\n-                input: Some(AttrInput::Literal(SmolStr::new(docs_text))),\n-                path: ModPath::from(hir_expand::name!(doc)),\n-            },\n-        );\n-        let mut attrs = owner.attrs().peekable();\n-        let entries = if attrs.peek().is_none() && docs.is_none() {\n+        let docs = ast::CommentIter::from_syntax_node(owner.syntax()).map(|docs_text| {\n+            (\n+                docs_text.syntax().text_range().start(),\n+                docs_text.doc_comment().map(|doc| Attr {\n+                    input: Some(AttrInput::Literal(SmolStr::new(doc))),\n+                    path: ModPath::from(hir_expand::name!(doc)),\n+                }),\n+            )\n+        });\n+        let attrs = owner\n+            .attrs()\n+            .map(|attr| (attr.syntax().text_range().start(), Attr::from_src(attr, hygiene)));\n+        // sort here by syntax node offset because the source can have doc attributes and doc strings be interleaved\n+        let attrs: Vec<_> = docs.chain(attrs).sorted_by_key(|&(offset, _)| offset).collect();\n+        let entries = if attrs.is_empty() {\n             // Avoid heap allocation\n             None\n         } else {\n-            Some(attrs.flat_map(|ast| Attr::from_src(ast, hygiene)).chain(docs).collect())\n+            Some(attrs.into_iter().flat_map(|(_, attr)| attr).collect())\n         };\n         Attrs { entries }\n     }\n@@ -195,10 +202,15 @@ impl Attr {\n     fn from_src(ast: ast::Attr, hygiene: &Hygiene) -> Option<Attr> {\n         let path = ModPath::from_src(ast.path()?, hygiene)?;\n         let input = if let Some(lit) = ast.literal() {\n-            let value = if let ast::LiteralKind::String(string) = lit.kind() {\n-                string.value()?.into()\n-            } else {\n-                lit.syntax().first_token()?.text().trim_matches('\"').into()\n+            // FIXME: escape?\n+            let value = match lit.kind() {\n+                ast::LiteralKind::String(string) if string.is_raw() => {\n+                    let text = string.text().as_str();\n+                    let text = &text[string.text_range_between_quotes()?\n+                        - string.syntax().text_range().start()];\n+                    text.into()\n+                }\n+                _ => lit.syntax().first_token()?.text().trim_matches('\"').into(),\n             };\n             Some(AttrInput::Literal(value))\n         } else if let Some(tt) = ast.token_tree() {"}, {"sha": "6167d50e2722904e41ee3ce4eb25663995f4207a", "filename": "crates/syntax/src/ast/token_ext.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b064f6da9e4b439d8b7fdb083d65e330fb599ef8/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b064f6da9e4b439d8b7fdb083d65e330fb599ef8/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs?ref=b064f6da9e4b439d8b7fdb083d65e330fb599ef8", "patch": "@@ -18,12 +18,33 @@ impl ast::Comment {\n     }\n \n     pub fn prefix(&self) -> &'static str {\n-        let &(prefix, _kind) = CommentKind::BY_PREFIX\n-            .iter()\n-            .find(|&(prefix, kind)| self.kind() == *kind && self.text().starts_with(prefix))\n-            .unwrap();\n+        let &(prefix, _kind) = CommentKind::with_prefix_from_text(self.text());\n         prefix\n     }\n+\n+    pub fn kind_and_prefix(&self) -> &(&'static str, CommentKind) {\n+        CommentKind::with_prefix_from_text(self.text())\n+    }\n+\n+    /// Returns the textual content of a doc comment block as a single string.\n+    /// That is, strips leading `///` (+ optional 1 character of whitespace),\n+    /// trailing `*/`, trailing whitespace and then joins the lines.\n+    pub fn doc_comment(&self) -> Option<&str> {\n+        match self.kind_and_prefix() {\n+            (prefix, CommentKind { shape, doc: Some(_) }) => {\n+                let text = &self.text().as_str()[prefix.len()..];\n+                let ws = text.chars().next().filter(|c| c.is_whitespace());\n+                let text = ws.map_or(text, |ws| &text[ws.len_utf8()..]);\n+                match shape {\n+                    CommentShape::Block if text.ends_with(\"*/\") => {\n+                        Some(&text[..text.len() - \"*/\".len()])\n+                    }\n+                    _ => Some(text),\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n@@ -67,12 +88,13 @@ impl CommentKind {\n     ];\n \n     pub(crate) fn from_text(text: &str) -> CommentKind {\n-        let &(_prefix, kind) = CommentKind::BY_PREFIX\n-            .iter()\n-            .find(|&(prefix, _kind)| text.starts_with(prefix))\n-            .unwrap();\n+        let &(_prefix, kind) = Self::with_prefix_from_text(text);\n         kind\n     }\n+\n+    fn with_prefix_from_text(text: &str) -> &(&'static str, CommentKind) {\n+        CommentKind::BY_PREFIX.iter().find(|&(prefix, _kind)| text.starts_with(prefix)).unwrap()\n+    }\n }\n \n impl ast::Whitespace {"}, {"sha": "13a769d51a07971b4db7064ff6f673fbf7eb1fc3", "filename": "crates/syntax/src/ast/traits.rs", "status": "modified", "additions": 5, "deletions": 33, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b064f6da9e4b439d8b7fdb083d65e330fb599ef8/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b064f6da9e4b439d8b7fdb083d65e330fb599ef8/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs?ref=b064f6da9e4b439d8b7fdb083d65e330fb599ef8", "patch": "@@ -91,40 +91,12 @@ impl CommentIter {\n     /// That is, strips leading `///` (+ optional 1 character of whitespace),\n     /// trailing `*/`, trailing whitespace and then joins the lines.\n     pub fn doc_comment_text(self) -> Option<String> {\n-        let mut has_comments = false;\n-        let docs = self\n-            .filter(|comment| comment.kind().doc.is_some())\n-            .map(|comment| {\n-                has_comments = true;\n-                let prefix_len = comment.prefix().len();\n-\n-                let line: &str = comment.text().as_str();\n-\n-                // Determine if the prefix or prefix + 1 char is stripped\n-                let pos =\n-                    if let Some(ws) = line.chars().nth(prefix_len).filter(|c| c.is_whitespace()) {\n-                        prefix_len + ws.len_utf8()\n-                    } else {\n-                        prefix_len\n-                    };\n-\n-                let end = if comment.kind().shape.is_block() && line.ends_with(\"*/\") {\n-                    line.len() - 2\n-                } else {\n-                    line.len()\n-                };\n-\n-                // Note that we do not trim the end of the line here\n-                // since whitespace can have special meaning at the end\n-                // of a line in markdown.\n-                line[pos..end].to_owned()\n-            })\n-            .join(\"\\n\");\n-\n-        if has_comments {\n-            Some(docs)\n-        } else {\n+        let docs =\n+            self.filter_map(|comment| comment.doc_comment().map(ToOwned::to_owned)).join(\"\\n\");\n+        if docs.is_empty() {\n             None\n+        } else {\n+            Some(docs)\n         }\n     }\n }"}]}