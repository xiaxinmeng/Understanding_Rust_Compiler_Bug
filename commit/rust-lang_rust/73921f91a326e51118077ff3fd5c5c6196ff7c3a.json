{"sha": "73921f91a326e51118077ff3fd5c5c6196ff7c3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczOTIxZjkxYTMyNmU1MTExODA3N2ZmM2ZkNWM1YzYxOTZmZjdjM2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-22T22:40:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-22T22:40:36Z"}, "message": "auto merge of #7883 : brson/rust/rm-std-net, r=graydon\n\nThis removes all the code from libextra that depends on libuv. After that it removes three runtime features that existed to support the global uv loop: weak tasks, runtime-global variables, and at_exit handlers.\r\n\r\nThe networking code doesn't have many users besides servo, so shouldn't have much fallout. The timer code though is useful and will probably break out-of-tree code until the new scheduler lands, but I expect that to be soon.\r\n\r\nIt also incidentally moves `os::change_dir_locked` to `std::unstable`. This is a function used by test cases to avoid cwd races and in my opinion shouldn't be public (#7870).\r\n\r\nCloses #7251 and #7870", "tree": {"sha": "23b03c59e5ea158fc0db7095cf94393c0f4546a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23b03c59e5ea158fc0db7095cf94393c0f4546a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73921f91a326e51118077ff3fd5c5c6196ff7c3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73921f91a326e51118077ff3fd5c5c6196ff7c3a", "html_url": "https://github.com/rust-lang/rust/commit/73921f91a326e51118077ff3fd5c5c6196ff7c3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73921f91a326e51118077ff3fd5c5c6196ff7c3a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ed82fbb43804ebc7e06daca5812079630ec8952", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ed82fbb43804ebc7e06daca5812079630ec8952", "html_url": "https://github.com/rust-lang/rust/commit/9ed82fbb43804ebc7e06daca5812079630ec8952"}, {"sha": "407bffb33e59db9c2ed0c0c5a6533f2ab88743e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/407bffb33e59db9c2ed0c0c5a6533f2ab88743e0", "html_url": "https://github.com/rust-lang/rust/commit/407bffb33e59db9c2ed0c0c5a6533f2ab88743e0"}], "stats": {"total": 6061, "additions": 83, "deletions": 5978}, "files": [{"sha": "f4fb7bcd76c9972db24ed320e6a82d7afecc30d4", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -36,23 +36,9 @@ use std::str::{StrSlice, OwnedStr};\n \n pub use std::os;\n \n-pub mod uv_ll;\n-\n-// General io and system-services modules\n-\n-#[path = \"net/mod.rs\"]\n-pub mod net;\n-\n-// libuv modules\n-pub mod uv;\n-pub mod uv_iotask;\n-pub mod uv_global_loop;\n-\n-\n // Utility modules\n \n pub mod c_vec;\n-pub mod timer;\n pub mod io_util;\n pub mod rc;\n \n@@ -90,6 +76,7 @@ pub mod sha2;\n \n // And ... other stuff\n \n+pub mod url;\n pub mod ebml;\n pub mod dbg;\n pub mod getopts;"}, {"sha": "7840345e2763f3f8f0d105aacc5f7e59e345e395", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -639,7 +639,6 @@ mod test {\n     use flatpipes::serial;\n     use io_util::BufReader;\n     use flatpipes::{BytePort, FlatChan, FlatPort};\n-    use net::tcp::TcpSocketBuf;\n \n     use std::comm;\n     use std::int;\n@@ -728,7 +727,8 @@ mod test {\n     }\n \n     // FIXME #2064: Networking doesn't work on x86\n-    #[test]\n+    // XXX Broken until networking support is added back\n+    /*#[test]\n     #[cfg(target_arch = \"x86_64\")]\n     fn test_pod_tcp_stream() {\n         fn reader_port(buf: TcpSocketBuf\n@@ -745,6 +745,7 @@ mod test {\n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n     fn test_serializing_tcp_stream() {\n+        // XXX Broken until networking support is added back\n         fn reader_port(buf: TcpSocketBuf\n                       ) -> serial::ReaderPort<int, TcpSocketBuf> {\n             serial::reader_port(buf)\n@@ -860,7 +861,7 @@ mod test {\n         }\n \n         finish_port.recv();\n-    }\n+    }*/\n \n     // Tests that the different backends behave the same when the\n     // binary streaming protocol is broken"}, {"sha": "c1633ffa04114aea8ffe4a669123ed7fbeff3170", "filename": "src/libextra/net/ip.rs", "status": "removed", "additions": 0, "deletions": 452, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet%2Fip.rs?ref=9ed82fbb43804ebc7e06daca5812079630ec8952", "patch": "@@ -1,452 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Types/fns concerning Internet Protocol (IP), versions 4 & 6\n-\n-#[allow(missing_doc)];\n-\n-\n-use std::libc;\n-use std::comm::{stream, SharedChan};\n-use std::ptr;\n-use std::result;\n-use std::str;\n-\n-use iotask = uv::iotask::IoTask;\n-use interact = uv::iotask::interact;\n-\n-use sockaddr_in = uv_ll::sockaddr_in;\n-use sockaddr_in6 = uv_ll::sockaddr_in6;\n-use addrinfo = uv_ll::addrinfo;\n-use uv_getaddrinfo_t = uv_ll::uv_getaddrinfo_t;\n-use uv_ip4_name = uv_ll::ip4_name;\n-use uv_ip4_port = uv_ll::ip4_port;\n-use uv_ip6_name = uv_ll::ip6_name;\n-use uv_ip6_port = uv_ll::ip6_port;\n-use uv_getaddrinfo = uv_ll::getaddrinfo;\n-use uv_freeaddrinfo = uv_ll::freeaddrinfo;\n-use create_uv_getaddrinfo_t = uv_ll::getaddrinfo_t;\n-use set_data_for_req = uv_ll::set_data_for_req;\n-use get_data_for_req = uv_ll::get_data_for_req;\n-use ll = uv_ll;\n-\n-/// An IP address\n-#[deriving(Clone)]\n-pub enum IpAddr {\n-    /// An IPv4 address\n-    Ipv4(sockaddr_in),\n-    Ipv6(sockaddr_in6)\n-}\n-\n-/// Human-friendly feedback on why a parse_addr attempt failed\n-pub struct ParseAddrErr {\n-    err_msg: ~str,\n-}\n-\n-/**\n- * Convert a `IpAddr` to a str\n- *\n- * # Arguments\n- *\n- * * ip - a `extra::net::ip::IpAddr`\n- */\n-pub fn format_addr(ip: &IpAddr) -> ~str {\n-    match *ip {\n-      Ipv4(ref addr) =>  unsafe {\n-        let result = uv_ip4_name(addr);\n-        if result == ~\"\" {\n-            fail!(\"failed to convert inner sockaddr_in address to str\")\n-        }\n-        result\n-      },\n-      Ipv6(ref addr) => unsafe {\n-        let result = uv_ip6_name(addr);\n-        if result == ~\"\" {\n-            fail!(\"failed to convert inner sockaddr_in address to str\")\n-        }\n-        result\n-      }\n-    }\n-}\n-\n-/**\n- * Get the associated port\n- *\n- * # Arguments\n- * * ip - a `extra::net::ip::IpAddr`\n- */\n-pub fn get_port(ip: &IpAddr) -> uint {\n-    match *ip {\n-        Ipv4(ref addr) => unsafe {\n-            uv_ip4_port(addr)\n-        },\n-        Ipv6(ref addr) => unsafe {\n-            uv_ip6_port(addr)\n-        }\n-    }\n-}\n-\n-/// Represents errors returned from `net::ip::get_addr()`\n-enum IpGetAddrErr {\n-    GetAddrUnknownError\n-}\n-\n-/**\n- * Attempts name resolution on the provided `node` string\n- *\n- * # Arguments\n- *\n- * * `node` - a string representing some host address\n- * * `iotask` - a `uv::iotask` used to interact with the underlying event loop\n- *\n- * # Returns\n- *\n- * A `result<~[ip_addr], ip_get_addr_err>` instance that will contain\n- * a vector of `ip_addr` results, in the case of success, or an error\n- * object in the case of failure\n-*/\n-pub fn get_addr(node: &str, iotask: &iotask)\n-                -> result::Result<~[IpAddr], IpGetAddrErr> {\n-    let (output_po, output_ch) = stream();\n-    let mut output_ch = Some(SharedChan::new(output_ch));\n-    do str::as_buf(node) |node_ptr, len| {\n-        let output_ch = output_ch.take_unwrap();\n-        debug!(\"slice len %?\", len);\n-        let handle = create_uv_getaddrinfo_t();\n-        let handle_ptr: *uv_getaddrinfo_t = &handle;\n-        let handle_data = GetAddrData {\n-            output_ch: output_ch.clone()\n-        };\n-        let handle_data_ptr: *GetAddrData = &handle_data;\n-        do interact(iotask) |loop_ptr| {\n-            unsafe {\n-                let result = uv_getaddrinfo(\n-                    loop_ptr,\n-                    handle_ptr,\n-                    get_addr_cb,\n-                    node_ptr,\n-                    ptr::null(),\n-                    ptr::null());\n-                match result {\n-                    0i32 => {\n-                        set_data_for_req(handle_ptr, handle_data_ptr);\n-                    }\n-                    _ => {\n-                        output_ch.send(result::Err(GetAddrUnknownError));\n-                    }\n-                }\n-            }\n-        };\n-        output_po.recv()\n-    }\n-}\n-\n-pub mod v4 {\n-\n-    use net::ip::{IpAddr, Ipv4, ParseAddrErr};\n-    use uv::ll;\n-    use uv_ip4_addr = uv::ll::ip4_addr;\n-    use uv_ip4_name = uv::ll::ip4_name;\n-\n-    use std::cast::transmute;\n-    use std::result;\n-    use std::uint;\n-\n-    /**\n-     * Convert a str to `ip_addr`\n-     *\n-     * # Failure\n-     *\n-     * Fails if the string is not a valid IPv4 address\n-     *\n-     * # Arguments\n-     *\n-     * * ip - a string of the format `x.x.x.x`\n-     *\n-     * # Returns\n-     *\n-     * * an `ip_addr` of the `ipv4` variant\n-     */\n-    pub fn parse_addr(ip: &str) -> IpAddr {\n-        match try_parse_addr(ip) {\n-          result::Ok(addr) => addr,\n-          result::Err(ref err_data) => fail!(err_data.err_msg.clone())\n-        }\n-    }\n-\n-    // the simple, old style numberic representation of\n-    // ipv4\n-    #[deriving(Clone)]\n-    pub struct Ipv4Rep {\n-        a: u8,\n-        b: u8,\n-        c: u8,\n-        d: u8,\n-    }\n-\n-    pub trait AsUnsafeU32 {\n-        unsafe fn as_u32(&self) -> u32;\n-    }\n-\n-    impl AsUnsafeU32 for Ipv4Rep {\n-        // this is pretty dastardly, i know\n-        unsafe fn as_u32(&self) -> u32 {\n-            let this: &mut u32 = transmute(self);\n-            *this\n-        }\n-    }\n-    pub fn parse_to_ipv4_rep(ip: &str) -> result::Result<Ipv4Rep, ~str> {\n-        let parts: ~[uint] = ip.split_iter('.').transform(|s| {\n-            match uint::from_str(s) {\n-                Some(n) if n <= 255 => n,\n-                _ => 256\n-            }\n-        }).collect();\n-        if parts.len() != 4 {\n-            Err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n-        } else if parts.iter().any(|x| *x == 256u) {\n-            Err(fmt!(\"invalid octal in addr '%s'\", ip))\n-        } else {\n-            Ok(Ipv4Rep {\n-                a: parts[0] as u8, b: parts[1] as u8,\n-                c: parts[2] as u8, d: parts[3] as u8,\n-            })\n-        }\n-    }\n-    pub fn try_parse_addr(ip: &str) -> result::Result<IpAddr,ParseAddrErr> {\n-        unsafe {\n-            let INADDR_NONE = ll::get_INADDR_NONE();\n-            let ip_rep_result = parse_to_ipv4_rep(ip);\n-            if result::is_err(&ip_rep_result) {\n-                let err_str = result::get_err(&ip_rep_result);\n-                return result::Err(ParseAddrErr { err_msg: err_str })\n-            }\n-            // ipv4_rep.as_u32 is unsafe :/\n-            let input_is_inaddr_none =\n-                result::get(&ip_rep_result).as_u32() == INADDR_NONE;\n-\n-            let new_addr = uv_ip4_addr(ip, 22);\n-            let reformatted_name = uv_ip4_name(&new_addr);\n-            debug!(\"try_parse_addr: input ip: %s reparsed ip: %s\",\n-                            ip, reformatted_name);\n-            let ref_ip_rep_result = parse_to_ipv4_rep(reformatted_name);\n-            if result::is_err(&ref_ip_rep_result) {\n-                let err_str = result::get_err(&ref_ip_rep_result);\n-                return Err(ParseAddrErr { err_msg: err_str })\n-            }\n-\n-            if result::get(&ref_ip_rep_result).as_u32() == INADDR_NONE &&\n-                 !input_is_inaddr_none {\n-                Err(ParseAddrErr {\n-                    err_msg: ~\"uv_ip4_name produced invalid result.\",\n-                })\n-            } else {\n-                Ok(Ipv4(new_addr))\n-            }\n-        }\n-    }\n-}\n-pub mod v6 {\n-\n-    use net::ip::{IpAddr, Ipv6, ParseAddrErr};\n-    use uv_ip6_addr = uv::ll::ip6_addr;\n-    use uv_ip6_name = uv::ll::ip6_name;\n-\n-    use std::result;\n-\n-    /**\n-     * Convert a str to `ip_addr`\n-     *\n-     * # Failure\n-     *\n-     * Fails if the string is not a valid IPv6 address\n-     *\n-     * # Arguments\n-     *\n-     * * ip - an ipv6 string. See RFC2460 for spec.\n-     *\n-     * # Returns\n-     *\n-     * * an `ip_addr` of the `ipv6` variant\n-     */\n-    pub fn parse_addr(ip: &str) -> IpAddr {\n-        match try_parse_addr(ip) {\n-          result::Ok(addr) => addr,\n-          result::Err(err_data) => fail!(err_data.err_msg.clone())\n-        }\n-    }\n-    pub fn try_parse_addr(ip: &str) -> result::Result<IpAddr,ParseAddrErr> {\n-        unsafe {\n-            // need to figure out how to establish a parse failure..\n-            let new_addr = uv_ip6_addr(ip, 22);\n-            let reparsed_name = uv_ip6_name(&new_addr);\n-            debug!(\"v6::try_parse_addr ip: '%s' reparsed '%s'\",\n-                            ip, reparsed_name);\n-            // '::' appears to be uv_ip6_name() returns for bogus\n-            // parses..\n-            if  ip != &\"::\" && reparsed_name == ~\"::\" {\n-                Err(ParseAddrErr { err_msg:fmt!(\"failed to parse '%s'\", ip) })\n-            }\n-            else {\n-                Ok(Ipv6(new_addr))\n-            }\n-        }\n-    }\n-}\n-\n-struct GetAddrData {\n-    output_ch: SharedChan<result::Result<~[IpAddr],IpGetAddrErr>>\n-}\n-\n-extern fn get_addr_cb(handle: *uv_getaddrinfo_t,\n-                      status: libc::c_int,\n-                      res: *addrinfo) {\n-    unsafe {\n-        debug!(\"in get_addr_cb\");\n-        let handle_data = get_data_for_req(handle) as\n-            *GetAddrData;\n-        let output_ch = (*handle_data).output_ch.clone();\n-        if status == 0i32 {\n-            if res != (ptr::null::<addrinfo>()) {\n-                let mut out_vec = ~[];\n-                debug!(\"initial addrinfo: %?\", res);\n-                let mut curr_addr = res;\n-                loop {\n-                    let new_ip_addr = if ll::is_ipv4_addrinfo(curr_addr) {\n-                        Ipv4(*ll::addrinfo_as_sockaddr_in(curr_addr))\n-                    }\n-                    else if ll::is_ipv6_addrinfo(curr_addr) {\n-                        Ipv6(*ll::addrinfo_as_sockaddr_in6(curr_addr))\n-                    }\n-                    else {\n-                        debug!(\"curr_addr is not of family AF_INET or \\\n-                                AF_INET6. Error.\");\n-                        output_ch.send(\n-                            result::Err(GetAddrUnknownError));\n-                        break;\n-                    };\n-                    out_vec.push(new_ip_addr);\n-\n-                    let next_addr = ll::get_next_addrinfo(curr_addr);\n-                    if next_addr == ptr::null::<addrinfo>() as *addrinfo {\n-                        debug!(\"null next_addr encountered. no mas\");\n-                        break;\n-                    }\n-                    else {\n-                        curr_addr = next_addr;\n-                        debug!(\"next_addr addrinfo: %?\", curr_addr);\n-                    }\n-                }\n-                debug!(\"successful process addrinfo result, len: %?\",\n-                                out_vec.len());\n-                output_ch.send(result::Ok(out_vec));\n-            }\n-            else {\n-                debug!(\"addrinfo pointer is NULL\");\n-                output_ch.send(\n-                    result::Err(GetAddrUnknownError));\n-            }\n-        }\n-        else {\n-            debug!(\"status != 0 error in get_addr_cb\");\n-            output_ch.send(\n-                result::Err(GetAddrUnknownError));\n-        }\n-        if res != (ptr::null::<addrinfo>()) {\n-            uv_freeaddrinfo(res);\n-        }\n-        debug!(\"leaving get_addr_cb\");\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use net::ip::*;\n-    use net::ip::v4;\n-    use net::ip::v6;\n-    use uv;\n-\n-    use std::result;\n-\n-    #[test]\n-    fn test_ip_ipv4_parse_and_format_ip() {\n-        let localhost_str = ~\"127.0.0.1\";\n-        assert!(format_addr(&v4::parse_addr(localhost_str))\n-                == localhost_str)\n-    }\n-    #[test]\n-    fn test_ip_ipv6_parse_and_format_ip() {\n-        let localhost_str = ~\"::1\";\n-        let format_result = format_addr(&v6::parse_addr(localhost_str));\n-        debug!(\"results: expected: '%s' actual: '%s'\",\n-            localhost_str, format_result);\n-        assert_eq!(format_result, localhost_str);\n-    }\n-    #[test]\n-    fn test_ip_ipv4_bad_parse() {\n-        match v4::try_parse_addr(\"b4df00d\") {\n-          result::Err(ref err_info) => {\n-            debug!(\"got error as expected %?\", err_info);\n-            assert!(true);\n-          }\n-          result::Ok(ref addr) => {\n-            fail!(\"Expected failure, but got addr %?\", addr);\n-          }\n-        }\n-    }\n-    #[test]\n-    #[ignore(target_os=\"win32\")]\n-    fn test_ip_ipv6_bad_parse() {\n-        match v6::try_parse_addr(\"::,~2234k;\") {\n-          result::Err(ref err_info) => {\n-            debug!(\"got error as expected %?\", err_info);\n-            assert!(true);\n-          }\n-          result::Ok(ref addr) => {\n-            fail!(\"Expected failure, but got addr %?\", addr);\n-          }\n-        }\n-    }\n-    #[test]\n-    #[ignore(reason = \"valgrind says it's leaky\")]\n-    fn test_ip_get_addr() {\n-        let localhost_name = ~\"localhost\";\n-        let iotask = &uv::global_loop::get();\n-        let ga_result = get_addr(localhost_name, iotask);\n-        if result::is_err(&ga_result) {\n-            fail!(\"got err result from net::ip::get_addr();\")\n-        }\n-        // note really sure how to reliably test/assert\n-        // this.. mostly just wanting to see it work, atm.\n-        let results = result::unwrap(ga_result);\n-        debug!(\"test_get_addr: Number of results for %s: %?\",\n-                        localhost_name, results.len());\n-        for results.iter().advance |r| {\n-            let ipv_prefix = match *r {\n-              Ipv4(_) => ~\"IPv4\",\n-              Ipv6(_) => ~\"IPv6\"\n-            };\n-            debug!(\"test_get_addr: result %s: '%s'\",\n-                            ipv_prefix, format_addr(r));\n-        }\n-        // at least one result.. this is going to vary from system\n-        // to system, based on stuff like the contents of /etc/hosts\n-        assert!(!results.is_empty());\n-    }\n-    #[test]\n-    #[ignore(reason = \"valgrind says it's leaky\")]\n-    fn test_ip_get_addr_bad_input() {\n-        let localhost_name = ~\"sjkl234m,./sdf\";\n-        let iotask = &uv::global_loop::get();\n-        let ga_result = get_addr(localhost_name, iotask);\n-        assert!(result::is_err(&ga_result));\n-    }\n-}"}, {"sha": "463260bd3dcdfc837fa18a7f730dd8d60d2ff7aa", "filename": "src/libextra/net/mod.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet%2Fmod.rs?ref=9ed82fbb43804ebc7e06daca5812079630ec8952", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Top-level module for network-related functionality.\n-\n-Basically, including this module gives you:\n-\n-* `tcp`\n-* `ip`\n-* `url`\n-\n-See each of those three modules for documentation on what they do.\n-*/\n-\n-pub mod tcp;\n-pub mod ip;\n-pub mod url;"}, {"sha": "038ffd5788cc7a94176fd80c122fb938ace2194a", "filename": "src/libextra/net/tcp.rs", "status": "removed", "additions": 0, "deletions": 1959, "changes": 1959, "blob_url": "https://github.com/rust-lang/rust/blob/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet%2Ftcp.rs?ref=9ed82fbb43804ebc7e06daca5812079630ec8952", "patch": "@@ -1,1959 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! High-level interface to libuv's TCP functionality\n-// FIXME #4425: Need FFI fixes\n-\n-#[allow(missing_doc)];\n-\n-\n-use future;\n-use future_spawn = future::spawn;\n-use ip = net::ip;\n-use uv;\n-use uv::iotask;\n-use uv::iotask::IoTask;\n-\n-use std::io;\n-use std::libc::size_t;\n-use std::libc;\n-use std::comm::{stream, Port, SharedChan};\n-use std::ptr;\n-use std::result::{Result};\n-use std::result;\n-use std::num;\n-use std::vec;\n-\n-pub mod rustrt {\n-    use std::libc;\n-\n-    #[nolink]\n-    extern {\n-        pub unsafe fn rust_uv_current_kernel_malloc(size: libc::c_uint)\n-                                                    -> *libc::c_void;\n-        pub unsafe fn rust_uv_current_kernel_free(mem: *libc::c_void);\n-        pub unsafe fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n-    }\n-}\n-\n-/**\n- * Encapsulates an open TCP/IP connection through libuv\n- *\n- * `TcpSocket` is non-copyable/sendable and automagically handles closing the\n- * underlying libuv data structures when it goes out of scope. This is the\n- * data structure that is used for read/write operations over a TCP stream.\n- */\n-pub struct TcpSocket {\n-  socket_data: @TcpSocketData,\n-}\n-\n-#[unsafe_destructor]\n-impl Drop for TcpSocket {\n-    fn drop(&self) {\n-        tear_down_socket_data(self.socket_data)\n-    }\n-}\n-\n-pub fn TcpSocket(socket_data: @TcpSocketData) -> TcpSocket {\n-    TcpSocket {\n-        socket_data: socket_data\n-    }\n-}\n-\n-/**\n- * A buffered wrapper for `net::tcp::TcpSocket`\n- *\n- * It is created with a call to `net::tcp::socket_buf()` and has impls that\n- * satisfy both the `io::Reader` and `io::Writer` traits.\n- */\n-pub struct TcpSocketBuf {\n-    data: @mut TcpBufferedSocketData,\n-    end_of_stream: @mut bool\n-}\n-\n-pub fn TcpSocketBuf(data: @mut TcpBufferedSocketData) -> TcpSocketBuf {\n-    TcpSocketBuf {\n-        data: data,\n-        end_of_stream: @mut false\n-    }\n-}\n-\n-/// Contains raw, string-based, error information returned from libuv\n-#[deriving(Clone)]\n-pub struct TcpErrData {\n-    err_name: ~str,\n-    err_msg: ~str,\n-}\n-\n-/// Details returned as part of a `Result::Err` result from `tcp::listen`\n-#[deriving(Clone)]\n-pub enum TcpListenErrData {\n-    /**\n-     * Some unplanned-for error. The first and second fields correspond\n-     * to libuv's `err_name` and `err_msg` fields, respectively.\n-     */\n-    GenericListenErr(~str, ~str),\n-    /**\n-     * Failed to bind to the requested IP/Port, because it is already in use.\n-     *\n-     * # Possible Causes\n-     *\n-     * * Attempting to bind to a port already bound to another listener\n-     */\n-    AddressInUse,\n-    /**\n-     * Request to bind to an IP/Port was denied by the system.\n-     *\n-     * # Possible Causes\n-     *\n-     * * Attemping to binding to an IP/Port as a non-Administrator\n-     *   on Windows Vista+\n-     * * Attempting to bind, as a non-priv'd\n-     *   user, to 'privileged' ports (< 1024) on *nix\n-     */\n-    AccessDenied\n-}\n-/// Details returned as part of a `Result::Err` result from `tcp::connect`\n-#[deriving(Clone)]\n-pub enum TcpConnectErrData {\n-    /**\n-     * Some unplanned-for error. The first and second fields correspond\n-     * to libuv's `err_name` and `err_msg` fields, respectively.\n-     */\n-    GenericConnectErr(~str, ~str),\n-    /// Invalid IP or invalid port\n-    ConnectionRefused\n-}\n-\n-/**\n- * Initiate a client connection over TCP/IP\n- *\n- * # Arguments\n- *\n- * * `input_ip` - The IP address (versions 4 or 6) of the remote host\n- * * `port` - the unsigned integer of the desired remote host port\n- * * `iotask` - a `uv::iotask` that the tcp request will run on\n- *\n- * # Returns\n- *\n- * A `result` that, if the operation succeeds, contains a\n- * `net::net::TcpSocket` that can be used to send and receive data to/from\n- * the remote host. In the event of failure, a\n- * `net::tcp::TcpConnectErrData` instance will be returned\n- */\n-pub fn connect(input_ip: ip::IpAddr, port: uint,\n-               iotask: &IoTask)\n-    -> result::Result<TcpSocket, TcpConnectErrData> {\n-    unsafe {\n-        let (result_po, result_ch) = stream::<ConnAttempt>();\n-        let result_ch = SharedChan::new(result_ch);\n-        let (closed_signal_po, closed_signal_ch) = stream::<()>();\n-        let closed_signal_ch = SharedChan::new(closed_signal_ch);\n-        let conn_data = ConnectReqData {\n-            result_ch: result_ch,\n-            closed_signal_ch: closed_signal_ch\n-        };\n-        let conn_data_ptr: *ConnectReqData = &conn_data;\n-        let (reader_po, reader_ch) = stream::<Result<~[u8], TcpErrData>>();\n-        let reader_ch = SharedChan::new(reader_ch);\n-        let stream_handle_ptr = malloc_uv_tcp_t();\n-        *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n-        let socket_data = @TcpSocketData {\n-            reader_po: @reader_po,\n-            reader_ch: reader_ch,\n-            stream_handle_ptr: stream_handle_ptr,\n-            connect_req: uv::ll::connect_t(),\n-            write_req: uv::ll::write_t(),\n-            ipv6: match input_ip {\n-                ip::Ipv4(_) => { false }\n-                ip::Ipv6(_) => { true }\n-            },\n-            iotask: iotask.clone()\n-        };\n-        let socket_data_ptr: *TcpSocketData = &*socket_data;\n-        // get an unsafe representation of our stream_handle_ptr that\n-        // we can send into the interact cb to be handled in libuv..\n-        debug!(\"stream_handle_ptr outside interact %?\",\n-                        stream_handle_ptr);\n-        do iotask::interact(iotask) |loop_ptr| {\n-            debug!(\"in interact cb for tcp client connect..\");\n-            debug!(\"stream_handle_ptr in interact %?\",\n-                            stream_handle_ptr);\n-            match uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n-                0i32 => {\n-                    debug!(\"tcp_init successful\");\n-                    debug!(\"dealing w/ ipv4 connection..\");\n-                    let connect_req_ptr: *uv::ll::uv_connect_t =\n-                        &(*socket_data_ptr).connect_req;\n-                    let addr_str = ip::format_addr(&input_ip);\n-                    let connect_result = match input_ip {\n-                        ip::Ipv4(ref addr) => {\n-                            // have to \"recreate\" the\n-                            // sockaddr_in/6 since the ip_addr\n-                            // discards the port info.. should\n-                            // probably add an additional rust\n-                            // type that actually is closer to\n-                            // what the libuv API expects (ip str\n-                            // + port num)\n-                            debug!(\"addr: %?\", addr);\n-                            let in_addr = uv::ll::ip4_addr(addr_str,\n-                                                           port as int);\n-                            uv::ll::tcp_connect(\n-                                connect_req_ptr,\n-                                stream_handle_ptr,\n-                                &in_addr,\n-                                tcp_connect_on_connect_cb)\n-                        }\n-                        ip::Ipv6(ref addr) => {\n-                            debug!(\"addr: %?\", addr);\n-                            let in_addr = uv::ll::ip6_addr(addr_str,\n-                                                           port as int);\n-                            uv::ll::tcp_connect6(\n-                                connect_req_ptr,\n-                                stream_handle_ptr,\n-                                &in_addr,\n-                                tcp_connect_on_connect_cb)\n-                        }\n-                    };\n-                    match connect_result {\n-                        0i32 => {\n-                            debug!(\"tcp_connect successful: \\\n-                                    stream %x,\n-                                    socket data %x\",\n-                                   stream_handle_ptr as uint,\n-                                   socket_data_ptr as uint);\n-                            // reusable data that we'll have for the\n-                            // duration..\n-                            uv::ll::set_data_for_uv_handle(\n-                                stream_handle_ptr,\n-                                socket_data_ptr as\n-                                *libc::c_void);\n-                            // just so the connect_cb can send the\n-                            // outcome..\n-                            uv::ll::set_data_for_req(connect_req_ptr,\n-                                                     conn_data_ptr);\n-                            debug!(\"leaving tcp_connect interact cb...\");\n-                            // let tcp_connect_on_connect_cb send on\n-                            // the result_ch, now..\n-                        }\n-                        _ => {\n-                            // immediate connect\n-                            // failure.. probably a garbage ip or\n-                            // somesuch\n-                            let err_data =\n-                                uv::ll::get_last_err_data(loop_ptr);\n-                            let result_ch = (*conn_data_ptr)\n-                                .result_ch.clone();\n-                            result_ch.send(ConnFailure(err_data));\n-                            uv::ll::set_data_for_uv_handle(\n-                                stream_handle_ptr,\n-                                conn_data_ptr);\n-                            uv::ll::close(stream_handle_ptr,\n-                                          stream_error_close_cb);\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    // failure to create a tcp handle\n-                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                    let result_ch = (*conn_data_ptr).result_ch.clone();\n-                    result_ch.send(ConnFailure(err_data));\n-                }\n-            }\n-        }\n-        match result_po.recv() {\n-            ConnSuccess => {\n-                debug!(\"tcp::connect - received success on result_po\");\n-                result::Ok(TcpSocket(socket_data))\n-            }\n-            ConnFailure(ref err_data) => {\n-                closed_signal_po.recv();\n-                debug!(\"tcp::connect - received failure on result_po\");\n-                // still have to free the malloc'd stream handle..\n-                rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n-                                                    as *libc::c_void);\n-                let tcp_conn_err = match err_data.err_name {\n-                    ~\"ECONNREFUSED\" => ConnectionRefused,\n-                    _ => GenericConnectErr(err_data.err_name.clone(),\n-                                           err_data.err_msg.clone())\n-                };\n-                result::Err(tcp_conn_err)\n-            }\n-        }\n-    }\n-}\n-\n-/**\n- * Write binary data to a tcp stream; Blocks until operation completes\n- *\n- * # Arguments\n- *\n- * * sock - a `TcpSocket` to write to\n- * * raw_write_data - a vector of `~[u8]` that will be written to the stream.\n- * This value must remain valid for the duration of the `write` call\n- *\n- * # Returns\n- *\n- * A `Result` object with a `()` value as the `Ok` variant, or a\n- * `TcpErrData` value as the `Err` variant\n- */\n-pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n-             -> result::Result<(), TcpErrData> {\n-    let socket_data_ptr: *TcpSocketData = &*sock.socket_data;\n-    write_common_impl(socket_data_ptr, raw_write_data)\n-}\n-\n-/**\n- * Write binary data to tcp stream; Returns a `future::Future` value\n- * immediately\n- *\n- * # Safety\n- *\n- * This function can produce unsafe results if:\n- *\n- * 1. the call to `write_future` is made\n- * 2. the `future::Future` value returned is never resolved via\n- * `Future::get`\n- * 3. and then the `TcpSocket` passed in to `write_future` leaves\n- * scope and is destructed before the task that runs the libuv write\n- * operation completes.\n- *\n- * As such: If using `write_future`, always be sure to resolve the returned\n- * `Future` so as to ensure libuv doesn't try to access a released write\n- * handle. Otherwise, use the blocking `tcp::write` function instead.\n- *\n- * # Arguments\n- *\n- * * sock - a `TcpSocket` to write to\n- * * raw_write_data - a vector of `~[u8]` that will be written to the stream.\n- * This value must remain valid for the duration of the `write` call\n- *\n- * # Returns\n- *\n- * A `Future` value that, once the `write` operation completes, resolves to a\n- * `Result` object with a `nil` value as the `Ok` variant, or a `TcpErrData`\n- * value as the `Err` variant\n- */\n-pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n-    -> future::Future<result::Result<(), TcpErrData>>\n-{\n-    let socket_data_ptr: *TcpSocketData = &*sock.socket_data;\n-    do future_spawn {\n-        let data_copy = raw_write_data.clone();\n-        write_common_impl(socket_data_ptr, data_copy)\n-    }\n-}\n-\n-/**\n- * Begin reading binary data from an open TCP connection; used with\n- * `read_stop`\n- *\n- * # Arguments\n- *\n- * * sock -- a `net::tcp::TcpSocket` for the connection to read from\n- *\n- * # Returns\n- *\n- * * A `Result` instance that will either contain a\n- * `std::comm::Port<Result<~[u8], TcpErrData>>` that the user can read\n- * (and * optionally, loop on) from until `read_stop` is called, or a\n- * `TcpErrData` record\n- */\n-pub fn read_start(sock: &TcpSocket)\n-                  -> result::Result<@Port<result::Result<~[u8],\n-                                                         TcpErrData>>,\n-                                    TcpErrData> {\n-    let socket_data: *TcpSocketData = &*sock.socket_data;\n-    read_start_common_impl(socket_data)\n-}\n-\n-/**\n- * Stop reading from an open TCP connection; used with `read_start`\n- *\n- * # Arguments\n- *\n- * * `sock` - a `net::tcp::TcpSocket` that you wish to stop reading on\n- */\n-pub fn read_stop(sock: &TcpSocket) -> result::Result<(), TcpErrData> {\n-    let socket_data: *TcpSocketData = &*sock.socket_data;\n-    read_stop_common_impl(socket_data)\n-}\n-\n-/**\n- * Reads a single chunk of data from `TcpSocket`; block until data/error\n- * recv'd\n- *\n- * Does a blocking read operation for a single chunk of data from a\n- * `TcpSocket` until a data arrives or an error is received. The provided\n- * `timeout_msecs` value is used to raise an error if the timeout period\n- * passes without any data received.\n- *\n- * # Arguments\n- *\n- * * `sock` - a `net::tcp::TcpSocket` that you wish to read from\n- * * `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n- * read attempt. Pass `0u` to wait indefinitely\n- */\n-pub fn read(sock: &TcpSocket, timeout_msecs: uint)\n-            -> result::Result<~[u8],TcpErrData> {\n-    let socket_data: *TcpSocketData = &*sock.socket_data;\n-    read_common_impl(socket_data, timeout_msecs)\n-}\n-\n-/**\n- * Reads a single chunk of data; returns a `future::Future<~[u8]>`\n- * immediately\n- *\n- * Does a non-blocking read operation for a single chunk of data from a\n- * `TcpSocket` and immediately returns a `Future` value representing the\n- * result. When resolving the returned `Future`, it will block until data\n- * arrives or an error is received. The provided `timeout_msecs`\n- * value is used to raise an error if the timeout period passes without any\n- * data received.\n- *\n- * # Safety\n- *\n- * This function can produce unsafe results if the call to `read_future` is\n- * made, the `future::Future` value returned is never resolved via\n- * `Future::get`, and then the `TcpSocket` passed in to `read_future` leaves\n- * scope and is destructed before the task that runs the libuv read\n- * operation completes.\n- *\n- * As such: If using `read_future`, always be sure to resolve the returned\n- * `Future` so as to ensure libuv doesn't try to access a released read\n- * handle. Otherwise, use the blocking `tcp::read` function instead.\n- *\n- * # Arguments\n- *\n- * * `sock` - a `net::tcp::TcpSocket` that you wish to read from\n- * * `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n- * read attempt. Pass `0u` to wait indefinitely\n- */\n-fn read_future(sock: &TcpSocket, timeout_msecs: uint)\n-               -> future::Future<result::Result<~[u8],TcpErrData>> {\n-    let socket_data: *TcpSocketData = &*sock.socket_data;\n-    do future_spawn {\n-        read_common_impl(socket_data, timeout_msecs)\n-    }\n-}\n-\n-/**\n- * Bind an incoming client connection to a `net::tcp::TcpSocket`\n- *\n- * # Notes\n- *\n- * It is safe to call `net::tcp::accept` _only_ within the context of the\n- * `new_connect_cb` callback provided as the final argument to the\n- * `net::tcp::listen` function.\n- *\n- * The `new_conn` opaque value is provided _only_ as the first argument to the\n- * `new_connect_cb` provided as a part of `net::tcp::listen`.\n- * It can be safely sent to another task but it _must_ be\n- * used (via `net::tcp::accept`) before the `new_connect_cb` call it was\n- * provided to returns.\n- *\n- * This implies that a port/chan pair must be used to make sure that the\n- * `new_connect_cb` call blocks until an attempt to create a\n- * `net::tcp::TcpSocket` is completed.\n- *\n- * # Example\n- *\n- * Here, the `new_conn` is used in conjunction with `accept` from within\n- * a task spawned by the `new_connect_cb` passed into `listen`\n- *\n- * ~~~ {.rust}\n- * do net::tcp::listen(remote_ip, remote_port, backlog, iotask,\n- *     // this callback is ran once after the connection is successfully\n- *     // set up\n- *     |kill_ch| {\n- *       // pass the kill_ch to your main loop or wherever you want\n- *       // to be able to externally kill the server from\n- *     })\n- *     // this callback is ran when a new connection arrives\n- *     |new_conn, kill_ch| {\n- *     let (cont_po, cont_ch) = comm::stream::<option::Option<TcpErrData>>();\n- *     do task::spawn {\n- *         let accept_result = net::tcp::accept(new_conn);\n- *         match accept_result {\n- *             Err(accept_error) => {\n- *                 cont_ch.send(Some(accept_error));\n- *                 // fail?\n- *             },\n- *             Ok(sock) => {\n- *                 cont_ch.send(None);\n- *                 // do work here\n- *             }\n- *         }\n- *     };\n- *     match cont_po.recv() {\n- *       // shut down listen()\n- *       Some(err_data) => kill_ch.send(Some(err_data)),\n- *       // wait for next connection\n- *       None => ()\n- *     }\n- * };\n- * ~~~\n- *\n- * # Arguments\n- *\n- * * `new_conn` - an opaque value used to create a new `TcpSocket`\n- *\n- * # Returns\n- *\n- * On success, this function will return a `net::tcp::TcpSocket` as the\n- * `Ok` variant of a `Result`. The `net::tcp::TcpSocket` is anchored within\n- * the task that `accept` was called within for its lifetime. On failure,\n- * this function will return a `net::tcp::TcpErrData` record\n- * as the `Err` variant of a `Result`.\n- */\n-pub fn accept(new_conn: TcpNewConnection)\n-    -> result::Result<TcpSocket, TcpErrData> {\n-    unsafe {\n-        match new_conn{\n-            NewTcpConn(server_handle_ptr) => {\n-                let server_data_ptr = uv::ll::get_data_for_uv_handle(\n-                    server_handle_ptr) as *TcpListenFcData;\n-                let (reader_po, reader_ch) = stream::<\n-                    Result<~[u8], TcpErrData>>();\n-                let reader_ch = SharedChan::new(reader_ch);\n-                let iotask = &(*server_data_ptr).iotask;\n-                let stream_handle_ptr = malloc_uv_tcp_t();\n-                *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) =\n-                    uv::ll::tcp_t();\n-                let client_socket_data: @TcpSocketData = @TcpSocketData {\n-                    reader_po: @reader_po,\n-                    reader_ch: reader_ch,\n-                    stream_handle_ptr : stream_handle_ptr,\n-                    connect_req : uv::ll::connect_t(),\n-                    write_req : uv::ll::write_t(),\n-                    ipv6: (*server_data_ptr).ipv6,\n-                    iotask : iotask.clone()\n-                };\n-                let client_socket_data_ptr: *TcpSocketData =\n-                    &*client_socket_data;\n-                let client_stream_handle_ptr =\n-                    (*client_socket_data_ptr).stream_handle_ptr;\n-\n-                let (result_po, result_ch) = stream::<Option<TcpErrData>>();\n-                let result_ch = SharedChan::new(result_ch);\n-\n-                // UNSAFE LIBUV INTERACTION BEGIN\n-                // .. normally this happens within the context of\n-                // a call to uv::hl::interact.. but we're breaking\n-                // the rules here because this always has to be\n-                // called within the context of a listen() new_connect_cb\n-                // callback (or it will likely fail and drown your cat)\n-                debug!(\"in interact cb for tcp::accept\");\n-                let loop_ptr = uv::ll::get_loop_for_uv_handle(\n-                    server_handle_ptr);\n-                match uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n-                    0i32 => {\n-                        debug!(\"uv_tcp_init successful for \\\n-                                     client stream\");\n-                        match uv::ll::accept(\n-                            server_handle_ptr as *libc::c_void,\n-                            client_stream_handle_ptr as *libc::c_void) {\n-                            0i32 => {\n-                                debug!(\"successfully accepted client \\\n-                                        connection: \\\n-                                        stream %x, \\\n-                                        socket data %x\",\n-                                       client_stream_handle_ptr as uint,\n-                                       client_socket_data_ptr as uint);\n-                                uv::ll::set_data_for_uv_handle(\n-                                    client_stream_handle_ptr,\n-                                    client_socket_data_ptr\n-                                    as *libc::c_void);\n-                                let ptr = uv::ll::get_data_for_uv_handle(\n-                                    client_stream_handle_ptr);\n-                                debug!(\"ptrs: %x %x\",\n-                                       client_socket_data_ptr as uint,\n-                                       ptr as uint);\n-                                result_ch.send(None);\n-                            }\n-                            _ => {\n-                                debug!(\"failed to accept client conn\");\n-                                result_ch.send(Some(\n-                                    uv::ll::get_last_err_data(\n-                                        loop_ptr).to_tcp_err()));\n-                            }\n-                        }\n-                    }\n-                    _ => {\n-                        debug!(\"failed to accept client stream\");\n-                        result_ch.send(Some(\n-                            uv::ll::get_last_err_data(\n-                                loop_ptr).to_tcp_err()));\n-                    }\n-                }\n-                // UNSAFE LIBUV INTERACTION END\n-                match result_po.recv() {\n-                    Some(err_data) => result::Err(err_data),\n-                    None => result::Ok(TcpSocket(client_socket_data))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/**\n- * Bind to a given IP/port and listen for new connections\n- *\n- * # Arguments\n- *\n- * * `host_ip` - a `net::ip::IpAddr` representing a unique IP\n- * (versions 4 or 6)\n- * * `port` - a uint representing the port to listen on\n- * * `backlog` - a uint representing the number of incoming connections\n- * to cache in memory\n- * * `hl_loop` - a `uv_iotask::IoTask` that the tcp request will run on\n- * * `on_establish_cb` - a callback that is evaluated if/when the listener\n- * is successfully established. it takes no parameters\n- * * `new_connect_cb` - a callback to be evaluated, on the libuv thread,\n- * whenever a client attempts to conect on the provided ip/port. the\n- * callback's arguments are:\n- *     * `new_conn` - an opaque type that can be passed to\n- *     `net::tcp::accept` in order to be converted to a `TcpSocket`.\n- *     * `kill_ch` - channel of type `std::comm::Chan<Option<tcp_err_data>>`.\n- *     this channel can be used to send a message to cause `listen` to begin\n- *     closing the underlying libuv data structures.\n- *\n- * # returns\n- *\n- * a `Result` instance containing empty data of type `()` on a\n- * successful/normal shutdown, and a `TcpListenErrData` enum in the event\n- * of listen exiting because of an error\n- */\n-pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n-              iotask: &IoTask,\n-              on_establish_cb: ~fn(SharedChan<Option<TcpErrData>>),\n-              new_connect_cb: ~fn(TcpNewConnection,\n-                                  SharedChan<Option<TcpErrData>>))\n-    -> result::Result<(), TcpListenErrData> {\n-    do listen_common(host_ip, port, backlog, iotask,\n-                     on_establish_cb)\n-        // on_connect_cb\n-        |handle| {\n-        unsafe {\n-            let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n-                as *TcpListenFcData;\n-            let new_conn = NewTcpConn(handle);\n-            let kill_ch = (*server_data_ptr).kill_ch.clone();\n-            new_connect_cb(new_conn, kill_ch);\n-        }\n-    }\n-}\n-\n-fn listen_common(host_ip: ip::IpAddr,\n-                 port: uint,\n-                 backlog: uint,\n-                 iotask: &IoTask,\n-                 on_establish_cb: ~fn(SharedChan<Option<TcpErrData>>),\n-                 on_connect_cb: ~fn(*uv::ll::uv_tcp_t))\n-              -> result::Result<(), TcpListenErrData> {\n-    let (stream_closed_po, stream_closed_ch) = stream::<()>();\n-    let stream_closed_ch = SharedChan::new(stream_closed_ch);\n-    let (kill_po, kill_ch) = stream::<Option<TcpErrData>>();\n-    let kill_ch = SharedChan::new(kill_ch);\n-    let server_stream = uv::ll::tcp_t();\n-    let server_stream_ptr: *uv::ll::uv_tcp_t = &server_stream;\n-    let server_data: TcpListenFcData = TcpListenFcData {\n-        server_stream_ptr: server_stream_ptr,\n-        stream_closed_ch: stream_closed_ch,\n-        kill_ch: kill_ch.clone(),\n-        on_connect_cb: on_connect_cb,\n-        iotask: iotask.clone(),\n-        ipv6: match &host_ip {\n-            &ip::Ipv4(_) => { false }\n-            &ip::Ipv6(_) => { true }\n-        },\n-        active: @mut true\n-    };\n-    let server_data_ptr: *TcpListenFcData = &server_data;\n-\n-    let (setup_po, setup_ch) = stream();\n-\n-    // this is to address a compiler warning about\n-    // an implicit copy.. it seems that double nested\n-    // will defeat a move sigil, as is done to the host_ip\n-    // arg above.. this same pattern works w/o complaint in\n-    // tcp::connect (because the iotask::interact cb isn't\n-    // nested within a core::comm::listen block)\n-    let loc_ip = host_ip;\n-    do iotask::interact(iotask) |loop_ptr| {\n-        unsafe {\n-            match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n-                0i32 => {\n-                    uv::ll::set_data_for_uv_handle(\n-                        server_stream_ptr,\n-                        server_data_ptr);\n-                    let addr_str = ip::format_addr(&loc_ip);\n-                    let bind_result = match loc_ip {\n-                        ip::Ipv4(ref addr) => {\n-                            debug!(\"addr: %?\", addr);\n-                            let in_addr = uv::ll::ip4_addr(\n-                                addr_str,\n-                                port as int);\n-                            uv::ll::tcp_bind(server_stream_ptr, &in_addr)\n-                        }\n-                        ip::Ipv6(ref addr) => {\n-                            debug!(\"addr: %?\", addr);\n-                            let in_addr = uv::ll::ip6_addr(\n-                                addr_str,\n-                                port as int);\n-                            uv::ll::tcp_bind6(server_stream_ptr, &in_addr)\n-                        }\n-                    };\n-                    match bind_result {\n-                        0i32 => {\n-                            match uv::ll::listen(\n-                                server_stream_ptr,\n-                                backlog as libc::c_int,\n-                                tcp_lfc_on_connection_cb) {\n-                                0i32 => setup_ch.send(None),\n-                                _ => {\n-                                    debug!(\n-                                        \"failure to uv_tcp_init\");\n-                                    let err_data =\n-                                        uv::ll::get_last_err_data(\n-                                            loop_ptr);\n-                                    setup_ch.send(Some(err_data));\n-                                }\n-                            }\n-                        }\n-                        _ => {\n-                            debug!(\"failure to uv_tcp_bind\");\n-                            let err_data = uv::ll::get_last_err_data(\n-                                loop_ptr);\n-                            setup_ch.send(Some(err_data));\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    debug!(\"failure to uv_tcp_bind\");\n-                    let err_data = uv::ll::get_last_err_data(\n-                        loop_ptr);\n-                    setup_ch.send(Some(err_data));\n-                }\n-            }\n-        }\n-    }\n-\n-    let setup_result = setup_po.recv();\n-\n-    match setup_result {\n-        Some(ref err_data) => {\n-            do iotask::interact(iotask) |loop_ptr| {\n-                unsafe {\n-                    debug!(\n-                        \"tcp::listen post-kill recv hl interact %?\",\n-                             loop_ptr);\n-                    *(*server_data_ptr).active = false;\n-                    uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n-                }\n-            };\n-            stream_closed_po.recv();\n-            match err_data.err_name {\n-                ~\"EACCES\" => {\n-                    debug!(\"Got EACCES error\");\n-                    result::Err(AccessDenied)\n-                }\n-                ~\"EADDRINUSE\" => {\n-                    debug!(\"Got EADDRINUSE error\");\n-                    result::Err(AddressInUse)\n-                }\n-                _ => {\n-                    debug!(\"Got '%s' '%s' libuv error\",\n-                                    err_data.err_name, err_data.err_msg);\n-                    result::Err(\n-                        GenericListenErr(err_data.err_name.clone(),\n-                                         err_data.err_msg.clone()))\n-                }\n-            }\n-        }\n-        None => {\n-            on_establish_cb(kill_ch.clone());\n-            let kill_result = kill_po.recv();\n-            do iotask::interact(iotask) |loop_ptr| {\n-                unsafe {\n-                    debug!(\n-                        \"tcp::listen post-kill recv hl interact %?\",\n-                             loop_ptr);\n-                    *(*server_data_ptr).active = false;\n-                    uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n-                }\n-            };\n-            stream_closed_po.recv();\n-            match kill_result {\n-                // some failure post bind/listen\n-                Some(ref err_data) => result::Err(GenericListenErr(\n-                    err_data.err_name.clone(),\n-                    err_data.err_msg.clone())),\n-                // clean exit\n-                None => result::Ok(())\n-            }\n-        }\n-    }\n-}\n-\n-\n-/**\n- * Convert a `net::tcp::TcpSocket` to a `net::tcp::TcpSocketBuf`.\n- *\n- * This function takes ownership of a `net::tcp::TcpSocket`, returning it\n- * stored within a buffered wrapper, which can be converted to a `io::Reader`\n- * or `io::Writer`\n- *\n- * # Arguments\n- *\n- * * `sock` -- a `net::tcp::TcpSocket` that you want to buffer\n- *\n- * # Returns\n- *\n- * A buffered wrapper that you can cast as an `io::Reader` or `io::Writer`\n- */\n-pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n-    TcpSocketBuf(@mut TcpBufferedSocketData {\n-        sock: sock, buf: ~[], buf_off: 0\n-    })\n-}\n-\n-/// Convenience methods extending `net::tcp::TcpSocket`\n-impl TcpSocket {\n-    pub fn read_start(&self) -> result::Result<@Port<\n-        result::Result<~[u8], TcpErrData>>, TcpErrData> {\n-        read_start(self)\n-    }\n-    pub fn read_stop(&self) ->\n-        result::Result<(), TcpErrData> {\n-        read_stop(self)\n-    }\n-    pub fn read(&self, timeout_msecs: uint) ->\n-        result::Result<~[u8], TcpErrData> {\n-        read(self, timeout_msecs)\n-    }\n-    pub fn read_future(&self, timeout_msecs: uint) ->\n-        future::Future<result::Result<~[u8], TcpErrData>> {\n-        read_future(self, timeout_msecs)\n-    }\n-    pub fn write(&self, raw_write_data: ~[u8])\n-        -> result::Result<(), TcpErrData> {\n-        write(self, raw_write_data)\n-    }\n-    pub fn write_future(&self, raw_write_data: ~[u8])\n-        -> future::Future<result::Result<(), TcpErrData>> {\n-        write_future(self, raw_write_data)\n-    }\n-    pub fn get_peer_addr(&self) -> ip::IpAddr {\n-        unsafe {\n-            if self.socket_data.ipv6 {\n-                let addr = uv::ll::ip6_addr(\"\", 0);\n-                uv::ll::tcp_getpeername6(self.socket_data.stream_handle_ptr,\n-                                         &addr);\n-                ip::Ipv6(addr)\n-            } else {\n-                let addr = uv::ll::ip4_addr(\"\", 0);\n-                uv::ll::tcp_getpeername(self.socket_data.stream_handle_ptr,\n-                                        &addr);\n-                ip::Ipv4(addr)\n-            }\n-        }\n-    }\n-}\n-\n-/// Implementation of `io::Reader` trait for a buffered `net::tcp::TcpSocket`\n-impl io::Reader for TcpSocketBuf {\n-    fn read(&self, buf: &mut [u8], len: uint) -> uint {\n-        if len == 0 { return 0 }\n-        let mut count: uint = 0;\n-\n-        loop {\n-          assert!(count < len);\n-\n-          // If possible, copy up to `len` bytes from the internal\n-          // `data.buf` into `buf`\n-          let nbuffered = self.data.buf.len() - self.data.buf_off;\n-          let needed = len - count;\n-            if nbuffered > 0 {\n-                unsafe {\n-                    let ncopy = num::min(nbuffered, needed);\n-                    let dst = ptr::mut_offset(\n-                        vec::raw::to_mut_ptr(buf), count);\n-                    let src = ptr::offset(\n-                        vec::raw::to_ptr(self.data.buf),\n-                        self.data.buf_off);\n-                    ptr::copy_memory(dst, src, ncopy);\n-                    self.data.buf_off += ncopy;\n-                    count += ncopy;\n-                }\n-          }\n-\n-          assert!(count <= len);\n-          if count == len {\n-              break;\n-          }\n-\n-          // We copied all the bytes we had in the internal buffer into\n-          // the result buffer, but the caller wants more bytes, so we\n-          // need to read in data from the socket. Note that the internal\n-          // buffer is of no use anymore as we read all bytes from it,\n-          // so we can throw it away.\n-          let read_result = {\n-            let data = &*self.data;\n-            read(&data.sock, 0)\n-          };\n-          if read_result.is_err() {\n-              let err_data = read_result.get_err();\n-\n-              if err_data.err_name == ~\"EOF\" {\n-                  *self.end_of_stream = true;\n-                  break;\n-              } else {\n-                  debug!(\"ERROR sock_buf as io::reader.read err %? %?\",\n-                         err_data.err_name, err_data.err_msg);\n-                  // As we have already copied data into result buffer,\n-                  // we cannot simply return 0 here. Instead the error\n-                  // should show up in a later call to read().\n-                  break;\n-              }\n-          } else {\n-              self.data.buf = result::unwrap(read_result);\n-              self.data.buf_off = 0;\n-          }\n-        }\n-\n-        count\n-    }\n-    fn read_byte(&self) -> int {\n-        loop {\n-          if self.data.buf.len() > self.data.buf_off {\n-            let c = self.data.buf[self.data.buf_off];\n-            self.data.buf_off += 1;\n-            return c as int\n-          }\n-\n-          let read_result = {\n-            let data = &*self.data;\n-            read(&data.sock, 0)\n-          };\n-          if read_result.is_err() {\n-              let err_data = read_result.get_err();\n-\n-              if err_data.err_name == ~\"EOF\" {\n-                  *self.end_of_stream = true;\n-                  return -1\n-              } else {\n-                  debug!(\"ERROR sock_buf as io::reader.read err %? %?\",\n-                         err_data.err_name, err_data.err_msg);\n-                  fail!()\n-              }\n-          } else {\n-              self.data.buf = result::unwrap(read_result);\n-              self.data.buf_off = 0;\n-          }\n-        }\n-    }\n-    fn eof(&self) -> bool {\n-        *self.end_of_stream\n-    }\n-    fn seek(&self, dist: int, seek: io::SeekStyle) {\n-        debug!(\"tcp_socket_buf seek stub %? %?\", dist, seek);\n-        // noop\n-    }\n-    fn tell(&self) -> uint {\n-        0u // noop\n-    }\n-}\n-\n-/// Implementation of `io::Reader` trait for a buffered `net::tcp::TcpSocket`\n-impl io::Writer for TcpSocketBuf {\n-    pub fn write(&self, data: &[u8]) {\n-        let socket_data_ptr: *TcpSocketData =\n-            &(*((*(self.data)).sock).socket_data);\n-        let w_result = write_common_impl(socket_data_ptr,\n-                                         data.slice(0, data.len()).to_owned());\n-        if w_result.is_err() {\n-            let err_data = w_result.get_err();\n-            debug!(\n-                \"ERROR sock_buf as io::writer.writer err: %? %?\",\n-                err_data.err_name, err_data.err_msg);\n-        }\n-    }\n-    fn seek(&self, dist: int, seek: io::SeekStyle) {\n-      debug!(\"tcp_socket_buf seek stub %? %?\", dist, seek);\n-        // noop\n-    }\n-    fn tell(&self) -> uint {\n-        0u\n-    }\n-    fn flush(&self) -> int {\n-        0\n-    }\n-    fn get_type(&self) -> io::WriterType {\n-        io::File\n-    }\n-}\n-\n-// INTERNAL API\n-\n-fn tear_down_socket_data(socket_data: @TcpSocketData) {\n-    unsafe {\n-        let (closed_po, closed_ch) = stream::<()>();\n-        let closed_ch = SharedChan::new(closed_ch);\n-        let close_data = TcpSocketCloseData {\n-            closed_ch: closed_ch\n-        };\n-        let close_data_ptr: *TcpSocketCloseData = &close_data;\n-        let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-        do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n-            debug!(\n-                \"interact dtor for tcp_socket stream %? loop %?\",\n-                     stream_handle_ptr, loop_ptr);\n-            uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n-                                           close_data_ptr);\n-            uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n-        };\n-        closed_po.recv();\n-        //the line below will most likely crash\n-        //log(debug, fmt!(\"about to free socket_data at %?\", socket_data));\n-        rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n-                                            as *libc::c_void);\n-        debug!(\"exiting dtor for tcp_socket\");\n-    }\n-}\n-\n-// shared implementation for tcp::read\n-fn read_common_impl(socket_data: *TcpSocketData, timeout_msecs: uint)\n-    -> result::Result<~[u8],TcpErrData> {\n-    unsafe {\n-        use timer;\n-\n-        debug!(\"starting tcp::read\");\n-        let iotask = &(*socket_data).iotask;\n-        let rs_result = read_start_common_impl(socket_data);\n-        if result::is_err(&rs_result) {\n-            let err_data = result::get_err(&rs_result);\n-            result::Err(err_data)\n-        }\n-        else {\n-            debug!(\"tcp::read before recv_timeout\");\n-            let read_result = if timeout_msecs > 0u {\n-                timer::recv_timeout(\n-                    iotask, timeout_msecs, result::unwrap(rs_result))\n-            } else {\n-                Some(result::get(&rs_result).recv())\n-            };\n-            debug!(\"tcp::read after recv_timeout\");\n-            match read_result {\n-                None => {\n-                    debug!(\"tcp::read: timed out..\");\n-                    let err_data = TcpErrData {\n-                        err_name: ~\"TIMEOUT\",\n-                        err_msg: ~\"req timed out\"\n-                    };\n-                    read_stop_common_impl(socket_data);\n-                    result::Err(err_data)\n-                }\n-                Some(data_result) => {\n-                    debug!(\"tcp::read got data\");\n-                    read_stop_common_impl(socket_data);\n-                    data_result\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// shared impl for read_stop\n-fn read_stop_common_impl(socket_data: *TcpSocketData) ->\n-    result::Result<(), TcpErrData> {\n-    unsafe {\n-        let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-        let (stop_po, stop_ch) = stream::<Option<TcpErrData>>();\n-        do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n-            debug!(\"in interact cb for tcp::read_stop\");\n-            match uv::ll::read_stop(stream_handle_ptr\n-                                    as *uv::ll::uv_stream_t) {\n-                0i32 => {\n-                    debug!(\"successfully called uv_read_stop\");\n-                    stop_ch.send(None);\n-                }\n-                _ => {\n-                    debug!(\"failure in calling uv_read_stop\");\n-                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                    stop_ch.send(Some(err_data.to_tcp_err()));\n-                }\n-            }\n-        }\n-        match stop_po.recv() {\n-            Some(err_data) => Err(err_data),\n-            None => Ok(())\n-        }\n-    }\n-}\n-\n-// shared impl for read_start\n-fn read_start_common_impl(socket_data: *TcpSocketData)\n-    -> result::Result<@Port<\n-        result::Result<~[u8], TcpErrData>>, TcpErrData> {\n-    unsafe {\n-        let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-        let (start_po, start_ch) = stream::<Option<uv::ll::uv_err_data>>();\n-        debug!(\"in tcp::read_start before interact loop\");\n-        do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n-            debug!(\"in tcp::read_start interact cb %?\",\n-                            loop_ptr);\n-            match uv::ll::read_start(stream_handle_ptr\n-                                     as *uv::ll::uv_stream_t,\n-                                     on_alloc_cb,\n-                                     on_tcp_read_cb) {\n-                0i32 => {\n-                    debug!(\"success doing uv_read_start\");\n-                    start_ch.send(None);\n-                }\n-                _ => {\n-                    debug!(\"error attempting uv_read_start\");\n-                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                    start_ch.send(Some(err_data));\n-                }\n-            }\n-        }\n-        match start_po.recv() {\n-            Some(ref err_data) => result::Err(\n-                err_data.to_tcp_err()),\n-            None => {\n-                result::Ok((*socket_data).reader_po)\n-            }\n-        }\n-    }\n-}\n-\n-// helper to convert a \"class\" vector of [u8] to a *[uv::ll::uv_buf_t]\n-\n-// shared implementation used by write and write_future\n-fn write_common_impl(socket_data_ptr: *TcpSocketData,\n-                     raw_write_data: ~[u8])\n-    -> result::Result<(), TcpErrData> {\n-    unsafe {\n-        let write_req_ptr: *uv::ll::uv_write_t =\n-            &(*socket_data_ptr).write_req;\n-        let stream_handle_ptr =\n-            (*socket_data_ptr).stream_handle_ptr;\n-        let write_buf_vec = ~[\n-            uv::ll::buf_init(vec::raw::to_ptr(raw_write_data),\n-                             raw_write_data.len())\n-        ];\n-        let write_buf_vec_ptr: *~[uv::ll::uv_buf_t] = &write_buf_vec;\n-        let (result_po, result_ch) = stream::<TcpWriteResult>();\n-        let result_ch = SharedChan::new(result_ch);\n-        let write_data = WriteReqData {\n-            result_ch: result_ch\n-        };\n-        let write_data_ptr: *WriteReqData = &write_data;\n-        do iotask::interact(&(*socket_data_ptr).iotask) |loop_ptr| {\n-            debug!(\"in interact cb for tcp::write %?\",\n-                            loop_ptr);\n-            match uv::ll::write(write_req_ptr,\n-                                stream_handle_ptr,\n-                                write_buf_vec_ptr,\n-                                tcp_write_complete_cb) {\n-                0i32 => {\n-                    debug!(\"uv_write() invoked successfully\");\n-                    uv::ll::set_data_for_req(write_req_ptr,\n-                                             write_data_ptr);\n-                }\n-                _ => {\n-                    debug!(\"error invoking uv_write()\");\n-                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                    let result_ch = (*write_data_ptr).result_ch.clone();\n-                    result_ch.send(TcpWriteError(err_data.to_tcp_err()));\n-                }\n-            }\n-        }\n-        // FIXME (#2656): Instead of passing unsafe pointers to local data,\n-        // and waiting here for the write to complete, we should transfer\n-        // ownership of everything to the I/O task and let it deal with the\n-        // aftermath, so we don't have to sit here blocking.\n-        match result_po.recv() {\n-            TcpWriteSuccess => Ok(()),\n-            TcpWriteError(err_data) => Err(err_data)\n-        }\n-    }\n-}\n-\n-enum TcpNewConnection {\n-    NewTcpConn(*uv::ll::uv_tcp_t)\n-}\n-\n-struct TcpListenFcData {\n-    server_stream_ptr: *uv::ll::uv_tcp_t,\n-    stream_closed_ch: SharedChan<()>,\n-    kill_ch: SharedChan<Option<TcpErrData>>,\n-    on_connect_cb: ~fn(*uv::ll::uv_tcp_t),\n-    iotask: IoTask,\n-    ipv6: bool,\n-    active: @mut bool,\n-}\n-\n-extern fn tcp_lfc_close_cb(handle: *uv::ll::uv_tcp_t) {\n-    unsafe {\n-        let server_data_ptr = uv::ll::get_data_for_uv_handle(\n-            handle) as *TcpListenFcData;\n-        let stream_closed_ch = (*server_data_ptr).stream_closed_ch.clone();\n-        stream_closed_ch.send(());\n-    }\n-}\n-\n-extern fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n-                                     status: libc::c_int) {\n-    unsafe {\n-        let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n-            as *TcpListenFcData;\n-        let kill_ch = (*server_data_ptr).kill_ch.clone();\n-        if *(*server_data_ptr).active {\n-            match status {\n-              0i32 => ((*server_data_ptr).on_connect_cb)(handle),\n-              _ => {\n-                let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n-                kill_ch.send(\n-                           Some(uv::ll::get_last_err_data(loop_ptr)\n-                                .to_tcp_err()));\n-                *(*server_data_ptr).active = false;\n-              }\n-            }\n-        }\n-    }\n-}\n-\n-fn malloc_uv_tcp_t() -> *uv::ll::uv_tcp_t {\n-    unsafe {\n-        rustrt::rust_uv_current_kernel_malloc(\n-            rustrt::rust_uv_helper_uv_tcp_t_size()) as *uv::ll::uv_tcp_t\n-    }\n-}\n-\n-enum TcpConnectResult {\n-    TcpConnected(TcpSocket),\n-    TcpConnectError(TcpErrData)\n-}\n-\n-enum TcpWriteResult {\n-    TcpWriteSuccess,\n-    TcpWriteError(TcpErrData)\n-}\n-\n-enum TcpReadStartResult {\n-    TcpReadStartSuccess(Port<TcpReadResult>),\n-    TcpReadStartError(TcpErrData)\n-}\n-\n-enum TcpReadResult {\n-    TcpReadData(~[u8]),\n-    TcpReadDone,\n-    TcpReadErr(TcpErrData)\n-}\n-\n-trait ToTcpErr {\n-    fn to_tcp_err(&self) -> TcpErrData;\n-}\n-\n-impl ToTcpErr for uv::ll::uv_err_data {\n-    fn to_tcp_err(&self) -> TcpErrData {\n-        TcpErrData {\n-            err_name: self.err_name.clone(),\n-            err_msg: self.err_msg.clone(),\n-        }\n-    }\n-}\n-\n-extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n-                         nread: libc::ssize_t,\n-                         buf: uv::ll::uv_buf_t) {\n-    unsafe {\n-        debug!(\"entering on_tcp_read_cb stream: %x nread: %?\",\n-                        stream as uint, nread);\n-        let loop_ptr = uv::ll::get_loop_for_uv_handle(stream);\n-        let socket_data_ptr = uv::ll::get_data_for_uv_handle(stream)\n-            as *TcpSocketData;\n-        debug!(\"socket data is %x\", socket_data_ptr as uint);\n-        match nread as int {\n-          // incoming err.. probably eof\n-          -1 => {\n-            let err_data = uv::ll::get_last_err_data(loop_ptr).to_tcp_err();\n-            debug!(\"on_tcp_read_cb: incoming err.. name %? msg %?\",\n-                            err_data.err_name, err_data.err_msg);\n-            let reader_ch = &(*socket_data_ptr).reader_ch;\n-            reader_ch.send(result::Err(err_data));\n-          }\n-          // do nothing .. unneeded buf\n-          0 => (),\n-          // have data\n-          _ => {\n-            // we have data\n-            debug!(\"tcp on_read_cb nread: %d\", nread as int);\n-            let reader_ch = &(*socket_data_ptr).reader_ch;\n-            let buf_base = uv::ll::get_base_from_buf(buf);\n-            let new_bytes = vec::from_buf(buf_base, nread as uint);\n-            reader_ch.send(result::Ok(new_bytes));\n-          }\n-        }\n-        uv::ll::free_base_of_buf(buf);\n-        debug!(\"exiting on_tcp_read_cb\");\n-    }\n-}\n-\n-extern fn on_alloc_cb(handle: *libc::c_void,\n-                      suggested_size: size_t)\n-    -> uv::ll::uv_buf_t {\n-    unsafe {\n-        debug!(\"tcp read on_alloc_cb!\");\n-        let char_ptr = uv::ll::malloc_buf_base_of(suggested_size);\n-        debug!(\"tcp read on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n-                         handle,\n-                         char_ptr as uint,\n-                         suggested_size as uint);\n-        uv::ll::buf_init(char_ptr, suggested_size as uint)\n-    }\n-}\n-\n-struct TcpSocketCloseData {\n-    closed_ch: SharedChan<()>,\n-}\n-\n-extern fn tcp_socket_dtor_close_cb(handle: *uv::ll::uv_tcp_t) {\n-    unsafe {\n-        let data = uv::ll::get_data_for_uv_handle(handle)\n-            as *TcpSocketCloseData;\n-        let closed_ch = (*data).closed_ch.clone();\n-        closed_ch.send(());\n-        debug!(\"tcp_socket_dtor_close_cb exiting..\");\n-    }\n-}\n-\n-extern fn tcp_write_complete_cb(write_req: *uv::ll::uv_write_t,\n-                              status: libc::c_int) {\n-    unsafe {\n-        let write_data_ptr = uv::ll::get_data_for_req(write_req)\n-            as *WriteReqData;\n-        if status == 0i32 {\n-            debug!(\"successful write complete\");\n-            let result_ch = (*write_data_ptr).result_ch.clone();\n-            result_ch.send(TcpWriteSuccess);\n-        } else {\n-            let stream_handle_ptr = uv::ll::get_stream_handle_from_write_req(\n-                write_req);\n-            let loop_ptr = uv::ll::get_loop_for_uv_handle(stream_handle_ptr);\n-            let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            debug!(\"failure to write\");\n-            let result_ch = (*write_data_ptr).result_ch.clone();\n-            result_ch.send(TcpWriteError(err_data.to_tcp_err()));\n-        }\n-    }\n-}\n-\n-struct WriteReqData {\n-    result_ch: SharedChan<TcpWriteResult>,\n-}\n-\n-struct ConnectReqData {\n-    result_ch: SharedChan<ConnAttempt>,\n-    closed_signal_ch: SharedChan<()>,\n-}\n-\n-extern fn stream_error_close_cb(handle: *uv::ll::uv_tcp_t) {\n-    unsafe {\n-        let data = uv::ll::get_data_for_uv_handle(handle) as\n-            *ConnectReqData;\n-        let closed_signal_ch = (*data).closed_signal_ch.clone();\n-        closed_signal_ch.send(());\n-        debug!(\"exiting steam_error_close_cb for %?\", handle);\n-    }\n-}\n-\n-extern fn tcp_connect_close_cb(handle: *uv::ll::uv_tcp_t) {\n-    debug!(\"closed client tcp handle %?\", handle);\n-}\n-\n-extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n-                                   status: libc::c_int) {\n-    unsafe {\n-        let conn_data_ptr = (uv::ll::get_data_for_req(connect_req_ptr)\n-                          as *ConnectReqData);\n-        let result_ch = (*conn_data_ptr).result_ch.clone();\n-        debug!(\"tcp_connect result_ch %?\", result_ch);\n-        let tcp_stream_ptr =\n-            uv::ll::get_stream_handle_from_connect_req(connect_req_ptr);\n-        match status {\n-          0i32 => {\n-            debug!(\"successful tcp connection!\");\n-            result_ch.send(ConnSuccess);\n-          }\n-          _ => {\n-            debug!(\"error in tcp_connect_on_connect_cb\");\n-            let loop_ptr = uv::ll::get_loop_for_uv_handle(tcp_stream_ptr);\n-            let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            debug!(\"err_data %? %?\", err_data.err_name,\n-                            err_data.err_msg);\n-            result_ch.send(ConnFailure(err_data));\n-            uv::ll::set_data_for_uv_handle(tcp_stream_ptr,\n-                                           conn_data_ptr);\n-            uv::ll::close(tcp_stream_ptr, stream_error_close_cb);\n-          }\n-        }\n-        debug!(\"leaving tcp_connect_on_connect_cb\");\n-    }\n-}\n-\n-enum ConnAttempt {\n-    ConnSuccess,\n-    ConnFailure(uv::ll::uv_err_data)\n-}\n-\n-struct TcpSocketData {\n-    reader_po: @Port<result::Result<~[u8], TcpErrData>>,\n-    reader_ch: SharedChan<result::Result<~[u8], TcpErrData>>,\n-    stream_handle_ptr: *uv::ll::uv_tcp_t,\n-    connect_req: uv::ll::uv_connect_t,\n-    write_req: uv::ll::uv_write_t,\n-    ipv6: bool,\n-    iotask: IoTask,\n-}\n-\n-struct TcpBufferedSocketData {\n-    sock: TcpSocket,\n-    buf: ~[u8],\n-    buf_off: uint\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use net::ip;\n-    use net::tcp::{GenericListenErr, TcpConnectErrData, TcpListenErrData};\n-    use net::tcp::{connect, accept, read, listen, TcpSocket, socket_buf};\n-    use net;\n-    use uv::iotask::IoTask;\n-    use uv;\n-\n-    use std::cell::Cell;\n-    use std::comm::{stream, SharedChan};\n-    use std::io;\n-    use std::result;\n-    use std::str;\n-    use std::task;\n-\n-    // FIXME don't run on fbsd or linux 32 bit (#2064)\n-    #[cfg(target_os=\"win32\")]\n-    #[cfg(target_os=\"darwin\")]\n-    #[cfg(target_os=\"linux\")]\n-    #[cfg(target_os=\"android\")]\n-    mod tcp_ipv4_server_and_client_test {\n-        #[cfg(target_arch=\"x86_64\")]\n-        mod impl64 {\n-            use net::tcp::test::*;\n-\n-            #[test]\n-            fn test_gl_tcp_server_and_client_ipv4() {\n-                impl_gl_tcp_ipv4_server_and_client();\n-            }\n-            #[test]\n-            fn test_gl_tcp_get_peer_addr() {\n-                impl_gl_tcp_ipv4_get_peer_addr();\n-            }\n-            #[test]\n-            fn test_gl_tcp_ipv4_client_error_connection_refused() {\n-                impl_gl_tcp_ipv4_client_error_connection_refused();\n-            }\n-            #[test]\n-            fn test_gl_tcp_server_address_in_use() {\n-                impl_gl_tcp_ipv4_server_address_in_use();\n-            }\n-            #[test]\n-            fn test_gl_tcp_server_access_denied() {\n-                impl_gl_tcp_ipv4_server_access_denied();\n-            }\n-            // Strange failure on Windows. --pcwalton\n-            #[test]\n-            #[ignore(cfg(target_os = \"win32\"))]\n-            fn test_gl_tcp_ipv4_server_client_reader_writer() {\n-                impl_gl_tcp_ipv4_server_client_reader_writer();\n-            }\n-            #[test]\n-            fn test_tcp_socket_impl_reader_handles_eof() {\n-                impl_tcp_socket_impl_reader_handles_eof();\n-            }\n-        }\n-        #[cfg(target_arch=\"x86\")]\n-        #[cfg(target_arch=\"arm\")]\n-        #[cfg(target_arch=\"mips\")]\n-        mod impl32 {\n-            use net::tcp::test::*;\n-\n-            #[test]\n-            #[ignore(cfg(target_os = \"linux\"))]\n-            fn test_gl_tcp_server_and_client_ipv4() {\n-                unsafe {\n-                    impl_gl_tcp_ipv4_server_and_client();\n-                }\n-            }\n-            #[test]\n-            #[ignore(cfg(target_os = \"linux\"))]\n-            fn test_gl_tcp_get_peer_addr() {\n-                unsafe {\n-                    impl_gl_tcp_ipv4_get_peer_addr();\n-                }\n-            }\n-            #[test]\n-            #[ignore(cfg(target_os = \"linux\"))]\n-            fn test_gl_tcp_ipv4_client_error_connection_refused() {\n-                unsafe {\n-                    impl_gl_tcp_ipv4_client_error_connection_refused();\n-                }\n-            }\n-            #[test]\n-            #[ignore(cfg(target_os = \"linux\"))]\n-            fn test_gl_tcp_server_address_in_use() {\n-                unsafe {\n-                    impl_gl_tcp_ipv4_server_address_in_use();\n-                }\n-            }\n-            #[test]\n-            #[ignore(cfg(target_os = \"linux\"))]\n-            #[ignore(cfg(windows), reason = \"deadlocking bots\")]\n-            fn test_gl_tcp_server_access_denied() {\n-                unsafe {\n-                    impl_gl_tcp_ipv4_server_access_denied();\n-                }\n-            }\n-            #[test]\n-            #[ignore(cfg(target_os = \"linux\"))]\n-            #[ignore(cfg(target_os = \"win32\"))]\n-            fn test_gl_tcp_ipv4_server_client_reader_writer() {\n-                impl_gl_tcp_ipv4_server_client_reader_writer();\n-            }\n-        }\n-    }\n-    pub fn impl_gl_tcp_ipv4_server_and_client() {\n-        let hl_loop = &uv::global_loop::get();\n-        let server_ip = \"127.0.0.1\";\n-        let server_port = 8888u;\n-        let expected_req = ~\"ping\";\n-        let expected_resp = \"pong\";\n-\n-        let (server_result_po, server_result_ch) = stream::<~str>();\n-\n-        let (cont_po, cont_ch) = stream::<()>();\n-        let cont_ch = SharedChan::new(cont_ch);\n-        // server\n-        let hl_loop_clone = hl_loop.clone();\n-        do task::spawn_sched(task::ManualThreads(1u)) {\n-            let cont_ch = cont_ch.clone();\n-            let actual_req = run_tcp_test_server(\n-                server_ip,\n-                server_port,\n-                expected_resp.to_str(),\n-                cont_ch.clone(),\n-                &hl_loop_clone);\n-            server_result_ch.send(actual_req);\n-        };\n-        cont_po.recv();\n-        // client\n-        debug!(\"server started, firing up client..\");\n-        let actual_resp_result = run_tcp_test_client(\n-            server_ip,\n-            server_port,\n-            expected_req,\n-            hl_loop);\n-        assert!(actual_resp_result.is_ok());\n-        let actual_resp = actual_resp_result.get();\n-        let actual_req = server_result_po.recv();\n-        debug!(\"REQ: expected: '%s' actual: '%s'\",\n-                       expected_req, actual_req);\n-        debug!(\"RESP: expected: '%s' actual: '%s'\",\n-                       expected_resp, actual_resp);\n-        assert!(actual_req.contains(expected_req));\n-        assert!(actual_resp.contains(expected_resp));\n-    }\n-    pub fn impl_gl_tcp_ipv4_get_peer_addr() {\n-        let hl_loop = &uv::global_loop::get();\n-        let server_ip = \"127.0.0.1\";\n-        let server_port = 8887u;\n-        let expected_resp = \"pong\";\n-\n-        let (cont_po, cont_ch) = stream::<()>();\n-        let cont_ch = SharedChan::new(cont_ch);\n-        // server\n-        let hl_loop_clone = hl_loop.clone();\n-        do task::spawn_sched(task::ManualThreads(1u)) {\n-            let cont_ch = cont_ch.clone();\n-            run_tcp_test_server(\n-                server_ip,\n-                server_port,\n-                expected_resp.to_str(),\n-                cont_ch.clone(),\n-                &hl_loop_clone);\n-        };\n-        cont_po.recv();\n-        // client\n-        debug!(\"server started, firing up client..\");\n-        let server_ip_addr = ip::v4::parse_addr(server_ip);\n-        let iotask = uv::global_loop::get();\n-        let connect_result = connect(server_ip_addr, server_port,\n-                                     &iotask);\n-\n-        let sock = result::unwrap(connect_result);\n-\n-        debug!(\"testing peer address\");\n-        // This is what we are actually testing!\n-        assert!(net::ip::format_addr(&sock.get_peer_addr()) ==\n-            ~\"127.0.0.1\");\n-        assert_eq!(net::ip::get_port(&sock.get_peer_addr()), 8887);\n-\n-        // Fulfill the protocol the test server expects\n-        let resp_bytes = \"ping\".as_bytes().to_owned();\n-        tcp_write_single(&sock, resp_bytes);\n-        debug!(\"message sent\");\n-        sock.read(0u);\n-        debug!(\"result read\");\n-    }\n-    pub fn impl_gl_tcp_ipv4_client_error_connection_refused() {\n-        let hl_loop = &uv::global_loop::get();\n-        let server_ip = \"127.0.0.1\";\n-        let server_port = 8889u;\n-        let expected_req = ~\"ping\";\n-        // client\n-        debug!(\"firing up client..\");\n-        let actual_resp_result = run_tcp_test_client(\n-            server_ip,\n-            server_port,\n-            expected_req,\n-            hl_loop);\n-        match actual_resp_result.get_err() {\n-          ConnectionRefused => (),\n-          _ => fail!(\"unknown error.. expected connection_refused\")\n-        }\n-    }\n-    pub fn impl_gl_tcp_ipv4_server_address_in_use() {\n-        let hl_loop = &uv::global_loop::get();\n-        let server_ip = \"127.0.0.1\";\n-        let server_port = 8890u;\n-        let expected_req = ~\"ping\";\n-        let expected_resp = \"pong\";\n-\n-        let (cont_po, cont_ch) = stream::<()>();\n-        let cont_ch = SharedChan::new(cont_ch);\n-        // server\n-        let hl_loop_clone = hl_loop.clone();\n-        do task::spawn_sched(task::ManualThreads(1u)) {\n-            let cont_ch = cont_ch.clone();\n-            run_tcp_test_server(\n-                server_ip,\n-                server_port,\n-                expected_resp.to_str(),\n-                cont_ch.clone(),\n-                &hl_loop_clone);\n-        }\n-        cont_po.recv();\n-        // this one should fail..\n-        let listen_err = run_tcp_test_server_fail(\n-                            server_ip,\n-                            server_port,\n-                            hl_loop);\n-        // client.. just doing this so that the first server tears down\n-        debug!(\"server started, firing up client..\");\n-        run_tcp_test_client(\n-            server_ip,\n-            server_port,\n-            expected_req,\n-            hl_loop);\n-        match listen_err {\n-          AddressInUse => {\n-            assert!(true);\n-          }\n-          _ => {\n-            fail!(\"expected address_in_use listen error, \\\n-                   but got a different error varient. check logs.\");\n-          }\n-        }\n-    }\n-    pub fn impl_gl_tcp_ipv4_server_access_denied() {\n-        let hl_loop = &uv::global_loop::get();\n-        let server_ip = \"127.0.0.1\";\n-        let server_port = 80u;\n-        // this one should fail..\n-        let listen_err = run_tcp_test_server_fail(\n-                            server_ip,\n-                            server_port,\n-                            hl_loop);\n-        match listen_err {\n-          AccessDenied => {\n-            assert!(true);\n-          }\n-          _ => {\n-            fail!(\"expected address_in_use listen error, \\\n-                   but got a different error varient. check logs.\");\n-          }\n-        }\n-    }\n-    pub fn impl_gl_tcp_ipv4_server_client_reader_writer() {\n-\n-        let iotask = &uv::global_loop::get();\n-        let server_ip = \"127.0.0.1\";\n-        let server_port = 8891u;\n-        let expected_req = ~\"ping\";\n-        let expected_resp = \"pong\";\n-\n-        let (server_result_po, server_result_ch) = stream::<~str>();\n-\n-        let (cont_po, cont_ch) = stream::<()>();\n-        let cont_ch = SharedChan::new(cont_ch);\n-        // server\n-        let iotask_clone = iotask.clone();\n-        do task::spawn_sched(task::ManualThreads(1u)) {\n-            let cont_ch = cont_ch.clone();\n-            let actual_req = run_tcp_test_server(\n-                server_ip,\n-                server_port,\n-                expected_resp.to_str(),\n-                cont_ch.clone(),\n-                &iotask_clone);\n-            server_result_ch.send(actual_req);\n-        };\n-        cont_po.recv();\n-        // client\n-        let server_addr = ip::v4::parse_addr(server_ip);\n-        let conn_result = connect(server_addr, server_port, iotask);\n-        if result::is_err(&conn_result) {\n-            assert!(false);\n-        }\n-        let sock_buf = @socket_buf(result::unwrap(conn_result));\n-        buf_write(sock_buf, expected_req);\n-\n-        // so contrived!\n-        let actual_resp = buf_read(sock_buf, expected_resp.as_bytes().len());\n-\n-        let actual_req = server_result_po.recv();\n-        debug!(\"REQ: expected: '%s' actual: '%s'\",\n-                       expected_req, actual_req);\n-        debug!(\"RESP: expected: '%s' actual: '%s'\",\n-                       expected_resp, actual_resp);\n-        assert!(actual_req.contains(expected_req));\n-        assert!(actual_resp.contains(expected_resp));\n-    }\n-\n-    pub fn impl_tcp_socket_impl_reader_handles_eof() {\n-        use std::io::{Reader,ReaderUtil};\n-\n-        let hl_loop = &uv::global_loop::get();\n-        let server_ip = \"127.0.0.1\";\n-        let server_port = 10041u;\n-        let expected_req = ~\"GET /\";\n-        let expected_resp = \"A string\\nwith multiple lines\\n\";\n-\n-        let (cont_po, cont_ch) = stream::<()>();\n-        let cont_ch = SharedChan::new(cont_ch);\n-        // server\n-        let hl_loop_clone = hl_loop.clone();\n-        do task::spawn_sched(task::ManualThreads(1u)) {\n-            let cont_ch = cont_ch.clone();\n-            run_tcp_test_server(\n-                server_ip,\n-                server_port,\n-                expected_resp.to_str(),\n-                cont_ch.clone(),\n-                &hl_loop_clone);\n-        };\n-        cont_po.recv();\n-        // client\n-        debug!(\"server started, firing up client..\");\n-        let server_addr = ip::v4::parse_addr(server_ip);\n-        let conn_result = connect(server_addr, server_port, hl_loop);\n-        if result::is_err(&conn_result) {\n-            assert!(false);\n-        }\n-        let sock_buf = @socket_buf(result::unwrap(conn_result));\n-        buf_write(sock_buf, expected_req);\n-\n-        let buf_reader = sock_buf as @Reader;\n-        let actual_response = str::from_bytes(buf_reader.read_whole_stream());\n-        debug!(\"Actual response: %s\", actual_response);\n-        assert!(expected_resp == actual_response);\n-    }\n-\n-    fn buf_write<W:io::Writer>(w: &W, val: &str) {\n-        debug!(\"BUF_WRITE: val len %?\", val.len());\n-        let b_slice = val.as_bytes();\n-        debug!(\"BUF_WRITE: b_slice len %?\",\n-               b_slice.len());\n-        w.write(b_slice)\n-    }\n-\n-    fn buf_read<R:io::Reader>(r: &R, len: uint) -> ~str {\n-        let new_bytes = (*r).read_bytes(len);\n-        debug!(\"in buf_read.. new_bytes len: %?\",\n-                        new_bytes.len());\n-        str::from_bytes(new_bytes)\n-    }\n-\n-    fn run_tcp_test_server(server_ip: &str, server_port: uint, resp: ~str,\n-                          cont_ch: SharedChan<()>,\n-                          iotask: &IoTask) -> ~str {\n-        let (server_po, server_ch) = stream::<~str>();\n-        let server_ch = SharedChan::new(server_ch);\n-        let server_ip_addr = ip::v4::parse_addr(server_ip);\n-        let resp_cell = Cell::new(resp);\n-        let listen_result = listen(server_ip_addr, server_port, 128,\n-                                   iotask,\n-            // on_establish_cb -- called when listener is set up\n-            |kill_ch| {\n-                debug!(\"establish_cb %?\",\n-                    kill_ch);\n-                cont_ch.send(());\n-            },\n-            // risky to run this on the loop, but some users\n-            // will want the POWER\n-            |new_conn, kill_ch| {\n-                let resp_cell2 = Cell::new(resp_cell.take());\n-                debug!(\"SERVER: new connection!\");\n-                let (cont_po, cont_ch) = stream();\n-                let server_ch = server_ch.clone();\n-                do task::spawn_sched(task::ManualThreads(1u)) {\n-                    debug!(\"SERVER: starting worker for new req\");\n-\n-                    let accept_result = accept(new_conn);\n-                    debug!(\"SERVER: after accept()\");\n-                    if result::is_err(&accept_result) {\n-                        debug!(\"SERVER: error accept connection\");\n-                        let err_data = result::get_err(&accept_result);\n-                        kill_ch.send(Some(err_data));\n-                        debug!(\n-                            \"SERVER/WORKER: send on err cont ch\");\n-                        cont_ch.send(());\n-                    }\n-                    else {\n-                        debug!(\"SERVER/WORKER: send on cont ch\");\n-                        cont_ch.send(());\n-                        let sock = result::unwrap(accept_result);\n-                        let peer_addr = sock.get_peer_addr();\n-                        debug!(\"SERVER: successfully accepted \\\n-                                connection from %s:%u\",\n-                                 ip::format_addr(&peer_addr),\n-                                 ip::get_port(&peer_addr));\n-                        let received_req_bytes = read(&sock, 0u);\n-                        match received_req_bytes {\n-                          result::Ok(data) => {\n-                            debug!(\"SERVER: got REQ str::from_bytes..\");\n-                            debug!(\"SERVER: REQ data len: %?\",\n-                                            data.len());\n-                            server_ch.send(\n-                                str::from_bytes(data));\n-                            debug!(\"SERVER: before write\");\n-                            let s = resp_cell2.take();\n-                            tcp_write_single(&sock, s.as_bytes().to_owned());\n-                            debug!(\"SERVER: after write.. die\");\n-                            kill_ch.send(None);\n-                          }\n-                          result::Err(err_data) => {\n-                            debug!(\"SERVER: error recvd: %s %s\",\n-                                err_data.err_name, err_data.err_msg);\n-                            kill_ch.send(Some(err_data));\n-                            server_ch.send(~\"\");\n-                          }\n-                        }\n-                        debug!(\"SERVER: worker spinning down\");\n-                    }\n-                }\n-                debug!(\"SERVER: waiting to recv on cont_ch\");\n-                cont_po.recv();\n-        });\n-        // err check on listen_result\n-        if result::is_err(&listen_result) {\n-            match result::get_err(&listen_result) {\n-              GenericListenErr(ref name, ref msg) => {\n-                fail!(\"SERVER: exited abnormally name %s msg %s\", *name, *msg);\n-              }\n-              AccessDenied => {\n-                fail!(\"SERVER: exited abnormally, got access denied..\");\n-              }\n-              AddressInUse => {\n-                fail!(\"SERVER: exited abnormally, got address in use...\");\n-              }\n-            }\n-        }\n-        let ret_val = server_po.recv();\n-        debug!(\"SERVER: exited and got return val: '%s'\", ret_val);\n-        ret_val\n-    }\n-\n-    fn run_tcp_test_server_fail(server_ip: &str, server_port: uint,\n-                                iotask: &IoTask) -> TcpListenErrData {\n-        let server_ip_addr = ip::v4::parse_addr(server_ip);\n-        let listen_result = listen(server_ip_addr, server_port, 128,\n-                                   iotask,\n-            // on_establish_cb -- called when listener is set up\n-            |kill_ch| {\n-                debug!(\"establish_cb %?\", kill_ch);\n-            },\n-            |new_conn, kill_ch| {\n-                fail!(\"SERVER: shouldn't be called.. %? %?\", new_conn, kill_ch);\n-        });\n-        // err check on listen_result\n-        if result::is_err(&listen_result) {\n-            result::get_err(&listen_result)\n-        }\n-        else {\n-            fail!(\"SERVER: did not fail as expected\")\n-        }\n-    }\n-\n-    fn run_tcp_test_client(server_ip: &str, server_port: uint, resp: &str,\n-                          iotask: &IoTask) -> result::Result<~str,\n-                                                    TcpConnectErrData> {\n-        let server_ip_addr = ip::v4::parse_addr(server_ip);\n-\n-        debug!(\"CLIENT: starting..\");\n-        let connect_result = connect(server_ip_addr, server_port,\n-                                     iotask);\n-        if result::is_err(&connect_result) {\n-            debug!(\"CLIENT: failed to connect\");\n-            let err_data = result::get_err(&connect_result);\n-            Err(err_data)\n-        }\n-        else {\n-            let sock = result::unwrap(connect_result);\n-            let resp_bytes = resp.as_bytes().to_owned();\n-            tcp_write_single(&sock, resp_bytes);\n-            let read_result = sock.read(0u);\n-            if read_result.is_err() {\n-                debug!(\"CLIENT: failure to read\");\n-                Ok(~\"\")\n-            }\n-            else {\n-                let ret_val = str::from_bytes(read_result.get());\n-                debug!(\"CLIENT: after client_ch recv ret: '%s'\",\n-                   ret_val);\n-                Ok(ret_val)\n-            }\n-        }\n-    }\n-\n-    fn tcp_write_single(sock: &TcpSocket, val: ~[u8]) {\n-        let mut write_result_future = sock.write_future(val);\n-        let write_result = write_result_future.get();\n-        if result::is_err(&write_result) {\n-            debug!(\"tcp_write_single: write failed!\");\n-            let err_data = result::get_err(&write_result);\n-            debug!(\"tcp_write_single err name: %s msg: %s\",\n-                err_data.err_name, err_data.err_msg);\n-            // meh. torn on what to do here.\n-            fail!(\"tcp_write_single failed\");\n-        }\n-    }\n-}"}, {"sha": "c5fb4b9292e344df075d734c0fb9aa958a13ac06", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -48,10 +48,11 @@ mod tests {\n     fn recursive_mkdir_rel() {\n         use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n         use std::os;\n+        use std::unstable::change_dir_locked;\n \n         let root = mkdtemp(&os::tmpdir(), \"recursive_mkdir_rel\").\n             expect(\"recursive_mkdir_rel\");\n-        assert!(do os::change_dir_locked(&root) {\n+        assert!(do change_dir_locked(&root) {\n             let path = Path(\"frob\");\n             debug!(\"recursive_mkdir_rel: Making: %s in cwd %s [%?]\", path.to_str(),\n                    os::getcwd().to_str(),\n@@ -78,10 +79,11 @@ mod tests {\n     fn recursive_mkdir_rel_2() {\n         use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n         use std::os;\n+        use std::unstable::change_dir_locked;\n \n         let root = mkdtemp(&os::tmpdir(), \"recursive_mkdir_rel_2\").\n             expect(\"recursive_mkdir_rel_2\");\n-        assert!(do os::change_dir_locked(&root) {\n+        assert!(do change_dir_locked(&root) {\n             let path = Path(\"./frob/baz\");\n             debug!(\"recursive_mkdir_rel_2: Making: %s in cwd %s [%?]\", path.to_str(),\n                    os::getcwd().to_str(), os::path_exists(&path));"}, {"sha": "1cfbeb9e514dda1f5eb9e5916c79e93ab94ff850", "filename": "src/libextra/timer.rs", "status": "removed", "additions": 0, "deletions": 296, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftimer.rs?ref=9ed82fbb43804ebc7e06daca5812079630ec8952", "patch": "@@ -1,296 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Utilities that leverage libuv's `uv_timer_*` API\n-\n-\n-use uv;\n-use uv::iotask;\n-use uv::iotask::IoTask;\n-\n-use std::cast::transmute;\n-use std::cast;\n-use std::comm::{stream, Chan, SharedChan, Port, select2i};\n-use std::either;\n-use std::libc::c_void;\n-use std::libc;\n-\n-/**\n- * Wait for timeout period then send provided value over a channel\n- *\n- * This call returns immediately. Useful as the building block for a number\n- * of higher-level timer functions.\n- *\n- * Is not guaranteed to wait for exactly the specified time, but will wait\n- * for *at least* that period of time.\n- *\n- * # Arguments\n- *\n- * * `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n- * * msecs - a timeout period, in milliseconds, to wait\n- * * ch - a channel of type T to send a `val` on\n- * * val - a value of type T to send over the provided `ch`\n- */\n-pub fn delayed_send<T:Send>(iotask: &IoTask,\n-                              msecs: uint,\n-                              ch: &Chan<T>,\n-                              val: T) {\n-    let (timer_done_po, timer_done_ch) = stream::<()>();\n-    let timer_done_ch = SharedChan::new(timer_done_ch);\n-    let timer = uv::ll::timer_t();\n-    let timer_ptr: *uv::ll::uv_timer_t = &timer;\n-    do iotask::interact(iotask) |loop_ptr| {\n-        unsafe {\n-            let init_result = uv::ll::timer_init(loop_ptr, timer_ptr);\n-            if (init_result == 0i32) {\n-                let start_result = uv::ll::timer_start(\n-                    timer_ptr, delayed_send_cb, msecs, 0u);\n-                if (start_result == 0i32) {\n-                    // Note: putting the channel into a ~\n-                    // to cast to *c_void\n-                    let timer_done_ch_clone = ~timer_done_ch.clone();\n-                    let timer_done_ch_ptr = transmute::<\n-                        ~SharedChan<()>, *c_void>(\n-                        timer_done_ch_clone);\n-                    uv::ll::set_data_for_uv_handle(\n-                        timer_ptr,\n-                        timer_done_ch_ptr);\n-                } else {\n-                    let error_msg = uv::ll::get_last_err_info(\n-                        loop_ptr);\n-                    fail!(\"timer::delayed_send() start failed: %s\", error_msg);\n-                }\n-            } else {\n-                let error_msg = uv::ll::get_last_err_info(loop_ptr);\n-                fail!(\"timer::delayed_send() init failed: %s\", error_msg);\n-            }\n-        }\n-    };\n-    // delayed_send_cb has been processed by libuv\n-    timer_done_po.recv();\n-    // notify the caller immediately\n-    ch.send(val);\n-    // uv_close for this timer has been processed\n-    timer_done_po.recv();\n-}\n-\n-/**\n- * Blocks the current task for (at least) the specified time period.\n- *\n- * Is not guaranteed to sleep for exactly the specified time, but will sleep\n- * for *at least* that period of time.\n- *\n- * # Arguments\n- *\n- * * `iotask` - a `uv::iotask` that the tcp request will run on\n- * * msecs - an amount of time, in milliseconds, for the current task to block\n- */\n-pub fn sleep(iotask: &IoTask, msecs: uint) {\n-    let (exit_po, exit_ch) = stream::<()>();\n-    delayed_send(iotask, msecs, &exit_ch, ());\n-    exit_po.recv();\n-}\n-\n-/**\n- * Receive on a port for (up to) a specified time, then return an `Option<T>`\n- *\n- * This call will block to receive on the provided port for up to the\n- * specified timeout. Depending on whether the provided port receives in that\n- * time period, `recv_timeout` will return an `Option<T>` representing the\n- * result.\n- *\n- * # Arguments\n- *\n- * * `iotask' - `uv::iotask` that the tcp request will run on\n- * * msecs - an mount of time, in milliseconds, to wait to receive\n- * * wait_port - a `std::comm::port<T>` to receive on\n- *\n- * # Returns\n- *\n- * An `Option<T>` representing the outcome of the call. If the call `recv`'d\n- * on the provided port in the allotted timeout period, then the result will\n- * be a `Some(T)`. If not, then `None` will be returned.\n- */\n-pub fn recv_timeout<T:Send>(iotask: &IoTask, msecs: uint, wait_po: &Port<T>)\n-                            -> Option<T> {\n-    let (timeout_po, timeout_ch) = stream::<()>();\n-    let mut timeout_po = timeout_po;\n-    delayed_send(iotask, msecs, &timeout_ch, ());\n-\n-    // XXX: Workaround due to ports and channels not being &mut. They should\n-    // be.\n-    unsafe {\n-        let wait_po = cast::transmute_mut(wait_po);\n-\n-        either::either(\n-            |_| {\n-                None\n-            }, |_| {\n-                Some(wait_po.recv())\n-            }, &select2i(&mut timeout_po, wait_po)\n-        )\n-    }\n-}\n-\n-// INTERNAL API\n-extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t, status: libc::c_int) {\n-    unsafe {\n-        debug!(\n-            \"delayed_send_cb handle %? status %?\", handle, status);\n-        // Faking a borrowed pointer to our ~SharedChan\n-        let timer_done_ch_ptr: &*c_void = &uv::ll::get_data_for_uv_handle(\n-            handle);\n-        let timer_done_ch_ptr = transmute::<&*c_void, &~SharedChan<()>>(\n-            timer_done_ch_ptr);\n-        let stop_result = uv::ll::timer_stop(handle);\n-        if (stop_result == 0i32) {\n-            timer_done_ch_ptr.send(());\n-            uv::ll::close(handle, delayed_send_close_cb);\n-        } else {\n-            let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n-            let error_msg = uv::ll::get_last_err_info(loop_ptr);\n-            fail!(\"timer::sleep() init failed: %s\", error_msg);\n-        }\n-    }\n-}\n-\n-extern fn delayed_send_close_cb(handle: *uv::ll::uv_timer_t) {\n-    unsafe {\n-        debug!(\"delayed_send_close_cb handle %?\", handle);\n-        let timer_done_ch_ptr = uv::ll::get_data_for_uv_handle(handle);\n-        let timer_done_ch = transmute::<*c_void, ~SharedChan<()>>(\n-            timer_done_ch_ptr);\n-        timer_done_ch.send(());\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use timer::*;\n-    use uv;\n-\n-    use std::cell::Cell;\n-    use std::pipes::{stream, SharedChan};\n-    use std::rand::RngUtil;\n-    use std::rand;\n-    use std::task;\n-\n-    #[test]\n-    fn test_gl_timer_simple_sleep_test() {\n-        let hl_loop = &uv::global_loop::get();\n-        sleep(hl_loop, 1u);\n-    }\n-\n-    #[test]\n-    fn test_gl_timer_sleep_stress1() {\n-        let hl_loop = &uv::global_loop::get();\n-        for 50u.times {\n-            sleep(hl_loop, 1u);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_gl_timer_sleep_stress2() {\n-        let (po, ch) = stream();\n-        let ch = SharedChan::new(ch);\n-        let hl_loop = &uv::global_loop::get();\n-\n-        let repeat = 20u;\n-        let spec = {\n-\n-            ~[(1u,  20u),\n-             (10u, 10u),\n-             (20u, 2u)]\n-\n-        };\n-\n-        for repeat.times {\n-            let ch = ch.clone();\n-            for spec.iter().advance |spec| {\n-                let (times, maxms) = *spec;\n-                let ch = ch.clone();\n-                let hl_loop_clone = hl_loop.clone();\n-                do task::spawn {\n-                    use std::rand::*;\n-                    let mut rng = rng();\n-                    for times.times {\n-                        sleep(&hl_loop_clone, rng.next() as uint % maxms);\n-                    }\n-                    ch.send(());\n-                }\n-            }\n-        }\n-\n-        for (repeat * spec.len()).times {\n-            po.recv()\n-        }\n-    }\n-\n-    // Because valgrind serializes multithreaded programs it can\n-    // make timing-sensitive tests fail in wierd ways. In these\n-    // next test we run them many times and expect them to pass\n-    // the majority of tries.\n-\n-    #[test]\n-    #[cfg(ignore)]\n-    fn test_gl_timer_recv_timeout_before_time_passes() {\n-        let times = 100;\n-        let mut successes = 0;\n-        let mut failures = 0;\n-        let hl_loop = uv::global_loop::get();\n-\n-        for (times as uint).times {\n-            task::yield();\n-\n-            let expected = rand::rng().gen_str(16u);\n-            let (test_po, test_ch) = stream::<~str>();\n-\n-            do task::spawn() {\n-                delayed_send(hl_loop, 1u, &test_ch, expected);\n-            };\n-\n-            match recv_timeout(hl_loop, 10u, &test_po) {\n-              Some(val) => {\n-                assert_eq!(val, expected);\n-                successes += 1;\n-              }\n-              _ => failures += 1\n-            };\n-        }\n-\n-        assert!(successes > times / 2);\n-    }\n-\n-    #[test]\n-    fn test_gl_timer_recv_timeout_after_time_passes() {\n-        let times = 100;\n-        let mut successes = 0;\n-        let mut failures = 0;\n-        let hl_loop = uv::global_loop::get();\n-\n-        for (times as uint).times {\n-            let mut rng = rand::rng();\n-            let expected = Cell::new(rng.gen_str(16u));\n-            let (test_po, test_ch) = stream::<~str>();\n-            let hl_loop_clone = hl_loop.clone();\n-            do task::spawn() {\n-                delayed_send(&hl_loop_clone, 50u, &test_ch, expected.take());\n-            };\n-\n-            match recv_timeout(&hl_loop, 1u, &test_po) {\n-              None => successes += 1,\n-              _ => failures += 1\n-            };\n-        }\n-\n-        assert!(successes > times / 2);\n-    }\n-}"}, {"sha": "563619bb52d60ba182e09468a62d83eaf3eb7a5f", "filename": "src/libextra/url.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -800,7 +800,7 @@ fn test_get_path() {\n #[cfg(test)]\n mod tests {\n \n-    use net::url::*;\n+    use super::*;\n \n     use std::hashmap::HashMap;\n ", "previous_filename": "src/libextra/net/url.rs"}, {"sha": "e055b40705773dc6382d1274c5bdfb05292a2ae9", "filename": "src/libextra/uv.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv.rs?ref=9ed82fbb43804ebc7e06daca5812079630ec8952", "patch": "@@ -1,38 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * Rust bindings to libuv\n- *\n- * This is the base-module for various levels of bindings to\n- * the libuv library.\n- *\n- * These modules are seeing heavy work, currently, and the final\n- * API layout should not be inferred from its current form.\n- *\n- * This base module currently contains a historical, rust-based\n- * implementation of a few libuv operations that hews closely to\n- * the patterns of the libuv C-API. It was used, mostly, to explore\n- * some implementation details and will most likely be deprecated\n- * in the near future.\n- *\n- * The `ll` module contains low-level mappings for working directly\n- * with the libuv C-API.\n- *\n- * The `hl` module contains a set of tools library developers can\n- * use for interacting with an active libuv loop. This modules's\n- * API is meant to be used to write high-level,\n- * rust-idiomatic abstractions for utilizes libuv's asynchronous IO\n- * facilities.\n- */\n-\n-pub use ll = super::uv_ll;\n-pub use iotask = uv_iotask;\n-pub use global_loop = uv_global_loop;"}, {"sha": "5501d73ac86802d9cfb07488d66de7599614df68", "filename": "src/libextra/uv_global_loop.rs", "status": "removed", "additions": 0, "deletions": 227, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_global_loop.rs?ref=9ed82fbb43804ebc7e06daca5812079630ec8952", "patch": "@@ -1,227 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A process-wide libuv event loop for library use.\n-\n-\n-use iotask = uv_iotask;\n-use uv_iotask::{IoTask, spawn_iotask};\n-\n-use std::comm::Chan;\n-use std::option::{Some, None};\n-use std::task::task;\n-use std::unstable::global::{global_data_clone_create, global_data_clone};\n-use std::unstable::weak_task::weaken_task;\n-\n-/**\n- * Race-free helper to get access to a global task where a libuv\n- * loop is running.\n- *\n- * Use `uv::hl::interact` to do operations against the global\n- * loop that this function returns.\n- *\n- * # Return\n- *\n- * * A `hl::high_level_loop` that encapsulates communication with the global\n- * loop.\n- */\n-pub fn get() -> IoTask {\n-    return get_monitor_task_gl();\n-}\n-\n-#[doc(hidden)]\n-fn get_monitor_task_gl() -> IoTask {\n-\n-    type MonChan = Chan<IoTask>;\n-\n-    struct GlobalIoTask(IoTask);\n-\n-    impl Clone for GlobalIoTask {\n-        fn clone(&self) -> GlobalIoTask {\n-            GlobalIoTask((**self).clone())\n-        }\n-    }\n-\n-    fn key(_: GlobalIoTask) { }\n-\n-    match unsafe { global_data_clone(key) } {\n-        Some(GlobalIoTask(iotask)) => iotask,\n-        None => {\n-            let iotask: IoTask = spawn_loop();\n-            let mut installed = false;\n-            let final_iotask = unsafe {\n-                do global_data_clone_create(key) {\n-                    installed = true;\n-                    ~GlobalIoTask(iotask.clone())\n-                }\n-            };\n-            if installed {\n-                let mut task = task();\n-                task.unlinked();\n-                do task.spawn {\n-                    unsafe {\n-                        debug!(\"global monitor task starting\");\n-                        // As a weak task the runtime will notify us\n-                        // when to exit\n-                        do weaken_task |weak_exit_po| {\n-                            debug!(\"global monitor task is weak\");\n-                            weak_exit_po.recv();\n-                            iotask::exit(&iotask);\n-                            debug!(\"global monitor task is unweak\");\n-                        };\n-                        debug!(\"global monitor task exiting\");\n-                    }\n-                }\n-            } else {\n-                iotask::exit(&iotask);\n-            }\n-\n-            match final_iotask {\n-                GlobalIoTask(iotask) => iotask\n-            }\n-        }\n-    }\n-}\n-\n-fn spawn_loop() -> IoTask {\n-    let mut builder = task();\n-\n-    do builder.add_wrapper |task_body| {\n-        let result: ~fn() = || {\n-            // The I/O loop task also needs to be weak so it doesn't keep\n-            // the runtime alive\n-            unsafe {\n-                do weaken_task |_| {\n-                    debug!(\"global libuv task is now weak\");\n-                    task_body();\n-\n-                    // We don't wait for the exit message on weak_exit_po\n-                    // because the monitor task will tell the uv loop when to\n-                    // exit\n-\n-                    debug!(\"global libuv task is leaving weakened state\");\n-                }\n-            }\n-        };\n-        result\n-    };\n-\n-    builder.unlinked();\n-    spawn_iotask(builder)\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use get_gl = uv_global_loop::get;\n-    use uv::iotask;\n-    use uv::ll;\n-    use uv_iotask::IoTask;\n-\n-    use std::libc;\n-    use std::task;\n-    use std::cast::transmute;\n-    use std::libc::c_void;\n-    use std::comm::{stream, SharedChan, Chan};\n-\n-    extern fn simple_timer_close_cb(timer_ptr: *ll::uv_timer_t) {\n-        unsafe {\n-            let exit_ch_ptr = ll::get_data_for_uv_handle(\n-                timer_ptr as *libc::c_void);\n-            let exit_ch = transmute::<*c_void, ~Chan<bool>>(exit_ch_ptr);\n-            exit_ch.send(true);\n-            debug!(\"EXIT_CH_PTR simple_timer_close_cb exit_ch_ptr: %?\",\n-                     exit_ch_ptr);\n-        }\n-    }\n-    extern fn simple_timer_cb(timer_ptr: *ll::uv_timer_t,\n-                             _status: libc::c_int) {\n-        unsafe {\n-            debug!(~\"in simple timer cb\");\n-            ll::timer_stop(timer_ptr);\n-            let hl_loop = &get_gl();\n-            do iotask::interact(hl_loop) |_loop_ptr| {\n-                debug!(~\"closing timer\");\n-                ll::close(timer_ptr, simple_timer_close_cb);\n-                debug!(~\"about to deref exit_ch_ptr\");\n-                debug!(~\"after msg sent on deref'd exit_ch\");\n-            };\n-            debug!(~\"exiting simple timer cb\");\n-        }\n-    }\n-\n-    fn impl_uv_hl_simple_timer(iotask: &IoTask) {\n-        unsafe {\n-            let (exit_po, exit_ch) = stream::<bool>();\n-            let exit_ch_ptr: *libc::c_void = transmute(~exit_ch);\n-            debug!(\"EXIT_CH_PTR newly created exit_ch_ptr: %?\",\n-                            exit_ch_ptr);\n-            let timer_handle = ll::timer_t();\n-            let timer_ptr: *ll::uv_timer_t = &timer_handle;\n-            do iotask::interact(iotask) |loop_ptr| {\n-                debug!(~\"user code inside interact loop!!!\");\n-                let init_status = ll::timer_init(loop_ptr, timer_ptr);\n-                if(init_status == 0i32) {\n-                    ll::set_data_for_uv_handle(\n-                        timer_ptr as *libc::c_void,\n-                        exit_ch_ptr);\n-                    let start_status = ll::timer_start(timer_ptr,\n-                                                       simple_timer_cb,\n-                                                       1u, 0u);\n-                    if(start_status != 0i32) {\n-                        fail!(\"failure on ll::timer_start()\");\n-                    }\n-                }\n-                else {\n-                    fail!(\"failure on ll::timer_init()\");\n-                }\n-            };\n-            exit_po.recv();\n-            debug!(\n-                ~\"global_loop timer test: msg recv on exit_po, done..\");\n-        }\n-    }\n-\n-    #[test]\n-    fn test_gl_uv_global_loop_high_level_global_timer() {\n-        let hl_loop = &get_gl();\n-        let (exit_po, exit_ch) = stream::<()>();\n-        task::spawn_sched(task::ManualThreads(1u), || {\n-            let hl_loop = &get_gl();\n-            impl_uv_hl_simple_timer(hl_loop);\n-            exit_ch.send(());\n-        });\n-        impl_uv_hl_simple_timer(hl_loop);\n-        exit_po.recv();\n-    }\n-\n-    // keeping this test ignored until some kind of stress-test-harness\n-    // is set up for the build bots\n-    #[test]\n-    #[ignore]\n-    fn test_stress_gl_uv_global_loop_high_level_global_timer() {\n-        let (exit_po, exit_ch) = stream::<()>();\n-        let exit_ch = SharedChan::new(exit_ch);\n-        let cycles = 5000u;\n-        for cycles.times {\n-            let exit_ch_clone = exit_ch.clone();\n-            task::spawn_sched(task::ManualThreads(1u), || {\n-                let hl_loop = &get_gl();\n-                impl_uv_hl_simple_timer(hl_loop);\n-                exit_ch_clone.send(());\n-            });\n-        };\n-        for cycles.times {\n-            exit_po.recv();\n-        };\n-        debug!(\"test_stress_gl_uv_global_loop_high_level_global_timer \\\n-                exiting successfully!\");\n-    }\n-}"}, {"sha": "0a564045d32f06176ab045fa842b77387dcd69d4", "filename": "src/libextra/uv_iotask.rs", "status": "removed", "additions": 0, "deletions": 311, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_iotask.rs?ref=9ed82fbb43804ebc7e06daca5812079630ec8952", "patch": "@@ -1,311 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * A task-based interface to the uv loop\n- *\n- * The I/O task runs in its own single-threaded scheduler.  By using the\n- * `interact` function you can execute code in a uv callback.\n- */\n-\n-#[allow(missing_doc)];\n-\n-\n-use ll = uv_ll;\n-\n-use std::comm::{stream, Port, Chan, SharedChan};\n-use std::libc::c_void;\n-use std::libc;\n-use std::task;\n-\n-/// Used to abstract-away direct interaction with a libuv loop.\n-pub struct IoTask {\n-    async_handle: *ll::uv_async_t,\n-    op_chan: SharedChan<IoTaskMsg>\n-}\n-\n-impl Clone for IoTask {\n-    fn clone(&self) -> IoTask {\n-        IoTask{\n-            async_handle: self.async_handle,\n-            op_chan: self.op_chan.clone()\n-        }\n-    }\n-}\n-\n-pub fn spawn_iotask(mut task: task::TaskBuilder) -> IoTask {\n-    let (iotask_port, iotask_chan) = stream();\n-\n-    task.sched_mode(task::SingleThreaded);\n-    do task.spawn {\n-        debug!(\"entering libuv task\");\n-        run_loop(&iotask_chan);\n-        debug!(\"libuv task exiting\");\n-    };\n-\n-    iotask_port.recv()\n-}\n-\n-\n-/**\n- * Provide a callback to be processed by `iotask`\n- *\n- * The primary way to do operations again a running `iotask` that\n- * doesn't involve creating a uv handle via `safe_handle`\n- *\n- * # Warning\n- *\n- * This function is the only safe way to interact with _any_ `iotask`.\n- * Using functions in the `uv::ll` module outside of the `cb` passed into\n- * this function is _very dangerous_.\n- *\n- * # Arguments\n- *\n- * * iotask - a uv I/O task that you want to do operations against\n- * * cb - a function callback to be processed on the running loop's\n- * thread. The only parameter passed in is an opaque pointer representing the\n- * running `uv_loop_t*`. In the context of this callback, it is safe to use\n- * this pointer to do various uv_* API calls contained within the `uv::ll`\n- * module. It is not safe to send the `loop_ptr` param to this callback out\n- * via ports/chans.\n- */\n-pub fn interact(iotask: &IoTask, cb: ~fn(*c_void)) {\n-    send_msg(iotask, Interaction(cb));\n-}\n-\n-/**\n- * Shut down the I/O task\n- *\n- * Is used to signal to the loop that it should close the internally-held\n- * async handle and do a sanity check to make sure that all other handles are\n- * closed, causing a failure otherwise.\n- */\n-pub fn exit(iotask: &IoTask) {\n-    send_msg(iotask, TeardownLoop);\n-}\n-\n-\n-// INTERNAL API\n-\n-enum IoTaskMsg {\n-    Interaction(~fn(*libc::c_void)),\n-    TeardownLoop\n-}\n-\n-/// Run the loop and begin handling messages\n-fn run_loop(iotask_ch: &Chan<IoTask>) {\n-\n-    unsafe {\n-        debug!(\"creating loop\");\n-        let loop_ptr = ll::loop_new();\n-\n-        // set up the special async handle we'll use to allow multi-task\n-        // communication with this loop\n-        let async = ll::async_t();\n-        let async_handle: *ll::uv_async_t = &async;\n-\n-        // associate the async handle with the loop\n-        ll::async_init(loop_ptr, async_handle, wake_up_cb);\n-\n-        let (msg_po, msg_ch) = stream::<IoTaskMsg>();\n-\n-        // initialize our loop data and store it in the loop\n-        let data: IoTaskLoopData = IoTaskLoopData {\n-            async_handle: async_handle,\n-            msg_po: msg_po\n-        };\n-        ll::set_data_for_uv_handle(async_handle, &data);\n-\n-        // Send out a handle through which folks can talk to us\n-        // while we dwell in the I/O loop\n-        let iotask = IoTask {\n-            async_handle: async_handle,\n-            op_chan: SharedChan::new(msg_ch)\n-        };\n-        iotask_ch.send(iotask);\n-\n-        debug!(\"about to run uv loop\");\n-        // enter the loop... this blocks until the loop is done..\n-        ll::run(loop_ptr);\n-        debug!(\"uv loop ended\");\n-        ll::loop_delete(loop_ptr);\n-    }\n-}\n-\n-// data that lives for the lifetime of the high-evel oo\n-struct IoTaskLoopData {\n-    async_handle: *ll::uv_async_t,\n-    msg_po: Port<IoTaskMsg>,\n-}\n-\n-fn send_msg(iotask: &IoTask,\n-            msg: IoTaskMsg) {\n-    iotask.op_chan.send(msg);\n-    unsafe {\n-        ll::async_send(iotask.async_handle);\n-    }\n-}\n-\n-/// Dispatch all pending messages\n-extern fn wake_up_cb(async_handle: *ll::uv_async_t,\n-                    status: int) {\n-\n-    debug!(\"wake_up_cb extern.. handle: %? status: %?\",\n-                     async_handle, status);\n-\n-    unsafe {\n-        let loop_ptr = ll::get_loop_for_uv_handle(async_handle);\n-        let data =\n-            ll::get_data_for_uv_handle(async_handle) as *IoTaskLoopData;\n-        let msg_po = &(*data).msg_po;\n-\n-        while msg_po.peek() {\n-            match msg_po.recv() {\n-                Interaction(ref cb) => (*cb)(loop_ptr),\n-                TeardownLoop => begin_teardown(data)\n-            }\n-        }\n-    }\n-}\n-\n-fn begin_teardown(data: *IoTaskLoopData) {\n-    unsafe {\n-        debug!(\"iotask begin_teardown() called, close async_handle\");\n-        let async_handle = (*data).async_handle;\n-        ll::close(async_handle as *c_void, tear_down_close_cb);\n-    }\n-}\n-extern fn tear_down_walk_cb(handle: *libc::c_void, arg: *libc::c_void) {\n-    debug!(\"IN TEARDOWN WALK CB\");\n-    // pretty much, if we still have an active handle and it is *not*\n-    // the async handle that facilities global loop communication, we\n-    // want to barf out and fail\n-    assert_eq!(handle, arg);\n-}\n-\n-extern fn tear_down_close_cb(handle: *ll::uv_async_t) {\n-    unsafe {\n-        let loop_ptr = ll::get_loop_for_uv_handle(handle);\n-        debug!(\"in tear_down_close_cb\");\n-        ll::walk(loop_ptr, tear_down_walk_cb, handle as *libc::c_void);\n-    }\n-}\n-\n-#[cfg(test)]\n-extern fn async_close_cb(handle: *ll::uv_async_t) {\n-    unsafe {\n-        debug!(\"async_close_cb handle %?\", handle);\n-        let exit_ch = &(*(ll::get_data_for_uv_handle(handle)\n-                        as *AhData)).exit_ch;\n-        let exit_ch = exit_ch.clone();\n-        exit_ch.send(());\n-    }\n-}\n-\n-#[cfg(test)]\n-extern fn async_handle_cb(handle: *ll::uv_async_t, status: libc::c_int) {\n-    unsafe {\n-        debug!(\"async_handle_cb handle %? status %?\",handle,status);\n-        ll::close(handle, async_close_cb);\n-    }\n-}\n-\n-#[cfg(test)]\n-struct AhData {\n-    iotask: IoTask,\n-    exit_ch: SharedChan<()>\n-}\n-\n-#[cfg(test)]\n-fn impl_uv_iotask_async(iotask: &IoTask) {\n-    use std::ptr;\n-\n-    let async_handle = ll::async_t();\n-    let ah_ptr: *ll::uv_async_t = &async_handle;\n-    let (exit_po, exit_ch) = stream::<()>();\n-    let ah_data = AhData {\n-        iotask: iotask.clone(),\n-        exit_ch: SharedChan::new(exit_ch)\n-    };\n-    let ah_data_ptr: *AhData = ptr::to_unsafe_ptr(&ah_data);\n-    debug!(\"about to interact\");\n-    do interact(iotask) |loop_ptr| {\n-        unsafe {\n-            debug!(\"interacting\");\n-            ll::async_init(loop_ptr, ah_ptr, async_handle_cb);\n-            ll::set_data_for_uv_handle(\n-                ah_ptr, ah_data_ptr as *libc::c_void);\n-            ll::async_send(ah_ptr);\n-        }\n-    };\n-    debug!(\"waiting for async close\");\n-    exit_po.recv();\n-}\n-\n-// this fn documents the bear minimum necessary to roll your own\n-// high_level_loop\n-#[cfg(test)]\n-fn spawn_test_loop(exit_ch: ~Chan<()>) -> IoTask {\n-    let (iotask_port, iotask_ch) = stream::<IoTask>();\n-    do task::spawn_sched(task::ManualThreads(1u)) {\n-        debug!(\"about to run a test loop\");\n-        run_loop(&iotask_ch);\n-        exit_ch.send(());\n-    };\n-    return iotask_port.recv();\n-}\n-\n-#[cfg(test)]\n-extern fn lifetime_handle_close(handle: *libc::c_void) {\n-    debug!(\"lifetime_handle_close ptr %?\", handle);\n-}\n-\n-#[cfg(test)]\n-extern fn lifetime_async_callback(handle: *libc::c_void,\n-                                 status: libc::c_int) {\n-    debug!(\"lifetime_handle_close ptr %? status %?\",\n-                    handle, status);\n-}\n-\n-#[test]\n-fn test_uv_iotask_async() {\n-    let (exit_po, exit_ch) = stream::<()>();\n-    let iotask = &spawn_test_loop(~exit_ch);\n-\n-    debug!(\"spawned iotask\");\n-\n-    // using this handle to manage the lifetime of the\n-    // high_level_loop, as it will exit the first time one of\n-    // the impl_uv_hl_async() is cleaned up with no one ref'd\n-    // handles on the loop (Which can happen under\n-    // race-condition type situations.. this ensures that the\n-    // loop lives until, at least, all of the\n-    // impl_uv_hl_async() runs have been called, at least.\n-    let (work_exit_po, work_exit_ch) = stream::<()>();\n-    let work_exit_ch = SharedChan::new(work_exit_ch);\n-    for 7u.times {\n-        let iotask_clone = iotask.clone();\n-        let work_exit_ch_clone = work_exit_ch.clone();\n-        do task::spawn_sched(task::ManualThreads(1u)) {\n-            debug!(\"async\");\n-            impl_uv_iotask_async(&iotask_clone);\n-            debug!(\"done async\");\n-            work_exit_ch_clone.send(());\n-        };\n-    };\n-    for 7u.times {\n-        debug!(\"waiting\");\n-        work_exit_po.recv();\n-    };\n-    debug!(~\"sending teardown_loop msg..\");\n-    exit(iotask);\n-    exit_po.recv();\n-    debug!(~\"after recv on exit_po.. exiting..\");\n-}"}, {"sha": "1527b090f94c8c6c7cccdc3503fa346face04a6d", "filename": "src/libextra/uv_ll.rs", "status": "removed", "additions": 0, "deletions": 1928, "changes": 1928, "blob_url": "https://github.com/rust-lang/rust/blob/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibextra%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_ll.rs?ref=9ed82fbb43804ebc7e06daca5812079630ec8952", "patch": "@@ -1,1928 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * Low-level bindings to the libuv library.\n- *\n- * This module contains a set of direct, 'bare-metal' wrappers around\n- * the libuv C-API.\n- *\n- * Also contained herein are a set of rust records that map, in\n- * approximate memory-size, to the libuv data structures. The record\n- * implementations are adjusted, per-platform, to match their respective\n- * representations.\n- *\n- * There are also a collection of helper functions to ease interacting\n- * with the low-level API (such as a function to return the latest\n- * libuv error as a rust-formatted string).\n- *\n- * As new functionality, existant in uv.h, is added to the rust stdlib,\n- * the mappings should be added in this module.\n- *\n- * This module's implementation will hopefully be, eventually, replaced\n- * with per-platform, generated source files from rust-bindgen.\n- */\n-\n-#[allow(non_camel_case_types)]; // C types\n-#[allow(missing_doc)];\n-\n-\n-use std::libc::{c_void, size_t};\n-use std::libc;\n-use std::ptr::to_unsafe_ptr;\n-use std::ptr;\n-use std::str;\n-use std::vec;\n-\n-pub type uv_handle_t = c_void;\n-pub type uv_loop_t = c_void;\n-pub type uv_idle_t = c_void;\n-pub type uv_idle_cb = *u8;\n-\n-// libuv struct mappings\n-pub struct uv_ip4_addr {\n-    ip: ~[u8],\n-    port: int,\n-}\n-pub type uv_ip6_addr = uv_ip4_addr;\n-\n-pub enum uv_handle_type {\n-    UNKNOWN_HANDLE = 0,\n-    UV_TCP,\n-    UV_UDP,\n-    UV_NAMED_PIPE,\n-    UV_TTY,\n-    UV_FILE,\n-    UV_TIMER,\n-    UV_PREPARE,\n-    UV_CHECK,\n-    UV_IDLE,\n-    UV_ASYNC,\n-    UV_ARES_TASK,\n-    UV_ARES_EVENT,\n-    UV_PROCESS,\n-    UV_FS_EVENT\n-}\n-\n-pub type handle_type = libc::c_uint;\n-\n-pub struct uv_handle_fields {\n-   loop_handle: *libc::c_void,\n-   type_: handle_type,\n-   close_cb: *u8,\n-   data: *libc::c_void,\n-}\n-\n-// unix size: 8\n-pub struct uv_err_t {\n-    code: libc::c_int,\n-    sys_errno_: libc::c_int\n-}\n-\n-// don't create one of these directly. instead,\n-// count on it appearing in libuv callbacks or embedded\n-// in other types as a pointer to be used in other\n-// operations (so mostly treat it as opaque, once you\n-// have it in this form..)\n-pub struct uv_stream_t {\n-    fields: uv_handle_fields,\n-}\n-\n-// 64bit unix size: 216\n-#[cfg(target_os=\"macos\")]\n-pub struct uv_tcp_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8, a13: *u8, a14: *u8, a15: *u8,\n-    a16: *u8, a17: *u8, a18: *u8, a19: *u8,\n-    a20: *u8, a21: *u8, a22: *u8,\n-    a23: uv_tcp_t_osx_riders\n-}\n-#[cfg(target_arch=\"x86_64\")]\n-pub struct uv_tcp_t_osx_riders {\n-    a23: *u8,\n-}\n-#[cfg(target_arch=\"x86\")]\n-#[cfg(target_arch=\"arm\")]\n-pub struct uv_tcp_t_osx_riders {\n-    a23: *u8,\n-    a24: *u8, a25: *u8,\n-}\n-#[cfg(target_os=\"linux\")]\n-#[cfg(target_os=\"freebsd\")]\n-#[cfg(target_os=\"android\")]\n-pub struct uv_tcp_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8, a13: *u8, a14: *u8, a15: *u8,\n-    a16: *u8, a17: *u8, a18: *u8, a19: *u8,\n-    a20: *u8, a21: *u8,\n-    a22: uv_tcp_t_32bit_unix_riders,\n-}\n-// 32bit unix size: 328 (164)\n-#[cfg(target_arch=\"x86_64\")]\n-pub struct uv_tcp_t_32bit_unix_riders {\n-    a29: *u8,\n-}\n-#[cfg(target_arch=\"x86\")]\n-#[cfg(target_arch=\"arm\")]\n-#[cfg(target_arch=\"mips\")]\n-pub struct uv_tcp_t_32bit_unix_riders {\n-    a29: *u8, a30: *u8, a31: *u8,\n-}\n-\n-// 32bit win32 size: 240 (120)\n-#[cfg(windows)]\n-pub struct uv_tcp_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8, a13: *u8, a14: *u8, a15: *u8,\n-    a16: *u8, a17: *u8, a18: *u8, a19: *u8,\n-    a20: *u8, a21: *u8, a22: *u8, a23: *u8,\n-    a24: *u8, a25: *u8,\n-}\n-\n-// unix size: 64\n-#[cfg(unix)]\n-pub struct uv_connect_t {\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8\n-}\n-// win32 size: 88 (44)\n-#[cfg(windows)]\n-pub struct uv_connect_t {\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8,\n-}\n-\n-// unix size: 16\n-pub struct uv_buf_t {\n-    base: *u8,\n-    len: libc::size_t,\n-}\n-// no gen stub method.. should create\n-// it via uv::direct::buf_init()\n-\n-// unix size: 160\n-#[cfg(unix)]\n-pub struct uv_write_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8,\n-    a14: uv_write_t_32bit_unix_riders,\n-}\n-#[cfg(target_arch=\"x86_64\")]\n-pub struct uv_write_t_32bit_unix_riders {\n-    a13: *u8, a14: *u8, a15: *u8\n-}\n-#[cfg(target_arch=\"x86\")]\n-#[cfg(target_arch=\"arm\")]\n-#[cfg(target_arch=\"mips\")]\n-pub struct uv_write_t_32bit_unix_riders {\n-    a13: *u8, a14: *u8, a15: *u8,\n-    a16: *u8,\n-}\n-// win32 size: 136 (68)\n-#[cfg(windows)]\n-pub struct uv_write_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8,\n-}\n-// 64bit unix size: 96\n-// 32bit unix size: 152 (76)\n-#[cfg(unix)]\n-pub struct uv_async_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8,\n-    a07: uv_async_t_32bit_unix_riders,\n-}\n-#[cfg(target_arch=\"x86_64\")]\n-pub struct uv_async_t_32bit_unix_riders {\n-    a10: *u8,\n-}\n-#[cfg(target_arch=\"x86\")]\n-#[cfg(target_arch=\"arm\")]\n-#[cfg(target_arch=\"mips\")]\n-pub struct uv_async_t_32bit_unix_riders {\n-    a10: *u8,\n-}\n-// win32 size 132 (68)\n-#[cfg(windows)]\n-pub struct uv_async_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8,\n-}\n-\n-// 64bit unix size: 120\n-// 32bit unix size: 84\n-#[cfg(unix)]\n-pub struct uv_timer_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8,\n-    a11: uv_timer_t_32bit_unix_riders,\n-}\n-#[cfg(target_arch=\"x86_64\")]\n-pub struct uv_timer_t_32bit_unix_riders {\n-    a10: *u8,\n-}\n-#[cfg(target_arch=\"x86\")]\n-#[cfg(target_arch=\"arm\")]\n-#[cfg(target_arch=\"mips\")]\n-pub struct uv_timer_t_32bit_unix_riders {\n-    a10: *u8, a11: *u8, a12: *u8\n-}\n-// win32 size: 64\n-#[cfg(windows)]\n-pub struct uv_timer_t {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-}\n-\n-// unix size: 16\n-#[deriving(Clone)]\n-pub struct sockaddr_in {\n-    sin_family: u16,\n-    sin_port: u16,\n-    sin_addr: u32, // in_addr: this is an opaque, per-platform struct\n-    sin_zero: (u8, u8, u8, u8, u8, u8, u8, u8),\n-}\n-\n-// unix size: 28 .. FIXME #1645\n-// stuck with 32 because of rust padding structs?\n-#[cfg(target_arch=\"x86_64\")]\n-pub struct sockaddr_in6 {\n-    a0: *u8, a1: *u8,\n-    a2: *u8, a3: *u8,\n-}\n-\n-#[cfg(target_arch=\"x86\")]\n-#[cfg(target_arch=\"arm\")]\n-#[cfg(target_arch=\"mips\")]\n-pub struct sockaddr_in6 {\n-    a0: *u8, a1: *u8,\n-    a2: *u8, a3: *u8,\n-    a4: *u8, a5: *u8,\n-    a6: *u8, a7: *u8,\n-}\n-\n-impl Clone for sockaddr_in6 {\n-    fn clone(&self) -> sockaddr_in6 {\n-        *self\n-    }\n-}\n-\n-// unix size: 28 .. FIXME #1645\n-// stuck with 32 because of rust padding structs?\n-pub type addr_in = addr_in_impl::addr_in;\n-#[cfg(unix)]\n-pub mod addr_in_impl {\n-    #[cfg(target_arch=\"x86_64\")]\n-    pub struct addr_in {\n-        a0: *u8, a1: *u8,\n-        a2: *u8, a3: *u8,\n-    }\n-    #[cfg(target_arch=\"x86\")]\n-    #[cfg(target_arch=\"arm\")]\n-    #[cfg(target_arch=\"mips\")]\n-    pub struct addr_in {\n-        a0: *u8, a1: *u8,\n-        a2: *u8, a3: *u8,\n-        a4: *u8, a5: *u8,\n-        a6: *u8, a7: *u8,\n-    }\n-}\n-#[cfg(windows)]\n-pub mod addr_in_impl {\n-    pub struct addr_in {\n-        a0: *u8, a1: *u8,\n-        a2: *u8, a3: *u8,\n-    }\n-}\n-\n-// unix size: 48, 32bit: 32\n-pub type addrinfo = addrinfo_impl::addrinfo;\n-#[cfg(target_os=\"linux\")]\n-#[cfg(target_os=\"android\")]\n-pub mod addrinfo_impl {\n-    #[cfg(target_arch=\"x86_64\")]\n-    pub struct addrinfo {\n-        a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8,\n-    }\n-    #[cfg(target_arch=\"x86\")]\n-    #[cfg(target_arch=\"arm\")]\n-    #[cfg(target_arch=\"mips\")]\n-    pub struct addrinfo {\n-        a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    }\n-}\n-#[cfg(target_os=\"macos\")]\n-#[cfg(target_os=\"freebsd\")]\n-pub mod addrinfo_impl {\n-    pub struct addrinfo {\n-        a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8,\n-    }\n-}\n-#[cfg(windows)]\n-pub mod addrinfo_impl {\n-    pub struct addrinfo {\n-        a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8,\n-    }\n-}\n-\n-// unix size: 72\n-pub struct uv_getaddrinfo_t {\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8, a04: *u8, a05: *u8,\n-    a06: *u8, a07: *u8, a08: *u8, a09: *u8,\n-    a10: *u8, a11: *u8, a12: *u8, a13: *u8, a14: *u8, a15: *u8\n-}\n-\n-pub mod uv_ll_struct_stubgen {\n-\n-    use std::ptr;\n-\n-    use super::{\n-        uv_async_t,\n-        uv_connect_t,\n-        uv_getaddrinfo_t,\n-        uv_handle_fields,\n-        uv_tcp_t,\n-        uv_timer_t,\n-        uv_write_t,\n-    };\n-\n-    #[cfg(target_os = \"linux\")]\n-    #[cfg(target_os = \"android\")]\n-    #[cfg(target_os = \"macos\")]\n-    #[cfg(target_os = \"freebsd\")]\n-    use super::{\n-        uv_async_t_32bit_unix_riders,\n-        uv_timer_t_32bit_unix_riders,\n-        uv_write_t_32bit_unix_riders,\n-    };\n-\n-    #[cfg(target_os = \"linux\")]\n-    #[cfg(target_os = \"android\")]\n-    #[cfg(target_os = \"freebsd\")]\n-    use super::uv_tcp_t_32bit_unix_riders;\n-\n-    pub fn gen_stub_uv_tcp_t() -> uv_tcp_t {\n-        return gen_stub_os();\n-        #[cfg(target_os = \"linux\")]\n-        #[cfg(target_os = \"android\")]\n-        #[cfg(target_os = \"freebsd\")]\n-        pub fn gen_stub_os() -> uv_tcp_t {\n-            return gen_stub_arch();\n-            #[cfg(target_arch=\"x86_64\")]\n-            pub fn gen_stub_arch() -> uv_tcp_t {\n-                uv_tcp_t {\n-                    fields: uv_handle_fields {\n-                        loop_handle: ptr::null(), type_: 0u32,\n-                        close_cb: ptr::null(),\n-                        data: ptr::null(),\n-                    },\n-                    a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                    a03: 0 as *u8,\n-                    a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                    a07: 0 as *u8,\n-                    a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-                    a11: 0 as *u8,\n-                    a12: 0 as *u8, a13: 0 as *u8, a14: 0 as *u8,\n-                    a15: 0 as *u8,\n-                    a16: 0 as *u8, a17: 0 as *u8, a18: 0 as *u8,\n-                    a19: 0 as *u8,\n-                    a20: 0 as *u8, a21: 0 as *u8,\n-                    a22: uv_tcp_t_32bit_unix_riders { a29: 0 as *u8 },\n-                }\n-            }\n-            #[cfg(target_arch=\"x86\")]\n-            #[cfg(target_arch=\"arm\")]\n-            #[cfg(target_arch=\"mips\")]\n-            pub fn gen_stub_arch() -> uv_tcp_t {\n-                uv_tcp_t {\n-                    fields: uv_handle_fields {\n-                        loop_handle: ptr::null(), type_: 0u32,\n-                        close_cb: ptr::null(),\n-                        data: ptr::null(),\n-                    },\n-                    a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                    a03: 0 as *u8,\n-                    a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                    a07: 0 as *u8,\n-                    a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-                    a11: 0 as *u8,\n-                    a12: 0 as *u8, a13: 0 as *u8, a14: 0 as *u8,\n-                    a15: 0 as *u8,\n-                    a16: 0 as *u8, a17: 0 as *u8, a18: 0 as *u8,\n-                    a19: 0 as *u8,\n-                    a20: 0 as *u8, a21: 0 as *u8,\n-                    a22: uv_tcp_t_32bit_unix_riders {\n-                        a29: 0 as *u8, a30: 0 as *u8, a31: 0 as *u8,\n-                    },\n-                }\n-            }\n-        }\n-        #[cfg(windows)]\n-        pub fn gen_stub_os() -> uv_tcp_t {\n-            uv_tcp_t {\n-                fields: uv_handle_fields {\n-                    loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    data: ptr::null(),\n-                },\n-                a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                a03: 0 as *u8,\n-                a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                a07: 0 as *u8,\n-                a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-                a11: 0 as *u8,\n-                a12: 0 as *u8, a13: 0 as *u8, a14: 0 as *u8,\n-                a15: 0 as *u8,\n-                a16: 0 as *u8, a17: 0 as *u8, a18: 0 as *u8,\n-                a19: 0 as *u8,\n-                a20: 0 as *u8, a21: 0 as *u8, a22: 0 as *u8,\n-                a23: 0 as *u8,\n-                a24: 0 as *u8, a25: 0 as *u8,\n-            }\n-        }\n-        #[cfg(target_os = \"macos\")]\n-        pub fn gen_stub_os() -> uv_tcp_t {\n-            use super::uv_tcp_t_osx_riders;\n-\n-            return gen_stub_arch();\n-\n-            #[cfg(target_arch = \"x86_64\")]\n-            fn gen_stub_arch() -> uv_tcp_t {\n-                uv_tcp_t {\n-                    fields: uv_handle_fields {\n-                        loop_handle: ptr::null(), type_: 0u32,\n-                        close_cb: ptr::null(),\n-                        data: ptr::null(),\n-                    },\n-                    a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                    a03: 0 as *u8,\n-                    a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                    a07: 0 as *u8,\n-                    a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-                    a11: 0 as *u8,\n-                    a12: 0 as *u8, a13: 0 as *u8, a14: 0 as *u8,\n-                    a15: 0 as *u8,\n-                    a16: 0 as *u8, a17: 0 as *u8, a18: 0 as *u8,\n-                    a19: 0 as *u8,\n-                    a20: 0 as *u8, a21: 0 as *u8, a22: 0 as *u8,\n-                    a23: uv_tcp_t_osx_riders {\n-                        a23: 0 as *u8,\n-                    }\n-                }\n-            }\n-\n-            #[cfg(target_arch = \"x86\")]\n-            #[cfg(target_arch = \"arm\")]\n-            fn gen_stub_arch() -> uv_tcp_t {\n-                uv_tcp_t {\n-                    fields: uv_handle_fields {\n-                        loop_handle: ptr::null(), type_: 0u32,\n-                        close_cb: ptr::null(),\n-                        data: ptr::null(),\n-                    },\n-                    a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                    a03: 0 as *u8,\n-                    a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                    a07: 0 as *u8,\n-                    a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-                    a11: 0 as *u8,\n-                    a12: 0 as *u8, a13: 0 as *u8, a14: 0 as *u8,\n-                    a15: 0 as *u8,\n-                    a16: 0 as *u8, a17: 0 as *u8, a18: 0 as *u8,\n-                    a19: 0 as *u8,\n-                    a20: 0 as *u8, a21: 0 as *u8, a22: 0 as *u8,\n-                    a23: uv_tcp_t_osx_riders {\n-                        a23: 0 as *u8,\n-                        a24: 0 as *u8, a25: 0 as *u8,\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(unix)]\n-    pub fn gen_stub_uv_connect_t() -> uv_connect_t {\n-        uv_connect_t {\n-            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-            a03: 0 as *u8,\n-            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-            a07: 0 as *u8\n-        }\n-    }\n-    #[cfg(windows)]\n-    pub fn gen_stub_uv_connect_t() -> uv_connect_t {\n-        uv_connect_t {\n-            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-            a03: 0 as *u8,\n-            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-            a07: 0 as *u8,\n-            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-        }\n-    }\n-    #[cfg(unix)]\n-    pub fn gen_stub_uv_async_t() -> uv_async_t {\n-        return gen_stub_arch();\n-        #[cfg(target_arch = \"x86_64\")]\n-        pub fn gen_stub_arch() -> uv_async_t {\n-            uv_async_t {\n-                fields: uv_handle_fields {\n-                    loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    data: ptr::null(),\n-                },\n-                a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                a03: 0 as *u8,\n-                a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                a07: uv_async_t_32bit_unix_riders { a10: 0 as *u8 },\n-            }\n-        }\n-        #[cfg(target_arch = \"x86\")]\n-        #[cfg(target_arch=\"arm\")]\n-        #[cfg(target_arch=\"mips\")]\n-        pub fn gen_stub_arch() -> uv_async_t {\n-            uv_async_t {\n-                fields: uv_handle_fields {\n-                    loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    data: ptr::null(),\n-                },\n-                a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                a03: 0 as *u8,\n-                a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                a07: uv_async_t_32bit_unix_riders {\n-                    a10: 0 as *u8,\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(windows)]\n-    pub fn gen_stub_uv_async_t() -> uv_async_t {\n-        uv_async_t {\n-            fields: uv_handle_fields {\n-                loop_handle: ptr::null(), type_: 0u32,\n-                close_cb: ptr::null(),\n-                data: ptr::null(),\n-            },\n-            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-            a03: 0 as *u8,\n-            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-            a07: 0 as *u8,\n-            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-            a11: 0 as *u8,\n-            a12: 0 as *u8,\n-        }\n-    }\n-    #[cfg(unix)]\n-    pub fn gen_stub_uv_timer_t() -> uv_timer_t {\n-        return gen_stub_arch();\n-        #[cfg(target_arch = \"x86_64\")]\n-        pub fn gen_stub_arch() -> uv_timer_t {\n-            uv_timer_t {\n-                fields: uv_handle_fields {\n-                    loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    data: ptr::null(),\n-                },\n-                a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                a03: 0 as *u8,\n-                a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                a07: 0 as *u8,\n-                a08: 0 as *u8, a09: 0 as *u8,\n-                a11: uv_timer_t_32bit_unix_riders {\n-                    a10: 0 as *u8\n-                },\n-            }\n-        }\n-        #[cfg(target_arch = \"x86\")]\n-        #[cfg(target_arch=\"arm\")]\n-        #[cfg(target_arch=\"mips\")]\n-        pub fn gen_stub_arch() -> uv_timer_t {\n-            uv_timer_t {\n-                fields: uv_handle_fields {\n-                    loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    data: ptr::null(),\n-                },\n-                a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                a03: 0 as *u8,\n-                a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                a07: 0 as *u8,\n-                a08: 0 as *u8, a09: 0 as *u8,\n-                a11: uv_timer_t_32bit_unix_riders {\n-                    a10: 0 as *u8, a11: 0 as *u8,\n-                    a12: 0 as *u8,\n-                },\n-            }\n-        }\n-    }\n-    #[cfg(windows)]\n-    pub fn gen_stub_uv_timer_t() -> uv_timer_t {\n-        uv_timer_t {\n-            fields: uv_handle_fields {\n-                loop_handle: ptr::null(), type_: 0u32,\n-                close_cb: ptr::null(),\n-                data: ptr::null(),\n-            },\n-            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-            a03: 0 as *u8,\n-            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-            a07: 0 as *u8,\n-            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-            a11: 0 as *u8,\n-        }\n-    }\n-    #[cfg(unix)]\n-    pub fn gen_stub_uv_write_t() -> uv_write_t {\n-        return gen_stub_arch();\n-        #[cfg(target_arch=\"x86_64\")]\n-        pub fn gen_stub_arch() -> uv_write_t {\n-            uv_write_t {\n-                fields: uv_handle_fields {\n-                    loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    data: ptr::null(),\n-                },\n-                a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                a03: 0 as *u8,\n-                a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                a07: 0 as *u8,\n-                a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-                a11: 0 as *u8,\n-                a12: 0 as *u8,\n-                a14: uv_write_t_32bit_unix_riders { a13: 0 as *u8,\n-                                                   a14: 0 as *u8,\n-                                                   a15: 0 as *u8},\n-            }\n-        }\n-        #[cfg(target_arch=\"x86\")]\n-        #[cfg(target_arch=\"arm\")]\n-        #[cfg(target_arch=\"mips\")]\n-        pub fn gen_stub_arch() -> uv_write_t {\n-            uv_write_t {\n-                fields: uv_handle_fields {\n-                    loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    data: ptr::null(),\n-                },\n-                a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-                a03: 0 as *u8,\n-                a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-                a07: 0 as *u8,\n-                a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-                a11: 0 as *u8,\n-                a12: 0 as *u8,\n-                a14: uv_write_t_32bit_unix_riders {\n-                    a13: 0 as *u8,\n-                    a14: 0 as *u8,\n-                    a15: 0 as *u8,\n-                    a16: 0 as *u8,\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(windows)]\n-    pub fn gen_stub_uv_write_t() -> uv_write_t {\n-        uv_write_t {\n-            fields: uv_handle_fields {\n-                loop_handle: ptr::null(), type_: 0u32,\n-                close_cb: ptr::null(),\n-                data: ptr::null(),\n-            },\n-            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n-            a03: 0 as *u8,\n-            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n-            a07: 0 as *u8,\n-            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-            a11: 0 as *u8,\n-            a12: 0 as *u8\n-        }\n-    }\n-    pub fn gen_stub_uv_getaddrinfo_t() -> uv_getaddrinfo_t {\n-        uv_getaddrinfo_t {\n-            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n-            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n-            a08: 0 as *u8, a09: 0 as *u8,\n-            a10: 1 as *u8, a11: 1 as *u8, a12: 1 as *u8, a13: 1 as *u8,\n-            a14: 1 as *u8, a15: 1 as *u8\n-        }\n-    }\n-}\n-\n-#[nolink]\n-extern {\n-    // libuv public API\n-    unsafe fn rust_uv_loop_new() -> *libc::c_void;\n-    unsafe fn rust_uv_loop_delete(lp: *libc::c_void);\n-    unsafe fn rust_uv_run(loop_handle: *libc::c_void);\n-    unsafe fn rust_uv_close(handle: *libc::c_void, cb: *u8);\n-    unsafe fn rust_uv_walk(loop_handle: *libc::c_void, cb: *u8,\n-                           arg: *libc::c_void);\n-\n-    unsafe fn rust_uv_idle_new() -> *uv_idle_t;\n-    unsafe fn rust_uv_idle_delete(handle: *uv_idle_t);\n-    unsafe fn rust_uv_idle_init(loop_handle: *uv_loop_t,\n-                                handle: *uv_idle_t) -> libc::c_int;\n-    unsafe fn rust_uv_idle_start(handle: *uv_idle_t,\n-                                 cb: uv_idle_cb) -> libc::c_int;\n-    unsafe fn rust_uv_idle_stop(handle: *uv_idle_t) -> libc::c_int;\n-\n-    unsafe fn rust_uv_async_send(handle: *uv_async_t);\n-    unsafe fn rust_uv_async_init(loop_handle: *libc::c_void,\n-                          async_handle: *uv_async_t,\n-                          cb: *u8) -> libc::c_int;\n-    unsafe fn rust_uv_tcp_init(\n-        loop_handle: *libc::c_void,\n-        handle_ptr: *uv_tcp_t) -> libc::c_int;\n-    // FIXME ref #2604 .. ?\n-    unsafe fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8,\n-                        len: libc::size_t);\n-    unsafe fn rust_uv_last_error(loop_handle: *libc::c_void) -> uv_err_t;\n-    // FIXME ref #2064\n-    unsafe fn rust_uv_strerror(err: *uv_err_t) -> *libc::c_char;\n-    // FIXME ref #2064\n-    unsafe fn rust_uv_err_name(err: *uv_err_t) -> *libc::c_char;\n-    unsafe fn rust_uv_ip4_addr(ip: *u8, port: libc::c_int)\n-        -> sockaddr_in;\n-    unsafe fn rust_uv_ip6_addr(ip: *u8, port: libc::c_int)\n-        -> sockaddr_in6;\n-    unsafe fn rust_uv_ip4_name(src: *sockaddr_in,\n-                               dst: *u8,\n-                               size: libc::size_t)\n-                            -> libc::c_int;\n-    unsafe fn rust_uv_ip6_name(src: *sockaddr_in6,\n-                               dst: *u8,\n-                               size: libc::size_t)\n-                            -> libc::c_int;\n-    unsafe fn rust_uv_ip4_port(src: *sockaddr_in) -> libc::c_uint;\n-    unsafe fn rust_uv_ip6_port(src: *sockaddr_in6) -> libc::c_uint;\n-    // FIXME ref #2064\n-    unsafe fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n-                                  tcp_handle_ptr: *uv_tcp_t,\n-                                  after_cb: *u8,\n-                                  addr: *sockaddr_in)\n-                                  -> libc::c_int;\n-    // FIXME ref #2064\n-    unsafe fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t,\n-                               addr: *sockaddr_in) -> libc::c_int;\n-    // FIXME ref #2064\n-    unsafe fn rust_uv_tcp_connect6(connect_ptr: *uv_connect_t,\n-                                   tcp_handle_ptr: *uv_tcp_t,\n-                                   after_cb: *u8,\n-                                   addr: *sockaddr_in6) -> libc::c_int;\n-    // FIXME ref #2064\n-    unsafe fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t,\n-                                addr: *sockaddr_in6) -> libc::c_int;\n-    unsafe fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t,\n-                                      name: *sockaddr_in) -> libc::c_int;\n-    unsafe fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t,\n-                                       name: *sockaddr_in6) ->libc::c_int;\n-    unsafe fn rust_uv_listen(stream: *libc::c_void,\n-                             backlog: libc::c_int,\n-                             cb: *u8) -> libc::c_int;\n-    unsafe fn rust_uv_accept(server: *libc::c_void, client: *libc::c_void)\n-                          -> libc::c_int;\n-    unsafe fn rust_uv_write(req: *libc::c_void,\n-                            stream: *libc::c_void,\n-                            buf_in: *uv_buf_t,\n-                            buf_cnt: libc::c_int,\n-                            cb: *u8)\n-        -> libc::c_int;\n-    unsafe fn rust_uv_read_start(stream: *libc::c_void,\n-                                 on_alloc: *u8,\n-                                 on_read: *u8)\n-        -> libc::c_int;\n-    unsafe fn rust_uv_read_stop(stream: *libc::c_void) -> libc::c_int;\n-    unsafe fn rust_uv_timer_init(loop_handle: *libc::c_void,\n-                                 timer_handle: *uv_timer_t)\n-        -> libc::c_int;\n-    unsafe fn rust_uv_timer_start(\n-        timer_handle: *uv_timer_t,\n-        cb: *u8,\n-        timeout: libc::uint64_t,\n-        repeat: libc::uint64_t) -> libc::c_int;\n-    unsafe fn rust_uv_timer_stop(handle: *uv_timer_t) -> libc::c_int;\n-\n-    unsafe fn rust_uv_getaddrinfo(loop_ptr: *libc::c_void,\n-                                  handle: *uv_getaddrinfo_t,\n-                                  cb: *u8,\n-                                  node_name_ptr: *u8,\n-                                  service_name_ptr: *u8,\n-                                  // should probably only pass ptr::null()\n-                                  hints: *addrinfo)\n-        -> libc::c_int;\n-    unsafe fn rust_uv_freeaddrinfo(res: *addrinfo);\n-\n-    // data accessors/helpers for rust-mapped uv structs\n-    unsafe fn rust_uv_helper_get_INADDR_NONE() -> u32;\n-    unsafe fn rust_uv_is_ipv4_addrinfo(input: *addrinfo) -> bool;\n-    unsafe fn rust_uv_is_ipv6_addrinfo(input: *addrinfo) -> bool;\n-    unsafe fn rust_uv_get_next_addrinfo(input: *addrinfo) -> *addrinfo;\n-    unsafe fn rust_uv_addrinfo_as_sockaddr_in(input: *addrinfo)\n-        -> *sockaddr_in;\n-    unsafe fn rust_uv_addrinfo_as_sockaddr_in6(input: *addrinfo)\n-        -> *sockaddr_in6;\n-    unsafe fn rust_uv_malloc_buf_base_of(sug_size: libc::size_t) -> *u8;\n-    unsafe fn rust_uv_free_base_of_buf(buf: uv_buf_t);\n-    unsafe fn rust_uv_get_stream_handle_from_connect_req(\n-        connect_req: *uv_connect_t)\n-        -> *uv_stream_t;\n-    unsafe fn rust_uv_get_stream_handle_from_write_req(\n-        write_req: *uv_write_t)\n-        -> *uv_stream_t;\n-    unsafe fn rust_uv_get_loop_for_uv_handle(handle: *libc::c_void)\n-        -> *libc::c_void;\n-    unsafe fn rust_uv_get_data_for_uv_loop(loop_ptr: *libc::c_void)\n-        -> *libc::c_void;\n-    unsafe fn rust_uv_set_data_for_uv_loop(loop_ptr: *libc::c_void,\n-                                           data: *libc::c_void);\n-    unsafe fn rust_uv_get_data_for_uv_handle(handle: *libc::c_void)\n-        -> *libc::c_void;\n-    unsafe fn rust_uv_set_data_for_uv_handle(handle: *libc::c_void,\n-                                             data: *libc::c_void);\n-    unsafe fn rust_uv_get_data_for_req(req: *libc::c_void)\n-        -> *libc::c_void;\n-    unsafe fn rust_uv_set_data_for_req(req: *libc::c_void,\n-                                       data: *libc::c_void);\n-    unsafe fn rust_uv_get_base_from_buf(buf: uv_buf_t) -> *u8;\n-    unsafe fn rust_uv_get_len_from_buf(buf: uv_buf_t) -> libc::size_t;\n-\n-    // sizeof testing helpers\n-    unsafe fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_uv_connect_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_uv_buf_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_uv_write_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_uv_err_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_sockaddr_in_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_sockaddr_in6_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_uv_async_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_uv_timer_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_uv_getaddrinfo_t_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_addrinfo_size() -> libc::c_uint;\n-    unsafe fn rust_uv_helper_addr_in_size() -> libc::c_uint;\n-}\n-\n-pub unsafe fn loop_new() -> *libc::c_void {\n-    return rust_uv_loop_new();\n-}\n-\n-pub unsafe fn loop_delete(loop_handle: *libc::c_void) {\n-    rust_uv_loop_delete(loop_handle);\n-}\n-\n-pub unsafe fn run(loop_handle: *libc::c_void) {\n-    rust_uv_run(loop_handle);\n-}\n-\n-pub unsafe fn close<T>(handle: *T, cb: *u8) {\n-    rust_uv_close(handle as *libc::c_void, cb);\n-}\n-\n-pub unsafe fn walk(loop_handle: *libc::c_void, cb: *u8, arg: *libc::c_void) {\n-    rust_uv_walk(loop_handle, cb, arg);\n-}\n-\n-pub unsafe fn idle_new() -> *uv_idle_t {\n-    rust_uv_idle_new()\n-}\n-\n-pub unsafe fn idle_delete(handle: *uv_idle_t) {\n-    rust_uv_idle_delete(handle)\n-}\n-\n-pub unsafe fn idle_init(loop_handle: *uv_loop_t,\n-                        handle: *uv_idle_t) -> libc::c_int {\n-    rust_uv_idle_init(loop_handle, handle)\n-}\n-\n-pub unsafe fn idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> libc::c_int {\n-    rust_uv_idle_start(handle, cb)\n-}\n-\n-pub unsafe fn idle_stop(handle: *uv_idle_t) -> libc::c_int {\n-    rust_uv_idle_stop(handle)\n-}\n-\n-pub unsafe fn tcp_init(loop_handle: *libc::c_void, handle: *uv_tcp_t)\n-    -> libc::c_int {\n-    return rust_uv_tcp_init(loop_handle, handle);\n-}\n-// FIXME ref #2064\n-pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n-                      tcp_handle_ptr: *uv_tcp_t,\n-                      addr_ptr: *sockaddr_in,\n-                      after_connect_cb: *u8)\n--> libc::c_int {\n-    return rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n-                                    after_connect_cb, addr_ptr);\n-}\n-// FIXME ref #2064\n-pub unsafe fn tcp_connect6(connect_ptr: *uv_connect_t,\n-                      tcp_handle_ptr: *uv_tcp_t,\n-                      addr_ptr: *sockaddr_in6,\n-                      after_connect_cb: *u8)\n--> libc::c_int {\n-    return rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr,\n-                                    after_connect_cb, addr_ptr);\n-}\n-// FIXME ref #2064\n-pub unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t,\n-                   addr_ptr: *sockaddr_in) -> libc::c_int {\n-    return rust_uv_tcp_bind(tcp_server_ptr,\n-                                 addr_ptr);\n-}\n-// FIXME ref #2064\n-pub unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t,\n-                   addr_ptr: *sockaddr_in6) -> libc::c_int {\n-    return rust_uv_tcp_bind6(tcp_server_ptr,\n-                                 addr_ptr);\n-}\n-\n-pub unsafe fn tcp_getpeername(tcp_handle_ptr: *uv_tcp_t,\n-                              name: *sockaddr_in) -> libc::c_int {\n-    return rust_uv_tcp_getpeername(tcp_handle_ptr, name);\n-}\n-\n-pub unsafe fn tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t,\n-                               name: *sockaddr_in6) ->libc::c_int {\n-    return rust_uv_tcp_getpeername6(tcp_handle_ptr, name);\n-}\n-\n-pub unsafe fn listen<T>(stream: *T, backlog: libc::c_int,\n-                 cb: *u8) -> libc::c_int {\n-    return rust_uv_listen(stream as *libc::c_void, backlog, cb);\n-}\n-\n-pub unsafe fn accept(server: *libc::c_void, client: *libc::c_void)\n-    -> libc::c_int {\n-    return rust_uv_accept(server as *libc::c_void,\n-                               client as *libc::c_void);\n-}\n-\n-pub unsafe fn write<T>(req: *uv_write_t, stream: *T,\n-         buf_in: *~[uv_buf_t], cb: *u8) -> libc::c_int {\n-    let buf_ptr = vec::raw::to_ptr(*buf_in);\n-    let buf_cnt = (*buf_in).len() as i32;\n-    return rust_uv_write(req as *libc::c_void,\n-                              stream as *libc::c_void,\n-                              buf_ptr, buf_cnt, cb);\n-}\n-pub unsafe fn read_start(stream: *uv_stream_t, on_alloc: *u8,\n-                     on_read: *u8) -> libc::c_int {\n-    return rust_uv_read_start(stream as *libc::c_void,\n-                                   on_alloc, on_read);\n-}\n-\n-pub unsafe fn read_stop(stream: *uv_stream_t) -> libc::c_int {\n-    return rust_uv_read_stop(stream as *libc::c_void);\n-}\n-\n-pub unsafe fn last_error(loop_handle: *libc::c_void) -> uv_err_t {\n-    return rust_uv_last_error(loop_handle);\n-}\n-\n-pub unsafe fn strerror(err: *uv_err_t) -> *libc::c_char {\n-    return rust_uv_strerror(err);\n-}\n-pub unsafe fn err_name(err: *uv_err_t) -> *libc::c_char {\n-    return rust_uv_err_name(err);\n-}\n-\n-pub unsafe fn async_init(loop_handle: *libc::c_void,\n-                     async_handle: *uv_async_t,\n-                     cb: *u8) -> libc::c_int {\n-    return rust_uv_async_init(loop_handle,\n-                                   async_handle,\n-                                   cb);\n-}\n-\n-pub unsafe fn async_send(async_handle: *uv_async_t) {\n-    return rust_uv_async_send(async_handle);\n-}\n-pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n-    let out_buf = uv_buf_t { base: ptr::null(), len: 0 as libc::size_t };\n-    let out_buf_ptr: *uv_buf_t = &out_buf;\n-    rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n-    return out_buf;\n-}\n-pub unsafe fn ip4_addr(ip: &str, port: int) -> sockaddr_in {\n-    do str::as_c_str(ip) |ip_buf| {\n-        rust_uv_ip4_addr(ip_buf as *u8,\n-                                 port as libc::c_int)\n-    }\n-}\n-pub unsafe fn ip6_addr(ip: &str, port: int) -> sockaddr_in6 {\n-    do str::as_c_str(ip) |ip_buf| {\n-        rust_uv_ip6_addr(ip_buf as *u8,\n-                                 port as libc::c_int)\n-    }\n-}\n-pub unsafe fn ip4_name(src: &sockaddr_in) -> ~str {\n-    // ipv4 addr max size: 15 + 1 trailing null byte\n-    let dst: ~[u8] = ~[0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n-                     0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8];\n-    do dst.as_imm_buf |dst_buf, size| {\n-        rust_uv_ip4_name(to_unsafe_ptr(src),\n-                                 dst_buf, size as libc::size_t);\n-        // seems that checking the result of uv_ip4_name\n-        // doesn't work too well..\n-        // you're stuck looking at the value of dst_buf\n-        // to see if it is the string representation of\n-        // INADDR_NONE (0xffffffff or 255.255.255.255 on\n-        // many platforms)\n-        str::raw::from_buf(dst_buf)\n-    }\n-}\n-pub unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n-    // ipv6 addr max size: 45 + 1 trailing null byte\n-    let dst: ~[u8] = ~[0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n-                       0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n-                       0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n-                       0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n-                       0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n-                       0u8,0u8,0u8,0u8,0u8,0u8];\n-    do dst.as_imm_buf |dst_buf, size| {\n-        let src_unsafe_ptr = to_unsafe_ptr(src);\n-        let result = rust_uv_ip6_name(src_unsafe_ptr,\n-                                              dst_buf, size as libc::size_t);\n-        match result {\n-          0i32 => str::raw::from_buf(dst_buf),\n-          _ => ~\"\"\n-        }\n-    }\n-}\n-pub unsafe fn ip4_port(src: &sockaddr_in) -> uint {\n-    rust_uv_ip4_port(to_unsafe_ptr(src)) as uint\n-}\n-pub unsafe fn ip6_port(src: &sockaddr_in6) -> uint {\n-    rust_uv_ip6_port(to_unsafe_ptr(src)) as uint\n-}\n-\n-pub unsafe fn timer_init(loop_ptr: *libc::c_void,\n-                     timer_ptr: *uv_timer_t) -> libc::c_int {\n-    return rust_uv_timer_init(loop_ptr, timer_ptr);\n-}\n-pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: uint,\n-                      repeat: uint) -> libc::c_int {\n-    return rust_uv_timer_start(timer_ptr, cb, timeout as libc::uint64_t,\n-                               repeat as libc::uint64_t);\n-}\n-pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> libc::c_int {\n-    return rust_uv_timer_stop(timer_ptr);\n-}\n-pub unsafe fn getaddrinfo(loop_ptr: *libc::c_void,\n-                           handle: *uv_getaddrinfo_t,\n-                           cb: *u8,\n-                           node_name_ptr: *u8,\n-                           service_name_ptr: *u8,\n-                           hints: *addrinfo) -> libc::c_int {\n-    rust_uv_getaddrinfo(loop_ptr,\n-                           handle,\n-                           cb,\n-                           node_name_ptr,\n-                           service_name_ptr,\n-                           hints)\n-}\n-pub unsafe fn freeaddrinfo(res: *addrinfo) {\n-    rust_uv_freeaddrinfo(res);\n-}\n-\n-// libuv struct initializers\n-pub fn tcp_t() -> uv_tcp_t {\n-    return uv_ll_struct_stubgen::gen_stub_uv_tcp_t();\n-}\n-pub fn connect_t() -> uv_connect_t {\n-    return uv_ll_struct_stubgen::gen_stub_uv_connect_t();\n-}\n-pub fn write_t() -> uv_write_t {\n-    return uv_ll_struct_stubgen::gen_stub_uv_write_t();\n-}\n-pub fn async_t() -> uv_async_t {\n-    return uv_ll_struct_stubgen::gen_stub_uv_async_t();\n-}\n-pub fn timer_t() -> uv_timer_t {\n-    return uv_ll_struct_stubgen::gen_stub_uv_timer_t();\n-}\n-pub fn getaddrinfo_t() -> uv_getaddrinfo_t {\n-    return uv_ll_struct_stubgen::gen_stub_uv_getaddrinfo_t();\n-}\n-\n-// data access helpers\n-pub unsafe fn get_loop_for_uv_handle<T>(handle: *T)\n-    -> *libc::c_void {\n-    return rust_uv_get_loop_for_uv_handle(handle as *libc::c_void);\n-}\n-pub unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t)\n-    -> *uv_stream_t {\n-    return rust_uv_get_stream_handle_from_connect_req(\n-        connect);\n-}\n-pub unsafe fn get_stream_handle_from_write_req(\n-    write_req: *uv_write_t)\n-    -> *uv_stream_t {\n-    return rust_uv_get_stream_handle_from_write_req(\n-        write_req);\n-}\n-pub unsafe fn get_data_for_uv_loop(loop_ptr: *libc::c_void) -> *libc::c_void {\n-    rust_uv_get_data_for_uv_loop(loop_ptr)\n-}\n-pub unsafe fn set_data_for_uv_loop(loop_ptr: *libc::c_void,\n-                                   data: *libc::c_void) {\n-    rust_uv_set_data_for_uv_loop(loop_ptr, data);\n-}\n-pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *libc::c_void {\n-    return rust_uv_get_data_for_uv_handle(handle as *libc::c_void);\n-}\n-pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T, data: *U) {\n-    rust_uv_set_data_for_uv_handle(handle as *libc::c_void,\n-                                           data as *libc::c_void);\n-}\n-pub unsafe fn get_data_for_req<T>(req: *T) -> *libc::c_void {\n-    return rust_uv_get_data_for_req(req as *libc::c_void);\n-}\n-pub unsafe fn set_data_for_req<T, U>(req: *T,\n-                    data: *U) {\n-    rust_uv_set_data_for_req(req as *libc::c_void,\n-                                     data as *libc::c_void);\n-}\n-pub unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n-    return rust_uv_get_base_from_buf(buf);\n-}\n-pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> libc::size_t {\n-    return rust_uv_get_len_from_buf(buf);\n-}\n-pub unsafe fn malloc_buf_base_of(suggested_size: libc::size_t)\n-    -> *u8 {\n-    return rust_uv_malloc_buf_base_of(suggested_size);\n-}\n-pub unsafe fn free_base_of_buf(buf: uv_buf_t) {\n-    rust_uv_free_base_of_buf(buf);\n-}\n-\n-pub unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> ~str {\n-    let err = last_error(uv_loop);\n-    let err_ptr: *uv_err_t = &err;\n-    let err_name = str::raw::from_c_str(err_name(err_ptr));\n-    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n-    return fmt!(\"LIBUV ERROR: name: %s msg: %s\",\n-                    err_name, err_msg);\n-}\n-\n-pub unsafe fn get_last_err_data(uv_loop: *libc::c_void) -> uv_err_data {\n-    let err = last_error(uv_loop);\n-    let err_ptr: *uv_err_t = &err;\n-    let err_name = str::raw::from_c_str(err_name(err_ptr));\n-    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n-    uv_err_data { err_name: err_name, err_msg: err_msg }\n-}\n-\n-pub struct uv_err_data {\n-    err_name: ~str,\n-    err_msg: ~str,\n-}\n-\n-pub unsafe fn is_ipv4_addrinfo(input: *addrinfo) -> bool {\n-    rust_uv_is_ipv4_addrinfo(input)\n-}\n-pub unsafe fn is_ipv6_addrinfo(input: *addrinfo) -> bool {\n-    rust_uv_is_ipv6_addrinfo(input)\n-}\n-pub unsafe fn get_INADDR_NONE() -> u32 {\n-    rust_uv_helper_get_INADDR_NONE()\n-}\n-pub unsafe fn get_next_addrinfo(input: *addrinfo) -> *addrinfo {\n-    rust_uv_get_next_addrinfo(input)\n-}\n-pub unsafe fn addrinfo_as_sockaddr_in(input: *addrinfo) -> *sockaddr_in {\n-    rust_uv_addrinfo_as_sockaddr_in(input)\n-}\n-pub unsafe fn addrinfo_as_sockaddr_in6(input: *addrinfo) -> *sockaddr_in6 {\n-    rust_uv_addrinfo_as_sockaddr_in6(input)\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use super::*;\n-\n-    use std::comm::{SharedChan, stream, GenericChan, GenericPort};\n-    use std::libc;\n-    use std::str;\n-    use std::sys;\n-    use std::task;\n-    use std::vec;\n-\n-    enum tcp_read_data {\n-        tcp_read_eof,\n-        tcp_read_more(~[u8]),\n-        tcp_read_error\n-    }\n-\n-    struct request_wrapper {\n-        write_req: *uv_write_t,\n-        req_buf: *~[uv_buf_t],\n-        read_chan: SharedChan<~str>,\n-    }\n-\n-    extern fn after_close_cb(handle: *libc::c_void) {\n-        debug!(\"after uv_close! handle ptr: %?\",\n-                        handle);\n-    }\n-\n-    extern fn on_alloc_cb(handle: *libc::c_void,\n-                         suggested_size: libc::size_t)\n-        -> uv_buf_t {\n-        unsafe {\n-            debug!(~\"on_alloc_cb!\");\n-            let char_ptr = malloc_buf_base_of(suggested_size);\n-            debug!(\"on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n-                             handle,\n-                             char_ptr as uint,\n-                             suggested_size as uint);\n-            return buf_init(char_ptr, suggested_size as uint);\n-        }\n-    }\n-\n-    extern fn on_read_cb(stream: *uv_stream_t,\n-                        nread: libc::ssize_t,\n-                        buf: uv_buf_t) {\n-        unsafe {\n-            let nread = nread as int;\n-            debug!(\"CLIENT entering on_read_cb nred: %d\",\n-                            nread);\n-            if (nread > 0) {\n-                // we have data\n-                debug!(\"CLIENT read: data! nread: %d\", nread);\n-                read_stop(stream);\n-                let client_data =\n-                    get_data_for_uv_handle(stream as *libc::c_void)\n-                      as *request_wrapper;\n-                let buf_base = get_base_from_buf(buf);\n-                let bytes = vec::from_buf(buf_base, nread as uint);\n-                let read_chan = (*client_data).read_chan.clone();\n-                let msg_from_server = str::from_bytes(bytes);\n-                read_chan.send(msg_from_server);\n-                close(stream as *libc::c_void, after_close_cb)\n-            }\n-            else if (nread == -1) {\n-                // err .. possibly EOF\n-                debug!(~\"read: eof!\");\n-            }\n-            else {\n-                // nread == 0 .. do nothing, just free buf as below\n-                debug!(~\"read: do nothing!\");\n-            }\n-            // when we're done\n-            free_base_of_buf(buf);\n-            debug!(~\"CLIENT exiting on_read_cb\");\n-        }\n-    }\n-\n-    extern fn on_write_complete_cb(write_req: *uv_write_t,\n-                                  status: libc::c_int) {\n-        unsafe {\n-            debug!(\n-                \"CLIENT beginning on_write_complete_cb status: %d\",\n-                     status as int);\n-            let stream = get_stream_handle_from_write_req(write_req);\n-            debug!(\n-                \"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n-                stream as int, write_req as int);\n-            let result = read_start(stream, on_alloc_cb, on_read_cb);\n-            debug!(\"CLIENT ending on_write_complete_cb .. status: %d\",\n-                     result as int);\n-        }\n-    }\n-\n-    extern fn on_connect_cb(connect_req_ptr: *uv_connect_t,\n-                                 status: libc::c_int) {\n-        unsafe {\n-            debug!(\"beginning on_connect_cb .. status: %d\",\n-                             status as int);\n-            let stream =\n-                get_stream_handle_from_connect_req(connect_req_ptr);\n-            if (status == 0i32) {\n-                debug!(~\"on_connect_cb: in status=0 if..\");\n-                let client_data = get_data_for_req(\n-                    connect_req_ptr as *libc::c_void)\n-                    as *request_wrapper;\n-                let write_handle = (*client_data).write_req;\n-                debug!(\"on_connect_cb: tcp: %d write_hdl: %d\",\n-                                stream as int, write_handle as int);\n-                let write_result = write(write_handle,\n-                                  stream as *libc::c_void,\n-                                  (*client_data).req_buf,\n-                                  on_write_complete_cb);\n-                debug!(\"on_connect_cb: write() status: %d\",\n-                                 write_result as int);\n-            }\n-            else {\n-                let test_loop = get_loop_for_uv_handle(\n-                    stream as *libc::c_void);\n-                let err_msg = get_last_err_info(test_loop);\n-                debug!(err_msg);\n-                assert!(false);\n-            }\n-            debug!(~\"finishing on_connect_cb\");\n-        }\n-    }\n-\n-    fn impl_uv_tcp_request(ip: &str, port: int, req_str: &str,\n-                          client_chan: SharedChan<~str>) {\n-        unsafe {\n-            let test_loop = loop_new();\n-            let tcp_handle = tcp_t();\n-            let tcp_handle_ptr: *uv_tcp_t = &tcp_handle;\n-            let connect_handle = connect_t();\n-            let connect_req_ptr: *uv_connect_t = &connect_handle;\n-\n-            // this is the persistent payload of data that we\n-            // need to pass around to get this example to work.\n-            // In C, this would be a malloc'd or stack-allocated\n-            // struct that we'd cast to a void* and store as the\n-            // data field in our uv_connect_t struct\n-            let req_str_bytes = req_str.as_bytes();\n-            let req_msg_ptr: *u8 = vec::raw::to_ptr(req_str_bytes);\n-            debug!(\"req_msg ptr: %u\", req_msg_ptr as uint);\n-            let req_msg = ~[\n-                buf_init(req_msg_ptr, req_str_bytes.len())\n-            ];\n-            // this is the enclosing record, we'll pass a ptr to\n-            // this to C..\n-            let write_handle = write_t();\n-            let write_handle_ptr: *uv_write_t = &write_handle;\n-            debug!(\"tcp req: tcp stream: %d write_handle: %d\",\n-                             tcp_handle_ptr as int,\n-                             write_handle_ptr as int);\n-            let client_data = request_wrapper {\n-                write_req: write_handle_ptr,\n-                req_buf: &req_msg,\n-                read_chan: client_chan\n-            };\n-\n-            let tcp_init_result = tcp_init(test_loop as *libc::c_void,\n-                                           tcp_handle_ptr);\n-            if (tcp_init_result == 0) {\n-                debug!(~\"successful tcp_init_result\");\n-\n-                debug!(~\"building addr...\");\n-                let addr = ip4_addr(ip, port);\n-                // FIXME ref #2064\n-                let addr_ptr: *sockaddr_in = &addr;\n-                debug!(\"after build addr in rust. port: %u\",\n-                       addr.sin_port as uint);\n-\n-                // this should set up the connection request..\n-                debug!(\"b4 call tcp_connect connect cb: %u \",\n-                       on_connect_cb as uint);\n-                let tcp_connect_result = tcp_connect(connect_req_ptr,\n-                                                     tcp_handle_ptr,\n-                                                     addr_ptr,\n-                                                     on_connect_cb);\n-                if (tcp_connect_result == 0) {\n-                    // not set the data on the connect_req\n-                    // until its initialized\n-                    set_data_for_req(connect_req_ptr as *libc::c_void,\n-                                     &client_data);\n-                    set_data_for_uv_handle(tcp_handle_ptr as *libc::c_void,\n-                                           &client_data);\n-                    debug!(~\"before run tcp req loop\");\n-                    run(test_loop);\n-                    debug!(~\"after run tcp req loop\");\n-                }\n-                else {\n-                   debug!(~\"tcp_connect() failure\");\n-                   assert!(false);\n-                }\n-            }\n-            else {\n-                debug!(~\"tcp_init() failure\");\n-                assert!(false);\n-            }\n-            loop_delete(test_loop);\n-        }\n-    }\n-\n-    extern fn server_after_close_cb(handle: *libc::c_void) {\n-        debug!(\"SERVER server stream closed, should exit. h: %?\",\n-                   handle);\n-    }\n-\n-    extern fn client_stream_after_close_cb(handle: *libc::c_void) {\n-        unsafe {\n-            debug!(~\"SERVER: closed client stream, now closing server stream\");\n-            let client_data = get_data_for_uv_handle(\n-                handle) as\n-                *tcp_server_data;\n-            close((*client_data).server as *libc::c_void,\n-                          server_after_close_cb);\n-        }\n-    }\n-\n-    extern fn after_server_resp_write(req: *uv_write_t) {\n-        unsafe {\n-            let client_stream_ptr =\n-                get_stream_handle_from_write_req(req);\n-            debug!(~\"SERVER: resp sent... closing client stream\");\n-            close(client_stream_ptr as *libc::c_void,\n-                          client_stream_after_close_cb)\n-        }\n-    }\n-\n-    extern fn on_server_read_cb(client_stream_ptr: *uv_stream_t,\n-                               nread: libc::ssize_t,\n-                               buf: uv_buf_t) {\n-        unsafe {\n-            let nread = nread as int;\n-            if (nread > 0) {\n-                // we have data\n-                debug!(\"SERVER read: data! nread: %d\", nread);\n-\n-                // pull out the contents of the write from the client\n-                let buf_base = get_base_from_buf(buf);\n-                let buf_len = get_len_from_buf(buf) as uint;\n-                debug!(\"SERVER buf base: %u, len: %u, nread: %d\",\n-                                buf_base as uint,\n-                                buf_len as uint,\n-                                nread);\n-                let bytes = vec::from_buf(buf_base, nread as uint);\n-                let request_str = str::from_bytes(bytes);\n-\n-                let client_data = get_data_for_uv_handle(\n-                    client_stream_ptr as *libc::c_void) as *tcp_server_data;\n-\n-                let server_kill_msg = (*client_data).server_kill_msg.clone();\n-                let write_req = (*client_data).server_write_req;\n-                if request_str.contains(server_kill_msg) {\n-                    debug!(~\"SERVER: client req contains kill_msg!\");\n-                    debug!(~\"SERVER: sending response to client\");\n-                    read_stop(client_stream_ptr);\n-                    let server_chan = (*client_data).server_chan.clone();\n-                    server_chan.send(request_str);\n-                    let write_result = write(\n-                        write_req,\n-                        client_stream_ptr as *libc::c_void,\n-                        (*client_data).server_resp_buf,\n-                        after_server_resp_write);\n-                    debug!(\"SERVER: resp write result: %d\",\n-                                write_result as int);\n-                    if (write_result != 0i32) {\n-                        debug!(~\"bad result for server resp write()\");\n-                        debug!(get_last_err_info(\n-                            get_loop_for_uv_handle(client_stream_ptr\n-                                as *libc::c_void)));\n-                        assert!(false);\n-                    }\n-                }\n-                else {\n-                    debug!(~\"SERVER: client req !contain kill_msg!\");\n-                }\n-            }\n-            else if (nread == -1) {\n-                // err .. possibly EOF\n-                debug!(~\"read: eof!\");\n-            }\n-            else {\n-                // nread == 0 .. do nothing, just free buf as below\n-                debug!(~\"read: do nothing!\");\n-            }\n-            // when we're done\n-            free_base_of_buf(buf);\n-            debug!(~\"SERVER exiting on_read_cb\");\n-        }\n-    }\n-\n-    extern fn server_connection_cb(server_stream_ptr:\n-                                    *uv_stream_t,\n-                                  status: libc::c_int) {\n-        unsafe {\n-            debug!(~\"client connecting!\");\n-            let test_loop = get_loop_for_uv_handle(\n-                                   server_stream_ptr as *libc::c_void);\n-            if status != 0i32 {\n-                let err_msg = get_last_err_info(test_loop);\n-                debug!(\"server_connect_cb: non-zero status: %?\",\n-                             err_msg);\n-                return;\n-            }\n-            let server_data = get_data_for_uv_handle(\n-                server_stream_ptr as *libc::c_void) as *tcp_server_data;\n-            let client_stream_ptr = (*server_data).client;\n-            let client_init_result = tcp_init(test_loop,\n-                                                      client_stream_ptr);\n-            set_data_for_uv_handle(\n-                client_stream_ptr as *libc::c_void,\n-                server_data as *libc::c_void);\n-            if (client_init_result == 0i32) {\n-                debug!(~\"successfully initialized client stream\");\n-                let accept_result = accept(server_stream_ptr as\n-                                                     *libc::c_void,\n-                                                   client_stream_ptr as\n-                                                     *libc::c_void);\n-                if (accept_result == 0i32) {\n-                    // start reading\n-                    let read_result = read_start(\n-                        client_stream_ptr as *uv_stream_t,\n-                                                         on_alloc_cb,\n-                                                         on_server_read_cb);\n-                    if (read_result == 0i32) {\n-                        debug!(~\"successful server read start\");\n-                    }\n-                    else {\n-                        debug!(\"server_connection_cb: bad read:%d\",\n-                                        read_result as int);\n-                        assert!(false);\n-                    }\n-                }\n-                else {\n-                    debug!(\"server_connection_cb: bad accept: %d\",\n-                                accept_result as int);\n-                    assert!(false);\n-                }\n-            }\n-            else {\n-                debug!(\"server_connection_cb: bad client init: %d\",\n-                            client_init_result as int);\n-                assert!(false);\n-            }\n-        }\n-    }\n-\n-    struct tcp_server_data {\n-        client: *uv_tcp_t,\n-        server: *uv_tcp_t,\n-        server_kill_msg: ~str,\n-        server_resp_buf: *~[uv_buf_t],\n-        server_chan: SharedChan<~str>,\n-        server_write_req: *uv_write_t,\n-    }\n-\n-    struct async_handle_data {\n-        continue_chan: SharedChan<bool>,\n-    }\n-\n-    extern fn async_close_cb(handle: *libc::c_void) {\n-        debug!(\"SERVER: closing async cb... h: %?\",\n-                   handle);\n-    }\n-\n-    extern fn continue_async_cb(async_handle: *uv_async_t,\n-                               status: libc::c_int) {\n-        unsafe {\n-            // once we're in the body of this callback,\n-            // the tcp server's loop is set up, so we\n-            // can continue on to let the tcp client\n-            // do its thang\n-            let data = get_data_for_uv_handle(\n-                async_handle as *libc::c_void) as *async_handle_data;\n-            let continue_chan = (*data).continue_chan.clone();\n-            let should_continue = status == 0i32;\n-            continue_chan.send(should_continue);\n-            close(async_handle as *libc::c_void, async_close_cb);\n-        }\n-    }\n-\n-    fn impl_uv_tcp_server(server_ip: &str,\n-                          server_port: int,\n-                          kill_server_msg: ~str,\n-                          server_resp_msg: ~str,\n-                          server_chan: SharedChan<~str>,\n-                          continue_chan: SharedChan<bool>) {\n-        unsafe {\n-            let test_loop = loop_new();\n-            let tcp_server = tcp_t();\n-            let tcp_server_ptr: *uv_tcp_t = &tcp_server;\n-\n-            let tcp_client = tcp_t();\n-            let tcp_client_ptr: *uv_tcp_t = &tcp_client;\n-\n-            let server_write_req = write_t();\n-            let server_write_req_ptr: *uv_write_t = &server_write_req;\n-\n-            let resp_str_bytes = server_resp_msg.as_bytes();\n-            let resp_msg_ptr: *u8 = vec::raw::to_ptr(resp_str_bytes);\n-            debug!(\"resp_msg ptr: %u\", resp_msg_ptr as uint);\n-            let resp_msg = ~[\n-                buf_init(resp_msg_ptr, resp_str_bytes.len())\n-            ];\n-\n-            let continue_async_handle = async_t();\n-            let continue_async_handle_ptr: *uv_async_t =\n-                &continue_async_handle;\n-            let async_data =\n-                async_handle_data { continue_chan: continue_chan };\n-            let async_data_ptr: *async_handle_data = &async_data;\n-\n-            let server_data = tcp_server_data {\n-                client: tcp_client_ptr,\n-                server: tcp_server_ptr,\n-                server_kill_msg: kill_server_msg,\n-                server_resp_buf: &resp_msg,\n-                server_chan: server_chan,\n-                server_write_req: server_write_req_ptr\n-            };\n-            let server_data_ptr: *tcp_server_data = &server_data;\n-            set_data_for_uv_handle(tcp_server_ptr as *libc::c_void,\n-                                           server_data_ptr as *libc::c_void);\n-\n-            // uv_tcp_init()\n-            let tcp_init_result = tcp_init(\n-                test_loop as *libc::c_void, tcp_server_ptr);\n-            if (tcp_init_result == 0i32) {\n-                let server_addr = ip4_addr(server_ip, server_port);\n-                // FIXME ref #2064\n-                let server_addr_ptr: *sockaddr_in = &server_addr;\n-\n-                // uv_tcp_bind()\n-                let bind_result = tcp_bind(tcp_server_ptr, server_addr_ptr);\n-                if (bind_result == 0i32) {\n-                    debug!(~\"successful uv_tcp_bind, listening\");\n-\n-                    // uv_listen()\n-                    let listen_result = listen(tcp_server_ptr as\n-                                                         *libc::c_void,\n-                                                       128i32,\n-                                                       server_connection_cb);\n-                    if (listen_result == 0i32) {\n-                        // let the test know it can set up the tcp server,\n-                        // now.. this may still present a race, not sure..\n-                        let async_result = async_init(test_loop,\n-                                           continue_async_handle_ptr,\n-                                           continue_async_cb);\n-                        if (async_result == 0i32) {\n-                            set_data_for_uv_handle(\n-                                continue_async_handle_ptr as *libc::c_void,\n-                                async_data_ptr as *libc::c_void);\n-                            async_send(continue_async_handle_ptr);\n-                            // uv_run()\n-                            run(test_loop);\n-                            debug!(~\"server uv::run() has returned\");\n-                        }\n-                        else {\n-                            debug!(\"uv_async_init failure: %d\",\n-                                    async_result as int);\n-                            assert!(false);\n-                        }\n-                    }\n-                    else {\n-                        debug!(\"non-zero result on uv_listen: %d\",\n-                                    listen_result as int);\n-                        assert!(false);\n-                    }\n-                }\n-                else {\n-                    debug!(\"non-zero result on uv_tcp_bind: %d\",\n-                                bind_result as int);\n-                    assert!(false);\n-                }\n-            }\n-            else {\n-                debug!(\"non-zero result on uv_tcp_init: %d\",\n-                            tcp_init_result as int);\n-                assert!(false);\n-            }\n-            loop_delete(test_loop);\n-        }\n-    }\n-\n-    // this is the impl for a test that is (maybe) ran on a\n-    // per-platform/arch basis below\n-    pub fn impl_uv_tcp_server_and_request() {\n-        let bind_ip = ~\"0.0.0.0\";\n-        let request_ip = ~\"127.0.0.1\";\n-        let port = 8886;\n-        let kill_server_msg = ~\"does a dog have buddha nature?\";\n-        let server_resp_msg = ~\"mu!\";\n-        let (client_port, client_chan) = stream::<~str>();\n-        let client_chan = SharedChan::new(client_chan);\n-        let (server_port, server_chan) = stream::<~str>();\n-        let server_chan = SharedChan::new(server_chan);\n-\n-        let (continue_port, continue_chan) = stream::<bool>();\n-        let continue_chan = SharedChan::new(continue_chan);\n-\n-        let kill_server_msg_copy = kill_server_msg.clone();\n-        let server_resp_msg_copy = server_resp_msg.clone();\n-        do task::spawn_sched(task::ManualThreads(1)) {\n-            impl_uv_tcp_server(bind_ip, port,\n-                               kill_server_msg_copy.clone(),\n-                               server_resp_msg_copy.clone(),\n-                               server_chan.clone(),\n-                               continue_chan.clone());\n-        };\n-\n-        // block until the server up is.. possibly a race?\n-        debug!(~\"before receiving on server continue_port\");\n-        continue_port.recv();\n-        debug!(~\"received on continue port, set up tcp client\");\n-\n-        let kill_server_msg_copy = kill_server_msg.clone();\n-        do task::spawn_sched(task::ManualThreads(1u)) {\n-            impl_uv_tcp_request(request_ip, port,\n-                               kill_server_msg_copy,\n-                               client_chan.clone());\n-        };\n-\n-        let msg_from_client = server_port.recv();\n-        let msg_from_server = client_port.recv();\n-\n-        assert!(msg_from_client.contains(kill_server_msg));\n-        assert!(msg_from_server.contains(server_resp_msg));\n-    }\n-\n-    // FIXME don't run on fbsd or linux 32 bit(#2064)\n-    #[cfg(target_os=\"win32\")]\n-    #[cfg(target_os=\"darwin\")]\n-    #[cfg(target_os=\"linux\")]\n-    #[cfg(target_os=\"android\")]\n-    mod tcp_and_server_client_test {\n-        #[cfg(target_arch=\"x86_64\")]\n-        mod impl64 {\n-            #[test]\n-            fn test_uv_ll_tcp_server_and_request() {\n-                super::super::impl_uv_tcp_server_and_request();\n-            }\n-        }\n-        #[cfg(target_arch=\"x86\")]\n-        #[cfg(target_arch=\"arm\")]\n-        #[cfg(target_arch=\"mips\")]\n-        mod impl32 {\n-            #[test]\n-            #[ignore(cfg(target_os = \"linux\"))]\n-            fn test_uv_ll_tcp_server_and_request() {\n-                unsafe {\n-                    super::super::impl_uv_tcp_server_and_request();\n-                }\n-            }\n-        }\n-    }\n-\n-    fn struct_size_check_common<TStruct>(t_name: ~str,\n-                                         foreign_size: libc::c_uint) {\n-        let rust_size = sys::size_of::<TStruct>();\n-        let sizes_match = foreign_size as uint == rust_size;\n-        if !sizes_match {\n-            let output = fmt!(\n-                \"STRUCT_SIZE FAILURE: %s -- actual: %u expected: %u\",\n-                t_name, rust_size, foreign_size as uint);\n-            debug!(output);\n-        }\n-        assert!(sizes_match);\n-    }\n-\n-    // struct size tests\n-    #[test]\n-    fn test_uv_ll_struct_size_uv_tcp_t() {\n-        unsafe {\n-            struct_size_check_common::<uv_tcp_t>(\n-                ~\"uv_tcp_t\",\n-                super::rust_uv_helper_uv_tcp_t_size()\n-            );\n-        }\n-    }\n-    #[test]\n-    fn test_uv_ll_struct_size_uv_connect_t() {\n-        unsafe {\n-            struct_size_check_common::<uv_connect_t>(\n-                ~\"uv_connect_t\",\n-                super::rust_uv_helper_uv_connect_t_size()\n-            );\n-        }\n-    }\n-    #[test]\n-    fn test_uv_ll_struct_size_uv_buf_t() {\n-        unsafe {\n-            struct_size_check_common::<uv_buf_t>(\n-                ~\"uv_buf_t\",\n-                super::rust_uv_helper_uv_buf_t_size()\n-            );\n-        }\n-    }\n-    #[test]\n-    fn test_uv_ll_struct_size_uv_write_t() {\n-        unsafe {\n-            struct_size_check_common::<uv_write_t>(\n-                ~\"uv_write_t\",\n-                super::rust_uv_helper_uv_write_t_size()\n-            );\n-        }\n-    }\n-\n-    #[test]\n-    fn test_uv_ll_struct_size_sockaddr_in() {\n-        unsafe {\n-            struct_size_check_common::<sockaddr_in>(\n-                ~\"sockaddr_in\",\n-                super::rust_uv_helper_sockaddr_in_size()\n-            );\n-        }\n-    }\n-    #[test]\n-    fn test_uv_ll_struct_size_sockaddr_in6() {\n-        unsafe {\n-            let foreign_handle_size =\n-                super::rust_uv_helper_sockaddr_in6_size();\n-            let rust_handle_size = sys::size_of::<sockaddr_in6>();\n-            let output = fmt!(\"sockaddr_in6 -- foreign: %u rust: %u\",\n-                              foreign_handle_size as uint, rust_handle_size);\n-            debug!(output);\n-            // FIXME #1645 .. rust appears to pad structs to the nearest\n-            // byte..?\n-            // .. can't get the uv::ll::sockaddr_in6 to == 28 :/\n-            // .. so the type always appears to be 32 in size.. which is\n-            // good, i guess.. better too big than too little\n-            assert!((4u+foreign_handle_size as uint) ==\n-                rust_handle_size);\n-        }\n-    }\n-    #[test]\n-    #[ignore(reason = \"questionable size calculations\")]\n-    fn test_uv_ll_struct_size_addr_in() {\n-        unsafe {\n-            let foreign_handle_size =\n-                super::rust_uv_helper_addr_in_size();\n-            let rust_handle_size = sys::size_of::<addr_in>();\n-            let output = fmt!(\"addr_in -- foreign: %u rust: %u\",\n-                              foreign_handle_size as uint, rust_handle_size);\n-            debug!(output);\n-            // FIXME #1645 .. see note above about struct padding\n-            assert!((4u+foreign_handle_size as uint) ==\n-                rust_handle_size);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_uv_ll_struct_size_uv_async_t() {\n-        unsafe {\n-            struct_size_check_common::<uv_async_t>(\n-                ~\"uv_async_t\",\n-                super::rust_uv_helper_uv_async_t_size()\n-            );\n-        }\n-    }\n-\n-    #[test]\n-    fn test_uv_ll_struct_size_uv_timer_t() {\n-        unsafe {\n-            struct_size_check_common::<uv_timer_t>(\n-                ~\"uv_timer_t\",\n-                super::rust_uv_helper_uv_timer_t_size()\n-            );\n-        }\n-    }\n-\n-    #[test]\n-    #[ignore(cfg(target_os = \"win32\"))]\n-    fn test_uv_ll_struct_size_uv_getaddrinfo_t() {\n-        unsafe {\n-            struct_size_check_common::<uv_getaddrinfo_t>(\n-                ~\"uv_getaddrinfo_t\",\n-                super::rust_uv_helper_uv_getaddrinfo_t_size()\n-            );\n-        }\n-    }\n-    #[test]\n-    #[ignore(cfg(target_os = \"macos\"))]\n-    #[ignore(cfg(target_os = \"win32\"))]\n-    fn test_uv_ll_struct_size_addrinfo() {\n-        unsafe {\n-            struct_size_check_common::<uv_timer_t>(\n-                ~\"addrinfo\",\n-                super::rust_uv_helper_uv_timer_t_size()\n-            );\n-        }\n-    }\n-}"}, {"sha": "286b1f84802c3298eaec4541ab5306a605350916", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -791,12 +791,14 @@ fn rust_path_test() {\n \n #[test]\n fn rust_path_contents() {\n+    use std::unstable::change_dir_locked;\n+\n     let dir = mkdtemp(&os::tmpdir(), \"rust_path\").expect(\"rust_path_contents failed\");\n     let abc = &dir.push(\"A\").push(\"B\").push(\"C\");\n     assert!(os::mkdir_recursive(&abc.push(\".rust\"), U_RWX));\n     assert!(os::mkdir_recursive(&abc.pop().push(\".rust\"), U_RWX));\n     assert!(os::mkdir_recursive(&abc.pop().pop().push(\".rust\"), U_RWX));\n-    assert!(do os::change_dir_locked(&dir.push(\"A\").push(\"B\").push(\"C\")) {\n+    assert!(do change_dir_locked(&dir.push(\"A\").push(\"B\").push(\"C\")) {\n         let p = rust_path();\n         let cwd = os::getcwd().push(\".rust\");\n         let parent = cwd.pop().pop().push(\".rust\");"}, {"sha": "5981926fce30c618d292d1beb798c45755d6aef2", "filename": "src/libstd/os.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -863,34 +863,6 @@ pub fn change_dir(p: &Path) -> bool {\n     }\n }\n \n-/// Changes the current working directory to the specified\n-/// path while acquiring a global lock, then calls `action`.\n-/// If the change is successful, releases the lock and restores the\n-/// CWD to what it was before, returning true.\n-/// Returns false if the directory doesn't exist or if the directory change\n-/// is otherwise unsuccessful.\n-pub fn change_dir_locked(p: &Path, action: &fn()) -> bool {\n-    use unstable::global::global_data_clone_create;\n-    use unstable::sync::{Exclusive, exclusive};\n-\n-    fn key(_: Exclusive<()>) { }\n-\n-    unsafe {\n-        let result = global_data_clone_create(key, || { ~exclusive(()) });\n-\n-        do result.with_imm() |_| {\n-            let old_dir = os::getcwd();\n-            if change_dir(p) {\n-                action();\n-                change_dir(&old_dir)\n-            }\n-            else {\n-                false\n-            }\n-        }\n-    }\n-}\n-\n /// Copies a file from one location to another\n pub fn copy_file(from: &Path, to: &Path) -> bool {\n     return do_copy_file(from, to);"}, {"sha": "20ddf941a7b95d67af79b17eb75777fb7c1e4bc9", "filename": "src/libstd/unstable/at_exit.rs", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibstd%2Funstable%2Fat_exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibstd%2Funstable%2Fat_exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fat_exit.rs?ref=9ed82fbb43804ebc7e06daca5812079630ec8952", "patch": "@@ -1,100 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use cast;\n-use libc::size_t;\n-use rand::RngUtil;\n-use rand;\n-use sys;\n-use task;\n-use vec;\n-\n-#[cfg(test)] use uint;\n-\n-/**\n-Register a function to be run during runtime shutdown.\n-\n-After all non-weak tasks have exited, registered exit functions will\n-execute, in random order, on the primary scheduler. Each function runs\n-in its own unsupervised task.\n-*/\n-pub fn at_exit(f: ~fn()) {\n-    unsafe {\n-        let runner: &fn(*ExitFunctions) = exit_runner;\n-        let runner_pair: sys::Closure = cast::transmute(runner);\n-        let runner_ptr = runner_pair.code;\n-        let runner_ptr = cast::transmute(runner_ptr);\n-        rustrt::rust_register_exit_function(runner_ptr, ~f);\n-    }\n-}\n-\n-// NB: The double pointer indirection here is because ~fn() is a fat\n-// pointer and due to FFI problems I am more comfortable making the\n-// interface use a normal pointer\n-mod rustrt {\n-    use libc::c_void;\n-\n-    extern {\n-        pub fn rust_register_exit_function(runner: *c_void, f: ~~fn());\n-    }\n-}\n-\n-struct ExitFunctions {\n-    // The number of exit functions\n-    count: size_t,\n-    // The buffer of exit functions\n-    start: *~~fn()\n-}\n-\n-fn exit_runner(exit_fns: *ExitFunctions) {\n-    let exit_fns = unsafe { &*exit_fns };\n-    let count = (*exit_fns).count;\n-    let start = (*exit_fns).start;\n-\n-    // NB: from_buf memcpys from the source, which will\n-    // give us ownership of the array of functions\n-    let mut exit_fns_vec = unsafe { vec::from_buf(start, count as uint) };\n-    // Let's not make any promises about execution order\n-    let mut rng = rand::rng();\n-    rng.shuffle_mut(exit_fns_vec);\n-\n-    debug!(\"running %u exit functions\", exit_fns_vec.len());\n-\n-    while !exit_fns_vec.is_empty() {\n-        match exit_fns_vec.pop() {\n-            ~f => {\n-                let mut task = task::task();\n-                task.supervised();\n-                task.spawn(f);\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_at_exit() {\n-    let i = 10;\n-    do at_exit {\n-        debug!(\"at_exit1\");\n-        assert_eq!(i, 10);\n-    }\n-}\n-\n-#[test]\n-fn test_at_exit_many() {\n-    let i = 10;\n-    for uint::range(20, 100) |j| {\n-        do at_exit {\n-            debug!(\"at_exit2\");\n-            assert_eq!(i, 10);\n-            assert!(j > i);\n-        }\n-    }\n-}"}, {"sha": "af28879f73971c9a2fbed1ce880e361b4b142f6e", "filename": "src/libstd/unstable/global.rs", "status": "removed", "additions": 0, "deletions": 281, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibstd%2Funstable%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibstd%2Funstable%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fglobal.rs?ref=9ed82fbb43804ebc7e06daca5812079630ec8952", "patch": "@@ -1,281 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Global data\n-\n-An interface for creating and retrieving values with global\n-(per-runtime) scope.\n-\n-Global values are stored in a map and protected by a single global\n-mutex. Operations are provided for accessing and cloning the value\n-under the mutex.\n-\n-Because all globals go through a single mutex, they should be used\n-sparingly.  The interface is intended to be used with clonable,\n-atomically reference counted synchronization types, like ARCs, in\n-which case the value should be cached locally whenever possible to\n-avoid hitting the mutex.\n-*/\n-\n-use cast::{transmute};\n-use clone::Clone;\n-use kinds::Send;\n-use libc::{c_void, intptr_t};\n-use option::{Option, Some, None};\n-use ops::Drop;\n-use unstable::sync::{Exclusive, exclusive};\n-use unstable::at_exit::at_exit;\n-use unstable::intrinsics::atomic_cxchg;\n-use hashmap::HashMap;\n-use sys::Closure;\n-\n-#[cfg(test)] use unstable::sync::{UnsafeAtomicRcBox};\n-#[cfg(test)] use task::spawn;\n-#[cfg(test)] use uint;\n-\n-pub type GlobalDataKey<'self,T> = &'self fn(v: T);\n-\n-pub unsafe fn global_data_clone_create<T:Send + Clone>(\n-    key: GlobalDataKey<T>, create: &fn() -> ~T) -> T {\n-    /*!\n-     * Clone a global value or, if it has not been created,\n-     * first construct the value then return a clone.\n-     *\n-     * # Safety note\n-     *\n-     * Both the clone operation and the constructor are\n-     * called while the global lock is held. Recursive\n-     * use of the global interface in either of these\n-     * operations will result in deadlock.\n-     */\n-    global_data_clone_create_(key_ptr(key), create)\n-}\n-\n-unsafe fn global_data_clone_create_<T:Send + Clone>(\n-    key: uint, create: &fn() -> ~T) -> T {\n-\n-    let mut clone_value: Option<T> = None;\n-    do global_data_modify_(key) |value: Option<~T>| {\n-        match value {\n-            None => {\n-                let value = create();\n-                clone_value = Some((*value).clone());\n-                Some(value)\n-            }\n-            Some(value) => {\n-                clone_value = Some((*value).clone());\n-                Some(value)\n-            }\n-        }\n-    }\n-    return clone_value.unwrap();\n-}\n-\n-unsafe fn global_data_modify<T:Send>(\n-    key: GlobalDataKey<T>, op: &fn(Option<~T>) -> Option<~T>) {\n-\n-    global_data_modify_(key_ptr(key), op)\n-}\n-\n-unsafe fn global_data_modify_<T:Send>(\n-    key: uint, op: &fn(Option<~T>) -> Option<~T>) {\n-\n-    let mut old_dtor = None;\n-    do get_global_state().with |gs| {\n-        let (maybe_new_value, maybe_dtor) = match gs.map.pop(&key) {\n-            Some((ptr, dtor)) => {\n-                let value: ~T = transmute(ptr);\n-                (op(Some(value)), Some(dtor))\n-            }\n-            None => {\n-                (op(None), None)\n-            }\n-        };\n-        match maybe_new_value {\n-            Some(value) => {\n-                let data: *c_void = transmute(value);\n-                let dtor: ~fn() = match maybe_dtor {\n-                    Some(dtor) => dtor,\n-                    None => {\n-                        let dtor: ~fn() = || {\n-                            let _destroy_value: ~T = transmute(data);\n-                        };\n-                        dtor\n-                    }\n-                };\n-                let value = (data, dtor);\n-                gs.map.insert(key, value);\n-            }\n-            None => {\n-                match maybe_dtor {\n-                    Some(dtor) => old_dtor = Some(dtor),\n-                    None => ()\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub unsafe fn global_data_clone<T:Send + Clone>(\n-    key: GlobalDataKey<T>) -> Option<T> {\n-    let mut maybe_clone: Option<T> = None;\n-    do global_data_modify(key) |current| {\n-        match &current {\n-            &Some(~ref value) => {\n-                maybe_clone = Some(value.clone());\n-            }\n-            &None => ()\n-        }\n-        current\n-    }\n-    return maybe_clone;\n-}\n-\n-// GlobalState is a map from keys to unique pointers and a\n-// destructor. Keys are pointers derived from the type of the\n-// global value.  There is a single GlobalState instance per runtime.\n-struct GlobalState {\n-    map: HashMap<uint, (*c_void, ~fn())>\n-}\n-\n-impl Drop for GlobalState {\n-    fn drop(&self) {\n-        for self.map.each_value |v| {\n-            match v {\n-                &(_, ref dtor) => (*dtor)()\n-            }\n-        }\n-    }\n-}\n-\n-fn get_global_state() -> Exclusive<GlobalState> {\n-\n-    static POISON: int = -1;\n-\n-    // FIXME #4728: Doing atomic_cxchg to initialize the global state\n-    // lazily, which wouldn't be necessary with a runtime written\n-    // in Rust\n-    let global_ptr = unsafe { rust_get_global_data_ptr() };\n-\n-    if unsafe { *global_ptr } == 0 {\n-        // Global state doesn't exist yet, probably\n-\n-        // The global state object\n-        let state = GlobalState {\n-            map: HashMap::new()\n-        };\n-\n-        // It's under a reference-counted mutex\n-        let state = ~exclusive(state);\n-\n-        // Convert it to an integer\n-        let state_i: int = unsafe {\n-            let state_ptr: &Exclusive<GlobalState> = state;\n-            transmute(state_ptr)\n-        };\n-\n-        // Swap our structure into the global pointer\n-        let prev_i = unsafe { atomic_cxchg(&mut *global_ptr, 0, state_i) };\n-\n-        // Sanity check that we're not trying to reinitialize after shutdown\n-        assert!(prev_i != POISON);\n-\n-        if prev_i == 0 {\n-            // Successfully installed the global pointer\n-\n-            // Take a handle to return\n-            let clone = (*state).clone();\n-\n-            // Install a runtime exit function to destroy the global object\n-            do at_exit {\n-                // Poison the global pointer\n-                let prev_i = unsafe {\n-                    atomic_cxchg(&mut *global_ptr, state_i, POISON)\n-                };\n-                assert_eq!(prev_i, state_i);\n-\n-                // Capture the global state object in the at_exit closure\n-                // so that it is destroyed at the right time\n-                let _capture_global_state = &state;\n-            };\n-            return clone;\n-        } else {\n-            // Somebody else initialized the globals first\n-            let state: &Exclusive<GlobalState> = unsafe { transmute(prev_i) };\n-            return state.clone();\n-        }\n-    } else {\n-        let state: &Exclusive<GlobalState> = unsafe {\n-            transmute(*global_ptr)\n-        };\n-        return state.clone();\n-    }\n-}\n-\n-fn key_ptr<T:Send>(key: GlobalDataKey<T>) -> uint {\n-    unsafe {\n-        let closure: Closure = transmute(key);\n-        return transmute(closure.code);\n-    }\n-}\n-\n-extern {\n-    fn rust_get_global_data_ptr() -> *mut intptr_t;\n-}\n-\n-#[test]\n-fn test_clone_rc() {\n-    fn key(_v: UnsafeAtomicRcBox<int>) { }\n-\n-    for uint::range(0, 100) |_| {\n-        do spawn {\n-            unsafe {\n-                let val = do global_data_clone_create(key) {\n-                    ~UnsafeAtomicRcBox::new(10)\n-                };\n-\n-                assert!(val.get() == &10);\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_modify() {\n-    fn key(_v: UnsafeAtomicRcBox<int>) { }\n-\n-    unsafe {\n-        do global_data_modify(key) |v| {\n-            match v {\n-                None => { Some(~UnsafeAtomicRcBox::new(10)) }\n-                _ => fail!()\n-            }\n-        }\n-\n-        do global_data_modify(key) |v| {\n-            match v {\n-                Some(sms) => {\n-                    let v = sms.get();\n-                    assert!(*v == 10);\n-                    None\n-                },\n-                _ => fail!()\n-            }\n-        }\n-\n-        do global_data_modify(key) |v| {\n-            match v {\n-                None => { Some(~UnsafeAtomicRcBox::new(10)) }\n-                _ => fail!()\n-            }\n-        }\n-    }\n-}"}, {"sha": "d6fd2cbcd1e4d7ec175e086c59ee8bf0679bd0f6", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -16,13 +16,9 @@ use libc;\n use prelude::*;\n use task;\n \n-pub mod at_exit;\n-\n pub mod dynamic_lib;\n \n-pub mod global;\n pub mod finally;\n-pub mod weak_task;\n pub mod intrinsics;\n pub mod simd;\n pub mod extfmt;\n@@ -80,3 +76,53 @@ extern {\n     fn rust_raw_thread_start(f: &(&fn())) -> *raw_thread;\n     fn rust_raw_thread_join_delete(thread: *raw_thread);\n }\n+\n+\n+/// Changes the current working directory to the specified\n+/// path while acquiring a global lock, then calls `action`.\n+/// If the change is successful, releases the lock and restores the\n+/// CWD to what it was before, returning true.\n+/// Returns false if the directory doesn't exist or if the directory change\n+/// is otherwise unsuccessful.\n+///\n+/// This is used by test cases to avoid cwd races.\n+///\n+/// # Safety Note\n+///\n+/// This uses a pthread mutex so descheduling in the action callback\n+/// can lead to deadlock. Calling change_dir_locked recursively will\n+/// also deadlock.\n+pub fn change_dir_locked(p: &Path, action: &fn()) -> bool {\n+    use os;\n+    use os::change_dir;\n+    use task;\n+    use unstable::finally::Finally;\n+\n+    unsafe {\n+        // This is really sketchy. Using a pthread mutex so descheduling\n+        // in the `action` callback can cause deadlock. Doing it in\n+        // `task::atomically` to try to avoid that, but ... I don't know\n+        // this is all bogus.\n+        return do task::atomically {\n+            rust_take_change_dir_lock();\n+\n+            do (||{\n+                let old_dir = os::getcwd();\n+                if change_dir(p) {\n+                    action();\n+                    change_dir(&old_dir)\n+                }\n+                else {\n+                    false\n+                }\n+            }).finally {\n+                rust_drop_change_dir_lock();\n+            }\n+        }\n+    }\n+\n+    extern {\n+        fn rust_take_change_dir_lock();\n+        fn rust_drop_change_dir_lock();\n+    }\n+}"}, {"sha": "f5dfa1feb9b1346922e9cfa49eaacc498676ed44", "filename": "src/libstd/unstable/weak_task.rs", "status": "removed", "additions": 0, "deletions": 211, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibstd%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed82fbb43804ebc7e06daca5812079630ec8952/src%2Flibstd%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fweak_task.rs?ref=9ed82fbb43804ebc7e06daca5812079630ec8952", "patch": "@@ -1,211 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Weak tasks\n-\n-Weak tasks are a runtime feature for building global services that\n-do not keep the runtime alive. Normally the runtime exits when all\n-tasks exits, but if a task is weak then the runtime may exit while\n-it is running, sending a notification to the task that the runtime\n-is trying to shut down.\n-*/\n-\n-use cell::Cell;\n-use comm::{GenericSmartChan, stream};\n-use comm::{Port, Chan, SharedChan, GenericChan, GenericPort};\n-use hashmap::HashMap;\n-use option::{Some, None};\n-use unstable::at_exit::at_exit;\n-use unstable::finally::Finally;\n-use unstable::global::global_data_clone_create;\n-use task::rt::{task_id, get_task_id};\n-use task::task;\n-\n-#[cfg(test)] use task::spawn;\n-\n-type ShutdownMsg = ();\n-\n-// FIXME #4729: This could be a PortOne but I've experienced bugginess\n-// with oneshot pipes and try_send\n-pub unsafe fn weaken_task(f: &fn(Port<ShutdownMsg>)) {\n-    let service = global_data_clone_create(global_data_key,\n-                                           create_global_service);\n-    let (shutdown_port, shutdown_chan) = stream::<ShutdownMsg>();\n-    let shutdown_port = Cell::new(shutdown_port);\n-    let task = get_task_id();\n-    // Expect the weak task service to be alive\n-    assert!(service.try_send(RegisterWeakTask(task, shutdown_chan)));\n-    rust_dec_kernel_live_count();\n-    do (|| {\n-        f(shutdown_port.take())\n-    }).finally || {\n-        rust_inc_kernel_live_count();\n-        // Service my have already exited\n-        service.send(UnregisterWeakTask(task));\n-    }\n-}\n-\n-type WeakTaskService = SharedChan<ServiceMsg>;\n-type TaskHandle = task_id;\n-\n-fn global_data_key(_v: WeakTaskService) { }\n-\n-enum ServiceMsg {\n-    RegisterWeakTask(TaskHandle, Chan<ShutdownMsg>),\n-    UnregisterWeakTask(TaskHandle),\n-    Shutdown\n-}\n-\n-fn create_global_service() -> ~WeakTaskService {\n-\n-    debug!(\"creating global weak task service\");\n-    let (port, chan) = stream::<ServiceMsg>();\n-    let port = Cell::new(port);\n-    let chan = SharedChan::new(chan);\n-    let chan_clone = chan.clone();\n-\n-    let mut task = task();\n-    task.unlinked();\n-    do task.spawn {\n-        debug!(\"running global weak task service\");\n-        let port = Cell::new(port.take());\n-        do (|| {\n-            let port = port.take();\n-            // The weak task service is itself a weak task\n-            debug!(\"weakening the weak service task\");\n-            unsafe { rust_dec_kernel_live_count(); }\n-            run_weak_task_service(port);\n-        }).finally {\n-            debug!(\"unweakening the weak service task\");\n-            unsafe { rust_inc_kernel_live_count(); }\n-        }\n-    }\n-\n-    do at_exit {\n-        debug!(\"shutting down weak task service\");\n-        chan.send(Shutdown);\n-    }\n-\n-    return ~chan_clone;\n-}\n-\n-fn run_weak_task_service(port: Port<ServiceMsg>) {\n-\n-    let mut shutdown_map = HashMap::new();\n-\n-    loop {\n-        match port.recv() {\n-            RegisterWeakTask(task, shutdown_chan) => {\n-                let previously_unregistered =\n-                    shutdown_map.insert(task, shutdown_chan);\n-                assert!(previously_unregistered);\n-            }\n-            UnregisterWeakTask(task) => {\n-                match shutdown_map.pop(&task) {\n-                    Some(shutdown_chan) => {\n-                        // Oneshot pipes must send, even though\n-                        // nobody will receive this\n-                        shutdown_chan.send(());\n-                    }\n-                    None => fail!()\n-                }\n-            }\n-            Shutdown => break\n-        }\n-    }\n-\n-    for shutdown_map.consume().advance |(_, shutdown_chan)| {\n-        // Weak task may have already exited\n-        shutdown_chan.send(());\n-    }\n-}\n-\n-extern {\n-    unsafe fn rust_inc_kernel_live_count();\n-    unsafe fn rust_dec_kernel_live_count();\n-}\n-\n-#[test]\n-fn test_simple() {\n-    let (port, chan) = stream();\n-    do spawn {\n-        unsafe {\n-            do weaken_task |_signal| {\n-            }\n-        }\n-        chan.send(());\n-    }\n-    port.recv();\n-}\n-\n-#[test]\n-fn test_weak_weak() {\n-    let (port, chan) = stream();\n-    do spawn {\n-        unsafe {\n-            do weaken_task |_signal| {\n-            }\n-            do weaken_task |_signal| {\n-            }\n-        }\n-        chan.send(());\n-    }\n-    port.recv();\n-}\n-\n-#[test]\n-fn test_wait_for_signal() {\n-    do spawn {\n-        unsafe {\n-            do weaken_task |signal| {\n-                signal.recv();\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_wait_for_signal_many() {\n-    use uint;\n-    for uint::range(0, 100) |_| {\n-        do spawn {\n-            unsafe {\n-                do weaken_task |signal| {\n-                    signal.recv();\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_select_stream_and_oneshot() {\n-    use comm::select2i;\n-    use either::{Left, Right};\n-\n-    let (port, chan) = stream();\n-    let port = Cell::new(port);\n-    let (waitport, waitchan) = stream();\n-    do spawn {\n-        unsafe {\n-            do weaken_task |mut signal| {\n-                let mut port = port.take();\n-                match select2i(&mut port, &mut signal) {\n-                    Left(*) => (),\n-                    Right(*) => fail!()\n-                }\n-            }\n-        }\n-        waitchan.send(());\n-    }\n-    chan.send(());\n-    waitport.recv();\n-}"}, {"sha": "06b09bcedd2d06ff4ead09ef9a08b73c74f8db0a", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -757,30 +757,6 @@ rust_raw_thread_join_delete(raw_thread *thread) {\n     delete thread;\n }\n \n-extern \"C\" void\n-rust_register_exit_function(spawn_fn runner, fn_env_pair *f) {\n-    rust_task *task = rust_get_current_task();\n-    task->kernel->register_exit_function(runner, f);\n-}\n-\n-extern \"C\" intptr_t*\n-rust_get_global_data_ptr() {\n-    rust_task *task = rust_get_current_task();\n-    return &task->kernel->global_data;\n-}\n-\n-extern \"C\" void\n-rust_inc_kernel_live_count() {\n-    rust_task *task = rust_get_current_task();\n-    task->kernel->inc_live_count();\n-}\n-\n-extern \"C\" void\n-rust_dec_kernel_live_count() {\n-    rust_task *task = rust_get_current_task();\n-    task->kernel->dec_live_count();\n-}\n-\n #ifndef _WIN32\n #include <sys/types.h>\n #include <dirent.h>\n@@ -959,6 +935,18 @@ rust_get_exit_status_newrt() {\n     return exit_status;\n }\n \n+static lock_and_signal change_dir_lock;\n+\n+extern \"C\" CDECL void\n+rust_take_change_dir_lock() {\n+    global_args_lock.lock();\n+}\n+\n+extern \"C\" CDECL void\n+rust_drop_change_dir_lock() {\n+    global_args_lock.unlock();\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "814cfbb310a79aa3d2c608411d436fab953d3814", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -31,10 +31,7 @@ rust_kernel::rust_kernel(rust_env *env) :\n     sched_reaper(this),\n     osmain_driver(NULL),\n     non_weak_tasks(0),\n-    at_exit_runner(NULL),\n-    at_exit_started(false),\n-    env(env),\n-    global_data(0)\n+    env(env)\n {\n     // Create the single threaded scheduler that will run on the platform's\n     // main thread\n@@ -311,54 +308,9 @@ rust_kernel::begin_shutdown() {\n         }\n     }\n \n-    run_exit_functions();\n     allow_scheduler_exit();\n }\n \n-void\n-rust_kernel::register_exit_function(spawn_fn runner, fn_env_pair *f) {\n-    scoped_lock with(at_exit_lock);\n-\n-    assert(!at_exit_started && \"registering at_exit function after exit\");\n-\n-    if (at_exit_runner) {\n-        // FIXME #2912 Would be very nice to assert this but we can't because\n-        // of the way coretest works (the test case ends up using its own\n-        // function)\n-        //assert(runner == at_exit_runner\n-        //       && \"there can be only one at_exit_runner\");\n-    }\n-\n-    at_exit_runner = runner;\n-    at_exit_fns.push_back(f);\n-}\n-\n-void\n-rust_kernel::run_exit_functions() {\n-    rust_task *task;\n-\n-    {\n-        scoped_lock with(at_exit_lock);\n-\n-        assert(!at_exit_started && \"running exit functions twice?\");\n-\n-        at_exit_started = true;\n-\n-        if (at_exit_runner == NULL) {\n-            return;\n-        }\n-\n-        rust_scheduler *sched = get_scheduler_by_id(main_sched_id());\n-        assert(sched);\n-        task = sched->create_task(NULL, \"at_exit\");\n-\n-        final_exit_fns.count = at_exit_fns.size();\n-        final_exit_fns.start = at_exit_fns.data();\n-    }\n-\n-    task->start(at_exit_runner, NULL, &final_exit_fns);\n-}\n-\n //\n // Local Variables:\n // mode: C++"}, {"sha": "0fe3f7610403f776c7da2af200e8b5ffd82164c3", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -63,13 +63,6 @@ typedef intptr_t rust_task_id;\n \n typedef std::map<rust_sched_id, rust_scheduler*> sched_map;\n \n-// This is defined as a struct only because we need a single pointer to pass\n-// to the Rust function that runs the at_exit functions\n-struct exit_functions {\n-    size_t count;\n-    fn_env_pair **start;\n-};\n-\n class rust_kernel {\n     rust_exchange_alloc exchange_alloc;\n     rust_log _log;\n@@ -114,17 +107,8 @@ class rust_kernel {\n     void allow_scheduler_exit();\n     void begin_shutdown();\n \n-    lock_and_signal at_exit_lock;\n-    spawn_fn at_exit_runner;\n-    bool at_exit_started;\n-    std::vector<fn_env_pair*> at_exit_fns;\n-    exit_functions final_exit_fns;\n-\n-    void run_exit_functions();\n-\n public:\n     struct rust_env *env;\n-    intptr_t global_data;\n \n     rust_kernel(rust_env *env);\n \n@@ -157,7 +141,6 @@ class rust_kernel {\n     void inc_live_count();\n     void dec_live_count();\n \n-    void register_exit_function(spawn_fn runner, fn_env_pair *f);\n };\n \n template <typename T> struct kernel_owned {"}, {"sha": "db9fe2479526c88fe6181013b73e2fc70bb4ce08", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -214,10 +214,6 @@ linenoiseHistorySave\n linenoiseHistoryLoad\n rust_raw_thread_start\n rust_raw_thread_join_delete\n-rust_register_exit_function\n-rust_get_global_data_ptr\n-rust_inc_kernel_live_count\n-rust_dec_kernel_live_count\n rust_get_rt_tls_key\n swap_registers\n rust_readdir\n@@ -270,3 +266,5 @@ rust_take_global_args_lock\n rust_drop_global_args_lock\n rust_set_exit_status_newrt\n rust_get_exit_status_newrt\n+rust_take_change_dir_lock\n+rust_drop_change_dir_lock\n\\ No newline at end of file"}, {"sha": "1f5da69018ab5211b141ca8ac788927e5515a7a3", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // xfail-fast\n+// xfail-test needs networking\n \n extern mod extra;\n "}, {"sha": "42cd4081eda10aeadead5e4c630e78c7fc1c48cf", "filename": "src/test/run-pass/pipe-detect-term.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -13,6 +13,7 @@\n // Make sure that we can detect when one end of the pipe is closed.\n \n // xfail-win32\n+// xfail-test needs sleep\n \n extern mod extra;\n use extra::timer::sleep;"}, {"sha": "a61aad2e55c7a63710e8ec845a8ac1724efcd409", "filename": "src/test/run-pass/pipe-peek.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-peek.rs?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -10,9 +10,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern mod extra;\n-use extra::timer::sleep;\n-use extra::uv;\n use std::pipes;\n \n proto! oneshot ("}, {"sha": "d9e887fcee8bfb8e691b39215564f4f75050bb6f", "filename": "src/test/run-pass/pipe-select.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -12,6 +12,7 @@\n \n // xfail-pretty\n // xfail-win32\n+// xfail-test needs sleep\n \n extern mod extra;\n use extra::timer::sleep;"}, {"sha": "549c733244049888ca1d7ddd8641a62e1b9ae15d", "filename": "src/test/run-pass/pipe-sleep.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs?ref=73921f91a326e51118077ff3fd5c5c6196ff7c3a", "patch": "@@ -10,6 +10,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test needs sleep\n+\n extern mod extra;\n \n use extra::timer::sleep;"}]}