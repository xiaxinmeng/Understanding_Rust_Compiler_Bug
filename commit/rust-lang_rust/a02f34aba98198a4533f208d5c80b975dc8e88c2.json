{"sha": "a02f34aba98198a4533f208d5c80b975dc8e88c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMmYzNGFiYTk4MTk4YTQ1MzNmMjA4ZDVjODBiOTc1ZGM4ZTg4YzI=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-01-02T20:07:56Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-01-02T20:07:56Z"}, "message": "Merge pull request #520 from mcarton/#471\n\nImplement #471", "tree": {"sha": "3f4ef7bc91e70b9f8634da07a7435a3b6124b2b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f4ef7bc91e70b9f8634da07a7435a3b6124b2b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a02f34aba98198a4533f208d5c80b975dc8e88c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a02f34aba98198a4533f208d5c80b975dc8e88c2", "html_url": "https://github.com/rust-lang/rust/commit/a02f34aba98198a4533f208d5c80b975dc8e88c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a02f34aba98198a4533f208d5c80b975dc8e88c2/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e2029287790ca54fa87f9c7fe9da430d481cfaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e2029287790ca54fa87f9c7fe9da430d481cfaf", "html_url": "https://github.com/rust-lang/rust/commit/3e2029287790ca54fa87f9c7fe9da430d481cfaf"}, {"sha": "542685dad19bf6af1cc00224ed3b46ab7ca37a94", "url": "https://api.github.com/repos/rust-lang/rust/commits/542685dad19bf6af1cc00224ed3b46ab7ca37a94", "html_url": "https://github.com/rust-lang/rust/commit/542685dad19bf6af1cc00224ed3b46ab7ca37a94"}], "stats": {"total": 418, "additions": 326, "deletions": 92}, "files": [{"sha": "da51da6f96bebd4dcdea6ddb70651b5acf004c44", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a02f34aba98198a4533f208d5c80b975dc8e88c2/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/a02f34aba98198a4533f208d5c80b975dc8e88c2/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=a02f34aba98198a4533f208d5c80b975dc8e88c2", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 88 lints included in this crate:\n+There are 89 lints included in this crate:\n \n name                                                                                                     | default | meaning\n ---------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -41,6 +41,7 @@ name\n [linkedlist](https://github.com/Manishearth/rust-clippy/wiki#linkedlist)                                 | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a VecDeque\n [map_clone](https://github.com/Manishearth/rust-clippy/wiki#map_clone)                                   | warn    | using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends `.cloned()` instead)\n [match_bool](https://github.com/Manishearth/rust-clippy/wiki#match_bool)                                 | warn    | a match on boolean expression; recommends `if..else` block instead\n+[match_overlapping_arm](https://github.com/Manishearth/rust-clippy/wiki#match_overlapping_arm)           | warn    | a match has overlapping arms\n [match_ref_pats](https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats)                         | warn    | a match or `if let` has all arms prefixed with `&`; the match expression can be dereferenced instead\n [min_max](https://github.com/Manishearth/rust-clippy/wiki#min_max)                                       | warn    | `min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\n [modulo_one](https://github.com/Manishearth/rust-clippy/wiki#modulo_one)                                 | warn    | taking a number modulo 1, which always returns 0"}, {"sha": "c3e6d7828ba368ab98471bdd8277e69b8fa1d763", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a02f34aba98198a4533f208d5c80b975dc8e88c2/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02f34aba98198a4533f208d5c80b975dc8e88c2/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=a02f34aba98198a4533f208d5c80b975dc8e88c2", "patch": "@@ -174,6 +174,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         loops::WHILE_LET_ON_ITERATOR,\n         map_clone::MAP_CLONE,\n         matches::MATCH_BOOL,\n+        matches::MATCH_OVERLAPPING_ARM,\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,\n         methods::FILTER_NEXT,"}, {"sha": "8564c36e617568ce2a2bb7a846a4a3f2cc098173", "filename": "src/matches.rs", "status": "modified", "additions": 270, "deletions": 87, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/a02f34aba98198a4533f208d5c80b975dc8e88c2/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02f34aba98198a4533f208d5c80b975dc8e88c2/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=a02f34aba98198a4533f208d5c80b975dc8e88c2", "patch": "@@ -1,10 +1,14 @@\n use rustc::lint::*;\n-use rustc_front::hir::*;\n+use rustc::middle::const_eval::ConstVal::{Int, Uint};\n+use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n+use rustc::middle::const_eval::{eval_const_expr_partial, ConstVal};\n use rustc::middle::ty;\n+use rustc_front::hir::*;\n+use std::cmp::Ordering;\n use syntax::ast::Lit_::LitBool;\n use syntax::codemap::Span;\n \n-use utils::{snippet, span_lint, span_help_and_lint, in_external_macro, expr_block};\n+use utils::{snippet, span_lint, span_note_and_lint, span_help_and_lint, in_external_macro, expr_block};\n \n /// **What it does:** This lint checks for matches with a single arm where an `if let` will usually suffice. It is `Warn` by default.\n ///\n@@ -22,6 +26,7 @@ use utils::{snippet, span_lint, span_help_and_lint, in_external_macro, expr_bloc\n declare_lint!(pub SINGLE_MATCH, Warn,\n               \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n                is `_ => {}`) is used; recommends `if let` instead\");\n+\n /// **What it does:** This lint checks for matches where all arms match a reference, suggesting to remove the reference and deref the matched expression instead. It also checks for `if let &foo = bar` blocks. It is `Warn` by default.\n ///\n /// **Why is this bad?** It just makes the code less readable. That reference destructuring adds nothing to the code.\n@@ -40,6 +45,7 @@ declare_lint!(pub SINGLE_MATCH, Warn,\n declare_lint!(pub MATCH_REF_PATS, Warn,\n               \"a match or `if let` has all arms prefixed with `&`; the match expression can be \\\n                dereferenced instead\");\n+\n /// **What it does:** This lint checks for matches where match expression is a `bool`. It suggests to replace the expression with an `if...else` block. It is `Warn` by default.\n ///\n /// **Why is this bad?** It makes the code less readable.\n@@ -58,6 +64,25 @@ declare_lint!(pub MATCH_REF_PATS, Warn,\n declare_lint!(pub MATCH_BOOL, Warn,\n               \"a match on boolean expression; recommends `if..else` block instead\");\n \n+/// **What it does:** This lint checks for overlapping match arms. It is `Warn` by default.\n+///\n+/// **Why is this bad?** It is likely to be an error and if not, makes the code less obvious.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+///\n+/// ```\n+/// let x = 5;\n+/// match x {\n+///     1 ... 10 => println!(\"1 ... 10\"),\n+///     5 ... 15 => println!(\"5 ... 15\"),\n+///     _ => (),\n+/// }\n+/// ```\n+declare_lint!(pub MATCH_OVERLAPPING_ARM, Warn,\n+              \"a match has overlapping arms\");\n+\n #[allow(missing_copy_implementations)]\n pub struct MatchPass;\n \n@@ -71,101 +96,205 @@ impl LateLintPass for MatchPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if in_external_macro(cx, expr.span) { return; }\n         if let ExprMatch(ref ex, ref arms, MatchSource::Normal) = expr.node {\n-            // check preconditions for SINGLE_MATCH\n-                // only two arms\n-            if arms.len() == 2 &&\n-                // both of the arms have a single pattern and no guard\n-                arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n-                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n-                // and the second pattern is a `_` wildcard: this is not strictly necessary,\n-                // since the exhaustiveness check will ensure the last one is a catch-all,\n-                // but in some cases, an explicit match is preferred to catch situations\n-                // when an enum is extended, so we don't consider these cases\n-                arms[1].pats[0].node == PatWild &&\n-                // we don't want any content in the second arm (unit or empty block)\n-                is_unit_expr(&arms[1].body) &&\n-                // finally, MATCH_BOOL doesn't apply here\n-                (cx.tcx.expr_ty(ex).sty != ty::TyBool || cx.current_level(MATCH_BOOL) == Allow)\n-            {\n-                span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n-                                   \"you seem to be trying to use match for destructuring a \\\n-                                    single pattern. Consider using `if let`\",\n-                                   &format!(\"try\\nif let {} = {} {}\",\n-                                            snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                            snippet(cx, ex.span, \"..\"),\n-                                            expr_block(cx, &arms[0].body, None, \"..\")));\n-            }\n+            check_single_match(cx, ex, arms, expr);\n+            check_match_bool(cx, ex, arms, expr);\n+            check_overlapping_arms(cx, ex, arms);\n+        }\n+        if let ExprMatch(ref ex, ref arms, source) = expr.node {\n+            check_match_ref_pats(cx, ex, arms, source, expr);\n+        }\n+    }\n+}\n \n-            // check preconditions for MATCH_BOOL\n-            // type of expression == bool\n-            if cx.tcx.expr_ty(ex).sty == ty::TyBool {\n-                if arms.len() == 2 && arms[0].pats.len() == 1 { // no guards\n-                    let exprs = if let PatLit(ref arm_bool) = arms[0].pats[0].node {\n-                        if let ExprLit(ref lit) = arm_bool.node {\n-                            match lit.node {\n-                                LitBool(true) => Some((&*arms[0].body, &*arms[1].body)),\n-                                LitBool(false) => Some((&*arms[1].body, &*arms[0].body)),\n-                                _ => None,\n-                            }\n-                        } else { None }\n-                    } else { None };\n-                    if let Some((ref true_expr, ref false_expr)) = exprs {\n-                        if !is_unit_expr(true_expr) {\n-                            if !is_unit_expr(false_expr) {\n-                                span_help_and_lint(cx, MATCH_BOOL, expr.span,\n-                                    \"you seem to be trying to match on a boolean expression. \\\n-                                   Consider using an if..else block:\",\n-                                   &format!(\"try\\nif {} {} else {}\",\n-                                        snippet(cx, ex.span, \"b\"),\n-                                        expr_block(cx, true_expr, None, \"..\"),\n-                                        expr_block(cx, false_expr, None, \"..\")));\n-                            } else {\n-                                span_help_and_lint(cx, MATCH_BOOL, expr.span,\n-                                    \"you seem to be trying to match on a boolean expression. \\\n-                                   Consider using an if..else block:\",\n-                                   &format!(\"try\\nif {} {}\",\n-                                        snippet(cx, ex.span, \"b\"),\n-                                        expr_block(cx, true_expr, None, \"..\")));\n-                            }\n-                        } else if !is_unit_expr(false_expr) {\n-                            span_help_and_lint(cx, MATCH_BOOL, expr.span,\n-                                \"you seem to be trying to match on a boolean expression. \\\n-                               Consider using an if..else block:\",\n-                               &format!(\"try\\nif !{} {}\",\n-                                    snippet(cx, ex.span, \"b\"),\n-                                    expr_block(cx, false_expr, None, \"..\")));\n-                        } else {\n-                            span_lint(cx, MATCH_BOOL, expr.span,\n-                                   \"you seem to be trying to match on a boolean expression. \\\n-                                   Consider using an if..else block\");\n-                        }\n+fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+    if arms.len() == 2 &&\n+        // both of the arms have a single pattern and no guard\n+        arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+        arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n+        // and the second pattern is a `_` wildcard: this is not strictly necessary,\n+        // since the exhaustiveness check will ensure the last one is a catch-all,\n+        // but in some cases, an explicit match is preferred to catch situations\n+        // when an enum is extended, so we don't consider these cases\n+        arms[1].pats[0].node == PatWild &&\n+        // we don't want any content in the second arm (unit or empty block)\n+        is_unit_expr(&arms[1].body) &&\n+        // finally, MATCH_BOOL doesn't apply here\n+        (cx.tcx.expr_ty(ex).sty != ty::TyBool || cx.current_level(MATCH_BOOL) == Allow)\n+    {\n+        span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n+                           \"you seem to be trying to use match for destructuring a \\\n+                            single pattern. Consider using `if let`\",\n+                           &format!(\"try\\nif let {} = {} {}\",\n+                                    snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                    snippet(cx, ex.span, \"..\"),\n+                                    expr_block(cx, &arms[0].body, None, \"..\")));\n+    }\n+}\n+\n+fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+    // type of expression == bool\n+    if cx.tcx.expr_ty(ex).sty == ty::TyBool {\n+        if arms.len() == 2 && arms[0].pats.len() == 1 { // no guards\n+            let exprs = if let PatLit(ref arm_bool) = arms[0].pats[0].node {\n+                if let ExprLit(ref lit) = arm_bool.node {\n+                    match lit.node {\n+                        LitBool(true) => Some((&*arms[0].body, &*arms[1].body)),\n+                        LitBool(false) => Some((&*arms[1].body, &*arms[0].body)),\n+                        _ => None,\n+                    }\n+                } else { None }\n+            } else { None };\n+            if let Some((ref true_expr, ref false_expr)) = exprs {\n+                if !is_unit_expr(true_expr) {\n+                    if !is_unit_expr(false_expr) {\n+                        span_help_and_lint(cx, MATCH_BOOL, expr.span,\n+                            \"you seem to be trying to match on a boolean expression. \\\n+                           Consider using an if..else block:\",\n+                           &format!(\"try\\nif {} {} else {}\",\n+                                snippet(cx, ex.span, \"b\"),\n+                                expr_block(cx, true_expr, None, \"..\"),\n+                                expr_block(cx, false_expr, None, \"..\")));\n                     } else {\n-                        span_lint(cx, MATCH_BOOL, expr.span,\n+                        span_help_and_lint(cx, MATCH_BOOL, expr.span,\n                             \"you seem to be trying to match on a boolean expression. \\\n-                            Consider using an if..else block\");\n+                           Consider using an if..else block:\",\n+                           &format!(\"try\\nif {} {}\",\n+                                snippet(cx, ex.span, \"b\"),\n+                                expr_block(cx, true_expr, None, \"..\")));\n                     }\n+                } else if !is_unit_expr(false_expr) {\n+                    span_help_and_lint(cx, MATCH_BOOL, expr.span,\n+                        \"you seem to be trying to match on a boolean expression. \\\n+                       Consider using an if..else block:\",\n+                       &format!(\"try\\nif !{} {}\",\n+                            snippet(cx, ex.span, \"b\"),\n+                            expr_block(cx, false_expr, None, \"..\")));\n                 } else {\n                     span_lint(cx, MATCH_BOOL, expr.span,\n-                        \"you seem to be trying to match on a boolean expression. \\\n-                        Consider using an if..else block\");\n+                           \"you seem to be trying to match on a boolean expression. \\\n+                           Consider using an if..else block\");\n                 }\n+            } else {\n+                span_lint(cx, MATCH_BOOL, expr.span,\n+                    \"you seem to be trying to match on a boolean expression. \\\n+                    Consider using an if..else block\");\n             }\n+        } else {\n+            span_lint(cx, MATCH_BOOL, expr.span,\n+                \"you seem to be trying to match on a boolean expression. \\\n+                Consider using an if..else block\");\n         }\n-        if let ExprMatch(ref ex, ref arms, source) = expr.node {\n-            // check preconditions for MATCH_REF_PATS\n-            if has_only_ref_pats(arms) {\n-                if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n-                    let template = match_template(cx, expr.span, source, \"\", inner);\n-                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n-                        \"you don't need to add `&` to both the expression \\\n-                         and the patterns: use `{}`\", template));\n-                } else {\n-                    let template = match_template(cx, expr.span, source, \"*\", ex);\n-                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n-                        \"instead of prefixing all patterns with `&`, you can dereference the \\\n-                         expression: `{}`\", template));\n-                }\n+    }\n+}\n+\n+fn check_overlapping_arms(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n+    if arms.len() >= 2 &&\n+       cx.tcx.expr_ty(ex).is_integral() {\n+        let ranges = all_ranges(cx, arms);\n+        let overlap = match type_ranges(&ranges) {\n+            TypedRanges::IntRanges(ranges) => overlapping(&ranges).map(|(start, end)| (start.span, end.span)),\n+            TypedRanges::UintRanges(ranges) => overlapping(&ranges).map(|(start, end)| (start.span, end.span)),\n+            TypedRanges::None => None,\n+        };\n+\n+        if let Some((start, end)) = overlap {\n+            span_note_and_lint(cx, MATCH_OVERLAPPING_ARM, start,\n+                               \"some ranges overlap\",\n+                               end, \"overlaps with this\");\n+        }\n+    }\n+}\n+\n+fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: MatchSource, expr: &Expr) {\n+    if has_only_ref_pats(arms) {\n+        if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n+            let template = match_template(cx, expr.span, source, \"\", inner);\n+            span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n+                \"you don't need to add `&` to both the expression \\\n+                 and the patterns: use `{}`\", template));\n+        } else {\n+            let template = match_template(cx, expr.span, source, \"*\", ex);\n+            span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n+                \"instead of prefixing all patterns with `&`, you can dereference the \\\n+                 expression: `{}`\", template));\n+        }\n+    }\n+}\n+\n+/// Get all arms that are unbounded PatRange-s.\n+fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n+    arms.iter()\n+        .filter_map(|arm| {\n+            if let Arm { ref pats, guard: None, .. } = *arm {\n+                Some(pats.iter().filter_map(|pat| {\n+                    if_let_chain! {[\n+                        let PatRange(ref lhs, ref rhs) = pat.node,\n+                        let Ok(lhs) = eval_const_expr_partial(cx.tcx, &lhs, ExprTypeChecked, None),\n+                        let Ok(rhs) = eval_const_expr_partial(cx.tcx, &rhs, ExprTypeChecked, None)\n+                    ], {\n+                        return Some(SpannedRange { span: pat.span, node: (lhs, rhs) });\n+                    }}\n+\n+                    if_let_chain! {[\n+                        let PatLit(ref value) = pat.node,\n+                        let Ok(value) = eval_const_expr_partial(cx.tcx, &value, ExprTypeChecked, None)\n+                    ], {\n+                        return Some(SpannedRange { span: pat.span, node: (value.clone(), value) });\n+                    }}\n+\n+                    None\n+                }))\n+            }\n+            else {\n+                None\n             }\n+        })\n+        .flat_map(IntoIterator::into_iter)\n+        .collect()\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct SpannedRange<T> {\n+    pub span: Span,\n+    pub node: (T, T),\n+}\n+\n+#[derive(Debug)]\n+enum TypedRanges {\n+    IntRanges(Vec<SpannedRange<i64>>),\n+    UintRanges(Vec<SpannedRange<u64>>),\n+    None,\n+}\n+\n+/// Get all `Int` ranges or all `Uint` ranges. Mixed types are an error anyway and other types than\n+/// `Uint` and `Int` probably don't make sense.\n+fn type_ranges(ranges: &[SpannedRange<ConstVal>]) -> TypedRanges {\n+    if ranges.is_empty() {\n+        TypedRanges::None\n+    }\n+    else {\n+        match ranges[0].node {\n+            (Int(_), Int(_)) => {\n+                TypedRanges::IntRanges(ranges.iter().filter_map(|range| {\n+                    if let (Int(start), Int(end)) = range.node {\n+                        Some(SpannedRange { span: range.span, node: (start, end) })\n+                    }\n+                    else {\n+                        None\n+                    }\n+                }).collect())\n+            },\n+            (Uint(_), Uint(_)) => {\n+                TypedRanges::UintRanges(ranges.iter().filter_map(|range| {\n+                    if let (Uint(start), Uint(end)) = range.node {\n+                        Some(SpannedRange { span: range.span, node: (start, end) })\n+                    }\n+                    else {\n+                        None\n+                    }\n+                }).collect())\n+            },\n+            _ => TypedRanges::None,\n         }\n     }\n }\n@@ -209,3 +338,57 @@ fn match_template(cx: &LateContext,\n         }\n     }\n }\n+\n+pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n+    where T: Copy + Ord {\n+    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+    enum Kind<'a, T: 'a> {\n+        Start(T, &'a SpannedRange<T>),\n+        End(T, &'a SpannedRange<T>),\n+    }\n+\n+    impl<'a, T: Copy> Kind<'a, T> {\n+        fn range(&self) -> &'a SpannedRange<T> {\n+            match *self {\n+                Kind::Start(_, r) | Kind::End(_, r) => r\n+            }\n+        }\n+\n+        fn value(self) -> T {\n+            match self {\n+                Kind::Start(t, _) | Kind::End(t, _) => t\n+            }\n+        }\n+    }\n+\n+    impl<'a, T: Copy + Ord> PartialOrd for Kind<'a, T> {\n+        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+            Some(self.cmp(other))\n+        }\n+    }\n+\n+    impl<'a, T: Copy + Ord> Ord for Kind<'a, T> {\n+        fn cmp(&self, other: &Self) -> Ordering {\n+            self.value().cmp(&other.value())\n+        }\n+    }\n+\n+    let mut values = Vec::with_capacity(2*ranges.len());\n+\n+    for r in ranges {\n+        values.push(Kind::Start(r.node.0, &r));\n+        values.push(Kind::End(r.node.1, &r));\n+    }\n+\n+    values.sort();\n+\n+    for (a, b) in values.iter().zip(values.iter().skip(1)) {\n+        match (a, b) {\n+            (&Kind::Start(_, ra), &Kind::End(_, rb)) => if ra.node != rb.node { return Some((ra, rb)) },\n+            (&Kind::End(a, _), &Kind::Start(b, _)) if a != b => (),\n+            _ => return Some((&a.range(), &b.range())),\n+        }\n+    }\n+\n+    None\n+}"}, {"sha": "b569f9566efdb1aa47fff1974a96f26940ed9e53", "filename": "tests/compile-fail/matches.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a02f34aba98198a4533f208d5c80b975dc8e88c2/tests%2Fcompile-fail%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02f34aba98198a4533f208d5c80b975dc8e88c2/tests%2Fcompile-fail%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatches.rs?ref=a02f34aba98198a4533f208d5c80b975dc8e88c2", "patch": "@@ -51,17 +51,17 @@ fn match_bool() {\n         true => 1,\n         false => 0,\n     };\n-    \n+\n     match test { //~ ERROR you seem to be trying to match on a boolean expression\n         true => (),\n         false => { println!(\"Noooo!\"); }\n     };\n-    \n+\n     match test { //~ ERROR you seem to be trying to match on a boolean expression\n         false => { println!(\"Noooo!\"); }\n         _ => (),\n     };\n-    \n+\n     match test { //~ ERROR you seem to be trying to match on a boolean expression\n         false => { println!(\"Noooo!\"); }\n         true => { println!(\"Yes!\"); }\n@@ -70,7 +70,7 @@ fn match_bool() {\n     // Not linted\n     match option {\n         1 ... 10 => (),\n-        10 ... 20 => (),\n+        11 ... 20 => (),\n         _ => (),\n     };\n }\n@@ -115,5 +115,34 @@ fn ref_pats() {\n     }\n }\n \n+fn overlapping() {\n+    const FOO : u64 = 2;\n+\n+    match 42 {\n+        0 ... 10 => println!(\"0 ... 10\"), //~ERROR: some ranges overlap\n+        0 ... 11 => println!(\"0 ... 10\"),\n+        _ => (),\n+    }\n+\n+    match 42 {\n+        0 ... 5 => println!(\"0 ... 5\"), //~ERROR: some ranges overlap\n+        6 ... 7 => println!(\"6 ... 7\"),\n+        FOO ... 11 => println!(\"0 ... 10\"),\n+        _ => (),\n+    }\n+\n+    match 42 {\n+        2 => println!(\"2\"),\n+        0 ... 5 => println!(\"0 ... 5\"), //~ERROR: some ranges overlap\n+        _ => (),\n+    }\n+\n+    match 42 {\n+        0 ... 10 => println!(\"0 ... 10\"),\n+        11 ... 50 => println!(\"0 ... 10\"),\n+        _ => (),\n+    }\n+}\n+\n fn main() {\n }"}, {"sha": "03cc52817417eabc6610de6636ee7f5334f26e57", "filename": "tests/matches.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a02f34aba98198a4533f208d5c80b975dc8e88c2/tests%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02f34aba98198a4533f208d5c80b975dc8e88c2/tests%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmatches.rs?ref=a02f34aba98198a4533f208d5c80b975dc8e88c2", "patch": "@@ -0,0 +1,20 @@\n+#![allow(plugin_as_library)]\n+#![feature(rustc_private)]\n+\n+extern crate clippy;\n+extern crate syntax;\n+\n+#[test]\n+fn test_overlapping() {\n+    use clippy::matches::overlapping;\n+    use syntax::codemap::DUMMY_SP;\n+\n+    let sp = |s, e| clippy::matches::SpannedRange { span: DUMMY_SP, node: (s, e) };\n+\n+    assert_eq!(None, overlapping::<u8>(&[]));\n+    assert_eq!(None, overlapping(&[sp(1, 4)]));\n+    assert_eq!(None, overlapping(&[sp(1, 4), sp(5, 6)]));\n+    assert_eq!(None, overlapping(&[sp(1, 4), sp(5, 6), sp(10, 11)]));\n+    assert_eq!(Some((&sp(1, 4), &sp(3, 6))), overlapping(&[sp(1, 4), sp(3, 6)]));\n+    assert_eq!(Some((&sp(5, 6), &sp(6, 11))), overlapping(&[sp(1, 4), sp(5, 6), sp(6, 11)]));\n+}"}]}