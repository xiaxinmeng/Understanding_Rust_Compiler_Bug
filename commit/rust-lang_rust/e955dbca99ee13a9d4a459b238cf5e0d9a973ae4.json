{"sha": "e955dbca99ee13a9d4a459b238cf5e0d9a973ae4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5NTVkYmNhOTllZTEzYTlkNGE0NTliMjM4Y2Y1ZTBkOWE5NzNhZTQ=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-05-17T03:19:08Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-11-29T14:56:45Z"}, "message": "Use raw_entry for more efficient interning", "tree": {"sha": "b279be6285cde992114a5f509635d2940325e774", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b279be6285cde992114a5f509635d2940325e774"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e955dbca99ee13a9d4a459b238cf5e0d9a973ae4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e955dbca99ee13a9d4a459b238cf5e0d9a973ae4", "html_url": "https://github.com/rust-lang/rust/commit/e955dbca99ee13a9d4a459b238cf5e0d9a973ae4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e955dbca99ee13a9d4a459b238cf5e0d9a973ae4/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "147e60c5f89cfa2d3ffc247413956a37582c98e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/147e60c5f89cfa2d3ffc247413956a37582c98e7", "html_url": "https://github.com/rust-lang/rust/commit/147e60c5f89cfa2d3ffc247413956a37582c98e7"}], "stats": {"total": 255, "additions": 144, "deletions": 111}, "files": [{"sha": "4034abb468f591f0378887d9fe5c8aaf7756f3fb", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 74, "deletions": 111, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/e955dbca99ee13a9d4a459b238cf5e0d9a973ae4/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e955dbca99ee13a9d4a459b238cf5e0d9a973ae4/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e955dbca99ee13a9d4a459b238cf5e0d9a973ae4", "patch": "@@ -53,6 +53,7 @@ use ty::CanonicalTy;\n use ty::CanonicalPolyFnSig;\n use util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n+use rustc_data_structures::interner::HashInterner;\n use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n                                            StableHasher, StableHasherResult,\n@@ -113,7 +114,7 @@ pub struct GlobalArenas<'tcx> {\n     const_allocs: TypedArena<interpret::Allocation>,\n }\n \n-type InternedSet<'tcx, T> = Lock<FxHashSet<Interned<'tcx, T>>>;\n+type InternedSet<'tcx, T> = Lock<FxHashMap<Interned<'tcx, T>, ()>>;\n \n pub struct CtxtInterners<'tcx> {\n     /// The arena that types, regions, etc are allocated from\n@@ -166,51 +167,39 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n         // determine that all contents are in the global tcx.\n         // See comments on Lift for why we can't use that.\n         if flags.flags.intersects(ty::TypeFlags::KEEP_IN_LOCAL_TCX) {\n-            let mut interner = local.type_.borrow_mut();\n-            if let Some(&Interned(ty)) = interner.get(&st) {\n-                return ty;\n-            }\n-\n-            let ty_struct = TyS {\n-                sty: st,\n-                flags: flags.flags,\n-                outer_exclusive_binder: flags.outer_exclusive_binder,\n-            };\n+            local.type_.borrow_mut().intern(st, |st| {\n+                let ty_struct = TyS {\n+                    sty: st,\n+                    flags: flags.flags,\n+                    outer_exclusive_binder: flags.outer_exclusive_binder,\n+                };\n \n-            // Make sure we don't end up with inference\n-            // types/regions in the global interner\n-            if local as *const _ as usize == global as *const _ as usize {\n-                bug!(\"Attempted to intern `{:?}` which contains \\\n-                      inference types/regions in the global type context\",\n-                     &ty_struct);\n-            }\n+                // Make sure we don't end up with inference\n+                // types/regions in the global interner\n+                if local as *const _ as usize == global as *const _ as usize {\n+                    bug!(\"Attempted to intern `{:?}` which contains \\\n+                        inference types/regions in the global type context\",\n+                        &ty_struct);\n+                }\n \n-            // Don't be &mut TyS.\n-            let ty: Ty<'tcx> = local.arena.alloc(ty_struct);\n-            interner.insert(Interned(ty));\n-            ty\n+                Interned(local.arena.alloc(ty_struct))\n+            }).0\n         } else {\n-            let mut interner = global.type_.borrow_mut();\n-            if let Some(&Interned(ty)) = interner.get(&st) {\n-                return ty;\n-            }\n-\n-            let ty_struct = TyS {\n-                sty: st,\n-                flags: flags.flags,\n-                outer_exclusive_binder: flags.outer_exclusive_binder,\n-            };\n+            global.type_.borrow_mut().intern(st, |st| {\n+                let ty_struct = TyS {\n+                    sty: st,\n+                    flags: flags.flags,\n+                    outer_exclusive_binder: flags.outer_exclusive_binder,\n+                };\n \n-            // This is safe because all the types the ty_struct can point to\n-            // already is in the global arena\n-            let ty_struct: TyS<'gcx> = unsafe {\n-                mem::transmute(ty_struct)\n-            };\n+                // This is safe because all the types the ty_struct can point to\n+                // already is in the global arena\n+                let ty_struct: TyS<'gcx> = unsafe {\n+                    mem::transmute(ty_struct)\n+                };\n \n-            // Don't be &mut TyS.\n-            let ty: Ty<'gcx> = global.arena.alloc(ty_struct);\n-            interner.insert(Interned(ty));\n-            ty\n+                Interned(global.arena.alloc(ty_struct))\n+            }).0\n         }\n     }\n }\n@@ -825,12 +814,9 @@ impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n         let mk = |sty| CtxtInterners::intern_ty(interners, interners, sty);\n         let mk_region = |r| {\n-            if let Some(r) = interners.region.borrow().get(&r) {\n-                return r.0;\n-            }\n-            let r = interners.arena.alloc(r);\n-            interners.region.borrow_mut().insert(Interned(r));\n-            &*r\n+            interners.region.borrow_mut().intern(r, |r| {\n+                Interned(interners.arena.alloc(r))\n+            }).0\n         };\n         CommonTypes {\n             bool: mk(Bool),\n@@ -950,14 +936,14 @@ pub struct GlobalCtxt<'tcx> {\n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n \n-    stability_interner: Lock<FxHashSet<&'tcx attr::Stability>>,\n+    stability_interner: Lock<FxHashMap<&'tcx attr::Stability, ()>>,\n \n     /// Stores the value of constants (and deduplicates the actual memory)\n-    allocation_interner: Lock<FxHashSet<&'tcx Allocation>>,\n+    allocation_interner: Lock<FxHashMap<&'tcx Allocation, ()>>,\n \n     pub alloc_map: Lock<interpret::AllocMap<'tcx, &'tcx Allocation>>,\n \n-    layout_interner: Lock<FxHashSet<&'tcx LayoutDetails>>,\n+    layout_interner: Lock<FxHashMap<&'tcx LayoutDetails, ()>>,\n \n     /// A general purpose channel to throw data out the back towards LLVM worker\n     /// threads.\n@@ -1040,16 +1026,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self,\n         alloc: Allocation,\n     ) -> &'gcx Allocation {\n-        let allocs = &mut self.allocation_interner.borrow_mut();\n-        if let Some(alloc) = allocs.get(&alloc) {\n-            return alloc;\n-        }\n-\n-        let interned = self.global_arenas.const_allocs.alloc(alloc);\n-        if let Some(prev) = allocs.replace(interned) { // insert into interner\n-            bug!(\"Tried to overwrite interned Allocation: {:#?}\", prev)\n-        }\n-        interned\n+        self.allocation_interner.borrow_mut().intern(alloc, |alloc| {\n+            self.global_arenas.const_allocs.alloc(alloc)\n+        })\n     }\n \n     /// Allocates a byte or string literal for `mir::interpret`, read-only\n@@ -1061,29 +1040,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n-        let mut stability_interner = self.stability_interner.borrow_mut();\n-        if let Some(st) = stability_interner.get(&stab) {\n-            return st;\n-        }\n-\n-        let interned = self.global_interners.arena.alloc(stab);\n-        if let Some(prev) = stability_interner.replace(interned) {\n-            bug!(\"Tried to overwrite interned Stability: {:?}\", prev)\n-        }\n-        interned\n+        self.stability_interner.borrow_mut().intern(stab, |stab| {\n+            self.global_interners.arena.alloc(stab)\n+        })\n     }\n \n     pub fn intern_layout(self, layout: LayoutDetails) -> &'gcx LayoutDetails {\n-        let mut layout_interner = self.layout_interner.borrow_mut();\n-        if let Some(layout) = layout_interner.get(&layout) {\n-            return layout;\n-        }\n-\n-        let interned = self.global_arenas.layout.alloc(layout);\n-        if let Some(prev) = layout_interner.replace(interned) {\n-            bug!(\"Tried to overwrite interned Layout: {:?}\", prev)\n-        }\n-        interned\n+        self.layout_interner.borrow_mut().intern(layout, |layout| {\n+            self.global_arenas.layout.alloc(layout)\n+        })\n     }\n \n     /// Returns a range of the start/end indices specified with the\n@@ -2193,7 +2158,7 @@ macro_rules! sty_debug_print {\n                 };\n                 $(let mut $variant = total;)*\n \n-                for &Interned(t) in tcx.interners.type_.borrow().iter() {\n+                for &Interned(t) in tcx.interners.type_.borrow().keys() {\n                     let variant = match t.sty {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n                             ty::Float(..) | ty::Str | ty::Never => continue,\n@@ -2252,6 +2217,13 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n /// An entry in an interner.\n struct Interned<'tcx, T: 'tcx+?Sized>(&'tcx T);\n \n+impl<'tcx, T: 'tcx+?Sized> Clone for Interned<'tcx, T> {\n+    fn clone(&self) -> Self {\n+        Interned(self.0)\n+    }\n+}\n+impl<'tcx, T: 'tcx+?Sized> Copy for Interned<'tcx, T> {}\n+\n // NB: An Interned<Ty> compares and hashes as a sty.\n impl<'tcx> PartialEq for Interned<'tcx, TyS<'tcx>> {\n     fn eq(&self, other: &Interned<'tcx, TyS<'tcx>>) -> bool {\n@@ -2372,37 +2344,28 @@ macro_rules! intern_method {\n                 // determine that all contents are in the global tcx.\n                 // See comments on Lift for why we can't use that.\n                 if ($keep_in_local_tcx)(&v) {\n-                    let mut interner = self.interners.$name.borrow_mut();\n-                    if let Some(&Interned(v)) = interner.get(key) {\n-                        return v;\n-                    }\n-\n-                    // Make sure we don't end up with inference\n-                    // types/regions in the global tcx.\n-                    if self.is_global() {\n-                        bug!(\"Attempted to intern `{:?}` which contains \\\n-                              inference types/regions in the global type context\",\n-                             v);\n-                    }\n-\n-                    let i = $alloc_method(&self.interners.arena, v);\n-                    interner.insert(Interned(i));\n-                    i\n+                    self.interners.$name.borrow_mut().intern_ref(key, || {\n+                        // Make sure we don't end up with inference\n+                        // types/regions in the global tcx.\n+                        if self.is_global() {\n+                            bug!(\"Attempted to intern `{:?}` which contains \\\n+                                inference types/regions in the global type context\",\n+                                v);\n+                        }\n+\n+                        Interned($alloc_method(&self.interners.arena, v))\n+                    }).0\n                 } else {\n-                    let mut interner = self.global_interners.$name.borrow_mut();\n-                    if let Some(&Interned(v)) = interner.get(key) {\n-                        return v;\n-                    }\n-\n-                    // This transmutes $alloc<'tcx> to $alloc<'gcx>\n-                    let v = unsafe {\n-                        mem::transmute(v)\n-                    };\n-                    let i: &$lt_tcx $ty = $alloc_method(&self.global_interners.arena, v);\n-                    // Cast to 'gcx\n-                    let i = unsafe { mem::transmute(i) };\n-                    interner.insert(Interned(i));\n-                    i\n+                    self.global_interners.$name.borrow_mut().intern_ref(key, || {\n+                        // This transmutes $alloc<'tcx> to $alloc<'gcx>\n+                        let v = unsafe {\n+                            mem::transmute(v)\n+                        };\n+                        let i: &$lt_tcx $ty = $alloc_method(&self.global_interners.arena, v);\n+                        // Cast to 'gcx\n+                        let i = unsafe { mem::transmute(i) };\n+                        Interned(i)\n+                    }).0\n                 }\n             }\n         }"}, {"sha": "29e5aefee7f0bbbf35a81dd982d34aa710d6c001", "filename": "src/librustc_data_structures/interner.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e955dbca99ee13a9d4a459b238cf5e0d9a973ae4/src%2Flibrustc_data_structures%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e955dbca99ee13a9d4a459b238cf5e0d9a973ae4/src%2Flibrustc_data_structures%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Finterner.rs?ref=e955dbca99ee13a9d4a459b238cf5e0d9a973ae4", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::hash::Hash;\n+use std::hash::BuildHasher;\n+use std::hash::Hasher;\n+use std::collections::HashMap;\n+use std::collections::hash_map::RawEntryMut;\n+use std::borrow::Borrow;\n+\n+pub trait HashInterner<K: Eq + Hash> {\n+    fn intern_ref<Q: ?Sized, F: FnOnce() -> K>(&mut self, value: &Q, make: F) -> K\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq;\n+\n+    fn intern<Q, F: FnOnce(Q) -> K>(&mut self, value: Q, make: F) -> K\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq;\n+}\n+\n+impl<K: Eq + Hash + Copy, S: BuildHasher> HashInterner<K> for HashMap<K, (), S> {\n+    #[inline]\n+    fn intern_ref<Q: ?Sized, F: FnOnce() -> K>(&mut self, value: &Q, make: F) -> K\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n+    {\n+        let mut hasher = self.hasher().build_hasher();\n+        value.hash(&mut hasher);\n+        let hash = hasher.finish();\n+        let entry = self.raw_entry_mut().from_key_hashed_nocheck(hash, value);\n+\n+        match entry {\n+            RawEntryMut::Occupied(e) => *e.key(),\n+            RawEntryMut::Vacant(e) => {\n+                let v = make();\n+                e.insert_hashed_nocheck(hash, v, ());\n+                v\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn intern<Q, F: FnOnce(Q) -> K>(&mut self, value: Q, make: F) -> K\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n+    {\n+        let mut hasher = self.hasher().build_hasher();\n+        value.hash(&mut hasher);\n+        let hash = hasher.finish();\n+        let entry = self.raw_entry_mut().from_key_hashed_nocheck(hash, &value);\n+\n+        match entry {\n+            RawEntryMut::Occupied(e) => *e.key(),\n+            RawEntryMut::Vacant(e) => {\n+                let v = make(value);\n+                e.insert_hashed_nocheck(hash, v, ());\n+                v\n+            }\n+        }\n+    }\n+}"}, {"sha": "96cb235a933627c4d593400696b0cfa317439b62", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e955dbca99ee13a9d4a459b238cf5e0d9a973ae4/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e955dbca99ee13a9d4a459b238cf5e0d9a973ae4/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=e955dbca99ee13a9d4a459b238cf5e0d9a973ae4", "patch": "@@ -29,6 +29,7 @@\n #![feature(nll)]\n #![feature(allow_internal_unstable)]\n #![feature(vec_resize_with)]\n+#![feature(hash_raw_entry)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]\n@@ -66,6 +67,7 @@ pub mod flock;\n pub mod fx;\n pub mod graph;\n pub mod indexed_vec;\n+pub mod interner;\n pub mod obligation_forest;\n pub mod owning_ref;\n pub mod ptr_key;"}]}